// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package datasource_device_ap_stats

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/datasource/schema"
)

func DeviceApStatsDataSourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"device_ap_stats": schema.SetNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"auto_placement": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"info": schema.SingleNestedAttribute{
									Attributes: map[string]schema.Attribute{
										"cluster_number": schema.Int64Attribute{
											Computed:            true,
											Description:         "All APs sharing a given cluster number can be placed relative to each other",
											MarkdownDescription: "All APs sharing a given cluster number can be placed relative to each other",
										},
										"orientation_stats": schema.Int64Attribute{
											Computed:            true,
											Description:         "The orientation of an AP",
											MarkdownDescription: "The orientation of an AP",
										},
										"probability_surface": schema.SingleNestedAttribute{
											Attributes: map[string]schema.Attribute{
												"radius": schema.NumberAttribute{
													Computed:            true,
													Description:         "The radius representing placement uncertainty, measured in pixels",
													MarkdownDescription: "The radius representing placement uncertainty, measured in pixels",
												},
												"radius_m": schema.NumberAttribute{
													Computed:            true,
													Description:         "The radius representing placement uncertainty, measured in meters",
													MarkdownDescription: "The radius representing placement uncertainty, measured in meters",
												},
												"x": schema.Float64Attribute{
													Computed:            true,
													Description:         "Y-coordinate of the potential placement’s center, measured in pixels",
													MarkdownDescription: "Y-coordinate of the potential placement’s center, measured in pixels",
												},
											},
											CustomType: ProbabilitySurfaceType{
												ObjectType: types.ObjectType{
													AttrTypes: ProbabilitySurfaceValue{}.AttributeTypes(ctx),
												},
											},
											Computed:            true,
											Description:         "Coordinates representing a circle where the AP is most likely exists in the event of an inaccurate placement result",
											MarkdownDescription: "Coordinates representing a circle where the AP is most likely exists in the event of an inaccurate placement result",
										},
									},
									CustomType: InfoType{
										ObjectType: types.ObjectType{
											AttrTypes: InfoValue{}.AttributeTypes(ctx),
										},
									},
									Computed:            true,
									Description:         "Additional information about auto placements AP data",
									MarkdownDescription: "Additional information about auto placements AP data",
								},
								"recommended_anchor": schema.BoolAttribute{
									Computed:            true,
									Description:         "Flag to represent if AP is recommended as an anchor by auto placement service",
									MarkdownDescription: "Flag to represent if AP is recommended as an anchor by auto placement service",
								},
								"status": schema.StringAttribute{
									Computed:            true,
									Description:         "Basic Placement Status",
									MarkdownDescription: "Basic Placement Status",
								},
								"status_detail": schema.StringAttribute{
									Computed:            true,
									Description:         "Additional info about placement status",
									MarkdownDescription: "Additional info about placement status",
								},
								"use_auto_placement": schema.BoolAttribute{
									Computed:            true,
									Description:         "Flag to represent if auto_placement values are currently utilized",
									MarkdownDescription: "Flag to represent if auto_placement values are currently utilized",
								},
								"x": schema.Float64Attribute{
									Computed:            true,
									Description:         "X Autoplaced Position in pixels",
									MarkdownDescription: "X Autoplaced Position in pixels",
								},
								"x_m": schema.Float64Attribute{
									Computed:            true,
									Description:         "X Autoplaced Position in meters",
									MarkdownDescription: "X Autoplaced Position in meters",
								},
								"y": schema.Float64Attribute{
									Computed:            true,
									Description:         "Y Autoplaced Position in pixels",
									MarkdownDescription: "Y Autoplaced Position in pixels",
								},
								"y_m": schema.Float64Attribute{
									Computed:            true,
									Description:         "X Autoplaced Position in meters",
									MarkdownDescription: "X Autoplaced Position in meters",
								},
							},
							CustomType: AutoPlacementType{
								ObjectType: types.ObjectType{
									AttrTypes: AutoPlacementValue{}.AttributeTypes(ctx),
								},
							},
							Computed: true,
						},
						"auto_upgrade_stat": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"lastcheck": schema.Int64Attribute{
									Computed: true,
								},
							},
							CustomType: AutoUpgradeStatType{
								ObjectType: types.ObjectType{
									AttrTypes: AutoUpgradeStatValue{}.AttributeTypes(ctx),
								},
							},
							Computed: true,
						},
						"ble_stat": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"beacon_enabled": schema.BoolAttribute{
									Computed: true,
								},
								"beacon_rate": schema.Int64Attribute{
									Computed: true,
								},
								"eddystone_uid_enabled": schema.BoolAttribute{
									Computed: true,
								},
								"eddystone_uid_freq_msec": schema.Int64Attribute{
									Computed: true,
								},
								"eddystone_uid_instance": schema.StringAttribute{
									Computed: true,
								},
								"eddystone_uid_namespace": schema.StringAttribute{
									Computed: true,
								},
								"eddystone_url_enabled": schema.BoolAttribute{
									Computed: true,
								},
								"eddystone_url_freq_msec": schema.Int64Attribute{
									Computed:            true,
									Description:         "Frequency (msec) of data emmit by Eddystone-UID beacon",
									MarkdownDescription: "Frequency (msec) of data emmit by Eddystone-UID beacon",
								},
								"eddystone_url_url": schema.StringAttribute{
									Computed: true,
								},
								"ibeacon_enabled": schema.BoolAttribute{
									Computed: true,
								},
								"ibeacon_freq_msec": schema.Int64Attribute{
									Computed: true,
								},
								"ibeacon_major": schema.Int64Attribute{
									Computed: true,
								},
								"ibeacon_minor": schema.Int64Attribute{
									Computed: true,
								},
								"ibeacon_uuid": schema.StringAttribute{
									Computed: true,
								},
								"major": schema.Int64Attribute{
									Computed: true,
								},
								"minors": schema.ListAttribute{
									ElementType: types.Int64Type,
									Computed:    true,
								},
								"power": schema.Int64Attribute{
									Computed: true,
								},
								"rx_bytes": schema.Int64Attribute{
									Computed: true,
								},
								"rx_pkts": schema.Int64Attribute{
									Computed: true,
								},
								"tx_bytes": schema.Int64Attribute{
									Computed: true,
								},
								"tx_pkts": schema.Int64Attribute{
									Computed: true,
								},
								"tx_resets": schema.Int64Attribute{
									Computed:            true,
									Description:         "resets due to tx hung",
									MarkdownDescription: "resets due to tx hung",
								},
								"uuid": schema.StringAttribute{
									Computed: true,
								},
							},
							CustomType: BleStatType{
								ObjectType: types.ObjectType{
									AttrTypes: BleStatValue{}.AttributeTypes(ctx),
								},
							},
							Computed: true,
						},
						"cert_expiry": schema.NumberAttribute{
							Computed: true,
						},
						"config_reverted": schema.BoolAttribute{
							Computed: true,
						},
						"cpu_system": schema.Int64Attribute{
							Computed: true,
						},
						"cpu_util": schema.Int64Attribute{
							Computed: true,
						},
						"created_time": schema.Int64Attribute{
							Computed: true,
						},
						"deviceprofile_id": schema.StringAttribute{
							Computed: true,
						},
						"env_stat": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"accel_x": schema.Float64Attribute{
									Computed: true,
								},
								"accel_y": schema.Float64Attribute{
									Computed: true,
								},
								"accel_z": schema.Float64Attribute{
									Computed: true,
								},
								"ambient_temp": schema.Int64Attribute{
									Computed: true,
								},
								"attitude": schema.Int64Attribute{
									Computed: true,
								},
								"cpu_temp": schema.Int64Attribute{
									Computed: true,
								},
								"humidity": schema.Int64Attribute{
									Computed: true,
								},
								"magne_x": schema.Float64Attribute{
									Computed: true,
								},
								"magne_y": schema.Float64Attribute{
									Computed: true,
								},
								"magne_z": schema.Float64Attribute{
									Computed: true,
								},
								"pressure": schema.Float64Attribute{
									Computed: true,
								},
								"vcore_voltage": schema.Int64Attribute{
									Computed: true,
								},
							},
							CustomType: EnvStatType{
								ObjectType: types.ObjectType{
									AttrTypes: EnvStatValue{}.AttributeTypes(ctx),
								},
							},
							Computed:            true,
							Description:         "device environment, including CPU temperature, Ambient temperature, Humidity, Attitude, Pressure, Accelerometers, Magnetometers and vCore Voltage",
							MarkdownDescription: "device environment, including CPU temperature, Ambient temperature, Humidity, Attitude, Pressure, Accelerometers, Magnetometers and vCore Voltage",
						},
						"esl_stat": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"channel": schema.Int64Attribute{
									Computed: true,
								},
								"connected": schema.BoolAttribute{
									Computed: true,
								},
								"type": schema.StringAttribute{
									Computed: true,
								},
								"up": schema.BoolAttribute{
									Computed: true,
								},
							},
							CustomType: EslStatType{
								ObjectType: types.ObjectType{
									AttrTypes: EslStatValue{}.AttributeTypes(ctx),
								},
							},
							Computed: true,
						},
						"ext_ip": schema.StringAttribute{
							Computed: true,
						},
						"fwupdate": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"progress": schema.Int64Attribute{
									Computed: true,
								},
								"status": schema.StringAttribute{
									Computed: true,
								},
								"status_id": schema.Int64Attribute{
									Computed: true,
								},
								"timestamp": schema.Float64Attribute{
									Computed: true,
								},
								"will_retry": schema.BoolAttribute{
									Computed: true,
								},
							},
							CustomType: FwupdateType{
								ObjectType: types.ObjectType{
									AttrTypes: FwupdateValue{}.AttributeTypes(ctx),
								},
							},
							Computed: true,
						},
						"hw_rev": schema.StringAttribute{
							Computed: true,
						},
						"id": schema.StringAttribute{
							Computed: true,
						},
						"inactive_wired_vlans": schema.ListAttribute{
							ElementType: types.Int64Type,
							Computed:    true,
						},
						"iot_stat": schema.MapNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"value": schema.Int64Attribute{
										Computed: true,
									},
								},
								CustomType: IotStatType{
									ObjectType: types.ObjectType{
										AttrTypes: IotStatValue{}.AttributeTypes(ctx),
									},
								},
							},
							Computed: true,
						},
						"ip": schema.StringAttribute{
							Computed: true,
						},
						"ip_config": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"dns": schema.ListAttribute{
									ElementType:         types.StringType,
									Computed:            true,
									Description:         "if `type`==`static`",
									MarkdownDescription: "if `type`==`static`",
								},
								"dns_suffix": schema.ListAttribute{
									ElementType:         types.StringType,
									Computed:            true,
									Description:         "required if `type`==`static`",
									MarkdownDescription: "required if `type`==`static`",
								},
								"gateway": schema.StringAttribute{
									Computed:            true,
									Description:         "required if `type`==`static`",
									MarkdownDescription: "required if `type`==`static`",
								},
								"gateway6": schema.StringAttribute{
									Computed: true,
								},
								"ip": schema.StringAttribute{
									Computed:            true,
									Description:         "required if `type`==`static`",
									MarkdownDescription: "required if `type`==`static`",
								},
								"ip6": schema.StringAttribute{
									Computed: true,
								},
								"mtu": schema.Int64Attribute{
									Computed: true,
								},
								"netmask": schema.StringAttribute{
									Computed:            true,
									Description:         "required if `type`==`static`",
									MarkdownDescription: "required if `type`==`static`",
								},
								"netmask6": schema.StringAttribute{
									Computed: true,
								},
								"type": schema.StringAttribute{
									Computed: true,
								},
								"type6": schema.StringAttribute{
									Computed: true,
								},
								"vlan_id": schema.Int64Attribute{
									Computed:            true,
									Description:         "management vlan id, default is 1 (untagged)",
									MarkdownDescription: "management vlan id, default is 1 (untagged)",
								},
							},
							CustomType: IpConfigType{
								ObjectType: types.ObjectType{
									AttrTypes: IpConfigValue{}.AttributeTypes(ctx),
								},
							},
							Computed:            true,
							Description:         "IP AP settings",
							MarkdownDescription: "IP AP settings",
						},
						"ip_stat": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"dhcp_server": schema.StringAttribute{
									Computed: true,
								},
								"dns": schema.ListAttribute{
									ElementType: types.StringType,
									Computed:    true,
								},
								"dns_suffix": schema.ListAttribute{
									ElementType: types.StringType,
									Computed:    true,
								},
								"gateway": schema.StringAttribute{
									Computed: true,
								},
								"gateway6": schema.StringAttribute{
									Computed: true,
								},
								"ip": schema.StringAttribute{
									Computed: true,
								},
								"ip6": schema.StringAttribute{
									Computed: true,
								},
								"ips": schema.MapAttribute{
									ElementType: types.StringType,
									Computed:    true,
								},
								"netmask": schema.StringAttribute{
									Computed: true,
								},
								"netmask6": schema.StringAttribute{
									Computed: true,
								},
							},
							CustomType: IpStatType{
								ObjectType: types.ObjectType{
									AttrTypes: IpStatValue{}.AttributeTypes(ctx),
								},
							},
							Computed: true,
						},
						"l2tp_stat": schema.MapNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"sessions": schema.ListNestedAttribute{
										NestedObject: schema.NestedAttributeObject{
											Attributes: map[string]schema.Attribute{
												"local_sid": schema.Int64Attribute{
													Computed:            true,
													Description:         "remote sessions id (dynamically unless Tunnel is said to be static)",
													MarkdownDescription: "remote sessions id (dynamically unless Tunnel is said to be static)",
												},
												"remote_id": schema.StringAttribute{
													Computed:            true,
													Description:         "WxlanTunnel Remote ID (user-configured)",
													MarkdownDescription: "WxlanTunnel Remote ID (user-configured)",
												},
												"remote_sid": schema.Int64Attribute{
													Computed:            true,
													Description:         "remote sessions id (dynamically unless Tunnel is said to be static)",
													MarkdownDescription: "remote sessions id (dynamically unless Tunnel is said to be static)",
												},
												"state": schema.StringAttribute{
													Computed: true,
												},
											},
											CustomType: SessionsType{
												ObjectType: types.ObjectType{
													AttrTypes: SessionsValue{}.AttributeTypes(ctx),
												},
											},
										},
										Computed:            true,
										Description:         "list of sessions",
										MarkdownDescription: "list of sessions",
									},
									"state": schema.StringAttribute{
										Computed: true,
									},
									"uptime": schema.Int64Attribute{
										Computed:            true,
										Description:         "uptime",
										MarkdownDescription: "uptime",
									},
									"wxtunnel_id": schema.StringAttribute{
										Computed:            true,
										Description:         "WxlanTunnel ID",
										MarkdownDescription: "WxlanTunnel ID",
									},
								},
								CustomType: L2tpStatType{
									ObjectType: types.ObjectType{
										AttrTypes: L2tpStatValue{}.AttributeTypes(ctx),
									},
								},
							},
							Computed:            true,
							Description:         "l2tp tunnel status (key is the wxtunnel_id)",
							MarkdownDescription: "l2tp tunnel status (key is the wxtunnel_id)",
						},
						"last_seen": schema.NumberAttribute{
							Computed:            true,
							Description:         "last seen timestamp",
							MarkdownDescription: "last seen timestamp",
						},
						"last_trouble": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"code": schema.StringAttribute{
									Computed:            true,
									Description:         "Code definitions list at /api/v1/consts/ap_led_status",
									MarkdownDescription: "Code definitions list at /api/v1/consts/ap_led_status",
								},
								"timestamp": schema.Int64Attribute{
									Computed: true,
								},
							},
							CustomType: LastTroubleType{
								ObjectType: types.ObjectType{
									AttrTypes: LastTroubleValue{}.AttributeTypes(ctx),
								},
							},
							Computed:            true,
							Description:         "last trouble code of switch",
							MarkdownDescription: "last trouble code of switch",
						},
						"led": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"brightness": schema.Int64Attribute{
									Computed: true,
								},
								"enabled": schema.BoolAttribute{
									Computed: true,
								},
							},
							CustomType: LedType{
								ObjectType: types.ObjectType{
									AttrTypes: LedValue{}.AttributeTypes(ctx),
								},
							},
							Computed:            true,
							Description:         "LED AP settings",
							MarkdownDescription: "LED AP settings",
						},
						"lldp_stat": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"chassis_id": schema.StringAttribute{
									Computed: true,
								},
								"lldp_med_supported": schema.BoolAttribute{
									Computed:            true,
									Description:         "whether it support LLDP-MED",
									MarkdownDescription: "whether it support LLDP-MED",
								},
								"mgmt_addr": schema.StringAttribute{
									Computed:            true,
									Description:         "switch’s management address (if advertised), can be IPv4, IPv6, or MAC",
									MarkdownDescription: "switch’s management address (if advertised), can be IPv4, IPv6, or MAC",
								},
								"mgmt_addrs": schema.ListAttribute{
									ElementType: types.StringType,
									Computed:    true,
								},
								"port_desc": schema.StringAttribute{
									Computed:            true,
									Description:         "ge-0/0/4",
									MarkdownDescription: "ge-0/0/4",
								},
								"port_id": schema.StringAttribute{
									Computed: true,
								},
								"power_allocated": schema.NumberAttribute{
									Computed:            true,
									Description:         "in mW, provided/allocated by PSE",
									MarkdownDescription: "in mW, provided/allocated by PSE",
								},
								"power_draw": schema.NumberAttribute{
									Computed:            true,
									Description:         "in mW, total power needed by PD",
									MarkdownDescription: "in mW, total power needed by PD",
								},
								"power_request_count": schema.Int64Attribute{
									Computed:            true,
									Description:         "number of negotiations, if it keeps increasing, we don’t have a stable power",
									MarkdownDescription: "number of negotiations, if it keeps increasing, we don’t have a stable power",
								},
								"power_requested": schema.NumberAttribute{
									Computed:            true,
									Description:         "in mW, the current power requested by PD",
									MarkdownDescription: "in mW, the current power requested by PD",
								},
								"system_desc": schema.StringAttribute{
									Computed:            true,
									Description:         "description provided by switch",
									MarkdownDescription: "description provided by switch",
								},
								"system_name": schema.StringAttribute{
									Computed:            true,
									Description:         "name of the switch",
									MarkdownDescription: "name of the switch",
								},
							},
							CustomType: LldpStatType{
								ObjectType: types.ObjectType{
									AttrTypes: LldpStatValue{}.AttributeTypes(ctx),
								},
							},
							Computed:            true,
							Description:         "LLDP Stat (neighbor information, power negotiations)",
							MarkdownDescription: "LLDP Stat (neighbor information, power negotiations)",
						},
						"locating": schema.BoolAttribute{
							Computed: true,
						},
						"locked": schema.BoolAttribute{
							Computed:            true,
							Description:         "whether this AP is considered locked (placement / orientation has been vetted)",
							MarkdownDescription: "whether this AP is considered locked (placement / orientation has been vetted)",
						},
						"mac": schema.StringAttribute{
							Computed:            true,
							Description:         "device mac",
							MarkdownDescription: "device mac",
						},
						"map_id": schema.StringAttribute{
							Computed: true,
						},
						"mem_used_kb": schema.Int64Attribute{
							Computed: true,
						},
						"mesh_downlinks": schema.MapNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"band": schema.StringAttribute{
										Computed: true,
									},
									"channel": schema.Int64Attribute{
										Computed: true,
									},
									"idle_time": schema.Int64Attribute{
										Computed: true,
									},
									"last_seen": schema.NumberAttribute{
										Computed: true,
									},
									"proto": schema.StringAttribute{
										Computed: true,
									},
									"rssi": schema.Int64Attribute{
										Computed: true,
									},
									"rx_bps": schema.Int64Attribute{
										Computed: true,
									},
									"rx_bytes": schema.Int64Attribute{
										Computed: true,
									},
									"rx_packets": schema.Int64Attribute{
										Computed: true,
									},
									"rx_rate": schema.Int64Attribute{
										Computed: true,
									},
									"rx_retries": schema.Int64Attribute{
										Computed: true,
									},
									"site_id": schema.StringAttribute{
										Computed: true,
									},
									"snr": schema.Int64Attribute{
										Computed: true,
									},
									"tx_bps": schema.Int64Attribute{
										Computed: true,
									},
									"tx_bytes": schema.Int64Attribute{
										Computed: true,
									},
									"tx_packets": schema.Int64Attribute{
										Computed: true,
									},
									"tx_rate": schema.Int64Attribute{
										Computed: true,
									},
									"tx_retries": schema.Int64Attribute{
										Computed: true,
									},
								},
								CustomType: MeshDownlinksType{
									ObjectType: types.ObjectType{
										AttrTypes: MeshDownlinksValue{}.AttributeTypes(ctx),
									},
								},
							},
							Computed:            true,
							Description:         "Property key is the mesh downlink id (e.g `00000000-0000-0000-1000-5c5b35000010`)",
							MarkdownDescription: "Property key is the mesh downlink id (e.g `00000000-0000-0000-1000-5c5b35000010`)",
						},
						"mesh_uplink": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"band": schema.StringAttribute{
									Computed: true,
								},
								"channel": schema.Int64Attribute{
									Computed: true,
								},
								"idle_time": schema.Int64Attribute{
									Computed: true,
								},
								"last_seen": schema.NumberAttribute{
									Computed: true,
								},
								"proto": schema.StringAttribute{
									Computed: true,
								},
								"rssi": schema.Int64Attribute{
									Computed: true,
								},
								"rx_bps": schema.Int64Attribute{
									Computed: true,
								},
								"rx_bytes": schema.Int64Attribute{
									Computed: true,
								},
								"rx_packets": schema.Int64Attribute{
									Computed: true,
								},
								"rx_rate": schema.Int64Attribute{
									Computed: true,
								},
								"rx_retries": schema.Int64Attribute{
									Computed: true,
								},
								"site_id": schema.StringAttribute{
									Computed: true,
								},
								"snr": schema.Int64Attribute{
									Computed: true,
								},
								"tx_bps": schema.Int64Attribute{
									Computed: true,
								},
								"tx_bytes": schema.Int64Attribute{
									Computed: true,
								},
								"tx_packets": schema.Int64Attribute{
									Computed: true,
								},
								"tx_rate": schema.Int64Attribute{
									Computed: true,
								},
								"tx_retries": schema.Int64Attribute{
									Computed: true,
								},
								"uplink_ap_id": schema.StringAttribute{
									Computed: true,
								},
							},
							CustomType: MeshUplinkType{
								ObjectType: types.ObjectType{
									AttrTypes: MeshUplinkValue{}.AttributeTypes(ctx),
								},
							},
							Computed: true,
						},
						"model": schema.StringAttribute{
							Computed:            true,
							Description:         "device model",
							MarkdownDescription: "device model",
						},
						"modified_time": schema.Int64Attribute{
							Computed: true,
						},
						"mount": schema.StringAttribute{
							Computed: true,
						},
						"name": schema.StringAttribute{
							Computed: true,
						},
						"notes": schema.StringAttribute{
							Computed: true,
						},
						"num_clients": schema.Int64Attribute{
							Computed:            true,
							Description:         "how many wireless clients are currently connected",
							MarkdownDescription: "how many wireless clients are currently connected",
						},
						"org_id": schema.StringAttribute{
							Computed: true,
						},
						"port_stat": schema.MapNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"full_duplex": schema.BoolAttribute{
										Computed: true,
									},
									"rx_bytes": schema.NumberAttribute{
										Computed: true,
									},
									"rx_errors": schema.NumberAttribute{
										Computed: true,
									},
									"rx_pkts": schema.NumberAttribute{
										Computed: true,
									},
									"speed": schema.Int64Attribute{
										Computed: true,
									},
									"tx_bytes": schema.NumberAttribute{
										Computed: true,
									},
									"tx_pkts": schema.NumberAttribute{
										Computed: true,
									},
									"up": schema.BoolAttribute{
										Computed: true,
									},
								},
								CustomType: PortStatType{
									ObjectType: types.ObjectType{
										AttrTypes: PortStatValue{}.AttributeTypes(ctx),
									},
								},
							},
							Computed:            true,
							Description:         "Property key is the port name (e.g. `eth0`)",
							MarkdownDescription: "Property key is the port name (e.g. `eth0`)",
						},
						"power_budget": schema.Int64Attribute{
							Computed:            true,
							Description:         "in mW, surplus if positive or deficit if negative",
							MarkdownDescription: "in mW, surplus if positive or deficit if negative",
						},
						"power_constrained": schema.BoolAttribute{
							Computed:            true,
							Description:         "whether insufficient power",
							MarkdownDescription: "whether insufficient power",
						},
						"power_opmode": schema.StringAttribute{
							Computed:            true,
							Description:         "constrained mode",
							MarkdownDescription: "constrained mode",
						},
						"power_src": schema.StringAttribute{
							Computed:            true,
							Description:         "DC Input / PoE 802.3at / PoE 802.3af / LLDP / ? (unknown)",
							MarkdownDescription: "DC Input / PoE 802.3at / PoE 802.3af / LLDP / ? (unknown)",
						},
						"radio_stat": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"band_24": schema.SingleNestedAttribute{
									Attributes: map[string]schema.Attribute{
										"bandwidth": schema.Int64Attribute{
											Computed:            true,
											Description:         "channel width for the band * `80` is only applicable for band_5 and band_6 * `160` is only for band_6",
											MarkdownDescription: "channel width for the band * `80` is only applicable for band_5 and band_6 * `160` is only for band_6",
										},
										"channel": schema.Int64Attribute{
											Computed:            true,
											Description:         "current channel the radio is running on",
											MarkdownDescription: "current channel the radio is running on",
										},
										"dynamic_chaining_enalbed": schema.BoolAttribute{
											Computed:            true,
											Description:         "Use dynamic chaining for downlink",
											MarkdownDescription: "Use dynamic chaining for downlink",
										},
										"mac": schema.StringAttribute{
											Computed:            true,
											Description:         "radio (base) mac, it can have 16 bssids (e.g. 5c5b350001a0-5c5b350001af)",
											MarkdownDescription: "radio (base) mac, it can have 16 bssids (e.g. 5c5b350001a0-5c5b350001af)",
										},
										"noise_floor": schema.Int64Attribute{
											Computed: true,
										},
										"num_clients": schema.Int64Attribute{
											Computed: true,
										},
										"power": schema.Int64Attribute{
											Computed:            true,
											Description:         "transmit power (in dBm)",
											MarkdownDescription: "transmit power (in dBm)",
										},
										"rx_bytes": schema.Int64Attribute{
											Computed: true,
										},
										"rx_pkts": schema.Int64Attribute{
											Computed: true,
										},
										"tx_bytes": schema.Int64Attribute{
											Computed: true,
										},
										"tx_pkts": schema.Int64Attribute{
											Computed: true,
										},
										"usage": schema.StringAttribute{
											Computed: true,
										},
										"util_all": schema.Int64Attribute{
											Computed:            true,
											Description:         "all utilization in percentage",
											MarkdownDescription: "all utilization in percentage",
										},
										"util_non_wifi": schema.Int64Attribute{
											Computed:            true,
											Description:         "reception of “No Packets” utilization in percentage, received frames with invalid PLCPs and CRS glitches as noise",
											MarkdownDescription: "reception of “No Packets” utilization in percentage, received frames with invalid PLCPs and CRS glitches as noise",
										},
										"util_rx_in_bss": schema.Int64Attribute{
											Computed:            true,
											Description:         "reception of “In BSS” utilization in percentage, only frames that are received from AP/STAs within the BSS",
											MarkdownDescription: "reception of “In BSS” utilization in percentage, only frames that are received from AP/STAs within the BSS",
										},
										"util_rx_other_bss": schema.Int64Attribute{
											Computed:            true,
											Description:         "reception of “Other BSS” utilization in percentage, all frames received from AP/STAs that are outside the BSS",
											MarkdownDescription: "reception of “Other BSS” utilization in percentage, all frames received from AP/STAs that are outside the BSS",
										},
										"util_tx": schema.Int64Attribute{
											Computed:            true,
											Description:         "transmission utilization in percentage",
											MarkdownDescription: "transmission utilization in percentage",
										},
										"util_undecodable_wifi": schema.Int64Attribute{
											Computed:            true,
											Description:         "reception of “UnDecodable Wifi“ utilization in percentage, only Preamble, PLCP header is decoded, Rest is undecodable in this radio",
											MarkdownDescription: "reception of “UnDecodable Wifi“ utilization in percentage, only Preamble, PLCP header is decoded, Rest is undecodable in this radio",
										},
										"util_unknown_wifi": schema.Int64Attribute{
											Computed:            true,
											Description:         "reception of “No Category” utilization in percentage, all 802.11 frames that are corrupted at the receiver",
											MarkdownDescription: "reception of “No Category” utilization in percentage, all 802.11 frames that are corrupted at the receiver",
										},
									},
									CustomType: BandType{
										ObjectType: types.ObjectType{
											AttrTypes: BandValue{}.AttributeTypes(ctx),
										},
									},
									Computed:            true,
									Description:         "radio stat",
									MarkdownDescription: "radio stat",
								},
								"band_5": schema.SingleNestedAttribute{
									Attributes: map[string]schema.Attribute{
										"bandwidth": schema.Int64Attribute{
											Computed:            true,
											Description:         "channel width for the band * `80` is only applicable for band_5 and band_6 * `160` is only for band_6",
											MarkdownDescription: "channel width for the band * `80` is only applicable for band_5 and band_6 * `160` is only for band_6",
										},
										"channel": schema.Int64Attribute{
											Computed:            true,
											Description:         "current channel the radio is running on",
											MarkdownDescription: "current channel the radio is running on",
										},
										"dynamic_chaining_enalbed": schema.BoolAttribute{
											Computed:            true,
											Description:         "Use dynamic chaining for downlink",
											MarkdownDescription: "Use dynamic chaining for downlink",
										},
										"mac": schema.StringAttribute{
											Computed:            true,
											Description:         "radio (base) mac, it can have 16 bssids (e.g. 5c5b350001a0-5c5b350001af)",
											MarkdownDescription: "radio (base) mac, it can have 16 bssids (e.g. 5c5b350001a0-5c5b350001af)",
										},
										"noise_floor": schema.Int64Attribute{
											Computed: true,
										},
										"num_clients": schema.Int64Attribute{
											Computed: true,
										},
										"power": schema.Int64Attribute{
											Computed:            true,
											Description:         "transmit power (in dBm)",
											MarkdownDescription: "transmit power (in dBm)",
										},
										"rx_bytes": schema.Int64Attribute{
											Computed: true,
										},
										"rx_pkts": schema.Int64Attribute{
											Computed: true,
										},
										"tx_bytes": schema.Int64Attribute{
											Computed: true,
										},
										"tx_pkts": schema.Int64Attribute{
											Computed: true,
										},
										"usage": schema.StringAttribute{
											Computed: true,
										},
										"util_all": schema.Int64Attribute{
											Computed:            true,
											Description:         "all utilization in percentage",
											MarkdownDescription: "all utilization in percentage",
										},
										"util_non_wifi": schema.Int64Attribute{
											Computed:            true,
											Description:         "reception of “No Packets” utilization in percentage, received frames with invalid PLCPs and CRS glitches as noise",
											MarkdownDescription: "reception of “No Packets” utilization in percentage, received frames with invalid PLCPs and CRS glitches as noise",
										},
										"util_rx_in_bss": schema.Int64Attribute{
											Computed:            true,
											Description:         "reception of “In BSS” utilization in percentage, only frames that are received from AP/STAs within the BSS",
											MarkdownDescription: "reception of “In BSS” utilization in percentage, only frames that are received from AP/STAs within the BSS",
										},
										"util_rx_other_bss": schema.Int64Attribute{
											Computed:            true,
											Description:         "reception of “Other BSS” utilization in percentage, all frames received from AP/STAs that are outside the BSS",
											MarkdownDescription: "reception of “Other BSS” utilization in percentage, all frames received from AP/STAs that are outside the BSS",
										},
										"util_tx": schema.Int64Attribute{
											Computed:            true,
											Description:         "transmission utilization in percentage",
											MarkdownDescription: "transmission utilization in percentage",
										},
										"util_undecodable_wifi": schema.Int64Attribute{
											Computed:            true,
											Description:         "reception of “UnDecodable Wifi“ utilization in percentage, only Preamble, PLCP header is decoded, Rest is undecodable in this radio",
											MarkdownDescription: "reception of “UnDecodable Wifi“ utilization in percentage, only Preamble, PLCP header is decoded, Rest is undecodable in this radio",
										},
										"util_unknown_wifi": schema.Int64Attribute{
											Computed:            true,
											Description:         "reception of “No Category” utilization in percentage, all 802.11 frames that are corrupted at the receiver",
											MarkdownDescription: "reception of “No Category” utilization in percentage, all 802.11 frames that are corrupted at the receiver",
										},
									},
									CustomType: BandType{
										ObjectType: types.ObjectType{
											AttrTypes: BandValue{}.AttributeTypes(ctx),
										},
									},
									Computed:            true,
									Description:         "radio stat",
									MarkdownDescription: "radio stat",
								},
								"band_6": schema.SingleNestedAttribute{
									Attributes: map[string]schema.Attribute{
										"bandwidth": schema.Int64Attribute{
											Computed:            true,
											Description:         "channel width for the band * `80` is only applicable for band_5 and band_6 * `160` is only for band_6",
											MarkdownDescription: "channel width for the band * `80` is only applicable for band_5 and band_6 * `160` is only for band_6",
										},
										"channel": schema.Int64Attribute{
											Computed:            true,
											Description:         "current channel the radio is running on",
											MarkdownDescription: "current channel the radio is running on",
										},
										"dynamic_chaining_enalbed": schema.BoolAttribute{
											Computed:            true,
											Description:         "Use dynamic chaining for downlink",
											MarkdownDescription: "Use dynamic chaining for downlink",
										},
										"mac": schema.StringAttribute{
											Computed:            true,
											Description:         "radio (base) mac, it can have 16 bssids (e.g. 5c5b350001a0-5c5b350001af)",
											MarkdownDescription: "radio (base) mac, it can have 16 bssids (e.g. 5c5b350001a0-5c5b350001af)",
										},
										"noise_floor": schema.Int64Attribute{
											Computed: true,
										},
										"num_clients": schema.Int64Attribute{
											Computed: true,
										},
										"power": schema.Int64Attribute{
											Computed:            true,
											Description:         "transmit power (in dBm)",
											MarkdownDescription: "transmit power (in dBm)",
										},
										"rx_bytes": schema.Int64Attribute{
											Computed: true,
										},
										"rx_pkts": schema.Int64Attribute{
											Computed: true,
										},
										"tx_bytes": schema.Int64Attribute{
											Computed: true,
										},
										"tx_pkts": schema.Int64Attribute{
											Computed: true,
										},
										"usage": schema.StringAttribute{
											Computed: true,
										},
										"util_all": schema.Int64Attribute{
											Computed:            true,
											Description:         "all utilization in percentage",
											MarkdownDescription: "all utilization in percentage",
										},
										"util_non_wifi": schema.Int64Attribute{
											Computed:            true,
											Description:         "reception of “No Packets” utilization in percentage, received frames with invalid PLCPs and CRS glitches as noise",
											MarkdownDescription: "reception of “No Packets” utilization in percentage, received frames with invalid PLCPs and CRS glitches as noise",
										},
										"util_rx_in_bss": schema.Int64Attribute{
											Computed:            true,
											Description:         "reception of “In BSS” utilization in percentage, only frames that are received from AP/STAs within the BSS",
											MarkdownDescription: "reception of “In BSS” utilization in percentage, only frames that are received from AP/STAs within the BSS",
										},
										"util_rx_other_bss": schema.Int64Attribute{
											Computed:            true,
											Description:         "reception of “Other BSS” utilization in percentage, all frames received from AP/STAs that are outside the BSS",
											MarkdownDescription: "reception of “Other BSS” utilization in percentage, all frames received from AP/STAs that are outside the BSS",
										},
										"util_tx": schema.Int64Attribute{
											Computed:            true,
											Description:         "transmission utilization in percentage",
											MarkdownDescription: "transmission utilization in percentage",
										},
										"util_undecodable_wifi": schema.Int64Attribute{
											Computed:            true,
											Description:         "reception of “UnDecodable Wifi“ utilization in percentage, only Preamble, PLCP header is decoded, Rest is undecodable in this radio",
											MarkdownDescription: "reception of “UnDecodable Wifi“ utilization in percentage, only Preamble, PLCP header is decoded, Rest is undecodable in this radio",
										},
										"util_unknown_wifi": schema.Int64Attribute{
											Computed:            true,
											Description:         "reception of “No Category” utilization in percentage, all 802.11 frames that are corrupted at the receiver",
											MarkdownDescription: "reception of “No Category” utilization in percentage, all 802.11 frames that are corrupted at the receiver",
										},
									},
									CustomType: BandType{
										ObjectType: types.ObjectType{
											AttrTypes: BandValue{}.AttributeTypes(ctx),
										},
									},
									Computed:            true,
									Description:         "radio stat",
									MarkdownDescription: "radio stat",
								},
							},
							CustomType: RadioStatType{
								ObjectType: types.ObjectType{
									AttrTypes: RadioStatValue{}.AttributeTypes(ctx),
								},
							},
							Computed: true,
						},
						"rx_bps": schema.NumberAttribute{
							Computed: true,
						},
						"rx_bytes": schema.Int64Attribute{
							Computed: true,
						},
						"rx_pkts": schema.Int64Attribute{
							Computed: true,
						},
						"serial": schema.StringAttribute{
							Computed:            true,
							Description:         "serial",
							MarkdownDescription: "serial",
						},
						"site_id": schema.StringAttribute{
							Computed: true,
						},
						"status": schema.StringAttribute{
							Computed: true,
						},
						"switch_redundancy": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"num_redundant_aps": schema.Int64Attribute{
									Computed: true,
								},
							},
							CustomType: SwitchRedundancyType{
								ObjectType: types.ObjectType{
									AttrTypes: SwitchRedundancyValue{}.AttributeTypes(ctx),
								},
							},
							Computed: true,
						},
						"tx_bps": schema.NumberAttribute{
							Computed: true,
						},
						"tx_bytes": schema.NumberAttribute{
							Computed: true,
						},
						"tx_pkts": schema.NumberAttribute{
							Computed: true,
						},
						"uptime": schema.NumberAttribute{
							Computed:            true,
							Description:         "how long, in seconds, has the device been up (or rebooted)",
							MarkdownDescription: "how long, in seconds, has the device been up (or rebooted)",
						},
						"usb_stat": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"channel": schema.Int64Attribute{
									Computed: true,
								},
								"connected": schema.BoolAttribute{
									Computed: true,
								},
								"last_activity": schema.Int64Attribute{
									Computed: true,
								},
								"type": schema.StringAttribute{
									Computed: true,
								},
								"up": schema.BoolAttribute{
									Computed: true,
								},
							},
							CustomType: UsbStatType{
								ObjectType: types.ObjectType{
									AttrTypes: UsbStatValue{}.AttributeTypes(ctx),
								},
							},
							Computed: true,
						},
						"version": schema.StringAttribute{
							Computed: true,
						},
						"x": schema.Float64Attribute{
							Computed: true,
						},
						"y": schema.Float64Attribute{
							Computed: true,
						},
					},
					CustomType: DeviceApStatsType{
						ObjectType: types.ObjectType{
							AttrTypes: DeviceApStatsValue{}.AttributeTypes(ctx),
						},
					},
				},
				Computed: true,
			},
			"duration": schema.StringAttribute{
				Optional:            true,
				Description:         "duration like 7d, 2w",
				MarkdownDescription: "duration like 7d, 2w",
			},
			"end": schema.Int64Attribute{
				Optional:            true,
				Description:         "end datetime, can be epoch or relative time like -1d, -2h; now if not specified",
				MarkdownDescription: "end datetime, can be epoch or relative time like -1d, -2h; now if not specified",
			},
			"mac": schema.StringAttribute{
				Optional: true,
			},
			"org_id": schema.StringAttribute{
				Required: true,
			},
			"site_id": schema.StringAttribute{
				Optional: true,
			},
			"start": schema.Int64Attribute{
				Optional:            true,
				Description:         "start datetime, can be epoch or relative time like -1d, -1w; -1d if not specified",
				MarkdownDescription: "start datetime, can be epoch or relative time like -1d, -1w; -1d if not specified",
			},
			"status": schema.StringAttribute{
				Optional: true,
				Validators: []validator.String{
					stringvalidator.OneOf(
						"",
						"all",
						"connected",
						"disconnected",
					),
				},
			},
		},
	}
}

type DeviceApStatsModel struct {
	DeviceApStats types.Set    `tfsdk:"device_ap_stats"`
	Duration      types.String `tfsdk:"duration"`
	End           types.Int64  `tfsdk:"end"`
	Mac           types.String `tfsdk:"mac"`
	OrgId         types.String `tfsdk:"org_id"`
	SiteId        types.String `tfsdk:"site_id"`
	Start         types.Int64  `tfsdk:"start"`
	Status        types.String `tfsdk:"status"`
}

var _ basetypes.ObjectTypable = DeviceApStatsType{}

type DeviceApStatsType struct {
	basetypes.ObjectType
}

func (t DeviceApStatsType) Equal(o attr.Type) bool {
	other, ok := o.(DeviceApStatsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t DeviceApStatsType) String() string {
	return "DeviceApStatsType"
}

func (t DeviceApStatsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	autoPlacementAttribute, ok := attributes["auto_placement"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auto_placement is missing from object`)

		return nil, diags
	}

	autoPlacementVal, ok := autoPlacementAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auto_placement expected to be basetypes.ObjectValue, was: %T`, autoPlacementAttribute))
	}

	autoUpgradeStatAttribute, ok := attributes["auto_upgrade_stat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auto_upgrade_stat is missing from object`)

		return nil, diags
	}

	autoUpgradeStatVal, ok := autoUpgradeStatAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auto_upgrade_stat expected to be basetypes.ObjectValue, was: %T`, autoUpgradeStatAttribute))
	}

	bleStatAttribute, ok := attributes["ble_stat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ble_stat is missing from object`)

		return nil, diags
	}

	bleStatVal, ok := bleStatAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ble_stat expected to be basetypes.ObjectValue, was: %T`, bleStatAttribute))
	}

	certExpiryAttribute, ok := attributes["cert_expiry"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cert_expiry is missing from object`)

		return nil, diags
	}

	certExpiryVal, ok := certExpiryAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cert_expiry expected to be basetypes.NumberValue, was: %T`, certExpiryAttribute))
	}

	configRevertedAttribute, ok := attributes["config_reverted"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`config_reverted is missing from object`)

		return nil, diags
	}

	configRevertedVal, ok := configRevertedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`config_reverted expected to be basetypes.BoolValue, was: %T`, configRevertedAttribute))
	}

	cpuSystemAttribute, ok := attributes["cpu_system"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cpu_system is missing from object`)

		return nil, diags
	}

	cpuSystemVal, ok := cpuSystemAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cpu_system expected to be basetypes.Int64Value, was: %T`, cpuSystemAttribute))
	}

	cpuUtilAttribute, ok := attributes["cpu_util"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cpu_util is missing from object`)

		return nil, diags
	}

	cpuUtilVal, ok := cpuUtilAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cpu_util expected to be basetypes.Int64Value, was: %T`, cpuUtilAttribute))
	}

	createdTimeAttribute, ok := attributes["created_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_time is missing from object`)

		return nil, diags
	}

	createdTimeVal, ok := createdTimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_time expected to be basetypes.Int64Value, was: %T`, createdTimeAttribute))
	}

	deviceprofileIdAttribute, ok := attributes["deviceprofile_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`deviceprofile_id is missing from object`)

		return nil, diags
	}

	deviceprofileIdVal, ok := deviceprofileIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`deviceprofile_id expected to be basetypes.StringValue, was: %T`, deviceprofileIdAttribute))
	}

	envStatAttribute, ok := attributes["env_stat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`env_stat is missing from object`)

		return nil, diags
	}

	envStatVal, ok := envStatAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`env_stat expected to be basetypes.ObjectValue, was: %T`, envStatAttribute))
	}

	eslStatAttribute, ok := attributes["esl_stat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`esl_stat is missing from object`)

		return nil, diags
	}

	eslStatVal, ok := eslStatAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`esl_stat expected to be basetypes.ObjectValue, was: %T`, eslStatAttribute))
	}

	extIpAttribute, ok := attributes["ext_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ext_ip is missing from object`)

		return nil, diags
	}

	extIpVal, ok := extIpAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ext_ip expected to be basetypes.StringValue, was: %T`, extIpAttribute))
	}

	fwupdateAttribute, ok := attributes["fwupdate"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fwupdate is missing from object`)

		return nil, diags
	}

	fwupdateVal, ok := fwupdateAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fwupdate expected to be basetypes.ObjectValue, was: %T`, fwupdateAttribute))
	}

	hwRevAttribute, ok := attributes["hw_rev"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`hw_rev is missing from object`)

		return nil, diags
	}

	hwRevVal, ok := hwRevAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`hw_rev expected to be basetypes.StringValue, was: %T`, hwRevAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	inactiveWiredVlansAttribute, ok := attributes["inactive_wired_vlans"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`inactive_wired_vlans is missing from object`)

		return nil, diags
	}

	inactiveWiredVlansVal, ok := inactiveWiredVlansAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`inactive_wired_vlans expected to be basetypes.ListValue, was: %T`, inactiveWiredVlansAttribute))
	}

	iotStatAttribute, ok := attributes["iot_stat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`iot_stat is missing from object`)

		return nil, diags
	}

	iotStatVal, ok := iotStatAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`iot_stat expected to be basetypes.MapValue, was: %T`, iotStatAttribute))
	}

	ipAttribute, ok := attributes["ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip is missing from object`)

		return nil, diags
	}

	ipVal, ok := ipAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip expected to be basetypes.StringValue, was: %T`, ipAttribute))
	}

	ipConfigAttribute, ok := attributes["ip_config"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_config is missing from object`)

		return nil, diags
	}

	ipConfigVal, ok := ipConfigAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_config expected to be basetypes.ObjectValue, was: %T`, ipConfigAttribute))
	}

	ipStatAttribute, ok := attributes["ip_stat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_stat is missing from object`)

		return nil, diags
	}

	ipStatVal, ok := ipStatAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_stat expected to be basetypes.ObjectValue, was: %T`, ipStatAttribute))
	}

	l2tpStatAttribute, ok := attributes["l2tp_stat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`l2tp_stat is missing from object`)

		return nil, diags
	}

	l2tpStatVal, ok := l2tpStatAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`l2tp_stat expected to be basetypes.MapValue, was: %T`, l2tpStatAttribute))
	}

	lastSeenAttribute, ok := attributes["last_seen"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`last_seen is missing from object`)

		return nil, diags
	}

	lastSeenVal, ok := lastSeenAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`last_seen expected to be basetypes.NumberValue, was: %T`, lastSeenAttribute))
	}

	lastTroubleAttribute, ok := attributes["last_trouble"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`last_trouble is missing from object`)

		return nil, diags
	}

	lastTroubleVal, ok := lastTroubleAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`last_trouble expected to be basetypes.ObjectValue, was: %T`, lastTroubleAttribute))
	}

	ledAttribute, ok := attributes["led"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`led is missing from object`)

		return nil, diags
	}

	ledVal, ok := ledAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`led expected to be basetypes.ObjectValue, was: %T`, ledAttribute))
	}

	lldpStatAttribute, ok := attributes["lldp_stat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lldp_stat is missing from object`)

		return nil, diags
	}

	lldpStatVal, ok := lldpStatAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lldp_stat expected to be basetypes.ObjectValue, was: %T`, lldpStatAttribute))
	}

	locatingAttribute, ok := attributes["locating"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`locating is missing from object`)

		return nil, diags
	}

	locatingVal, ok := locatingAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`locating expected to be basetypes.BoolValue, was: %T`, locatingAttribute))
	}

	lockedAttribute, ok := attributes["locked"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`locked is missing from object`)

		return nil, diags
	}

	lockedVal, ok := lockedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`locked expected to be basetypes.BoolValue, was: %T`, lockedAttribute))
	}

	macAttribute, ok := attributes["mac"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mac is missing from object`)

		return nil, diags
	}

	macVal, ok := macAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mac expected to be basetypes.StringValue, was: %T`, macAttribute))
	}

	mapIdAttribute, ok := attributes["map_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`map_id is missing from object`)

		return nil, diags
	}

	mapIdVal, ok := mapIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`map_id expected to be basetypes.StringValue, was: %T`, mapIdAttribute))
	}

	memUsedKbAttribute, ok := attributes["mem_used_kb"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mem_used_kb is missing from object`)

		return nil, diags
	}

	memUsedKbVal, ok := memUsedKbAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mem_used_kb expected to be basetypes.Int64Value, was: %T`, memUsedKbAttribute))
	}

	meshDownlinksAttribute, ok := attributes["mesh_downlinks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mesh_downlinks is missing from object`)

		return nil, diags
	}

	meshDownlinksVal, ok := meshDownlinksAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mesh_downlinks expected to be basetypes.MapValue, was: %T`, meshDownlinksAttribute))
	}

	meshUplinkAttribute, ok := attributes["mesh_uplink"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mesh_uplink is missing from object`)

		return nil, diags
	}

	meshUplinkVal, ok := meshUplinkAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mesh_uplink expected to be basetypes.ObjectValue, was: %T`, meshUplinkAttribute))
	}

	modelAttribute, ok := attributes["model"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`model is missing from object`)

		return nil, diags
	}

	modelVal, ok := modelAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`model expected to be basetypes.StringValue, was: %T`, modelAttribute))
	}

	modifiedTimeAttribute, ok := attributes["modified_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`modified_time is missing from object`)

		return nil, diags
	}

	modifiedTimeVal, ok := modifiedTimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`modified_time expected to be basetypes.Int64Value, was: %T`, modifiedTimeAttribute))
	}

	mountAttribute, ok := attributes["mount"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mount is missing from object`)

		return nil, diags
	}

	mountVal, ok := mountAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mount expected to be basetypes.StringValue, was: %T`, mountAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	notesAttribute, ok := attributes["notes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`notes is missing from object`)

		return nil, diags
	}

	notesVal, ok := notesAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`notes expected to be basetypes.StringValue, was: %T`, notesAttribute))
	}

	numClientsAttribute, ok := attributes["num_clients"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`num_clients is missing from object`)

		return nil, diags
	}

	numClientsVal, ok := numClientsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`num_clients expected to be basetypes.Int64Value, was: %T`, numClientsAttribute))
	}

	orgIdAttribute, ok := attributes["org_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`org_id is missing from object`)

		return nil, diags
	}

	orgIdVal, ok := orgIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`org_id expected to be basetypes.StringValue, was: %T`, orgIdAttribute))
	}

	portStatAttribute, ok := attributes["port_stat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_stat is missing from object`)

		return nil, diags
	}

	portStatVal, ok := portStatAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_stat expected to be basetypes.MapValue, was: %T`, portStatAttribute))
	}

	powerBudgetAttribute, ok := attributes["power_budget"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`power_budget is missing from object`)

		return nil, diags
	}

	powerBudgetVal, ok := powerBudgetAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`power_budget expected to be basetypes.Int64Value, was: %T`, powerBudgetAttribute))
	}

	powerConstrainedAttribute, ok := attributes["power_constrained"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`power_constrained is missing from object`)

		return nil, diags
	}

	powerConstrainedVal, ok := powerConstrainedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`power_constrained expected to be basetypes.BoolValue, was: %T`, powerConstrainedAttribute))
	}

	powerOpmodeAttribute, ok := attributes["power_opmode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`power_opmode is missing from object`)

		return nil, diags
	}

	powerOpmodeVal, ok := powerOpmodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`power_opmode expected to be basetypes.StringValue, was: %T`, powerOpmodeAttribute))
	}

	powerSrcAttribute, ok := attributes["power_src"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`power_src is missing from object`)

		return nil, diags
	}

	powerSrcVal, ok := powerSrcAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`power_src expected to be basetypes.StringValue, was: %T`, powerSrcAttribute))
	}

	radioStatAttribute, ok := attributes["radio_stat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`radio_stat is missing from object`)

		return nil, diags
	}

	radioStatVal, ok := radioStatAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`radio_stat expected to be basetypes.ObjectValue, was: %T`, radioStatAttribute))
	}

	rxBpsAttribute, ok := attributes["rx_bps"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rx_bps is missing from object`)

		return nil, diags
	}

	rxBpsVal, ok := rxBpsAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rx_bps expected to be basetypes.NumberValue, was: %T`, rxBpsAttribute))
	}

	rxBytesAttribute, ok := attributes["rx_bytes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rx_bytes is missing from object`)

		return nil, diags
	}

	rxBytesVal, ok := rxBytesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rx_bytes expected to be basetypes.Int64Value, was: %T`, rxBytesAttribute))
	}

	rxPktsAttribute, ok := attributes["rx_pkts"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rx_pkts is missing from object`)

		return nil, diags
	}

	rxPktsVal, ok := rxPktsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rx_pkts expected to be basetypes.Int64Value, was: %T`, rxPktsAttribute))
	}

	serialAttribute, ok := attributes["serial"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`serial is missing from object`)

		return nil, diags
	}

	serialVal, ok := serialAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`serial expected to be basetypes.StringValue, was: %T`, serialAttribute))
	}

	siteIdAttribute, ok := attributes["site_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`site_id is missing from object`)

		return nil, diags
	}

	siteIdVal, ok := siteIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`site_id expected to be basetypes.StringValue, was: %T`, siteIdAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return nil, diags
	}

	statusVal, ok := statusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be basetypes.StringValue, was: %T`, statusAttribute))
	}

	switchRedundancyAttribute, ok := attributes["switch_redundancy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`switch_redundancy is missing from object`)

		return nil, diags
	}

	switchRedundancyVal, ok := switchRedundancyAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`switch_redundancy expected to be basetypes.ObjectValue, was: %T`, switchRedundancyAttribute))
	}

	txBpsAttribute, ok := attributes["tx_bps"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tx_bps is missing from object`)

		return nil, diags
	}

	txBpsVal, ok := txBpsAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tx_bps expected to be basetypes.NumberValue, was: %T`, txBpsAttribute))
	}

	txBytesAttribute, ok := attributes["tx_bytes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tx_bytes is missing from object`)

		return nil, diags
	}

	txBytesVal, ok := txBytesAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tx_bytes expected to be basetypes.NumberValue, was: %T`, txBytesAttribute))
	}

	txPktsAttribute, ok := attributes["tx_pkts"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tx_pkts is missing from object`)

		return nil, diags
	}

	txPktsVal, ok := txPktsAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tx_pkts expected to be basetypes.NumberValue, was: %T`, txPktsAttribute))
	}

	uptimeAttribute, ok := attributes["uptime"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uptime is missing from object`)

		return nil, diags
	}

	uptimeVal, ok := uptimeAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uptime expected to be basetypes.NumberValue, was: %T`, uptimeAttribute))
	}

	usbStatAttribute, ok := attributes["usb_stat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`usb_stat is missing from object`)

		return nil, diags
	}

	usbStatVal, ok := usbStatAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`usb_stat expected to be basetypes.ObjectValue, was: %T`, usbStatAttribute))
	}

	versionAttribute, ok := attributes["version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`version is missing from object`)

		return nil, diags
	}

	versionVal, ok := versionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`version expected to be basetypes.StringValue, was: %T`, versionAttribute))
	}

	xAttribute, ok := attributes["x"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`x is missing from object`)

		return nil, diags
	}

	xVal, ok := xAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`x expected to be basetypes.Float64Value, was: %T`, xAttribute))
	}

	yAttribute, ok := attributes["y"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`y is missing from object`)

		return nil, diags
	}

	yVal, ok := yAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`y expected to be basetypes.Float64Value, was: %T`, yAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return DeviceApStatsValue{
		AutoPlacement:      autoPlacementVal,
		AutoUpgradeStat:    autoUpgradeStatVal,
		BleStat:            bleStatVal,
		CertExpiry:         certExpiryVal,
		ConfigReverted:     configRevertedVal,
		CpuSystem:          cpuSystemVal,
		CpuUtil:            cpuUtilVal,
		CreatedTime:        createdTimeVal,
		DeviceprofileId:    deviceprofileIdVal,
		EnvStat:            envStatVal,
		EslStat:            eslStatVal,
		ExtIp:              extIpVal,
		Fwupdate:           fwupdateVal,
		HwRev:              hwRevVal,
		Id:                 idVal,
		InactiveWiredVlans: inactiveWiredVlansVal,
		IotStat:            iotStatVal,
		Ip:                 ipVal,
		IpConfig:           ipConfigVal,
		IpStat:             ipStatVal,
		L2tpStat:           l2tpStatVal,
		LastSeen:           lastSeenVal,
		LastTrouble:        lastTroubleVal,
		Led:                ledVal,
		LldpStat:           lldpStatVal,
		Locating:           locatingVal,
		Locked:             lockedVal,
		Mac:                macVal,
		MapId:              mapIdVal,
		MemUsedKb:          memUsedKbVal,
		MeshDownlinks:      meshDownlinksVal,
		MeshUplink:         meshUplinkVal,
		Model:              modelVal,
		ModifiedTime:       modifiedTimeVal,
		Mount:              mountVal,
		Name:               nameVal,
		Notes:              notesVal,
		NumClients:         numClientsVal,
		OrgId:              orgIdVal,
		PortStat:           portStatVal,
		PowerBudget:        powerBudgetVal,
		PowerConstrained:   powerConstrainedVal,
		PowerOpmode:        powerOpmodeVal,
		PowerSrc:           powerSrcVal,
		RadioStat:          radioStatVal,
		RxBps:              rxBpsVal,
		RxBytes:            rxBytesVal,
		RxPkts:             rxPktsVal,
		Serial:             serialVal,
		SiteId:             siteIdVal,
		Status:             statusVal,
		SwitchRedundancy:   switchRedundancyVal,
		TxBps:              txBpsVal,
		TxBytes:            txBytesVal,
		TxPkts:             txPktsVal,
		Uptime:             uptimeVal,
		UsbStat:            usbStatVal,
		Version:            versionVal,
		X:                  xVal,
		Y:                  yVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewDeviceApStatsValueNull() DeviceApStatsValue {
	return DeviceApStatsValue{
		state: attr.ValueStateNull,
	}
}

func NewDeviceApStatsValueUnknown() DeviceApStatsValue {
	return DeviceApStatsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewDeviceApStatsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (DeviceApStatsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing DeviceApStatsValue Attribute Value",
				"While creating a DeviceApStatsValue value, a missing attribute value was detected. "+
					"A DeviceApStatsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DeviceApStatsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid DeviceApStatsValue Attribute Type",
				"While creating a DeviceApStatsValue value, an invalid attribute value was detected. "+
					"A DeviceApStatsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DeviceApStatsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("DeviceApStatsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra DeviceApStatsValue Attribute Value",
				"While creating a DeviceApStatsValue value, an extra attribute value was detected. "+
					"A DeviceApStatsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra DeviceApStatsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewDeviceApStatsValueUnknown(), diags
	}

	autoPlacementAttribute, ok := attributes["auto_placement"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auto_placement is missing from object`)

		return NewDeviceApStatsValueUnknown(), diags
	}

	autoPlacementVal, ok := autoPlacementAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auto_placement expected to be basetypes.ObjectValue, was: %T`, autoPlacementAttribute))
	}

	autoUpgradeStatAttribute, ok := attributes["auto_upgrade_stat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auto_upgrade_stat is missing from object`)

		return NewDeviceApStatsValueUnknown(), diags
	}

	autoUpgradeStatVal, ok := autoUpgradeStatAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auto_upgrade_stat expected to be basetypes.ObjectValue, was: %T`, autoUpgradeStatAttribute))
	}

	bleStatAttribute, ok := attributes["ble_stat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ble_stat is missing from object`)

		return NewDeviceApStatsValueUnknown(), diags
	}

	bleStatVal, ok := bleStatAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ble_stat expected to be basetypes.ObjectValue, was: %T`, bleStatAttribute))
	}

	certExpiryAttribute, ok := attributes["cert_expiry"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cert_expiry is missing from object`)

		return NewDeviceApStatsValueUnknown(), diags
	}

	certExpiryVal, ok := certExpiryAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cert_expiry expected to be basetypes.NumberValue, was: %T`, certExpiryAttribute))
	}

	configRevertedAttribute, ok := attributes["config_reverted"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`config_reverted is missing from object`)

		return NewDeviceApStatsValueUnknown(), diags
	}

	configRevertedVal, ok := configRevertedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`config_reverted expected to be basetypes.BoolValue, was: %T`, configRevertedAttribute))
	}

	cpuSystemAttribute, ok := attributes["cpu_system"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cpu_system is missing from object`)

		return NewDeviceApStatsValueUnknown(), diags
	}

	cpuSystemVal, ok := cpuSystemAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cpu_system expected to be basetypes.Int64Value, was: %T`, cpuSystemAttribute))
	}

	cpuUtilAttribute, ok := attributes["cpu_util"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cpu_util is missing from object`)

		return NewDeviceApStatsValueUnknown(), diags
	}

	cpuUtilVal, ok := cpuUtilAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cpu_util expected to be basetypes.Int64Value, was: %T`, cpuUtilAttribute))
	}

	createdTimeAttribute, ok := attributes["created_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_time is missing from object`)

		return NewDeviceApStatsValueUnknown(), diags
	}

	createdTimeVal, ok := createdTimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_time expected to be basetypes.Int64Value, was: %T`, createdTimeAttribute))
	}

	deviceprofileIdAttribute, ok := attributes["deviceprofile_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`deviceprofile_id is missing from object`)

		return NewDeviceApStatsValueUnknown(), diags
	}

	deviceprofileIdVal, ok := deviceprofileIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`deviceprofile_id expected to be basetypes.StringValue, was: %T`, deviceprofileIdAttribute))
	}

	envStatAttribute, ok := attributes["env_stat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`env_stat is missing from object`)

		return NewDeviceApStatsValueUnknown(), diags
	}

	envStatVal, ok := envStatAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`env_stat expected to be basetypes.ObjectValue, was: %T`, envStatAttribute))
	}

	eslStatAttribute, ok := attributes["esl_stat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`esl_stat is missing from object`)

		return NewDeviceApStatsValueUnknown(), diags
	}

	eslStatVal, ok := eslStatAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`esl_stat expected to be basetypes.ObjectValue, was: %T`, eslStatAttribute))
	}

	extIpAttribute, ok := attributes["ext_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ext_ip is missing from object`)

		return NewDeviceApStatsValueUnknown(), diags
	}

	extIpVal, ok := extIpAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ext_ip expected to be basetypes.StringValue, was: %T`, extIpAttribute))
	}

	fwupdateAttribute, ok := attributes["fwupdate"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fwupdate is missing from object`)

		return NewDeviceApStatsValueUnknown(), diags
	}

	fwupdateVal, ok := fwupdateAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fwupdate expected to be basetypes.ObjectValue, was: %T`, fwupdateAttribute))
	}

	hwRevAttribute, ok := attributes["hw_rev"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`hw_rev is missing from object`)

		return NewDeviceApStatsValueUnknown(), diags
	}

	hwRevVal, ok := hwRevAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`hw_rev expected to be basetypes.StringValue, was: %T`, hwRevAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewDeviceApStatsValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	inactiveWiredVlansAttribute, ok := attributes["inactive_wired_vlans"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`inactive_wired_vlans is missing from object`)

		return NewDeviceApStatsValueUnknown(), diags
	}

	inactiveWiredVlansVal, ok := inactiveWiredVlansAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`inactive_wired_vlans expected to be basetypes.ListValue, was: %T`, inactiveWiredVlansAttribute))
	}

	iotStatAttribute, ok := attributes["iot_stat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`iot_stat is missing from object`)

		return NewDeviceApStatsValueUnknown(), diags
	}

	iotStatVal, ok := iotStatAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`iot_stat expected to be basetypes.MapValue, was: %T`, iotStatAttribute))
	}

	ipAttribute, ok := attributes["ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip is missing from object`)

		return NewDeviceApStatsValueUnknown(), diags
	}

	ipVal, ok := ipAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip expected to be basetypes.StringValue, was: %T`, ipAttribute))
	}

	ipConfigAttribute, ok := attributes["ip_config"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_config is missing from object`)

		return NewDeviceApStatsValueUnknown(), diags
	}

	ipConfigVal, ok := ipConfigAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_config expected to be basetypes.ObjectValue, was: %T`, ipConfigAttribute))
	}

	ipStatAttribute, ok := attributes["ip_stat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_stat is missing from object`)

		return NewDeviceApStatsValueUnknown(), diags
	}

	ipStatVal, ok := ipStatAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_stat expected to be basetypes.ObjectValue, was: %T`, ipStatAttribute))
	}

	l2tpStatAttribute, ok := attributes["l2tp_stat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`l2tp_stat is missing from object`)

		return NewDeviceApStatsValueUnknown(), diags
	}

	l2tpStatVal, ok := l2tpStatAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`l2tp_stat expected to be basetypes.MapValue, was: %T`, l2tpStatAttribute))
	}

	lastSeenAttribute, ok := attributes["last_seen"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`last_seen is missing from object`)

		return NewDeviceApStatsValueUnknown(), diags
	}

	lastSeenVal, ok := lastSeenAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`last_seen expected to be basetypes.NumberValue, was: %T`, lastSeenAttribute))
	}

	lastTroubleAttribute, ok := attributes["last_trouble"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`last_trouble is missing from object`)

		return NewDeviceApStatsValueUnknown(), diags
	}

	lastTroubleVal, ok := lastTroubleAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`last_trouble expected to be basetypes.ObjectValue, was: %T`, lastTroubleAttribute))
	}

	ledAttribute, ok := attributes["led"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`led is missing from object`)

		return NewDeviceApStatsValueUnknown(), diags
	}

	ledVal, ok := ledAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`led expected to be basetypes.ObjectValue, was: %T`, ledAttribute))
	}

	lldpStatAttribute, ok := attributes["lldp_stat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lldp_stat is missing from object`)

		return NewDeviceApStatsValueUnknown(), diags
	}

	lldpStatVal, ok := lldpStatAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lldp_stat expected to be basetypes.ObjectValue, was: %T`, lldpStatAttribute))
	}

	locatingAttribute, ok := attributes["locating"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`locating is missing from object`)

		return NewDeviceApStatsValueUnknown(), diags
	}

	locatingVal, ok := locatingAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`locating expected to be basetypes.BoolValue, was: %T`, locatingAttribute))
	}

	lockedAttribute, ok := attributes["locked"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`locked is missing from object`)

		return NewDeviceApStatsValueUnknown(), diags
	}

	lockedVal, ok := lockedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`locked expected to be basetypes.BoolValue, was: %T`, lockedAttribute))
	}

	macAttribute, ok := attributes["mac"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mac is missing from object`)

		return NewDeviceApStatsValueUnknown(), diags
	}

	macVal, ok := macAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mac expected to be basetypes.StringValue, was: %T`, macAttribute))
	}

	mapIdAttribute, ok := attributes["map_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`map_id is missing from object`)

		return NewDeviceApStatsValueUnknown(), diags
	}

	mapIdVal, ok := mapIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`map_id expected to be basetypes.StringValue, was: %T`, mapIdAttribute))
	}

	memUsedKbAttribute, ok := attributes["mem_used_kb"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mem_used_kb is missing from object`)

		return NewDeviceApStatsValueUnknown(), diags
	}

	memUsedKbVal, ok := memUsedKbAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mem_used_kb expected to be basetypes.Int64Value, was: %T`, memUsedKbAttribute))
	}

	meshDownlinksAttribute, ok := attributes["mesh_downlinks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mesh_downlinks is missing from object`)

		return NewDeviceApStatsValueUnknown(), diags
	}

	meshDownlinksVal, ok := meshDownlinksAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mesh_downlinks expected to be basetypes.MapValue, was: %T`, meshDownlinksAttribute))
	}

	meshUplinkAttribute, ok := attributes["mesh_uplink"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mesh_uplink is missing from object`)

		return NewDeviceApStatsValueUnknown(), diags
	}

	meshUplinkVal, ok := meshUplinkAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mesh_uplink expected to be basetypes.ObjectValue, was: %T`, meshUplinkAttribute))
	}

	modelAttribute, ok := attributes["model"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`model is missing from object`)

		return NewDeviceApStatsValueUnknown(), diags
	}

	modelVal, ok := modelAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`model expected to be basetypes.StringValue, was: %T`, modelAttribute))
	}

	modifiedTimeAttribute, ok := attributes["modified_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`modified_time is missing from object`)

		return NewDeviceApStatsValueUnknown(), diags
	}

	modifiedTimeVal, ok := modifiedTimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`modified_time expected to be basetypes.Int64Value, was: %T`, modifiedTimeAttribute))
	}

	mountAttribute, ok := attributes["mount"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mount is missing from object`)

		return NewDeviceApStatsValueUnknown(), diags
	}

	mountVal, ok := mountAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mount expected to be basetypes.StringValue, was: %T`, mountAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewDeviceApStatsValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	notesAttribute, ok := attributes["notes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`notes is missing from object`)

		return NewDeviceApStatsValueUnknown(), diags
	}

	notesVal, ok := notesAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`notes expected to be basetypes.StringValue, was: %T`, notesAttribute))
	}

	numClientsAttribute, ok := attributes["num_clients"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`num_clients is missing from object`)

		return NewDeviceApStatsValueUnknown(), diags
	}

	numClientsVal, ok := numClientsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`num_clients expected to be basetypes.Int64Value, was: %T`, numClientsAttribute))
	}

	orgIdAttribute, ok := attributes["org_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`org_id is missing from object`)

		return NewDeviceApStatsValueUnknown(), diags
	}

	orgIdVal, ok := orgIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`org_id expected to be basetypes.StringValue, was: %T`, orgIdAttribute))
	}

	portStatAttribute, ok := attributes["port_stat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_stat is missing from object`)

		return NewDeviceApStatsValueUnknown(), diags
	}

	portStatVal, ok := portStatAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_stat expected to be basetypes.MapValue, was: %T`, portStatAttribute))
	}

	powerBudgetAttribute, ok := attributes["power_budget"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`power_budget is missing from object`)

		return NewDeviceApStatsValueUnknown(), diags
	}

	powerBudgetVal, ok := powerBudgetAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`power_budget expected to be basetypes.Int64Value, was: %T`, powerBudgetAttribute))
	}

	powerConstrainedAttribute, ok := attributes["power_constrained"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`power_constrained is missing from object`)

		return NewDeviceApStatsValueUnknown(), diags
	}

	powerConstrainedVal, ok := powerConstrainedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`power_constrained expected to be basetypes.BoolValue, was: %T`, powerConstrainedAttribute))
	}

	powerOpmodeAttribute, ok := attributes["power_opmode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`power_opmode is missing from object`)

		return NewDeviceApStatsValueUnknown(), diags
	}

	powerOpmodeVal, ok := powerOpmodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`power_opmode expected to be basetypes.StringValue, was: %T`, powerOpmodeAttribute))
	}

	powerSrcAttribute, ok := attributes["power_src"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`power_src is missing from object`)

		return NewDeviceApStatsValueUnknown(), diags
	}

	powerSrcVal, ok := powerSrcAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`power_src expected to be basetypes.StringValue, was: %T`, powerSrcAttribute))
	}

	radioStatAttribute, ok := attributes["radio_stat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`radio_stat is missing from object`)

		return NewDeviceApStatsValueUnknown(), diags
	}

	radioStatVal, ok := radioStatAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`radio_stat expected to be basetypes.ObjectValue, was: %T`, radioStatAttribute))
	}

	rxBpsAttribute, ok := attributes["rx_bps"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rx_bps is missing from object`)

		return NewDeviceApStatsValueUnknown(), diags
	}

	rxBpsVal, ok := rxBpsAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rx_bps expected to be basetypes.NumberValue, was: %T`, rxBpsAttribute))
	}

	rxBytesAttribute, ok := attributes["rx_bytes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rx_bytes is missing from object`)

		return NewDeviceApStatsValueUnknown(), diags
	}

	rxBytesVal, ok := rxBytesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rx_bytes expected to be basetypes.Int64Value, was: %T`, rxBytesAttribute))
	}

	rxPktsAttribute, ok := attributes["rx_pkts"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rx_pkts is missing from object`)

		return NewDeviceApStatsValueUnknown(), diags
	}

	rxPktsVal, ok := rxPktsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rx_pkts expected to be basetypes.Int64Value, was: %T`, rxPktsAttribute))
	}

	serialAttribute, ok := attributes["serial"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`serial is missing from object`)

		return NewDeviceApStatsValueUnknown(), diags
	}

	serialVal, ok := serialAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`serial expected to be basetypes.StringValue, was: %T`, serialAttribute))
	}

	siteIdAttribute, ok := attributes["site_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`site_id is missing from object`)

		return NewDeviceApStatsValueUnknown(), diags
	}

	siteIdVal, ok := siteIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`site_id expected to be basetypes.StringValue, was: %T`, siteIdAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return NewDeviceApStatsValueUnknown(), diags
	}

	statusVal, ok := statusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be basetypes.StringValue, was: %T`, statusAttribute))
	}

	switchRedundancyAttribute, ok := attributes["switch_redundancy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`switch_redundancy is missing from object`)

		return NewDeviceApStatsValueUnknown(), diags
	}

	switchRedundancyVal, ok := switchRedundancyAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`switch_redundancy expected to be basetypes.ObjectValue, was: %T`, switchRedundancyAttribute))
	}

	txBpsAttribute, ok := attributes["tx_bps"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tx_bps is missing from object`)

		return NewDeviceApStatsValueUnknown(), diags
	}

	txBpsVal, ok := txBpsAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tx_bps expected to be basetypes.NumberValue, was: %T`, txBpsAttribute))
	}

	txBytesAttribute, ok := attributes["tx_bytes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tx_bytes is missing from object`)

		return NewDeviceApStatsValueUnknown(), diags
	}

	txBytesVal, ok := txBytesAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tx_bytes expected to be basetypes.NumberValue, was: %T`, txBytesAttribute))
	}

	txPktsAttribute, ok := attributes["tx_pkts"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tx_pkts is missing from object`)

		return NewDeviceApStatsValueUnknown(), diags
	}

	txPktsVal, ok := txPktsAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tx_pkts expected to be basetypes.NumberValue, was: %T`, txPktsAttribute))
	}

	uptimeAttribute, ok := attributes["uptime"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uptime is missing from object`)

		return NewDeviceApStatsValueUnknown(), diags
	}

	uptimeVal, ok := uptimeAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uptime expected to be basetypes.NumberValue, was: %T`, uptimeAttribute))
	}

	usbStatAttribute, ok := attributes["usb_stat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`usb_stat is missing from object`)

		return NewDeviceApStatsValueUnknown(), diags
	}

	usbStatVal, ok := usbStatAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`usb_stat expected to be basetypes.ObjectValue, was: %T`, usbStatAttribute))
	}

	versionAttribute, ok := attributes["version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`version is missing from object`)

		return NewDeviceApStatsValueUnknown(), diags
	}

	versionVal, ok := versionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`version expected to be basetypes.StringValue, was: %T`, versionAttribute))
	}

	xAttribute, ok := attributes["x"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`x is missing from object`)

		return NewDeviceApStatsValueUnknown(), diags
	}

	xVal, ok := xAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`x expected to be basetypes.Float64Value, was: %T`, xAttribute))
	}

	yAttribute, ok := attributes["y"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`y is missing from object`)

		return NewDeviceApStatsValueUnknown(), diags
	}

	yVal, ok := yAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`y expected to be basetypes.Float64Value, was: %T`, yAttribute))
	}

	if diags.HasError() {
		return NewDeviceApStatsValueUnknown(), diags
	}

	return DeviceApStatsValue{
		AutoPlacement:      autoPlacementVal,
		AutoUpgradeStat:    autoUpgradeStatVal,
		BleStat:            bleStatVal,
		CertExpiry:         certExpiryVal,
		ConfigReverted:     configRevertedVal,
		CpuSystem:          cpuSystemVal,
		CpuUtil:            cpuUtilVal,
		CreatedTime:        createdTimeVal,
		DeviceprofileId:    deviceprofileIdVal,
		EnvStat:            envStatVal,
		EslStat:            eslStatVal,
		ExtIp:              extIpVal,
		Fwupdate:           fwupdateVal,
		HwRev:              hwRevVal,
		Id:                 idVal,
		InactiveWiredVlans: inactiveWiredVlansVal,
		IotStat:            iotStatVal,
		Ip:                 ipVal,
		IpConfig:           ipConfigVal,
		IpStat:             ipStatVal,
		L2tpStat:           l2tpStatVal,
		LastSeen:           lastSeenVal,
		LastTrouble:        lastTroubleVal,
		Led:                ledVal,
		LldpStat:           lldpStatVal,
		Locating:           locatingVal,
		Locked:             lockedVal,
		Mac:                macVal,
		MapId:              mapIdVal,
		MemUsedKb:          memUsedKbVal,
		MeshDownlinks:      meshDownlinksVal,
		MeshUplink:         meshUplinkVal,
		Model:              modelVal,
		ModifiedTime:       modifiedTimeVal,
		Mount:              mountVal,
		Name:               nameVal,
		Notes:              notesVal,
		NumClients:         numClientsVal,
		OrgId:              orgIdVal,
		PortStat:           portStatVal,
		PowerBudget:        powerBudgetVal,
		PowerConstrained:   powerConstrainedVal,
		PowerOpmode:        powerOpmodeVal,
		PowerSrc:           powerSrcVal,
		RadioStat:          radioStatVal,
		RxBps:              rxBpsVal,
		RxBytes:            rxBytesVal,
		RxPkts:             rxPktsVal,
		Serial:             serialVal,
		SiteId:             siteIdVal,
		Status:             statusVal,
		SwitchRedundancy:   switchRedundancyVal,
		TxBps:              txBpsVal,
		TxBytes:            txBytesVal,
		TxPkts:             txPktsVal,
		Uptime:             uptimeVal,
		UsbStat:            usbStatVal,
		Version:            versionVal,
		X:                  xVal,
		Y:                  yVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewDeviceApStatsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) DeviceApStatsValue {
	object, diags := NewDeviceApStatsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewDeviceApStatsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t DeviceApStatsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewDeviceApStatsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewDeviceApStatsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewDeviceApStatsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewDeviceApStatsValueMust(DeviceApStatsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t DeviceApStatsType) ValueType(ctx context.Context) attr.Value {
	return DeviceApStatsValue{}
}

var _ basetypes.ObjectValuable = DeviceApStatsValue{}

type DeviceApStatsValue struct {
	AutoPlacement      basetypes.ObjectValue  `tfsdk:"auto_placement"`
	AutoUpgradeStat    basetypes.ObjectValue  `tfsdk:"auto_upgrade_stat"`
	BleStat            basetypes.ObjectValue  `tfsdk:"ble_stat"`
	CertExpiry         basetypes.NumberValue  `tfsdk:"cert_expiry"`
	ConfigReverted     basetypes.BoolValue    `tfsdk:"config_reverted"`
	CpuSystem          basetypes.Int64Value   `tfsdk:"cpu_system"`
	CpuUtil            basetypes.Int64Value   `tfsdk:"cpu_util"`
	CreatedTime        basetypes.Int64Value   `tfsdk:"created_time"`
	DeviceprofileId    basetypes.StringValue  `tfsdk:"deviceprofile_id"`
	EnvStat            basetypes.ObjectValue  `tfsdk:"env_stat"`
	EslStat            basetypes.ObjectValue  `tfsdk:"esl_stat"`
	ExtIp              basetypes.StringValue  `tfsdk:"ext_ip"`
	Fwupdate           basetypes.ObjectValue  `tfsdk:"fwupdate"`
	HwRev              basetypes.StringValue  `tfsdk:"hw_rev"`
	Id                 basetypes.StringValue  `tfsdk:"id"`
	InactiveWiredVlans basetypes.ListValue    `tfsdk:"inactive_wired_vlans"`
	IotStat            basetypes.MapValue     `tfsdk:"iot_stat"`
	Ip                 basetypes.StringValue  `tfsdk:"ip"`
	IpConfig           basetypes.ObjectValue  `tfsdk:"ip_config"`
	IpStat             basetypes.ObjectValue  `tfsdk:"ip_stat"`
	L2tpStat           basetypes.MapValue     `tfsdk:"l2tp_stat"`
	LastSeen           basetypes.NumberValue  `tfsdk:"last_seen"`
	LastTrouble        basetypes.ObjectValue  `tfsdk:"last_trouble"`
	Led                basetypes.ObjectValue  `tfsdk:"led"`
	LldpStat           basetypes.ObjectValue  `tfsdk:"lldp_stat"`
	Locating           basetypes.BoolValue    `tfsdk:"locating"`
	Locked             basetypes.BoolValue    `tfsdk:"locked"`
	Mac                basetypes.StringValue  `tfsdk:"mac"`
	MapId              basetypes.StringValue  `tfsdk:"map_id"`
	MemUsedKb          basetypes.Int64Value   `tfsdk:"mem_used_kb"`
	MeshDownlinks      basetypes.MapValue     `tfsdk:"mesh_downlinks"`
	MeshUplink         basetypes.ObjectValue  `tfsdk:"mesh_uplink"`
	Model              basetypes.StringValue  `tfsdk:"model"`
	ModifiedTime       basetypes.Int64Value   `tfsdk:"modified_time"`
	Mount              basetypes.StringValue  `tfsdk:"mount"`
	Name               basetypes.StringValue  `tfsdk:"name"`
	Notes              basetypes.StringValue  `tfsdk:"notes"`
	NumClients         basetypes.Int64Value   `tfsdk:"num_clients"`
	OrgId              basetypes.StringValue  `tfsdk:"org_id"`
	PortStat           basetypes.MapValue     `tfsdk:"port_stat"`
	PowerBudget        basetypes.Int64Value   `tfsdk:"power_budget"`
	PowerConstrained   basetypes.BoolValue    `tfsdk:"power_constrained"`
	PowerOpmode        basetypes.StringValue  `tfsdk:"power_opmode"`
	PowerSrc           basetypes.StringValue  `tfsdk:"power_src"`
	RadioStat          basetypes.ObjectValue  `tfsdk:"radio_stat"`
	RxBps              basetypes.NumberValue  `tfsdk:"rx_bps"`
	RxBytes            basetypes.Int64Value   `tfsdk:"rx_bytes"`
	RxPkts             basetypes.Int64Value   `tfsdk:"rx_pkts"`
	Serial             basetypes.StringValue  `tfsdk:"serial"`
	SiteId             basetypes.StringValue  `tfsdk:"site_id"`
	Status             basetypes.StringValue  `tfsdk:"status"`
	SwitchRedundancy   basetypes.ObjectValue  `tfsdk:"switch_redundancy"`
	TxBps              basetypes.NumberValue  `tfsdk:"tx_bps"`
	TxBytes            basetypes.NumberValue  `tfsdk:"tx_bytes"`
	TxPkts             basetypes.NumberValue  `tfsdk:"tx_pkts"`
	Uptime             basetypes.NumberValue  `tfsdk:"uptime"`
	UsbStat            basetypes.ObjectValue  `tfsdk:"usb_stat"`
	Version            basetypes.StringValue  `tfsdk:"version"`
	X                  basetypes.Float64Value `tfsdk:"x"`
	Y                  basetypes.Float64Value `tfsdk:"y"`
	state              attr.ValueState
}

func (v DeviceApStatsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 60)

	var val tftypes.Value
	var err error

	attrTypes["auto_placement"] = basetypes.ObjectType{
		AttrTypes: AutoPlacementValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["auto_upgrade_stat"] = basetypes.ObjectType{
		AttrTypes: AutoUpgradeStatValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["ble_stat"] = basetypes.ObjectType{
		AttrTypes: BleStatValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["cert_expiry"] = basetypes.NumberType{}.TerraformType(ctx)
	attrTypes["config_reverted"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["cpu_system"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["cpu_util"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["created_time"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["deviceprofile_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["env_stat"] = basetypes.ObjectType{
		AttrTypes: EnvStatValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["esl_stat"] = basetypes.ObjectType{
		AttrTypes: EslStatValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["ext_ip"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["fwupdate"] = basetypes.ObjectType{
		AttrTypes: FwupdateValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["hw_rev"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["inactive_wired_vlans"] = basetypes.ListType{
		ElemType: types.Int64Type,
	}.TerraformType(ctx)
	attrTypes["iot_stat"] = basetypes.MapType{
		ElemType: IotStatValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["ip"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ip_config"] = basetypes.ObjectType{
		AttrTypes: IpConfigValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["ip_stat"] = basetypes.ObjectType{
		AttrTypes: IpStatValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["l2tp_stat"] = basetypes.MapType{
		ElemType: L2tpStatValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["last_seen"] = basetypes.NumberType{}.TerraformType(ctx)
	attrTypes["last_trouble"] = basetypes.ObjectType{
		AttrTypes: LastTroubleValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["led"] = basetypes.ObjectType{
		AttrTypes: LedValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["lldp_stat"] = basetypes.ObjectType{
		AttrTypes: LldpStatValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["locating"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["locked"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["mac"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["map_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["mem_used_kb"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["mesh_downlinks"] = basetypes.MapType{
		ElemType: MeshDownlinksValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["mesh_uplink"] = basetypes.ObjectType{
		AttrTypes: MeshUplinkValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["model"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["modified_time"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["mount"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["notes"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["num_clients"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["org_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["port_stat"] = basetypes.MapType{
		ElemType: PortStatValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["power_budget"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["power_constrained"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["power_opmode"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["power_src"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["radio_stat"] = basetypes.ObjectType{
		AttrTypes: RadioStatValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["rx_bps"] = basetypes.NumberType{}.TerraformType(ctx)
	attrTypes["rx_bytes"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["rx_pkts"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["serial"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["site_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["status"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["switch_redundancy"] = basetypes.ObjectType{
		AttrTypes: SwitchRedundancyValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["tx_bps"] = basetypes.NumberType{}.TerraformType(ctx)
	attrTypes["tx_bytes"] = basetypes.NumberType{}.TerraformType(ctx)
	attrTypes["tx_pkts"] = basetypes.NumberType{}.TerraformType(ctx)
	attrTypes["uptime"] = basetypes.NumberType{}.TerraformType(ctx)
	attrTypes["usb_stat"] = basetypes.ObjectType{
		AttrTypes: UsbStatValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["version"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["x"] = basetypes.Float64Type{}.TerraformType(ctx)
	attrTypes["y"] = basetypes.Float64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 60)

		val, err = v.AutoPlacement.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["auto_placement"] = val

		val, err = v.AutoUpgradeStat.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["auto_upgrade_stat"] = val

		val, err = v.BleStat.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ble_stat"] = val

		val, err = v.CertExpiry.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cert_expiry"] = val

		val, err = v.ConfigReverted.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["config_reverted"] = val

		val, err = v.CpuSystem.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cpu_system"] = val

		val, err = v.CpuUtil.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cpu_util"] = val

		val, err = v.CreatedTime.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["created_time"] = val

		val, err = v.DeviceprofileId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["deviceprofile_id"] = val

		val, err = v.EnvStat.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["env_stat"] = val

		val, err = v.EslStat.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["esl_stat"] = val

		val, err = v.ExtIp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ext_ip"] = val

		val, err = v.Fwupdate.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["fwupdate"] = val

		val, err = v.HwRev.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["hw_rev"] = val

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.InactiveWiredVlans.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["inactive_wired_vlans"] = val

		val, err = v.IotStat.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["iot_stat"] = val

		val, err = v.Ip.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip"] = val

		val, err = v.IpConfig.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip_config"] = val

		val, err = v.IpStat.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip_stat"] = val

		val, err = v.L2tpStat.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["l2tp_stat"] = val

		val, err = v.LastSeen.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["last_seen"] = val

		val, err = v.LastTrouble.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["last_trouble"] = val

		val, err = v.Led.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["led"] = val

		val, err = v.LldpStat.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["lldp_stat"] = val

		val, err = v.Locating.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["locating"] = val

		val, err = v.Locked.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["locked"] = val

		val, err = v.Mac.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mac"] = val

		val, err = v.MapId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["map_id"] = val

		val, err = v.MemUsedKb.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mem_used_kb"] = val

		val, err = v.MeshDownlinks.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mesh_downlinks"] = val

		val, err = v.MeshUplink.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mesh_uplink"] = val

		val, err = v.Model.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["model"] = val

		val, err = v.ModifiedTime.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["modified_time"] = val

		val, err = v.Mount.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mount"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Notes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["notes"] = val

		val, err = v.NumClients.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["num_clients"] = val

		val, err = v.OrgId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["org_id"] = val

		val, err = v.PortStat.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port_stat"] = val

		val, err = v.PowerBudget.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["power_budget"] = val

		val, err = v.PowerConstrained.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["power_constrained"] = val

		val, err = v.PowerOpmode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["power_opmode"] = val

		val, err = v.PowerSrc.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["power_src"] = val

		val, err = v.RadioStat.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["radio_stat"] = val

		val, err = v.RxBps.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["rx_bps"] = val

		val, err = v.RxBytes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["rx_bytes"] = val

		val, err = v.RxPkts.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["rx_pkts"] = val

		val, err = v.Serial.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["serial"] = val

		val, err = v.SiteId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["site_id"] = val

		val, err = v.Status.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["status"] = val

		val, err = v.SwitchRedundancy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["switch_redundancy"] = val

		val, err = v.TxBps.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tx_bps"] = val

		val, err = v.TxBytes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tx_bytes"] = val

		val, err = v.TxPkts.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tx_pkts"] = val

		val, err = v.Uptime.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["uptime"] = val

		val, err = v.UsbStat.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["usb_stat"] = val

		val, err = v.Version.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["version"] = val

		val, err = v.X.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["x"] = val

		val, err = v.Y.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["y"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v DeviceApStatsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v DeviceApStatsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v DeviceApStatsValue) String() string {
	return "DeviceApStatsValue"
}

func (v DeviceApStatsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var autoPlacement basetypes.ObjectValue

	if v.AutoPlacement.IsNull() {
		autoPlacement = types.ObjectNull(
			AutoPlacementValue{}.AttributeTypes(ctx),
		)
	}

	if v.AutoPlacement.IsUnknown() {
		autoPlacement = types.ObjectUnknown(
			AutoPlacementValue{}.AttributeTypes(ctx),
		)
	}

	if !v.AutoPlacement.IsNull() && !v.AutoPlacement.IsUnknown() {
		autoPlacement = types.ObjectValueMust(
			AutoPlacementValue{}.AttributeTypes(ctx),
			v.AutoPlacement.Attributes(),
		)
	}

	var autoUpgradeStat basetypes.ObjectValue

	if v.AutoUpgradeStat.IsNull() {
		autoUpgradeStat = types.ObjectNull(
			AutoUpgradeStatValue{}.AttributeTypes(ctx),
		)
	}

	if v.AutoUpgradeStat.IsUnknown() {
		autoUpgradeStat = types.ObjectUnknown(
			AutoUpgradeStatValue{}.AttributeTypes(ctx),
		)
	}

	if !v.AutoUpgradeStat.IsNull() && !v.AutoUpgradeStat.IsUnknown() {
		autoUpgradeStat = types.ObjectValueMust(
			AutoUpgradeStatValue{}.AttributeTypes(ctx),
			v.AutoUpgradeStat.Attributes(),
		)
	}

	var bleStat basetypes.ObjectValue

	if v.BleStat.IsNull() {
		bleStat = types.ObjectNull(
			BleStatValue{}.AttributeTypes(ctx),
		)
	}

	if v.BleStat.IsUnknown() {
		bleStat = types.ObjectUnknown(
			BleStatValue{}.AttributeTypes(ctx),
		)
	}

	if !v.BleStat.IsNull() && !v.BleStat.IsUnknown() {
		bleStat = types.ObjectValueMust(
			BleStatValue{}.AttributeTypes(ctx),
			v.BleStat.Attributes(),
		)
	}

	var envStat basetypes.ObjectValue

	if v.EnvStat.IsNull() {
		envStat = types.ObjectNull(
			EnvStatValue{}.AttributeTypes(ctx),
		)
	}

	if v.EnvStat.IsUnknown() {
		envStat = types.ObjectUnknown(
			EnvStatValue{}.AttributeTypes(ctx),
		)
	}

	if !v.EnvStat.IsNull() && !v.EnvStat.IsUnknown() {
		envStat = types.ObjectValueMust(
			EnvStatValue{}.AttributeTypes(ctx),
			v.EnvStat.Attributes(),
		)
	}

	var eslStat basetypes.ObjectValue

	if v.EslStat.IsNull() {
		eslStat = types.ObjectNull(
			EslStatValue{}.AttributeTypes(ctx),
		)
	}

	if v.EslStat.IsUnknown() {
		eslStat = types.ObjectUnknown(
			EslStatValue{}.AttributeTypes(ctx),
		)
	}

	if !v.EslStat.IsNull() && !v.EslStat.IsUnknown() {
		eslStat = types.ObjectValueMust(
			EslStatValue{}.AttributeTypes(ctx),
			v.EslStat.Attributes(),
		)
	}

	var fwupdate basetypes.ObjectValue

	if v.Fwupdate.IsNull() {
		fwupdate = types.ObjectNull(
			FwupdateValue{}.AttributeTypes(ctx),
		)
	}

	if v.Fwupdate.IsUnknown() {
		fwupdate = types.ObjectUnknown(
			FwupdateValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Fwupdate.IsNull() && !v.Fwupdate.IsUnknown() {
		fwupdate = types.ObjectValueMust(
			FwupdateValue{}.AttributeTypes(ctx),
			v.Fwupdate.Attributes(),
		)
	}

	iotStat := types.MapValueMust(
		IotStatType{
			basetypes.ObjectType{
				AttrTypes: IotStatValue{}.AttributeTypes(ctx),
			},
		},
		v.IotStat.Elements(),
	)

	if v.IotStat.IsNull() {
		iotStat = types.MapNull(
			IotStatType{
				basetypes.ObjectType{
					AttrTypes: IotStatValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.IotStat.IsUnknown() {
		iotStat = types.MapUnknown(
			IotStatType{
				basetypes.ObjectType{
					AttrTypes: IotStatValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var ipConfig basetypes.ObjectValue

	if v.IpConfig.IsNull() {
		ipConfig = types.ObjectNull(
			IpConfigValue{}.AttributeTypes(ctx),
		)
	}

	if v.IpConfig.IsUnknown() {
		ipConfig = types.ObjectUnknown(
			IpConfigValue{}.AttributeTypes(ctx),
		)
	}

	if !v.IpConfig.IsNull() && !v.IpConfig.IsUnknown() {
		ipConfig = types.ObjectValueMust(
			IpConfigValue{}.AttributeTypes(ctx),
			v.IpConfig.Attributes(),
		)
	}

	var ipStat basetypes.ObjectValue

	if v.IpStat.IsNull() {
		ipStat = types.ObjectNull(
			IpStatValue{}.AttributeTypes(ctx),
		)
	}

	if v.IpStat.IsUnknown() {
		ipStat = types.ObjectUnknown(
			IpStatValue{}.AttributeTypes(ctx),
		)
	}

	if !v.IpStat.IsNull() && !v.IpStat.IsUnknown() {
		ipStat = types.ObjectValueMust(
			IpStatValue{}.AttributeTypes(ctx),
			v.IpStat.Attributes(),
		)
	}

	l2tpStat := types.MapValueMust(
		L2tpStatType{
			basetypes.ObjectType{
				AttrTypes: L2tpStatValue{}.AttributeTypes(ctx),
			},
		},
		v.L2tpStat.Elements(),
	)

	if v.L2tpStat.IsNull() {
		l2tpStat = types.MapNull(
			L2tpStatType{
				basetypes.ObjectType{
					AttrTypes: L2tpStatValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.L2tpStat.IsUnknown() {
		l2tpStat = types.MapUnknown(
			L2tpStatType{
				basetypes.ObjectType{
					AttrTypes: L2tpStatValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var lastTrouble basetypes.ObjectValue

	if v.LastTrouble.IsNull() {
		lastTrouble = types.ObjectNull(
			LastTroubleValue{}.AttributeTypes(ctx),
		)
	}

	if v.LastTrouble.IsUnknown() {
		lastTrouble = types.ObjectUnknown(
			LastTroubleValue{}.AttributeTypes(ctx),
		)
	}

	if !v.LastTrouble.IsNull() && !v.LastTrouble.IsUnknown() {
		lastTrouble = types.ObjectValueMust(
			LastTroubleValue{}.AttributeTypes(ctx),
			v.LastTrouble.Attributes(),
		)
	}

	var led basetypes.ObjectValue

	if v.Led.IsNull() {
		led = types.ObjectNull(
			LedValue{}.AttributeTypes(ctx),
		)
	}

	if v.Led.IsUnknown() {
		led = types.ObjectUnknown(
			LedValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Led.IsNull() && !v.Led.IsUnknown() {
		led = types.ObjectValueMust(
			LedValue{}.AttributeTypes(ctx),
			v.Led.Attributes(),
		)
	}

	var lldpStat basetypes.ObjectValue

	if v.LldpStat.IsNull() {
		lldpStat = types.ObjectNull(
			LldpStatValue{}.AttributeTypes(ctx),
		)
	}

	if v.LldpStat.IsUnknown() {
		lldpStat = types.ObjectUnknown(
			LldpStatValue{}.AttributeTypes(ctx),
		)
	}

	if !v.LldpStat.IsNull() && !v.LldpStat.IsUnknown() {
		lldpStat = types.ObjectValueMust(
			LldpStatValue{}.AttributeTypes(ctx),
			v.LldpStat.Attributes(),
		)
	}

	meshDownlinks := types.MapValueMust(
		MeshDownlinksType{
			basetypes.ObjectType{
				AttrTypes: MeshDownlinksValue{}.AttributeTypes(ctx),
			},
		},
		v.MeshDownlinks.Elements(),
	)

	if v.MeshDownlinks.IsNull() {
		meshDownlinks = types.MapNull(
			MeshDownlinksType{
				basetypes.ObjectType{
					AttrTypes: MeshDownlinksValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.MeshDownlinks.IsUnknown() {
		meshDownlinks = types.MapUnknown(
			MeshDownlinksType{
				basetypes.ObjectType{
					AttrTypes: MeshDownlinksValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var meshUplink basetypes.ObjectValue

	if v.MeshUplink.IsNull() {
		meshUplink = types.ObjectNull(
			MeshUplinkValue{}.AttributeTypes(ctx),
		)
	}

	if v.MeshUplink.IsUnknown() {
		meshUplink = types.ObjectUnknown(
			MeshUplinkValue{}.AttributeTypes(ctx),
		)
	}

	if !v.MeshUplink.IsNull() && !v.MeshUplink.IsUnknown() {
		meshUplink = types.ObjectValueMust(
			MeshUplinkValue{}.AttributeTypes(ctx),
			v.MeshUplink.Attributes(),
		)
	}

	portStat := types.MapValueMust(
		PortStatType{
			basetypes.ObjectType{
				AttrTypes: PortStatValue{}.AttributeTypes(ctx),
			},
		},
		v.PortStat.Elements(),
	)

	if v.PortStat.IsNull() {
		portStat = types.MapNull(
			PortStatType{
				basetypes.ObjectType{
					AttrTypes: PortStatValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.PortStat.IsUnknown() {
		portStat = types.MapUnknown(
			PortStatType{
				basetypes.ObjectType{
					AttrTypes: PortStatValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var radioStat basetypes.ObjectValue

	if v.RadioStat.IsNull() {
		radioStat = types.ObjectNull(
			RadioStatValue{}.AttributeTypes(ctx),
		)
	}

	if v.RadioStat.IsUnknown() {
		radioStat = types.ObjectUnknown(
			RadioStatValue{}.AttributeTypes(ctx),
		)
	}

	if !v.RadioStat.IsNull() && !v.RadioStat.IsUnknown() {
		radioStat = types.ObjectValueMust(
			RadioStatValue{}.AttributeTypes(ctx),
			v.RadioStat.Attributes(),
		)
	}

	var switchRedundancy basetypes.ObjectValue

	if v.SwitchRedundancy.IsNull() {
		switchRedundancy = types.ObjectNull(
			SwitchRedundancyValue{}.AttributeTypes(ctx),
		)
	}

	if v.SwitchRedundancy.IsUnknown() {
		switchRedundancy = types.ObjectUnknown(
			SwitchRedundancyValue{}.AttributeTypes(ctx),
		)
	}

	if !v.SwitchRedundancy.IsNull() && !v.SwitchRedundancy.IsUnknown() {
		switchRedundancy = types.ObjectValueMust(
			SwitchRedundancyValue{}.AttributeTypes(ctx),
			v.SwitchRedundancy.Attributes(),
		)
	}

	var usbStat basetypes.ObjectValue

	if v.UsbStat.IsNull() {
		usbStat = types.ObjectNull(
			UsbStatValue{}.AttributeTypes(ctx),
		)
	}

	if v.UsbStat.IsUnknown() {
		usbStat = types.ObjectUnknown(
			UsbStatValue{}.AttributeTypes(ctx),
		)
	}

	if !v.UsbStat.IsNull() && !v.UsbStat.IsUnknown() {
		usbStat = types.ObjectValueMust(
			UsbStatValue{}.AttributeTypes(ctx),
			v.UsbStat.Attributes(),
		)
	}

	inactiveWiredVlansVal, d := types.ListValue(types.Int64Type, v.InactiveWiredVlans.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"auto_placement": basetypes.ObjectType{
				AttrTypes: AutoPlacementValue{}.AttributeTypes(ctx),
			},
			"auto_upgrade_stat": basetypes.ObjectType{
				AttrTypes: AutoUpgradeStatValue{}.AttributeTypes(ctx),
			},
			"ble_stat": basetypes.ObjectType{
				AttrTypes: BleStatValue{}.AttributeTypes(ctx),
			},
			"cert_expiry":      basetypes.NumberType{},
			"config_reverted":  basetypes.BoolType{},
			"cpu_system":       basetypes.Int64Type{},
			"cpu_util":         basetypes.Int64Type{},
			"created_time":     basetypes.Int64Type{},
			"deviceprofile_id": basetypes.StringType{},
			"env_stat": basetypes.ObjectType{
				AttrTypes: EnvStatValue{}.AttributeTypes(ctx),
			},
			"esl_stat": basetypes.ObjectType{
				AttrTypes: EslStatValue{}.AttributeTypes(ctx),
			},
			"ext_ip": basetypes.StringType{},
			"fwupdate": basetypes.ObjectType{
				AttrTypes: FwupdateValue{}.AttributeTypes(ctx),
			},
			"hw_rev": basetypes.StringType{},
			"id":     basetypes.StringType{},
			"inactive_wired_vlans": basetypes.ListType{
				ElemType: types.Int64Type,
			},
			"iot_stat": basetypes.MapType{
				ElemType: IotStatValue{}.Type(ctx),
			},
			"ip": basetypes.StringType{},
			"ip_config": basetypes.ObjectType{
				AttrTypes: IpConfigValue{}.AttributeTypes(ctx),
			},
			"ip_stat": basetypes.ObjectType{
				AttrTypes: IpStatValue{}.AttributeTypes(ctx),
			},
			"l2tp_stat": basetypes.MapType{
				ElemType: L2tpStatValue{}.Type(ctx),
			},
			"last_seen": basetypes.NumberType{},
			"last_trouble": basetypes.ObjectType{
				AttrTypes: LastTroubleValue{}.AttributeTypes(ctx),
			},
			"led": basetypes.ObjectType{
				AttrTypes: LedValue{}.AttributeTypes(ctx),
			},
			"lldp_stat": basetypes.ObjectType{
				AttrTypes: LldpStatValue{}.AttributeTypes(ctx),
			},
			"locating":    basetypes.BoolType{},
			"locked":      basetypes.BoolType{},
			"mac":         basetypes.StringType{},
			"map_id":      basetypes.StringType{},
			"mem_used_kb": basetypes.Int64Type{},
			"mesh_downlinks": basetypes.MapType{
				ElemType: MeshDownlinksValue{}.Type(ctx),
			},
			"mesh_uplink": basetypes.ObjectType{
				AttrTypes: MeshUplinkValue{}.AttributeTypes(ctx),
			},
			"model":         basetypes.StringType{},
			"modified_time": basetypes.Int64Type{},
			"mount":         basetypes.StringType{},
			"name":          basetypes.StringType{},
			"notes":         basetypes.StringType{},
			"num_clients":   basetypes.Int64Type{},
			"org_id":        basetypes.StringType{},
			"port_stat": basetypes.MapType{
				ElemType: PortStatValue{}.Type(ctx),
			},
			"power_budget":      basetypes.Int64Type{},
			"power_constrained": basetypes.BoolType{},
			"power_opmode":      basetypes.StringType{},
			"power_src":         basetypes.StringType{},
			"radio_stat": basetypes.ObjectType{
				AttrTypes: RadioStatValue{}.AttributeTypes(ctx),
			},
			"rx_bps":   basetypes.NumberType{},
			"rx_bytes": basetypes.Int64Type{},
			"rx_pkts":  basetypes.Int64Type{},
			"serial":   basetypes.StringType{},
			"site_id":  basetypes.StringType{},
			"status":   basetypes.StringType{},
			"switch_redundancy": basetypes.ObjectType{
				AttrTypes: SwitchRedundancyValue{}.AttributeTypes(ctx),
			},
			"tx_bps":   basetypes.NumberType{},
			"tx_bytes": basetypes.NumberType{},
			"tx_pkts":  basetypes.NumberType{},
			"uptime":   basetypes.NumberType{},
			"usb_stat": basetypes.ObjectType{
				AttrTypes: UsbStatValue{}.AttributeTypes(ctx),
			},
			"version": basetypes.StringType{},
			"x":       basetypes.Float64Type{},
			"y":       basetypes.Float64Type{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"auto_placement": basetypes.ObjectType{
			AttrTypes: AutoPlacementValue{}.AttributeTypes(ctx),
		},
		"auto_upgrade_stat": basetypes.ObjectType{
			AttrTypes: AutoUpgradeStatValue{}.AttributeTypes(ctx),
		},
		"ble_stat": basetypes.ObjectType{
			AttrTypes: BleStatValue{}.AttributeTypes(ctx),
		},
		"cert_expiry":      basetypes.NumberType{},
		"config_reverted":  basetypes.BoolType{},
		"cpu_system":       basetypes.Int64Type{},
		"cpu_util":         basetypes.Int64Type{},
		"created_time":     basetypes.Int64Type{},
		"deviceprofile_id": basetypes.StringType{},
		"env_stat": basetypes.ObjectType{
			AttrTypes: EnvStatValue{}.AttributeTypes(ctx),
		},
		"esl_stat": basetypes.ObjectType{
			AttrTypes: EslStatValue{}.AttributeTypes(ctx),
		},
		"ext_ip": basetypes.StringType{},
		"fwupdate": basetypes.ObjectType{
			AttrTypes: FwupdateValue{}.AttributeTypes(ctx),
		},
		"hw_rev": basetypes.StringType{},
		"id":     basetypes.StringType{},
		"inactive_wired_vlans": basetypes.ListType{
			ElemType: types.Int64Type,
		},
		"iot_stat": basetypes.MapType{
			ElemType: IotStatValue{}.Type(ctx),
		},
		"ip": basetypes.StringType{},
		"ip_config": basetypes.ObjectType{
			AttrTypes: IpConfigValue{}.AttributeTypes(ctx),
		},
		"ip_stat": basetypes.ObjectType{
			AttrTypes: IpStatValue{}.AttributeTypes(ctx),
		},
		"l2tp_stat": basetypes.MapType{
			ElemType: L2tpStatValue{}.Type(ctx),
		},
		"last_seen": basetypes.NumberType{},
		"last_trouble": basetypes.ObjectType{
			AttrTypes: LastTroubleValue{}.AttributeTypes(ctx),
		},
		"led": basetypes.ObjectType{
			AttrTypes: LedValue{}.AttributeTypes(ctx),
		},
		"lldp_stat": basetypes.ObjectType{
			AttrTypes: LldpStatValue{}.AttributeTypes(ctx),
		},
		"locating":    basetypes.BoolType{},
		"locked":      basetypes.BoolType{},
		"mac":         basetypes.StringType{},
		"map_id":      basetypes.StringType{},
		"mem_used_kb": basetypes.Int64Type{},
		"mesh_downlinks": basetypes.MapType{
			ElemType: MeshDownlinksValue{}.Type(ctx),
		},
		"mesh_uplink": basetypes.ObjectType{
			AttrTypes: MeshUplinkValue{}.AttributeTypes(ctx),
		},
		"model":         basetypes.StringType{},
		"modified_time": basetypes.Int64Type{},
		"mount":         basetypes.StringType{},
		"name":          basetypes.StringType{},
		"notes":         basetypes.StringType{},
		"num_clients":   basetypes.Int64Type{},
		"org_id":        basetypes.StringType{},
		"port_stat": basetypes.MapType{
			ElemType: PortStatValue{}.Type(ctx),
		},
		"power_budget":      basetypes.Int64Type{},
		"power_constrained": basetypes.BoolType{},
		"power_opmode":      basetypes.StringType{},
		"power_src":         basetypes.StringType{},
		"radio_stat": basetypes.ObjectType{
			AttrTypes: RadioStatValue{}.AttributeTypes(ctx),
		},
		"rx_bps":   basetypes.NumberType{},
		"rx_bytes": basetypes.Int64Type{},
		"rx_pkts":  basetypes.Int64Type{},
		"serial":   basetypes.StringType{},
		"site_id":  basetypes.StringType{},
		"status":   basetypes.StringType{},
		"switch_redundancy": basetypes.ObjectType{
			AttrTypes: SwitchRedundancyValue{}.AttributeTypes(ctx),
		},
		"tx_bps":   basetypes.NumberType{},
		"tx_bytes": basetypes.NumberType{},
		"tx_pkts":  basetypes.NumberType{},
		"uptime":   basetypes.NumberType{},
		"usb_stat": basetypes.ObjectType{
			AttrTypes: UsbStatValue{}.AttributeTypes(ctx),
		},
		"version": basetypes.StringType{},
		"x":       basetypes.Float64Type{},
		"y":       basetypes.Float64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"auto_placement":       autoPlacement,
			"auto_upgrade_stat":    autoUpgradeStat,
			"ble_stat":             bleStat,
			"cert_expiry":          v.CertExpiry,
			"config_reverted":      v.ConfigReverted,
			"cpu_system":           v.CpuSystem,
			"cpu_util":             v.CpuUtil,
			"created_time":         v.CreatedTime,
			"deviceprofile_id":     v.DeviceprofileId,
			"env_stat":             envStat,
			"esl_stat":             eslStat,
			"ext_ip":               v.ExtIp,
			"fwupdate":             fwupdate,
			"hw_rev":               v.HwRev,
			"id":                   v.Id,
			"inactive_wired_vlans": inactiveWiredVlansVal,
			"iot_stat":             iotStat,
			"ip":                   v.Ip,
			"ip_config":            ipConfig,
			"ip_stat":              ipStat,
			"l2tp_stat":            l2tpStat,
			"last_seen":            v.LastSeen,
			"last_trouble":         lastTrouble,
			"led":                  led,
			"lldp_stat":            lldpStat,
			"locating":             v.Locating,
			"locked":               v.Locked,
			"mac":                  v.Mac,
			"map_id":               v.MapId,
			"mem_used_kb":          v.MemUsedKb,
			"mesh_downlinks":       meshDownlinks,
			"mesh_uplink":          meshUplink,
			"model":                v.Model,
			"modified_time":        v.ModifiedTime,
			"mount":                v.Mount,
			"name":                 v.Name,
			"notes":                v.Notes,
			"num_clients":          v.NumClients,
			"org_id":               v.OrgId,
			"port_stat":            portStat,
			"power_budget":         v.PowerBudget,
			"power_constrained":    v.PowerConstrained,
			"power_opmode":         v.PowerOpmode,
			"power_src":            v.PowerSrc,
			"radio_stat":           radioStat,
			"rx_bps":               v.RxBps,
			"rx_bytes":             v.RxBytes,
			"rx_pkts":              v.RxPkts,
			"serial":               v.Serial,
			"site_id":              v.SiteId,
			"status":               v.Status,
			"switch_redundancy":    switchRedundancy,
			"tx_bps":               v.TxBps,
			"tx_bytes":             v.TxBytes,
			"tx_pkts":              v.TxPkts,
			"uptime":               v.Uptime,
			"usb_stat":             usbStat,
			"version":              v.Version,
			"x":                    v.X,
			"y":                    v.Y,
		})

	return objVal, diags
}

func (v DeviceApStatsValue) Equal(o attr.Value) bool {
	other, ok := o.(DeviceApStatsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AutoPlacement.Equal(other.AutoPlacement) {
		return false
	}

	if !v.AutoUpgradeStat.Equal(other.AutoUpgradeStat) {
		return false
	}

	if !v.BleStat.Equal(other.BleStat) {
		return false
	}

	if !v.CertExpiry.Equal(other.CertExpiry) {
		return false
	}

	if !v.ConfigReverted.Equal(other.ConfigReverted) {
		return false
	}

	if !v.CpuSystem.Equal(other.CpuSystem) {
		return false
	}

	if !v.CpuUtil.Equal(other.CpuUtil) {
		return false
	}

	if !v.CreatedTime.Equal(other.CreatedTime) {
		return false
	}

	if !v.DeviceprofileId.Equal(other.DeviceprofileId) {
		return false
	}

	if !v.EnvStat.Equal(other.EnvStat) {
		return false
	}

	if !v.EslStat.Equal(other.EslStat) {
		return false
	}

	if !v.ExtIp.Equal(other.ExtIp) {
		return false
	}

	if !v.Fwupdate.Equal(other.Fwupdate) {
		return false
	}

	if !v.HwRev.Equal(other.HwRev) {
		return false
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.InactiveWiredVlans.Equal(other.InactiveWiredVlans) {
		return false
	}

	if !v.IotStat.Equal(other.IotStat) {
		return false
	}

	if !v.Ip.Equal(other.Ip) {
		return false
	}

	if !v.IpConfig.Equal(other.IpConfig) {
		return false
	}

	if !v.IpStat.Equal(other.IpStat) {
		return false
	}

	if !v.L2tpStat.Equal(other.L2tpStat) {
		return false
	}

	if !v.LastSeen.Equal(other.LastSeen) {
		return false
	}

	if !v.LastTrouble.Equal(other.LastTrouble) {
		return false
	}

	if !v.Led.Equal(other.Led) {
		return false
	}

	if !v.LldpStat.Equal(other.LldpStat) {
		return false
	}

	if !v.Locating.Equal(other.Locating) {
		return false
	}

	if !v.Locked.Equal(other.Locked) {
		return false
	}

	if !v.Mac.Equal(other.Mac) {
		return false
	}

	if !v.MapId.Equal(other.MapId) {
		return false
	}

	if !v.MemUsedKb.Equal(other.MemUsedKb) {
		return false
	}

	if !v.MeshDownlinks.Equal(other.MeshDownlinks) {
		return false
	}

	if !v.MeshUplink.Equal(other.MeshUplink) {
		return false
	}

	if !v.Model.Equal(other.Model) {
		return false
	}

	if !v.ModifiedTime.Equal(other.ModifiedTime) {
		return false
	}

	if !v.Mount.Equal(other.Mount) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Notes.Equal(other.Notes) {
		return false
	}

	if !v.NumClients.Equal(other.NumClients) {
		return false
	}

	if !v.OrgId.Equal(other.OrgId) {
		return false
	}

	if !v.PortStat.Equal(other.PortStat) {
		return false
	}

	if !v.PowerBudget.Equal(other.PowerBudget) {
		return false
	}

	if !v.PowerConstrained.Equal(other.PowerConstrained) {
		return false
	}

	if !v.PowerOpmode.Equal(other.PowerOpmode) {
		return false
	}

	if !v.PowerSrc.Equal(other.PowerSrc) {
		return false
	}

	if !v.RadioStat.Equal(other.RadioStat) {
		return false
	}

	if !v.RxBps.Equal(other.RxBps) {
		return false
	}

	if !v.RxBytes.Equal(other.RxBytes) {
		return false
	}

	if !v.RxPkts.Equal(other.RxPkts) {
		return false
	}

	if !v.Serial.Equal(other.Serial) {
		return false
	}

	if !v.SiteId.Equal(other.SiteId) {
		return false
	}

	if !v.Status.Equal(other.Status) {
		return false
	}

	if !v.SwitchRedundancy.Equal(other.SwitchRedundancy) {
		return false
	}

	if !v.TxBps.Equal(other.TxBps) {
		return false
	}

	if !v.TxBytes.Equal(other.TxBytes) {
		return false
	}

	if !v.TxPkts.Equal(other.TxPkts) {
		return false
	}

	if !v.Uptime.Equal(other.Uptime) {
		return false
	}

	if !v.UsbStat.Equal(other.UsbStat) {
		return false
	}

	if !v.Version.Equal(other.Version) {
		return false
	}

	if !v.X.Equal(other.X) {
		return false
	}

	if !v.Y.Equal(other.Y) {
		return false
	}

	return true
}

func (v DeviceApStatsValue) Type(ctx context.Context) attr.Type {
	return DeviceApStatsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v DeviceApStatsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"auto_placement": basetypes.ObjectType{
			AttrTypes: AutoPlacementValue{}.AttributeTypes(ctx),
		},
		"auto_upgrade_stat": basetypes.ObjectType{
			AttrTypes: AutoUpgradeStatValue{}.AttributeTypes(ctx),
		},
		"ble_stat": basetypes.ObjectType{
			AttrTypes: BleStatValue{}.AttributeTypes(ctx),
		},
		"cert_expiry":      basetypes.NumberType{},
		"config_reverted":  basetypes.BoolType{},
		"cpu_system":       basetypes.Int64Type{},
		"cpu_util":         basetypes.Int64Type{},
		"created_time":     basetypes.Int64Type{},
		"deviceprofile_id": basetypes.StringType{},
		"env_stat": basetypes.ObjectType{
			AttrTypes: EnvStatValue{}.AttributeTypes(ctx),
		},
		"esl_stat": basetypes.ObjectType{
			AttrTypes: EslStatValue{}.AttributeTypes(ctx),
		},
		"ext_ip": basetypes.StringType{},
		"fwupdate": basetypes.ObjectType{
			AttrTypes: FwupdateValue{}.AttributeTypes(ctx),
		},
		"hw_rev": basetypes.StringType{},
		"id":     basetypes.StringType{},
		"inactive_wired_vlans": basetypes.ListType{
			ElemType: types.Int64Type,
		},
		"iot_stat": basetypes.MapType{
			ElemType: IotStatValue{}.Type(ctx),
		},
		"ip": basetypes.StringType{},
		"ip_config": basetypes.ObjectType{
			AttrTypes: IpConfigValue{}.AttributeTypes(ctx),
		},
		"ip_stat": basetypes.ObjectType{
			AttrTypes: IpStatValue{}.AttributeTypes(ctx),
		},
		"l2tp_stat": basetypes.MapType{
			ElemType: L2tpStatValue{}.Type(ctx),
		},
		"last_seen": basetypes.NumberType{},
		"last_trouble": basetypes.ObjectType{
			AttrTypes: LastTroubleValue{}.AttributeTypes(ctx),
		},
		"led": basetypes.ObjectType{
			AttrTypes: LedValue{}.AttributeTypes(ctx),
		},
		"lldp_stat": basetypes.ObjectType{
			AttrTypes: LldpStatValue{}.AttributeTypes(ctx),
		},
		"locating":    basetypes.BoolType{},
		"locked":      basetypes.BoolType{},
		"mac":         basetypes.StringType{},
		"map_id":      basetypes.StringType{},
		"mem_used_kb": basetypes.Int64Type{},
		"mesh_downlinks": basetypes.MapType{
			ElemType: MeshDownlinksValue{}.Type(ctx),
		},
		"mesh_uplink": basetypes.ObjectType{
			AttrTypes: MeshUplinkValue{}.AttributeTypes(ctx),
		},
		"model":         basetypes.StringType{},
		"modified_time": basetypes.Int64Type{},
		"mount":         basetypes.StringType{},
		"name":          basetypes.StringType{},
		"notes":         basetypes.StringType{},
		"num_clients":   basetypes.Int64Type{},
		"org_id":        basetypes.StringType{},
		"port_stat": basetypes.MapType{
			ElemType: PortStatValue{}.Type(ctx),
		},
		"power_budget":      basetypes.Int64Type{},
		"power_constrained": basetypes.BoolType{},
		"power_opmode":      basetypes.StringType{},
		"power_src":         basetypes.StringType{},
		"radio_stat": basetypes.ObjectType{
			AttrTypes: RadioStatValue{}.AttributeTypes(ctx),
		},
		"rx_bps":   basetypes.NumberType{},
		"rx_bytes": basetypes.Int64Type{},
		"rx_pkts":  basetypes.Int64Type{},
		"serial":   basetypes.StringType{},
		"site_id":  basetypes.StringType{},
		"status":   basetypes.StringType{},
		"switch_redundancy": basetypes.ObjectType{
			AttrTypes: SwitchRedundancyValue{}.AttributeTypes(ctx),
		},
		"tx_bps":   basetypes.NumberType{},
		"tx_bytes": basetypes.NumberType{},
		"tx_pkts":  basetypes.NumberType{},
		"uptime":   basetypes.NumberType{},
		"usb_stat": basetypes.ObjectType{
			AttrTypes: UsbStatValue{}.AttributeTypes(ctx),
		},
		"version": basetypes.StringType{},
		"x":       basetypes.Float64Type{},
		"y":       basetypes.Float64Type{},
	}
}

var _ basetypes.ObjectTypable = AutoPlacementType{}

type AutoPlacementType struct {
	basetypes.ObjectType
}

func (t AutoPlacementType) Equal(o attr.Type) bool {
	other, ok := o.(AutoPlacementType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AutoPlacementType) String() string {
	return "AutoPlacementType"
}

func (t AutoPlacementType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	infoAttribute, ok := attributes["info"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`info is missing from object`)

		return nil, diags
	}

	infoVal, ok := infoAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`info expected to be basetypes.ObjectValue, was: %T`, infoAttribute))
	}

	recommendedAnchorAttribute, ok := attributes["recommended_anchor"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`recommended_anchor is missing from object`)

		return nil, diags
	}

	recommendedAnchorVal, ok := recommendedAnchorAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`recommended_anchor expected to be basetypes.BoolValue, was: %T`, recommendedAnchorAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return nil, diags
	}

	statusVal, ok := statusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be basetypes.StringValue, was: %T`, statusAttribute))
	}

	statusDetailAttribute, ok := attributes["status_detail"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status_detail is missing from object`)

		return nil, diags
	}

	statusDetailVal, ok := statusDetailAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status_detail expected to be basetypes.StringValue, was: %T`, statusDetailAttribute))
	}

	useAutoPlacementAttribute, ok := attributes["use_auto_placement"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`use_auto_placement is missing from object`)

		return nil, diags
	}

	useAutoPlacementVal, ok := useAutoPlacementAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`use_auto_placement expected to be basetypes.BoolValue, was: %T`, useAutoPlacementAttribute))
	}

	xAttribute, ok := attributes["x"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`x is missing from object`)

		return nil, diags
	}

	xVal, ok := xAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`x expected to be basetypes.Float64Value, was: %T`, xAttribute))
	}

	xMAttribute, ok := attributes["x_m"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`x_m is missing from object`)

		return nil, diags
	}

	xMVal, ok := xMAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`x_m expected to be basetypes.Float64Value, was: %T`, xMAttribute))
	}

	yAttribute, ok := attributes["y"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`y is missing from object`)

		return nil, diags
	}

	yVal, ok := yAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`y expected to be basetypes.Float64Value, was: %T`, yAttribute))
	}

	yMAttribute, ok := attributes["y_m"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`y_m is missing from object`)

		return nil, diags
	}

	yMVal, ok := yMAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`y_m expected to be basetypes.Float64Value, was: %T`, yMAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AutoPlacementValue{
		Info:              infoVal,
		RecommendedAnchor: recommendedAnchorVal,
		Status:            statusVal,
		StatusDetail:      statusDetailVal,
		UseAutoPlacement:  useAutoPlacementVal,
		X:                 xVal,
		XM:                xMVal,
		Y:                 yVal,
		YM:                yMVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewAutoPlacementValueNull() AutoPlacementValue {
	return AutoPlacementValue{
		state: attr.ValueStateNull,
	}
}

func NewAutoPlacementValueUnknown() AutoPlacementValue {
	return AutoPlacementValue{
		state: attr.ValueStateUnknown,
	}
}

func NewAutoPlacementValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AutoPlacementValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AutoPlacementValue Attribute Value",
				"While creating a AutoPlacementValue value, a missing attribute value was detected. "+
					"A AutoPlacementValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AutoPlacementValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AutoPlacementValue Attribute Type",
				"While creating a AutoPlacementValue value, an invalid attribute value was detected. "+
					"A AutoPlacementValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AutoPlacementValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AutoPlacementValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AutoPlacementValue Attribute Value",
				"While creating a AutoPlacementValue value, an extra attribute value was detected. "+
					"A AutoPlacementValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AutoPlacementValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAutoPlacementValueUnknown(), diags
	}

	infoAttribute, ok := attributes["info"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`info is missing from object`)

		return NewAutoPlacementValueUnknown(), diags
	}

	infoVal, ok := infoAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`info expected to be basetypes.ObjectValue, was: %T`, infoAttribute))
	}

	recommendedAnchorAttribute, ok := attributes["recommended_anchor"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`recommended_anchor is missing from object`)

		return NewAutoPlacementValueUnknown(), diags
	}

	recommendedAnchorVal, ok := recommendedAnchorAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`recommended_anchor expected to be basetypes.BoolValue, was: %T`, recommendedAnchorAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return NewAutoPlacementValueUnknown(), diags
	}

	statusVal, ok := statusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be basetypes.StringValue, was: %T`, statusAttribute))
	}

	statusDetailAttribute, ok := attributes["status_detail"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status_detail is missing from object`)

		return NewAutoPlacementValueUnknown(), diags
	}

	statusDetailVal, ok := statusDetailAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status_detail expected to be basetypes.StringValue, was: %T`, statusDetailAttribute))
	}

	useAutoPlacementAttribute, ok := attributes["use_auto_placement"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`use_auto_placement is missing from object`)

		return NewAutoPlacementValueUnknown(), diags
	}

	useAutoPlacementVal, ok := useAutoPlacementAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`use_auto_placement expected to be basetypes.BoolValue, was: %T`, useAutoPlacementAttribute))
	}

	xAttribute, ok := attributes["x"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`x is missing from object`)

		return NewAutoPlacementValueUnknown(), diags
	}

	xVal, ok := xAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`x expected to be basetypes.Float64Value, was: %T`, xAttribute))
	}

	xMAttribute, ok := attributes["x_m"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`x_m is missing from object`)

		return NewAutoPlacementValueUnknown(), diags
	}

	xMVal, ok := xMAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`x_m expected to be basetypes.Float64Value, was: %T`, xMAttribute))
	}

	yAttribute, ok := attributes["y"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`y is missing from object`)

		return NewAutoPlacementValueUnknown(), diags
	}

	yVal, ok := yAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`y expected to be basetypes.Float64Value, was: %T`, yAttribute))
	}

	yMAttribute, ok := attributes["y_m"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`y_m is missing from object`)

		return NewAutoPlacementValueUnknown(), diags
	}

	yMVal, ok := yMAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`y_m expected to be basetypes.Float64Value, was: %T`, yMAttribute))
	}

	if diags.HasError() {
		return NewAutoPlacementValueUnknown(), diags
	}

	return AutoPlacementValue{
		Info:              infoVal,
		RecommendedAnchor: recommendedAnchorVal,
		Status:            statusVal,
		StatusDetail:      statusDetailVal,
		UseAutoPlacement:  useAutoPlacementVal,
		X:                 xVal,
		XM:                xMVal,
		Y:                 yVal,
		YM:                yMVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewAutoPlacementValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AutoPlacementValue {
	object, diags := NewAutoPlacementValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAutoPlacementValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AutoPlacementType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAutoPlacementValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAutoPlacementValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAutoPlacementValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAutoPlacementValueMust(AutoPlacementValue{}.AttributeTypes(ctx), attributes), nil
}

func (t AutoPlacementType) ValueType(ctx context.Context) attr.Value {
	return AutoPlacementValue{}
}

var _ basetypes.ObjectValuable = AutoPlacementValue{}

type AutoPlacementValue struct {
	Info              basetypes.ObjectValue  `tfsdk:"info"`
	RecommendedAnchor basetypes.BoolValue    `tfsdk:"recommended_anchor"`
	Status            basetypes.StringValue  `tfsdk:"status"`
	StatusDetail      basetypes.StringValue  `tfsdk:"status_detail"`
	UseAutoPlacement  basetypes.BoolValue    `tfsdk:"use_auto_placement"`
	X                 basetypes.Float64Value `tfsdk:"x"`
	XM                basetypes.Float64Value `tfsdk:"x_m"`
	Y                 basetypes.Float64Value `tfsdk:"y"`
	YM                basetypes.Float64Value `tfsdk:"y_m"`
	state             attr.ValueState
}

func (v AutoPlacementValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 9)

	var val tftypes.Value
	var err error

	attrTypes["info"] = basetypes.ObjectType{
		AttrTypes: InfoValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["recommended_anchor"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["status"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["status_detail"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["use_auto_placement"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["x"] = basetypes.Float64Type{}.TerraformType(ctx)
	attrTypes["x_m"] = basetypes.Float64Type{}.TerraformType(ctx)
	attrTypes["y"] = basetypes.Float64Type{}.TerraformType(ctx)
	attrTypes["y_m"] = basetypes.Float64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 9)

		val, err = v.Info.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["info"] = val

		val, err = v.RecommendedAnchor.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["recommended_anchor"] = val

		val, err = v.Status.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["status"] = val

		val, err = v.StatusDetail.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["status_detail"] = val

		val, err = v.UseAutoPlacement.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["use_auto_placement"] = val

		val, err = v.X.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["x"] = val

		val, err = v.XM.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["x_m"] = val

		val, err = v.Y.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["y"] = val

		val, err = v.YM.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["y_m"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AutoPlacementValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AutoPlacementValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AutoPlacementValue) String() string {
	return "AutoPlacementValue"
}

func (v AutoPlacementValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var info basetypes.ObjectValue

	if v.Info.IsNull() {
		info = types.ObjectNull(
			InfoValue{}.AttributeTypes(ctx),
		)
	}

	if v.Info.IsUnknown() {
		info = types.ObjectUnknown(
			InfoValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Info.IsNull() && !v.Info.IsUnknown() {
		info = types.ObjectValueMust(
			InfoValue{}.AttributeTypes(ctx),
			v.Info.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"info": basetypes.ObjectType{
			AttrTypes: InfoValue{}.AttributeTypes(ctx),
		},
		"recommended_anchor": basetypes.BoolType{},
		"status":             basetypes.StringType{},
		"status_detail":      basetypes.StringType{},
		"use_auto_placement": basetypes.BoolType{},
		"x":                  basetypes.Float64Type{},
		"x_m":                basetypes.Float64Type{},
		"y":                  basetypes.Float64Type{},
		"y_m":                basetypes.Float64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"info":               info,
			"recommended_anchor": v.RecommendedAnchor,
			"status":             v.Status,
			"status_detail":      v.StatusDetail,
			"use_auto_placement": v.UseAutoPlacement,
			"x":                  v.X,
			"x_m":                v.XM,
			"y":                  v.Y,
			"y_m":                v.YM,
		})

	return objVal, diags
}

func (v AutoPlacementValue) Equal(o attr.Value) bool {
	other, ok := o.(AutoPlacementValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Info.Equal(other.Info) {
		return false
	}

	if !v.RecommendedAnchor.Equal(other.RecommendedAnchor) {
		return false
	}

	if !v.Status.Equal(other.Status) {
		return false
	}

	if !v.StatusDetail.Equal(other.StatusDetail) {
		return false
	}

	if !v.UseAutoPlacement.Equal(other.UseAutoPlacement) {
		return false
	}

	if !v.X.Equal(other.X) {
		return false
	}

	if !v.XM.Equal(other.XM) {
		return false
	}

	if !v.Y.Equal(other.Y) {
		return false
	}

	if !v.YM.Equal(other.YM) {
		return false
	}

	return true
}

func (v AutoPlacementValue) Type(ctx context.Context) attr.Type {
	return AutoPlacementType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AutoPlacementValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"info": basetypes.ObjectType{
			AttrTypes: InfoValue{}.AttributeTypes(ctx),
		},
		"recommended_anchor": basetypes.BoolType{},
		"status":             basetypes.StringType{},
		"status_detail":      basetypes.StringType{},
		"use_auto_placement": basetypes.BoolType{},
		"x":                  basetypes.Float64Type{},
		"x_m":                basetypes.Float64Type{},
		"y":                  basetypes.Float64Type{},
		"y_m":                basetypes.Float64Type{},
	}
}

var _ basetypes.ObjectTypable = InfoType{}

type InfoType struct {
	basetypes.ObjectType
}

func (t InfoType) Equal(o attr.Type) bool {
	other, ok := o.(InfoType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t InfoType) String() string {
	return "InfoType"
}

func (t InfoType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	clusterNumberAttribute, ok := attributes["cluster_number"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cluster_number is missing from object`)

		return nil, diags
	}

	clusterNumberVal, ok := clusterNumberAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cluster_number expected to be basetypes.Int64Value, was: %T`, clusterNumberAttribute))
	}

	orientationStatsAttribute, ok := attributes["orientation_stats"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`orientation_stats is missing from object`)

		return nil, diags
	}

	orientationStatsVal, ok := orientationStatsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`orientation_stats expected to be basetypes.Int64Value, was: %T`, orientationStatsAttribute))
	}

	probabilitySurfaceAttribute, ok := attributes["probability_surface"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`probability_surface is missing from object`)

		return nil, diags
	}

	probabilitySurfaceVal, ok := probabilitySurfaceAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`probability_surface expected to be basetypes.ObjectValue, was: %T`, probabilitySurfaceAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return InfoValue{
		ClusterNumber:      clusterNumberVal,
		OrientationStats:   orientationStatsVal,
		ProbabilitySurface: probabilitySurfaceVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewInfoValueNull() InfoValue {
	return InfoValue{
		state: attr.ValueStateNull,
	}
}

func NewInfoValueUnknown() InfoValue {
	return InfoValue{
		state: attr.ValueStateUnknown,
	}
}

func NewInfoValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (InfoValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing InfoValue Attribute Value",
				"While creating a InfoValue value, a missing attribute value was detected. "+
					"A InfoValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("InfoValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid InfoValue Attribute Type",
				"While creating a InfoValue value, an invalid attribute value was detected. "+
					"A InfoValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("InfoValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("InfoValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra InfoValue Attribute Value",
				"While creating a InfoValue value, an extra attribute value was detected. "+
					"A InfoValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra InfoValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewInfoValueUnknown(), diags
	}

	clusterNumberAttribute, ok := attributes["cluster_number"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cluster_number is missing from object`)

		return NewInfoValueUnknown(), diags
	}

	clusterNumberVal, ok := clusterNumberAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cluster_number expected to be basetypes.Int64Value, was: %T`, clusterNumberAttribute))
	}

	orientationStatsAttribute, ok := attributes["orientation_stats"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`orientation_stats is missing from object`)

		return NewInfoValueUnknown(), diags
	}

	orientationStatsVal, ok := orientationStatsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`orientation_stats expected to be basetypes.Int64Value, was: %T`, orientationStatsAttribute))
	}

	probabilitySurfaceAttribute, ok := attributes["probability_surface"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`probability_surface is missing from object`)

		return NewInfoValueUnknown(), diags
	}

	probabilitySurfaceVal, ok := probabilitySurfaceAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`probability_surface expected to be basetypes.ObjectValue, was: %T`, probabilitySurfaceAttribute))
	}

	if diags.HasError() {
		return NewInfoValueUnknown(), diags
	}

	return InfoValue{
		ClusterNumber:      clusterNumberVal,
		OrientationStats:   orientationStatsVal,
		ProbabilitySurface: probabilitySurfaceVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewInfoValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) InfoValue {
	object, diags := NewInfoValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewInfoValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t InfoType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewInfoValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewInfoValueUnknown(), nil
	}

	if in.IsNull() {
		return NewInfoValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewInfoValueMust(InfoValue{}.AttributeTypes(ctx), attributes), nil
}

func (t InfoType) ValueType(ctx context.Context) attr.Value {
	return InfoValue{}
}

var _ basetypes.ObjectValuable = InfoValue{}

type InfoValue struct {
	ClusterNumber      basetypes.Int64Value  `tfsdk:"cluster_number"`
	OrientationStats   basetypes.Int64Value  `tfsdk:"orientation_stats"`
	ProbabilitySurface basetypes.ObjectValue `tfsdk:"probability_surface"`
	state              attr.ValueState
}

func (v InfoValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["cluster_number"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["orientation_stats"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["probability_surface"] = basetypes.ObjectType{
		AttrTypes: ProbabilitySurfaceValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.ClusterNumber.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cluster_number"] = val

		val, err = v.OrientationStats.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["orientation_stats"] = val

		val, err = v.ProbabilitySurface.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["probability_surface"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v InfoValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v InfoValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v InfoValue) String() string {
	return "InfoValue"
}

func (v InfoValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var probabilitySurface basetypes.ObjectValue

	if v.ProbabilitySurface.IsNull() {
		probabilitySurface = types.ObjectNull(
			ProbabilitySurfaceValue{}.AttributeTypes(ctx),
		)
	}

	if v.ProbabilitySurface.IsUnknown() {
		probabilitySurface = types.ObjectUnknown(
			ProbabilitySurfaceValue{}.AttributeTypes(ctx),
		)
	}

	if !v.ProbabilitySurface.IsNull() && !v.ProbabilitySurface.IsUnknown() {
		probabilitySurface = types.ObjectValueMust(
			ProbabilitySurfaceValue{}.AttributeTypes(ctx),
			v.ProbabilitySurface.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"cluster_number":    basetypes.Int64Type{},
		"orientation_stats": basetypes.Int64Type{},
		"probability_surface": basetypes.ObjectType{
			AttrTypes: ProbabilitySurfaceValue{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"cluster_number":      v.ClusterNumber,
			"orientation_stats":   v.OrientationStats,
			"probability_surface": probabilitySurface,
		})

	return objVal, diags
}

func (v InfoValue) Equal(o attr.Value) bool {
	other, ok := o.(InfoValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.ClusterNumber.Equal(other.ClusterNumber) {
		return false
	}

	if !v.OrientationStats.Equal(other.OrientationStats) {
		return false
	}

	if !v.ProbabilitySurface.Equal(other.ProbabilitySurface) {
		return false
	}

	return true
}

func (v InfoValue) Type(ctx context.Context) attr.Type {
	return InfoType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v InfoValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"cluster_number":    basetypes.Int64Type{},
		"orientation_stats": basetypes.Int64Type{},
		"probability_surface": basetypes.ObjectType{
			AttrTypes: ProbabilitySurfaceValue{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = ProbabilitySurfaceType{}

type ProbabilitySurfaceType struct {
	basetypes.ObjectType
}

func (t ProbabilitySurfaceType) Equal(o attr.Type) bool {
	other, ok := o.(ProbabilitySurfaceType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ProbabilitySurfaceType) String() string {
	return "ProbabilitySurfaceType"
}

func (t ProbabilitySurfaceType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	radiusAttribute, ok := attributes["radius"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`radius is missing from object`)

		return nil, diags
	}

	radiusVal, ok := radiusAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`radius expected to be basetypes.NumberValue, was: %T`, radiusAttribute))
	}

	radiusMAttribute, ok := attributes["radius_m"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`radius_m is missing from object`)

		return nil, diags
	}

	radiusMVal, ok := radiusMAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`radius_m expected to be basetypes.NumberValue, was: %T`, radiusMAttribute))
	}

	xAttribute, ok := attributes["x"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`x is missing from object`)

		return nil, diags
	}

	xVal, ok := xAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`x expected to be basetypes.Float64Value, was: %T`, xAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ProbabilitySurfaceValue{
		Radius:  radiusVal,
		RadiusM: radiusMVal,
		X:       xVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewProbabilitySurfaceValueNull() ProbabilitySurfaceValue {
	return ProbabilitySurfaceValue{
		state: attr.ValueStateNull,
	}
}

func NewProbabilitySurfaceValueUnknown() ProbabilitySurfaceValue {
	return ProbabilitySurfaceValue{
		state: attr.ValueStateUnknown,
	}
}

func NewProbabilitySurfaceValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ProbabilitySurfaceValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ProbabilitySurfaceValue Attribute Value",
				"While creating a ProbabilitySurfaceValue value, a missing attribute value was detected. "+
					"A ProbabilitySurfaceValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ProbabilitySurfaceValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ProbabilitySurfaceValue Attribute Type",
				"While creating a ProbabilitySurfaceValue value, an invalid attribute value was detected. "+
					"A ProbabilitySurfaceValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ProbabilitySurfaceValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ProbabilitySurfaceValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ProbabilitySurfaceValue Attribute Value",
				"While creating a ProbabilitySurfaceValue value, an extra attribute value was detected. "+
					"A ProbabilitySurfaceValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ProbabilitySurfaceValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewProbabilitySurfaceValueUnknown(), diags
	}

	radiusAttribute, ok := attributes["radius"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`radius is missing from object`)

		return NewProbabilitySurfaceValueUnknown(), diags
	}

	radiusVal, ok := radiusAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`radius expected to be basetypes.NumberValue, was: %T`, radiusAttribute))
	}

	radiusMAttribute, ok := attributes["radius_m"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`radius_m is missing from object`)

		return NewProbabilitySurfaceValueUnknown(), diags
	}

	radiusMVal, ok := radiusMAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`radius_m expected to be basetypes.NumberValue, was: %T`, radiusMAttribute))
	}

	xAttribute, ok := attributes["x"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`x is missing from object`)

		return NewProbabilitySurfaceValueUnknown(), diags
	}

	xVal, ok := xAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`x expected to be basetypes.Float64Value, was: %T`, xAttribute))
	}

	if diags.HasError() {
		return NewProbabilitySurfaceValueUnknown(), diags
	}

	return ProbabilitySurfaceValue{
		Radius:  radiusVal,
		RadiusM: radiusMVal,
		X:       xVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewProbabilitySurfaceValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ProbabilitySurfaceValue {
	object, diags := NewProbabilitySurfaceValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewProbabilitySurfaceValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ProbabilitySurfaceType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewProbabilitySurfaceValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewProbabilitySurfaceValueUnknown(), nil
	}

	if in.IsNull() {
		return NewProbabilitySurfaceValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewProbabilitySurfaceValueMust(ProbabilitySurfaceValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ProbabilitySurfaceType) ValueType(ctx context.Context) attr.Value {
	return ProbabilitySurfaceValue{}
}

var _ basetypes.ObjectValuable = ProbabilitySurfaceValue{}

type ProbabilitySurfaceValue struct {
	Radius  basetypes.NumberValue  `tfsdk:"radius"`
	RadiusM basetypes.NumberValue  `tfsdk:"radius_m"`
	X       basetypes.Float64Value `tfsdk:"x"`
	state   attr.ValueState
}

func (v ProbabilitySurfaceValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["radius"] = basetypes.NumberType{}.TerraformType(ctx)
	attrTypes["radius_m"] = basetypes.NumberType{}.TerraformType(ctx)
	attrTypes["x"] = basetypes.Float64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Radius.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["radius"] = val

		val, err = v.RadiusM.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["radius_m"] = val

		val, err = v.X.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["x"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ProbabilitySurfaceValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ProbabilitySurfaceValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ProbabilitySurfaceValue) String() string {
	return "ProbabilitySurfaceValue"
}

func (v ProbabilitySurfaceValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"radius":   basetypes.NumberType{},
		"radius_m": basetypes.NumberType{},
		"x":        basetypes.Float64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"radius":   v.Radius,
			"radius_m": v.RadiusM,
			"x":        v.X,
		})

	return objVal, diags
}

func (v ProbabilitySurfaceValue) Equal(o attr.Value) bool {
	other, ok := o.(ProbabilitySurfaceValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Radius.Equal(other.Radius) {
		return false
	}

	if !v.RadiusM.Equal(other.RadiusM) {
		return false
	}

	if !v.X.Equal(other.X) {
		return false
	}

	return true
}

func (v ProbabilitySurfaceValue) Type(ctx context.Context) attr.Type {
	return ProbabilitySurfaceType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ProbabilitySurfaceValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"radius":   basetypes.NumberType{},
		"radius_m": basetypes.NumberType{},
		"x":        basetypes.Float64Type{},
	}
}

var _ basetypes.ObjectTypable = AutoUpgradeStatType{}

type AutoUpgradeStatType struct {
	basetypes.ObjectType
}

func (t AutoUpgradeStatType) Equal(o attr.Type) bool {
	other, ok := o.(AutoUpgradeStatType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AutoUpgradeStatType) String() string {
	return "AutoUpgradeStatType"
}

func (t AutoUpgradeStatType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	lastcheckAttribute, ok := attributes["lastcheck"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lastcheck is missing from object`)

		return nil, diags
	}

	lastcheckVal, ok := lastcheckAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lastcheck expected to be basetypes.Int64Value, was: %T`, lastcheckAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AutoUpgradeStatValue{
		Lastcheck: lastcheckVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewAutoUpgradeStatValueNull() AutoUpgradeStatValue {
	return AutoUpgradeStatValue{
		state: attr.ValueStateNull,
	}
}

func NewAutoUpgradeStatValueUnknown() AutoUpgradeStatValue {
	return AutoUpgradeStatValue{
		state: attr.ValueStateUnknown,
	}
}

func NewAutoUpgradeStatValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AutoUpgradeStatValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AutoUpgradeStatValue Attribute Value",
				"While creating a AutoUpgradeStatValue value, a missing attribute value was detected. "+
					"A AutoUpgradeStatValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AutoUpgradeStatValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AutoUpgradeStatValue Attribute Type",
				"While creating a AutoUpgradeStatValue value, an invalid attribute value was detected. "+
					"A AutoUpgradeStatValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AutoUpgradeStatValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AutoUpgradeStatValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AutoUpgradeStatValue Attribute Value",
				"While creating a AutoUpgradeStatValue value, an extra attribute value was detected. "+
					"A AutoUpgradeStatValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AutoUpgradeStatValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAutoUpgradeStatValueUnknown(), diags
	}

	lastcheckAttribute, ok := attributes["lastcheck"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lastcheck is missing from object`)

		return NewAutoUpgradeStatValueUnknown(), diags
	}

	lastcheckVal, ok := lastcheckAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lastcheck expected to be basetypes.Int64Value, was: %T`, lastcheckAttribute))
	}

	if diags.HasError() {
		return NewAutoUpgradeStatValueUnknown(), diags
	}

	return AutoUpgradeStatValue{
		Lastcheck: lastcheckVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewAutoUpgradeStatValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AutoUpgradeStatValue {
	object, diags := NewAutoUpgradeStatValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAutoUpgradeStatValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AutoUpgradeStatType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAutoUpgradeStatValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAutoUpgradeStatValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAutoUpgradeStatValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAutoUpgradeStatValueMust(AutoUpgradeStatValue{}.AttributeTypes(ctx), attributes), nil
}

func (t AutoUpgradeStatType) ValueType(ctx context.Context) attr.Value {
	return AutoUpgradeStatValue{}
}

var _ basetypes.ObjectValuable = AutoUpgradeStatValue{}

type AutoUpgradeStatValue struct {
	Lastcheck basetypes.Int64Value `tfsdk:"lastcheck"`
	state     attr.ValueState
}

func (v AutoUpgradeStatValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["lastcheck"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Lastcheck.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["lastcheck"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AutoUpgradeStatValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AutoUpgradeStatValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AutoUpgradeStatValue) String() string {
	return "AutoUpgradeStatValue"
}

func (v AutoUpgradeStatValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"lastcheck": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"lastcheck": v.Lastcheck,
		})

	return objVal, diags
}

func (v AutoUpgradeStatValue) Equal(o attr.Value) bool {
	other, ok := o.(AutoUpgradeStatValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Lastcheck.Equal(other.Lastcheck) {
		return false
	}

	return true
}

func (v AutoUpgradeStatValue) Type(ctx context.Context) attr.Type {
	return AutoUpgradeStatType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AutoUpgradeStatValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"lastcheck": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = BleStatType{}

type BleStatType struct {
	basetypes.ObjectType
}

func (t BleStatType) Equal(o attr.Type) bool {
	other, ok := o.(BleStatType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t BleStatType) String() string {
	return "BleStatType"
}

func (t BleStatType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	beaconEnabledAttribute, ok := attributes["beacon_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`beacon_enabled is missing from object`)

		return nil, diags
	}

	beaconEnabledVal, ok := beaconEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`beacon_enabled expected to be basetypes.BoolValue, was: %T`, beaconEnabledAttribute))
	}

	beaconRateAttribute, ok := attributes["beacon_rate"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`beacon_rate is missing from object`)

		return nil, diags
	}

	beaconRateVal, ok := beaconRateAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`beacon_rate expected to be basetypes.Int64Value, was: %T`, beaconRateAttribute))
	}

	eddystoneUidEnabledAttribute, ok := attributes["eddystone_uid_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`eddystone_uid_enabled is missing from object`)

		return nil, diags
	}

	eddystoneUidEnabledVal, ok := eddystoneUidEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`eddystone_uid_enabled expected to be basetypes.BoolValue, was: %T`, eddystoneUidEnabledAttribute))
	}

	eddystoneUidFreqMsecAttribute, ok := attributes["eddystone_uid_freq_msec"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`eddystone_uid_freq_msec is missing from object`)

		return nil, diags
	}

	eddystoneUidFreqMsecVal, ok := eddystoneUidFreqMsecAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`eddystone_uid_freq_msec expected to be basetypes.Int64Value, was: %T`, eddystoneUidFreqMsecAttribute))
	}

	eddystoneUidInstanceAttribute, ok := attributes["eddystone_uid_instance"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`eddystone_uid_instance is missing from object`)

		return nil, diags
	}

	eddystoneUidInstanceVal, ok := eddystoneUidInstanceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`eddystone_uid_instance expected to be basetypes.StringValue, was: %T`, eddystoneUidInstanceAttribute))
	}

	eddystoneUidNamespaceAttribute, ok := attributes["eddystone_uid_namespace"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`eddystone_uid_namespace is missing from object`)

		return nil, diags
	}

	eddystoneUidNamespaceVal, ok := eddystoneUidNamespaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`eddystone_uid_namespace expected to be basetypes.StringValue, was: %T`, eddystoneUidNamespaceAttribute))
	}

	eddystoneUrlEnabledAttribute, ok := attributes["eddystone_url_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`eddystone_url_enabled is missing from object`)

		return nil, diags
	}

	eddystoneUrlEnabledVal, ok := eddystoneUrlEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`eddystone_url_enabled expected to be basetypes.BoolValue, was: %T`, eddystoneUrlEnabledAttribute))
	}

	eddystoneUrlFreqMsecAttribute, ok := attributes["eddystone_url_freq_msec"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`eddystone_url_freq_msec is missing from object`)

		return nil, diags
	}

	eddystoneUrlFreqMsecVal, ok := eddystoneUrlFreqMsecAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`eddystone_url_freq_msec expected to be basetypes.Int64Value, was: %T`, eddystoneUrlFreqMsecAttribute))
	}

	eddystoneUrlUrlAttribute, ok := attributes["eddystone_url_url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`eddystone_url_url is missing from object`)

		return nil, diags
	}

	eddystoneUrlUrlVal, ok := eddystoneUrlUrlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`eddystone_url_url expected to be basetypes.StringValue, was: %T`, eddystoneUrlUrlAttribute))
	}

	ibeaconEnabledAttribute, ok := attributes["ibeacon_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ibeacon_enabled is missing from object`)

		return nil, diags
	}

	ibeaconEnabledVal, ok := ibeaconEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ibeacon_enabled expected to be basetypes.BoolValue, was: %T`, ibeaconEnabledAttribute))
	}

	ibeaconFreqMsecAttribute, ok := attributes["ibeacon_freq_msec"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ibeacon_freq_msec is missing from object`)

		return nil, diags
	}

	ibeaconFreqMsecVal, ok := ibeaconFreqMsecAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ibeacon_freq_msec expected to be basetypes.Int64Value, was: %T`, ibeaconFreqMsecAttribute))
	}

	ibeaconMajorAttribute, ok := attributes["ibeacon_major"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ibeacon_major is missing from object`)

		return nil, diags
	}

	ibeaconMajorVal, ok := ibeaconMajorAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ibeacon_major expected to be basetypes.Int64Value, was: %T`, ibeaconMajorAttribute))
	}

	ibeaconMinorAttribute, ok := attributes["ibeacon_minor"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ibeacon_minor is missing from object`)

		return nil, diags
	}

	ibeaconMinorVal, ok := ibeaconMinorAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ibeacon_minor expected to be basetypes.Int64Value, was: %T`, ibeaconMinorAttribute))
	}

	ibeaconUuidAttribute, ok := attributes["ibeacon_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ibeacon_uuid is missing from object`)

		return nil, diags
	}

	ibeaconUuidVal, ok := ibeaconUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ibeacon_uuid expected to be basetypes.StringValue, was: %T`, ibeaconUuidAttribute))
	}

	majorAttribute, ok := attributes["major"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`major is missing from object`)

		return nil, diags
	}

	majorVal, ok := majorAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`major expected to be basetypes.Int64Value, was: %T`, majorAttribute))
	}

	minorsAttribute, ok := attributes["minors"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`minors is missing from object`)

		return nil, diags
	}

	minorsVal, ok := minorsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`minors expected to be basetypes.ListValue, was: %T`, minorsAttribute))
	}

	powerAttribute, ok := attributes["power"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`power is missing from object`)

		return nil, diags
	}

	powerVal, ok := powerAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`power expected to be basetypes.Int64Value, was: %T`, powerAttribute))
	}

	rxBytesAttribute, ok := attributes["rx_bytes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rx_bytes is missing from object`)

		return nil, diags
	}

	rxBytesVal, ok := rxBytesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rx_bytes expected to be basetypes.Int64Value, was: %T`, rxBytesAttribute))
	}

	rxPktsAttribute, ok := attributes["rx_pkts"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rx_pkts is missing from object`)

		return nil, diags
	}

	rxPktsVal, ok := rxPktsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rx_pkts expected to be basetypes.Int64Value, was: %T`, rxPktsAttribute))
	}

	txBytesAttribute, ok := attributes["tx_bytes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tx_bytes is missing from object`)

		return nil, diags
	}

	txBytesVal, ok := txBytesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tx_bytes expected to be basetypes.Int64Value, was: %T`, txBytesAttribute))
	}

	txPktsAttribute, ok := attributes["tx_pkts"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tx_pkts is missing from object`)

		return nil, diags
	}

	txPktsVal, ok := txPktsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tx_pkts expected to be basetypes.Int64Value, was: %T`, txPktsAttribute))
	}

	txResetsAttribute, ok := attributes["tx_resets"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tx_resets is missing from object`)

		return nil, diags
	}

	txResetsVal, ok := txResetsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tx_resets expected to be basetypes.Int64Value, was: %T`, txResetsAttribute))
	}

	uuidAttribute, ok := attributes["uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uuid is missing from object`)

		return nil, diags
	}

	uuidVal, ok := uuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uuid expected to be basetypes.StringValue, was: %T`, uuidAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return BleStatValue{
		BeaconEnabled:         beaconEnabledVal,
		BeaconRate:            beaconRateVal,
		EddystoneUidEnabled:   eddystoneUidEnabledVal,
		EddystoneUidFreqMsec:  eddystoneUidFreqMsecVal,
		EddystoneUidInstance:  eddystoneUidInstanceVal,
		EddystoneUidNamespace: eddystoneUidNamespaceVal,
		EddystoneUrlEnabled:   eddystoneUrlEnabledVal,
		EddystoneUrlFreqMsec:  eddystoneUrlFreqMsecVal,
		EddystoneUrlUrl:       eddystoneUrlUrlVal,
		IbeaconEnabled:        ibeaconEnabledVal,
		IbeaconFreqMsec:       ibeaconFreqMsecVal,
		IbeaconMajor:          ibeaconMajorVal,
		IbeaconMinor:          ibeaconMinorVal,
		IbeaconUuid:           ibeaconUuidVal,
		Major:                 majorVal,
		Minors:                minorsVal,
		Power:                 powerVal,
		RxBytes:               rxBytesVal,
		RxPkts:                rxPktsVal,
		TxBytes:               txBytesVal,
		TxPkts:                txPktsVal,
		TxResets:              txResetsVal,
		Uuid:                  uuidVal,
		state:                 attr.ValueStateKnown,
	}, diags
}

func NewBleStatValueNull() BleStatValue {
	return BleStatValue{
		state: attr.ValueStateNull,
	}
}

func NewBleStatValueUnknown() BleStatValue {
	return BleStatValue{
		state: attr.ValueStateUnknown,
	}
}

func NewBleStatValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (BleStatValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing BleStatValue Attribute Value",
				"While creating a BleStatValue value, a missing attribute value was detected. "+
					"A BleStatValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("BleStatValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid BleStatValue Attribute Type",
				"While creating a BleStatValue value, an invalid attribute value was detected. "+
					"A BleStatValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("BleStatValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("BleStatValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra BleStatValue Attribute Value",
				"While creating a BleStatValue value, an extra attribute value was detected. "+
					"A BleStatValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra BleStatValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewBleStatValueUnknown(), diags
	}

	beaconEnabledAttribute, ok := attributes["beacon_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`beacon_enabled is missing from object`)

		return NewBleStatValueUnknown(), diags
	}

	beaconEnabledVal, ok := beaconEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`beacon_enabled expected to be basetypes.BoolValue, was: %T`, beaconEnabledAttribute))
	}

	beaconRateAttribute, ok := attributes["beacon_rate"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`beacon_rate is missing from object`)

		return NewBleStatValueUnknown(), diags
	}

	beaconRateVal, ok := beaconRateAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`beacon_rate expected to be basetypes.Int64Value, was: %T`, beaconRateAttribute))
	}

	eddystoneUidEnabledAttribute, ok := attributes["eddystone_uid_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`eddystone_uid_enabled is missing from object`)

		return NewBleStatValueUnknown(), diags
	}

	eddystoneUidEnabledVal, ok := eddystoneUidEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`eddystone_uid_enabled expected to be basetypes.BoolValue, was: %T`, eddystoneUidEnabledAttribute))
	}

	eddystoneUidFreqMsecAttribute, ok := attributes["eddystone_uid_freq_msec"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`eddystone_uid_freq_msec is missing from object`)

		return NewBleStatValueUnknown(), diags
	}

	eddystoneUidFreqMsecVal, ok := eddystoneUidFreqMsecAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`eddystone_uid_freq_msec expected to be basetypes.Int64Value, was: %T`, eddystoneUidFreqMsecAttribute))
	}

	eddystoneUidInstanceAttribute, ok := attributes["eddystone_uid_instance"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`eddystone_uid_instance is missing from object`)

		return NewBleStatValueUnknown(), diags
	}

	eddystoneUidInstanceVal, ok := eddystoneUidInstanceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`eddystone_uid_instance expected to be basetypes.StringValue, was: %T`, eddystoneUidInstanceAttribute))
	}

	eddystoneUidNamespaceAttribute, ok := attributes["eddystone_uid_namespace"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`eddystone_uid_namespace is missing from object`)

		return NewBleStatValueUnknown(), diags
	}

	eddystoneUidNamespaceVal, ok := eddystoneUidNamespaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`eddystone_uid_namespace expected to be basetypes.StringValue, was: %T`, eddystoneUidNamespaceAttribute))
	}

	eddystoneUrlEnabledAttribute, ok := attributes["eddystone_url_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`eddystone_url_enabled is missing from object`)

		return NewBleStatValueUnknown(), diags
	}

	eddystoneUrlEnabledVal, ok := eddystoneUrlEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`eddystone_url_enabled expected to be basetypes.BoolValue, was: %T`, eddystoneUrlEnabledAttribute))
	}

	eddystoneUrlFreqMsecAttribute, ok := attributes["eddystone_url_freq_msec"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`eddystone_url_freq_msec is missing from object`)

		return NewBleStatValueUnknown(), diags
	}

	eddystoneUrlFreqMsecVal, ok := eddystoneUrlFreqMsecAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`eddystone_url_freq_msec expected to be basetypes.Int64Value, was: %T`, eddystoneUrlFreqMsecAttribute))
	}

	eddystoneUrlUrlAttribute, ok := attributes["eddystone_url_url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`eddystone_url_url is missing from object`)

		return NewBleStatValueUnknown(), diags
	}

	eddystoneUrlUrlVal, ok := eddystoneUrlUrlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`eddystone_url_url expected to be basetypes.StringValue, was: %T`, eddystoneUrlUrlAttribute))
	}

	ibeaconEnabledAttribute, ok := attributes["ibeacon_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ibeacon_enabled is missing from object`)

		return NewBleStatValueUnknown(), diags
	}

	ibeaconEnabledVal, ok := ibeaconEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ibeacon_enabled expected to be basetypes.BoolValue, was: %T`, ibeaconEnabledAttribute))
	}

	ibeaconFreqMsecAttribute, ok := attributes["ibeacon_freq_msec"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ibeacon_freq_msec is missing from object`)

		return NewBleStatValueUnknown(), diags
	}

	ibeaconFreqMsecVal, ok := ibeaconFreqMsecAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ibeacon_freq_msec expected to be basetypes.Int64Value, was: %T`, ibeaconFreqMsecAttribute))
	}

	ibeaconMajorAttribute, ok := attributes["ibeacon_major"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ibeacon_major is missing from object`)

		return NewBleStatValueUnknown(), diags
	}

	ibeaconMajorVal, ok := ibeaconMajorAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ibeacon_major expected to be basetypes.Int64Value, was: %T`, ibeaconMajorAttribute))
	}

	ibeaconMinorAttribute, ok := attributes["ibeacon_minor"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ibeacon_minor is missing from object`)

		return NewBleStatValueUnknown(), diags
	}

	ibeaconMinorVal, ok := ibeaconMinorAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ibeacon_minor expected to be basetypes.Int64Value, was: %T`, ibeaconMinorAttribute))
	}

	ibeaconUuidAttribute, ok := attributes["ibeacon_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ibeacon_uuid is missing from object`)

		return NewBleStatValueUnknown(), diags
	}

	ibeaconUuidVal, ok := ibeaconUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ibeacon_uuid expected to be basetypes.StringValue, was: %T`, ibeaconUuidAttribute))
	}

	majorAttribute, ok := attributes["major"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`major is missing from object`)

		return NewBleStatValueUnknown(), diags
	}

	majorVal, ok := majorAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`major expected to be basetypes.Int64Value, was: %T`, majorAttribute))
	}

	minorsAttribute, ok := attributes["minors"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`minors is missing from object`)

		return NewBleStatValueUnknown(), diags
	}

	minorsVal, ok := minorsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`minors expected to be basetypes.ListValue, was: %T`, minorsAttribute))
	}

	powerAttribute, ok := attributes["power"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`power is missing from object`)

		return NewBleStatValueUnknown(), diags
	}

	powerVal, ok := powerAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`power expected to be basetypes.Int64Value, was: %T`, powerAttribute))
	}

	rxBytesAttribute, ok := attributes["rx_bytes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rx_bytes is missing from object`)

		return NewBleStatValueUnknown(), diags
	}

	rxBytesVal, ok := rxBytesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rx_bytes expected to be basetypes.Int64Value, was: %T`, rxBytesAttribute))
	}

	rxPktsAttribute, ok := attributes["rx_pkts"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rx_pkts is missing from object`)

		return NewBleStatValueUnknown(), diags
	}

	rxPktsVal, ok := rxPktsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rx_pkts expected to be basetypes.Int64Value, was: %T`, rxPktsAttribute))
	}

	txBytesAttribute, ok := attributes["tx_bytes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tx_bytes is missing from object`)

		return NewBleStatValueUnknown(), diags
	}

	txBytesVal, ok := txBytesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tx_bytes expected to be basetypes.Int64Value, was: %T`, txBytesAttribute))
	}

	txPktsAttribute, ok := attributes["tx_pkts"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tx_pkts is missing from object`)

		return NewBleStatValueUnknown(), diags
	}

	txPktsVal, ok := txPktsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tx_pkts expected to be basetypes.Int64Value, was: %T`, txPktsAttribute))
	}

	txResetsAttribute, ok := attributes["tx_resets"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tx_resets is missing from object`)

		return NewBleStatValueUnknown(), diags
	}

	txResetsVal, ok := txResetsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tx_resets expected to be basetypes.Int64Value, was: %T`, txResetsAttribute))
	}

	uuidAttribute, ok := attributes["uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uuid is missing from object`)

		return NewBleStatValueUnknown(), diags
	}

	uuidVal, ok := uuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uuid expected to be basetypes.StringValue, was: %T`, uuidAttribute))
	}

	if diags.HasError() {
		return NewBleStatValueUnknown(), diags
	}

	return BleStatValue{
		BeaconEnabled:         beaconEnabledVal,
		BeaconRate:            beaconRateVal,
		EddystoneUidEnabled:   eddystoneUidEnabledVal,
		EddystoneUidFreqMsec:  eddystoneUidFreqMsecVal,
		EddystoneUidInstance:  eddystoneUidInstanceVal,
		EddystoneUidNamespace: eddystoneUidNamespaceVal,
		EddystoneUrlEnabled:   eddystoneUrlEnabledVal,
		EddystoneUrlFreqMsec:  eddystoneUrlFreqMsecVal,
		EddystoneUrlUrl:       eddystoneUrlUrlVal,
		IbeaconEnabled:        ibeaconEnabledVal,
		IbeaconFreqMsec:       ibeaconFreqMsecVal,
		IbeaconMajor:          ibeaconMajorVal,
		IbeaconMinor:          ibeaconMinorVal,
		IbeaconUuid:           ibeaconUuidVal,
		Major:                 majorVal,
		Minors:                minorsVal,
		Power:                 powerVal,
		RxBytes:               rxBytesVal,
		RxPkts:                rxPktsVal,
		TxBytes:               txBytesVal,
		TxPkts:                txPktsVal,
		TxResets:              txResetsVal,
		Uuid:                  uuidVal,
		state:                 attr.ValueStateKnown,
	}, diags
}

func NewBleStatValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) BleStatValue {
	object, diags := NewBleStatValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewBleStatValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t BleStatType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewBleStatValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewBleStatValueUnknown(), nil
	}

	if in.IsNull() {
		return NewBleStatValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewBleStatValueMust(BleStatValue{}.AttributeTypes(ctx), attributes), nil
}

func (t BleStatType) ValueType(ctx context.Context) attr.Value {
	return BleStatValue{}
}

var _ basetypes.ObjectValuable = BleStatValue{}

type BleStatValue struct {
	BeaconEnabled         basetypes.BoolValue   `tfsdk:"beacon_enabled"`
	BeaconRate            basetypes.Int64Value  `tfsdk:"beacon_rate"`
	EddystoneUidEnabled   basetypes.BoolValue   `tfsdk:"eddystone_uid_enabled"`
	EddystoneUidFreqMsec  basetypes.Int64Value  `tfsdk:"eddystone_uid_freq_msec"`
	EddystoneUidInstance  basetypes.StringValue `tfsdk:"eddystone_uid_instance"`
	EddystoneUidNamespace basetypes.StringValue `tfsdk:"eddystone_uid_namespace"`
	EddystoneUrlEnabled   basetypes.BoolValue   `tfsdk:"eddystone_url_enabled"`
	EddystoneUrlFreqMsec  basetypes.Int64Value  `tfsdk:"eddystone_url_freq_msec"`
	EddystoneUrlUrl       basetypes.StringValue `tfsdk:"eddystone_url_url"`
	IbeaconEnabled        basetypes.BoolValue   `tfsdk:"ibeacon_enabled"`
	IbeaconFreqMsec       basetypes.Int64Value  `tfsdk:"ibeacon_freq_msec"`
	IbeaconMajor          basetypes.Int64Value  `tfsdk:"ibeacon_major"`
	IbeaconMinor          basetypes.Int64Value  `tfsdk:"ibeacon_minor"`
	IbeaconUuid           basetypes.StringValue `tfsdk:"ibeacon_uuid"`
	Major                 basetypes.Int64Value  `tfsdk:"major"`
	Minors                basetypes.ListValue   `tfsdk:"minors"`
	Power                 basetypes.Int64Value  `tfsdk:"power"`
	RxBytes               basetypes.Int64Value  `tfsdk:"rx_bytes"`
	RxPkts                basetypes.Int64Value  `tfsdk:"rx_pkts"`
	TxBytes               basetypes.Int64Value  `tfsdk:"tx_bytes"`
	TxPkts                basetypes.Int64Value  `tfsdk:"tx_pkts"`
	TxResets              basetypes.Int64Value  `tfsdk:"tx_resets"`
	Uuid                  basetypes.StringValue `tfsdk:"uuid"`
	state                 attr.ValueState
}

func (v BleStatValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 23)

	var val tftypes.Value
	var err error

	attrTypes["beacon_enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["beacon_rate"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["eddystone_uid_enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["eddystone_uid_freq_msec"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["eddystone_uid_instance"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["eddystone_uid_namespace"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["eddystone_url_enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["eddystone_url_freq_msec"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["eddystone_url_url"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ibeacon_enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["ibeacon_freq_msec"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["ibeacon_major"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["ibeacon_minor"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["ibeacon_uuid"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["major"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["minors"] = basetypes.ListType{
		ElemType: types.Int64Type,
	}.TerraformType(ctx)
	attrTypes["power"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["rx_bytes"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["rx_pkts"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["tx_bytes"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["tx_pkts"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["tx_resets"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["uuid"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 23)

		val, err = v.BeaconEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["beacon_enabled"] = val

		val, err = v.BeaconRate.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["beacon_rate"] = val

		val, err = v.EddystoneUidEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["eddystone_uid_enabled"] = val

		val, err = v.EddystoneUidFreqMsec.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["eddystone_uid_freq_msec"] = val

		val, err = v.EddystoneUidInstance.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["eddystone_uid_instance"] = val

		val, err = v.EddystoneUidNamespace.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["eddystone_uid_namespace"] = val

		val, err = v.EddystoneUrlEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["eddystone_url_enabled"] = val

		val, err = v.EddystoneUrlFreqMsec.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["eddystone_url_freq_msec"] = val

		val, err = v.EddystoneUrlUrl.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["eddystone_url_url"] = val

		val, err = v.IbeaconEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ibeacon_enabled"] = val

		val, err = v.IbeaconFreqMsec.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ibeacon_freq_msec"] = val

		val, err = v.IbeaconMajor.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ibeacon_major"] = val

		val, err = v.IbeaconMinor.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ibeacon_minor"] = val

		val, err = v.IbeaconUuid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ibeacon_uuid"] = val

		val, err = v.Major.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["major"] = val

		val, err = v.Minors.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["minors"] = val

		val, err = v.Power.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["power"] = val

		val, err = v.RxBytes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["rx_bytes"] = val

		val, err = v.RxPkts.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["rx_pkts"] = val

		val, err = v.TxBytes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tx_bytes"] = val

		val, err = v.TxPkts.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tx_pkts"] = val

		val, err = v.TxResets.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tx_resets"] = val

		val, err = v.Uuid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["uuid"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v BleStatValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v BleStatValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v BleStatValue) String() string {
	return "BleStatValue"
}

func (v BleStatValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	minorsVal, d := types.ListValue(types.Int64Type, v.Minors.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"beacon_enabled":          basetypes.BoolType{},
			"beacon_rate":             basetypes.Int64Type{},
			"eddystone_uid_enabled":   basetypes.BoolType{},
			"eddystone_uid_freq_msec": basetypes.Int64Type{},
			"eddystone_uid_instance":  basetypes.StringType{},
			"eddystone_uid_namespace": basetypes.StringType{},
			"eddystone_url_enabled":   basetypes.BoolType{},
			"eddystone_url_freq_msec": basetypes.Int64Type{},
			"eddystone_url_url":       basetypes.StringType{},
			"ibeacon_enabled":         basetypes.BoolType{},
			"ibeacon_freq_msec":       basetypes.Int64Type{},
			"ibeacon_major":           basetypes.Int64Type{},
			"ibeacon_minor":           basetypes.Int64Type{},
			"ibeacon_uuid":            basetypes.StringType{},
			"major":                   basetypes.Int64Type{},
			"minors": basetypes.ListType{
				ElemType: types.Int64Type,
			},
			"power":     basetypes.Int64Type{},
			"rx_bytes":  basetypes.Int64Type{},
			"rx_pkts":   basetypes.Int64Type{},
			"tx_bytes":  basetypes.Int64Type{},
			"tx_pkts":   basetypes.Int64Type{},
			"tx_resets": basetypes.Int64Type{},
			"uuid":      basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"beacon_enabled":          basetypes.BoolType{},
		"beacon_rate":             basetypes.Int64Type{},
		"eddystone_uid_enabled":   basetypes.BoolType{},
		"eddystone_uid_freq_msec": basetypes.Int64Type{},
		"eddystone_uid_instance":  basetypes.StringType{},
		"eddystone_uid_namespace": basetypes.StringType{},
		"eddystone_url_enabled":   basetypes.BoolType{},
		"eddystone_url_freq_msec": basetypes.Int64Type{},
		"eddystone_url_url":       basetypes.StringType{},
		"ibeacon_enabled":         basetypes.BoolType{},
		"ibeacon_freq_msec":       basetypes.Int64Type{},
		"ibeacon_major":           basetypes.Int64Type{},
		"ibeacon_minor":           basetypes.Int64Type{},
		"ibeacon_uuid":            basetypes.StringType{},
		"major":                   basetypes.Int64Type{},
		"minors": basetypes.ListType{
			ElemType: types.Int64Type,
		},
		"power":     basetypes.Int64Type{},
		"rx_bytes":  basetypes.Int64Type{},
		"rx_pkts":   basetypes.Int64Type{},
		"tx_bytes":  basetypes.Int64Type{},
		"tx_pkts":   basetypes.Int64Type{},
		"tx_resets": basetypes.Int64Type{},
		"uuid":      basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"beacon_enabled":          v.BeaconEnabled,
			"beacon_rate":             v.BeaconRate,
			"eddystone_uid_enabled":   v.EddystoneUidEnabled,
			"eddystone_uid_freq_msec": v.EddystoneUidFreqMsec,
			"eddystone_uid_instance":  v.EddystoneUidInstance,
			"eddystone_uid_namespace": v.EddystoneUidNamespace,
			"eddystone_url_enabled":   v.EddystoneUrlEnabled,
			"eddystone_url_freq_msec": v.EddystoneUrlFreqMsec,
			"eddystone_url_url":       v.EddystoneUrlUrl,
			"ibeacon_enabled":         v.IbeaconEnabled,
			"ibeacon_freq_msec":       v.IbeaconFreqMsec,
			"ibeacon_major":           v.IbeaconMajor,
			"ibeacon_minor":           v.IbeaconMinor,
			"ibeacon_uuid":            v.IbeaconUuid,
			"major":                   v.Major,
			"minors":                  minorsVal,
			"power":                   v.Power,
			"rx_bytes":                v.RxBytes,
			"rx_pkts":                 v.RxPkts,
			"tx_bytes":                v.TxBytes,
			"tx_pkts":                 v.TxPkts,
			"tx_resets":               v.TxResets,
			"uuid":                    v.Uuid,
		})

	return objVal, diags
}

func (v BleStatValue) Equal(o attr.Value) bool {
	other, ok := o.(BleStatValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.BeaconEnabled.Equal(other.BeaconEnabled) {
		return false
	}

	if !v.BeaconRate.Equal(other.BeaconRate) {
		return false
	}

	if !v.EddystoneUidEnabled.Equal(other.EddystoneUidEnabled) {
		return false
	}

	if !v.EddystoneUidFreqMsec.Equal(other.EddystoneUidFreqMsec) {
		return false
	}

	if !v.EddystoneUidInstance.Equal(other.EddystoneUidInstance) {
		return false
	}

	if !v.EddystoneUidNamespace.Equal(other.EddystoneUidNamespace) {
		return false
	}

	if !v.EddystoneUrlEnabled.Equal(other.EddystoneUrlEnabled) {
		return false
	}

	if !v.EddystoneUrlFreqMsec.Equal(other.EddystoneUrlFreqMsec) {
		return false
	}

	if !v.EddystoneUrlUrl.Equal(other.EddystoneUrlUrl) {
		return false
	}

	if !v.IbeaconEnabled.Equal(other.IbeaconEnabled) {
		return false
	}

	if !v.IbeaconFreqMsec.Equal(other.IbeaconFreqMsec) {
		return false
	}

	if !v.IbeaconMajor.Equal(other.IbeaconMajor) {
		return false
	}

	if !v.IbeaconMinor.Equal(other.IbeaconMinor) {
		return false
	}

	if !v.IbeaconUuid.Equal(other.IbeaconUuid) {
		return false
	}

	if !v.Major.Equal(other.Major) {
		return false
	}

	if !v.Minors.Equal(other.Minors) {
		return false
	}

	if !v.Power.Equal(other.Power) {
		return false
	}

	if !v.RxBytes.Equal(other.RxBytes) {
		return false
	}

	if !v.RxPkts.Equal(other.RxPkts) {
		return false
	}

	if !v.TxBytes.Equal(other.TxBytes) {
		return false
	}

	if !v.TxPkts.Equal(other.TxPkts) {
		return false
	}

	if !v.TxResets.Equal(other.TxResets) {
		return false
	}

	if !v.Uuid.Equal(other.Uuid) {
		return false
	}

	return true
}

func (v BleStatValue) Type(ctx context.Context) attr.Type {
	return BleStatType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v BleStatValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"beacon_enabled":          basetypes.BoolType{},
		"beacon_rate":             basetypes.Int64Type{},
		"eddystone_uid_enabled":   basetypes.BoolType{},
		"eddystone_uid_freq_msec": basetypes.Int64Type{},
		"eddystone_uid_instance":  basetypes.StringType{},
		"eddystone_uid_namespace": basetypes.StringType{},
		"eddystone_url_enabled":   basetypes.BoolType{},
		"eddystone_url_freq_msec": basetypes.Int64Type{},
		"eddystone_url_url":       basetypes.StringType{},
		"ibeacon_enabled":         basetypes.BoolType{},
		"ibeacon_freq_msec":       basetypes.Int64Type{},
		"ibeacon_major":           basetypes.Int64Type{},
		"ibeacon_minor":           basetypes.Int64Type{},
		"ibeacon_uuid":            basetypes.StringType{},
		"major":                   basetypes.Int64Type{},
		"minors": basetypes.ListType{
			ElemType: types.Int64Type,
		},
		"power":     basetypes.Int64Type{},
		"rx_bytes":  basetypes.Int64Type{},
		"rx_pkts":   basetypes.Int64Type{},
		"tx_bytes":  basetypes.Int64Type{},
		"tx_pkts":   basetypes.Int64Type{},
		"tx_resets": basetypes.Int64Type{},
		"uuid":      basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = EnvStatType{}

type EnvStatType struct {
	basetypes.ObjectType
}

func (t EnvStatType) Equal(o attr.Type) bool {
	other, ok := o.(EnvStatType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t EnvStatType) String() string {
	return "EnvStatType"
}

func (t EnvStatType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	accelXAttribute, ok := attributes["accel_x"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`accel_x is missing from object`)

		return nil, diags
	}

	accelXVal, ok := accelXAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`accel_x expected to be basetypes.Float64Value, was: %T`, accelXAttribute))
	}

	accelYAttribute, ok := attributes["accel_y"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`accel_y is missing from object`)

		return nil, diags
	}

	accelYVal, ok := accelYAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`accel_y expected to be basetypes.Float64Value, was: %T`, accelYAttribute))
	}

	accelZAttribute, ok := attributes["accel_z"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`accel_z is missing from object`)

		return nil, diags
	}

	accelZVal, ok := accelZAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`accel_z expected to be basetypes.Float64Value, was: %T`, accelZAttribute))
	}

	ambientTempAttribute, ok := attributes["ambient_temp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ambient_temp is missing from object`)

		return nil, diags
	}

	ambientTempVal, ok := ambientTempAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ambient_temp expected to be basetypes.Int64Value, was: %T`, ambientTempAttribute))
	}

	attitudeAttribute, ok := attributes["attitude"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`attitude is missing from object`)

		return nil, diags
	}

	attitudeVal, ok := attitudeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`attitude expected to be basetypes.Int64Value, was: %T`, attitudeAttribute))
	}

	cpuTempAttribute, ok := attributes["cpu_temp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cpu_temp is missing from object`)

		return nil, diags
	}

	cpuTempVal, ok := cpuTempAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cpu_temp expected to be basetypes.Int64Value, was: %T`, cpuTempAttribute))
	}

	humidityAttribute, ok := attributes["humidity"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`humidity is missing from object`)

		return nil, diags
	}

	humidityVal, ok := humidityAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`humidity expected to be basetypes.Int64Value, was: %T`, humidityAttribute))
	}

	magneXAttribute, ok := attributes["magne_x"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`magne_x is missing from object`)

		return nil, diags
	}

	magneXVal, ok := magneXAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`magne_x expected to be basetypes.Float64Value, was: %T`, magneXAttribute))
	}

	magneYAttribute, ok := attributes["magne_y"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`magne_y is missing from object`)

		return nil, diags
	}

	magneYVal, ok := magneYAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`magne_y expected to be basetypes.Float64Value, was: %T`, magneYAttribute))
	}

	magneZAttribute, ok := attributes["magne_z"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`magne_z is missing from object`)

		return nil, diags
	}

	magneZVal, ok := magneZAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`magne_z expected to be basetypes.Float64Value, was: %T`, magneZAttribute))
	}

	pressureAttribute, ok := attributes["pressure"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pressure is missing from object`)

		return nil, diags
	}

	pressureVal, ok := pressureAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pressure expected to be basetypes.Float64Value, was: %T`, pressureAttribute))
	}

	vcoreVoltageAttribute, ok := attributes["vcore_voltage"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vcore_voltage is missing from object`)

		return nil, diags
	}

	vcoreVoltageVal, ok := vcoreVoltageAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vcore_voltage expected to be basetypes.Int64Value, was: %T`, vcoreVoltageAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return EnvStatValue{
		AccelX:       accelXVal,
		AccelY:       accelYVal,
		AccelZ:       accelZVal,
		AmbientTemp:  ambientTempVal,
		Attitude:     attitudeVal,
		CpuTemp:      cpuTempVal,
		Humidity:     humidityVal,
		MagneX:       magneXVal,
		MagneY:       magneYVal,
		MagneZ:       magneZVal,
		Pressure:     pressureVal,
		VcoreVoltage: vcoreVoltageVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewEnvStatValueNull() EnvStatValue {
	return EnvStatValue{
		state: attr.ValueStateNull,
	}
}

func NewEnvStatValueUnknown() EnvStatValue {
	return EnvStatValue{
		state: attr.ValueStateUnknown,
	}
}

func NewEnvStatValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (EnvStatValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing EnvStatValue Attribute Value",
				"While creating a EnvStatValue value, a missing attribute value was detected. "+
					"A EnvStatValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("EnvStatValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid EnvStatValue Attribute Type",
				"While creating a EnvStatValue value, an invalid attribute value was detected. "+
					"A EnvStatValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("EnvStatValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("EnvStatValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra EnvStatValue Attribute Value",
				"While creating a EnvStatValue value, an extra attribute value was detected. "+
					"A EnvStatValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra EnvStatValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewEnvStatValueUnknown(), diags
	}

	accelXAttribute, ok := attributes["accel_x"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`accel_x is missing from object`)

		return NewEnvStatValueUnknown(), diags
	}

	accelXVal, ok := accelXAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`accel_x expected to be basetypes.Float64Value, was: %T`, accelXAttribute))
	}

	accelYAttribute, ok := attributes["accel_y"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`accel_y is missing from object`)

		return NewEnvStatValueUnknown(), diags
	}

	accelYVal, ok := accelYAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`accel_y expected to be basetypes.Float64Value, was: %T`, accelYAttribute))
	}

	accelZAttribute, ok := attributes["accel_z"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`accel_z is missing from object`)

		return NewEnvStatValueUnknown(), diags
	}

	accelZVal, ok := accelZAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`accel_z expected to be basetypes.Float64Value, was: %T`, accelZAttribute))
	}

	ambientTempAttribute, ok := attributes["ambient_temp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ambient_temp is missing from object`)

		return NewEnvStatValueUnknown(), diags
	}

	ambientTempVal, ok := ambientTempAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ambient_temp expected to be basetypes.Int64Value, was: %T`, ambientTempAttribute))
	}

	attitudeAttribute, ok := attributes["attitude"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`attitude is missing from object`)

		return NewEnvStatValueUnknown(), diags
	}

	attitudeVal, ok := attitudeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`attitude expected to be basetypes.Int64Value, was: %T`, attitudeAttribute))
	}

	cpuTempAttribute, ok := attributes["cpu_temp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cpu_temp is missing from object`)

		return NewEnvStatValueUnknown(), diags
	}

	cpuTempVal, ok := cpuTempAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cpu_temp expected to be basetypes.Int64Value, was: %T`, cpuTempAttribute))
	}

	humidityAttribute, ok := attributes["humidity"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`humidity is missing from object`)

		return NewEnvStatValueUnknown(), diags
	}

	humidityVal, ok := humidityAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`humidity expected to be basetypes.Int64Value, was: %T`, humidityAttribute))
	}

	magneXAttribute, ok := attributes["magne_x"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`magne_x is missing from object`)

		return NewEnvStatValueUnknown(), diags
	}

	magneXVal, ok := magneXAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`magne_x expected to be basetypes.Float64Value, was: %T`, magneXAttribute))
	}

	magneYAttribute, ok := attributes["magne_y"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`magne_y is missing from object`)

		return NewEnvStatValueUnknown(), diags
	}

	magneYVal, ok := magneYAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`magne_y expected to be basetypes.Float64Value, was: %T`, magneYAttribute))
	}

	magneZAttribute, ok := attributes["magne_z"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`magne_z is missing from object`)

		return NewEnvStatValueUnknown(), diags
	}

	magneZVal, ok := magneZAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`magne_z expected to be basetypes.Float64Value, was: %T`, magneZAttribute))
	}

	pressureAttribute, ok := attributes["pressure"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pressure is missing from object`)

		return NewEnvStatValueUnknown(), diags
	}

	pressureVal, ok := pressureAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pressure expected to be basetypes.Float64Value, was: %T`, pressureAttribute))
	}

	vcoreVoltageAttribute, ok := attributes["vcore_voltage"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vcore_voltage is missing from object`)

		return NewEnvStatValueUnknown(), diags
	}

	vcoreVoltageVal, ok := vcoreVoltageAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vcore_voltage expected to be basetypes.Int64Value, was: %T`, vcoreVoltageAttribute))
	}

	if diags.HasError() {
		return NewEnvStatValueUnknown(), diags
	}

	return EnvStatValue{
		AccelX:       accelXVal,
		AccelY:       accelYVal,
		AccelZ:       accelZVal,
		AmbientTemp:  ambientTempVal,
		Attitude:     attitudeVal,
		CpuTemp:      cpuTempVal,
		Humidity:     humidityVal,
		MagneX:       magneXVal,
		MagneY:       magneYVal,
		MagneZ:       magneZVal,
		Pressure:     pressureVal,
		VcoreVoltage: vcoreVoltageVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewEnvStatValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) EnvStatValue {
	object, diags := NewEnvStatValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewEnvStatValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t EnvStatType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewEnvStatValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewEnvStatValueUnknown(), nil
	}

	if in.IsNull() {
		return NewEnvStatValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewEnvStatValueMust(EnvStatValue{}.AttributeTypes(ctx), attributes), nil
}

func (t EnvStatType) ValueType(ctx context.Context) attr.Value {
	return EnvStatValue{}
}

var _ basetypes.ObjectValuable = EnvStatValue{}

type EnvStatValue struct {
	AccelX       basetypes.Float64Value `tfsdk:"accel_x"`
	AccelY       basetypes.Float64Value `tfsdk:"accel_y"`
	AccelZ       basetypes.Float64Value `tfsdk:"accel_z"`
	AmbientTemp  basetypes.Int64Value   `tfsdk:"ambient_temp"`
	Attitude     basetypes.Int64Value   `tfsdk:"attitude"`
	CpuTemp      basetypes.Int64Value   `tfsdk:"cpu_temp"`
	Humidity     basetypes.Int64Value   `tfsdk:"humidity"`
	MagneX       basetypes.Float64Value `tfsdk:"magne_x"`
	MagneY       basetypes.Float64Value `tfsdk:"magne_y"`
	MagneZ       basetypes.Float64Value `tfsdk:"magne_z"`
	Pressure     basetypes.Float64Value `tfsdk:"pressure"`
	VcoreVoltage basetypes.Int64Value   `tfsdk:"vcore_voltage"`
	state        attr.ValueState
}

func (v EnvStatValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 12)

	var val tftypes.Value
	var err error

	attrTypes["accel_x"] = basetypes.Float64Type{}.TerraformType(ctx)
	attrTypes["accel_y"] = basetypes.Float64Type{}.TerraformType(ctx)
	attrTypes["accel_z"] = basetypes.Float64Type{}.TerraformType(ctx)
	attrTypes["ambient_temp"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["attitude"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["cpu_temp"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["humidity"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["magne_x"] = basetypes.Float64Type{}.TerraformType(ctx)
	attrTypes["magne_y"] = basetypes.Float64Type{}.TerraformType(ctx)
	attrTypes["magne_z"] = basetypes.Float64Type{}.TerraformType(ctx)
	attrTypes["pressure"] = basetypes.Float64Type{}.TerraformType(ctx)
	attrTypes["vcore_voltage"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 12)

		val, err = v.AccelX.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["accel_x"] = val

		val, err = v.AccelY.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["accel_y"] = val

		val, err = v.AccelZ.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["accel_z"] = val

		val, err = v.AmbientTemp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ambient_temp"] = val

		val, err = v.Attitude.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["attitude"] = val

		val, err = v.CpuTemp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cpu_temp"] = val

		val, err = v.Humidity.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["humidity"] = val

		val, err = v.MagneX.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["magne_x"] = val

		val, err = v.MagneY.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["magne_y"] = val

		val, err = v.MagneZ.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["magne_z"] = val

		val, err = v.Pressure.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["pressure"] = val

		val, err = v.VcoreVoltage.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vcore_voltage"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v EnvStatValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v EnvStatValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v EnvStatValue) String() string {
	return "EnvStatValue"
}

func (v EnvStatValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"accel_x":       basetypes.Float64Type{},
		"accel_y":       basetypes.Float64Type{},
		"accel_z":       basetypes.Float64Type{},
		"ambient_temp":  basetypes.Int64Type{},
		"attitude":      basetypes.Int64Type{},
		"cpu_temp":      basetypes.Int64Type{},
		"humidity":      basetypes.Int64Type{},
		"magne_x":       basetypes.Float64Type{},
		"magne_y":       basetypes.Float64Type{},
		"magne_z":       basetypes.Float64Type{},
		"pressure":      basetypes.Float64Type{},
		"vcore_voltage": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"accel_x":       v.AccelX,
			"accel_y":       v.AccelY,
			"accel_z":       v.AccelZ,
			"ambient_temp":  v.AmbientTemp,
			"attitude":      v.Attitude,
			"cpu_temp":      v.CpuTemp,
			"humidity":      v.Humidity,
			"magne_x":       v.MagneX,
			"magne_y":       v.MagneY,
			"magne_z":       v.MagneZ,
			"pressure":      v.Pressure,
			"vcore_voltage": v.VcoreVoltage,
		})

	return objVal, diags
}

func (v EnvStatValue) Equal(o attr.Value) bool {
	other, ok := o.(EnvStatValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AccelX.Equal(other.AccelX) {
		return false
	}

	if !v.AccelY.Equal(other.AccelY) {
		return false
	}

	if !v.AccelZ.Equal(other.AccelZ) {
		return false
	}

	if !v.AmbientTemp.Equal(other.AmbientTemp) {
		return false
	}

	if !v.Attitude.Equal(other.Attitude) {
		return false
	}

	if !v.CpuTemp.Equal(other.CpuTemp) {
		return false
	}

	if !v.Humidity.Equal(other.Humidity) {
		return false
	}

	if !v.MagneX.Equal(other.MagneX) {
		return false
	}

	if !v.MagneY.Equal(other.MagneY) {
		return false
	}

	if !v.MagneZ.Equal(other.MagneZ) {
		return false
	}

	if !v.Pressure.Equal(other.Pressure) {
		return false
	}

	if !v.VcoreVoltage.Equal(other.VcoreVoltage) {
		return false
	}

	return true
}

func (v EnvStatValue) Type(ctx context.Context) attr.Type {
	return EnvStatType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v EnvStatValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"accel_x":       basetypes.Float64Type{},
		"accel_y":       basetypes.Float64Type{},
		"accel_z":       basetypes.Float64Type{},
		"ambient_temp":  basetypes.Int64Type{},
		"attitude":      basetypes.Int64Type{},
		"cpu_temp":      basetypes.Int64Type{},
		"humidity":      basetypes.Int64Type{},
		"magne_x":       basetypes.Float64Type{},
		"magne_y":       basetypes.Float64Type{},
		"magne_z":       basetypes.Float64Type{},
		"pressure":      basetypes.Float64Type{},
		"vcore_voltage": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = EslStatType{}

type EslStatType struct {
	basetypes.ObjectType
}

func (t EslStatType) Equal(o attr.Type) bool {
	other, ok := o.(EslStatType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t EslStatType) String() string {
	return "EslStatType"
}

func (t EslStatType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	channelAttribute, ok := attributes["channel"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`channel is missing from object`)

		return nil, diags
	}

	channelVal, ok := channelAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`channel expected to be basetypes.Int64Value, was: %T`, channelAttribute))
	}

	connectedAttribute, ok := attributes["connected"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`connected is missing from object`)

		return nil, diags
	}

	connectedVal, ok := connectedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`connected expected to be basetypes.BoolValue, was: %T`, connectedAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	upAttribute, ok := attributes["up"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`up is missing from object`)

		return nil, diags
	}

	upVal, ok := upAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`up expected to be basetypes.BoolValue, was: %T`, upAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return EslStatValue{
		Channel:     channelVal,
		Connected:   connectedVal,
		EslStatType: typeVal,
		Up:          upVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewEslStatValueNull() EslStatValue {
	return EslStatValue{
		state: attr.ValueStateNull,
	}
}

func NewEslStatValueUnknown() EslStatValue {
	return EslStatValue{
		state: attr.ValueStateUnknown,
	}
}

func NewEslStatValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (EslStatValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing EslStatValue Attribute Value",
				"While creating a EslStatValue value, a missing attribute value was detected. "+
					"A EslStatValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("EslStatValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid EslStatValue Attribute Type",
				"While creating a EslStatValue value, an invalid attribute value was detected. "+
					"A EslStatValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("EslStatValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("EslStatValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra EslStatValue Attribute Value",
				"While creating a EslStatValue value, an extra attribute value was detected. "+
					"A EslStatValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra EslStatValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewEslStatValueUnknown(), diags
	}

	channelAttribute, ok := attributes["channel"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`channel is missing from object`)

		return NewEslStatValueUnknown(), diags
	}

	channelVal, ok := channelAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`channel expected to be basetypes.Int64Value, was: %T`, channelAttribute))
	}

	connectedAttribute, ok := attributes["connected"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`connected is missing from object`)

		return NewEslStatValueUnknown(), diags
	}

	connectedVal, ok := connectedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`connected expected to be basetypes.BoolValue, was: %T`, connectedAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewEslStatValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	upAttribute, ok := attributes["up"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`up is missing from object`)

		return NewEslStatValueUnknown(), diags
	}

	upVal, ok := upAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`up expected to be basetypes.BoolValue, was: %T`, upAttribute))
	}

	if diags.HasError() {
		return NewEslStatValueUnknown(), diags
	}

	return EslStatValue{
		Channel:     channelVal,
		Connected:   connectedVal,
		EslStatType: typeVal,
		Up:          upVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewEslStatValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) EslStatValue {
	object, diags := NewEslStatValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewEslStatValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t EslStatType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewEslStatValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewEslStatValueUnknown(), nil
	}

	if in.IsNull() {
		return NewEslStatValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewEslStatValueMust(EslStatValue{}.AttributeTypes(ctx), attributes), nil
}

func (t EslStatType) ValueType(ctx context.Context) attr.Value {
	return EslStatValue{}
}

var _ basetypes.ObjectValuable = EslStatValue{}

type EslStatValue struct {
	Channel     basetypes.Int64Value  `tfsdk:"channel"`
	Connected   basetypes.BoolValue   `tfsdk:"connected"`
	EslStatType basetypes.StringValue `tfsdk:"type"`
	Up          basetypes.BoolValue   `tfsdk:"up"`
	state       attr.ValueState
}

func (v EslStatValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["channel"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["connected"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["up"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Channel.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["channel"] = val

		val, err = v.Connected.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["connected"] = val

		val, err = v.EslStatType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		val, err = v.Up.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["up"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v EslStatValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v EslStatValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v EslStatValue) String() string {
	return "EslStatValue"
}

func (v EslStatValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"channel":   basetypes.Int64Type{},
		"connected": basetypes.BoolType{},
		"type":      basetypes.StringType{},
		"up":        basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"channel":   v.Channel,
			"connected": v.Connected,
			"type":      v.EslStatType,
			"up":        v.Up,
		})

	return objVal, diags
}

func (v EslStatValue) Equal(o attr.Value) bool {
	other, ok := o.(EslStatValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Channel.Equal(other.Channel) {
		return false
	}

	if !v.Connected.Equal(other.Connected) {
		return false
	}

	if !v.EslStatType.Equal(other.EslStatType) {
		return false
	}

	if !v.Up.Equal(other.Up) {
		return false
	}

	return true
}

func (v EslStatValue) Type(ctx context.Context) attr.Type {
	return EslStatType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v EslStatValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"channel":   basetypes.Int64Type{},
		"connected": basetypes.BoolType{},
		"type":      basetypes.StringType{},
		"up":        basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = FwupdateType{}

type FwupdateType struct {
	basetypes.ObjectType
}

func (t FwupdateType) Equal(o attr.Type) bool {
	other, ok := o.(FwupdateType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t FwupdateType) String() string {
	return "FwupdateType"
}

func (t FwupdateType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	progressAttribute, ok := attributes["progress"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`progress is missing from object`)

		return nil, diags
	}

	progressVal, ok := progressAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`progress expected to be basetypes.Int64Value, was: %T`, progressAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return nil, diags
	}

	statusVal, ok := statusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be basetypes.StringValue, was: %T`, statusAttribute))
	}

	statusIdAttribute, ok := attributes["status_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status_id is missing from object`)

		return nil, diags
	}

	statusIdVal, ok := statusIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status_id expected to be basetypes.Int64Value, was: %T`, statusIdAttribute))
	}

	timestampAttribute, ok := attributes["timestamp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`timestamp is missing from object`)

		return nil, diags
	}

	timestampVal, ok := timestampAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`timestamp expected to be basetypes.Float64Value, was: %T`, timestampAttribute))
	}

	willRetryAttribute, ok := attributes["will_retry"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`will_retry is missing from object`)

		return nil, diags
	}

	willRetryVal, ok := willRetryAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`will_retry expected to be basetypes.BoolValue, was: %T`, willRetryAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return FwupdateValue{
		Progress:  progressVal,
		Status:    statusVal,
		StatusId:  statusIdVal,
		Timestamp: timestampVal,
		WillRetry: willRetryVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewFwupdateValueNull() FwupdateValue {
	return FwupdateValue{
		state: attr.ValueStateNull,
	}
}

func NewFwupdateValueUnknown() FwupdateValue {
	return FwupdateValue{
		state: attr.ValueStateUnknown,
	}
}

func NewFwupdateValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (FwupdateValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing FwupdateValue Attribute Value",
				"While creating a FwupdateValue value, a missing attribute value was detected. "+
					"A FwupdateValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("FwupdateValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid FwupdateValue Attribute Type",
				"While creating a FwupdateValue value, an invalid attribute value was detected. "+
					"A FwupdateValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("FwupdateValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("FwupdateValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra FwupdateValue Attribute Value",
				"While creating a FwupdateValue value, an extra attribute value was detected. "+
					"A FwupdateValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra FwupdateValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewFwupdateValueUnknown(), diags
	}

	progressAttribute, ok := attributes["progress"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`progress is missing from object`)

		return NewFwupdateValueUnknown(), diags
	}

	progressVal, ok := progressAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`progress expected to be basetypes.Int64Value, was: %T`, progressAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return NewFwupdateValueUnknown(), diags
	}

	statusVal, ok := statusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be basetypes.StringValue, was: %T`, statusAttribute))
	}

	statusIdAttribute, ok := attributes["status_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status_id is missing from object`)

		return NewFwupdateValueUnknown(), diags
	}

	statusIdVal, ok := statusIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status_id expected to be basetypes.Int64Value, was: %T`, statusIdAttribute))
	}

	timestampAttribute, ok := attributes["timestamp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`timestamp is missing from object`)

		return NewFwupdateValueUnknown(), diags
	}

	timestampVal, ok := timestampAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`timestamp expected to be basetypes.Float64Value, was: %T`, timestampAttribute))
	}

	willRetryAttribute, ok := attributes["will_retry"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`will_retry is missing from object`)

		return NewFwupdateValueUnknown(), diags
	}

	willRetryVal, ok := willRetryAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`will_retry expected to be basetypes.BoolValue, was: %T`, willRetryAttribute))
	}

	if diags.HasError() {
		return NewFwupdateValueUnknown(), diags
	}

	return FwupdateValue{
		Progress:  progressVal,
		Status:    statusVal,
		StatusId:  statusIdVal,
		Timestamp: timestampVal,
		WillRetry: willRetryVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewFwupdateValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) FwupdateValue {
	object, diags := NewFwupdateValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewFwupdateValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t FwupdateType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewFwupdateValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewFwupdateValueUnknown(), nil
	}

	if in.IsNull() {
		return NewFwupdateValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewFwupdateValueMust(FwupdateValue{}.AttributeTypes(ctx), attributes), nil
}

func (t FwupdateType) ValueType(ctx context.Context) attr.Value {
	return FwupdateValue{}
}

var _ basetypes.ObjectValuable = FwupdateValue{}

type FwupdateValue struct {
	Progress  basetypes.Int64Value   `tfsdk:"progress"`
	Status    basetypes.StringValue  `tfsdk:"status"`
	StatusId  basetypes.Int64Value   `tfsdk:"status_id"`
	Timestamp basetypes.Float64Value `tfsdk:"timestamp"`
	WillRetry basetypes.BoolValue    `tfsdk:"will_retry"`
	state     attr.ValueState
}

func (v FwupdateValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["progress"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["status"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["status_id"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["timestamp"] = basetypes.Float64Type{}.TerraformType(ctx)
	attrTypes["will_retry"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.Progress.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["progress"] = val

		val, err = v.Status.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["status"] = val

		val, err = v.StatusId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["status_id"] = val

		val, err = v.Timestamp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["timestamp"] = val

		val, err = v.WillRetry.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["will_retry"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v FwupdateValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v FwupdateValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v FwupdateValue) String() string {
	return "FwupdateValue"
}

func (v FwupdateValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"progress":   basetypes.Int64Type{},
		"status":     basetypes.StringType{},
		"status_id":  basetypes.Int64Type{},
		"timestamp":  basetypes.Float64Type{},
		"will_retry": basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"progress":   v.Progress,
			"status":     v.Status,
			"status_id":  v.StatusId,
			"timestamp":  v.Timestamp,
			"will_retry": v.WillRetry,
		})

	return objVal, diags
}

func (v FwupdateValue) Equal(o attr.Value) bool {
	other, ok := o.(FwupdateValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Progress.Equal(other.Progress) {
		return false
	}

	if !v.Status.Equal(other.Status) {
		return false
	}

	if !v.StatusId.Equal(other.StatusId) {
		return false
	}

	if !v.Timestamp.Equal(other.Timestamp) {
		return false
	}

	if !v.WillRetry.Equal(other.WillRetry) {
		return false
	}

	return true
}

func (v FwupdateValue) Type(ctx context.Context) attr.Type {
	return FwupdateType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v FwupdateValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"progress":   basetypes.Int64Type{},
		"status":     basetypes.StringType{},
		"status_id":  basetypes.Int64Type{},
		"timestamp":  basetypes.Float64Type{},
		"will_retry": basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = IotStatType{}

type IotStatType struct {
	basetypes.ObjectType
}

func (t IotStatType) Equal(o attr.Type) bool {
	other, ok := o.(IotStatType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t IotStatType) String() string {
	return "IotStatType"
}

func (t IotStatType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return nil, diags
	}

	valueVal, ok := valueAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.Int64Value, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return IotStatValue{
		Value: valueVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewIotStatValueNull() IotStatValue {
	return IotStatValue{
		state: attr.ValueStateNull,
	}
}

func NewIotStatValueUnknown() IotStatValue {
	return IotStatValue{
		state: attr.ValueStateUnknown,
	}
}

func NewIotStatValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (IotStatValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing IotStatValue Attribute Value",
				"While creating a IotStatValue value, a missing attribute value was detected. "+
					"A IotStatValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("IotStatValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid IotStatValue Attribute Type",
				"While creating a IotStatValue value, an invalid attribute value was detected. "+
					"A IotStatValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("IotStatValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("IotStatValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra IotStatValue Attribute Value",
				"While creating a IotStatValue value, an extra attribute value was detected. "+
					"A IotStatValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra IotStatValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewIotStatValueUnknown(), diags
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return NewIotStatValueUnknown(), diags
	}

	valueVal, ok := valueAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.Int64Value, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return NewIotStatValueUnknown(), diags
	}

	return IotStatValue{
		Value: valueVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewIotStatValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) IotStatValue {
	object, diags := NewIotStatValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewIotStatValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t IotStatType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewIotStatValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewIotStatValueUnknown(), nil
	}

	if in.IsNull() {
		return NewIotStatValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewIotStatValueMust(IotStatValue{}.AttributeTypes(ctx), attributes), nil
}

func (t IotStatType) ValueType(ctx context.Context) attr.Value {
	return IotStatValue{}
}

var _ basetypes.ObjectValuable = IotStatValue{}

type IotStatValue struct {
	Value basetypes.Int64Value `tfsdk:"value"`
	state attr.ValueState
}

func (v IotStatValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["value"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Value.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["value"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v IotStatValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v IotStatValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v IotStatValue) String() string {
	return "IotStatValue"
}

func (v IotStatValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"value": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"value": v.Value,
		})

	return objVal, diags
}

func (v IotStatValue) Equal(o attr.Value) bool {
	other, ok := o.(IotStatValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Value.Equal(other.Value) {
		return false
	}

	return true
}

func (v IotStatValue) Type(ctx context.Context) attr.Type {
	return IotStatType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v IotStatValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"value": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = IpConfigType{}

type IpConfigType struct {
	basetypes.ObjectType
}

func (t IpConfigType) Equal(o attr.Type) bool {
	other, ok := o.(IpConfigType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t IpConfigType) String() string {
	return "IpConfigType"
}

func (t IpConfigType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	dnsAttribute, ok := attributes["dns"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dns is missing from object`)

		return nil, diags
	}

	dnsVal, ok := dnsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dns expected to be basetypes.ListValue, was: %T`, dnsAttribute))
	}

	dnsSuffixAttribute, ok := attributes["dns_suffix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dns_suffix is missing from object`)

		return nil, diags
	}

	dnsSuffixVal, ok := dnsSuffixAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dns_suffix expected to be basetypes.ListValue, was: %T`, dnsSuffixAttribute))
	}

	gatewayAttribute, ok := attributes["gateway"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gateway is missing from object`)

		return nil, diags
	}

	gatewayVal, ok := gatewayAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gateway expected to be basetypes.StringValue, was: %T`, gatewayAttribute))
	}

	gateway6Attribute, ok := attributes["gateway6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gateway6 is missing from object`)

		return nil, diags
	}

	gateway6Val, ok := gateway6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gateway6 expected to be basetypes.StringValue, was: %T`, gateway6Attribute))
	}

	ipAttribute, ok := attributes["ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip is missing from object`)

		return nil, diags
	}

	ipVal, ok := ipAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip expected to be basetypes.StringValue, was: %T`, ipAttribute))
	}

	ip6Attribute, ok := attributes["ip6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip6 is missing from object`)

		return nil, diags
	}

	ip6Val, ok := ip6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip6 expected to be basetypes.StringValue, was: %T`, ip6Attribute))
	}

	mtuAttribute, ok := attributes["mtu"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mtu is missing from object`)

		return nil, diags
	}

	mtuVal, ok := mtuAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mtu expected to be basetypes.Int64Value, was: %T`, mtuAttribute))
	}

	netmaskAttribute, ok := attributes["netmask"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`netmask is missing from object`)

		return nil, diags
	}

	netmaskVal, ok := netmaskAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`netmask expected to be basetypes.StringValue, was: %T`, netmaskAttribute))
	}

	netmask6Attribute, ok := attributes["netmask6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`netmask6 is missing from object`)

		return nil, diags
	}

	netmask6Val, ok := netmask6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`netmask6 expected to be basetypes.StringValue, was: %T`, netmask6Attribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	type6Attribute, ok := attributes["type6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type6 is missing from object`)

		return nil, diags
	}

	type6Val, ok := type6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type6 expected to be basetypes.StringValue, was: %T`, type6Attribute))
	}

	vlanIdAttribute, ok := attributes["vlan_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan_id is missing from object`)

		return nil, diags
	}

	vlanIdVal, ok := vlanIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan_id expected to be basetypes.Int64Value, was: %T`, vlanIdAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return IpConfigValue{
		Dns:          dnsVal,
		DnsSuffix:    dnsSuffixVal,
		Gateway:      gatewayVal,
		Gateway6:     gateway6Val,
		Ip:           ipVal,
		Ip6:          ip6Val,
		Mtu:          mtuVal,
		Netmask:      netmaskVal,
		Netmask6:     netmask6Val,
		IpConfigType: typeVal,
		Type6:        type6Val,
		VlanId:       vlanIdVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewIpConfigValueNull() IpConfigValue {
	return IpConfigValue{
		state: attr.ValueStateNull,
	}
}

func NewIpConfigValueUnknown() IpConfigValue {
	return IpConfigValue{
		state: attr.ValueStateUnknown,
	}
}

func NewIpConfigValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (IpConfigValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing IpConfigValue Attribute Value",
				"While creating a IpConfigValue value, a missing attribute value was detected. "+
					"A IpConfigValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("IpConfigValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid IpConfigValue Attribute Type",
				"While creating a IpConfigValue value, an invalid attribute value was detected. "+
					"A IpConfigValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("IpConfigValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("IpConfigValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra IpConfigValue Attribute Value",
				"While creating a IpConfigValue value, an extra attribute value was detected. "+
					"A IpConfigValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra IpConfigValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewIpConfigValueUnknown(), diags
	}

	dnsAttribute, ok := attributes["dns"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dns is missing from object`)

		return NewIpConfigValueUnknown(), diags
	}

	dnsVal, ok := dnsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dns expected to be basetypes.ListValue, was: %T`, dnsAttribute))
	}

	dnsSuffixAttribute, ok := attributes["dns_suffix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dns_suffix is missing from object`)

		return NewIpConfigValueUnknown(), diags
	}

	dnsSuffixVal, ok := dnsSuffixAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dns_suffix expected to be basetypes.ListValue, was: %T`, dnsSuffixAttribute))
	}

	gatewayAttribute, ok := attributes["gateway"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gateway is missing from object`)

		return NewIpConfigValueUnknown(), diags
	}

	gatewayVal, ok := gatewayAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gateway expected to be basetypes.StringValue, was: %T`, gatewayAttribute))
	}

	gateway6Attribute, ok := attributes["gateway6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gateway6 is missing from object`)

		return NewIpConfigValueUnknown(), diags
	}

	gateway6Val, ok := gateway6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gateway6 expected to be basetypes.StringValue, was: %T`, gateway6Attribute))
	}

	ipAttribute, ok := attributes["ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip is missing from object`)

		return NewIpConfigValueUnknown(), diags
	}

	ipVal, ok := ipAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip expected to be basetypes.StringValue, was: %T`, ipAttribute))
	}

	ip6Attribute, ok := attributes["ip6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip6 is missing from object`)

		return NewIpConfigValueUnknown(), diags
	}

	ip6Val, ok := ip6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip6 expected to be basetypes.StringValue, was: %T`, ip6Attribute))
	}

	mtuAttribute, ok := attributes["mtu"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mtu is missing from object`)

		return NewIpConfigValueUnknown(), diags
	}

	mtuVal, ok := mtuAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mtu expected to be basetypes.Int64Value, was: %T`, mtuAttribute))
	}

	netmaskAttribute, ok := attributes["netmask"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`netmask is missing from object`)

		return NewIpConfigValueUnknown(), diags
	}

	netmaskVal, ok := netmaskAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`netmask expected to be basetypes.StringValue, was: %T`, netmaskAttribute))
	}

	netmask6Attribute, ok := attributes["netmask6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`netmask6 is missing from object`)

		return NewIpConfigValueUnknown(), diags
	}

	netmask6Val, ok := netmask6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`netmask6 expected to be basetypes.StringValue, was: %T`, netmask6Attribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewIpConfigValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	type6Attribute, ok := attributes["type6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type6 is missing from object`)

		return NewIpConfigValueUnknown(), diags
	}

	type6Val, ok := type6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type6 expected to be basetypes.StringValue, was: %T`, type6Attribute))
	}

	vlanIdAttribute, ok := attributes["vlan_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan_id is missing from object`)

		return NewIpConfigValueUnknown(), diags
	}

	vlanIdVal, ok := vlanIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan_id expected to be basetypes.Int64Value, was: %T`, vlanIdAttribute))
	}

	if diags.HasError() {
		return NewIpConfigValueUnknown(), diags
	}

	return IpConfigValue{
		Dns:          dnsVal,
		DnsSuffix:    dnsSuffixVal,
		Gateway:      gatewayVal,
		Gateway6:     gateway6Val,
		Ip:           ipVal,
		Ip6:          ip6Val,
		Mtu:          mtuVal,
		Netmask:      netmaskVal,
		Netmask6:     netmask6Val,
		IpConfigType: typeVal,
		Type6:        type6Val,
		VlanId:       vlanIdVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewIpConfigValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) IpConfigValue {
	object, diags := NewIpConfigValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewIpConfigValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t IpConfigType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewIpConfigValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewIpConfigValueUnknown(), nil
	}

	if in.IsNull() {
		return NewIpConfigValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewIpConfigValueMust(IpConfigValue{}.AttributeTypes(ctx), attributes), nil
}

func (t IpConfigType) ValueType(ctx context.Context) attr.Value {
	return IpConfigValue{}
}

var _ basetypes.ObjectValuable = IpConfigValue{}

type IpConfigValue struct {
	Dns          basetypes.ListValue   `tfsdk:"dns"`
	DnsSuffix    basetypes.ListValue   `tfsdk:"dns_suffix"`
	Gateway      basetypes.StringValue `tfsdk:"gateway"`
	Gateway6     basetypes.StringValue `tfsdk:"gateway6"`
	Ip           basetypes.StringValue `tfsdk:"ip"`
	Ip6          basetypes.StringValue `tfsdk:"ip6"`
	Mtu          basetypes.Int64Value  `tfsdk:"mtu"`
	Netmask      basetypes.StringValue `tfsdk:"netmask"`
	Netmask6     basetypes.StringValue `tfsdk:"netmask6"`
	IpConfigType basetypes.StringValue `tfsdk:"type"`
	Type6        basetypes.StringValue `tfsdk:"type6"`
	VlanId       basetypes.Int64Value  `tfsdk:"vlan_id"`
	state        attr.ValueState
}

func (v IpConfigValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 12)

	var val tftypes.Value
	var err error

	attrTypes["dns"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["dns_suffix"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["gateway"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["gateway6"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ip"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ip6"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["mtu"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["netmask"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["netmask6"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["type6"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["vlan_id"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 12)

		val, err = v.Dns.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dns"] = val

		val, err = v.DnsSuffix.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dns_suffix"] = val

		val, err = v.Gateway.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["gateway"] = val

		val, err = v.Gateway6.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["gateway6"] = val

		val, err = v.Ip.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip"] = val

		val, err = v.Ip6.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip6"] = val

		val, err = v.Mtu.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mtu"] = val

		val, err = v.Netmask.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["netmask"] = val

		val, err = v.Netmask6.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["netmask6"] = val

		val, err = v.IpConfigType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		val, err = v.Type6.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type6"] = val

		val, err = v.VlanId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vlan_id"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v IpConfigValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v IpConfigValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v IpConfigValue) String() string {
	return "IpConfigValue"
}

func (v IpConfigValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	dnsVal, d := types.ListValue(types.StringType, v.Dns.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"dns": basetypes.ListType{
				ElemType: types.StringType,
			},
			"dns_suffix": basetypes.ListType{
				ElemType: types.StringType,
			},
			"gateway":  basetypes.StringType{},
			"gateway6": basetypes.StringType{},
			"ip":       basetypes.StringType{},
			"ip6":      basetypes.StringType{},
			"mtu":      basetypes.Int64Type{},
			"netmask":  basetypes.StringType{},
			"netmask6": basetypes.StringType{},
			"type":     basetypes.StringType{},
			"type6":    basetypes.StringType{},
			"vlan_id":  basetypes.Int64Type{},
		}), diags
	}

	dnsSuffixVal, d := types.ListValue(types.StringType, v.DnsSuffix.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"dns": basetypes.ListType{
				ElemType: types.StringType,
			},
			"dns_suffix": basetypes.ListType{
				ElemType: types.StringType,
			},
			"gateway":  basetypes.StringType{},
			"gateway6": basetypes.StringType{},
			"ip":       basetypes.StringType{},
			"ip6":      basetypes.StringType{},
			"mtu":      basetypes.Int64Type{},
			"netmask":  basetypes.StringType{},
			"netmask6": basetypes.StringType{},
			"type":     basetypes.StringType{},
			"type6":    basetypes.StringType{},
			"vlan_id":  basetypes.Int64Type{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"dns": basetypes.ListType{
			ElemType: types.StringType,
		},
		"dns_suffix": basetypes.ListType{
			ElemType: types.StringType,
		},
		"gateway":  basetypes.StringType{},
		"gateway6": basetypes.StringType{},
		"ip":       basetypes.StringType{},
		"ip6":      basetypes.StringType{},
		"mtu":      basetypes.Int64Type{},
		"netmask":  basetypes.StringType{},
		"netmask6": basetypes.StringType{},
		"type":     basetypes.StringType{},
		"type6":    basetypes.StringType{},
		"vlan_id":  basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"dns":        dnsVal,
			"dns_suffix": dnsSuffixVal,
			"gateway":    v.Gateway,
			"gateway6":   v.Gateway6,
			"ip":         v.Ip,
			"ip6":        v.Ip6,
			"mtu":        v.Mtu,
			"netmask":    v.Netmask,
			"netmask6":   v.Netmask6,
			"type":       v.IpConfigType,
			"type6":      v.Type6,
			"vlan_id":    v.VlanId,
		})

	return objVal, diags
}

func (v IpConfigValue) Equal(o attr.Value) bool {
	other, ok := o.(IpConfigValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Dns.Equal(other.Dns) {
		return false
	}

	if !v.DnsSuffix.Equal(other.DnsSuffix) {
		return false
	}

	if !v.Gateway.Equal(other.Gateway) {
		return false
	}

	if !v.Gateway6.Equal(other.Gateway6) {
		return false
	}

	if !v.Ip.Equal(other.Ip) {
		return false
	}

	if !v.Ip6.Equal(other.Ip6) {
		return false
	}

	if !v.Mtu.Equal(other.Mtu) {
		return false
	}

	if !v.Netmask.Equal(other.Netmask) {
		return false
	}

	if !v.Netmask6.Equal(other.Netmask6) {
		return false
	}

	if !v.IpConfigType.Equal(other.IpConfigType) {
		return false
	}

	if !v.Type6.Equal(other.Type6) {
		return false
	}

	if !v.VlanId.Equal(other.VlanId) {
		return false
	}

	return true
}

func (v IpConfigValue) Type(ctx context.Context) attr.Type {
	return IpConfigType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v IpConfigValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"dns": basetypes.ListType{
			ElemType: types.StringType,
		},
		"dns_suffix": basetypes.ListType{
			ElemType: types.StringType,
		},
		"gateway":  basetypes.StringType{},
		"gateway6": basetypes.StringType{},
		"ip":       basetypes.StringType{},
		"ip6":      basetypes.StringType{},
		"mtu":      basetypes.Int64Type{},
		"netmask":  basetypes.StringType{},
		"netmask6": basetypes.StringType{},
		"type":     basetypes.StringType{},
		"type6":    basetypes.StringType{},
		"vlan_id":  basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = IpStatType{}

type IpStatType struct {
	basetypes.ObjectType
}

func (t IpStatType) Equal(o attr.Type) bool {
	other, ok := o.(IpStatType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t IpStatType) String() string {
	return "IpStatType"
}

func (t IpStatType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	dhcpServerAttribute, ok := attributes["dhcp_server"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dhcp_server is missing from object`)

		return nil, diags
	}

	dhcpServerVal, ok := dhcpServerAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dhcp_server expected to be basetypes.StringValue, was: %T`, dhcpServerAttribute))
	}

	dnsAttribute, ok := attributes["dns"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dns is missing from object`)

		return nil, diags
	}

	dnsVal, ok := dnsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dns expected to be basetypes.ListValue, was: %T`, dnsAttribute))
	}

	dnsSuffixAttribute, ok := attributes["dns_suffix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dns_suffix is missing from object`)

		return nil, diags
	}

	dnsSuffixVal, ok := dnsSuffixAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dns_suffix expected to be basetypes.ListValue, was: %T`, dnsSuffixAttribute))
	}

	gatewayAttribute, ok := attributes["gateway"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gateway is missing from object`)

		return nil, diags
	}

	gatewayVal, ok := gatewayAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gateway expected to be basetypes.StringValue, was: %T`, gatewayAttribute))
	}

	gateway6Attribute, ok := attributes["gateway6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gateway6 is missing from object`)

		return nil, diags
	}

	gateway6Val, ok := gateway6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gateway6 expected to be basetypes.StringValue, was: %T`, gateway6Attribute))
	}

	ipAttribute, ok := attributes["ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip is missing from object`)

		return nil, diags
	}

	ipVal, ok := ipAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip expected to be basetypes.StringValue, was: %T`, ipAttribute))
	}

	ip6Attribute, ok := attributes["ip6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip6 is missing from object`)

		return nil, diags
	}

	ip6Val, ok := ip6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip6 expected to be basetypes.StringValue, was: %T`, ip6Attribute))
	}

	ipsAttribute, ok := attributes["ips"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ips is missing from object`)

		return nil, diags
	}

	ipsVal, ok := ipsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ips expected to be basetypes.MapValue, was: %T`, ipsAttribute))
	}

	netmaskAttribute, ok := attributes["netmask"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`netmask is missing from object`)

		return nil, diags
	}

	netmaskVal, ok := netmaskAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`netmask expected to be basetypes.StringValue, was: %T`, netmaskAttribute))
	}

	netmask6Attribute, ok := attributes["netmask6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`netmask6 is missing from object`)

		return nil, diags
	}

	netmask6Val, ok := netmask6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`netmask6 expected to be basetypes.StringValue, was: %T`, netmask6Attribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return IpStatValue{
		DhcpServer: dhcpServerVal,
		Dns:        dnsVal,
		DnsSuffix:  dnsSuffixVal,
		Gateway:    gatewayVal,
		Gateway6:   gateway6Val,
		Ip:         ipVal,
		Ip6:        ip6Val,
		Ips:        ipsVal,
		Netmask:    netmaskVal,
		Netmask6:   netmask6Val,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewIpStatValueNull() IpStatValue {
	return IpStatValue{
		state: attr.ValueStateNull,
	}
}

func NewIpStatValueUnknown() IpStatValue {
	return IpStatValue{
		state: attr.ValueStateUnknown,
	}
}

func NewIpStatValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (IpStatValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing IpStatValue Attribute Value",
				"While creating a IpStatValue value, a missing attribute value was detected. "+
					"A IpStatValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("IpStatValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid IpStatValue Attribute Type",
				"While creating a IpStatValue value, an invalid attribute value was detected. "+
					"A IpStatValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("IpStatValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("IpStatValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra IpStatValue Attribute Value",
				"While creating a IpStatValue value, an extra attribute value was detected. "+
					"A IpStatValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra IpStatValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewIpStatValueUnknown(), diags
	}

	dhcpServerAttribute, ok := attributes["dhcp_server"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dhcp_server is missing from object`)

		return NewIpStatValueUnknown(), diags
	}

	dhcpServerVal, ok := dhcpServerAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dhcp_server expected to be basetypes.StringValue, was: %T`, dhcpServerAttribute))
	}

	dnsAttribute, ok := attributes["dns"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dns is missing from object`)

		return NewIpStatValueUnknown(), diags
	}

	dnsVal, ok := dnsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dns expected to be basetypes.ListValue, was: %T`, dnsAttribute))
	}

	dnsSuffixAttribute, ok := attributes["dns_suffix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dns_suffix is missing from object`)

		return NewIpStatValueUnknown(), diags
	}

	dnsSuffixVal, ok := dnsSuffixAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dns_suffix expected to be basetypes.ListValue, was: %T`, dnsSuffixAttribute))
	}

	gatewayAttribute, ok := attributes["gateway"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gateway is missing from object`)

		return NewIpStatValueUnknown(), diags
	}

	gatewayVal, ok := gatewayAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gateway expected to be basetypes.StringValue, was: %T`, gatewayAttribute))
	}

	gateway6Attribute, ok := attributes["gateway6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gateway6 is missing from object`)

		return NewIpStatValueUnknown(), diags
	}

	gateway6Val, ok := gateway6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gateway6 expected to be basetypes.StringValue, was: %T`, gateway6Attribute))
	}

	ipAttribute, ok := attributes["ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip is missing from object`)

		return NewIpStatValueUnknown(), diags
	}

	ipVal, ok := ipAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip expected to be basetypes.StringValue, was: %T`, ipAttribute))
	}

	ip6Attribute, ok := attributes["ip6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip6 is missing from object`)

		return NewIpStatValueUnknown(), diags
	}

	ip6Val, ok := ip6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip6 expected to be basetypes.StringValue, was: %T`, ip6Attribute))
	}

	ipsAttribute, ok := attributes["ips"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ips is missing from object`)

		return NewIpStatValueUnknown(), diags
	}

	ipsVal, ok := ipsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ips expected to be basetypes.MapValue, was: %T`, ipsAttribute))
	}

	netmaskAttribute, ok := attributes["netmask"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`netmask is missing from object`)

		return NewIpStatValueUnknown(), diags
	}

	netmaskVal, ok := netmaskAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`netmask expected to be basetypes.StringValue, was: %T`, netmaskAttribute))
	}

	netmask6Attribute, ok := attributes["netmask6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`netmask6 is missing from object`)

		return NewIpStatValueUnknown(), diags
	}

	netmask6Val, ok := netmask6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`netmask6 expected to be basetypes.StringValue, was: %T`, netmask6Attribute))
	}

	if diags.HasError() {
		return NewIpStatValueUnknown(), diags
	}

	return IpStatValue{
		DhcpServer: dhcpServerVal,
		Dns:        dnsVal,
		DnsSuffix:  dnsSuffixVal,
		Gateway:    gatewayVal,
		Gateway6:   gateway6Val,
		Ip:         ipVal,
		Ip6:        ip6Val,
		Ips:        ipsVal,
		Netmask:    netmaskVal,
		Netmask6:   netmask6Val,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewIpStatValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) IpStatValue {
	object, diags := NewIpStatValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewIpStatValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t IpStatType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewIpStatValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewIpStatValueUnknown(), nil
	}

	if in.IsNull() {
		return NewIpStatValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewIpStatValueMust(IpStatValue{}.AttributeTypes(ctx), attributes), nil
}

func (t IpStatType) ValueType(ctx context.Context) attr.Value {
	return IpStatValue{}
}

var _ basetypes.ObjectValuable = IpStatValue{}

type IpStatValue struct {
	DhcpServer basetypes.StringValue `tfsdk:"dhcp_server"`
	Dns        basetypes.ListValue   `tfsdk:"dns"`
	DnsSuffix  basetypes.ListValue   `tfsdk:"dns_suffix"`
	Gateway    basetypes.StringValue `tfsdk:"gateway"`
	Gateway6   basetypes.StringValue `tfsdk:"gateway6"`
	Ip         basetypes.StringValue `tfsdk:"ip"`
	Ip6        basetypes.StringValue `tfsdk:"ip6"`
	Ips        basetypes.MapValue    `tfsdk:"ips"`
	Netmask    basetypes.StringValue `tfsdk:"netmask"`
	Netmask6   basetypes.StringValue `tfsdk:"netmask6"`
	state      attr.ValueState
}

func (v IpStatValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 10)

	var val tftypes.Value
	var err error

	attrTypes["dhcp_server"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["dns"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["dns_suffix"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["gateway"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["gateway6"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ip"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ip6"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ips"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["netmask"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["netmask6"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 10)

		val, err = v.DhcpServer.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dhcp_server"] = val

		val, err = v.Dns.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dns"] = val

		val, err = v.DnsSuffix.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dns_suffix"] = val

		val, err = v.Gateway.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["gateway"] = val

		val, err = v.Gateway6.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["gateway6"] = val

		val, err = v.Ip.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip"] = val

		val, err = v.Ip6.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip6"] = val

		val, err = v.Ips.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ips"] = val

		val, err = v.Netmask.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["netmask"] = val

		val, err = v.Netmask6.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["netmask6"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v IpStatValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v IpStatValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v IpStatValue) String() string {
	return "IpStatValue"
}

func (v IpStatValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	dnsVal, d := types.ListValue(types.StringType, v.Dns.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"dhcp_server": basetypes.StringType{},
			"dns": basetypes.ListType{
				ElemType: types.StringType,
			},
			"dns_suffix": basetypes.ListType{
				ElemType: types.StringType,
			},
			"gateway":  basetypes.StringType{},
			"gateway6": basetypes.StringType{},
			"ip":       basetypes.StringType{},
			"ip6":      basetypes.StringType{},
			"ips": basetypes.MapType{
				ElemType: types.StringType,
			},
			"netmask":  basetypes.StringType{},
			"netmask6": basetypes.StringType{},
		}), diags
	}

	dnsSuffixVal, d := types.ListValue(types.StringType, v.DnsSuffix.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"dhcp_server": basetypes.StringType{},
			"dns": basetypes.ListType{
				ElemType: types.StringType,
			},
			"dns_suffix": basetypes.ListType{
				ElemType: types.StringType,
			},
			"gateway":  basetypes.StringType{},
			"gateway6": basetypes.StringType{},
			"ip":       basetypes.StringType{},
			"ip6":      basetypes.StringType{},
			"ips": basetypes.MapType{
				ElemType: types.StringType,
			},
			"netmask":  basetypes.StringType{},
			"netmask6": basetypes.StringType{},
		}), diags
	}

	ipsVal, d := types.MapValue(types.StringType, v.Ips.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"dhcp_server": basetypes.StringType{},
			"dns": basetypes.ListType{
				ElemType: types.StringType,
			},
			"dns_suffix": basetypes.ListType{
				ElemType: types.StringType,
			},
			"gateway":  basetypes.StringType{},
			"gateway6": basetypes.StringType{},
			"ip":       basetypes.StringType{},
			"ip6":      basetypes.StringType{},
			"ips": basetypes.MapType{
				ElemType: types.StringType,
			},
			"netmask":  basetypes.StringType{},
			"netmask6": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"dhcp_server": basetypes.StringType{},
		"dns": basetypes.ListType{
			ElemType: types.StringType,
		},
		"dns_suffix": basetypes.ListType{
			ElemType: types.StringType,
		},
		"gateway":  basetypes.StringType{},
		"gateway6": basetypes.StringType{},
		"ip":       basetypes.StringType{},
		"ip6":      basetypes.StringType{},
		"ips": basetypes.MapType{
			ElemType: types.StringType,
		},
		"netmask":  basetypes.StringType{},
		"netmask6": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"dhcp_server": v.DhcpServer,
			"dns":         dnsVal,
			"dns_suffix":  dnsSuffixVal,
			"gateway":     v.Gateway,
			"gateway6":    v.Gateway6,
			"ip":          v.Ip,
			"ip6":         v.Ip6,
			"ips":         ipsVal,
			"netmask":     v.Netmask,
			"netmask6":    v.Netmask6,
		})

	return objVal, diags
}

func (v IpStatValue) Equal(o attr.Value) bool {
	other, ok := o.(IpStatValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.DhcpServer.Equal(other.DhcpServer) {
		return false
	}

	if !v.Dns.Equal(other.Dns) {
		return false
	}

	if !v.DnsSuffix.Equal(other.DnsSuffix) {
		return false
	}

	if !v.Gateway.Equal(other.Gateway) {
		return false
	}

	if !v.Gateway6.Equal(other.Gateway6) {
		return false
	}

	if !v.Ip.Equal(other.Ip) {
		return false
	}

	if !v.Ip6.Equal(other.Ip6) {
		return false
	}

	if !v.Ips.Equal(other.Ips) {
		return false
	}

	if !v.Netmask.Equal(other.Netmask) {
		return false
	}

	if !v.Netmask6.Equal(other.Netmask6) {
		return false
	}

	return true
}

func (v IpStatValue) Type(ctx context.Context) attr.Type {
	return IpStatType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v IpStatValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"dhcp_server": basetypes.StringType{},
		"dns": basetypes.ListType{
			ElemType: types.StringType,
		},
		"dns_suffix": basetypes.ListType{
			ElemType: types.StringType,
		},
		"gateway":  basetypes.StringType{},
		"gateway6": basetypes.StringType{},
		"ip":       basetypes.StringType{},
		"ip6":      basetypes.StringType{},
		"ips": basetypes.MapType{
			ElemType: types.StringType,
		},
		"netmask":  basetypes.StringType{},
		"netmask6": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = L2tpStatType{}

type L2tpStatType struct {
	basetypes.ObjectType
}

func (t L2tpStatType) Equal(o attr.Type) bool {
	other, ok := o.(L2tpStatType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t L2tpStatType) String() string {
	return "L2tpStatType"
}

func (t L2tpStatType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	sessionsAttribute, ok := attributes["sessions"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sessions is missing from object`)

		return nil, diags
	}

	sessionsVal, ok := sessionsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sessions expected to be basetypes.ListValue, was: %T`, sessionsAttribute))
	}

	stateAttribute, ok := attributes["state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`state is missing from object`)

		return nil, diags
	}

	stateVal, ok := stateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`state expected to be basetypes.StringValue, was: %T`, stateAttribute))
	}

	uptimeAttribute, ok := attributes["uptime"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uptime is missing from object`)

		return nil, diags
	}

	uptimeVal, ok := uptimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uptime expected to be basetypes.Int64Value, was: %T`, uptimeAttribute))
	}

	wxtunnelIdAttribute, ok := attributes["wxtunnel_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wxtunnel_id is missing from object`)

		return nil, diags
	}

	wxtunnelIdVal, ok := wxtunnelIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wxtunnel_id expected to be basetypes.StringValue, was: %T`, wxtunnelIdAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return L2tpStatValue{
		Sessions:   sessionsVal,
		State:      stateVal,
		Uptime:     uptimeVal,
		WxtunnelId: wxtunnelIdVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewL2tpStatValueNull() L2tpStatValue {
	return L2tpStatValue{
		state: attr.ValueStateNull,
	}
}

func NewL2tpStatValueUnknown() L2tpStatValue {
	return L2tpStatValue{
		state: attr.ValueStateUnknown,
	}
}

func NewL2tpStatValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (L2tpStatValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing L2tpStatValue Attribute Value",
				"While creating a L2tpStatValue value, a missing attribute value was detected. "+
					"A L2tpStatValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("L2tpStatValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid L2tpStatValue Attribute Type",
				"While creating a L2tpStatValue value, an invalid attribute value was detected. "+
					"A L2tpStatValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("L2tpStatValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("L2tpStatValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra L2tpStatValue Attribute Value",
				"While creating a L2tpStatValue value, an extra attribute value was detected. "+
					"A L2tpStatValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra L2tpStatValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewL2tpStatValueUnknown(), diags
	}

	sessionsAttribute, ok := attributes["sessions"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sessions is missing from object`)

		return NewL2tpStatValueUnknown(), diags
	}

	sessionsVal, ok := sessionsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sessions expected to be basetypes.ListValue, was: %T`, sessionsAttribute))
	}

	stateAttribute, ok := attributes["state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`state is missing from object`)

		return NewL2tpStatValueUnknown(), diags
	}

	stateVal, ok := stateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`state expected to be basetypes.StringValue, was: %T`, stateAttribute))
	}

	uptimeAttribute, ok := attributes["uptime"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uptime is missing from object`)

		return NewL2tpStatValueUnknown(), diags
	}

	uptimeVal, ok := uptimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uptime expected to be basetypes.Int64Value, was: %T`, uptimeAttribute))
	}

	wxtunnelIdAttribute, ok := attributes["wxtunnel_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wxtunnel_id is missing from object`)

		return NewL2tpStatValueUnknown(), diags
	}

	wxtunnelIdVal, ok := wxtunnelIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wxtunnel_id expected to be basetypes.StringValue, was: %T`, wxtunnelIdAttribute))
	}

	if diags.HasError() {
		return NewL2tpStatValueUnknown(), diags
	}

	return L2tpStatValue{
		Sessions:   sessionsVal,
		State:      stateVal,
		Uptime:     uptimeVal,
		WxtunnelId: wxtunnelIdVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewL2tpStatValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) L2tpStatValue {
	object, diags := NewL2tpStatValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewL2tpStatValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t L2tpStatType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewL2tpStatValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewL2tpStatValueUnknown(), nil
	}

	if in.IsNull() {
		return NewL2tpStatValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewL2tpStatValueMust(L2tpStatValue{}.AttributeTypes(ctx), attributes), nil
}

func (t L2tpStatType) ValueType(ctx context.Context) attr.Value {
	return L2tpStatValue{}
}

var _ basetypes.ObjectValuable = L2tpStatValue{}

type L2tpStatValue struct {
	Sessions   basetypes.ListValue   `tfsdk:"sessions"`
	State      basetypes.StringValue `tfsdk:"state"`
	Uptime     basetypes.Int64Value  `tfsdk:"uptime"`
	WxtunnelId basetypes.StringValue `tfsdk:"wxtunnel_id"`
	state      attr.ValueState
}

func (v L2tpStatValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["sessions"] = basetypes.ListType{
		ElemType: SessionsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["state"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["uptime"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["wxtunnel_id"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Sessions.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["sessions"] = val

		val, err = v.State.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["state"] = val

		val, err = v.Uptime.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["uptime"] = val

		val, err = v.WxtunnelId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["wxtunnel_id"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v L2tpStatValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v L2tpStatValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v L2tpStatValue) String() string {
	return "L2tpStatValue"
}

func (v L2tpStatValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	sessions := types.ListValueMust(
		SessionsType{
			basetypes.ObjectType{
				AttrTypes: SessionsValue{}.AttributeTypes(ctx),
			},
		},
		v.Sessions.Elements(),
	)

	if v.Sessions.IsNull() {
		sessions = types.ListNull(
			SessionsType{
				basetypes.ObjectType{
					AttrTypes: SessionsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Sessions.IsUnknown() {
		sessions = types.ListUnknown(
			SessionsType{
				basetypes.ObjectType{
					AttrTypes: SessionsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"sessions": basetypes.ListType{
			ElemType: SessionsValue{}.Type(ctx),
		},
		"state":       basetypes.StringType{},
		"uptime":      basetypes.Int64Type{},
		"wxtunnel_id": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"sessions":    sessions,
			"state":       v.State,
			"uptime":      v.Uptime,
			"wxtunnel_id": v.WxtunnelId,
		})

	return objVal, diags
}

func (v L2tpStatValue) Equal(o attr.Value) bool {
	other, ok := o.(L2tpStatValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Sessions.Equal(other.Sessions) {
		return false
	}

	if !v.State.Equal(other.State) {
		return false
	}

	if !v.Uptime.Equal(other.Uptime) {
		return false
	}

	if !v.WxtunnelId.Equal(other.WxtunnelId) {
		return false
	}

	return true
}

func (v L2tpStatValue) Type(ctx context.Context) attr.Type {
	return L2tpStatType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v L2tpStatValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"sessions": basetypes.ListType{
			ElemType: SessionsValue{}.Type(ctx),
		},
		"state":       basetypes.StringType{},
		"uptime":      basetypes.Int64Type{},
		"wxtunnel_id": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = SessionsType{}

type SessionsType struct {
	basetypes.ObjectType
}

func (t SessionsType) Equal(o attr.Type) bool {
	other, ok := o.(SessionsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SessionsType) String() string {
	return "SessionsType"
}

func (t SessionsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	localSidAttribute, ok := attributes["local_sid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`local_sid is missing from object`)

		return nil, diags
	}

	localSidVal, ok := localSidAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`local_sid expected to be basetypes.Int64Value, was: %T`, localSidAttribute))
	}

	remoteIdAttribute, ok := attributes["remote_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remote_id is missing from object`)

		return nil, diags
	}

	remoteIdVal, ok := remoteIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remote_id expected to be basetypes.StringValue, was: %T`, remoteIdAttribute))
	}

	remoteSidAttribute, ok := attributes["remote_sid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remote_sid is missing from object`)

		return nil, diags
	}

	remoteSidVal, ok := remoteSidAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remote_sid expected to be basetypes.Int64Value, was: %T`, remoteSidAttribute))
	}

	stateAttribute, ok := attributes["state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`state is missing from object`)

		return nil, diags
	}

	stateVal, ok := stateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`state expected to be basetypes.StringValue, was: %T`, stateAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SessionsValue{
		LocalSid:  localSidVal,
		RemoteId:  remoteIdVal,
		RemoteSid: remoteSidVal,
		State:     stateVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewSessionsValueNull() SessionsValue {
	return SessionsValue{
		state: attr.ValueStateNull,
	}
}

func NewSessionsValueUnknown() SessionsValue {
	return SessionsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSessionsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SessionsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SessionsValue Attribute Value",
				"While creating a SessionsValue value, a missing attribute value was detected. "+
					"A SessionsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SessionsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SessionsValue Attribute Type",
				"While creating a SessionsValue value, an invalid attribute value was detected. "+
					"A SessionsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SessionsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SessionsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SessionsValue Attribute Value",
				"While creating a SessionsValue value, an extra attribute value was detected. "+
					"A SessionsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SessionsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSessionsValueUnknown(), diags
	}

	localSidAttribute, ok := attributes["local_sid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`local_sid is missing from object`)

		return NewSessionsValueUnknown(), diags
	}

	localSidVal, ok := localSidAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`local_sid expected to be basetypes.Int64Value, was: %T`, localSidAttribute))
	}

	remoteIdAttribute, ok := attributes["remote_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remote_id is missing from object`)

		return NewSessionsValueUnknown(), diags
	}

	remoteIdVal, ok := remoteIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remote_id expected to be basetypes.StringValue, was: %T`, remoteIdAttribute))
	}

	remoteSidAttribute, ok := attributes["remote_sid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remote_sid is missing from object`)

		return NewSessionsValueUnknown(), diags
	}

	remoteSidVal, ok := remoteSidAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remote_sid expected to be basetypes.Int64Value, was: %T`, remoteSidAttribute))
	}

	stateAttribute, ok := attributes["state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`state is missing from object`)

		return NewSessionsValueUnknown(), diags
	}

	stateVal, ok := stateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`state expected to be basetypes.StringValue, was: %T`, stateAttribute))
	}

	if diags.HasError() {
		return NewSessionsValueUnknown(), diags
	}

	return SessionsValue{
		LocalSid:  localSidVal,
		RemoteId:  remoteIdVal,
		RemoteSid: remoteSidVal,
		State:     stateVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewSessionsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SessionsValue {
	object, diags := NewSessionsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSessionsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SessionsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSessionsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSessionsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSessionsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSessionsValueMust(SessionsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SessionsType) ValueType(ctx context.Context) attr.Value {
	return SessionsValue{}
}

var _ basetypes.ObjectValuable = SessionsValue{}

type SessionsValue struct {
	LocalSid  basetypes.Int64Value  `tfsdk:"local_sid"`
	RemoteId  basetypes.StringValue `tfsdk:"remote_id"`
	RemoteSid basetypes.Int64Value  `tfsdk:"remote_sid"`
	State     basetypes.StringValue `tfsdk:"state"`
	state     attr.ValueState
}

func (v SessionsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["local_sid"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["remote_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["remote_sid"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["state"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.LocalSid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["local_sid"] = val

		val, err = v.RemoteId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["remote_id"] = val

		val, err = v.RemoteSid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["remote_sid"] = val

		val, err = v.State.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["state"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SessionsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SessionsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SessionsValue) String() string {
	return "SessionsValue"
}

func (v SessionsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"local_sid":  basetypes.Int64Type{},
		"remote_id":  basetypes.StringType{},
		"remote_sid": basetypes.Int64Type{},
		"state":      basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"local_sid":  v.LocalSid,
			"remote_id":  v.RemoteId,
			"remote_sid": v.RemoteSid,
			"state":      v.State,
		})

	return objVal, diags
}

func (v SessionsValue) Equal(o attr.Value) bool {
	other, ok := o.(SessionsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.LocalSid.Equal(other.LocalSid) {
		return false
	}

	if !v.RemoteId.Equal(other.RemoteId) {
		return false
	}

	if !v.RemoteSid.Equal(other.RemoteSid) {
		return false
	}

	if !v.State.Equal(other.State) {
		return false
	}

	return true
}

func (v SessionsValue) Type(ctx context.Context) attr.Type {
	return SessionsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SessionsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"local_sid":  basetypes.Int64Type{},
		"remote_id":  basetypes.StringType{},
		"remote_sid": basetypes.Int64Type{},
		"state":      basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = LastTroubleType{}

type LastTroubleType struct {
	basetypes.ObjectType
}

func (t LastTroubleType) Equal(o attr.Type) bool {
	other, ok := o.(LastTroubleType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t LastTroubleType) String() string {
	return "LastTroubleType"
}

func (t LastTroubleType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	codeAttribute, ok := attributes["code"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`code is missing from object`)

		return nil, diags
	}

	codeVal, ok := codeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`code expected to be basetypes.StringValue, was: %T`, codeAttribute))
	}

	timestampAttribute, ok := attributes["timestamp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`timestamp is missing from object`)

		return nil, diags
	}

	timestampVal, ok := timestampAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`timestamp expected to be basetypes.Int64Value, was: %T`, timestampAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return LastTroubleValue{
		Code:      codeVal,
		Timestamp: timestampVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewLastTroubleValueNull() LastTroubleValue {
	return LastTroubleValue{
		state: attr.ValueStateNull,
	}
}

func NewLastTroubleValueUnknown() LastTroubleValue {
	return LastTroubleValue{
		state: attr.ValueStateUnknown,
	}
}

func NewLastTroubleValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (LastTroubleValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing LastTroubleValue Attribute Value",
				"While creating a LastTroubleValue value, a missing attribute value was detected. "+
					"A LastTroubleValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("LastTroubleValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid LastTroubleValue Attribute Type",
				"While creating a LastTroubleValue value, an invalid attribute value was detected. "+
					"A LastTroubleValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("LastTroubleValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("LastTroubleValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra LastTroubleValue Attribute Value",
				"While creating a LastTroubleValue value, an extra attribute value was detected. "+
					"A LastTroubleValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra LastTroubleValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewLastTroubleValueUnknown(), diags
	}

	codeAttribute, ok := attributes["code"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`code is missing from object`)

		return NewLastTroubleValueUnknown(), diags
	}

	codeVal, ok := codeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`code expected to be basetypes.StringValue, was: %T`, codeAttribute))
	}

	timestampAttribute, ok := attributes["timestamp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`timestamp is missing from object`)

		return NewLastTroubleValueUnknown(), diags
	}

	timestampVal, ok := timestampAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`timestamp expected to be basetypes.Int64Value, was: %T`, timestampAttribute))
	}

	if diags.HasError() {
		return NewLastTroubleValueUnknown(), diags
	}

	return LastTroubleValue{
		Code:      codeVal,
		Timestamp: timestampVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewLastTroubleValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) LastTroubleValue {
	object, diags := NewLastTroubleValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewLastTroubleValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t LastTroubleType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewLastTroubleValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewLastTroubleValueUnknown(), nil
	}

	if in.IsNull() {
		return NewLastTroubleValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewLastTroubleValueMust(LastTroubleValue{}.AttributeTypes(ctx), attributes), nil
}

func (t LastTroubleType) ValueType(ctx context.Context) attr.Value {
	return LastTroubleValue{}
}

var _ basetypes.ObjectValuable = LastTroubleValue{}

type LastTroubleValue struct {
	Code      basetypes.StringValue `tfsdk:"code"`
	Timestamp basetypes.Int64Value  `tfsdk:"timestamp"`
	state     attr.ValueState
}

func (v LastTroubleValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["code"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["timestamp"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Code.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["code"] = val

		val, err = v.Timestamp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["timestamp"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v LastTroubleValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v LastTroubleValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v LastTroubleValue) String() string {
	return "LastTroubleValue"
}

func (v LastTroubleValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"code":      basetypes.StringType{},
		"timestamp": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"code":      v.Code,
			"timestamp": v.Timestamp,
		})

	return objVal, diags
}

func (v LastTroubleValue) Equal(o attr.Value) bool {
	other, ok := o.(LastTroubleValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Code.Equal(other.Code) {
		return false
	}

	if !v.Timestamp.Equal(other.Timestamp) {
		return false
	}

	return true
}

func (v LastTroubleValue) Type(ctx context.Context) attr.Type {
	return LastTroubleType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v LastTroubleValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"code":      basetypes.StringType{},
		"timestamp": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = LedType{}

type LedType struct {
	basetypes.ObjectType
}

func (t LedType) Equal(o attr.Type) bool {
	other, ok := o.(LedType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t LedType) String() string {
	return "LedType"
}

func (t LedType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	brightnessAttribute, ok := attributes["brightness"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`brightness is missing from object`)

		return nil, diags
	}

	brightnessVal, ok := brightnessAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`brightness expected to be basetypes.Int64Value, was: %T`, brightnessAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return LedValue{
		Brightness: brightnessVal,
		Enabled:    enabledVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewLedValueNull() LedValue {
	return LedValue{
		state: attr.ValueStateNull,
	}
}

func NewLedValueUnknown() LedValue {
	return LedValue{
		state: attr.ValueStateUnknown,
	}
}

func NewLedValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (LedValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing LedValue Attribute Value",
				"While creating a LedValue value, a missing attribute value was detected. "+
					"A LedValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("LedValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid LedValue Attribute Type",
				"While creating a LedValue value, an invalid attribute value was detected. "+
					"A LedValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("LedValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("LedValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra LedValue Attribute Value",
				"While creating a LedValue value, an extra attribute value was detected. "+
					"A LedValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra LedValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewLedValueUnknown(), diags
	}

	brightnessAttribute, ok := attributes["brightness"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`brightness is missing from object`)

		return NewLedValueUnknown(), diags
	}

	brightnessVal, ok := brightnessAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`brightness expected to be basetypes.Int64Value, was: %T`, brightnessAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewLedValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	if diags.HasError() {
		return NewLedValueUnknown(), diags
	}

	return LedValue{
		Brightness: brightnessVal,
		Enabled:    enabledVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewLedValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) LedValue {
	object, diags := NewLedValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewLedValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t LedType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewLedValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewLedValueUnknown(), nil
	}

	if in.IsNull() {
		return NewLedValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewLedValueMust(LedValue{}.AttributeTypes(ctx), attributes), nil
}

func (t LedType) ValueType(ctx context.Context) attr.Value {
	return LedValue{}
}

var _ basetypes.ObjectValuable = LedValue{}

type LedValue struct {
	Brightness basetypes.Int64Value `tfsdk:"brightness"`
	Enabled    basetypes.BoolValue  `tfsdk:"enabled"`
	state      attr.ValueState
}

func (v LedValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["brightness"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Brightness.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["brightness"] = val

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v LedValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v LedValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v LedValue) String() string {
	return "LedValue"
}

func (v LedValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"brightness": basetypes.Int64Type{},
		"enabled":    basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"brightness": v.Brightness,
			"enabled":    v.Enabled,
		})

	return objVal, diags
}

func (v LedValue) Equal(o attr.Value) bool {
	other, ok := o.(LedValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Brightness.Equal(other.Brightness) {
		return false
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	return true
}

func (v LedValue) Type(ctx context.Context) attr.Type {
	return LedType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v LedValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"brightness": basetypes.Int64Type{},
		"enabled":    basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = LldpStatType{}

type LldpStatType struct {
	basetypes.ObjectType
}

func (t LldpStatType) Equal(o attr.Type) bool {
	other, ok := o.(LldpStatType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t LldpStatType) String() string {
	return "LldpStatType"
}

func (t LldpStatType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	chassisIdAttribute, ok := attributes["chassis_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`chassis_id is missing from object`)

		return nil, diags
	}

	chassisIdVal, ok := chassisIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`chassis_id expected to be basetypes.StringValue, was: %T`, chassisIdAttribute))
	}

	lldpMedSupportedAttribute, ok := attributes["lldp_med_supported"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lldp_med_supported is missing from object`)

		return nil, diags
	}

	lldpMedSupportedVal, ok := lldpMedSupportedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lldp_med_supported expected to be basetypes.BoolValue, was: %T`, lldpMedSupportedAttribute))
	}

	mgmtAddrAttribute, ok := attributes["mgmt_addr"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mgmt_addr is missing from object`)

		return nil, diags
	}

	mgmtAddrVal, ok := mgmtAddrAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mgmt_addr expected to be basetypes.StringValue, was: %T`, mgmtAddrAttribute))
	}

	mgmtAddrsAttribute, ok := attributes["mgmt_addrs"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mgmt_addrs is missing from object`)

		return nil, diags
	}

	mgmtAddrsVal, ok := mgmtAddrsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mgmt_addrs expected to be basetypes.ListValue, was: %T`, mgmtAddrsAttribute))
	}

	portDescAttribute, ok := attributes["port_desc"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_desc is missing from object`)

		return nil, diags
	}

	portDescVal, ok := portDescAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_desc expected to be basetypes.StringValue, was: %T`, portDescAttribute))
	}

	portIdAttribute, ok := attributes["port_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_id is missing from object`)

		return nil, diags
	}

	portIdVal, ok := portIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_id expected to be basetypes.StringValue, was: %T`, portIdAttribute))
	}

	powerAllocatedAttribute, ok := attributes["power_allocated"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`power_allocated is missing from object`)

		return nil, diags
	}

	powerAllocatedVal, ok := powerAllocatedAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`power_allocated expected to be basetypes.NumberValue, was: %T`, powerAllocatedAttribute))
	}

	powerDrawAttribute, ok := attributes["power_draw"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`power_draw is missing from object`)

		return nil, diags
	}

	powerDrawVal, ok := powerDrawAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`power_draw expected to be basetypes.NumberValue, was: %T`, powerDrawAttribute))
	}

	powerRequestCountAttribute, ok := attributes["power_request_count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`power_request_count is missing from object`)

		return nil, diags
	}

	powerRequestCountVal, ok := powerRequestCountAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`power_request_count expected to be basetypes.Int64Value, was: %T`, powerRequestCountAttribute))
	}

	powerRequestedAttribute, ok := attributes["power_requested"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`power_requested is missing from object`)

		return nil, diags
	}

	powerRequestedVal, ok := powerRequestedAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`power_requested expected to be basetypes.NumberValue, was: %T`, powerRequestedAttribute))
	}

	systemDescAttribute, ok := attributes["system_desc"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`system_desc is missing from object`)

		return nil, diags
	}

	systemDescVal, ok := systemDescAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`system_desc expected to be basetypes.StringValue, was: %T`, systemDescAttribute))
	}

	systemNameAttribute, ok := attributes["system_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`system_name is missing from object`)

		return nil, diags
	}

	systemNameVal, ok := systemNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`system_name expected to be basetypes.StringValue, was: %T`, systemNameAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return LldpStatValue{
		ChassisId:         chassisIdVal,
		LldpMedSupported:  lldpMedSupportedVal,
		MgmtAddr:          mgmtAddrVal,
		MgmtAddrs:         mgmtAddrsVal,
		PortDesc:          portDescVal,
		PortId:            portIdVal,
		PowerAllocated:    powerAllocatedVal,
		PowerDraw:         powerDrawVal,
		PowerRequestCount: powerRequestCountVal,
		PowerRequested:    powerRequestedVal,
		SystemDesc:        systemDescVal,
		SystemName:        systemNameVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewLldpStatValueNull() LldpStatValue {
	return LldpStatValue{
		state: attr.ValueStateNull,
	}
}

func NewLldpStatValueUnknown() LldpStatValue {
	return LldpStatValue{
		state: attr.ValueStateUnknown,
	}
}

func NewLldpStatValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (LldpStatValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing LldpStatValue Attribute Value",
				"While creating a LldpStatValue value, a missing attribute value was detected. "+
					"A LldpStatValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("LldpStatValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid LldpStatValue Attribute Type",
				"While creating a LldpStatValue value, an invalid attribute value was detected. "+
					"A LldpStatValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("LldpStatValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("LldpStatValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra LldpStatValue Attribute Value",
				"While creating a LldpStatValue value, an extra attribute value was detected. "+
					"A LldpStatValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra LldpStatValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewLldpStatValueUnknown(), diags
	}

	chassisIdAttribute, ok := attributes["chassis_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`chassis_id is missing from object`)

		return NewLldpStatValueUnknown(), diags
	}

	chassisIdVal, ok := chassisIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`chassis_id expected to be basetypes.StringValue, was: %T`, chassisIdAttribute))
	}

	lldpMedSupportedAttribute, ok := attributes["lldp_med_supported"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lldp_med_supported is missing from object`)

		return NewLldpStatValueUnknown(), diags
	}

	lldpMedSupportedVal, ok := lldpMedSupportedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lldp_med_supported expected to be basetypes.BoolValue, was: %T`, lldpMedSupportedAttribute))
	}

	mgmtAddrAttribute, ok := attributes["mgmt_addr"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mgmt_addr is missing from object`)

		return NewLldpStatValueUnknown(), diags
	}

	mgmtAddrVal, ok := mgmtAddrAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mgmt_addr expected to be basetypes.StringValue, was: %T`, mgmtAddrAttribute))
	}

	mgmtAddrsAttribute, ok := attributes["mgmt_addrs"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mgmt_addrs is missing from object`)

		return NewLldpStatValueUnknown(), diags
	}

	mgmtAddrsVal, ok := mgmtAddrsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mgmt_addrs expected to be basetypes.ListValue, was: %T`, mgmtAddrsAttribute))
	}

	portDescAttribute, ok := attributes["port_desc"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_desc is missing from object`)

		return NewLldpStatValueUnknown(), diags
	}

	portDescVal, ok := portDescAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_desc expected to be basetypes.StringValue, was: %T`, portDescAttribute))
	}

	portIdAttribute, ok := attributes["port_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_id is missing from object`)

		return NewLldpStatValueUnknown(), diags
	}

	portIdVal, ok := portIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_id expected to be basetypes.StringValue, was: %T`, portIdAttribute))
	}

	powerAllocatedAttribute, ok := attributes["power_allocated"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`power_allocated is missing from object`)

		return NewLldpStatValueUnknown(), diags
	}

	powerAllocatedVal, ok := powerAllocatedAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`power_allocated expected to be basetypes.NumberValue, was: %T`, powerAllocatedAttribute))
	}

	powerDrawAttribute, ok := attributes["power_draw"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`power_draw is missing from object`)

		return NewLldpStatValueUnknown(), diags
	}

	powerDrawVal, ok := powerDrawAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`power_draw expected to be basetypes.NumberValue, was: %T`, powerDrawAttribute))
	}

	powerRequestCountAttribute, ok := attributes["power_request_count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`power_request_count is missing from object`)

		return NewLldpStatValueUnknown(), diags
	}

	powerRequestCountVal, ok := powerRequestCountAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`power_request_count expected to be basetypes.Int64Value, was: %T`, powerRequestCountAttribute))
	}

	powerRequestedAttribute, ok := attributes["power_requested"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`power_requested is missing from object`)

		return NewLldpStatValueUnknown(), diags
	}

	powerRequestedVal, ok := powerRequestedAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`power_requested expected to be basetypes.NumberValue, was: %T`, powerRequestedAttribute))
	}

	systemDescAttribute, ok := attributes["system_desc"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`system_desc is missing from object`)

		return NewLldpStatValueUnknown(), diags
	}

	systemDescVal, ok := systemDescAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`system_desc expected to be basetypes.StringValue, was: %T`, systemDescAttribute))
	}

	systemNameAttribute, ok := attributes["system_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`system_name is missing from object`)

		return NewLldpStatValueUnknown(), diags
	}

	systemNameVal, ok := systemNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`system_name expected to be basetypes.StringValue, was: %T`, systemNameAttribute))
	}

	if diags.HasError() {
		return NewLldpStatValueUnknown(), diags
	}

	return LldpStatValue{
		ChassisId:         chassisIdVal,
		LldpMedSupported:  lldpMedSupportedVal,
		MgmtAddr:          mgmtAddrVal,
		MgmtAddrs:         mgmtAddrsVal,
		PortDesc:          portDescVal,
		PortId:            portIdVal,
		PowerAllocated:    powerAllocatedVal,
		PowerDraw:         powerDrawVal,
		PowerRequestCount: powerRequestCountVal,
		PowerRequested:    powerRequestedVal,
		SystemDesc:        systemDescVal,
		SystemName:        systemNameVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewLldpStatValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) LldpStatValue {
	object, diags := NewLldpStatValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewLldpStatValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t LldpStatType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewLldpStatValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewLldpStatValueUnknown(), nil
	}

	if in.IsNull() {
		return NewLldpStatValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewLldpStatValueMust(LldpStatValue{}.AttributeTypes(ctx), attributes), nil
}

func (t LldpStatType) ValueType(ctx context.Context) attr.Value {
	return LldpStatValue{}
}

var _ basetypes.ObjectValuable = LldpStatValue{}

type LldpStatValue struct {
	ChassisId         basetypes.StringValue `tfsdk:"chassis_id"`
	LldpMedSupported  basetypes.BoolValue   `tfsdk:"lldp_med_supported"`
	MgmtAddr          basetypes.StringValue `tfsdk:"mgmt_addr"`
	MgmtAddrs         basetypes.ListValue   `tfsdk:"mgmt_addrs"`
	PortDesc          basetypes.StringValue `tfsdk:"port_desc"`
	PortId            basetypes.StringValue `tfsdk:"port_id"`
	PowerAllocated    basetypes.NumberValue `tfsdk:"power_allocated"`
	PowerDraw         basetypes.NumberValue `tfsdk:"power_draw"`
	PowerRequestCount basetypes.Int64Value  `tfsdk:"power_request_count"`
	PowerRequested    basetypes.NumberValue `tfsdk:"power_requested"`
	SystemDesc        basetypes.StringValue `tfsdk:"system_desc"`
	SystemName        basetypes.StringValue `tfsdk:"system_name"`
	state             attr.ValueState
}

func (v LldpStatValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 12)

	var val tftypes.Value
	var err error

	attrTypes["chassis_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["lldp_med_supported"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["mgmt_addr"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["mgmt_addrs"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["port_desc"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["port_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["power_allocated"] = basetypes.NumberType{}.TerraformType(ctx)
	attrTypes["power_draw"] = basetypes.NumberType{}.TerraformType(ctx)
	attrTypes["power_request_count"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["power_requested"] = basetypes.NumberType{}.TerraformType(ctx)
	attrTypes["system_desc"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["system_name"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 12)

		val, err = v.ChassisId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["chassis_id"] = val

		val, err = v.LldpMedSupported.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["lldp_med_supported"] = val

		val, err = v.MgmtAddr.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mgmt_addr"] = val

		val, err = v.MgmtAddrs.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mgmt_addrs"] = val

		val, err = v.PortDesc.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port_desc"] = val

		val, err = v.PortId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port_id"] = val

		val, err = v.PowerAllocated.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["power_allocated"] = val

		val, err = v.PowerDraw.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["power_draw"] = val

		val, err = v.PowerRequestCount.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["power_request_count"] = val

		val, err = v.PowerRequested.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["power_requested"] = val

		val, err = v.SystemDesc.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["system_desc"] = val

		val, err = v.SystemName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["system_name"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v LldpStatValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v LldpStatValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v LldpStatValue) String() string {
	return "LldpStatValue"
}

func (v LldpStatValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	mgmtAddrsVal, d := types.ListValue(types.StringType, v.MgmtAddrs.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"chassis_id":         basetypes.StringType{},
			"lldp_med_supported": basetypes.BoolType{},
			"mgmt_addr":          basetypes.StringType{},
			"mgmt_addrs": basetypes.ListType{
				ElemType: types.StringType,
			},
			"port_desc":           basetypes.StringType{},
			"port_id":             basetypes.StringType{},
			"power_allocated":     basetypes.NumberType{},
			"power_draw":          basetypes.NumberType{},
			"power_request_count": basetypes.Int64Type{},
			"power_requested":     basetypes.NumberType{},
			"system_desc":         basetypes.StringType{},
			"system_name":         basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"chassis_id":         basetypes.StringType{},
		"lldp_med_supported": basetypes.BoolType{},
		"mgmt_addr":          basetypes.StringType{},
		"mgmt_addrs": basetypes.ListType{
			ElemType: types.StringType,
		},
		"port_desc":           basetypes.StringType{},
		"port_id":             basetypes.StringType{},
		"power_allocated":     basetypes.NumberType{},
		"power_draw":          basetypes.NumberType{},
		"power_request_count": basetypes.Int64Type{},
		"power_requested":     basetypes.NumberType{},
		"system_desc":         basetypes.StringType{},
		"system_name":         basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"chassis_id":          v.ChassisId,
			"lldp_med_supported":  v.LldpMedSupported,
			"mgmt_addr":           v.MgmtAddr,
			"mgmt_addrs":          mgmtAddrsVal,
			"port_desc":           v.PortDesc,
			"port_id":             v.PortId,
			"power_allocated":     v.PowerAllocated,
			"power_draw":          v.PowerDraw,
			"power_request_count": v.PowerRequestCount,
			"power_requested":     v.PowerRequested,
			"system_desc":         v.SystemDesc,
			"system_name":         v.SystemName,
		})

	return objVal, diags
}

func (v LldpStatValue) Equal(o attr.Value) bool {
	other, ok := o.(LldpStatValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.ChassisId.Equal(other.ChassisId) {
		return false
	}

	if !v.LldpMedSupported.Equal(other.LldpMedSupported) {
		return false
	}

	if !v.MgmtAddr.Equal(other.MgmtAddr) {
		return false
	}

	if !v.MgmtAddrs.Equal(other.MgmtAddrs) {
		return false
	}

	if !v.PortDesc.Equal(other.PortDesc) {
		return false
	}

	if !v.PortId.Equal(other.PortId) {
		return false
	}

	if !v.PowerAllocated.Equal(other.PowerAllocated) {
		return false
	}

	if !v.PowerDraw.Equal(other.PowerDraw) {
		return false
	}

	if !v.PowerRequestCount.Equal(other.PowerRequestCount) {
		return false
	}

	if !v.PowerRequested.Equal(other.PowerRequested) {
		return false
	}

	if !v.SystemDesc.Equal(other.SystemDesc) {
		return false
	}

	if !v.SystemName.Equal(other.SystemName) {
		return false
	}

	return true
}

func (v LldpStatValue) Type(ctx context.Context) attr.Type {
	return LldpStatType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v LldpStatValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"chassis_id":         basetypes.StringType{},
		"lldp_med_supported": basetypes.BoolType{},
		"mgmt_addr":          basetypes.StringType{},
		"mgmt_addrs": basetypes.ListType{
			ElemType: types.StringType,
		},
		"port_desc":           basetypes.StringType{},
		"port_id":             basetypes.StringType{},
		"power_allocated":     basetypes.NumberType{},
		"power_draw":          basetypes.NumberType{},
		"power_request_count": basetypes.Int64Type{},
		"power_requested":     basetypes.NumberType{},
		"system_desc":         basetypes.StringType{},
		"system_name":         basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = MeshDownlinksType{}

type MeshDownlinksType struct {
	basetypes.ObjectType
}

func (t MeshDownlinksType) Equal(o attr.Type) bool {
	other, ok := o.(MeshDownlinksType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t MeshDownlinksType) String() string {
	return "MeshDownlinksType"
}

func (t MeshDownlinksType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	bandAttribute, ok := attributes["band"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`band is missing from object`)

		return nil, diags
	}

	bandVal, ok := bandAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`band expected to be basetypes.StringValue, was: %T`, bandAttribute))
	}

	channelAttribute, ok := attributes["channel"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`channel is missing from object`)

		return nil, diags
	}

	channelVal, ok := channelAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`channel expected to be basetypes.Int64Value, was: %T`, channelAttribute))
	}

	idleTimeAttribute, ok := attributes["idle_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`idle_time is missing from object`)

		return nil, diags
	}

	idleTimeVal, ok := idleTimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`idle_time expected to be basetypes.Int64Value, was: %T`, idleTimeAttribute))
	}

	lastSeenAttribute, ok := attributes["last_seen"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`last_seen is missing from object`)

		return nil, diags
	}

	lastSeenVal, ok := lastSeenAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`last_seen expected to be basetypes.NumberValue, was: %T`, lastSeenAttribute))
	}

	protoAttribute, ok := attributes["proto"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`proto is missing from object`)

		return nil, diags
	}

	protoVal, ok := protoAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`proto expected to be basetypes.StringValue, was: %T`, protoAttribute))
	}

	rssiAttribute, ok := attributes["rssi"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rssi is missing from object`)

		return nil, diags
	}

	rssiVal, ok := rssiAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rssi expected to be basetypes.Int64Value, was: %T`, rssiAttribute))
	}

	rxBpsAttribute, ok := attributes["rx_bps"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rx_bps is missing from object`)

		return nil, diags
	}

	rxBpsVal, ok := rxBpsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rx_bps expected to be basetypes.Int64Value, was: %T`, rxBpsAttribute))
	}

	rxBytesAttribute, ok := attributes["rx_bytes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rx_bytes is missing from object`)

		return nil, diags
	}

	rxBytesVal, ok := rxBytesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rx_bytes expected to be basetypes.Int64Value, was: %T`, rxBytesAttribute))
	}

	rxPacketsAttribute, ok := attributes["rx_packets"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rx_packets is missing from object`)

		return nil, diags
	}

	rxPacketsVal, ok := rxPacketsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rx_packets expected to be basetypes.Int64Value, was: %T`, rxPacketsAttribute))
	}

	rxRateAttribute, ok := attributes["rx_rate"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rx_rate is missing from object`)

		return nil, diags
	}

	rxRateVal, ok := rxRateAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rx_rate expected to be basetypes.Int64Value, was: %T`, rxRateAttribute))
	}

	rxRetriesAttribute, ok := attributes["rx_retries"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rx_retries is missing from object`)

		return nil, diags
	}

	rxRetriesVal, ok := rxRetriesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rx_retries expected to be basetypes.Int64Value, was: %T`, rxRetriesAttribute))
	}

	siteIdAttribute, ok := attributes["site_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`site_id is missing from object`)

		return nil, diags
	}

	siteIdVal, ok := siteIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`site_id expected to be basetypes.StringValue, was: %T`, siteIdAttribute))
	}

	snrAttribute, ok := attributes["snr"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`snr is missing from object`)

		return nil, diags
	}

	snrVal, ok := snrAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`snr expected to be basetypes.Int64Value, was: %T`, snrAttribute))
	}

	txBpsAttribute, ok := attributes["tx_bps"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tx_bps is missing from object`)

		return nil, diags
	}

	txBpsVal, ok := txBpsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tx_bps expected to be basetypes.Int64Value, was: %T`, txBpsAttribute))
	}

	txBytesAttribute, ok := attributes["tx_bytes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tx_bytes is missing from object`)

		return nil, diags
	}

	txBytesVal, ok := txBytesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tx_bytes expected to be basetypes.Int64Value, was: %T`, txBytesAttribute))
	}

	txPacketsAttribute, ok := attributes["tx_packets"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tx_packets is missing from object`)

		return nil, diags
	}

	txPacketsVal, ok := txPacketsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tx_packets expected to be basetypes.Int64Value, was: %T`, txPacketsAttribute))
	}

	txRateAttribute, ok := attributes["tx_rate"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tx_rate is missing from object`)

		return nil, diags
	}

	txRateVal, ok := txRateAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tx_rate expected to be basetypes.Int64Value, was: %T`, txRateAttribute))
	}

	txRetriesAttribute, ok := attributes["tx_retries"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tx_retries is missing from object`)

		return nil, diags
	}

	txRetriesVal, ok := txRetriesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tx_retries expected to be basetypes.Int64Value, was: %T`, txRetriesAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return MeshDownlinksValue{
		Band:      bandVal,
		Channel:   channelVal,
		IdleTime:  idleTimeVal,
		LastSeen:  lastSeenVal,
		Proto:     protoVal,
		Rssi:      rssiVal,
		RxBps:     rxBpsVal,
		RxBytes:   rxBytesVal,
		RxPackets: rxPacketsVal,
		RxRate:    rxRateVal,
		RxRetries: rxRetriesVal,
		SiteId:    siteIdVal,
		Snr:       snrVal,
		TxBps:     txBpsVal,
		TxBytes:   txBytesVal,
		TxPackets: txPacketsVal,
		TxRate:    txRateVal,
		TxRetries: txRetriesVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewMeshDownlinksValueNull() MeshDownlinksValue {
	return MeshDownlinksValue{
		state: attr.ValueStateNull,
	}
}

func NewMeshDownlinksValueUnknown() MeshDownlinksValue {
	return MeshDownlinksValue{
		state: attr.ValueStateUnknown,
	}
}

func NewMeshDownlinksValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (MeshDownlinksValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing MeshDownlinksValue Attribute Value",
				"While creating a MeshDownlinksValue value, a missing attribute value was detected. "+
					"A MeshDownlinksValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MeshDownlinksValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid MeshDownlinksValue Attribute Type",
				"While creating a MeshDownlinksValue value, an invalid attribute value was detected. "+
					"A MeshDownlinksValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MeshDownlinksValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("MeshDownlinksValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra MeshDownlinksValue Attribute Value",
				"While creating a MeshDownlinksValue value, an extra attribute value was detected. "+
					"A MeshDownlinksValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra MeshDownlinksValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewMeshDownlinksValueUnknown(), diags
	}

	bandAttribute, ok := attributes["band"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`band is missing from object`)

		return NewMeshDownlinksValueUnknown(), diags
	}

	bandVal, ok := bandAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`band expected to be basetypes.StringValue, was: %T`, bandAttribute))
	}

	channelAttribute, ok := attributes["channel"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`channel is missing from object`)

		return NewMeshDownlinksValueUnknown(), diags
	}

	channelVal, ok := channelAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`channel expected to be basetypes.Int64Value, was: %T`, channelAttribute))
	}

	idleTimeAttribute, ok := attributes["idle_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`idle_time is missing from object`)

		return NewMeshDownlinksValueUnknown(), diags
	}

	idleTimeVal, ok := idleTimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`idle_time expected to be basetypes.Int64Value, was: %T`, idleTimeAttribute))
	}

	lastSeenAttribute, ok := attributes["last_seen"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`last_seen is missing from object`)

		return NewMeshDownlinksValueUnknown(), diags
	}

	lastSeenVal, ok := lastSeenAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`last_seen expected to be basetypes.NumberValue, was: %T`, lastSeenAttribute))
	}

	protoAttribute, ok := attributes["proto"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`proto is missing from object`)

		return NewMeshDownlinksValueUnknown(), diags
	}

	protoVal, ok := protoAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`proto expected to be basetypes.StringValue, was: %T`, protoAttribute))
	}

	rssiAttribute, ok := attributes["rssi"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rssi is missing from object`)

		return NewMeshDownlinksValueUnknown(), diags
	}

	rssiVal, ok := rssiAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rssi expected to be basetypes.Int64Value, was: %T`, rssiAttribute))
	}

	rxBpsAttribute, ok := attributes["rx_bps"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rx_bps is missing from object`)

		return NewMeshDownlinksValueUnknown(), diags
	}

	rxBpsVal, ok := rxBpsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rx_bps expected to be basetypes.Int64Value, was: %T`, rxBpsAttribute))
	}

	rxBytesAttribute, ok := attributes["rx_bytes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rx_bytes is missing from object`)

		return NewMeshDownlinksValueUnknown(), diags
	}

	rxBytesVal, ok := rxBytesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rx_bytes expected to be basetypes.Int64Value, was: %T`, rxBytesAttribute))
	}

	rxPacketsAttribute, ok := attributes["rx_packets"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rx_packets is missing from object`)

		return NewMeshDownlinksValueUnknown(), diags
	}

	rxPacketsVal, ok := rxPacketsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rx_packets expected to be basetypes.Int64Value, was: %T`, rxPacketsAttribute))
	}

	rxRateAttribute, ok := attributes["rx_rate"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rx_rate is missing from object`)

		return NewMeshDownlinksValueUnknown(), diags
	}

	rxRateVal, ok := rxRateAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rx_rate expected to be basetypes.Int64Value, was: %T`, rxRateAttribute))
	}

	rxRetriesAttribute, ok := attributes["rx_retries"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rx_retries is missing from object`)

		return NewMeshDownlinksValueUnknown(), diags
	}

	rxRetriesVal, ok := rxRetriesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rx_retries expected to be basetypes.Int64Value, was: %T`, rxRetriesAttribute))
	}

	siteIdAttribute, ok := attributes["site_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`site_id is missing from object`)

		return NewMeshDownlinksValueUnknown(), diags
	}

	siteIdVal, ok := siteIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`site_id expected to be basetypes.StringValue, was: %T`, siteIdAttribute))
	}

	snrAttribute, ok := attributes["snr"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`snr is missing from object`)

		return NewMeshDownlinksValueUnknown(), diags
	}

	snrVal, ok := snrAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`snr expected to be basetypes.Int64Value, was: %T`, snrAttribute))
	}

	txBpsAttribute, ok := attributes["tx_bps"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tx_bps is missing from object`)

		return NewMeshDownlinksValueUnknown(), diags
	}

	txBpsVal, ok := txBpsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tx_bps expected to be basetypes.Int64Value, was: %T`, txBpsAttribute))
	}

	txBytesAttribute, ok := attributes["tx_bytes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tx_bytes is missing from object`)

		return NewMeshDownlinksValueUnknown(), diags
	}

	txBytesVal, ok := txBytesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tx_bytes expected to be basetypes.Int64Value, was: %T`, txBytesAttribute))
	}

	txPacketsAttribute, ok := attributes["tx_packets"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tx_packets is missing from object`)

		return NewMeshDownlinksValueUnknown(), diags
	}

	txPacketsVal, ok := txPacketsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tx_packets expected to be basetypes.Int64Value, was: %T`, txPacketsAttribute))
	}

	txRateAttribute, ok := attributes["tx_rate"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tx_rate is missing from object`)

		return NewMeshDownlinksValueUnknown(), diags
	}

	txRateVal, ok := txRateAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tx_rate expected to be basetypes.Int64Value, was: %T`, txRateAttribute))
	}

	txRetriesAttribute, ok := attributes["tx_retries"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tx_retries is missing from object`)

		return NewMeshDownlinksValueUnknown(), diags
	}

	txRetriesVal, ok := txRetriesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tx_retries expected to be basetypes.Int64Value, was: %T`, txRetriesAttribute))
	}

	if diags.HasError() {
		return NewMeshDownlinksValueUnknown(), diags
	}

	return MeshDownlinksValue{
		Band:      bandVal,
		Channel:   channelVal,
		IdleTime:  idleTimeVal,
		LastSeen:  lastSeenVal,
		Proto:     protoVal,
		Rssi:      rssiVal,
		RxBps:     rxBpsVal,
		RxBytes:   rxBytesVal,
		RxPackets: rxPacketsVal,
		RxRate:    rxRateVal,
		RxRetries: rxRetriesVal,
		SiteId:    siteIdVal,
		Snr:       snrVal,
		TxBps:     txBpsVal,
		TxBytes:   txBytesVal,
		TxPackets: txPacketsVal,
		TxRate:    txRateVal,
		TxRetries: txRetriesVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewMeshDownlinksValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) MeshDownlinksValue {
	object, diags := NewMeshDownlinksValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewMeshDownlinksValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t MeshDownlinksType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewMeshDownlinksValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewMeshDownlinksValueUnknown(), nil
	}

	if in.IsNull() {
		return NewMeshDownlinksValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewMeshDownlinksValueMust(MeshDownlinksValue{}.AttributeTypes(ctx), attributes), nil
}

func (t MeshDownlinksType) ValueType(ctx context.Context) attr.Value {
	return MeshDownlinksValue{}
}

var _ basetypes.ObjectValuable = MeshDownlinksValue{}

type MeshDownlinksValue struct {
	Band      basetypes.StringValue `tfsdk:"band"`
	Channel   basetypes.Int64Value  `tfsdk:"channel"`
	IdleTime  basetypes.Int64Value  `tfsdk:"idle_time"`
	LastSeen  basetypes.NumberValue `tfsdk:"last_seen"`
	Proto     basetypes.StringValue `tfsdk:"proto"`
	Rssi      basetypes.Int64Value  `tfsdk:"rssi"`
	RxBps     basetypes.Int64Value  `tfsdk:"rx_bps"`
	RxBytes   basetypes.Int64Value  `tfsdk:"rx_bytes"`
	RxPackets basetypes.Int64Value  `tfsdk:"rx_packets"`
	RxRate    basetypes.Int64Value  `tfsdk:"rx_rate"`
	RxRetries basetypes.Int64Value  `tfsdk:"rx_retries"`
	SiteId    basetypes.StringValue `tfsdk:"site_id"`
	Snr       basetypes.Int64Value  `tfsdk:"snr"`
	TxBps     basetypes.Int64Value  `tfsdk:"tx_bps"`
	TxBytes   basetypes.Int64Value  `tfsdk:"tx_bytes"`
	TxPackets basetypes.Int64Value  `tfsdk:"tx_packets"`
	TxRate    basetypes.Int64Value  `tfsdk:"tx_rate"`
	TxRetries basetypes.Int64Value  `tfsdk:"tx_retries"`
	state     attr.ValueState
}

func (v MeshDownlinksValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 18)

	var val tftypes.Value
	var err error

	attrTypes["band"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["channel"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["idle_time"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["last_seen"] = basetypes.NumberType{}.TerraformType(ctx)
	attrTypes["proto"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["rssi"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["rx_bps"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["rx_bytes"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["rx_packets"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["rx_rate"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["rx_retries"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["site_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["snr"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["tx_bps"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["tx_bytes"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["tx_packets"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["tx_rate"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["tx_retries"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 18)

		val, err = v.Band.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["band"] = val

		val, err = v.Channel.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["channel"] = val

		val, err = v.IdleTime.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["idle_time"] = val

		val, err = v.LastSeen.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["last_seen"] = val

		val, err = v.Proto.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["proto"] = val

		val, err = v.Rssi.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["rssi"] = val

		val, err = v.RxBps.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["rx_bps"] = val

		val, err = v.RxBytes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["rx_bytes"] = val

		val, err = v.RxPackets.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["rx_packets"] = val

		val, err = v.RxRate.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["rx_rate"] = val

		val, err = v.RxRetries.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["rx_retries"] = val

		val, err = v.SiteId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["site_id"] = val

		val, err = v.Snr.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["snr"] = val

		val, err = v.TxBps.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tx_bps"] = val

		val, err = v.TxBytes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tx_bytes"] = val

		val, err = v.TxPackets.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tx_packets"] = val

		val, err = v.TxRate.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tx_rate"] = val

		val, err = v.TxRetries.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tx_retries"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v MeshDownlinksValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v MeshDownlinksValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v MeshDownlinksValue) String() string {
	return "MeshDownlinksValue"
}

func (v MeshDownlinksValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"band":       basetypes.StringType{},
		"channel":    basetypes.Int64Type{},
		"idle_time":  basetypes.Int64Type{},
		"last_seen":  basetypes.NumberType{},
		"proto":      basetypes.StringType{},
		"rssi":       basetypes.Int64Type{},
		"rx_bps":     basetypes.Int64Type{},
		"rx_bytes":   basetypes.Int64Type{},
		"rx_packets": basetypes.Int64Type{},
		"rx_rate":    basetypes.Int64Type{},
		"rx_retries": basetypes.Int64Type{},
		"site_id":    basetypes.StringType{},
		"snr":        basetypes.Int64Type{},
		"tx_bps":     basetypes.Int64Type{},
		"tx_bytes":   basetypes.Int64Type{},
		"tx_packets": basetypes.Int64Type{},
		"tx_rate":    basetypes.Int64Type{},
		"tx_retries": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"band":       v.Band,
			"channel":    v.Channel,
			"idle_time":  v.IdleTime,
			"last_seen":  v.LastSeen,
			"proto":      v.Proto,
			"rssi":       v.Rssi,
			"rx_bps":     v.RxBps,
			"rx_bytes":   v.RxBytes,
			"rx_packets": v.RxPackets,
			"rx_rate":    v.RxRate,
			"rx_retries": v.RxRetries,
			"site_id":    v.SiteId,
			"snr":        v.Snr,
			"tx_bps":     v.TxBps,
			"tx_bytes":   v.TxBytes,
			"tx_packets": v.TxPackets,
			"tx_rate":    v.TxRate,
			"tx_retries": v.TxRetries,
		})

	return objVal, diags
}

func (v MeshDownlinksValue) Equal(o attr.Value) bool {
	other, ok := o.(MeshDownlinksValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Band.Equal(other.Band) {
		return false
	}

	if !v.Channel.Equal(other.Channel) {
		return false
	}

	if !v.IdleTime.Equal(other.IdleTime) {
		return false
	}

	if !v.LastSeen.Equal(other.LastSeen) {
		return false
	}

	if !v.Proto.Equal(other.Proto) {
		return false
	}

	if !v.Rssi.Equal(other.Rssi) {
		return false
	}

	if !v.RxBps.Equal(other.RxBps) {
		return false
	}

	if !v.RxBytes.Equal(other.RxBytes) {
		return false
	}

	if !v.RxPackets.Equal(other.RxPackets) {
		return false
	}

	if !v.RxRate.Equal(other.RxRate) {
		return false
	}

	if !v.RxRetries.Equal(other.RxRetries) {
		return false
	}

	if !v.SiteId.Equal(other.SiteId) {
		return false
	}

	if !v.Snr.Equal(other.Snr) {
		return false
	}

	if !v.TxBps.Equal(other.TxBps) {
		return false
	}

	if !v.TxBytes.Equal(other.TxBytes) {
		return false
	}

	if !v.TxPackets.Equal(other.TxPackets) {
		return false
	}

	if !v.TxRate.Equal(other.TxRate) {
		return false
	}

	if !v.TxRetries.Equal(other.TxRetries) {
		return false
	}

	return true
}

func (v MeshDownlinksValue) Type(ctx context.Context) attr.Type {
	return MeshDownlinksType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v MeshDownlinksValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"band":       basetypes.StringType{},
		"channel":    basetypes.Int64Type{},
		"idle_time":  basetypes.Int64Type{},
		"last_seen":  basetypes.NumberType{},
		"proto":      basetypes.StringType{},
		"rssi":       basetypes.Int64Type{},
		"rx_bps":     basetypes.Int64Type{},
		"rx_bytes":   basetypes.Int64Type{},
		"rx_packets": basetypes.Int64Type{},
		"rx_rate":    basetypes.Int64Type{},
		"rx_retries": basetypes.Int64Type{},
		"site_id":    basetypes.StringType{},
		"snr":        basetypes.Int64Type{},
		"tx_bps":     basetypes.Int64Type{},
		"tx_bytes":   basetypes.Int64Type{},
		"tx_packets": basetypes.Int64Type{},
		"tx_rate":    basetypes.Int64Type{},
		"tx_retries": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = MeshUplinkType{}

type MeshUplinkType struct {
	basetypes.ObjectType
}

func (t MeshUplinkType) Equal(o attr.Type) bool {
	other, ok := o.(MeshUplinkType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t MeshUplinkType) String() string {
	return "MeshUplinkType"
}

func (t MeshUplinkType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	bandAttribute, ok := attributes["band"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`band is missing from object`)

		return nil, diags
	}

	bandVal, ok := bandAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`band expected to be basetypes.StringValue, was: %T`, bandAttribute))
	}

	channelAttribute, ok := attributes["channel"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`channel is missing from object`)

		return nil, diags
	}

	channelVal, ok := channelAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`channel expected to be basetypes.Int64Value, was: %T`, channelAttribute))
	}

	idleTimeAttribute, ok := attributes["idle_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`idle_time is missing from object`)

		return nil, diags
	}

	idleTimeVal, ok := idleTimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`idle_time expected to be basetypes.Int64Value, was: %T`, idleTimeAttribute))
	}

	lastSeenAttribute, ok := attributes["last_seen"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`last_seen is missing from object`)

		return nil, diags
	}

	lastSeenVal, ok := lastSeenAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`last_seen expected to be basetypes.NumberValue, was: %T`, lastSeenAttribute))
	}

	protoAttribute, ok := attributes["proto"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`proto is missing from object`)

		return nil, diags
	}

	protoVal, ok := protoAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`proto expected to be basetypes.StringValue, was: %T`, protoAttribute))
	}

	rssiAttribute, ok := attributes["rssi"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rssi is missing from object`)

		return nil, diags
	}

	rssiVal, ok := rssiAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rssi expected to be basetypes.Int64Value, was: %T`, rssiAttribute))
	}

	rxBpsAttribute, ok := attributes["rx_bps"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rx_bps is missing from object`)

		return nil, diags
	}

	rxBpsVal, ok := rxBpsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rx_bps expected to be basetypes.Int64Value, was: %T`, rxBpsAttribute))
	}

	rxBytesAttribute, ok := attributes["rx_bytes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rx_bytes is missing from object`)

		return nil, diags
	}

	rxBytesVal, ok := rxBytesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rx_bytes expected to be basetypes.Int64Value, was: %T`, rxBytesAttribute))
	}

	rxPacketsAttribute, ok := attributes["rx_packets"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rx_packets is missing from object`)

		return nil, diags
	}

	rxPacketsVal, ok := rxPacketsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rx_packets expected to be basetypes.Int64Value, was: %T`, rxPacketsAttribute))
	}

	rxRateAttribute, ok := attributes["rx_rate"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rx_rate is missing from object`)

		return nil, diags
	}

	rxRateVal, ok := rxRateAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rx_rate expected to be basetypes.Int64Value, was: %T`, rxRateAttribute))
	}

	rxRetriesAttribute, ok := attributes["rx_retries"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rx_retries is missing from object`)

		return nil, diags
	}

	rxRetriesVal, ok := rxRetriesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rx_retries expected to be basetypes.Int64Value, was: %T`, rxRetriesAttribute))
	}

	siteIdAttribute, ok := attributes["site_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`site_id is missing from object`)

		return nil, diags
	}

	siteIdVal, ok := siteIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`site_id expected to be basetypes.StringValue, was: %T`, siteIdAttribute))
	}

	snrAttribute, ok := attributes["snr"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`snr is missing from object`)

		return nil, diags
	}

	snrVal, ok := snrAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`snr expected to be basetypes.Int64Value, was: %T`, snrAttribute))
	}

	txBpsAttribute, ok := attributes["tx_bps"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tx_bps is missing from object`)

		return nil, diags
	}

	txBpsVal, ok := txBpsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tx_bps expected to be basetypes.Int64Value, was: %T`, txBpsAttribute))
	}

	txBytesAttribute, ok := attributes["tx_bytes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tx_bytes is missing from object`)

		return nil, diags
	}

	txBytesVal, ok := txBytesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tx_bytes expected to be basetypes.Int64Value, was: %T`, txBytesAttribute))
	}

	txPacketsAttribute, ok := attributes["tx_packets"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tx_packets is missing from object`)

		return nil, diags
	}

	txPacketsVal, ok := txPacketsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tx_packets expected to be basetypes.Int64Value, was: %T`, txPacketsAttribute))
	}

	txRateAttribute, ok := attributes["tx_rate"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tx_rate is missing from object`)

		return nil, diags
	}

	txRateVal, ok := txRateAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tx_rate expected to be basetypes.Int64Value, was: %T`, txRateAttribute))
	}

	txRetriesAttribute, ok := attributes["tx_retries"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tx_retries is missing from object`)

		return nil, diags
	}

	txRetriesVal, ok := txRetriesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tx_retries expected to be basetypes.Int64Value, was: %T`, txRetriesAttribute))
	}

	uplinkApIdAttribute, ok := attributes["uplink_ap_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uplink_ap_id is missing from object`)

		return nil, diags
	}

	uplinkApIdVal, ok := uplinkApIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uplink_ap_id expected to be basetypes.StringValue, was: %T`, uplinkApIdAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return MeshUplinkValue{
		Band:       bandVal,
		Channel:    channelVal,
		IdleTime:   idleTimeVal,
		LastSeen:   lastSeenVal,
		Proto:      protoVal,
		Rssi:       rssiVal,
		RxBps:      rxBpsVal,
		RxBytes:    rxBytesVal,
		RxPackets:  rxPacketsVal,
		RxRate:     rxRateVal,
		RxRetries:  rxRetriesVal,
		SiteId:     siteIdVal,
		Snr:        snrVal,
		TxBps:      txBpsVal,
		TxBytes:    txBytesVal,
		TxPackets:  txPacketsVal,
		TxRate:     txRateVal,
		TxRetries:  txRetriesVal,
		UplinkApId: uplinkApIdVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewMeshUplinkValueNull() MeshUplinkValue {
	return MeshUplinkValue{
		state: attr.ValueStateNull,
	}
}

func NewMeshUplinkValueUnknown() MeshUplinkValue {
	return MeshUplinkValue{
		state: attr.ValueStateUnknown,
	}
}

func NewMeshUplinkValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (MeshUplinkValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing MeshUplinkValue Attribute Value",
				"While creating a MeshUplinkValue value, a missing attribute value was detected. "+
					"A MeshUplinkValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MeshUplinkValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid MeshUplinkValue Attribute Type",
				"While creating a MeshUplinkValue value, an invalid attribute value was detected. "+
					"A MeshUplinkValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MeshUplinkValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("MeshUplinkValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra MeshUplinkValue Attribute Value",
				"While creating a MeshUplinkValue value, an extra attribute value was detected. "+
					"A MeshUplinkValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra MeshUplinkValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewMeshUplinkValueUnknown(), diags
	}

	bandAttribute, ok := attributes["band"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`band is missing from object`)

		return NewMeshUplinkValueUnknown(), diags
	}

	bandVal, ok := bandAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`band expected to be basetypes.StringValue, was: %T`, bandAttribute))
	}

	channelAttribute, ok := attributes["channel"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`channel is missing from object`)

		return NewMeshUplinkValueUnknown(), diags
	}

	channelVal, ok := channelAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`channel expected to be basetypes.Int64Value, was: %T`, channelAttribute))
	}

	idleTimeAttribute, ok := attributes["idle_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`idle_time is missing from object`)

		return NewMeshUplinkValueUnknown(), diags
	}

	idleTimeVal, ok := idleTimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`idle_time expected to be basetypes.Int64Value, was: %T`, idleTimeAttribute))
	}

	lastSeenAttribute, ok := attributes["last_seen"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`last_seen is missing from object`)

		return NewMeshUplinkValueUnknown(), diags
	}

	lastSeenVal, ok := lastSeenAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`last_seen expected to be basetypes.NumberValue, was: %T`, lastSeenAttribute))
	}

	protoAttribute, ok := attributes["proto"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`proto is missing from object`)

		return NewMeshUplinkValueUnknown(), diags
	}

	protoVal, ok := protoAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`proto expected to be basetypes.StringValue, was: %T`, protoAttribute))
	}

	rssiAttribute, ok := attributes["rssi"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rssi is missing from object`)

		return NewMeshUplinkValueUnknown(), diags
	}

	rssiVal, ok := rssiAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rssi expected to be basetypes.Int64Value, was: %T`, rssiAttribute))
	}

	rxBpsAttribute, ok := attributes["rx_bps"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rx_bps is missing from object`)

		return NewMeshUplinkValueUnknown(), diags
	}

	rxBpsVal, ok := rxBpsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rx_bps expected to be basetypes.Int64Value, was: %T`, rxBpsAttribute))
	}

	rxBytesAttribute, ok := attributes["rx_bytes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rx_bytes is missing from object`)

		return NewMeshUplinkValueUnknown(), diags
	}

	rxBytesVal, ok := rxBytesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rx_bytes expected to be basetypes.Int64Value, was: %T`, rxBytesAttribute))
	}

	rxPacketsAttribute, ok := attributes["rx_packets"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rx_packets is missing from object`)

		return NewMeshUplinkValueUnknown(), diags
	}

	rxPacketsVal, ok := rxPacketsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rx_packets expected to be basetypes.Int64Value, was: %T`, rxPacketsAttribute))
	}

	rxRateAttribute, ok := attributes["rx_rate"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rx_rate is missing from object`)

		return NewMeshUplinkValueUnknown(), diags
	}

	rxRateVal, ok := rxRateAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rx_rate expected to be basetypes.Int64Value, was: %T`, rxRateAttribute))
	}

	rxRetriesAttribute, ok := attributes["rx_retries"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rx_retries is missing from object`)

		return NewMeshUplinkValueUnknown(), diags
	}

	rxRetriesVal, ok := rxRetriesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rx_retries expected to be basetypes.Int64Value, was: %T`, rxRetriesAttribute))
	}

	siteIdAttribute, ok := attributes["site_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`site_id is missing from object`)

		return NewMeshUplinkValueUnknown(), diags
	}

	siteIdVal, ok := siteIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`site_id expected to be basetypes.StringValue, was: %T`, siteIdAttribute))
	}

	snrAttribute, ok := attributes["snr"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`snr is missing from object`)

		return NewMeshUplinkValueUnknown(), diags
	}

	snrVal, ok := snrAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`snr expected to be basetypes.Int64Value, was: %T`, snrAttribute))
	}

	txBpsAttribute, ok := attributes["tx_bps"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tx_bps is missing from object`)

		return NewMeshUplinkValueUnknown(), diags
	}

	txBpsVal, ok := txBpsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tx_bps expected to be basetypes.Int64Value, was: %T`, txBpsAttribute))
	}

	txBytesAttribute, ok := attributes["tx_bytes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tx_bytes is missing from object`)

		return NewMeshUplinkValueUnknown(), diags
	}

	txBytesVal, ok := txBytesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tx_bytes expected to be basetypes.Int64Value, was: %T`, txBytesAttribute))
	}

	txPacketsAttribute, ok := attributes["tx_packets"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tx_packets is missing from object`)

		return NewMeshUplinkValueUnknown(), diags
	}

	txPacketsVal, ok := txPacketsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tx_packets expected to be basetypes.Int64Value, was: %T`, txPacketsAttribute))
	}

	txRateAttribute, ok := attributes["tx_rate"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tx_rate is missing from object`)

		return NewMeshUplinkValueUnknown(), diags
	}

	txRateVal, ok := txRateAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tx_rate expected to be basetypes.Int64Value, was: %T`, txRateAttribute))
	}

	txRetriesAttribute, ok := attributes["tx_retries"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tx_retries is missing from object`)

		return NewMeshUplinkValueUnknown(), diags
	}

	txRetriesVal, ok := txRetriesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tx_retries expected to be basetypes.Int64Value, was: %T`, txRetriesAttribute))
	}

	uplinkApIdAttribute, ok := attributes["uplink_ap_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uplink_ap_id is missing from object`)

		return NewMeshUplinkValueUnknown(), diags
	}

	uplinkApIdVal, ok := uplinkApIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uplink_ap_id expected to be basetypes.StringValue, was: %T`, uplinkApIdAttribute))
	}

	if diags.HasError() {
		return NewMeshUplinkValueUnknown(), diags
	}

	return MeshUplinkValue{
		Band:       bandVal,
		Channel:    channelVal,
		IdleTime:   idleTimeVal,
		LastSeen:   lastSeenVal,
		Proto:      protoVal,
		Rssi:       rssiVal,
		RxBps:      rxBpsVal,
		RxBytes:    rxBytesVal,
		RxPackets:  rxPacketsVal,
		RxRate:     rxRateVal,
		RxRetries:  rxRetriesVal,
		SiteId:     siteIdVal,
		Snr:        snrVal,
		TxBps:      txBpsVal,
		TxBytes:    txBytesVal,
		TxPackets:  txPacketsVal,
		TxRate:     txRateVal,
		TxRetries:  txRetriesVal,
		UplinkApId: uplinkApIdVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewMeshUplinkValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) MeshUplinkValue {
	object, diags := NewMeshUplinkValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewMeshUplinkValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t MeshUplinkType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewMeshUplinkValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewMeshUplinkValueUnknown(), nil
	}

	if in.IsNull() {
		return NewMeshUplinkValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewMeshUplinkValueMust(MeshUplinkValue{}.AttributeTypes(ctx), attributes), nil
}

func (t MeshUplinkType) ValueType(ctx context.Context) attr.Value {
	return MeshUplinkValue{}
}

var _ basetypes.ObjectValuable = MeshUplinkValue{}

type MeshUplinkValue struct {
	Band       basetypes.StringValue `tfsdk:"band"`
	Channel    basetypes.Int64Value  `tfsdk:"channel"`
	IdleTime   basetypes.Int64Value  `tfsdk:"idle_time"`
	LastSeen   basetypes.NumberValue `tfsdk:"last_seen"`
	Proto      basetypes.StringValue `tfsdk:"proto"`
	Rssi       basetypes.Int64Value  `tfsdk:"rssi"`
	RxBps      basetypes.Int64Value  `tfsdk:"rx_bps"`
	RxBytes    basetypes.Int64Value  `tfsdk:"rx_bytes"`
	RxPackets  basetypes.Int64Value  `tfsdk:"rx_packets"`
	RxRate     basetypes.Int64Value  `tfsdk:"rx_rate"`
	RxRetries  basetypes.Int64Value  `tfsdk:"rx_retries"`
	SiteId     basetypes.StringValue `tfsdk:"site_id"`
	Snr        basetypes.Int64Value  `tfsdk:"snr"`
	TxBps      basetypes.Int64Value  `tfsdk:"tx_bps"`
	TxBytes    basetypes.Int64Value  `tfsdk:"tx_bytes"`
	TxPackets  basetypes.Int64Value  `tfsdk:"tx_packets"`
	TxRate     basetypes.Int64Value  `tfsdk:"tx_rate"`
	TxRetries  basetypes.Int64Value  `tfsdk:"tx_retries"`
	UplinkApId basetypes.StringValue `tfsdk:"uplink_ap_id"`
	state      attr.ValueState
}

func (v MeshUplinkValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 19)

	var val tftypes.Value
	var err error

	attrTypes["band"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["channel"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["idle_time"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["last_seen"] = basetypes.NumberType{}.TerraformType(ctx)
	attrTypes["proto"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["rssi"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["rx_bps"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["rx_bytes"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["rx_packets"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["rx_rate"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["rx_retries"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["site_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["snr"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["tx_bps"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["tx_bytes"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["tx_packets"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["tx_rate"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["tx_retries"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["uplink_ap_id"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 19)

		val, err = v.Band.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["band"] = val

		val, err = v.Channel.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["channel"] = val

		val, err = v.IdleTime.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["idle_time"] = val

		val, err = v.LastSeen.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["last_seen"] = val

		val, err = v.Proto.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["proto"] = val

		val, err = v.Rssi.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["rssi"] = val

		val, err = v.RxBps.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["rx_bps"] = val

		val, err = v.RxBytes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["rx_bytes"] = val

		val, err = v.RxPackets.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["rx_packets"] = val

		val, err = v.RxRate.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["rx_rate"] = val

		val, err = v.RxRetries.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["rx_retries"] = val

		val, err = v.SiteId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["site_id"] = val

		val, err = v.Snr.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["snr"] = val

		val, err = v.TxBps.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tx_bps"] = val

		val, err = v.TxBytes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tx_bytes"] = val

		val, err = v.TxPackets.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tx_packets"] = val

		val, err = v.TxRate.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tx_rate"] = val

		val, err = v.TxRetries.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tx_retries"] = val

		val, err = v.UplinkApId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["uplink_ap_id"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v MeshUplinkValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v MeshUplinkValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v MeshUplinkValue) String() string {
	return "MeshUplinkValue"
}

func (v MeshUplinkValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"band":         basetypes.StringType{},
		"channel":      basetypes.Int64Type{},
		"idle_time":    basetypes.Int64Type{},
		"last_seen":    basetypes.NumberType{},
		"proto":        basetypes.StringType{},
		"rssi":         basetypes.Int64Type{},
		"rx_bps":       basetypes.Int64Type{},
		"rx_bytes":     basetypes.Int64Type{},
		"rx_packets":   basetypes.Int64Type{},
		"rx_rate":      basetypes.Int64Type{},
		"rx_retries":   basetypes.Int64Type{},
		"site_id":      basetypes.StringType{},
		"snr":          basetypes.Int64Type{},
		"tx_bps":       basetypes.Int64Type{},
		"tx_bytes":     basetypes.Int64Type{},
		"tx_packets":   basetypes.Int64Type{},
		"tx_rate":      basetypes.Int64Type{},
		"tx_retries":   basetypes.Int64Type{},
		"uplink_ap_id": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"band":         v.Band,
			"channel":      v.Channel,
			"idle_time":    v.IdleTime,
			"last_seen":    v.LastSeen,
			"proto":        v.Proto,
			"rssi":         v.Rssi,
			"rx_bps":       v.RxBps,
			"rx_bytes":     v.RxBytes,
			"rx_packets":   v.RxPackets,
			"rx_rate":      v.RxRate,
			"rx_retries":   v.RxRetries,
			"site_id":      v.SiteId,
			"snr":          v.Snr,
			"tx_bps":       v.TxBps,
			"tx_bytes":     v.TxBytes,
			"tx_packets":   v.TxPackets,
			"tx_rate":      v.TxRate,
			"tx_retries":   v.TxRetries,
			"uplink_ap_id": v.UplinkApId,
		})

	return objVal, diags
}

func (v MeshUplinkValue) Equal(o attr.Value) bool {
	other, ok := o.(MeshUplinkValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Band.Equal(other.Band) {
		return false
	}

	if !v.Channel.Equal(other.Channel) {
		return false
	}

	if !v.IdleTime.Equal(other.IdleTime) {
		return false
	}

	if !v.LastSeen.Equal(other.LastSeen) {
		return false
	}

	if !v.Proto.Equal(other.Proto) {
		return false
	}

	if !v.Rssi.Equal(other.Rssi) {
		return false
	}

	if !v.RxBps.Equal(other.RxBps) {
		return false
	}

	if !v.RxBytes.Equal(other.RxBytes) {
		return false
	}

	if !v.RxPackets.Equal(other.RxPackets) {
		return false
	}

	if !v.RxRate.Equal(other.RxRate) {
		return false
	}

	if !v.RxRetries.Equal(other.RxRetries) {
		return false
	}

	if !v.SiteId.Equal(other.SiteId) {
		return false
	}

	if !v.Snr.Equal(other.Snr) {
		return false
	}

	if !v.TxBps.Equal(other.TxBps) {
		return false
	}

	if !v.TxBytes.Equal(other.TxBytes) {
		return false
	}

	if !v.TxPackets.Equal(other.TxPackets) {
		return false
	}

	if !v.TxRate.Equal(other.TxRate) {
		return false
	}

	if !v.TxRetries.Equal(other.TxRetries) {
		return false
	}

	if !v.UplinkApId.Equal(other.UplinkApId) {
		return false
	}

	return true
}

func (v MeshUplinkValue) Type(ctx context.Context) attr.Type {
	return MeshUplinkType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v MeshUplinkValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"band":         basetypes.StringType{},
		"channel":      basetypes.Int64Type{},
		"idle_time":    basetypes.Int64Type{},
		"last_seen":    basetypes.NumberType{},
		"proto":        basetypes.StringType{},
		"rssi":         basetypes.Int64Type{},
		"rx_bps":       basetypes.Int64Type{},
		"rx_bytes":     basetypes.Int64Type{},
		"rx_packets":   basetypes.Int64Type{},
		"rx_rate":      basetypes.Int64Type{},
		"rx_retries":   basetypes.Int64Type{},
		"site_id":      basetypes.StringType{},
		"snr":          basetypes.Int64Type{},
		"tx_bps":       basetypes.Int64Type{},
		"tx_bytes":     basetypes.Int64Type{},
		"tx_packets":   basetypes.Int64Type{},
		"tx_rate":      basetypes.Int64Type{},
		"tx_retries":   basetypes.Int64Type{},
		"uplink_ap_id": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = PortStatType{}

type PortStatType struct {
	basetypes.ObjectType
}

func (t PortStatType) Equal(o attr.Type) bool {
	other, ok := o.(PortStatType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PortStatType) String() string {
	return "PortStatType"
}

func (t PortStatType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	fullDuplexAttribute, ok := attributes["full_duplex"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`full_duplex is missing from object`)

		return nil, diags
	}

	fullDuplexVal, ok := fullDuplexAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`full_duplex expected to be basetypes.BoolValue, was: %T`, fullDuplexAttribute))
	}

	rxBytesAttribute, ok := attributes["rx_bytes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rx_bytes is missing from object`)

		return nil, diags
	}

	rxBytesVal, ok := rxBytesAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rx_bytes expected to be basetypes.NumberValue, was: %T`, rxBytesAttribute))
	}

	rxErrorsAttribute, ok := attributes["rx_errors"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rx_errors is missing from object`)

		return nil, diags
	}

	rxErrorsVal, ok := rxErrorsAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rx_errors expected to be basetypes.NumberValue, was: %T`, rxErrorsAttribute))
	}

	rxPktsAttribute, ok := attributes["rx_pkts"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rx_pkts is missing from object`)

		return nil, diags
	}

	rxPktsVal, ok := rxPktsAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rx_pkts expected to be basetypes.NumberValue, was: %T`, rxPktsAttribute))
	}

	speedAttribute, ok := attributes["speed"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`speed is missing from object`)

		return nil, diags
	}

	speedVal, ok := speedAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`speed expected to be basetypes.Int64Value, was: %T`, speedAttribute))
	}

	txBytesAttribute, ok := attributes["tx_bytes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tx_bytes is missing from object`)

		return nil, diags
	}

	txBytesVal, ok := txBytesAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tx_bytes expected to be basetypes.NumberValue, was: %T`, txBytesAttribute))
	}

	txPktsAttribute, ok := attributes["tx_pkts"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tx_pkts is missing from object`)

		return nil, diags
	}

	txPktsVal, ok := txPktsAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tx_pkts expected to be basetypes.NumberValue, was: %T`, txPktsAttribute))
	}

	upAttribute, ok := attributes["up"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`up is missing from object`)

		return nil, diags
	}

	upVal, ok := upAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`up expected to be basetypes.BoolValue, was: %T`, upAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PortStatValue{
		FullDuplex: fullDuplexVal,
		RxBytes:    rxBytesVal,
		RxErrors:   rxErrorsVal,
		RxPkts:     rxPktsVal,
		Speed:      speedVal,
		TxBytes:    txBytesVal,
		TxPkts:     txPktsVal,
		Up:         upVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewPortStatValueNull() PortStatValue {
	return PortStatValue{
		state: attr.ValueStateNull,
	}
}

func NewPortStatValueUnknown() PortStatValue {
	return PortStatValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPortStatValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PortStatValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PortStatValue Attribute Value",
				"While creating a PortStatValue value, a missing attribute value was detected. "+
					"A PortStatValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PortStatValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PortStatValue Attribute Type",
				"While creating a PortStatValue value, an invalid attribute value was detected. "+
					"A PortStatValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PortStatValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PortStatValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PortStatValue Attribute Value",
				"While creating a PortStatValue value, an extra attribute value was detected. "+
					"A PortStatValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PortStatValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPortStatValueUnknown(), diags
	}

	fullDuplexAttribute, ok := attributes["full_duplex"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`full_duplex is missing from object`)

		return NewPortStatValueUnknown(), diags
	}

	fullDuplexVal, ok := fullDuplexAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`full_duplex expected to be basetypes.BoolValue, was: %T`, fullDuplexAttribute))
	}

	rxBytesAttribute, ok := attributes["rx_bytes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rx_bytes is missing from object`)

		return NewPortStatValueUnknown(), diags
	}

	rxBytesVal, ok := rxBytesAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rx_bytes expected to be basetypes.NumberValue, was: %T`, rxBytesAttribute))
	}

	rxErrorsAttribute, ok := attributes["rx_errors"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rx_errors is missing from object`)

		return NewPortStatValueUnknown(), diags
	}

	rxErrorsVal, ok := rxErrorsAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rx_errors expected to be basetypes.NumberValue, was: %T`, rxErrorsAttribute))
	}

	rxPktsAttribute, ok := attributes["rx_pkts"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rx_pkts is missing from object`)

		return NewPortStatValueUnknown(), diags
	}

	rxPktsVal, ok := rxPktsAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rx_pkts expected to be basetypes.NumberValue, was: %T`, rxPktsAttribute))
	}

	speedAttribute, ok := attributes["speed"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`speed is missing from object`)

		return NewPortStatValueUnknown(), diags
	}

	speedVal, ok := speedAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`speed expected to be basetypes.Int64Value, was: %T`, speedAttribute))
	}

	txBytesAttribute, ok := attributes["tx_bytes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tx_bytes is missing from object`)

		return NewPortStatValueUnknown(), diags
	}

	txBytesVal, ok := txBytesAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tx_bytes expected to be basetypes.NumberValue, was: %T`, txBytesAttribute))
	}

	txPktsAttribute, ok := attributes["tx_pkts"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tx_pkts is missing from object`)

		return NewPortStatValueUnknown(), diags
	}

	txPktsVal, ok := txPktsAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tx_pkts expected to be basetypes.NumberValue, was: %T`, txPktsAttribute))
	}

	upAttribute, ok := attributes["up"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`up is missing from object`)

		return NewPortStatValueUnknown(), diags
	}

	upVal, ok := upAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`up expected to be basetypes.BoolValue, was: %T`, upAttribute))
	}

	if diags.HasError() {
		return NewPortStatValueUnknown(), diags
	}

	return PortStatValue{
		FullDuplex: fullDuplexVal,
		RxBytes:    rxBytesVal,
		RxErrors:   rxErrorsVal,
		RxPkts:     rxPktsVal,
		Speed:      speedVal,
		TxBytes:    txBytesVal,
		TxPkts:     txPktsVal,
		Up:         upVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewPortStatValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PortStatValue {
	object, diags := NewPortStatValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPortStatValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PortStatType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPortStatValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPortStatValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPortStatValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPortStatValueMust(PortStatValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PortStatType) ValueType(ctx context.Context) attr.Value {
	return PortStatValue{}
}

var _ basetypes.ObjectValuable = PortStatValue{}

type PortStatValue struct {
	FullDuplex basetypes.BoolValue   `tfsdk:"full_duplex"`
	RxBytes    basetypes.NumberValue `tfsdk:"rx_bytes"`
	RxErrors   basetypes.NumberValue `tfsdk:"rx_errors"`
	RxPkts     basetypes.NumberValue `tfsdk:"rx_pkts"`
	Speed      basetypes.Int64Value  `tfsdk:"speed"`
	TxBytes    basetypes.NumberValue `tfsdk:"tx_bytes"`
	TxPkts     basetypes.NumberValue `tfsdk:"tx_pkts"`
	Up         basetypes.BoolValue   `tfsdk:"up"`
	state      attr.ValueState
}

func (v PortStatValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 8)

	var val tftypes.Value
	var err error

	attrTypes["full_duplex"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["rx_bytes"] = basetypes.NumberType{}.TerraformType(ctx)
	attrTypes["rx_errors"] = basetypes.NumberType{}.TerraformType(ctx)
	attrTypes["rx_pkts"] = basetypes.NumberType{}.TerraformType(ctx)
	attrTypes["speed"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["tx_bytes"] = basetypes.NumberType{}.TerraformType(ctx)
	attrTypes["tx_pkts"] = basetypes.NumberType{}.TerraformType(ctx)
	attrTypes["up"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 8)

		val, err = v.FullDuplex.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["full_duplex"] = val

		val, err = v.RxBytes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["rx_bytes"] = val

		val, err = v.RxErrors.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["rx_errors"] = val

		val, err = v.RxPkts.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["rx_pkts"] = val

		val, err = v.Speed.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["speed"] = val

		val, err = v.TxBytes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tx_bytes"] = val

		val, err = v.TxPkts.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tx_pkts"] = val

		val, err = v.Up.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["up"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PortStatValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PortStatValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PortStatValue) String() string {
	return "PortStatValue"
}

func (v PortStatValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"full_duplex": basetypes.BoolType{},
		"rx_bytes":    basetypes.NumberType{},
		"rx_errors":   basetypes.NumberType{},
		"rx_pkts":     basetypes.NumberType{},
		"speed":       basetypes.Int64Type{},
		"tx_bytes":    basetypes.NumberType{},
		"tx_pkts":     basetypes.NumberType{},
		"up":          basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"full_duplex": v.FullDuplex,
			"rx_bytes":    v.RxBytes,
			"rx_errors":   v.RxErrors,
			"rx_pkts":     v.RxPkts,
			"speed":       v.Speed,
			"tx_bytes":    v.TxBytes,
			"tx_pkts":     v.TxPkts,
			"up":          v.Up,
		})

	return objVal, diags
}

func (v PortStatValue) Equal(o attr.Value) bool {
	other, ok := o.(PortStatValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.FullDuplex.Equal(other.FullDuplex) {
		return false
	}

	if !v.RxBytes.Equal(other.RxBytes) {
		return false
	}

	if !v.RxErrors.Equal(other.RxErrors) {
		return false
	}

	if !v.RxPkts.Equal(other.RxPkts) {
		return false
	}

	if !v.Speed.Equal(other.Speed) {
		return false
	}

	if !v.TxBytes.Equal(other.TxBytes) {
		return false
	}

	if !v.TxPkts.Equal(other.TxPkts) {
		return false
	}

	if !v.Up.Equal(other.Up) {
		return false
	}

	return true
}

func (v PortStatValue) Type(ctx context.Context) attr.Type {
	return PortStatType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PortStatValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"full_duplex": basetypes.BoolType{},
		"rx_bytes":    basetypes.NumberType{},
		"rx_errors":   basetypes.NumberType{},
		"rx_pkts":     basetypes.NumberType{},
		"speed":       basetypes.Int64Type{},
		"tx_bytes":    basetypes.NumberType{},
		"tx_pkts":     basetypes.NumberType{},
		"up":          basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = RadioStatType{}

type RadioStatType struct {
	basetypes.ObjectType
}

func (t RadioStatType) Equal(o attr.Type) bool {
	other, ok := o.(RadioStatType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t RadioStatType) String() string {
	return "RadioStatType"
}

func (t RadioStatType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	band24Attribute, ok := attributes["band_24"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`band_24 is missing from object`)

		return nil, diags
	}

	band24Val, ok := band24Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`band_24 expected to be basetypes.ObjectValue, was: %T`, band24Attribute))
	}

	band5Attribute, ok := attributes["band_5"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`band_5 is missing from object`)

		return nil, diags
	}

	band5Val, ok := band5Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`band_5 expected to be basetypes.ObjectValue, was: %T`, band5Attribute))
	}

	band6Attribute, ok := attributes["band_6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`band_6 is missing from object`)

		return nil, diags
	}

	band6Val, ok := band6Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`band_6 expected to be basetypes.ObjectValue, was: %T`, band6Attribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return RadioStatValue{
		Band24: band24Val,
		Band5:  band5Val,
		Band6:  band6Val,
		state:  attr.ValueStateKnown,
	}, diags
}

func NewRadioStatValueNull() RadioStatValue {
	return RadioStatValue{
		state: attr.ValueStateNull,
	}
}

func NewRadioStatValueUnknown() RadioStatValue {
	return RadioStatValue{
		state: attr.ValueStateUnknown,
	}
}

func NewRadioStatValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (RadioStatValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing RadioStatValue Attribute Value",
				"While creating a RadioStatValue value, a missing attribute value was detected. "+
					"A RadioStatValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RadioStatValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid RadioStatValue Attribute Type",
				"While creating a RadioStatValue value, an invalid attribute value was detected. "+
					"A RadioStatValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RadioStatValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("RadioStatValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra RadioStatValue Attribute Value",
				"While creating a RadioStatValue value, an extra attribute value was detected. "+
					"A RadioStatValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra RadioStatValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewRadioStatValueUnknown(), diags
	}

	band24Attribute, ok := attributes["band_24"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`band_24 is missing from object`)

		return NewRadioStatValueUnknown(), diags
	}

	band24Val, ok := band24Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`band_24 expected to be basetypes.ObjectValue, was: %T`, band24Attribute))
	}

	band5Attribute, ok := attributes["band_5"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`band_5 is missing from object`)

		return NewRadioStatValueUnknown(), diags
	}

	band5Val, ok := band5Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`band_5 expected to be basetypes.ObjectValue, was: %T`, band5Attribute))
	}

	band6Attribute, ok := attributes["band_6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`band_6 is missing from object`)

		return NewRadioStatValueUnknown(), diags
	}

	band6Val, ok := band6Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`band_6 expected to be basetypes.ObjectValue, was: %T`, band6Attribute))
	}

	if diags.HasError() {
		return NewRadioStatValueUnknown(), diags
	}

	return RadioStatValue{
		Band24: band24Val,
		Band5:  band5Val,
		Band6:  band6Val,
		state:  attr.ValueStateKnown,
	}, diags
}

func NewRadioStatValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) RadioStatValue {
	object, diags := NewRadioStatValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewRadioStatValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t RadioStatType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewRadioStatValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewRadioStatValueUnknown(), nil
	}

	if in.IsNull() {
		return NewRadioStatValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewRadioStatValueMust(RadioStatValue{}.AttributeTypes(ctx), attributes), nil
}

func (t RadioStatType) ValueType(ctx context.Context) attr.Value {
	return RadioStatValue{}
}

var _ basetypes.ObjectValuable = RadioStatValue{}

type RadioStatValue struct {
	Band24 basetypes.ObjectValue `tfsdk:"band_24"`
	Band5  basetypes.ObjectValue `tfsdk:"band_5"`
	Band6  basetypes.ObjectValue `tfsdk:"band_6"`
	state  attr.ValueState
}

func (v RadioStatValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["band_24"] = basetypes.ObjectType{
		AttrTypes: BandValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["band_5"] = basetypes.ObjectType{
		AttrTypes: BandValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["band_6"] = basetypes.ObjectType{
		AttrTypes: BandValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Band24.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["band_24"] = val

		val, err = v.Band5.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["band_5"] = val

		val, err = v.Band6.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["band_6"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v RadioStatValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v RadioStatValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v RadioStatValue) String() string {
	return "RadioStatValue"
}

func (v RadioStatValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var band24 basetypes.ObjectValue

	if v.Band24.IsNull() {
		band24 = types.ObjectNull(
			BandValue{}.AttributeTypes(ctx),
		)
	}

	if v.Band24.IsUnknown() {
		band24 = types.ObjectUnknown(
			BandValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Band24.IsNull() && !v.Band24.IsUnknown() {
		band24 = types.ObjectValueMust(
			BandValue{}.AttributeTypes(ctx),
			v.Band24.Attributes(),
		)
	}

	var band5 basetypes.ObjectValue

	if v.Band5.IsNull() {
		band5 = types.ObjectNull(
			BandValue{}.AttributeTypes(ctx),
		)
	}

	if v.Band5.IsUnknown() {
		band5 = types.ObjectUnknown(
			BandValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Band5.IsNull() && !v.Band5.IsUnknown() {
		band5 = types.ObjectValueMust(
			BandValue{}.AttributeTypes(ctx),
			v.Band5.Attributes(),
		)
	}

	var band6 basetypes.ObjectValue

	if v.Band6.IsNull() {
		band6 = types.ObjectNull(
			BandValue{}.AttributeTypes(ctx),
		)
	}

	if v.Band6.IsUnknown() {
		band6 = types.ObjectUnknown(
			BandValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Band6.IsNull() && !v.Band6.IsUnknown() {
		band6 = types.ObjectValueMust(
			BandValue{}.AttributeTypes(ctx),
			v.Band6.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"band_24": basetypes.ObjectType{
			AttrTypes: BandValue{}.AttributeTypes(ctx),
		},
		"band_5": basetypes.ObjectType{
			AttrTypes: BandValue{}.AttributeTypes(ctx),
		},
		"band_6": basetypes.ObjectType{
			AttrTypes: BandValue{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"band_24": band24,
			"band_5":  band5,
			"band_6":  band6,
		})

	return objVal, diags
}

func (v RadioStatValue) Equal(o attr.Value) bool {
	other, ok := o.(RadioStatValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Band24.Equal(other.Band24) {
		return false
	}

	if !v.Band5.Equal(other.Band5) {
		return false
	}

	if !v.Band6.Equal(other.Band6) {
		return false
	}

	return true
}

func (v RadioStatValue) Type(ctx context.Context) attr.Type {
	return RadioStatType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v RadioStatValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"band_24": basetypes.ObjectType{
			AttrTypes: BandValue{}.AttributeTypes(ctx),
		},
		"band_5": basetypes.ObjectType{
			AttrTypes: BandValue{}.AttributeTypes(ctx),
		},
		"band_6": basetypes.ObjectType{
			AttrTypes: BandValue{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = BandType{}

type BandType struct {
	basetypes.ObjectType
}

func (t BandType) Equal(o attr.Type) bool {
	other, ok := o.(BandType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t BandType) String() string {
	return "BandType"
}

func (t BandType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	bandwidthAttribute, ok := attributes["bandwidth"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bandwidth is missing from object`)

		return nil, diags
	}

	bandwidthVal, ok := bandwidthAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bandwidth expected to be basetypes.Int64Value, was: %T`, bandwidthAttribute))
	}

	channelAttribute, ok := attributes["channel"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`channel is missing from object`)

		return nil, diags
	}

	channelVal, ok := channelAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`channel expected to be basetypes.Int64Value, was: %T`, channelAttribute))
	}

	dynamicChainingEnalbedAttribute, ok := attributes["dynamic_chaining_enalbed"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dynamic_chaining_enalbed is missing from object`)

		return nil, diags
	}

	dynamicChainingEnalbedVal, ok := dynamicChainingEnalbedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dynamic_chaining_enalbed expected to be basetypes.BoolValue, was: %T`, dynamicChainingEnalbedAttribute))
	}

	macAttribute, ok := attributes["mac"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mac is missing from object`)

		return nil, diags
	}

	macVal, ok := macAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mac expected to be basetypes.StringValue, was: %T`, macAttribute))
	}

	noiseFloorAttribute, ok := attributes["noise_floor"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`noise_floor is missing from object`)

		return nil, diags
	}

	noiseFloorVal, ok := noiseFloorAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`noise_floor expected to be basetypes.Int64Value, was: %T`, noiseFloorAttribute))
	}

	numClientsAttribute, ok := attributes["num_clients"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`num_clients is missing from object`)

		return nil, diags
	}

	numClientsVal, ok := numClientsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`num_clients expected to be basetypes.Int64Value, was: %T`, numClientsAttribute))
	}

	powerAttribute, ok := attributes["power"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`power is missing from object`)

		return nil, diags
	}

	powerVal, ok := powerAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`power expected to be basetypes.Int64Value, was: %T`, powerAttribute))
	}

	rxBytesAttribute, ok := attributes["rx_bytes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rx_bytes is missing from object`)

		return nil, diags
	}

	rxBytesVal, ok := rxBytesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rx_bytes expected to be basetypes.Int64Value, was: %T`, rxBytesAttribute))
	}

	rxPktsAttribute, ok := attributes["rx_pkts"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rx_pkts is missing from object`)

		return nil, diags
	}

	rxPktsVal, ok := rxPktsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rx_pkts expected to be basetypes.Int64Value, was: %T`, rxPktsAttribute))
	}

	txBytesAttribute, ok := attributes["tx_bytes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tx_bytes is missing from object`)

		return nil, diags
	}

	txBytesVal, ok := txBytesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tx_bytes expected to be basetypes.Int64Value, was: %T`, txBytesAttribute))
	}

	txPktsAttribute, ok := attributes["tx_pkts"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tx_pkts is missing from object`)

		return nil, diags
	}

	txPktsVal, ok := txPktsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tx_pkts expected to be basetypes.Int64Value, was: %T`, txPktsAttribute))
	}

	usageAttribute, ok := attributes["usage"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`usage is missing from object`)

		return nil, diags
	}

	usageVal, ok := usageAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`usage expected to be basetypes.StringValue, was: %T`, usageAttribute))
	}

	utilAllAttribute, ok := attributes["util_all"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`util_all is missing from object`)

		return nil, diags
	}

	utilAllVal, ok := utilAllAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`util_all expected to be basetypes.Int64Value, was: %T`, utilAllAttribute))
	}

	utilNonWifiAttribute, ok := attributes["util_non_wifi"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`util_non_wifi is missing from object`)

		return nil, diags
	}

	utilNonWifiVal, ok := utilNonWifiAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`util_non_wifi expected to be basetypes.Int64Value, was: %T`, utilNonWifiAttribute))
	}

	utilRxInBssAttribute, ok := attributes["util_rx_in_bss"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`util_rx_in_bss is missing from object`)

		return nil, diags
	}

	utilRxInBssVal, ok := utilRxInBssAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`util_rx_in_bss expected to be basetypes.Int64Value, was: %T`, utilRxInBssAttribute))
	}

	utilRxOtherBssAttribute, ok := attributes["util_rx_other_bss"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`util_rx_other_bss is missing from object`)

		return nil, diags
	}

	utilRxOtherBssVal, ok := utilRxOtherBssAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`util_rx_other_bss expected to be basetypes.Int64Value, was: %T`, utilRxOtherBssAttribute))
	}

	utilTxAttribute, ok := attributes["util_tx"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`util_tx is missing from object`)

		return nil, diags
	}

	utilTxVal, ok := utilTxAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`util_tx expected to be basetypes.Int64Value, was: %T`, utilTxAttribute))
	}

	utilUndecodableWifiAttribute, ok := attributes["util_undecodable_wifi"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`util_undecodable_wifi is missing from object`)

		return nil, diags
	}

	utilUndecodableWifiVal, ok := utilUndecodableWifiAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`util_undecodable_wifi expected to be basetypes.Int64Value, was: %T`, utilUndecodableWifiAttribute))
	}

	utilUnknownWifiAttribute, ok := attributes["util_unknown_wifi"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`util_unknown_wifi is missing from object`)

		return nil, diags
	}

	utilUnknownWifiVal, ok := utilUnknownWifiAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`util_unknown_wifi expected to be basetypes.Int64Value, was: %T`, utilUnknownWifiAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return BandValue{
		Bandwidth:              bandwidthVal,
		Channel:                channelVal,
		DynamicChainingEnalbed: dynamicChainingEnalbedVal,
		Mac:                    macVal,
		NoiseFloor:             noiseFloorVal,
		NumClients:             numClientsVal,
		Power:                  powerVal,
		RxBytes:                rxBytesVal,
		RxPkts:                 rxPktsVal,
		TxBytes:                txBytesVal,
		TxPkts:                 txPktsVal,
		Usage:                  usageVal,
		UtilAll:                utilAllVal,
		UtilNonWifi:            utilNonWifiVal,
		UtilRxInBss:            utilRxInBssVal,
		UtilRxOtherBss:         utilRxOtherBssVal,
		UtilTx:                 utilTxVal,
		UtilUndecodableWifi:    utilUndecodableWifiVal,
		UtilUnknownWifi:        utilUnknownWifiVal,
		state:                  attr.ValueStateKnown,
	}, diags
}

func NewBandValueNull() BandValue {
	return BandValue{
		state: attr.ValueStateNull,
	}
}

func NewBandValueUnknown() BandValue {
	return BandValue{
		state: attr.ValueStateUnknown,
	}
}

func NewBandValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (BandValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing BandValue Attribute Value",
				"While creating a BandValue value, a missing attribute value was detected. "+
					"A BandValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("BandValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid BandValue Attribute Type",
				"While creating a BandValue value, an invalid attribute value was detected. "+
					"A BandValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("BandValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("BandValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra BandValue Attribute Value",
				"While creating a BandValue value, an extra attribute value was detected. "+
					"A BandValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra BandValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewBandValueUnknown(), diags
	}

	bandwidthAttribute, ok := attributes["bandwidth"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bandwidth is missing from object`)

		return NewBandValueUnknown(), diags
	}

	bandwidthVal, ok := bandwidthAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bandwidth expected to be basetypes.Int64Value, was: %T`, bandwidthAttribute))
	}

	channelAttribute, ok := attributes["channel"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`channel is missing from object`)

		return NewBandValueUnknown(), diags
	}

	channelVal, ok := channelAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`channel expected to be basetypes.Int64Value, was: %T`, channelAttribute))
	}

	dynamicChainingEnalbedAttribute, ok := attributes["dynamic_chaining_enalbed"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dynamic_chaining_enalbed is missing from object`)

		return NewBandValueUnknown(), diags
	}

	dynamicChainingEnalbedVal, ok := dynamicChainingEnalbedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dynamic_chaining_enalbed expected to be basetypes.BoolValue, was: %T`, dynamicChainingEnalbedAttribute))
	}

	macAttribute, ok := attributes["mac"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mac is missing from object`)

		return NewBandValueUnknown(), diags
	}

	macVal, ok := macAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mac expected to be basetypes.StringValue, was: %T`, macAttribute))
	}

	noiseFloorAttribute, ok := attributes["noise_floor"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`noise_floor is missing from object`)

		return NewBandValueUnknown(), diags
	}

	noiseFloorVal, ok := noiseFloorAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`noise_floor expected to be basetypes.Int64Value, was: %T`, noiseFloorAttribute))
	}

	numClientsAttribute, ok := attributes["num_clients"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`num_clients is missing from object`)

		return NewBandValueUnknown(), diags
	}

	numClientsVal, ok := numClientsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`num_clients expected to be basetypes.Int64Value, was: %T`, numClientsAttribute))
	}

	powerAttribute, ok := attributes["power"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`power is missing from object`)

		return NewBandValueUnknown(), diags
	}

	powerVal, ok := powerAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`power expected to be basetypes.Int64Value, was: %T`, powerAttribute))
	}

	rxBytesAttribute, ok := attributes["rx_bytes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rx_bytes is missing from object`)

		return NewBandValueUnknown(), diags
	}

	rxBytesVal, ok := rxBytesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rx_bytes expected to be basetypes.Int64Value, was: %T`, rxBytesAttribute))
	}

	rxPktsAttribute, ok := attributes["rx_pkts"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rx_pkts is missing from object`)

		return NewBandValueUnknown(), diags
	}

	rxPktsVal, ok := rxPktsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rx_pkts expected to be basetypes.Int64Value, was: %T`, rxPktsAttribute))
	}

	txBytesAttribute, ok := attributes["tx_bytes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tx_bytes is missing from object`)

		return NewBandValueUnknown(), diags
	}

	txBytesVal, ok := txBytesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tx_bytes expected to be basetypes.Int64Value, was: %T`, txBytesAttribute))
	}

	txPktsAttribute, ok := attributes["tx_pkts"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tx_pkts is missing from object`)

		return NewBandValueUnknown(), diags
	}

	txPktsVal, ok := txPktsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tx_pkts expected to be basetypes.Int64Value, was: %T`, txPktsAttribute))
	}

	usageAttribute, ok := attributes["usage"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`usage is missing from object`)

		return NewBandValueUnknown(), diags
	}

	usageVal, ok := usageAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`usage expected to be basetypes.StringValue, was: %T`, usageAttribute))
	}

	utilAllAttribute, ok := attributes["util_all"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`util_all is missing from object`)

		return NewBandValueUnknown(), diags
	}

	utilAllVal, ok := utilAllAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`util_all expected to be basetypes.Int64Value, was: %T`, utilAllAttribute))
	}

	utilNonWifiAttribute, ok := attributes["util_non_wifi"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`util_non_wifi is missing from object`)

		return NewBandValueUnknown(), diags
	}

	utilNonWifiVal, ok := utilNonWifiAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`util_non_wifi expected to be basetypes.Int64Value, was: %T`, utilNonWifiAttribute))
	}

	utilRxInBssAttribute, ok := attributes["util_rx_in_bss"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`util_rx_in_bss is missing from object`)

		return NewBandValueUnknown(), diags
	}

	utilRxInBssVal, ok := utilRxInBssAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`util_rx_in_bss expected to be basetypes.Int64Value, was: %T`, utilRxInBssAttribute))
	}

	utilRxOtherBssAttribute, ok := attributes["util_rx_other_bss"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`util_rx_other_bss is missing from object`)

		return NewBandValueUnknown(), diags
	}

	utilRxOtherBssVal, ok := utilRxOtherBssAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`util_rx_other_bss expected to be basetypes.Int64Value, was: %T`, utilRxOtherBssAttribute))
	}

	utilTxAttribute, ok := attributes["util_tx"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`util_tx is missing from object`)

		return NewBandValueUnknown(), diags
	}

	utilTxVal, ok := utilTxAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`util_tx expected to be basetypes.Int64Value, was: %T`, utilTxAttribute))
	}

	utilUndecodableWifiAttribute, ok := attributes["util_undecodable_wifi"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`util_undecodable_wifi is missing from object`)

		return NewBandValueUnknown(), diags
	}

	utilUndecodableWifiVal, ok := utilUndecodableWifiAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`util_undecodable_wifi expected to be basetypes.Int64Value, was: %T`, utilUndecodableWifiAttribute))
	}

	utilUnknownWifiAttribute, ok := attributes["util_unknown_wifi"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`util_unknown_wifi is missing from object`)

		return NewBandValueUnknown(), diags
	}

	utilUnknownWifiVal, ok := utilUnknownWifiAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`util_unknown_wifi expected to be basetypes.Int64Value, was: %T`, utilUnknownWifiAttribute))
	}

	if diags.HasError() {
		return NewBandValueUnknown(), diags
	}

	return BandValue{
		Bandwidth:              bandwidthVal,
		Channel:                channelVal,
		DynamicChainingEnalbed: dynamicChainingEnalbedVal,
		Mac:                    macVal,
		NoiseFloor:             noiseFloorVal,
		NumClients:             numClientsVal,
		Power:                  powerVal,
		RxBytes:                rxBytesVal,
		RxPkts:                 rxPktsVal,
		TxBytes:                txBytesVal,
		TxPkts:                 txPktsVal,
		Usage:                  usageVal,
		UtilAll:                utilAllVal,
		UtilNonWifi:            utilNonWifiVal,
		UtilRxInBss:            utilRxInBssVal,
		UtilRxOtherBss:         utilRxOtherBssVal,
		UtilTx:                 utilTxVal,
		UtilUndecodableWifi:    utilUndecodableWifiVal,
		UtilUnknownWifi:        utilUnknownWifiVal,
		state:                  attr.ValueStateKnown,
	}, diags
}

func NewBandValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) BandValue {
	object, diags := NewBandValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewBandValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t BandType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewBandValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewBandValueUnknown(), nil
	}

	if in.IsNull() {
		return NewBandValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewBandValueMust(BandValue{}.AttributeTypes(ctx), attributes), nil
}

func (t BandType) ValueType(ctx context.Context) attr.Value {
	return BandValue{}
}

var _ basetypes.ObjectValuable = BandValue{}

type BandValue struct {
	Bandwidth              basetypes.Int64Value  `tfsdk:"bandwidth"`
	Channel                basetypes.Int64Value  `tfsdk:"channel"`
	DynamicChainingEnalbed basetypes.BoolValue   `tfsdk:"dynamic_chaining_enalbed"`
	Mac                    basetypes.StringValue `tfsdk:"mac"`
	NoiseFloor             basetypes.Int64Value  `tfsdk:"noise_floor"`
	NumClients             basetypes.Int64Value  `tfsdk:"num_clients"`
	Power                  basetypes.Int64Value  `tfsdk:"power"`
	RxBytes                basetypes.Int64Value  `tfsdk:"rx_bytes"`
	RxPkts                 basetypes.Int64Value  `tfsdk:"rx_pkts"`
	TxBytes                basetypes.Int64Value  `tfsdk:"tx_bytes"`
	TxPkts                 basetypes.Int64Value  `tfsdk:"tx_pkts"`
	Usage                  basetypes.StringValue `tfsdk:"usage"`
	UtilAll                basetypes.Int64Value  `tfsdk:"util_all"`
	UtilNonWifi            basetypes.Int64Value  `tfsdk:"util_non_wifi"`
	UtilRxInBss            basetypes.Int64Value  `tfsdk:"util_rx_in_bss"`
	UtilRxOtherBss         basetypes.Int64Value  `tfsdk:"util_rx_other_bss"`
	UtilTx                 basetypes.Int64Value  `tfsdk:"util_tx"`
	UtilUndecodableWifi    basetypes.Int64Value  `tfsdk:"util_undecodable_wifi"`
	UtilUnknownWifi        basetypes.Int64Value  `tfsdk:"util_unknown_wifi"`
	state                  attr.ValueState
}

func (v BandValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 19)

	var val tftypes.Value
	var err error

	attrTypes["bandwidth"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["channel"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["dynamic_chaining_enalbed"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["mac"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["noise_floor"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["num_clients"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["power"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["rx_bytes"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["rx_pkts"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["tx_bytes"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["tx_pkts"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["usage"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["util_all"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["util_non_wifi"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["util_rx_in_bss"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["util_rx_other_bss"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["util_tx"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["util_undecodable_wifi"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["util_unknown_wifi"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 19)

		val, err = v.Bandwidth.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bandwidth"] = val

		val, err = v.Channel.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["channel"] = val

		val, err = v.DynamicChainingEnalbed.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dynamic_chaining_enalbed"] = val

		val, err = v.Mac.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mac"] = val

		val, err = v.NoiseFloor.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["noise_floor"] = val

		val, err = v.NumClients.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["num_clients"] = val

		val, err = v.Power.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["power"] = val

		val, err = v.RxBytes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["rx_bytes"] = val

		val, err = v.RxPkts.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["rx_pkts"] = val

		val, err = v.TxBytes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tx_bytes"] = val

		val, err = v.TxPkts.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tx_pkts"] = val

		val, err = v.Usage.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["usage"] = val

		val, err = v.UtilAll.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["util_all"] = val

		val, err = v.UtilNonWifi.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["util_non_wifi"] = val

		val, err = v.UtilRxInBss.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["util_rx_in_bss"] = val

		val, err = v.UtilRxOtherBss.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["util_rx_other_bss"] = val

		val, err = v.UtilTx.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["util_tx"] = val

		val, err = v.UtilUndecodableWifi.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["util_undecodable_wifi"] = val

		val, err = v.UtilUnknownWifi.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["util_unknown_wifi"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v BandValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v BandValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v BandValue) String() string {
	return "BandValue"
}

func (v BandValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"bandwidth":                basetypes.Int64Type{},
		"channel":                  basetypes.Int64Type{},
		"dynamic_chaining_enalbed": basetypes.BoolType{},
		"mac":                      basetypes.StringType{},
		"noise_floor":              basetypes.Int64Type{},
		"num_clients":              basetypes.Int64Type{},
		"power":                    basetypes.Int64Type{},
		"rx_bytes":                 basetypes.Int64Type{},
		"rx_pkts":                  basetypes.Int64Type{},
		"tx_bytes":                 basetypes.Int64Type{},
		"tx_pkts":                  basetypes.Int64Type{},
		"usage":                    basetypes.StringType{},
		"util_all":                 basetypes.Int64Type{},
		"util_non_wifi":            basetypes.Int64Type{},
		"util_rx_in_bss":           basetypes.Int64Type{},
		"util_rx_other_bss":        basetypes.Int64Type{},
		"util_tx":                  basetypes.Int64Type{},
		"util_undecodable_wifi":    basetypes.Int64Type{},
		"util_unknown_wifi":        basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"bandwidth":                v.Bandwidth,
			"channel":                  v.Channel,
			"dynamic_chaining_enalbed": v.DynamicChainingEnalbed,
			"mac":                      v.Mac,
			"noise_floor":              v.NoiseFloor,
			"num_clients":              v.NumClients,
			"power":                    v.Power,
			"rx_bytes":                 v.RxBytes,
			"rx_pkts":                  v.RxPkts,
			"tx_bytes":                 v.TxBytes,
			"tx_pkts":                  v.TxPkts,
			"usage":                    v.Usage,
			"util_all":                 v.UtilAll,
			"util_non_wifi":            v.UtilNonWifi,
			"util_rx_in_bss":           v.UtilRxInBss,
			"util_rx_other_bss":        v.UtilRxOtherBss,
			"util_tx":                  v.UtilTx,
			"util_undecodable_wifi":    v.UtilUndecodableWifi,
			"util_unknown_wifi":        v.UtilUnknownWifi,
		})

	return objVal, diags
}

func (v BandValue) Equal(o attr.Value) bool {
	other, ok := o.(BandValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Bandwidth.Equal(other.Bandwidth) {
		return false
	}

	if !v.Channel.Equal(other.Channel) {
		return false
	}

	if !v.DynamicChainingEnalbed.Equal(other.DynamicChainingEnalbed) {
		return false
	}

	if !v.Mac.Equal(other.Mac) {
		return false
	}

	if !v.NoiseFloor.Equal(other.NoiseFloor) {
		return false
	}

	if !v.NumClients.Equal(other.NumClients) {
		return false
	}

	if !v.Power.Equal(other.Power) {
		return false
	}

	if !v.RxBytes.Equal(other.RxBytes) {
		return false
	}

	if !v.RxPkts.Equal(other.RxPkts) {
		return false
	}

	if !v.TxBytes.Equal(other.TxBytes) {
		return false
	}

	if !v.TxPkts.Equal(other.TxPkts) {
		return false
	}

	if !v.Usage.Equal(other.Usage) {
		return false
	}

	if !v.UtilAll.Equal(other.UtilAll) {
		return false
	}

	if !v.UtilNonWifi.Equal(other.UtilNonWifi) {
		return false
	}

	if !v.UtilRxInBss.Equal(other.UtilRxInBss) {
		return false
	}

	if !v.UtilRxOtherBss.Equal(other.UtilRxOtherBss) {
		return false
	}

	if !v.UtilTx.Equal(other.UtilTx) {
		return false
	}

	if !v.UtilUndecodableWifi.Equal(other.UtilUndecodableWifi) {
		return false
	}

	if !v.UtilUnknownWifi.Equal(other.UtilUnknownWifi) {
		return false
	}

	return true
}

func (v BandValue) Type(ctx context.Context) attr.Type {
	return BandType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v BandValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"bandwidth":                basetypes.Int64Type{},
		"channel":                  basetypes.Int64Type{},
		"dynamic_chaining_enalbed": basetypes.BoolType{},
		"mac":                      basetypes.StringType{},
		"noise_floor":              basetypes.Int64Type{},
		"num_clients":              basetypes.Int64Type{},
		"power":                    basetypes.Int64Type{},
		"rx_bytes":                 basetypes.Int64Type{},
		"rx_pkts":                  basetypes.Int64Type{},
		"tx_bytes":                 basetypes.Int64Type{},
		"tx_pkts":                  basetypes.Int64Type{},
		"usage":                    basetypes.StringType{},
		"util_all":                 basetypes.Int64Type{},
		"util_non_wifi":            basetypes.Int64Type{},
		"util_rx_in_bss":           basetypes.Int64Type{},
		"util_rx_other_bss":        basetypes.Int64Type{},
		"util_tx":                  basetypes.Int64Type{},
		"util_undecodable_wifi":    basetypes.Int64Type{},
		"util_unknown_wifi":        basetypes.Int64Type{},
	}
}











































var _ basetypes.ObjectTypable = SwitchRedundancyType{}

type SwitchRedundancyType struct {
	basetypes.ObjectType
}

func (t SwitchRedundancyType) Equal(o attr.Type) bool {
	other, ok := o.(SwitchRedundancyType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SwitchRedundancyType) String() string {
	return "SwitchRedundancyType"
}

func (t SwitchRedundancyType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	numRedundantApsAttribute, ok := attributes["num_redundant_aps"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`num_redundant_aps is missing from object`)

		return nil, diags
	}

	numRedundantApsVal, ok := numRedundantApsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`num_redundant_aps expected to be basetypes.Int64Value, was: %T`, numRedundantApsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SwitchRedundancyValue{
		NumRedundantAps: numRedundantApsVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewSwitchRedundancyValueNull() SwitchRedundancyValue {
	return SwitchRedundancyValue{
		state: attr.ValueStateNull,
	}
}

func NewSwitchRedundancyValueUnknown() SwitchRedundancyValue {
	return SwitchRedundancyValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSwitchRedundancyValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SwitchRedundancyValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SwitchRedundancyValue Attribute Value",
				"While creating a SwitchRedundancyValue value, a missing attribute value was detected. "+
					"A SwitchRedundancyValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SwitchRedundancyValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SwitchRedundancyValue Attribute Type",
				"While creating a SwitchRedundancyValue value, an invalid attribute value was detected. "+
					"A SwitchRedundancyValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SwitchRedundancyValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SwitchRedundancyValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SwitchRedundancyValue Attribute Value",
				"While creating a SwitchRedundancyValue value, an extra attribute value was detected. "+
					"A SwitchRedundancyValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SwitchRedundancyValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSwitchRedundancyValueUnknown(), diags
	}

	numRedundantApsAttribute, ok := attributes["num_redundant_aps"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`num_redundant_aps is missing from object`)

		return NewSwitchRedundancyValueUnknown(), diags
	}

	numRedundantApsVal, ok := numRedundantApsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`num_redundant_aps expected to be basetypes.Int64Value, was: %T`, numRedundantApsAttribute))
	}

	if diags.HasError() {
		return NewSwitchRedundancyValueUnknown(), diags
	}

	return SwitchRedundancyValue{
		NumRedundantAps: numRedundantApsVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewSwitchRedundancyValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SwitchRedundancyValue {
	object, diags := NewSwitchRedundancyValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSwitchRedundancyValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SwitchRedundancyType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSwitchRedundancyValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSwitchRedundancyValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSwitchRedundancyValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSwitchRedundancyValueMust(SwitchRedundancyValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SwitchRedundancyType) ValueType(ctx context.Context) attr.Value {
	return SwitchRedundancyValue{}
}

var _ basetypes.ObjectValuable = SwitchRedundancyValue{}

type SwitchRedundancyValue struct {
	NumRedundantAps basetypes.Int64Value `tfsdk:"num_redundant_aps"`
	state           attr.ValueState
}

func (v SwitchRedundancyValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["num_redundant_aps"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.NumRedundantAps.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["num_redundant_aps"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SwitchRedundancyValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SwitchRedundancyValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SwitchRedundancyValue) String() string {
	return "SwitchRedundancyValue"
}

func (v SwitchRedundancyValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"num_redundant_aps": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"num_redundant_aps": v.NumRedundantAps,
		})

	return objVal, diags
}

func (v SwitchRedundancyValue) Equal(o attr.Value) bool {
	other, ok := o.(SwitchRedundancyValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.NumRedundantAps.Equal(other.NumRedundantAps) {
		return false
	}

	return true
}

func (v SwitchRedundancyValue) Type(ctx context.Context) attr.Type {
	return SwitchRedundancyType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SwitchRedundancyValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"num_redundant_aps": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = UsbStatType{}

type UsbStatType struct {
	basetypes.ObjectType
}

func (t UsbStatType) Equal(o attr.Type) bool {
	other, ok := o.(UsbStatType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t UsbStatType) String() string {
	return "UsbStatType"
}

func (t UsbStatType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	channelAttribute, ok := attributes["channel"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`channel is missing from object`)

		return nil, diags
	}

	channelVal, ok := channelAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`channel expected to be basetypes.Int64Value, was: %T`, channelAttribute))
	}

	connectedAttribute, ok := attributes["connected"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`connected is missing from object`)

		return nil, diags
	}

	connectedVal, ok := connectedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`connected expected to be basetypes.BoolValue, was: %T`, connectedAttribute))
	}

	lastActivityAttribute, ok := attributes["last_activity"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`last_activity is missing from object`)

		return nil, diags
	}

	lastActivityVal, ok := lastActivityAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`last_activity expected to be basetypes.Int64Value, was: %T`, lastActivityAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	upAttribute, ok := attributes["up"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`up is missing from object`)

		return nil, diags
	}

	upVal, ok := upAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`up expected to be basetypes.BoolValue, was: %T`, upAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return UsbStatValue{
		Channel:      channelVal,
		Connected:    connectedVal,
		LastActivity: lastActivityVal,
		UsbStatType:  typeVal,
		Up:           upVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewUsbStatValueNull() UsbStatValue {
	return UsbStatValue{
		state: attr.ValueStateNull,
	}
}

func NewUsbStatValueUnknown() UsbStatValue {
	return UsbStatValue{
		state: attr.ValueStateUnknown,
	}
}

func NewUsbStatValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (UsbStatValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing UsbStatValue Attribute Value",
				"While creating a UsbStatValue value, a missing attribute value was detected. "+
					"A UsbStatValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("UsbStatValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid UsbStatValue Attribute Type",
				"While creating a UsbStatValue value, an invalid attribute value was detected. "+
					"A UsbStatValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("UsbStatValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("UsbStatValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra UsbStatValue Attribute Value",
				"While creating a UsbStatValue value, an extra attribute value was detected. "+
					"A UsbStatValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra UsbStatValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewUsbStatValueUnknown(), diags
	}

	channelAttribute, ok := attributes["channel"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`channel is missing from object`)

		return NewUsbStatValueUnknown(), diags
	}

	channelVal, ok := channelAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`channel expected to be basetypes.Int64Value, was: %T`, channelAttribute))
	}

	connectedAttribute, ok := attributes["connected"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`connected is missing from object`)

		return NewUsbStatValueUnknown(), diags
	}

	connectedVal, ok := connectedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`connected expected to be basetypes.BoolValue, was: %T`, connectedAttribute))
	}

	lastActivityAttribute, ok := attributes["last_activity"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`last_activity is missing from object`)

		return NewUsbStatValueUnknown(), diags
	}

	lastActivityVal, ok := lastActivityAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`last_activity expected to be basetypes.Int64Value, was: %T`, lastActivityAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewUsbStatValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	upAttribute, ok := attributes["up"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`up is missing from object`)

		return NewUsbStatValueUnknown(), diags
	}

	upVal, ok := upAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`up expected to be basetypes.BoolValue, was: %T`, upAttribute))
	}

	if diags.HasError() {
		return NewUsbStatValueUnknown(), diags
	}

	return UsbStatValue{
		Channel:      channelVal,
		Connected:    connectedVal,
		LastActivity: lastActivityVal,
		UsbStatType:  typeVal,
		Up:           upVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewUsbStatValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) UsbStatValue {
	object, diags := NewUsbStatValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewUsbStatValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t UsbStatType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewUsbStatValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewUsbStatValueUnknown(), nil
	}

	if in.IsNull() {
		return NewUsbStatValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewUsbStatValueMust(UsbStatValue{}.AttributeTypes(ctx), attributes), nil
}

func (t UsbStatType) ValueType(ctx context.Context) attr.Value {
	return UsbStatValue{}
}

var _ basetypes.ObjectValuable = UsbStatValue{}

type UsbStatValue struct {
	Channel      basetypes.Int64Value  `tfsdk:"channel"`
	Connected    basetypes.BoolValue   `tfsdk:"connected"`
	LastActivity basetypes.Int64Value  `tfsdk:"last_activity"`
	UsbStatType  basetypes.StringValue `tfsdk:"type"`
	Up           basetypes.BoolValue   `tfsdk:"up"`
	state        attr.ValueState
}

func (v UsbStatValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["channel"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["connected"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["last_activity"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["up"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.Channel.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["channel"] = val

		val, err = v.Connected.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["connected"] = val

		val, err = v.LastActivity.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["last_activity"] = val

		val, err = v.UsbStatType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		val, err = v.Up.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["up"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v UsbStatValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v UsbStatValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v UsbStatValue) String() string {
	return "UsbStatValue"
}

func (v UsbStatValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"channel":       basetypes.Int64Type{},
		"connected":     basetypes.BoolType{},
		"last_activity": basetypes.Int64Type{},
		"type":          basetypes.StringType{},
		"up":            basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"channel":       v.Channel,
			"connected":     v.Connected,
			"last_activity": v.LastActivity,
			"type":          v.UsbStatType,
			"up":            v.Up,
		})

	return objVal, diags
}

func (v UsbStatValue) Equal(o attr.Value) bool {
	other, ok := o.(UsbStatValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Channel.Equal(other.Channel) {
		return false
	}

	if !v.Connected.Equal(other.Connected) {
		return false
	}

	if !v.LastActivity.Equal(other.LastActivity) {
		return false
	}

	if !v.UsbStatType.Equal(other.UsbStatType) {
		return false
	}

	if !v.Up.Equal(other.Up) {
		return false
	}

	return true
}

func (v UsbStatValue) Type(ctx context.Context) attr.Type {
	return UsbStatType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v UsbStatValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"channel":       basetypes.Int64Type{},
		"connected":     basetypes.BoolType{},
		"last_activity": basetypes.Int64Type{},
		"type":          basetypes.StringType{},
		"up":            basetypes.BoolType{},
	}
}
