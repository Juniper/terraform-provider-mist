// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package datasource_device_gateway_stats

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/datasource/schema"
)

func DeviceGatewayStatsDataSourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"device_gateway_stats": schema.SetNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"ap_redundancy": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"modules": schema.MapNestedAttribute{
									NestedObject: schema.NestedAttributeObject{
										Attributes: map[string]schema.Attribute{
											"num_aps": schema.Int64Attribute{
												Computed: true,
											},
											"num_aps_with_switch_redundancy": schema.Int64Attribute{
												Computed: true,
											},
										},
										CustomType: ModulesType{
											ObjectType: types.ObjectType{
												AttrTypes: ModulesValue{}.AttributeTypes(ctx),
											},
										},
									},
									Computed:            true,
									Description:         "Property key is the node id",
									MarkdownDescription: "Property key is the node id",
								},
								"num_aps": schema.Int64Attribute{
									Computed: true,
								},
								"num_aps_with_switch_redundancy": schema.Int64Attribute{
									Computed: true,
								},
							},
							CustomType: ApRedundancyType{
								ObjectType: types.ObjectType{
									AttrTypes: ApRedundancyValue{}.AttributeTypes(ctx),
								},
							},
							Computed: true,
						},
						"arp_table_stats": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"arp_table_count": schema.Int64Attribute{
									Computed: true,
								},
								"max_entries_supported": schema.Int64Attribute{
									Computed: true,
								},
							},
							CustomType: ArpTableStatsType{
								ObjectType: types.ObjectType{
									AttrTypes: ArpTableStatsValue{}.AttributeTypes(ctx),
								},
							},
							Computed: true,
						},
						"cert_expiry": schema.Int64Attribute{
							Computed: true,
						},
						"cluster_config": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"configuration": schema.StringAttribute{
									Computed: true,
								},
								"control_link_info": schema.SingleNestedAttribute{
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											Computed: true,
										},
										"status": schema.StringAttribute{
											Computed: true,
										},
									},
									CustomType: ControlLinkInfoType{
										ObjectType: types.ObjectType{
											AttrTypes: ControlLinkInfoValue{}.AttributeTypes(ctx),
										},
									},
									Computed: true,
								},
								"ethernet_connection": schema.ListNestedAttribute{
									NestedObject: schema.NestedAttributeObject{
										Attributes: map[string]schema.Attribute{
											"name": schema.StringAttribute{
												Computed: true,
											},
											"status": schema.StringAttribute{
												Computed: true,
											},
										},
										CustomType: EthernetConnectionType{
											ObjectType: types.ObjectType{
												AttrTypes: EthernetConnectionValue{}.AttributeTypes(ctx),
											},
										},
									},
									Computed: true,
								},
								"fabric_link_info": schema.SingleNestedAttribute{
									Attributes: map[string]schema.Attribute{
										"data_plane_notified_status": schema.StringAttribute{
											Computed: true,
										},
										"interface": schema.ListAttribute{
											ElementType: types.StringType,
											Computed:    true,
										},
										"internal_status": schema.StringAttribute{
											Computed: true,
										},
										"state": schema.StringAttribute{
											Computed: true,
										},
										"status": schema.StringAttribute{
											Computed: true,
										},
									},
									CustomType: FabricLinkInfoType{
										ObjectType: types.ObjectType{
											AttrTypes: FabricLinkInfoValue{}.AttributeTypes(ctx),
										},
									},
									Computed: true,
								},
								"last_status_change_reason": schema.StringAttribute{
									Computed: true,
								},
								"operational": schema.StringAttribute{
									Computed: true,
								},
								"primary_node_health": schema.StringAttribute{
									Computed: true,
								},
								"redundancy_group_information": schema.ListNestedAttribute{
									NestedObject: schema.NestedAttributeObject{
										Attributes: map[string]schema.Attribute{
											"id": schema.Int64Attribute{
												Computed: true,
											},
											"monitoring_failure": schema.StringAttribute{
												Computed: true,
											},
											"threshold": schema.Int64Attribute{
												Computed: true,
											},
										},
										CustomType: RedundancyGroupInformationType{
											ObjectType: types.ObjectType{
												AttrTypes: RedundancyGroupInformationValue{}.AttributeTypes(ctx),
											},
										},
									},
									Computed: true,
								},
								"secondary_node_health": schema.StringAttribute{
									Computed: true,
								},
								"status": schema.StringAttribute{
									Computed: true,
								},
							},
							CustomType: ClusterConfigType{
								ObjectType: types.ObjectType{
									AttrTypes: ClusterConfigValue{}.AttributeTypes(ctx),
								},
							},
							Computed: true,
						},
						"cluster_stat": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"state": schema.StringAttribute{
									Computed: true,
								},
							},
							CustomType: ClusterStatType{
								ObjectType: types.ObjectType{
									AttrTypes: ClusterStatValue{}.AttributeTypes(ctx),
								},
							},
							Computed: true,
						},
						"conductor_name": schema.StringAttribute{
							Computed: true,
						},
						"config_status": schema.StringAttribute{
							Computed: true,
						},
						"cpu2_stat": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"idle": schema.NumberAttribute{
									Computed:            true,
									Description:         "Percentage of CPU time that is idle",
									MarkdownDescription: "Percentage of CPU time that is idle",
								},
								"interrupt": schema.NumberAttribute{
									Computed:            true,
									Description:         "Percentage of CPU time being used by interrupts",
									MarkdownDescription: "Percentage of CPU time being used by interrupts",
								},
								"load_avg": schema.ListAttribute{
									ElementType:         types.NumberType,
									Computed:            true,
									Description:         "Load averages for the last 1, 5, and 15 minutes",
									MarkdownDescription: "Load averages for the last 1, 5, and 15 minutes",
								},
								"system": schema.NumberAttribute{
									Computed:            true,
									Description:         "Percentage of CPU time being used by system processes",
									MarkdownDescription: "Percentage of CPU time being used by system processes",
								},
								"user": schema.NumberAttribute{
									Computed:            true,
									Description:         "Percentage of CPU time being used by user processe",
									MarkdownDescription: "Percentage of CPU time being used by user processe",
								},
							},
							CustomType: CpuStatType{
								ObjectType: types.ObjectType{
									AttrTypes: CpuStatValue{}.AttributeTypes(ctx),
								},
							},
							Computed: true,
						},
						"cpu_stat": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"idle": schema.NumberAttribute{
									Computed:            true,
									Description:         "Percentage of CPU time that is idle",
									MarkdownDescription: "Percentage of CPU time that is idle",
								},
								"interrupt": schema.NumberAttribute{
									Computed:            true,
									Description:         "Percentage of CPU time being used by interrupts",
									MarkdownDescription: "Percentage of CPU time being used by interrupts",
								},
								"load_avg": schema.ListAttribute{
									ElementType:         types.NumberType,
									Computed:            true,
									Description:         "Load averages for the last 1, 5, and 15 minutes",
									MarkdownDescription: "Load averages for the last 1, 5, and 15 minutes",
								},
								"system": schema.NumberAttribute{
									Computed:            true,
									Description:         "Percentage of CPU time being used by system processes",
									MarkdownDescription: "Percentage of CPU time being used by system processes",
								},
								"user": schema.NumberAttribute{
									Computed:            true,
									Description:         "Percentage of CPU time being used by user processe",
									MarkdownDescription: "Percentage of CPU time being used by user processe",
								},
							},
							CustomType: CpuStatType{
								ObjectType: types.ObjectType{
									AttrTypes: CpuStatValue{}.AttributeTypes(ctx),
								},
							},
							Computed: true,
						},
						"created_time": schema.Int64Attribute{
							Computed: true,
						},
						"deviceprofile_id": schema.StringAttribute{
							Computed: true,
						},
						"dhcpd2_stat": schema.MapNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"num_ips": schema.Int64Attribute{
										Computed: true,
									},
									"num_leased": schema.Int64Attribute{
										Computed: true,
									},
								},
								CustomType: DhcpdStatType{
									ObjectType: types.ObjectType{
										AttrTypes: DhcpdStatValue{}.AttributeTypes(ctx),
									},
								},
							},
							Computed:            true,
							Description:         "Property key is the network name",
							MarkdownDescription: "Property key is the network name",
						},
						"dhcpd_stat": schema.MapNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"num_ips": schema.Int64Attribute{
										Computed: true,
									},
									"num_leased": schema.Int64Attribute{
										Computed: true,
									},
								},
								CustomType: DhcpdStatType{
									ObjectType: types.ObjectType{
										AttrTypes: DhcpdStatValue{}.AttributeTypes(ctx),
									},
								},
							},
							Computed:            true,
							Description:         "Property key is the network name",
							MarkdownDescription: "Property key is the network name",
						},
						"ext_ip": schema.StringAttribute{
							Computed:            true,
							Description:         "IP address",
							MarkdownDescription: "IP address",
						},
						"fwupdate": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"progress": schema.Int64Attribute{
									Computed: true,
								},
								"status": schema.StringAttribute{
									Computed: true,
								},
								"status_id": schema.Int64Attribute{
									Computed: true,
								},
								"timestamp": schema.Float64Attribute{
									Computed: true,
								},
								"will_retry": schema.BoolAttribute{
									Computed: true,
								},
							},
							CustomType: FwupdateType{
								ObjectType: types.ObjectType{
									AttrTypes: FwupdateValue{}.AttributeTypes(ctx),
								},
							},
							Computed: true,
						},
						"has_pcap": schema.BoolAttribute{
							Computed: true,
						},
						"hostname": schema.StringAttribute{
							Computed:            true,
							Description:         "hostname reported by the device",
							MarkdownDescription: "hostname reported by the device",
						},
						"id": schema.StringAttribute{
							Computed:            true,
							Description:         "serial",
							MarkdownDescription: "serial",
						},
						"if2_stat": schema.MapNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"address_mode": schema.StringAttribute{
										Computed: true,
									},
									"ips": schema.ListAttribute{
										ElementType: types.StringType,
										Computed:    true,
									},
									"nat_addresses": schema.ListAttribute{
										ElementType: types.StringType,
										Computed:    true,
									},
									"network_name": schema.StringAttribute{
										Computed: true,
									},
									"port_id": schema.StringAttribute{
										Computed: true,
									},
									"port_usage": schema.StringAttribute{
										Computed: true,
									},
									"redundancy_state": schema.StringAttribute{
										Computed: true,
									},
									"rx_bytes": schema.Int64Attribute{
										Computed: true,
									},
									"rx_pkts": schema.Int64Attribute{
										Computed: true,
									},
									"servp_info": schema.SingleNestedAttribute{
										Attributes: map[string]schema.Attribute{
											"asn": schema.StringAttribute{
												Computed: true,
											},
											"city": schema.StringAttribute{
												Computed: true,
											},
											"country_code": schema.StringAttribute{
												Computed: true,
											},
											"latitude": schema.NumberAttribute{
												Computed: true,
											},
											"longitude": schema.NumberAttribute{
												Computed: true,
											},
											"org": schema.StringAttribute{
												Computed: true,
											},
											"region_code": schema.StringAttribute{
												Computed: true,
											},
										},
										CustomType: ServpInfoType{
											ObjectType: types.ObjectType{
												AttrTypes: ServpInfoValue{}.AttributeTypes(ctx),
											},
										},
										Computed: true,
									},
									"tx_bytes": schema.Int64Attribute{
										Computed: true,
									},
									"tx_pkts": schema.Int64Attribute{
										Computed: true,
									},
									"up": schema.BoolAttribute{
										Computed: true,
									},
									"vlan": schema.Int64Attribute{
										Computed: true,
									},
									"wan_name": schema.StringAttribute{
										Computed: true,
									},
									"wan_type": schema.StringAttribute{
										Computed: true,
									},
								},
								CustomType: IfStatType{
									ObjectType: types.ObjectType{
										AttrTypes: IfStatValue{}.AttributeTypes(ctx),
									},
								},
							},
							Computed:            true,
							Description:         "Property key is the interface name",
							MarkdownDescription: "Property key is the interface name",
						},
						"if_stat": schema.MapNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"address_mode": schema.StringAttribute{
										Computed: true,
									},
									"ips": schema.ListAttribute{
										ElementType: types.StringType,
										Computed:    true,
									},
									"nat_addresses": schema.ListAttribute{
										ElementType: types.StringType,
										Computed:    true,
									},
									"network_name": schema.StringAttribute{
										Computed: true,
									},
									"port_id": schema.StringAttribute{
										Computed: true,
									},
									"port_usage": schema.StringAttribute{
										Computed: true,
									},
									"redundancy_state": schema.StringAttribute{
										Computed: true,
									},
									"rx_bytes": schema.Int64Attribute{
										Computed: true,
									},
									"rx_pkts": schema.Int64Attribute{
										Computed: true,
									},
									"servp_info": schema.SingleNestedAttribute{
										Attributes: map[string]schema.Attribute{
											"asn": schema.StringAttribute{
												Computed: true,
											},
											"city": schema.StringAttribute{
												Computed: true,
											},
											"country_code": schema.StringAttribute{
												Computed: true,
											},
											"latitude": schema.NumberAttribute{
												Computed: true,
											},
											"longitude": schema.NumberAttribute{
												Computed: true,
											},
											"org": schema.StringAttribute{
												Computed: true,
											},
											"region_code": schema.StringAttribute{
												Computed: true,
											},
										},
										CustomType: ServpInfoType{
											ObjectType: types.ObjectType{
												AttrTypes: ServpInfoValue{}.AttributeTypes(ctx),
											},
										},
										Computed: true,
									},
									"tx_bytes": schema.Int64Attribute{
										Computed: true,
									},
									"tx_pkts": schema.Int64Attribute{
										Computed: true,
									},
									"up": schema.BoolAttribute{
										Computed: true,
									},
									"vlan": schema.Int64Attribute{
										Computed: true,
									},
									"wan_name": schema.StringAttribute{
										Computed: true,
									},
									"wan_type": schema.StringAttribute{
										Computed: true,
									},
								},
								CustomType: IfStatType{
									ObjectType: types.ObjectType{
										AttrTypes: IfStatValue{}.AttributeTypes(ctx),
									},
								},
							},
							Computed:            true,
							Description:         "Property key is the interface name",
							MarkdownDescription: "Property key is the interface name",
						},
						"ip": schema.StringAttribute{
							Computed:            true,
							Description:         "IP address",
							MarkdownDescription: "IP address",
						},
						"ip2_stat": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"dhcp_server": schema.StringAttribute{
									Computed: true,
								},
								"dns": schema.ListAttribute{
									ElementType: types.StringType,
									Computed:    true,
								},
								"dns_suffix": schema.ListAttribute{
									ElementType: types.StringType,
									Computed:    true,
								},
								"gateway": schema.StringAttribute{
									Computed: true,
								},
								"gateway6": schema.StringAttribute{
									Computed: true,
								},
								"ip": schema.StringAttribute{
									Computed: true,
								},
								"ip6": schema.StringAttribute{
									Computed: true,
								},
								"ips": schema.MapAttribute{
									ElementType: types.StringType,
									Computed:    true,
								},
								"netmask": schema.StringAttribute{
									Computed: true,
								},
								"netmask6": schema.StringAttribute{
									Computed: true,
								},
							},
							CustomType: IpStatType{
								ObjectType: types.ObjectType{
									AttrTypes: IpStatValue{}.AttributeTypes(ctx),
								},
							},
							Computed: true,
						},
						"ip_stat": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"dhcp_server": schema.StringAttribute{
									Computed: true,
								},
								"dns": schema.ListAttribute{
									ElementType: types.StringType,
									Computed:    true,
								},
								"dns_suffix": schema.ListAttribute{
									ElementType: types.StringType,
									Computed:    true,
								},
								"gateway": schema.StringAttribute{
									Computed: true,
								},
								"gateway6": schema.StringAttribute{
									Computed: true,
								},
								"ip": schema.StringAttribute{
									Computed: true,
								},
								"ip6": schema.StringAttribute{
									Computed: true,
								},
								"ips": schema.MapAttribute{
									ElementType: types.StringType,
									Computed:    true,
								},
								"netmask": schema.StringAttribute{
									Computed: true,
								},
								"netmask6": schema.StringAttribute{
									Computed: true,
								},
							},
							CustomType: IpStatType{
								ObjectType: types.ObjectType{
									AttrTypes: IpStatValue{}.AttributeTypes(ctx),
								},
							},
							Computed: true,
						},
						"is_ha": schema.BoolAttribute{
							Computed: true,
						},
						"last_seen": schema.NumberAttribute{
							Computed:            true,
							Description:         "last seen timestamp",
							MarkdownDescription: "last seen timestamp",
						},
						"mac": schema.StringAttribute{
							Computed:            true,
							Description:         "device mac",
							MarkdownDescription: "device mac",
						},
						"map_id": schema.StringAttribute{
							Computed:            true,
							Description:         "serial",
							MarkdownDescription: "serial",
						},
						"memory2_stat": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"usage": schema.NumberAttribute{
									Computed: true,
								},
							},
							CustomType: MemoryStatType{
								ObjectType: types.ObjectType{
									AttrTypes: MemoryStatValue{}.AttributeTypes(ctx),
								},
							},
							Computed:            true,
							Description:         "memory usage stat (for virtual chassis, memory usage of master RE)",
							MarkdownDescription: "memory usage stat (for virtual chassis, memory usage of master RE)",
						},
						"memory_stat": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"usage": schema.NumberAttribute{
									Computed: true,
								},
							},
							CustomType: MemoryStatType{
								ObjectType: types.ObjectType{
									AttrTypes: MemoryStatValue{}.AttributeTypes(ctx),
								},
							},
							Computed:            true,
							Description:         "memory usage stat (for virtual chassis, memory usage of master RE)",
							MarkdownDescription: "memory usage stat (for virtual chassis, memory usage of master RE)",
						},
						"model": schema.StringAttribute{
							Computed:            true,
							Description:         "device model",
							MarkdownDescription: "device model",
						},
						"modified_time": schema.Int64Attribute{
							Computed: true,
						},
						"module2_stat": schema.ListNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"backup_version": schema.StringAttribute{
										Computed: true,
									},
									"bios_version": schema.StringAttribute{
										Computed: true,
									},
									"cpld_version": schema.StringAttribute{
										Computed: true,
									},
									"errors": schema.ListNestedAttribute{
										NestedObject: schema.NestedAttributeObject{
											Attributes: map[string]schema.Attribute{
												"feature": schema.StringAttribute{
													Computed: true,
												},
												"minimum_version": schema.StringAttribute{
													Computed: true,
												},
												"reason": schema.StringAttribute{
													Computed: true,
												},
												"since": schema.Int64Attribute{
													Computed: true,
												},
												"type": schema.StringAttribute{
													Computed: true,
												},
											},
											CustomType: ErrorsType{
												ObjectType: types.ObjectType{
													AttrTypes: ErrorsValue{}.AttributeTypes(ctx),
												},
											},
										},
										Computed:            true,
										Description:         "used to report all error states the device node is running into.\nAn error should always have `type` and `since` fields, and could have some other fields specific to that type.",
										MarkdownDescription: "used to report all error states the device node is running into.\nAn error should always have `type` and `since` fields, and could have some other fields specific to that type.",
									},
									"fans": schema.ListNestedAttribute{
										NestedObject: schema.NestedAttributeObject{
											Attributes: map[string]schema.Attribute{
												"airflow": schema.StringAttribute{
													Computed: true,
												},
												"name": schema.StringAttribute{
													Computed: true,
												},
												"status": schema.StringAttribute{
													Computed: true,
												},
											},
											CustomType: FansType{
												ObjectType: types.ObjectType{
													AttrTypes: FansValue{}.AttributeTypes(ctx),
												},
											},
										},
										Computed: true,
									},
									"fpga_version": schema.StringAttribute{
										Computed: true,
									},
									"last_seen": schema.NumberAttribute{
										Computed: true,
									},
									"model": schema.StringAttribute{
										Computed: true,
									},
									"optics_cpld_version": schema.StringAttribute{
										Computed: true,
									},
									"pending_version": schema.StringAttribute{
										Computed: true,
									},
									"pics": schema.ListNestedAttribute{
										NestedObject: schema.NestedAttributeObject{
											Attributes: map[string]schema.Attribute{
												"index": schema.Int64Attribute{
													Computed: true,
												},
												"model_number": schema.StringAttribute{
													Computed: true,
												},
												"port_groups": schema.ListNestedAttribute{
													NestedObject: schema.NestedAttributeObject{
														Attributes: map[string]schema.Attribute{
															"count": schema.Int64Attribute{
																Computed: true,
															},
															"type": schema.StringAttribute{
																Computed: true,
															},
														},
														CustomType: PortGroupsType{
															ObjectType: types.ObjectType{
																AttrTypes: PortGroupsValue{}.AttributeTypes(ctx),
															},
														},
													},
													Computed: true,
												},
											},
											CustomType: PicsType{
												ObjectType: types.ObjectType{
													AttrTypes: PicsValue{}.AttributeTypes(ctx),
												},
											},
										},
										Computed: true,
									},
									"poe": schema.SingleNestedAttribute{
										Attributes: map[string]schema.Attribute{
											"max_power": schema.NumberAttribute{
												Computed: true,
											},
											"power_draw": schema.NumberAttribute{
												Computed: true,
											},
										},
										CustomType: PoeType{
											ObjectType: types.ObjectType{
												AttrTypes: PoeValue{}.AttributeTypes(ctx),
											},
										},
										Computed: true,
									},
									"poe_version": schema.StringAttribute{
										Computed: true,
									},
									"power_cpld_version": schema.StringAttribute{
										Computed: true,
									},
									"psus": schema.ListNestedAttribute{
										NestedObject: schema.NestedAttributeObject{
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													Computed: true,
												},
												"status": schema.StringAttribute{
													Computed: true,
												},
											},
											CustomType: PsusType{
												ObjectType: types.ObjectType{
													AttrTypes: PsusValue{}.AttributeTypes(ctx),
												},
											},
										},
										Computed: true,
									},
									"re_fpga_version": schema.StringAttribute{
										Computed: true,
									},
									"recovery_version": schema.StringAttribute{
										Computed: true,
									},
									"serial": schema.StringAttribute{
										Computed: true,
									},
									"status": schema.StringAttribute{
										Computed: true,
									},
									"temperatures": schema.ListNestedAttribute{
										NestedObject: schema.NestedAttributeObject{
											Attributes: map[string]schema.Attribute{
												"celsius": schema.NumberAttribute{
													Computed: true,
												},
												"name": schema.StringAttribute{
													Computed: true,
												},
												"status": schema.StringAttribute{
													Computed: true,
												},
											},
											CustomType: TemperaturesType{
												ObjectType: types.ObjectType{
													AttrTypes: TemperaturesValue{}.AttributeTypes(ctx),
												},
											},
										},
										Computed: true,
									},
									"tmc_fpga_version": schema.StringAttribute{
										Computed: true,
									},
									"uboot_version": schema.StringAttribute{
										Computed: true,
									},
									"uptime": schema.Int64Attribute{
										Computed: true,
									},
									"vc_links": schema.ListNestedAttribute{
										NestedObject: schema.NestedAttributeObject{
											Attributes: map[string]schema.Attribute{
												"neighbor_module_idx": schema.Int64Attribute{
													Computed: true,
												},
												"neighbor_port_id": schema.StringAttribute{
													Computed: true,
												},
												"port_id": schema.StringAttribute{
													Computed: true,
												},
											},
											CustomType: VcLinksType{
												ObjectType: types.ObjectType{
													AttrTypes: VcLinksValue{}.AttributeTypes(ctx),
												},
											},
										},
										Computed: true,
									},
									"vc_mode": schema.StringAttribute{
										Computed: true,
									},
									"vc_role": schema.StringAttribute{
										Computed:            true,
										Description:         "master / backup / linecard",
										MarkdownDescription: "master / backup / linecard",
									},
									"vc_state": schema.StringAttribute{
										Computed: true,
									},
									"version": schema.StringAttribute{
										Computed: true,
									},
								},
								CustomType: ModuleStatType{
									ObjectType: types.ObjectType{
										AttrTypes: ModuleStatValue{}.AttributeTypes(ctx),
									},
								},
							},
							Computed: true,
						},
						"module_stat": schema.ListNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"backup_version": schema.StringAttribute{
										Computed: true,
									},
									"bios_version": schema.StringAttribute{
										Computed: true,
									},
									"cpld_version": schema.StringAttribute{
										Computed: true,
									},
									"errors": schema.ListNestedAttribute{
										NestedObject: schema.NestedAttributeObject{
											Attributes: map[string]schema.Attribute{
												"feature": schema.StringAttribute{
													Computed: true,
												},
												"minimum_version": schema.StringAttribute{
													Computed: true,
												},
												"reason": schema.StringAttribute{
													Computed: true,
												},
												"since": schema.Int64Attribute{
													Computed: true,
												},
												"type": schema.StringAttribute{
													Computed: true,
												},
											},
											CustomType: ErrorsType{
												ObjectType: types.ObjectType{
													AttrTypes: ErrorsValue{}.AttributeTypes(ctx),
												},
											},
										},
										Computed:            true,
										Description:         "used to report all error states the device node is running into.\nAn error should always have `type` and `since` fields, and could have some other fields specific to that type.",
										MarkdownDescription: "used to report all error states the device node is running into.\nAn error should always have `type` and `since` fields, and could have some other fields specific to that type.",
									},
									"fans": schema.ListNestedAttribute{
										NestedObject: schema.NestedAttributeObject{
											Attributes: map[string]schema.Attribute{
												"airflow": schema.StringAttribute{
													Computed: true,
												},
												"name": schema.StringAttribute{
													Computed: true,
												},
												"status": schema.StringAttribute{
													Computed: true,
												},
											},
											CustomType: FansType{
												ObjectType: types.ObjectType{
													AttrTypes: FansValue{}.AttributeTypes(ctx),
												},
											},
										},
										Computed: true,
									},
									"fpga_version": schema.StringAttribute{
										Computed: true,
									},
									"last_seen": schema.NumberAttribute{
										Computed: true,
									},
									"model": schema.StringAttribute{
										Computed: true,
									},
									"optics_cpld_version": schema.StringAttribute{
										Computed: true,
									},
									"pending_version": schema.StringAttribute{
										Computed: true,
									},
									"pics": schema.ListNestedAttribute{
										NestedObject: schema.NestedAttributeObject{
											Attributes: map[string]schema.Attribute{
												"index": schema.Int64Attribute{
													Computed: true,
												},
												"model_number": schema.StringAttribute{
													Computed: true,
												},
												"port_groups": schema.ListNestedAttribute{
													NestedObject: schema.NestedAttributeObject{
														Attributes: map[string]schema.Attribute{
															"count": schema.Int64Attribute{
																Computed: true,
															},
															"type": schema.StringAttribute{
																Computed: true,
															},
														},
														CustomType: PortGroupsType{
															ObjectType: types.ObjectType{
																AttrTypes: PortGroupsValue{}.AttributeTypes(ctx),
															},
														},
													},
													Computed: true,
												},
											},
											CustomType: PicsType{
												ObjectType: types.ObjectType{
													AttrTypes: PicsValue{}.AttributeTypes(ctx),
												},
											},
										},
										Computed: true,
									},
									"poe": schema.SingleNestedAttribute{
										Attributes: map[string]schema.Attribute{
											"max_power": schema.NumberAttribute{
												Computed: true,
											},
											"power_draw": schema.NumberAttribute{
												Computed: true,
											},
										},
										CustomType: PoeType{
											ObjectType: types.ObjectType{
												AttrTypes: PoeValue{}.AttributeTypes(ctx),
											},
										},
										Computed: true,
									},
									"poe_version": schema.StringAttribute{
										Computed: true,
									},
									"power_cpld_version": schema.StringAttribute{
										Computed: true,
									},
									"psus": schema.ListNestedAttribute{
										NestedObject: schema.NestedAttributeObject{
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													Computed: true,
												},
												"status": schema.StringAttribute{
													Computed: true,
												},
											},
											CustomType: PsusType{
												ObjectType: types.ObjectType{
													AttrTypes: PsusValue{}.AttributeTypes(ctx),
												},
											},
										},
										Computed: true,
									},
									"re_fpga_version": schema.StringAttribute{
										Computed: true,
									},
									"recovery_version": schema.StringAttribute{
										Computed: true,
									},
									"serial": schema.StringAttribute{
										Computed: true,
									},
									"status": schema.StringAttribute{
										Computed: true,
									},
									"temperatures": schema.ListNestedAttribute{
										NestedObject: schema.NestedAttributeObject{
											Attributes: map[string]schema.Attribute{
												"celsius": schema.NumberAttribute{
													Computed: true,
												},
												"name": schema.StringAttribute{
													Computed: true,
												},
												"status": schema.StringAttribute{
													Computed: true,
												},
											},
											CustomType: TemperaturesType{
												ObjectType: types.ObjectType{
													AttrTypes: TemperaturesValue{}.AttributeTypes(ctx),
												},
											},
										},
										Computed: true,
									},
									"tmc_fpga_version": schema.StringAttribute{
										Computed: true,
									},
									"uboot_version": schema.StringAttribute{
										Computed: true,
									},
									"uptime": schema.Int64Attribute{
										Computed: true,
									},
									"vc_links": schema.ListNestedAttribute{
										NestedObject: schema.NestedAttributeObject{
											Attributes: map[string]schema.Attribute{
												"neighbor_module_idx": schema.Int64Attribute{
													Computed: true,
												},
												"neighbor_port_id": schema.StringAttribute{
													Computed: true,
												},
												"port_id": schema.StringAttribute{
													Computed: true,
												},
											},
											CustomType: VcLinksType{
												ObjectType: types.ObjectType{
													AttrTypes: VcLinksValue{}.AttributeTypes(ctx),
												},
											},
										},
										Computed: true,
									},
									"vc_mode": schema.StringAttribute{
										Computed: true,
									},
									"vc_role": schema.StringAttribute{
										Computed:            true,
										Description:         "master / backup / linecard",
										MarkdownDescription: "master / backup / linecard",
									},
									"vc_state": schema.StringAttribute{
										Computed: true,
									},
									"version": schema.StringAttribute{
										Computed: true,
									},
								},
								CustomType: ModuleStatType{
									ObjectType: types.ObjectType{
										AttrTypes: ModuleStatValue{}.AttributeTypes(ctx),
									},
								},
							},
							Computed: true,
						},
						"name": schema.StringAttribute{
							Computed:            true,
							Description:         "device name if configured",
							MarkdownDescription: "device name if configured",
						},
						"node_name": schema.StringAttribute{
							Computed: true,
						},
						"org_id": schema.StringAttribute{
							Computed:            true,
							Description:         "serial",
							MarkdownDescription: "serial",
						},
						"route_summary_stats": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"fib_routes": schema.Int64Attribute{
									Computed: true,
								},
								"max_unicast_routes_supported": schema.Int64Attribute{
									Computed: true,
								},
								"rib_routes": schema.Int64Attribute{
									Computed: true,
								},
								"total_routes": schema.Int64Attribute{
									Computed: true,
								},
							},
							CustomType: RouteSummaryStatsType{
								ObjectType: types.ObjectType{
									AttrTypes: RouteSummaryStatsValue{}.AttributeTypes(ctx),
								},
							},
							Computed: true,
						},
						"router_name": schema.StringAttribute{
							Computed:            true,
							Description:         "device name if configured",
							MarkdownDescription: "device name if configured",
						},
						"serial": schema.StringAttribute{
							Computed:            true,
							Description:         "serial",
							MarkdownDescription: "serial",
						},
						"service2_stat": schema.MapNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"ash_version": schema.StringAttribute{
										Computed: true,
									},
									"cia_version": schema.StringAttribute{
										Computed: true,
									},
									"ember_version": schema.StringAttribute{
										Computed: true,
									},
									"ipsec_client_version": schema.StringAttribute{
										Computed: true,
									},
									"mist_agent_version": schema.StringAttribute{
										Computed: true,
									},
									"package_version": schema.StringAttribute{
										Computed: true,
									},
									"testing_tools_version": schema.StringAttribute{
										Computed: true,
									},
									"wheeljack_version": schema.StringAttribute{
										Computed: true,
									},
								},
								CustomType: ServiceStatType{
									ObjectType: types.ObjectType{
										AttrTypes: ServiceStatValue{}.AttributeTypes(ctx),
									},
								},
							},
							Computed: true,
						},
						"service_stat": schema.MapNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"ash_version": schema.StringAttribute{
										Computed: true,
									},
									"cia_version": schema.StringAttribute{
										Computed: true,
									},
									"ember_version": schema.StringAttribute{
										Computed: true,
									},
									"ipsec_client_version": schema.StringAttribute{
										Computed: true,
									},
									"mist_agent_version": schema.StringAttribute{
										Computed: true,
									},
									"package_version": schema.StringAttribute{
										Computed: true,
									},
									"testing_tools_version": schema.StringAttribute{
										Computed: true,
									},
									"wheeljack_version": schema.StringAttribute{
										Computed: true,
									},
								},
								CustomType: ServiceStatType{
									ObjectType: types.ObjectType{
										AttrTypes: ServiceStatValue{}.AttributeTypes(ctx),
									},
								},
							},
							Computed: true,
						},
						"service_status": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"appid_install_result": schema.StringAttribute{
									Computed: true,
								},
								"appid_install_timestamp": schema.StringAttribute{
									Computed: true,
								},
								"appid_status": schema.StringAttribute{
									Computed: true,
								},
								"appid_version": schema.Int64Attribute{
									Computed: true,
								},
								"ewf_status": schema.StringAttribute{
									Computed: true,
								},
								"idp_install_result": schema.StringAttribute{
									Computed: true,
								},
								"idp_install_timestamp": schema.StringAttribute{
									Computed: true,
								},
								"idp_policy": schema.StringAttribute{
									Computed: true,
								},
								"idp_status": schema.StringAttribute{
									Computed: true,
								},
								"idp_update_timestamp": schema.StringAttribute{
									Computed: true,
								},
							},
							CustomType: ServiceStatusType{
								ObjectType: types.ObjectType{
									AttrTypes: ServiceStatusValue{}.AttributeTypes(ctx),
								},
							},
							Computed: true,
						},
						"site_id": schema.StringAttribute{
							Computed:            true,
							Description:         "serial",
							MarkdownDescription: "serial",
						},
						"spu2_stat": schema.ListNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"spu_cpu": schema.Int64Attribute{
										Computed: true,
									},
									"spu_current_session": schema.Int64Attribute{
										Computed: true,
									},
									"spu_max_session": schema.Int64Attribute{
										Computed: true,
									},
									"spu_memory": schema.Int64Attribute{
										Computed: true,
									},
									"spu_pending_session": schema.Int64Attribute{
										Computed: true,
									},
									"spu_valid_session": schema.Int64Attribute{
										Computed: true,
									},
								},
								CustomType: SpuStatType{
									ObjectType: types.ObjectType{
										AttrTypes: SpuStatValue{}.AttributeTypes(ctx),
									},
								},
							},
							Computed: true,
						},
						"spu_stat": schema.ListNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"spu_cpu": schema.Int64Attribute{
										Computed: true,
									},
									"spu_current_session": schema.Int64Attribute{
										Computed: true,
									},
									"spu_max_session": schema.Int64Attribute{
										Computed: true,
									},
									"spu_memory": schema.Int64Attribute{
										Computed: true,
									},
									"spu_pending_session": schema.Int64Attribute{
										Computed: true,
									},
									"spu_valid_session": schema.Int64Attribute{
										Computed: true,
									},
								},
								CustomType: SpuStatType{
									ObjectType: types.ObjectType{
										AttrTypes: SpuStatValue{}.AttributeTypes(ctx),
									},
								},
							},
							Computed: true,
						},
						"status": schema.StringAttribute{
							Computed: true,
						},
						"uptime": schema.NumberAttribute{
							Computed: true,
						},
						"version": schema.StringAttribute{
							Computed: true,
						},
					},
					CustomType: DeviceGatewayStatsType{
						ObjectType: types.ObjectType{
							AttrTypes: DeviceGatewayStatsValue{}.AttributeTypes(ctx),
						},
					},
				},
				Computed: true,
			},
			"duration": schema.StringAttribute{
				Optional:            true,
				Description:         "duration like 7d, 2w",
				MarkdownDescription: "duration like 7d, 2w",
			},
			"end": schema.Int64Attribute{
				Optional:            true,
				Description:         "end datetime, can be epoch or relative time like -1d, -2h; now if not specified",
				MarkdownDescription: "end datetime, can be epoch or relative time like -1d, -2h; now if not specified",
			},
			"mac": schema.StringAttribute{
				Optional: true,
			},
			"org_id": schema.StringAttribute{
				Required: true,
			},
			"site_id": schema.StringAttribute{
				Optional: true,
			},
			"start": schema.Int64Attribute{
				Optional:            true,
				Description:         "start datetime, can be epoch or relative time like -1d, -1w; -1d if not specified",
				MarkdownDescription: "start datetime, can be epoch or relative time like -1d, -1w; -1d if not specified",
			},
			"status": schema.StringAttribute{
				Optional: true,
				Validators: []validator.String{
					stringvalidator.OneOf(
						"",
						"all",
						"connected",
						"disconnected",
					),
				},
			},
		},
	}
}

type DeviceGatewayStatsModel struct {
	DeviceGatewayStats types.Set    `tfsdk:"device_gateway_stats"`
	Duration           types.String `tfsdk:"duration"`
	End                types.Int64  `tfsdk:"end"`
	Mac                types.String `tfsdk:"mac"`
	OrgId              types.String `tfsdk:"org_id"`
	SiteId             types.String `tfsdk:"site_id"`
	Start              types.Int64  `tfsdk:"start"`
	Status             types.String `tfsdk:"status"`
}

var _ basetypes.ObjectTypable = DeviceGatewayStatsType{}

type DeviceGatewayStatsType struct {
	basetypes.ObjectType
}

func (t DeviceGatewayStatsType) Equal(o attr.Type) bool {
	other, ok := o.(DeviceGatewayStatsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t DeviceGatewayStatsType) String() string {
	return "DeviceGatewayStatsType"
}

func (t DeviceGatewayStatsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	apRedundancyAttribute, ok := attributes["ap_redundancy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ap_redundancy is missing from object`)

		return nil, diags
	}

	apRedundancyVal, ok := apRedundancyAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ap_redundancy expected to be basetypes.ObjectValue, was: %T`, apRedundancyAttribute))
	}

	arpTableStatsAttribute, ok := attributes["arp_table_stats"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`arp_table_stats is missing from object`)

		return nil, diags
	}

	arpTableStatsVal, ok := arpTableStatsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`arp_table_stats expected to be basetypes.ObjectValue, was: %T`, arpTableStatsAttribute))
	}

	certExpiryAttribute, ok := attributes["cert_expiry"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cert_expiry is missing from object`)

		return nil, diags
	}

	certExpiryVal, ok := certExpiryAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cert_expiry expected to be basetypes.Int64Value, was: %T`, certExpiryAttribute))
	}

	clusterConfigAttribute, ok := attributes["cluster_config"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cluster_config is missing from object`)

		return nil, diags
	}

	clusterConfigVal, ok := clusterConfigAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cluster_config expected to be basetypes.ObjectValue, was: %T`, clusterConfigAttribute))
	}

	clusterStatAttribute, ok := attributes["cluster_stat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cluster_stat is missing from object`)

		return nil, diags
	}

	clusterStatVal, ok := clusterStatAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cluster_stat expected to be basetypes.ObjectValue, was: %T`, clusterStatAttribute))
	}

	conductorNameAttribute, ok := attributes["conductor_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`conductor_name is missing from object`)

		return nil, diags
	}

	conductorNameVal, ok := conductorNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`conductor_name expected to be basetypes.StringValue, was: %T`, conductorNameAttribute))
	}

	configStatusAttribute, ok := attributes["config_status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`config_status is missing from object`)

		return nil, diags
	}

	configStatusVal, ok := configStatusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`config_status expected to be basetypes.StringValue, was: %T`, configStatusAttribute))
	}

	cpu2StatAttribute, ok := attributes["cpu2_stat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cpu2_stat is missing from object`)

		return nil, diags
	}

	cpu2StatVal, ok := cpu2StatAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cpu2_stat expected to be basetypes.ObjectValue, was: %T`, cpu2StatAttribute))
	}

	cpuStatAttribute, ok := attributes["cpu_stat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cpu_stat is missing from object`)

		return nil, diags
	}

	cpuStatVal, ok := cpuStatAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cpu_stat expected to be basetypes.ObjectValue, was: %T`, cpuStatAttribute))
	}

	createdTimeAttribute, ok := attributes["created_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_time is missing from object`)

		return nil, diags
	}

	createdTimeVal, ok := createdTimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_time expected to be basetypes.Int64Value, was: %T`, createdTimeAttribute))
	}

	deviceprofileIdAttribute, ok := attributes["deviceprofile_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`deviceprofile_id is missing from object`)

		return nil, diags
	}

	deviceprofileIdVal, ok := deviceprofileIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`deviceprofile_id expected to be basetypes.StringValue, was: %T`, deviceprofileIdAttribute))
	}

	dhcpd2StatAttribute, ok := attributes["dhcpd2_stat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dhcpd2_stat is missing from object`)

		return nil, diags
	}

	dhcpd2StatVal, ok := dhcpd2StatAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dhcpd2_stat expected to be basetypes.MapValue, was: %T`, dhcpd2StatAttribute))
	}

	dhcpdStatAttribute, ok := attributes["dhcpd_stat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dhcpd_stat is missing from object`)

		return nil, diags
	}

	dhcpdStatVal, ok := dhcpdStatAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dhcpd_stat expected to be basetypes.MapValue, was: %T`, dhcpdStatAttribute))
	}

	extIpAttribute, ok := attributes["ext_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ext_ip is missing from object`)

		return nil, diags
	}

	extIpVal, ok := extIpAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ext_ip expected to be basetypes.StringValue, was: %T`, extIpAttribute))
	}

	fwupdateAttribute, ok := attributes["fwupdate"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fwupdate is missing from object`)

		return nil, diags
	}

	fwupdateVal, ok := fwupdateAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fwupdate expected to be basetypes.ObjectValue, was: %T`, fwupdateAttribute))
	}

	hasPcapAttribute, ok := attributes["has_pcap"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`has_pcap is missing from object`)

		return nil, diags
	}

	hasPcapVal, ok := hasPcapAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`has_pcap expected to be basetypes.BoolValue, was: %T`, hasPcapAttribute))
	}

	hostnameAttribute, ok := attributes["hostname"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`hostname is missing from object`)

		return nil, diags
	}

	hostnameVal, ok := hostnameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`hostname expected to be basetypes.StringValue, was: %T`, hostnameAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	if2StatAttribute, ok := attributes["if2_stat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`if2_stat is missing from object`)

		return nil, diags
	}

	if2StatVal, ok := if2StatAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`if2_stat expected to be basetypes.MapValue, was: %T`, if2StatAttribute))
	}

	ifStatAttribute, ok := attributes["if_stat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`if_stat is missing from object`)

		return nil, diags
	}

	ifStatVal, ok := ifStatAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`if_stat expected to be basetypes.MapValue, was: %T`, ifStatAttribute))
	}

	ipAttribute, ok := attributes["ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip is missing from object`)

		return nil, diags
	}

	ipVal, ok := ipAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip expected to be basetypes.StringValue, was: %T`, ipAttribute))
	}

	ip2StatAttribute, ok := attributes["ip2_stat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip2_stat is missing from object`)

		return nil, diags
	}

	ip2StatVal, ok := ip2StatAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip2_stat expected to be basetypes.ObjectValue, was: %T`, ip2StatAttribute))
	}

	ipStatAttribute, ok := attributes["ip_stat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_stat is missing from object`)

		return nil, diags
	}

	ipStatVal, ok := ipStatAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_stat expected to be basetypes.ObjectValue, was: %T`, ipStatAttribute))
	}

	isHaAttribute, ok := attributes["is_ha"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`is_ha is missing from object`)

		return nil, diags
	}

	isHaVal, ok := isHaAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`is_ha expected to be basetypes.BoolValue, was: %T`, isHaAttribute))
	}

	lastSeenAttribute, ok := attributes["last_seen"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`last_seen is missing from object`)

		return nil, diags
	}

	lastSeenVal, ok := lastSeenAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`last_seen expected to be basetypes.NumberValue, was: %T`, lastSeenAttribute))
	}

	macAttribute, ok := attributes["mac"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mac is missing from object`)

		return nil, diags
	}

	macVal, ok := macAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mac expected to be basetypes.StringValue, was: %T`, macAttribute))
	}

	mapIdAttribute, ok := attributes["map_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`map_id is missing from object`)

		return nil, diags
	}

	mapIdVal, ok := mapIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`map_id expected to be basetypes.StringValue, was: %T`, mapIdAttribute))
	}

	memory2StatAttribute, ok := attributes["memory2_stat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`memory2_stat is missing from object`)

		return nil, diags
	}

	memory2StatVal, ok := memory2StatAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`memory2_stat expected to be basetypes.ObjectValue, was: %T`, memory2StatAttribute))
	}

	memoryStatAttribute, ok := attributes["memory_stat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`memory_stat is missing from object`)

		return nil, diags
	}

	memoryStatVal, ok := memoryStatAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`memory_stat expected to be basetypes.ObjectValue, was: %T`, memoryStatAttribute))
	}

	modelAttribute, ok := attributes["model"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`model is missing from object`)

		return nil, diags
	}

	modelVal, ok := modelAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`model expected to be basetypes.StringValue, was: %T`, modelAttribute))
	}

	modifiedTimeAttribute, ok := attributes["modified_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`modified_time is missing from object`)

		return nil, diags
	}

	modifiedTimeVal, ok := modifiedTimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`modified_time expected to be basetypes.Int64Value, was: %T`, modifiedTimeAttribute))
	}

	module2StatAttribute, ok := attributes["module2_stat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`module2_stat is missing from object`)

		return nil, diags
	}

	module2StatVal, ok := module2StatAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`module2_stat expected to be basetypes.ListValue, was: %T`, module2StatAttribute))
	}

	moduleStatAttribute, ok := attributes["module_stat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`module_stat is missing from object`)

		return nil, diags
	}

	moduleStatVal, ok := moduleStatAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`module_stat expected to be basetypes.ListValue, was: %T`, moduleStatAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	nodeNameAttribute, ok := attributes["node_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node_name is missing from object`)

		return nil, diags
	}

	nodeNameVal, ok := nodeNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node_name expected to be basetypes.StringValue, was: %T`, nodeNameAttribute))
	}

	orgIdAttribute, ok := attributes["org_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`org_id is missing from object`)

		return nil, diags
	}

	orgIdVal, ok := orgIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`org_id expected to be basetypes.StringValue, was: %T`, orgIdAttribute))
	}

	routeSummaryStatsAttribute, ok := attributes["route_summary_stats"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`route_summary_stats is missing from object`)

		return nil, diags
	}

	routeSummaryStatsVal, ok := routeSummaryStatsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`route_summary_stats expected to be basetypes.ObjectValue, was: %T`, routeSummaryStatsAttribute))
	}

	routerNameAttribute, ok := attributes["router_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`router_name is missing from object`)

		return nil, diags
	}

	routerNameVal, ok := routerNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`router_name expected to be basetypes.StringValue, was: %T`, routerNameAttribute))
	}

	serialAttribute, ok := attributes["serial"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`serial is missing from object`)

		return nil, diags
	}

	serialVal, ok := serialAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`serial expected to be basetypes.StringValue, was: %T`, serialAttribute))
	}

	service2StatAttribute, ok := attributes["service2_stat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`service2_stat is missing from object`)

		return nil, diags
	}

	service2StatVal, ok := service2StatAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`service2_stat expected to be basetypes.MapValue, was: %T`, service2StatAttribute))
	}

	serviceStatAttribute, ok := attributes["service_stat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`service_stat is missing from object`)

		return nil, diags
	}

	serviceStatVal, ok := serviceStatAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`service_stat expected to be basetypes.MapValue, was: %T`, serviceStatAttribute))
	}

	serviceStatusAttribute, ok := attributes["service_status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`service_status is missing from object`)

		return nil, diags
	}

	serviceStatusVal, ok := serviceStatusAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`service_status expected to be basetypes.ObjectValue, was: %T`, serviceStatusAttribute))
	}

	siteIdAttribute, ok := attributes["site_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`site_id is missing from object`)

		return nil, diags
	}

	siteIdVal, ok := siteIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`site_id expected to be basetypes.StringValue, was: %T`, siteIdAttribute))
	}

	spu2StatAttribute, ok := attributes["spu2_stat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`spu2_stat is missing from object`)

		return nil, diags
	}

	spu2StatVal, ok := spu2StatAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`spu2_stat expected to be basetypes.ListValue, was: %T`, spu2StatAttribute))
	}

	spuStatAttribute, ok := attributes["spu_stat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`spu_stat is missing from object`)

		return nil, diags
	}

	spuStatVal, ok := spuStatAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`spu_stat expected to be basetypes.ListValue, was: %T`, spuStatAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return nil, diags
	}

	statusVal, ok := statusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be basetypes.StringValue, was: %T`, statusAttribute))
	}

	uptimeAttribute, ok := attributes["uptime"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uptime is missing from object`)

		return nil, diags
	}

	uptimeVal, ok := uptimeAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uptime expected to be basetypes.NumberValue, was: %T`, uptimeAttribute))
	}

	versionAttribute, ok := attributes["version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`version is missing from object`)

		return nil, diags
	}

	versionVal, ok := versionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`version expected to be basetypes.StringValue, was: %T`, versionAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return DeviceGatewayStatsValue{
		ApRedundancy:      apRedundancyVal,
		ArpTableStats:     arpTableStatsVal,
		CertExpiry:        certExpiryVal,
		ClusterConfig:     clusterConfigVal,
		ClusterStat:       clusterStatVal,
		ConductorName:     conductorNameVal,
		ConfigStatus:      configStatusVal,
		Cpu2Stat:          cpu2StatVal,
		CpuStat:           cpuStatVal,
		CreatedTime:       createdTimeVal,
		DeviceprofileId:   deviceprofileIdVal,
		Dhcpd2Stat:        dhcpd2StatVal,
		DhcpdStat:         dhcpdStatVal,
		ExtIp:             extIpVal,
		Fwupdate:          fwupdateVal,
		HasPcap:           hasPcapVal,
		Hostname:          hostnameVal,
		Id:                idVal,
		If2Stat:           if2StatVal,
		IfStat:            ifStatVal,
		Ip:                ipVal,
		Ip2Stat:           ip2StatVal,
		IpStat:            ipStatVal,
		IsHa:              isHaVal,
		LastSeen:          lastSeenVal,
		Mac:               macVal,
		MapId:             mapIdVal,
		Memory2Stat:       memory2StatVal,
		MemoryStat:        memoryStatVal,
		Model:             modelVal,
		ModifiedTime:      modifiedTimeVal,
		Module2Stat:       module2StatVal,
		ModuleStat:        moduleStatVal,
		Name:              nameVal,
		NodeName:          nodeNameVal,
		OrgId:             orgIdVal,
		RouteSummaryStats: routeSummaryStatsVal,
		RouterName:        routerNameVal,
		Serial:            serialVal,
		Service2Stat:      service2StatVal,
		ServiceStat:       serviceStatVal,
		ServiceStatus:     serviceStatusVal,
		SiteId:            siteIdVal,
		Spu2Stat:          spu2StatVal,
		SpuStat:           spuStatVal,
		Status:            statusVal,
		Uptime:            uptimeVal,
		Version:           versionVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewDeviceGatewayStatsValueNull() DeviceGatewayStatsValue {
	return DeviceGatewayStatsValue{
		state: attr.ValueStateNull,
	}
}

func NewDeviceGatewayStatsValueUnknown() DeviceGatewayStatsValue {
	return DeviceGatewayStatsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewDeviceGatewayStatsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (DeviceGatewayStatsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing DeviceGatewayStatsValue Attribute Value",
				"While creating a DeviceGatewayStatsValue value, a missing attribute value was detected. "+
					"A DeviceGatewayStatsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DeviceGatewayStatsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid DeviceGatewayStatsValue Attribute Type",
				"While creating a DeviceGatewayStatsValue value, an invalid attribute value was detected. "+
					"A DeviceGatewayStatsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DeviceGatewayStatsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("DeviceGatewayStatsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra DeviceGatewayStatsValue Attribute Value",
				"While creating a DeviceGatewayStatsValue value, an extra attribute value was detected. "+
					"A DeviceGatewayStatsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra DeviceGatewayStatsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewDeviceGatewayStatsValueUnknown(), diags
	}

	apRedundancyAttribute, ok := attributes["ap_redundancy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ap_redundancy is missing from object`)

		return NewDeviceGatewayStatsValueUnknown(), diags
	}

	apRedundancyVal, ok := apRedundancyAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ap_redundancy expected to be basetypes.ObjectValue, was: %T`, apRedundancyAttribute))
	}

	arpTableStatsAttribute, ok := attributes["arp_table_stats"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`arp_table_stats is missing from object`)

		return NewDeviceGatewayStatsValueUnknown(), diags
	}

	arpTableStatsVal, ok := arpTableStatsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`arp_table_stats expected to be basetypes.ObjectValue, was: %T`, arpTableStatsAttribute))
	}

	certExpiryAttribute, ok := attributes["cert_expiry"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cert_expiry is missing from object`)

		return NewDeviceGatewayStatsValueUnknown(), diags
	}

	certExpiryVal, ok := certExpiryAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cert_expiry expected to be basetypes.Int64Value, was: %T`, certExpiryAttribute))
	}

	clusterConfigAttribute, ok := attributes["cluster_config"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cluster_config is missing from object`)

		return NewDeviceGatewayStatsValueUnknown(), diags
	}

	clusterConfigVal, ok := clusterConfigAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cluster_config expected to be basetypes.ObjectValue, was: %T`, clusterConfigAttribute))
	}

	clusterStatAttribute, ok := attributes["cluster_stat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cluster_stat is missing from object`)

		return NewDeviceGatewayStatsValueUnknown(), diags
	}

	clusterStatVal, ok := clusterStatAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cluster_stat expected to be basetypes.ObjectValue, was: %T`, clusterStatAttribute))
	}

	conductorNameAttribute, ok := attributes["conductor_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`conductor_name is missing from object`)

		return NewDeviceGatewayStatsValueUnknown(), diags
	}

	conductorNameVal, ok := conductorNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`conductor_name expected to be basetypes.StringValue, was: %T`, conductorNameAttribute))
	}

	configStatusAttribute, ok := attributes["config_status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`config_status is missing from object`)

		return NewDeviceGatewayStatsValueUnknown(), diags
	}

	configStatusVal, ok := configStatusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`config_status expected to be basetypes.StringValue, was: %T`, configStatusAttribute))
	}

	cpu2StatAttribute, ok := attributes["cpu2_stat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cpu2_stat is missing from object`)

		return NewDeviceGatewayStatsValueUnknown(), diags
	}

	cpu2StatVal, ok := cpu2StatAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cpu2_stat expected to be basetypes.ObjectValue, was: %T`, cpu2StatAttribute))
	}

	cpuStatAttribute, ok := attributes["cpu_stat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cpu_stat is missing from object`)

		return NewDeviceGatewayStatsValueUnknown(), diags
	}

	cpuStatVal, ok := cpuStatAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cpu_stat expected to be basetypes.ObjectValue, was: %T`, cpuStatAttribute))
	}

	createdTimeAttribute, ok := attributes["created_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_time is missing from object`)

		return NewDeviceGatewayStatsValueUnknown(), diags
	}

	createdTimeVal, ok := createdTimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_time expected to be basetypes.Int64Value, was: %T`, createdTimeAttribute))
	}

	deviceprofileIdAttribute, ok := attributes["deviceprofile_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`deviceprofile_id is missing from object`)

		return NewDeviceGatewayStatsValueUnknown(), diags
	}

	deviceprofileIdVal, ok := deviceprofileIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`deviceprofile_id expected to be basetypes.StringValue, was: %T`, deviceprofileIdAttribute))
	}

	dhcpd2StatAttribute, ok := attributes["dhcpd2_stat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dhcpd2_stat is missing from object`)

		return NewDeviceGatewayStatsValueUnknown(), diags
	}

	dhcpd2StatVal, ok := dhcpd2StatAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dhcpd2_stat expected to be basetypes.MapValue, was: %T`, dhcpd2StatAttribute))
	}

	dhcpdStatAttribute, ok := attributes["dhcpd_stat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dhcpd_stat is missing from object`)

		return NewDeviceGatewayStatsValueUnknown(), diags
	}

	dhcpdStatVal, ok := dhcpdStatAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dhcpd_stat expected to be basetypes.MapValue, was: %T`, dhcpdStatAttribute))
	}

	extIpAttribute, ok := attributes["ext_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ext_ip is missing from object`)

		return NewDeviceGatewayStatsValueUnknown(), diags
	}

	extIpVal, ok := extIpAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ext_ip expected to be basetypes.StringValue, was: %T`, extIpAttribute))
	}

	fwupdateAttribute, ok := attributes["fwupdate"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fwupdate is missing from object`)

		return NewDeviceGatewayStatsValueUnknown(), diags
	}

	fwupdateVal, ok := fwupdateAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fwupdate expected to be basetypes.ObjectValue, was: %T`, fwupdateAttribute))
	}

	hasPcapAttribute, ok := attributes["has_pcap"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`has_pcap is missing from object`)

		return NewDeviceGatewayStatsValueUnknown(), diags
	}

	hasPcapVal, ok := hasPcapAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`has_pcap expected to be basetypes.BoolValue, was: %T`, hasPcapAttribute))
	}

	hostnameAttribute, ok := attributes["hostname"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`hostname is missing from object`)

		return NewDeviceGatewayStatsValueUnknown(), diags
	}

	hostnameVal, ok := hostnameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`hostname expected to be basetypes.StringValue, was: %T`, hostnameAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewDeviceGatewayStatsValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	if2StatAttribute, ok := attributes["if2_stat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`if2_stat is missing from object`)

		return NewDeviceGatewayStatsValueUnknown(), diags
	}

	if2StatVal, ok := if2StatAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`if2_stat expected to be basetypes.MapValue, was: %T`, if2StatAttribute))
	}

	ifStatAttribute, ok := attributes["if_stat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`if_stat is missing from object`)

		return NewDeviceGatewayStatsValueUnknown(), diags
	}

	ifStatVal, ok := ifStatAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`if_stat expected to be basetypes.MapValue, was: %T`, ifStatAttribute))
	}

	ipAttribute, ok := attributes["ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip is missing from object`)

		return NewDeviceGatewayStatsValueUnknown(), diags
	}

	ipVal, ok := ipAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip expected to be basetypes.StringValue, was: %T`, ipAttribute))
	}

	ip2StatAttribute, ok := attributes["ip2_stat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip2_stat is missing from object`)

		return NewDeviceGatewayStatsValueUnknown(), diags
	}

	ip2StatVal, ok := ip2StatAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip2_stat expected to be basetypes.ObjectValue, was: %T`, ip2StatAttribute))
	}

	ipStatAttribute, ok := attributes["ip_stat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_stat is missing from object`)

		return NewDeviceGatewayStatsValueUnknown(), diags
	}

	ipStatVal, ok := ipStatAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_stat expected to be basetypes.ObjectValue, was: %T`, ipStatAttribute))
	}

	isHaAttribute, ok := attributes["is_ha"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`is_ha is missing from object`)

		return NewDeviceGatewayStatsValueUnknown(), diags
	}

	isHaVal, ok := isHaAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`is_ha expected to be basetypes.BoolValue, was: %T`, isHaAttribute))
	}

	lastSeenAttribute, ok := attributes["last_seen"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`last_seen is missing from object`)

		return NewDeviceGatewayStatsValueUnknown(), diags
	}

	lastSeenVal, ok := lastSeenAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`last_seen expected to be basetypes.NumberValue, was: %T`, lastSeenAttribute))
	}

	macAttribute, ok := attributes["mac"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mac is missing from object`)

		return NewDeviceGatewayStatsValueUnknown(), diags
	}

	macVal, ok := macAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mac expected to be basetypes.StringValue, was: %T`, macAttribute))
	}

	mapIdAttribute, ok := attributes["map_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`map_id is missing from object`)

		return NewDeviceGatewayStatsValueUnknown(), diags
	}

	mapIdVal, ok := mapIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`map_id expected to be basetypes.StringValue, was: %T`, mapIdAttribute))
	}

	memory2StatAttribute, ok := attributes["memory2_stat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`memory2_stat is missing from object`)

		return NewDeviceGatewayStatsValueUnknown(), diags
	}

	memory2StatVal, ok := memory2StatAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`memory2_stat expected to be basetypes.ObjectValue, was: %T`, memory2StatAttribute))
	}

	memoryStatAttribute, ok := attributes["memory_stat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`memory_stat is missing from object`)

		return NewDeviceGatewayStatsValueUnknown(), diags
	}

	memoryStatVal, ok := memoryStatAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`memory_stat expected to be basetypes.ObjectValue, was: %T`, memoryStatAttribute))
	}

	modelAttribute, ok := attributes["model"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`model is missing from object`)

		return NewDeviceGatewayStatsValueUnknown(), diags
	}

	modelVal, ok := modelAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`model expected to be basetypes.StringValue, was: %T`, modelAttribute))
	}

	modifiedTimeAttribute, ok := attributes["modified_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`modified_time is missing from object`)

		return NewDeviceGatewayStatsValueUnknown(), diags
	}

	modifiedTimeVal, ok := modifiedTimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`modified_time expected to be basetypes.Int64Value, was: %T`, modifiedTimeAttribute))
	}

	module2StatAttribute, ok := attributes["module2_stat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`module2_stat is missing from object`)

		return NewDeviceGatewayStatsValueUnknown(), diags
	}

	module2StatVal, ok := module2StatAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`module2_stat expected to be basetypes.ListValue, was: %T`, module2StatAttribute))
	}

	moduleStatAttribute, ok := attributes["module_stat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`module_stat is missing from object`)

		return NewDeviceGatewayStatsValueUnknown(), diags
	}

	moduleStatVal, ok := moduleStatAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`module_stat expected to be basetypes.ListValue, was: %T`, moduleStatAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewDeviceGatewayStatsValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	nodeNameAttribute, ok := attributes["node_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node_name is missing from object`)

		return NewDeviceGatewayStatsValueUnknown(), diags
	}

	nodeNameVal, ok := nodeNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node_name expected to be basetypes.StringValue, was: %T`, nodeNameAttribute))
	}

	orgIdAttribute, ok := attributes["org_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`org_id is missing from object`)

		return NewDeviceGatewayStatsValueUnknown(), diags
	}

	orgIdVal, ok := orgIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`org_id expected to be basetypes.StringValue, was: %T`, orgIdAttribute))
	}

	routeSummaryStatsAttribute, ok := attributes["route_summary_stats"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`route_summary_stats is missing from object`)

		return NewDeviceGatewayStatsValueUnknown(), diags
	}

	routeSummaryStatsVal, ok := routeSummaryStatsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`route_summary_stats expected to be basetypes.ObjectValue, was: %T`, routeSummaryStatsAttribute))
	}

	routerNameAttribute, ok := attributes["router_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`router_name is missing from object`)

		return NewDeviceGatewayStatsValueUnknown(), diags
	}

	routerNameVal, ok := routerNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`router_name expected to be basetypes.StringValue, was: %T`, routerNameAttribute))
	}

	serialAttribute, ok := attributes["serial"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`serial is missing from object`)

		return NewDeviceGatewayStatsValueUnknown(), diags
	}

	serialVal, ok := serialAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`serial expected to be basetypes.StringValue, was: %T`, serialAttribute))
	}

	service2StatAttribute, ok := attributes["service2_stat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`service2_stat is missing from object`)

		return NewDeviceGatewayStatsValueUnknown(), diags
	}

	service2StatVal, ok := service2StatAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`service2_stat expected to be basetypes.MapValue, was: %T`, service2StatAttribute))
	}

	serviceStatAttribute, ok := attributes["service_stat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`service_stat is missing from object`)

		return NewDeviceGatewayStatsValueUnknown(), diags
	}

	serviceStatVal, ok := serviceStatAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`service_stat expected to be basetypes.MapValue, was: %T`, serviceStatAttribute))
	}

	serviceStatusAttribute, ok := attributes["service_status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`service_status is missing from object`)

		return NewDeviceGatewayStatsValueUnknown(), diags
	}

	serviceStatusVal, ok := serviceStatusAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`service_status expected to be basetypes.ObjectValue, was: %T`, serviceStatusAttribute))
	}

	siteIdAttribute, ok := attributes["site_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`site_id is missing from object`)

		return NewDeviceGatewayStatsValueUnknown(), diags
	}

	siteIdVal, ok := siteIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`site_id expected to be basetypes.StringValue, was: %T`, siteIdAttribute))
	}

	spu2StatAttribute, ok := attributes["spu2_stat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`spu2_stat is missing from object`)

		return NewDeviceGatewayStatsValueUnknown(), diags
	}

	spu2StatVal, ok := spu2StatAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`spu2_stat expected to be basetypes.ListValue, was: %T`, spu2StatAttribute))
	}

	spuStatAttribute, ok := attributes["spu_stat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`spu_stat is missing from object`)

		return NewDeviceGatewayStatsValueUnknown(), diags
	}

	spuStatVal, ok := spuStatAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`spu_stat expected to be basetypes.ListValue, was: %T`, spuStatAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return NewDeviceGatewayStatsValueUnknown(), diags
	}

	statusVal, ok := statusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be basetypes.StringValue, was: %T`, statusAttribute))
	}

	uptimeAttribute, ok := attributes["uptime"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uptime is missing from object`)

		return NewDeviceGatewayStatsValueUnknown(), diags
	}

	uptimeVal, ok := uptimeAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uptime expected to be basetypes.NumberValue, was: %T`, uptimeAttribute))
	}

	versionAttribute, ok := attributes["version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`version is missing from object`)

		return NewDeviceGatewayStatsValueUnknown(), diags
	}

	versionVal, ok := versionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`version expected to be basetypes.StringValue, was: %T`, versionAttribute))
	}

	if diags.HasError() {
		return NewDeviceGatewayStatsValueUnknown(), diags
	}

	return DeviceGatewayStatsValue{
		ApRedundancy:      apRedundancyVal,
		ArpTableStats:     arpTableStatsVal,
		CertExpiry:        certExpiryVal,
		ClusterConfig:     clusterConfigVal,
		ClusterStat:       clusterStatVal,
		ConductorName:     conductorNameVal,
		ConfigStatus:      configStatusVal,
		Cpu2Stat:          cpu2StatVal,
		CpuStat:           cpuStatVal,
		CreatedTime:       createdTimeVal,
		DeviceprofileId:   deviceprofileIdVal,
		Dhcpd2Stat:        dhcpd2StatVal,
		DhcpdStat:         dhcpdStatVal,
		ExtIp:             extIpVal,
		Fwupdate:          fwupdateVal,
		HasPcap:           hasPcapVal,
		Hostname:          hostnameVal,
		Id:                idVal,
		If2Stat:           if2StatVal,
		IfStat:            ifStatVal,
		Ip:                ipVal,
		Ip2Stat:           ip2StatVal,
		IpStat:            ipStatVal,
		IsHa:              isHaVal,
		LastSeen:          lastSeenVal,
		Mac:               macVal,
		MapId:             mapIdVal,
		Memory2Stat:       memory2StatVal,
		MemoryStat:        memoryStatVal,
		Model:             modelVal,
		ModifiedTime:      modifiedTimeVal,
		Module2Stat:       module2StatVal,
		ModuleStat:        moduleStatVal,
		Name:              nameVal,
		NodeName:          nodeNameVal,
		OrgId:             orgIdVal,
		RouteSummaryStats: routeSummaryStatsVal,
		RouterName:        routerNameVal,
		Serial:            serialVal,
		Service2Stat:      service2StatVal,
		ServiceStat:       serviceStatVal,
		ServiceStatus:     serviceStatusVal,
		SiteId:            siteIdVal,
		Spu2Stat:          spu2StatVal,
		SpuStat:           spuStatVal,
		Status:            statusVal,
		Uptime:            uptimeVal,
		Version:           versionVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewDeviceGatewayStatsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) DeviceGatewayStatsValue {
	object, diags := NewDeviceGatewayStatsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewDeviceGatewayStatsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t DeviceGatewayStatsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewDeviceGatewayStatsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewDeviceGatewayStatsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewDeviceGatewayStatsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewDeviceGatewayStatsValueMust(DeviceGatewayStatsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t DeviceGatewayStatsType) ValueType(ctx context.Context) attr.Value {
	return DeviceGatewayStatsValue{}
}

var _ basetypes.ObjectValuable = DeviceGatewayStatsValue{}

type DeviceGatewayStatsValue struct {
	ApRedundancy      basetypes.ObjectValue `tfsdk:"ap_redundancy"`
	ArpTableStats     basetypes.ObjectValue `tfsdk:"arp_table_stats"`
	CertExpiry        basetypes.Int64Value  `tfsdk:"cert_expiry"`
	ClusterConfig     basetypes.ObjectValue `tfsdk:"cluster_config"`
	ClusterStat       basetypes.ObjectValue `tfsdk:"cluster_stat"`
	ConductorName     basetypes.StringValue `tfsdk:"conductor_name"`
	ConfigStatus      basetypes.StringValue `tfsdk:"config_status"`
	Cpu2Stat          basetypes.ObjectValue `tfsdk:"cpu2_stat"`
	CpuStat           basetypes.ObjectValue `tfsdk:"cpu_stat"`
	CreatedTime       basetypes.Int64Value  `tfsdk:"created_time"`
	DeviceprofileId   basetypes.StringValue `tfsdk:"deviceprofile_id"`
	Dhcpd2Stat        basetypes.MapValue    `tfsdk:"dhcpd2_stat"`
	DhcpdStat         basetypes.MapValue    `tfsdk:"dhcpd_stat"`
	ExtIp             basetypes.StringValue `tfsdk:"ext_ip"`
	Fwupdate          basetypes.ObjectValue `tfsdk:"fwupdate"`
	HasPcap           basetypes.BoolValue   `tfsdk:"has_pcap"`
	Hostname          basetypes.StringValue `tfsdk:"hostname"`
	Id                basetypes.StringValue `tfsdk:"id"`
	If2Stat           basetypes.MapValue    `tfsdk:"if2_stat"`
	IfStat            basetypes.MapValue    `tfsdk:"if_stat"`
	Ip                basetypes.StringValue `tfsdk:"ip"`
	Ip2Stat           basetypes.ObjectValue `tfsdk:"ip2_stat"`
	IpStat            basetypes.ObjectValue `tfsdk:"ip_stat"`
	IsHa              basetypes.BoolValue   `tfsdk:"is_ha"`
	LastSeen          basetypes.NumberValue `tfsdk:"last_seen"`
	Mac               basetypes.StringValue `tfsdk:"mac"`
	MapId             basetypes.StringValue `tfsdk:"map_id"`
	Memory2Stat       basetypes.ObjectValue `tfsdk:"memory2_stat"`
	MemoryStat        basetypes.ObjectValue `tfsdk:"memory_stat"`
	Model             basetypes.StringValue `tfsdk:"model"`
	ModifiedTime      basetypes.Int64Value  `tfsdk:"modified_time"`
	Module2Stat       basetypes.ListValue   `tfsdk:"module2_stat"`
	ModuleStat        basetypes.ListValue   `tfsdk:"module_stat"`
	Name              basetypes.StringValue `tfsdk:"name"`
	NodeName          basetypes.StringValue `tfsdk:"node_name"`
	OrgId             basetypes.StringValue `tfsdk:"org_id"`
	RouteSummaryStats basetypes.ObjectValue `tfsdk:"route_summary_stats"`
	RouterName        basetypes.StringValue `tfsdk:"router_name"`
	Serial            basetypes.StringValue `tfsdk:"serial"`
	Service2Stat      basetypes.MapValue    `tfsdk:"service2_stat"`
	ServiceStat       basetypes.MapValue    `tfsdk:"service_stat"`
	ServiceStatus     basetypes.ObjectValue `tfsdk:"service_status"`
	SiteId            basetypes.StringValue `tfsdk:"site_id"`
	Spu2Stat          basetypes.ListValue   `tfsdk:"spu2_stat"`
	SpuStat           basetypes.ListValue   `tfsdk:"spu_stat"`
	Status            basetypes.StringValue `tfsdk:"status"`
	Uptime            basetypes.NumberValue `tfsdk:"uptime"`
	Version           basetypes.StringValue `tfsdk:"version"`
	state             attr.ValueState
}

func (v DeviceGatewayStatsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 48)

	var val tftypes.Value
	var err error

	attrTypes["ap_redundancy"] = basetypes.ObjectType{
		AttrTypes: ApRedundancyValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["arp_table_stats"] = basetypes.ObjectType{
		AttrTypes: ArpTableStatsValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["cert_expiry"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["cluster_config"] = basetypes.ObjectType{
		AttrTypes: ClusterConfigValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["cluster_stat"] = basetypes.ObjectType{
		AttrTypes: ClusterStatValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["conductor_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["config_status"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["cpu2_stat"] = basetypes.ObjectType{
		AttrTypes: CpuStatValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["cpu_stat"] = basetypes.ObjectType{
		AttrTypes: CpuStatValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["created_time"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["deviceprofile_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["dhcpd2_stat"] = basetypes.MapType{
		ElemType: DhcpdStatValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["dhcpd_stat"] = basetypes.MapType{
		ElemType: DhcpdStatValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["ext_ip"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["fwupdate"] = basetypes.ObjectType{
		AttrTypes: FwupdateValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["has_pcap"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["hostname"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["if2_stat"] = basetypes.MapType{
		ElemType: IfStatValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["if_stat"] = basetypes.MapType{
		ElemType: IfStatValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["ip"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ip2_stat"] = basetypes.ObjectType{
		AttrTypes: IpStatValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["ip_stat"] = basetypes.ObjectType{
		AttrTypes: IpStatValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["is_ha"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["last_seen"] = basetypes.NumberType{}.TerraformType(ctx)
	attrTypes["mac"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["map_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["memory2_stat"] = basetypes.ObjectType{
		AttrTypes: MemoryStatValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["memory_stat"] = basetypes.ObjectType{
		AttrTypes: MemoryStatValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["model"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["modified_time"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["module2_stat"] = basetypes.ListType{
		ElemType: ModuleStatValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["module_stat"] = basetypes.ListType{
		ElemType: ModuleStatValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["node_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["org_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["route_summary_stats"] = basetypes.ObjectType{
		AttrTypes: RouteSummaryStatsValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["router_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["serial"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["service2_stat"] = basetypes.MapType{
		ElemType: ServiceStatValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["service_stat"] = basetypes.MapType{
		ElemType: ServiceStatValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["service_status"] = basetypes.ObjectType{
		AttrTypes: ServiceStatusValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["site_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["spu2_stat"] = basetypes.ListType{
		ElemType: SpuStatValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["spu_stat"] = basetypes.ListType{
		ElemType: SpuStatValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["status"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["uptime"] = basetypes.NumberType{}.TerraformType(ctx)
	attrTypes["version"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 48)

		val, err = v.ApRedundancy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ap_redundancy"] = val

		val, err = v.ArpTableStats.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["arp_table_stats"] = val

		val, err = v.CertExpiry.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cert_expiry"] = val

		val, err = v.ClusterConfig.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cluster_config"] = val

		val, err = v.ClusterStat.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cluster_stat"] = val

		val, err = v.ConductorName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["conductor_name"] = val

		val, err = v.ConfigStatus.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["config_status"] = val

		val, err = v.Cpu2Stat.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cpu2_stat"] = val

		val, err = v.CpuStat.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cpu_stat"] = val

		val, err = v.CreatedTime.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["created_time"] = val

		val, err = v.DeviceprofileId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["deviceprofile_id"] = val

		val, err = v.Dhcpd2Stat.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dhcpd2_stat"] = val

		val, err = v.DhcpdStat.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dhcpd_stat"] = val

		val, err = v.ExtIp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ext_ip"] = val

		val, err = v.Fwupdate.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["fwupdate"] = val

		val, err = v.HasPcap.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["has_pcap"] = val

		val, err = v.Hostname.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["hostname"] = val

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.If2Stat.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["if2_stat"] = val

		val, err = v.IfStat.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["if_stat"] = val

		val, err = v.Ip.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip"] = val

		val, err = v.Ip2Stat.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip2_stat"] = val

		val, err = v.IpStat.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip_stat"] = val

		val, err = v.IsHa.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["is_ha"] = val

		val, err = v.LastSeen.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["last_seen"] = val

		val, err = v.Mac.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mac"] = val

		val, err = v.MapId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["map_id"] = val

		val, err = v.Memory2Stat.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["memory2_stat"] = val

		val, err = v.MemoryStat.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["memory_stat"] = val

		val, err = v.Model.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["model"] = val

		val, err = v.ModifiedTime.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["modified_time"] = val

		val, err = v.Module2Stat.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["module2_stat"] = val

		val, err = v.ModuleStat.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["module_stat"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.NodeName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["node_name"] = val

		val, err = v.OrgId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["org_id"] = val

		val, err = v.RouteSummaryStats.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["route_summary_stats"] = val

		val, err = v.RouterName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["router_name"] = val

		val, err = v.Serial.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["serial"] = val

		val, err = v.Service2Stat.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["service2_stat"] = val

		val, err = v.ServiceStat.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["service_stat"] = val

		val, err = v.ServiceStatus.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["service_status"] = val

		val, err = v.SiteId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["site_id"] = val

		val, err = v.Spu2Stat.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["spu2_stat"] = val

		val, err = v.SpuStat.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["spu_stat"] = val

		val, err = v.Status.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["status"] = val

		val, err = v.Uptime.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["uptime"] = val

		val, err = v.Version.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["version"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v DeviceGatewayStatsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v DeviceGatewayStatsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v DeviceGatewayStatsValue) String() string {
	return "DeviceGatewayStatsValue"
}

func (v DeviceGatewayStatsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var apRedundancy basetypes.ObjectValue

	if v.ApRedundancy.IsNull() {
		apRedundancy = types.ObjectNull(
			ApRedundancyValue{}.AttributeTypes(ctx),
		)
	}

	if v.ApRedundancy.IsUnknown() {
		apRedundancy = types.ObjectUnknown(
			ApRedundancyValue{}.AttributeTypes(ctx),
		)
	}

	if !v.ApRedundancy.IsNull() && !v.ApRedundancy.IsUnknown() {
		apRedundancy = types.ObjectValueMust(
			ApRedundancyValue{}.AttributeTypes(ctx),
			v.ApRedundancy.Attributes(),
		)
	}

	var arpTableStats basetypes.ObjectValue

	if v.ArpTableStats.IsNull() {
		arpTableStats = types.ObjectNull(
			ArpTableStatsValue{}.AttributeTypes(ctx),
		)
	}

	if v.ArpTableStats.IsUnknown() {
		arpTableStats = types.ObjectUnknown(
			ArpTableStatsValue{}.AttributeTypes(ctx),
		)
	}

	if !v.ArpTableStats.IsNull() && !v.ArpTableStats.IsUnknown() {
		arpTableStats = types.ObjectValueMust(
			ArpTableStatsValue{}.AttributeTypes(ctx),
			v.ArpTableStats.Attributes(),
		)
	}

	var clusterConfig basetypes.ObjectValue

	if v.ClusterConfig.IsNull() {
		clusterConfig = types.ObjectNull(
			ClusterConfigValue{}.AttributeTypes(ctx),
		)
	}

	if v.ClusterConfig.IsUnknown() {
		clusterConfig = types.ObjectUnknown(
			ClusterConfigValue{}.AttributeTypes(ctx),
		)
	}

	if !v.ClusterConfig.IsNull() && !v.ClusterConfig.IsUnknown() {
		clusterConfig = types.ObjectValueMust(
			ClusterConfigValue{}.AttributeTypes(ctx),
			v.ClusterConfig.Attributes(),
		)
	}

	var clusterStat basetypes.ObjectValue

	if v.ClusterStat.IsNull() {
		clusterStat = types.ObjectNull(
			ClusterStatValue{}.AttributeTypes(ctx),
		)
	}

	if v.ClusterStat.IsUnknown() {
		clusterStat = types.ObjectUnknown(
			ClusterStatValue{}.AttributeTypes(ctx),
		)
	}

	if !v.ClusterStat.IsNull() && !v.ClusterStat.IsUnknown() {
		clusterStat = types.ObjectValueMust(
			ClusterStatValue{}.AttributeTypes(ctx),
			v.ClusterStat.Attributes(),
		)
	}

	var cpu2Stat basetypes.ObjectValue

	if v.Cpu2Stat.IsNull() {
		cpu2Stat = types.ObjectNull(
			CpuStatValue{}.AttributeTypes(ctx),
		)
	}

	if v.Cpu2Stat.IsUnknown() {
		cpu2Stat = types.ObjectUnknown(
			CpuStatValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Cpu2Stat.IsNull() && !v.Cpu2Stat.IsUnknown() {
		cpu2Stat = types.ObjectValueMust(
			CpuStatValue{}.AttributeTypes(ctx),
			v.Cpu2Stat.Attributes(),
		)
	}

	var cpuStat basetypes.ObjectValue

	if v.CpuStat.IsNull() {
		cpuStat = types.ObjectNull(
			CpuStatValue{}.AttributeTypes(ctx),
		)
	}

	if v.CpuStat.IsUnknown() {
		cpuStat = types.ObjectUnknown(
			CpuStatValue{}.AttributeTypes(ctx),
		)
	}

	if !v.CpuStat.IsNull() && !v.CpuStat.IsUnknown() {
		cpuStat = types.ObjectValueMust(
			CpuStatValue{}.AttributeTypes(ctx),
			v.CpuStat.Attributes(),
		)
	}

	dhcpd2Stat := types.MapValueMust(
		DhcpdStatType{
			basetypes.ObjectType{
				AttrTypes: DhcpdStatValue{}.AttributeTypes(ctx),
			},
		},
		v.Dhcpd2Stat.Elements(),
	)

	if v.Dhcpd2Stat.IsNull() {
		dhcpd2Stat = types.MapNull(
			DhcpdStatType{
				basetypes.ObjectType{
					AttrTypes: DhcpdStatValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Dhcpd2Stat.IsUnknown() {
		dhcpd2Stat = types.MapUnknown(
			DhcpdStatType{
				basetypes.ObjectType{
					AttrTypes: DhcpdStatValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	dhcpdStat := types.MapValueMust(
		DhcpdStatType{
			basetypes.ObjectType{
				AttrTypes: DhcpdStatValue{}.AttributeTypes(ctx),
			},
		},
		v.DhcpdStat.Elements(),
	)

	if v.DhcpdStat.IsNull() {
		dhcpdStat = types.MapNull(
			DhcpdStatType{
				basetypes.ObjectType{
					AttrTypes: DhcpdStatValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.DhcpdStat.IsUnknown() {
		dhcpdStat = types.MapUnknown(
			DhcpdStatType{
				basetypes.ObjectType{
					AttrTypes: DhcpdStatValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var fwupdate basetypes.ObjectValue

	if v.Fwupdate.IsNull() {
		fwupdate = types.ObjectNull(
			FwupdateValue{}.AttributeTypes(ctx),
		)
	}

	if v.Fwupdate.IsUnknown() {
		fwupdate = types.ObjectUnknown(
			FwupdateValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Fwupdate.IsNull() && !v.Fwupdate.IsUnknown() {
		fwupdate = types.ObjectValueMust(
			FwupdateValue{}.AttributeTypes(ctx),
			v.Fwupdate.Attributes(),
		)
	}

	if2Stat := types.MapValueMust(
		IfStatType{
			basetypes.ObjectType{
				AttrTypes: IfStatValue{}.AttributeTypes(ctx),
			},
		},
		v.If2Stat.Elements(),
	)

	if v.If2Stat.IsNull() {
		if2Stat = types.MapNull(
			IfStatType{
				basetypes.ObjectType{
					AttrTypes: IfStatValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.If2Stat.IsUnknown() {
		if2Stat = types.MapUnknown(
			IfStatType{
				basetypes.ObjectType{
					AttrTypes: IfStatValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	ifStat := types.MapValueMust(
		IfStatType{
			basetypes.ObjectType{
				AttrTypes: IfStatValue{}.AttributeTypes(ctx),
			},
		},
		v.IfStat.Elements(),
	)

	if v.IfStat.IsNull() {
		ifStat = types.MapNull(
			IfStatType{
				basetypes.ObjectType{
					AttrTypes: IfStatValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.IfStat.IsUnknown() {
		ifStat = types.MapUnknown(
			IfStatType{
				basetypes.ObjectType{
					AttrTypes: IfStatValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var ip2Stat basetypes.ObjectValue

	if v.Ip2Stat.IsNull() {
		ip2Stat = types.ObjectNull(
			IpStatValue{}.AttributeTypes(ctx),
		)
	}

	if v.Ip2Stat.IsUnknown() {
		ip2Stat = types.ObjectUnknown(
			IpStatValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Ip2Stat.IsNull() && !v.Ip2Stat.IsUnknown() {
		ip2Stat = types.ObjectValueMust(
			IpStatValue{}.AttributeTypes(ctx),
			v.Ip2Stat.Attributes(),
		)
	}

	var ipStat basetypes.ObjectValue

	if v.IpStat.IsNull() {
		ipStat = types.ObjectNull(
			IpStatValue{}.AttributeTypes(ctx),
		)
	}

	if v.IpStat.IsUnknown() {
		ipStat = types.ObjectUnknown(
			IpStatValue{}.AttributeTypes(ctx),
		)
	}

	if !v.IpStat.IsNull() && !v.IpStat.IsUnknown() {
		ipStat = types.ObjectValueMust(
			IpStatValue{}.AttributeTypes(ctx),
			v.IpStat.Attributes(),
		)
	}

	var memory2Stat basetypes.ObjectValue

	if v.Memory2Stat.IsNull() {
		memory2Stat = types.ObjectNull(
			MemoryStatValue{}.AttributeTypes(ctx),
		)
	}

	if v.Memory2Stat.IsUnknown() {
		memory2Stat = types.ObjectUnknown(
			MemoryStatValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Memory2Stat.IsNull() && !v.Memory2Stat.IsUnknown() {
		memory2Stat = types.ObjectValueMust(
			MemoryStatValue{}.AttributeTypes(ctx),
			v.Memory2Stat.Attributes(),
		)
	}

	var memoryStat basetypes.ObjectValue

	if v.MemoryStat.IsNull() {
		memoryStat = types.ObjectNull(
			MemoryStatValue{}.AttributeTypes(ctx),
		)
	}

	if v.MemoryStat.IsUnknown() {
		memoryStat = types.ObjectUnknown(
			MemoryStatValue{}.AttributeTypes(ctx),
		)
	}

	if !v.MemoryStat.IsNull() && !v.MemoryStat.IsUnknown() {
		memoryStat = types.ObjectValueMust(
			MemoryStatValue{}.AttributeTypes(ctx),
			v.MemoryStat.Attributes(),
		)
	}

	module2Stat := types.ListValueMust(
		ModuleStatType{
			basetypes.ObjectType{
				AttrTypes: ModuleStatValue{}.AttributeTypes(ctx),
			},
		},
		v.Module2Stat.Elements(),
	)

	if v.Module2Stat.IsNull() {
		module2Stat = types.ListNull(
			ModuleStatType{
				basetypes.ObjectType{
					AttrTypes: ModuleStatValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Module2Stat.IsUnknown() {
		module2Stat = types.ListUnknown(
			ModuleStatType{
				basetypes.ObjectType{
					AttrTypes: ModuleStatValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	moduleStat := types.ListValueMust(
		ModuleStatType{
			basetypes.ObjectType{
				AttrTypes: ModuleStatValue{}.AttributeTypes(ctx),
			},
		},
		v.ModuleStat.Elements(),
	)

	if v.ModuleStat.IsNull() {
		moduleStat = types.ListNull(
			ModuleStatType{
				basetypes.ObjectType{
					AttrTypes: ModuleStatValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.ModuleStat.IsUnknown() {
		moduleStat = types.ListUnknown(
			ModuleStatType{
				basetypes.ObjectType{
					AttrTypes: ModuleStatValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var routeSummaryStats basetypes.ObjectValue

	if v.RouteSummaryStats.IsNull() {
		routeSummaryStats = types.ObjectNull(
			RouteSummaryStatsValue{}.AttributeTypes(ctx),
		)
	}

	if v.RouteSummaryStats.IsUnknown() {
		routeSummaryStats = types.ObjectUnknown(
			RouteSummaryStatsValue{}.AttributeTypes(ctx),
		)
	}

	if !v.RouteSummaryStats.IsNull() && !v.RouteSummaryStats.IsUnknown() {
		routeSummaryStats = types.ObjectValueMust(
			RouteSummaryStatsValue{}.AttributeTypes(ctx),
			v.RouteSummaryStats.Attributes(),
		)
	}

	service2Stat := types.MapValueMust(
		ServiceStatType{
			basetypes.ObjectType{
				AttrTypes: ServiceStatValue{}.AttributeTypes(ctx),
			},
		},
		v.Service2Stat.Elements(),
	)

	if v.Service2Stat.IsNull() {
		service2Stat = types.MapNull(
			ServiceStatType{
				basetypes.ObjectType{
					AttrTypes: ServiceStatValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Service2Stat.IsUnknown() {
		service2Stat = types.MapUnknown(
			ServiceStatType{
				basetypes.ObjectType{
					AttrTypes: ServiceStatValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	serviceStat := types.MapValueMust(
		ServiceStatType{
			basetypes.ObjectType{
				AttrTypes: ServiceStatValue{}.AttributeTypes(ctx),
			},
		},
		v.ServiceStat.Elements(),
	)

	if v.ServiceStat.IsNull() {
		serviceStat = types.MapNull(
			ServiceStatType{
				basetypes.ObjectType{
					AttrTypes: ServiceStatValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.ServiceStat.IsUnknown() {
		serviceStat = types.MapUnknown(
			ServiceStatType{
				basetypes.ObjectType{
					AttrTypes: ServiceStatValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var serviceStatus basetypes.ObjectValue

	if v.ServiceStatus.IsNull() {
		serviceStatus = types.ObjectNull(
			ServiceStatusValue{}.AttributeTypes(ctx),
		)
	}

	if v.ServiceStatus.IsUnknown() {
		serviceStatus = types.ObjectUnknown(
			ServiceStatusValue{}.AttributeTypes(ctx),
		)
	}

	if !v.ServiceStatus.IsNull() && !v.ServiceStatus.IsUnknown() {
		serviceStatus = types.ObjectValueMust(
			ServiceStatusValue{}.AttributeTypes(ctx),
			v.ServiceStatus.Attributes(),
		)
	}

	spu2Stat := types.ListValueMust(
		SpuStatType{
			basetypes.ObjectType{
				AttrTypes: SpuStatValue{}.AttributeTypes(ctx),
			},
		},
		v.Spu2Stat.Elements(),
	)

	if v.Spu2Stat.IsNull() {
		spu2Stat = types.ListNull(
			SpuStatType{
				basetypes.ObjectType{
					AttrTypes: SpuStatValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Spu2Stat.IsUnknown() {
		spu2Stat = types.ListUnknown(
			SpuStatType{
				basetypes.ObjectType{
					AttrTypes: SpuStatValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	spuStat := types.ListValueMust(
		SpuStatType{
			basetypes.ObjectType{
				AttrTypes: SpuStatValue{}.AttributeTypes(ctx),
			},
		},
		v.SpuStat.Elements(),
	)

	if v.SpuStat.IsNull() {
		spuStat = types.ListNull(
			SpuStatType{
				basetypes.ObjectType{
					AttrTypes: SpuStatValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.SpuStat.IsUnknown() {
		spuStat = types.ListUnknown(
			SpuStatType{
				basetypes.ObjectType{
					AttrTypes: SpuStatValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"ap_redundancy": basetypes.ObjectType{
			AttrTypes: ApRedundancyValue{}.AttributeTypes(ctx),
		},
		"arp_table_stats": basetypes.ObjectType{
			AttrTypes: ArpTableStatsValue{}.AttributeTypes(ctx),
		},
		"cert_expiry": basetypes.Int64Type{},
		"cluster_config": basetypes.ObjectType{
			AttrTypes: ClusterConfigValue{}.AttributeTypes(ctx),
		},
		"cluster_stat": basetypes.ObjectType{
			AttrTypes: ClusterStatValue{}.AttributeTypes(ctx),
		},
		"conductor_name": basetypes.StringType{},
		"config_status":  basetypes.StringType{},
		"cpu2_stat": basetypes.ObjectType{
			AttrTypes: CpuStatValue{}.AttributeTypes(ctx),
		},
		"cpu_stat": basetypes.ObjectType{
			AttrTypes: CpuStatValue{}.AttributeTypes(ctx),
		},
		"created_time":     basetypes.Int64Type{},
		"deviceprofile_id": basetypes.StringType{},
		"dhcpd2_stat": basetypes.MapType{
			ElemType: DhcpdStatValue{}.Type(ctx),
		},
		"dhcpd_stat": basetypes.MapType{
			ElemType: DhcpdStatValue{}.Type(ctx),
		},
		"ext_ip": basetypes.StringType{},
		"fwupdate": basetypes.ObjectType{
			AttrTypes: FwupdateValue{}.AttributeTypes(ctx),
		},
		"has_pcap": basetypes.BoolType{},
		"hostname": basetypes.StringType{},
		"id":       basetypes.StringType{},
		"if2_stat": basetypes.MapType{
			ElemType: IfStatValue{}.Type(ctx),
		},
		"if_stat": basetypes.MapType{
			ElemType: IfStatValue{}.Type(ctx),
		},
		"ip": basetypes.StringType{},
		"ip2_stat": basetypes.ObjectType{
			AttrTypes: IpStatValue{}.AttributeTypes(ctx),
		},
		"ip_stat": basetypes.ObjectType{
			AttrTypes: IpStatValue{}.AttributeTypes(ctx),
		},
		"is_ha":     basetypes.BoolType{},
		"last_seen": basetypes.NumberType{},
		"mac":       basetypes.StringType{},
		"map_id":    basetypes.StringType{},
		"memory2_stat": basetypes.ObjectType{
			AttrTypes: MemoryStatValue{}.AttributeTypes(ctx),
		},
		"memory_stat": basetypes.ObjectType{
			AttrTypes: MemoryStatValue{}.AttributeTypes(ctx),
		},
		"model":         basetypes.StringType{},
		"modified_time": basetypes.Int64Type{},
		"module2_stat": basetypes.ListType{
			ElemType: ModuleStatValue{}.Type(ctx),
		},
		"module_stat": basetypes.ListType{
			ElemType: ModuleStatValue{}.Type(ctx),
		},
		"name":      basetypes.StringType{},
		"node_name": basetypes.StringType{},
		"org_id":    basetypes.StringType{},
		"route_summary_stats": basetypes.ObjectType{
			AttrTypes: RouteSummaryStatsValue{}.AttributeTypes(ctx),
		},
		"router_name": basetypes.StringType{},
		"serial":      basetypes.StringType{},
		"service2_stat": basetypes.MapType{
			ElemType: ServiceStatValue{}.Type(ctx),
		},
		"service_stat": basetypes.MapType{
			ElemType: ServiceStatValue{}.Type(ctx),
		},
		"service_status": basetypes.ObjectType{
			AttrTypes: ServiceStatusValue{}.AttributeTypes(ctx),
		},
		"site_id": basetypes.StringType{},
		"spu2_stat": basetypes.ListType{
			ElemType: SpuStatValue{}.Type(ctx),
		},
		"spu_stat": basetypes.ListType{
			ElemType: SpuStatValue{}.Type(ctx),
		},
		"status":  basetypes.StringType{},
		"uptime":  basetypes.NumberType{},
		"version": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"ap_redundancy":       apRedundancy,
			"arp_table_stats":     arpTableStats,
			"cert_expiry":         v.CertExpiry,
			"cluster_config":      clusterConfig,
			"cluster_stat":        clusterStat,
			"conductor_name":      v.ConductorName,
			"config_status":       v.ConfigStatus,
			"cpu2_stat":           cpu2Stat,
			"cpu_stat":            cpuStat,
			"created_time":        v.CreatedTime,
			"deviceprofile_id":    v.DeviceprofileId,
			"dhcpd2_stat":         dhcpd2Stat,
			"dhcpd_stat":          dhcpdStat,
			"ext_ip":              v.ExtIp,
			"fwupdate":            fwupdate,
			"has_pcap":            v.HasPcap,
			"hostname":            v.Hostname,
			"id":                  v.Id,
			"if2_stat":            if2Stat,
			"if_stat":             ifStat,
			"ip":                  v.Ip,
			"ip2_stat":            ip2Stat,
			"ip_stat":             ipStat,
			"is_ha":               v.IsHa,
			"last_seen":           v.LastSeen,
			"mac":                 v.Mac,
			"map_id":              v.MapId,
			"memory2_stat":        memory2Stat,
			"memory_stat":         memoryStat,
			"model":               v.Model,
			"modified_time":       v.ModifiedTime,
			"module2_stat":        module2Stat,
			"module_stat":         moduleStat,
			"name":                v.Name,
			"node_name":           v.NodeName,
			"org_id":              v.OrgId,
			"route_summary_stats": routeSummaryStats,
			"router_name":         v.RouterName,
			"serial":              v.Serial,
			"service2_stat":       service2Stat,
			"service_stat":        serviceStat,
			"service_status":      serviceStatus,
			"site_id":             v.SiteId,
			"spu2_stat":           spu2Stat,
			"spu_stat":            spuStat,
			"status":              v.Status,
			"uptime":              v.Uptime,
			"version":             v.Version,
		})

	return objVal, diags
}

func (v DeviceGatewayStatsValue) Equal(o attr.Value) bool {
	other, ok := o.(DeviceGatewayStatsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.ApRedundancy.Equal(other.ApRedundancy) {
		return false
	}

	if !v.ArpTableStats.Equal(other.ArpTableStats) {
		return false
	}

	if !v.CertExpiry.Equal(other.CertExpiry) {
		return false
	}

	if !v.ClusterConfig.Equal(other.ClusterConfig) {
		return false
	}

	if !v.ClusterStat.Equal(other.ClusterStat) {
		return false
	}

	if !v.ConductorName.Equal(other.ConductorName) {
		return false
	}

	if !v.ConfigStatus.Equal(other.ConfigStatus) {
		return false
	}

	if !v.Cpu2Stat.Equal(other.Cpu2Stat) {
		return false
	}

	if !v.CpuStat.Equal(other.CpuStat) {
		return false
	}

	if !v.CreatedTime.Equal(other.CreatedTime) {
		return false
	}

	if !v.DeviceprofileId.Equal(other.DeviceprofileId) {
		return false
	}

	if !v.Dhcpd2Stat.Equal(other.Dhcpd2Stat) {
		return false
	}

	if !v.DhcpdStat.Equal(other.DhcpdStat) {
		return false
	}

	if !v.ExtIp.Equal(other.ExtIp) {
		return false
	}

	if !v.Fwupdate.Equal(other.Fwupdate) {
		return false
	}

	if !v.HasPcap.Equal(other.HasPcap) {
		return false
	}

	if !v.Hostname.Equal(other.Hostname) {
		return false
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.If2Stat.Equal(other.If2Stat) {
		return false
	}

	if !v.IfStat.Equal(other.IfStat) {
		return false
	}

	if !v.Ip.Equal(other.Ip) {
		return false
	}

	if !v.Ip2Stat.Equal(other.Ip2Stat) {
		return false
	}

	if !v.IpStat.Equal(other.IpStat) {
		return false
	}

	if !v.IsHa.Equal(other.IsHa) {
		return false
	}

	if !v.LastSeen.Equal(other.LastSeen) {
		return false
	}

	if !v.Mac.Equal(other.Mac) {
		return false
	}

	if !v.MapId.Equal(other.MapId) {
		return false
	}

	if !v.Memory2Stat.Equal(other.Memory2Stat) {
		return false
	}

	if !v.MemoryStat.Equal(other.MemoryStat) {
		return false
	}

	if !v.Model.Equal(other.Model) {
		return false
	}

	if !v.ModifiedTime.Equal(other.ModifiedTime) {
		return false
	}

	if !v.Module2Stat.Equal(other.Module2Stat) {
		return false
	}

	if !v.ModuleStat.Equal(other.ModuleStat) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.NodeName.Equal(other.NodeName) {
		return false
	}

	if !v.OrgId.Equal(other.OrgId) {
		return false
	}

	if !v.RouteSummaryStats.Equal(other.RouteSummaryStats) {
		return false
	}

	if !v.RouterName.Equal(other.RouterName) {
		return false
	}

	if !v.Serial.Equal(other.Serial) {
		return false
	}

	if !v.Service2Stat.Equal(other.Service2Stat) {
		return false
	}

	if !v.ServiceStat.Equal(other.ServiceStat) {
		return false
	}

	if !v.ServiceStatus.Equal(other.ServiceStatus) {
		return false
	}

	if !v.SiteId.Equal(other.SiteId) {
		return false
	}

	if !v.Spu2Stat.Equal(other.Spu2Stat) {
		return false
	}

	if !v.SpuStat.Equal(other.SpuStat) {
		return false
	}

	if !v.Status.Equal(other.Status) {
		return false
	}

	if !v.Uptime.Equal(other.Uptime) {
		return false
	}

	if !v.Version.Equal(other.Version) {
		return false
	}

	return true
}

func (v DeviceGatewayStatsValue) Type(ctx context.Context) attr.Type {
	return DeviceGatewayStatsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v DeviceGatewayStatsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"ap_redundancy": basetypes.ObjectType{
			AttrTypes: ApRedundancyValue{}.AttributeTypes(ctx),
		},
		"arp_table_stats": basetypes.ObjectType{
			AttrTypes: ArpTableStatsValue{}.AttributeTypes(ctx),
		},
		"cert_expiry": basetypes.Int64Type{},
		"cluster_config": basetypes.ObjectType{
			AttrTypes: ClusterConfigValue{}.AttributeTypes(ctx),
		},
		"cluster_stat": basetypes.ObjectType{
			AttrTypes: ClusterStatValue{}.AttributeTypes(ctx),
		},
		"conductor_name": basetypes.StringType{},
		"config_status":  basetypes.StringType{},
		"cpu2_stat": basetypes.ObjectType{
			AttrTypes: CpuStatValue{}.AttributeTypes(ctx),
		},
		"cpu_stat": basetypes.ObjectType{
			AttrTypes: CpuStatValue{}.AttributeTypes(ctx),
		},
		"created_time":     basetypes.Int64Type{},
		"deviceprofile_id": basetypes.StringType{},
		"dhcpd2_stat": basetypes.MapType{
			ElemType: DhcpdStatValue{}.Type(ctx),
		},
		"dhcpd_stat": basetypes.MapType{
			ElemType: DhcpdStatValue{}.Type(ctx),
		},
		"ext_ip": basetypes.StringType{},
		"fwupdate": basetypes.ObjectType{
			AttrTypes: FwupdateValue{}.AttributeTypes(ctx),
		},
		"has_pcap": basetypes.BoolType{},
		"hostname": basetypes.StringType{},
		"id":       basetypes.StringType{},
		"if2_stat": basetypes.MapType{
			ElemType: IfStatValue{}.Type(ctx),
		},
		"if_stat": basetypes.MapType{
			ElemType: IfStatValue{}.Type(ctx),
		},
		"ip": basetypes.StringType{},
		"ip2_stat": basetypes.ObjectType{
			AttrTypes: IpStatValue{}.AttributeTypes(ctx),
		},
		"ip_stat": basetypes.ObjectType{
			AttrTypes: IpStatValue{}.AttributeTypes(ctx),
		},
		"is_ha":     basetypes.BoolType{},
		"last_seen": basetypes.NumberType{},
		"mac":       basetypes.StringType{},
		"map_id":    basetypes.StringType{},
		"memory2_stat": basetypes.ObjectType{
			AttrTypes: MemoryStatValue{}.AttributeTypes(ctx),
		},
		"memory_stat": basetypes.ObjectType{
			AttrTypes: MemoryStatValue{}.AttributeTypes(ctx),
		},
		"model":         basetypes.StringType{},
		"modified_time": basetypes.Int64Type{},
		"module2_stat": basetypes.ListType{
			ElemType: ModuleStatValue{}.Type(ctx),
		},
		"module_stat": basetypes.ListType{
			ElemType: ModuleStatValue{}.Type(ctx),
		},
		"name":      basetypes.StringType{},
		"node_name": basetypes.StringType{},
		"org_id":    basetypes.StringType{},
		"route_summary_stats": basetypes.ObjectType{
			AttrTypes: RouteSummaryStatsValue{}.AttributeTypes(ctx),
		},
		"router_name": basetypes.StringType{},
		"serial":      basetypes.StringType{},
		"service2_stat": basetypes.MapType{
			ElemType: ServiceStatValue{}.Type(ctx),
		},
		"service_stat": basetypes.MapType{
			ElemType: ServiceStatValue{}.Type(ctx),
		},
		"service_status": basetypes.ObjectType{
			AttrTypes: ServiceStatusValue{}.AttributeTypes(ctx),
		},
		"site_id": basetypes.StringType{},
		"spu2_stat": basetypes.ListType{
			ElemType: SpuStatValue{}.Type(ctx),
		},
		"spu_stat": basetypes.ListType{
			ElemType: SpuStatValue{}.Type(ctx),
		},
		"status":  basetypes.StringType{},
		"uptime":  basetypes.NumberType{},
		"version": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = ApRedundancyType{}

type ApRedundancyType struct {
	basetypes.ObjectType
}

func (t ApRedundancyType) Equal(o attr.Type) bool {
	other, ok := o.(ApRedundancyType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ApRedundancyType) String() string {
	return "ApRedundancyType"
}

func (t ApRedundancyType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	modulesAttribute, ok := attributes["modules"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`modules is missing from object`)

		return nil, diags
	}

	modulesVal, ok := modulesAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`modules expected to be basetypes.MapValue, was: %T`, modulesAttribute))
	}

	numApsAttribute, ok := attributes["num_aps"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`num_aps is missing from object`)

		return nil, diags
	}

	numApsVal, ok := numApsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`num_aps expected to be basetypes.Int64Value, was: %T`, numApsAttribute))
	}

	numApsWithSwitchRedundancyAttribute, ok := attributes["num_aps_with_switch_redundancy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`num_aps_with_switch_redundancy is missing from object`)

		return nil, diags
	}

	numApsWithSwitchRedundancyVal, ok := numApsWithSwitchRedundancyAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`num_aps_with_switch_redundancy expected to be basetypes.Int64Value, was: %T`, numApsWithSwitchRedundancyAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ApRedundancyValue{
		Modules:                    modulesVal,
		NumAps:                     numApsVal,
		NumApsWithSwitchRedundancy: numApsWithSwitchRedundancyVal,
		state:                      attr.ValueStateKnown,
	}, diags
}

func NewApRedundancyValueNull() ApRedundancyValue {
	return ApRedundancyValue{
		state: attr.ValueStateNull,
	}
}

func NewApRedundancyValueUnknown() ApRedundancyValue {
	return ApRedundancyValue{
		state: attr.ValueStateUnknown,
	}
}

func NewApRedundancyValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ApRedundancyValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ApRedundancyValue Attribute Value",
				"While creating a ApRedundancyValue value, a missing attribute value was detected. "+
					"A ApRedundancyValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ApRedundancyValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ApRedundancyValue Attribute Type",
				"While creating a ApRedundancyValue value, an invalid attribute value was detected. "+
					"A ApRedundancyValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ApRedundancyValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ApRedundancyValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ApRedundancyValue Attribute Value",
				"While creating a ApRedundancyValue value, an extra attribute value was detected. "+
					"A ApRedundancyValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ApRedundancyValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewApRedundancyValueUnknown(), diags
	}

	modulesAttribute, ok := attributes["modules"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`modules is missing from object`)

		return NewApRedundancyValueUnknown(), diags
	}

	modulesVal, ok := modulesAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`modules expected to be basetypes.MapValue, was: %T`, modulesAttribute))
	}

	numApsAttribute, ok := attributes["num_aps"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`num_aps is missing from object`)

		return NewApRedundancyValueUnknown(), diags
	}

	numApsVal, ok := numApsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`num_aps expected to be basetypes.Int64Value, was: %T`, numApsAttribute))
	}

	numApsWithSwitchRedundancyAttribute, ok := attributes["num_aps_with_switch_redundancy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`num_aps_with_switch_redundancy is missing from object`)

		return NewApRedundancyValueUnknown(), diags
	}

	numApsWithSwitchRedundancyVal, ok := numApsWithSwitchRedundancyAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`num_aps_with_switch_redundancy expected to be basetypes.Int64Value, was: %T`, numApsWithSwitchRedundancyAttribute))
	}

	if diags.HasError() {
		return NewApRedundancyValueUnknown(), diags
	}

	return ApRedundancyValue{
		Modules:                    modulesVal,
		NumAps:                     numApsVal,
		NumApsWithSwitchRedundancy: numApsWithSwitchRedundancyVal,
		state:                      attr.ValueStateKnown,
	}, diags
}

func NewApRedundancyValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ApRedundancyValue {
	object, diags := NewApRedundancyValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewApRedundancyValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ApRedundancyType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewApRedundancyValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewApRedundancyValueUnknown(), nil
	}

	if in.IsNull() {
		return NewApRedundancyValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewApRedundancyValueMust(ApRedundancyValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ApRedundancyType) ValueType(ctx context.Context) attr.Value {
	return ApRedundancyValue{}
}

var _ basetypes.ObjectValuable = ApRedundancyValue{}

type ApRedundancyValue struct {
	Modules                    basetypes.MapValue   `tfsdk:"modules"`
	NumAps                     basetypes.Int64Value `tfsdk:"num_aps"`
	NumApsWithSwitchRedundancy basetypes.Int64Value `tfsdk:"num_aps_with_switch_redundancy"`
	state                      attr.ValueState
}

func (v ApRedundancyValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["modules"] = basetypes.MapType{
		ElemType: ModulesValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["num_aps"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["num_aps_with_switch_redundancy"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Modules.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["modules"] = val

		val, err = v.NumAps.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["num_aps"] = val

		val, err = v.NumApsWithSwitchRedundancy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["num_aps_with_switch_redundancy"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ApRedundancyValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ApRedundancyValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ApRedundancyValue) String() string {
	return "ApRedundancyValue"
}

func (v ApRedundancyValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	modules := types.MapValueMust(
		ModulesType{
			basetypes.ObjectType{
				AttrTypes: ModulesValue{}.AttributeTypes(ctx),
			},
		},
		v.Modules.Elements(),
	)

	if v.Modules.IsNull() {
		modules = types.MapNull(
			ModulesType{
				basetypes.ObjectType{
					AttrTypes: ModulesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Modules.IsUnknown() {
		modules = types.MapUnknown(
			ModulesType{
				basetypes.ObjectType{
					AttrTypes: ModulesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"modules": basetypes.MapType{
			ElemType: ModulesValue{}.Type(ctx),
		},
		"num_aps":                        basetypes.Int64Type{},
		"num_aps_with_switch_redundancy": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"modules":                        modules,
			"num_aps":                        v.NumAps,
			"num_aps_with_switch_redundancy": v.NumApsWithSwitchRedundancy,
		})

	return objVal, diags
}

func (v ApRedundancyValue) Equal(o attr.Value) bool {
	other, ok := o.(ApRedundancyValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Modules.Equal(other.Modules) {
		return false
	}

	if !v.NumAps.Equal(other.NumAps) {
		return false
	}

	if !v.NumApsWithSwitchRedundancy.Equal(other.NumApsWithSwitchRedundancy) {
		return false
	}

	return true
}

func (v ApRedundancyValue) Type(ctx context.Context) attr.Type {
	return ApRedundancyType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ApRedundancyValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"modules": basetypes.MapType{
			ElemType: ModulesValue{}.Type(ctx),
		},
		"num_aps":                        basetypes.Int64Type{},
		"num_aps_with_switch_redundancy": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = ModulesType{}

type ModulesType struct {
	basetypes.ObjectType
}

func (t ModulesType) Equal(o attr.Type) bool {
	other, ok := o.(ModulesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ModulesType) String() string {
	return "ModulesType"
}

func (t ModulesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	numApsAttribute, ok := attributes["num_aps"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`num_aps is missing from object`)

		return nil, diags
	}

	numApsVal, ok := numApsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`num_aps expected to be basetypes.Int64Value, was: %T`, numApsAttribute))
	}

	numApsWithSwitchRedundancyAttribute, ok := attributes["num_aps_with_switch_redundancy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`num_aps_with_switch_redundancy is missing from object`)

		return nil, diags
	}

	numApsWithSwitchRedundancyVal, ok := numApsWithSwitchRedundancyAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`num_aps_with_switch_redundancy expected to be basetypes.Int64Value, was: %T`, numApsWithSwitchRedundancyAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ModulesValue{
		NumAps:                     numApsVal,
		NumApsWithSwitchRedundancy: numApsWithSwitchRedundancyVal,
		state:                      attr.ValueStateKnown,
	}, diags
}

func NewModulesValueNull() ModulesValue {
	return ModulesValue{
		state: attr.ValueStateNull,
	}
}

func NewModulesValueUnknown() ModulesValue {
	return ModulesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewModulesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ModulesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ModulesValue Attribute Value",
				"While creating a ModulesValue value, a missing attribute value was detected. "+
					"A ModulesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ModulesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ModulesValue Attribute Type",
				"While creating a ModulesValue value, an invalid attribute value was detected. "+
					"A ModulesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ModulesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ModulesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ModulesValue Attribute Value",
				"While creating a ModulesValue value, an extra attribute value was detected. "+
					"A ModulesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ModulesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewModulesValueUnknown(), diags
	}

	numApsAttribute, ok := attributes["num_aps"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`num_aps is missing from object`)

		return NewModulesValueUnknown(), diags
	}

	numApsVal, ok := numApsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`num_aps expected to be basetypes.Int64Value, was: %T`, numApsAttribute))
	}

	numApsWithSwitchRedundancyAttribute, ok := attributes["num_aps_with_switch_redundancy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`num_aps_with_switch_redundancy is missing from object`)

		return NewModulesValueUnknown(), diags
	}

	numApsWithSwitchRedundancyVal, ok := numApsWithSwitchRedundancyAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`num_aps_with_switch_redundancy expected to be basetypes.Int64Value, was: %T`, numApsWithSwitchRedundancyAttribute))
	}

	if diags.HasError() {
		return NewModulesValueUnknown(), diags
	}

	return ModulesValue{
		NumAps:                     numApsVal,
		NumApsWithSwitchRedundancy: numApsWithSwitchRedundancyVal,
		state:                      attr.ValueStateKnown,
	}, diags
}

func NewModulesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ModulesValue {
	object, diags := NewModulesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewModulesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ModulesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewModulesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewModulesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewModulesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewModulesValueMust(ModulesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ModulesType) ValueType(ctx context.Context) attr.Value {
	return ModulesValue{}
}

var _ basetypes.ObjectValuable = ModulesValue{}

type ModulesValue struct {
	NumAps                     basetypes.Int64Value `tfsdk:"num_aps"`
	NumApsWithSwitchRedundancy basetypes.Int64Value `tfsdk:"num_aps_with_switch_redundancy"`
	state                      attr.ValueState
}

func (v ModulesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["num_aps"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["num_aps_with_switch_redundancy"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.NumAps.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["num_aps"] = val

		val, err = v.NumApsWithSwitchRedundancy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["num_aps_with_switch_redundancy"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ModulesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ModulesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ModulesValue) String() string {
	return "ModulesValue"
}

func (v ModulesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"num_aps":                        basetypes.Int64Type{},
		"num_aps_with_switch_redundancy": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"num_aps":                        v.NumAps,
			"num_aps_with_switch_redundancy": v.NumApsWithSwitchRedundancy,
		})

	return objVal, diags
}

func (v ModulesValue) Equal(o attr.Value) bool {
	other, ok := o.(ModulesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.NumAps.Equal(other.NumAps) {
		return false
	}

	if !v.NumApsWithSwitchRedundancy.Equal(other.NumApsWithSwitchRedundancy) {
		return false
	}

	return true
}

func (v ModulesValue) Type(ctx context.Context) attr.Type {
	return ModulesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ModulesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"num_aps":                        basetypes.Int64Type{},
		"num_aps_with_switch_redundancy": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = ArpTableStatsType{}

type ArpTableStatsType struct {
	basetypes.ObjectType
}

func (t ArpTableStatsType) Equal(o attr.Type) bool {
	other, ok := o.(ArpTableStatsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ArpTableStatsType) String() string {
	return "ArpTableStatsType"
}

func (t ArpTableStatsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	arpTableCountAttribute, ok := attributes["arp_table_count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`arp_table_count is missing from object`)

		return nil, diags
	}

	arpTableCountVal, ok := arpTableCountAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`arp_table_count expected to be basetypes.Int64Value, was: %T`, arpTableCountAttribute))
	}

	maxEntriesSupportedAttribute, ok := attributes["max_entries_supported"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_entries_supported is missing from object`)

		return nil, diags
	}

	maxEntriesSupportedVal, ok := maxEntriesSupportedAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_entries_supported expected to be basetypes.Int64Value, was: %T`, maxEntriesSupportedAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ArpTableStatsValue{
		ArpTableCount:       arpTableCountVal,
		MaxEntriesSupported: maxEntriesSupportedVal,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewArpTableStatsValueNull() ArpTableStatsValue {
	return ArpTableStatsValue{
		state: attr.ValueStateNull,
	}
}

func NewArpTableStatsValueUnknown() ArpTableStatsValue {
	return ArpTableStatsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewArpTableStatsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ArpTableStatsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ArpTableStatsValue Attribute Value",
				"While creating a ArpTableStatsValue value, a missing attribute value was detected. "+
					"A ArpTableStatsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ArpTableStatsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ArpTableStatsValue Attribute Type",
				"While creating a ArpTableStatsValue value, an invalid attribute value was detected. "+
					"A ArpTableStatsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ArpTableStatsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ArpTableStatsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ArpTableStatsValue Attribute Value",
				"While creating a ArpTableStatsValue value, an extra attribute value was detected. "+
					"A ArpTableStatsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ArpTableStatsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewArpTableStatsValueUnknown(), diags
	}

	arpTableCountAttribute, ok := attributes["arp_table_count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`arp_table_count is missing from object`)

		return NewArpTableStatsValueUnknown(), diags
	}

	arpTableCountVal, ok := arpTableCountAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`arp_table_count expected to be basetypes.Int64Value, was: %T`, arpTableCountAttribute))
	}

	maxEntriesSupportedAttribute, ok := attributes["max_entries_supported"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_entries_supported is missing from object`)

		return NewArpTableStatsValueUnknown(), diags
	}

	maxEntriesSupportedVal, ok := maxEntriesSupportedAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_entries_supported expected to be basetypes.Int64Value, was: %T`, maxEntriesSupportedAttribute))
	}

	if diags.HasError() {
		return NewArpTableStatsValueUnknown(), diags
	}

	return ArpTableStatsValue{
		ArpTableCount:       arpTableCountVal,
		MaxEntriesSupported: maxEntriesSupportedVal,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewArpTableStatsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ArpTableStatsValue {
	object, diags := NewArpTableStatsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewArpTableStatsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ArpTableStatsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewArpTableStatsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewArpTableStatsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewArpTableStatsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewArpTableStatsValueMust(ArpTableStatsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ArpTableStatsType) ValueType(ctx context.Context) attr.Value {
	return ArpTableStatsValue{}
}

var _ basetypes.ObjectValuable = ArpTableStatsValue{}

type ArpTableStatsValue struct {
	ArpTableCount       basetypes.Int64Value `tfsdk:"arp_table_count"`
	MaxEntriesSupported basetypes.Int64Value `tfsdk:"max_entries_supported"`
	state               attr.ValueState
}

func (v ArpTableStatsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["arp_table_count"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["max_entries_supported"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.ArpTableCount.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["arp_table_count"] = val

		val, err = v.MaxEntriesSupported.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_entries_supported"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ArpTableStatsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ArpTableStatsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ArpTableStatsValue) String() string {
	return "ArpTableStatsValue"
}

func (v ArpTableStatsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"arp_table_count":       basetypes.Int64Type{},
		"max_entries_supported": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"arp_table_count":       v.ArpTableCount,
			"max_entries_supported": v.MaxEntriesSupported,
		})

	return objVal, diags
}

func (v ArpTableStatsValue) Equal(o attr.Value) bool {
	other, ok := o.(ArpTableStatsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.ArpTableCount.Equal(other.ArpTableCount) {
		return false
	}

	if !v.MaxEntriesSupported.Equal(other.MaxEntriesSupported) {
		return false
	}

	return true
}

func (v ArpTableStatsValue) Type(ctx context.Context) attr.Type {
	return ArpTableStatsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ArpTableStatsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"arp_table_count":       basetypes.Int64Type{},
		"max_entries_supported": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = ClusterConfigType{}

type ClusterConfigType struct {
	basetypes.ObjectType
}

func (t ClusterConfigType) Equal(o attr.Type) bool {
	other, ok := o.(ClusterConfigType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ClusterConfigType) String() string {
	return "ClusterConfigType"
}

func (t ClusterConfigType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	configurationAttribute, ok := attributes["configuration"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`configuration is missing from object`)

		return nil, diags
	}

	configurationVal, ok := configurationAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`configuration expected to be basetypes.StringValue, was: %T`, configurationAttribute))
	}

	controlLinkInfoAttribute, ok := attributes["control_link_info"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`control_link_info is missing from object`)

		return nil, diags
	}

	controlLinkInfoVal, ok := controlLinkInfoAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`control_link_info expected to be basetypes.ObjectValue, was: %T`, controlLinkInfoAttribute))
	}

	ethernetConnectionAttribute, ok := attributes["ethernet_connection"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ethernet_connection is missing from object`)

		return nil, diags
	}

	ethernetConnectionVal, ok := ethernetConnectionAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ethernet_connection expected to be basetypes.ListValue, was: %T`, ethernetConnectionAttribute))
	}

	fabricLinkInfoAttribute, ok := attributes["fabric_link_info"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fabric_link_info is missing from object`)

		return nil, diags
	}

	fabricLinkInfoVal, ok := fabricLinkInfoAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fabric_link_info expected to be basetypes.ObjectValue, was: %T`, fabricLinkInfoAttribute))
	}

	lastStatusChangeReasonAttribute, ok := attributes["last_status_change_reason"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`last_status_change_reason is missing from object`)

		return nil, diags
	}

	lastStatusChangeReasonVal, ok := lastStatusChangeReasonAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`last_status_change_reason expected to be basetypes.StringValue, was: %T`, lastStatusChangeReasonAttribute))
	}

	operationalAttribute, ok := attributes["operational"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`operational is missing from object`)

		return nil, diags
	}

	operationalVal, ok := operationalAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`operational expected to be basetypes.StringValue, was: %T`, operationalAttribute))
	}

	primaryNodeHealthAttribute, ok := attributes["primary_node_health"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`primary_node_health is missing from object`)

		return nil, diags
	}

	primaryNodeHealthVal, ok := primaryNodeHealthAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`primary_node_health expected to be basetypes.StringValue, was: %T`, primaryNodeHealthAttribute))
	}

	redundancyGroupInformationAttribute, ok := attributes["redundancy_group_information"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`redundancy_group_information is missing from object`)

		return nil, diags
	}

	redundancyGroupInformationVal, ok := redundancyGroupInformationAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`redundancy_group_information expected to be basetypes.ListValue, was: %T`, redundancyGroupInformationAttribute))
	}

	secondaryNodeHealthAttribute, ok := attributes["secondary_node_health"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`secondary_node_health is missing from object`)

		return nil, diags
	}

	secondaryNodeHealthVal, ok := secondaryNodeHealthAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`secondary_node_health expected to be basetypes.StringValue, was: %T`, secondaryNodeHealthAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return nil, diags
	}

	statusVal, ok := statusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be basetypes.StringValue, was: %T`, statusAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ClusterConfigValue{
		Configuration:              configurationVal,
		ControlLinkInfo:            controlLinkInfoVal,
		EthernetConnection:         ethernetConnectionVal,
		FabricLinkInfo:             fabricLinkInfoVal,
		LastStatusChangeReason:     lastStatusChangeReasonVal,
		Operational:                operationalVal,
		PrimaryNodeHealth:          primaryNodeHealthVal,
		RedundancyGroupInformation: redundancyGroupInformationVal,
		SecondaryNodeHealth:        secondaryNodeHealthVal,
		Status:                     statusVal,
		state:                      attr.ValueStateKnown,
	}, diags
}

func NewClusterConfigValueNull() ClusterConfigValue {
	return ClusterConfigValue{
		state: attr.ValueStateNull,
	}
}

func NewClusterConfigValueUnknown() ClusterConfigValue {
	return ClusterConfigValue{
		state: attr.ValueStateUnknown,
	}
}

func NewClusterConfigValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ClusterConfigValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ClusterConfigValue Attribute Value",
				"While creating a ClusterConfigValue value, a missing attribute value was detected. "+
					"A ClusterConfigValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ClusterConfigValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ClusterConfigValue Attribute Type",
				"While creating a ClusterConfigValue value, an invalid attribute value was detected. "+
					"A ClusterConfigValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ClusterConfigValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ClusterConfigValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ClusterConfigValue Attribute Value",
				"While creating a ClusterConfigValue value, an extra attribute value was detected. "+
					"A ClusterConfigValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ClusterConfigValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewClusterConfigValueUnknown(), diags
	}

	configurationAttribute, ok := attributes["configuration"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`configuration is missing from object`)

		return NewClusterConfigValueUnknown(), diags
	}

	configurationVal, ok := configurationAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`configuration expected to be basetypes.StringValue, was: %T`, configurationAttribute))
	}

	controlLinkInfoAttribute, ok := attributes["control_link_info"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`control_link_info is missing from object`)

		return NewClusterConfigValueUnknown(), diags
	}

	controlLinkInfoVal, ok := controlLinkInfoAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`control_link_info expected to be basetypes.ObjectValue, was: %T`, controlLinkInfoAttribute))
	}

	ethernetConnectionAttribute, ok := attributes["ethernet_connection"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ethernet_connection is missing from object`)

		return NewClusterConfigValueUnknown(), diags
	}

	ethernetConnectionVal, ok := ethernetConnectionAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ethernet_connection expected to be basetypes.ListValue, was: %T`, ethernetConnectionAttribute))
	}

	fabricLinkInfoAttribute, ok := attributes["fabric_link_info"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fabric_link_info is missing from object`)

		return NewClusterConfigValueUnknown(), diags
	}

	fabricLinkInfoVal, ok := fabricLinkInfoAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fabric_link_info expected to be basetypes.ObjectValue, was: %T`, fabricLinkInfoAttribute))
	}

	lastStatusChangeReasonAttribute, ok := attributes["last_status_change_reason"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`last_status_change_reason is missing from object`)

		return NewClusterConfigValueUnknown(), diags
	}

	lastStatusChangeReasonVal, ok := lastStatusChangeReasonAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`last_status_change_reason expected to be basetypes.StringValue, was: %T`, lastStatusChangeReasonAttribute))
	}

	operationalAttribute, ok := attributes["operational"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`operational is missing from object`)

		return NewClusterConfigValueUnknown(), diags
	}

	operationalVal, ok := operationalAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`operational expected to be basetypes.StringValue, was: %T`, operationalAttribute))
	}

	primaryNodeHealthAttribute, ok := attributes["primary_node_health"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`primary_node_health is missing from object`)

		return NewClusterConfigValueUnknown(), diags
	}

	primaryNodeHealthVal, ok := primaryNodeHealthAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`primary_node_health expected to be basetypes.StringValue, was: %T`, primaryNodeHealthAttribute))
	}

	redundancyGroupInformationAttribute, ok := attributes["redundancy_group_information"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`redundancy_group_information is missing from object`)

		return NewClusterConfigValueUnknown(), diags
	}

	redundancyGroupInformationVal, ok := redundancyGroupInformationAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`redundancy_group_information expected to be basetypes.ListValue, was: %T`, redundancyGroupInformationAttribute))
	}

	secondaryNodeHealthAttribute, ok := attributes["secondary_node_health"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`secondary_node_health is missing from object`)

		return NewClusterConfigValueUnknown(), diags
	}

	secondaryNodeHealthVal, ok := secondaryNodeHealthAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`secondary_node_health expected to be basetypes.StringValue, was: %T`, secondaryNodeHealthAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return NewClusterConfigValueUnknown(), diags
	}

	statusVal, ok := statusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be basetypes.StringValue, was: %T`, statusAttribute))
	}

	if diags.HasError() {
		return NewClusterConfigValueUnknown(), diags
	}

	return ClusterConfigValue{
		Configuration:              configurationVal,
		ControlLinkInfo:            controlLinkInfoVal,
		EthernetConnection:         ethernetConnectionVal,
		FabricLinkInfo:             fabricLinkInfoVal,
		LastStatusChangeReason:     lastStatusChangeReasonVal,
		Operational:                operationalVal,
		PrimaryNodeHealth:          primaryNodeHealthVal,
		RedundancyGroupInformation: redundancyGroupInformationVal,
		SecondaryNodeHealth:        secondaryNodeHealthVal,
		Status:                     statusVal,
		state:                      attr.ValueStateKnown,
	}, diags
}

func NewClusterConfigValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ClusterConfigValue {
	object, diags := NewClusterConfigValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewClusterConfigValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ClusterConfigType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewClusterConfigValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewClusterConfigValueUnknown(), nil
	}

	if in.IsNull() {
		return NewClusterConfigValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewClusterConfigValueMust(ClusterConfigValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ClusterConfigType) ValueType(ctx context.Context) attr.Value {
	return ClusterConfigValue{}
}

var _ basetypes.ObjectValuable = ClusterConfigValue{}

type ClusterConfigValue struct {
	Configuration              basetypes.StringValue `tfsdk:"configuration"`
	ControlLinkInfo            basetypes.ObjectValue `tfsdk:"control_link_info"`
	EthernetConnection         basetypes.ListValue   `tfsdk:"ethernet_connection"`
	FabricLinkInfo             basetypes.ObjectValue `tfsdk:"fabric_link_info"`
	LastStatusChangeReason     basetypes.StringValue `tfsdk:"last_status_change_reason"`
	Operational                basetypes.StringValue `tfsdk:"operational"`
	PrimaryNodeHealth          basetypes.StringValue `tfsdk:"primary_node_health"`
	RedundancyGroupInformation basetypes.ListValue   `tfsdk:"redundancy_group_information"`
	SecondaryNodeHealth        basetypes.StringValue `tfsdk:"secondary_node_health"`
	Status                     basetypes.StringValue `tfsdk:"status"`
	state                      attr.ValueState
}

func (v ClusterConfigValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 10)

	var val tftypes.Value
	var err error

	attrTypes["configuration"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["control_link_info"] = basetypes.ObjectType{
		AttrTypes: ControlLinkInfoValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["ethernet_connection"] = basetypes.ListType{
		ElemType: EthernetConnectionValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["fabric_link_info"] = basetypes.ObjectType{
		AttrTypes: FabricLinkInfoValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["last_status_change_reason"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["operational"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["primary_node_health"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["redundancy_group_information"] = basetypes.ListType{
		ElemType: RedundancyGroupInformationValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["secondary_node_health"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["status"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 10)

		val, err = v.Configuration.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["configuration"] = val

		val, err = v.ControlLinkInfo.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["control_link_info"] = val

		val, err = v.EthernetConnection.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ethernet_connection"] = val

		val, err = v.FabricLinkInfo.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["fabric_link_info"] = val

		val, err = v.LastStatusChangeReason.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["last_status_change_reason"] = val

		val, err = v.Operational.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["operational"] = val

		val, err = v.PrimaryNodeHealth.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["primary_node_health"] = val

		val, err = v.RedundancyGroupInformation.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["redundancy_group_information"] = val

		val, err = v.SecondaryNodeHealth.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["secondary_node_health"] = val

		val, err = v.Status.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["status"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ClusterConfigValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ClusterConfigValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ClusterConfigValue) String() string {
	return "ClusterConfigValue"
}

func (v ClusterConfigValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var controlLinkInfo basetypes.ObjectValue

	if v.ControlLinkInfo.IsNull() {
		controlLinkInfo = types.ObjectNull(
			ControlLinkInfoValue{}.AttributeTypes(ctx),
		)
	}

	if v.ControlLinkInfo.IsUnknown() {
		controlLinkInfo = types.ObjectUnknown(
			ControlLinkInfoValue{}.AttributeTypes(ctx),
		)
	}

	if !v.ControlLinkInfo.IsNull() && !v.ControlLinkInfo.IsUnknown() {
		controlLinkInfo = types.ObjectValueMust(
			ControlLinkInfoValue{}.AttributeTypes(ctx),
			v.ControlLinkInfo.Attributes(),
		)
	}

	ethernetConnection := types.ListValueMust(
		EthernetConnectionType{
			basetypes.ObjectType{
				AttrTypes: EthernetConnectionValue{}.AttributeTypes(ctx),
			},
		},
		v.EthernetConnection.Elements(),
	)

	if v.EthernetConnection.IsNull() {
		ethernetConnection = types.ListNull(
			EthernetConnectionType{
				basetypes.ObjectType{
					AttrTypes: EthernetConnectionValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.EthernetConnection.IsUnknown() {
		ethernetConnection = types.ListUnknown(
			EthernetConnectionType{
				basetypes.ObjectType{
					AttrTypes: EthernetConnectionValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var fabricLinkInfo basetypes.ObjectValue

	if v.FabricLinkInfo.IsNull() {
		fabricLinkInfo = types.ObjectNull(
			FabricLinkInfoValue{}.AttributeTypes(ctx),
		)
	}

	if v.FabricLinkInfo.IsUnknown() {
		fabricLinkInfo = types.ObjectUnknown(
			FabricLinkInfoValue{}.AttributeTypes(ctx),
		)
	}

	if !v.FabricLinkInfo.IsNull() && !v.FabricLinkInfo.IsUnknown() {
		fabricLinkInfo = types.ObjectValueMust(
			FabricLinkInfoValue{}.AttributeTypes(ctx),
			v.FabricLinkInfo.Attributes(),
		)
	}

	redundancyGroupInformation := types.ListValueMust(
		RedundancyGroupInformationType{
			basetypes.ObjectType{
				AttrTypes: RedundancyGroupInformationValue{}.AttributeTypes(ctx),
			},
		},
		v.RedundancyGroupInformation.Elements(),
	)

	if v.RedundancyGroupInformation.IsNull() {
		redundancyGroupInformation = types.ListNull(
			RedundancyGroupInformationType{
				basetypes.ObjectType{
					AttrTypes: RedundancyGroupInformationValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.RedundancyGroupInformation.IsUnknown() {
		redundancyGroupInformation = types.ListUnknown(
			RedundancyGroupInformationType{
				basetypes.ObjectType{
					AttrTypes: RedundancyGroupInformationValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"configuration": basetypes.StringType{},
		"control_link_info": basetypes.ObjectType{
			AttrTypes: ControlLinkInfoValue{}.AttributeTypes(ctx),
		},
		"ethernet_connection": basetypes.ListType{
			ElemType: EthernetConnectionValue{}.Type(ctx),
		},
		"fabric_link_info": basetypes.ObjectType{
			AttrTypes: FabricLinkInfoValue{}.AttributeTypes(ctx),
		},
		"last_status_change_reason": basetypes.StringType{},
		"operational":               basetypes.StringType{},
		"primary_node_health":       basetypes.StringType{},
		"redundancy_group_information": basetypes.ListType{
			ElemType: RedundancyGroupInformationValue{}.Type(ctx),
		},
		"secondary_node_health": basetypes.StringType{},
		"status":                basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"configuration":                v.Configuration,
			"control_link_info":            controlLinkInfo,
			"ethernet_connection":          ethernetConnection,
			"fabric_link_info":             fabricLinkInfo,
			"last_status_change_reason":    v.LastStatusChangeReason,
			"operational":                  v.Operational,
			"primary_node_health":          v.PrimaryNodeHealth,
			"redundancy_group_information": redundancyGroupInformation,
			"secondary_node_health":        v.SecondaryNodeHealth,
			"status":                       v.Status,
		})

	return objVal, diags
}

func (v ClusterConfigValue) Equal(o attr.Value) bool {
	other, ok := o.(ClusterConfigValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Configuration.Equal(other.Configuration) {
		return false
	}

	if !v.ControlLinkInfo.Equal(other.ControlLinkInfo) {
		return false
	}

	if !v.EthernetConnection.Equal(other.EthernetConnection) {
		return false
	}

	if !v.FabricLinkInfo.Equal(other.FabricLinkInfo) {
		return false
	}

	if !v.LastStatusChangeReason.Equal(other.LastStatusChangeReason) {
		return false
	}

	if !v.Operational.Equal(other.Operational) {
		return false
	}

	if !v.PrimaryNodeHealth.Equal(other.PrimaryNodeHealth) {
		return false
	}

	if !v.RedundancyGroupInformation.Equal(other.RedundancyGroupInformation) {
		return false
	}

	if !v.SecondaryNodeHealth.Equal(other.SecondaryNodeHealth) {
		return false
	}

	if !v.Status.Equal(other.Status) {
		return false
	}

	return true
}

func (v ClusterConfigValue) Type(ctx context.Context) attr.Type {
	return ClusterConfigType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ClusterConfigValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"configuration": basetypes.StringType{},
		"control_link_info": basetypes.ObjectType{
			AttrTypes: ControlLinkInfoValue{}.AttributeTypes(ctx),
		},
		"ethernet_connection": basetypes.ListType{
			ElemType: EthernetConnectionValue{}.Type(ctx),
		},
		"fabric_link_info": basetypes.ObjectType{
			AttrTypes: FabricLinkInfoValue{}.AttributeTypes(ctx),
		},
		"last_status_change_reason": basetypes.StringType{},
		"operational":               basetypes.StringType{},
		"primary_node_health":       basetypes.StringType{},
		"redundancy_group_information": basetypes.ListType{
			ElemType: RedundancyGroupInformationValue{}.Type(ctx),
		},
		"secondary_node_health": basetypes.StringType{},
		"status":                basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = ControlLinkInfoType{}

type ControlLinkInfoType struct {
	basetypes.ObjectType
}

func (t ControlLinkInfoType) Equal(o attr.Type) bool {
	other, ok := o.(ControlLinkInfoType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ControlLinkInfoType) String() string {
	return "ControlLinkInfoType"
}

func (t ControlLinkInfoType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return nil, diags
	}

	statusVal, ok := statusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be basetypes.StringValue, was: %T`, statusAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ControlLinkInfoValue{
		Name:   nameVal,
		Status: statusVal,
		state:  attr.ValueStateKnown,
	}, diags
}

func NewControlLinkInfoValueNull() ControlLinkInfoValue {
	return ControlLinkInfoValue{
		state: attr.ValueStateNull,
	}
}

func NewControlLinkInfoValueUnknown() ControlLinkInfoValue {
	return ControlLinkInfoValue{
		state: attr.ValueStateUnknown,
	}
}

func NewControlLinkInfoValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ControlLinkInfoValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ControlLinkInfoValue Attribute Value",
				"While creating a ControlLinkInfoValue value, a missing attribute value was detected. "+
					"A ControlLinkInfoValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ControlLinkInfoValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ControlLinkInfoValue Attribute Type",
				"While creating a ControlLinkInfoValue value, an invalid attribute value was detected. "+
					"A ControlLinkInfoValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ControlLinkInfoValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ControlLinkInfoValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ControlLinkInfoValue Attribute Value",
				"While creating a ControlLinkInfoValue value, an extra attribute value was detected. "+
					"A ControlLinkInfoValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ControlLinkInfoValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewControlLinkInfoValueUnknown(), diags
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewControlLinkInfoValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return NewControlLinkInfoValueUnknown(), diags
	}

	statusVal, ok := statusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be basetypes.StringValue, was: %T`, statusAttribute))
	}

	if diags.HasError() {
		return NewControlLinkInfoValueUnknown(), diags
	}

	return ControlLinkInfoValue{
		Name:   nameVal,
		Status: statusVal,
		state:  attr.ValueStateKnown,
	}, diags
}

func NewControlLinkInfoValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ControlLinkInfoValue {
	object, diags := NewControlLinkInfoValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewControlLinkInfoValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ControlLinkInfoType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewControlLinkInfoValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewControlLinkInfoValueUnknown(), nil
	}

	if in.IsNull() {
		return NewControlLinkInfoValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewControlLinkInfoValueMust(ControlLinkInfoValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ControlLinkInfoType) ValueType(ctx context.Context) attr.Value {
	return ControlLinkInfoValue{}
}

var _ basetypes.ObjectValuable = ControlLinkInfoValue{}

type ControlLinkInfoValue struct {
	Name   basetypes.StringValue `tfsdk:"name"`
	Status basetypes.StringValue `tfsdk:"status"`
	state  attr.ValueState
}

func (v ControlLinkInfoValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["status"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Status.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["status"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ControlLinkInfoValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ControlLinkInfoValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ControlLinkInfoValue) String() string {
	return "ControlLinkInfoValue"
}

func (v ControlLinkInfoValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"name":   basetypes.StringType{},
		"status": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"name":   v.Name,
			"status": v.Status,
		})

	return objVal, diags
}

func (v ControlLinkInfoValue) Equal(o attr.Value) bool {
	other, ok := o.(ControlLinkInfoValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Status.Equal(other.Status) {
		return false
	}

	return true
}

func (v ControlLinkInfoValue) Type(ctx context.Context) attr.Type {
	return ControlLinkInfoType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ControlLinkInfoValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"name":   basetypes.StringType{},
		"status": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = EthernetConnectionType{}

type EthernetConnectionType struct {
	basetypes.ObjectType
}

func (t EthernetConnectionType) Equal(o attr.Type) bool {
	other, ok := o.(EthernetConnectionType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t EthernetConnectionType) String() string {
	return "EthernetConnectionType"
}

func (t EthernetConnectionType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return nil, diags
	}

	statusVal, ok := statusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be basetypes.StringValue, was: %T`, statusAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return EthernetConnectionValue{
		Name:   nameVal,
		Status: statusVal,
		state:  attr.ValueStateKnown,
	}, diags
}

func NewEthernetConnectionValueNull() EthernetConnectionValue {
	return EthernetConnectionValue{
		state: attr.ValueStateNull,
	}
}

func NewEthernetConnectionValueUnknown() EthernetConnectionValue {
	return EthernetConnectionValue{
		state: attr.ValueStateUnknown,
	}
}

func NewEthernetConnectionValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (EthernetConnectionValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing EthernetConnectionValue Attribute Value",
				"While creating a EthernetConnectionValue value, a missing attribute value was detected. "+
					"A EthernetConnectionValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("EthernetConnectionValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid EthernetConnectionValue Attribute Type",
				"While creating a EthernetConnectionValue value, an invalid attribute value was detected. "+
					"A EthernetConnectionValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("EthernetConnectionValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("EthernetConnectionValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra EthernetConnectionValue Attribute Value",
				"While creating a EthernetConnectionValue value, an extra attribute value was detected. "+
					"A EthernetConnectionValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra EthernetConnectionValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewEthernetConnectionValueUnknown(), diags
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewEthernetConnectionValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return NewEthernetConnectionValueUnknown(), diags
	}

	statusVal, ok := statusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be basetypes.StringValue, was: %T`, statusAttribute))
	}

	if diags.HasError() {
		return NewEthernetConnectionValueUnknown(), diags
	}

	return EthernetConnectionValue{
		Name:   nameVal,
		Status: statusVal,
		state:  attr.ValueStateKnown,
	}, diags
}

func NewEthernetConnectionValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) EthernetConnectionValue {
	object, diags := NewEthernetConnectionValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewEthernetConnectionValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t EthernetConnectionType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewEthernetConnectionValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewEthernetConnectionValueUnknown(), nil
	}

	if in.IsNull() {
		return NewEthernetConnectionValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewEthernetConnectionValueMust(EthernetConnectionValue{}.AttributeTypes(ctx), attributes), nil
}

func (t EthernetConnectionType) ValueType(ctx context.Context) attr.Value {
	return EthernetConnectionValue{}
}

var _ basetypes.ObjectValuable = EthernetConnectionValue{}

type EthernetConnectionValue struct {
	Name   basetypes.StringValue `tfsdk:"name"`
	Status basetypes.StringValue `tfsdk:"status"`
	state  attr.ValueState
}

func (v EthernetConnectionValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["status"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Status.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["status"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v EthernetConnectionValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v EthernetConnectionValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v EthernetConnectionValue) String() string {
	return "EthernetConnectionValue"
}

func (v EthernetConnectionValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"name":   basetypes.StringType{},
		"status": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"name":   v.Name,
			"status": v.Status,
		})

	return objVal, diags
}

func (v EthernetConnectionValue) Equal(o attr.Value) bool {
	other, ok := o.(EthernetConnectionValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Status.Equal(other.Status) {
		return false
	}

	return true
}

func (v EthernetConnectionValue) Type(ctx context.Context) attr.Type {
	return EthernetConnectionType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v EthernetConnectionValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"name":   basetypes.StringType{},
		"status": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = FabricLinkInfoType{}

type FabricLinkInfoType struct {
	basetypes.ObjectType
}

func (t FabricLinkInfoType) Equal(o attr.Type) bool {
	other, ok := o.(FabricLinkInfoType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t FabricLinkInfoType) String() string {
	return "FabricLinkInfoType"
}

func (t FabricLinkInfoType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	dataPlaneNotifiedStatusAttribute, ok := attributes["data_plane_notified_status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`data_plane_notified_status is missing from object`)

		return nil, diags
	}

	dataPlaneNotifiedStatusVal, ok := dataPlaneNotifiedStatusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`data_plane_notified_status expected to be basetypes.StringValue, was: %T`, dataPlaneNotifiedStatusAttribute))
	}

	interfaceAttribute, ok := attributes["interface"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface is missing from object`)

		return nil, diags
	}

	interfaceVal, ok := interfaceAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface expected to be basetypes.ListValue, was: %T`, interfaceAttribute))
	}

	internalStatusAttribute, ok := attributes["internal_status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`internal_status is missing from object`)

		return nil, diags
	}

	internalStatusVal, ok := internalStatusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`internal_status expected to be basetypes.StringValue, was: %T`, internalStatusAttribute))
	}

	stateAttribute, ok := attributes["state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`state is missing from object`)

		return nil, diags
	}

	stateVal, ok := stateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`state expected to be basetypes.StringValue, was: %T`, stateAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return nil, diags
	}

	statusVal, ok := statusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be basetypes.StringValue, was: %T`, statusAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return FabricLinkInfoValue{
		DataPlaneNotifiedStatus: dataPlaneNotifiedStatusVal,
		Interface:               interfaceVal,
		InternalStatus:          internalStatusVal,
		State:                   stateVal,
		Status:                  statusVal,
		state:                   attr.ValueStateKnown,
	}, diags
}

func NewFabricLinkInfoValueNull() FabricLinkInfoValue {
	return FabricLinkInfoValue{
		state: attr.ValueStateNull,
	}
}

func NewFabricLinkInfoValueUnknown() FabricLinkInfoValue {
	return FabricLinkInfoValue{
		state: attr.ValueStateUnknown,
	}
}

func NewFabricLinkInfoValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (FabricLinkInfoValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing FabricLinkInfoValue Attribute Value",
				"While creating a FabricLinkInfoValue value, a missing attribute value was detected. "+
					"A FabricLinkInfoValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("FabricLinkInfoValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid FabricLinkInfoValue Attribute Type",
				"While creating a FabricLinkInfoValue value, an invalid attribute value was detected. "+
					"A FabricLinkInfoValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("FabricLinkInfoValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("FabricLinkInfoValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra FabricLinkInfoValue Attribute Value",
				"While creating a FabricLinkInfoValue value, an extra attribute value was detected. "+
					"A FabricLinkInfoValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra FabricLinkInfoValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewFabricLinkInfoValueUnknown(), diags
	}

	dataPlaneNotifiedStatusAttribute, ok := attributes["data_plane_notified_status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`data_plane_notified_status is missing from object`)

		return NewFabricLinkInfoValueUnknown(), diags
	}

	dataPlaneNotifiedStatusVal, ok := dataPlaneNotifiedStatusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`data_plane_notified_status expected to be basetypes.StringValue, was: %T`, dataPlaneNotifiedStatusAttribute))
	}

	interfaceAttribute, ok := attributes["interface"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface is missing from object`)

		return NewFabricLinkInfoValueUnknown(), diags
	}

	interfaceVal, ok := interfaceAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface expected to be basetypes.ListValue, was: %T`, interfaceAttribute))
	}

	internalStatusAttribute, ok := attributes["internal_status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`internal_status is missing from object`)

		return NewFabricLinkInfoValueUnknown(), diags
	}

	internalStatusVal, ok := internalStatusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`internal_status expected to be basetypes.StringValue, was: %T`, internalStatusAttribute))
	}

	stateAttribute, ok := attributes["state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`state is missing from object`)

		return NewFabricLinkInfoValueUnknown(), diags
	}

	stateVal, ok := stateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`state expected to be basetypes.StringValue, was: %T`, stateAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return NewFabricLinkInfoValueUnknown(), diags
	}

	statusVal, ok := statusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be basetypes.StringValue, was: %T`, statusAttribute))
	}

	if diags.HasError() {
		return NewFabricLinkInfoValueUnknown(), diags
	}

	return FabricLinkInfoValue{
		DataPlaneNotifiedStatus: dataPlaneNotifiedStatusVal,
		Interface:               interfaceVal,
		InternalStatus:          internalStatusVal,
		State:                   stateVal,
		Status:                  statusVal,
		state:                   attr.ValueStateKnown,
	}, diags
}

func NewFabricLinkInfoValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) FabricLinkInfoValue {
	object, diags := NewFabricLinkInfoValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewFabricLinkInfoValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t FabricLinkInfoType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewFabricLinkInfoValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewFabricLinkInfoValueUnknown(), nil
	}

	if in.IsNull() {
		return NewFabricLinkInfoValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewFabricLinkInfoValueMust(FabricLinkInfoValue{}.AttributeTypes(ctx), attributes), nil
}

func (t FabricLinkInfoType) ValueType(ctx context.Context) attr.Value {
	return FabricLinkInfoValue{}
}

var _ basetypes.ObjectValuable = FabricLinkInfoValue{}

type FabricLinkInfoValue struct {
	DataPlaneNotifiedStatus basetypes.StringValue `tfsdk:"data_plane_notified_status"`
	Interface               basetypes.ListValue   `tfsdk:"interface"`
	InternalStatus          basetypes.StringValue `tfsdk:"internal_status"`
	State                   basetypes.StringValue `tfsdk:"state"`
	Status                  basetypes.StringValue `tfsdk:"status"`
	state                   attr.ValueState
}

func (v FabricLinkInfoValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["data_plane_notified_status"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["interface"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["internal_status"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["state"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["status"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.DataPlaneNotifiedStatus.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["data_plane_notified_status"] = val

		val, err = v.Interface.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["interface"] = val

		val, err = v.InternalStatus.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["internal_status"] = val

		val, err = v.State.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["state"] = val

		val, err = v.Status.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["status"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v FabricLinkInfoValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v FabricLinkInfoValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v FabricLinkInfoValue) String() string {
	return "FabricLinkInfoValue"
}

func (v FabricLinkInfoValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	interfaceVal, d := types.ListValue(types.StringType, v.Interface.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"data_plane_notified_status": basetypes.StringType{},
			"interface": basetypes.ListType{
				ElemType: types.StringType,
			},
			"internal_status": basetypes.StringType{},
			"state":           basetypes.StringType{},
			"status":          basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"data_plane_notified_status": basetypes.StringType{},
		"interface": basetypes.ListType{
			ElemType: types.StringType,
		},
		"internal_status": basetypes.StringType{},
		"state":           basetypes.StringType{},
		"status":          basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"data_plane_notified_status": v.DataPlaneNotifiedStatus,
			"interface":                  interfaceVal,
			"internal_status":            v.InternalStatus,
			"state":                      v.State,
			"status":                     v.Status,
		})

	return objVal, diags
}

func (v FabricLinkInfoValue) Equal(o attr.Value) bool {
	other, ok := o.(FabricLinkInfoValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.DataPlaneNotifiedStatus.Equal(other.DataPlaneNotifiedStatus) {
		return false
	}

	if !v.Interface.Equal(other.Interface) {
		return false
	}

	if !v.InternalStatus.Equal(other.InternalStatus) {
		return false
	}

	if !v.State.Equal(other.State) {
		return false
	}

	if !v.Status.Equal(other.Status) {
		return false
	}

	return true
}

func (v FabricLinkInfoValue) Type(ctx context.Context) attr.Type {
	return FabricLinkInfoType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v FabricLinkInfoValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"data_plane_notified_status": basetypes.StringType{},
		"interface": basetypes.ListType{
			ElemType: types.StringType,
		},
		"internal_status": basetypes.StringType{},
		"state":           basetypes.StringType{},
		"status":          basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = RedundancyGroupInformationType{}

type RedundancyGroupInformationType struct {
	basetypes.ObjectType
}

func (t RedundancyGroupInformationType) Equal(o attr.Type) bool {
	other, ok := o.(RedundancyGroupInformationType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t RedundancyGroupInformationType) String() string {
	return "RedundancyGroupInformationType"
}

func (t RedundancyGroupInformationType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	monitoringFailureAttribute, ok := attributes["monitoring_failure"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`monitoring_failure is missing from object`)

		return nil, diags
	}

	monitoringFailureVal, ok := monitoringFailureAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`monitoring_failure expected to be basetypes.StringValue, was: %T`, monitoringFailureAttribute))
	}

	thresholdAttribute, ok := attributes["threshold"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`threshold is missing from object`)

		return nil, diags
	}

	thresholdVal, ok := thresholdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`threshold expected to be basetypes.Int64Value, was: %T`, thresholdAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return RedundancyGroupInformationValue{
		Id:                idVal,
		MonitoringFailure: monitoringFailureVal,
		Threshold:         thresholdVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewRedundancyGroupInformationValueNull() RedundancyGroupInformationValue {
	return RedundancyGroupInformationValue{
		state: attr.ValueStateNull,
	}
}

func NewRedundancyGroupInformationValueUnknown() RedundancyGroupInformationValue {
	return RedundancyGroupInformationValue{
		state: attr.ValueStateUnknown,
	}
}

func NewRedundancyGroupInformationValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (RedundancyGroupInformationValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing RedundancyGroupInformationValue Attribute Value",
				"While creating a RedundancyGroupInformationValue value, a missing attribute value was detected. "+
					"A RedundancyGroupInformationValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RedundancyGroupInformationValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid RedundancyGroupInformationValue Attribute Type",
				"While creating a RedundancyGroupInformationValue value, an invalid attribute value was detected. "+
					"A RedundancyGroupInformationValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RedundancyGroupInformationValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("RedundancyGroupInformationValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra RedundancyGroupInformationValue Attribute Value",
				"While creating a RedundancyGroupInformationValue value, an extra attribute value was detected. "+
					"A RedundancyGroupInformationValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra RedundancyGroupInformationValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewRedundancyGroupInformationValueUnknown(), diags
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewRedundancyGroupInformationValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	monitoringFailureAttribute, ok := attributes["monitoring_failure"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`monitoring_failure is missing from object`)

		return NewRedundancyGroupInformationValueUnknown(), diags
	}

	monitoringFailureVal, ok := monitoringFailureAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`monitoring_failure expected to be basetypes.StringValue, was: %T`, monitoringFailureAttribute))
	}

	thresholdAttribute, ok := attributes["threshold"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`threshold is missing from object`)

		return NewRedundancyGroupInformationValueUnknown(), diags
	}

	thresholdVal, ok := thresholdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`threshold expected to be basetypes.Int64Value, was: %T`, thresholdAttribute))
	}

	if diags.HasError() {
		return NewRedundancyGroupInformationValueUnknown(), diags
	}

	return RedundancyGroupInformationValue{
		Id:                idVal,
		MonitoringFailure: monitoringFailureVal,
		Threshold:         thresholdVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewRedundancyGroupInformationValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) RedundancyGroupInformationValue {
	object, diags := NewRedundancyGroupInformationValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewRedundancyGroupInformationValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t RedundancyGroupInformationType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewRedundancyGroupInformationValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewRedundancyGroupInformationValueUnknown(), nil
	}

	if in.IsNull() {
		return NewRedundancyGroupInformationValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewRedundancyGroupInformationValueMust(RedundancyGroupInformationValue{}.AttributeTypes(ctx), attributes), nil
}

func (t RedundancyGroupInformationType) ValueType(ctx context.Context) attr.Value {
	return RedundancyGroupInformationValue{}
}

var _ basetypes.ObjectValuable = RedundancyGroupInformationValue{}

type RedundancyGroupInformationValue struct {
	Id                basetypes.Int64Value  `tfsdk:"id"`
	MonitoringFailure basetypes.StringValue `tfsdk:"monitoring_failure"`
	Threshold         basetypes.Int64Value  `tfsdk:"threshold"`
	state             attr.ValueState
}

func (v RedundancyGroupInformationValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["id"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["monitoring_failure"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["threshold"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.MonitoringFailure.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["monitoring_failure"] = val

		val, err = v.Threshold.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["threshold"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v RedundancyGroupInformationValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v RedundancyGroupInformationValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v RedundancyGroupInformationValue) String() string {
	return "RedundancyGroupInformationValue"
}

func (v RedundancyGroupInformationValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"id":                 basetypes.Int64Type{},
		"monitoring_failure": basetypes.StringType{},
		"threshold":          basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"id":                 v.Id,
			"monitoring_failure": v.MonitoringFailure,
			"threshold":          v.Threshold,
		})

	return objVal, diags
}

func (v RedundancyGroupInformationValue) Equal(o attr.Value) bool {
	other, ok := o.(RedundancyGroupInformationValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.MonitoringFailure.Equal(other.MonitoringFailure) {
		return false
	}

	if !v.Threshold.Equal(other.Threshold) {
		return false
	}

	return true
}

func (v RedundancyGroupInformationValue) Type(ctx context.Context) attr.Type {
	return RedundancyGroupInformationType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v RedundancyGroupInformationValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"id":                 basetypes.Int64Type{},
		"monitoring_failure": basetypes.StringType{},
		"threshold":          basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = ClusterStatType{}

type ClusterStatType struct {
	basetypes.ObjectType
}

func (t ClusterStatType) Equal(o attr.Type) bool {
	other, ok := o.(ClusterStatType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ClusterStatType) String() string {
	return "ClusterStatType"
}

func (t ClusterStatType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	stateAttribute, ok := attributes["state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`state is missing from object`)

		return nil, diags
	}

	stateVal, ok := stateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`state expected to be basetypes.StringValue, was: %T`, stateAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ClusterStatValue{
		State: stateVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewClusterStatValueNull() ClusterStatValue {
	return ClusterStatValue{
		state: attr.ValueStateNull,
	}
}

func NewClusterStatValueUnknown() ClusterStatValue {
	return ClusterStatValue{
		state: attr.ValueStateUnknown,
	}
}

func NewClusterStatValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ClusterStatValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ClusterStatValue Attribute Value",
				"While creating a ClusterStatValue value, a missing attribute value was detected. "+
					"A ClusterStatValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ClusterStatValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ClusterStatValue Attribute Type",
				"While creating a ClusterStatValue value, an invalid attribute value was detected. "+
					"A ClusterStatValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ClusterStatValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ClusterStatValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ClusterStatValue Attribute Value",
				"While creating a ClusterStatValue value, an extra attribute value was detected. "+
					"A ClusterStatValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ClusterStatValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewClusterStatValueUnknown(), diags
	}

	stateAttribute, ok := attributes["state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`state is missing from object`)

		return NewClusterStatValueUnknown(), diags
	}

	stateVal, ok := stateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`state expected to be basetypes.StringValue, was: %T`, stateAttribute))
	}

	if diags.HasError() {
		return NewClusterStatValueUnknown(), diags
	}

	return ClusterStatValue{
		State: stateVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewClusterStatValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ClusterStatValue {
	object, diags := NewClusterStatValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewClusterStatValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ClusterStatType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewClusterStatValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewClusterStatValueUnknown(), nil
	}

	if in.IsNull() {
		return NewClusterStatValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewClusterStatValueMust(ClusterStatValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ClusterStatType) ValueType(ctx context.Context) attr.Value {
	return ClusterStatValue{}
}

var _ basetypes.ObjectValuable = ClusterStatValue{}

type ClusterStatValue struct {
	State basetypes.StringValue `tfsdk:"state"`
	state attr.ValueState
}

func (v ClusterStatValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["state"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.State.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["state"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ClusterStatValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ClusterStatValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ClusterStatValue) String() string {
	return "ClusterStatValue"
}

func (v ClusterStatValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"state": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"state": v.State,
		})

	return objVal, diags
}

func (v ClusterStatValue) Equal(o attr.Value) bool {
	other, ok := o.(ClusterStatValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.State.Equal(other.State) {
		return false
	}

	return true
}

func (v ClusterStatValue) Type(ctx context.Context) attr.Type {
	return ClusterStatType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ClusterStatValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"state": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = CpuStatType{}

type CpuStatType struct {
	basetypes.ObjectType
}

func (t CpuStatType) Equal(o attr.Type) bool {
	other, ok := o.(CpuStatType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t CpuStatType) String() string {
	return "CpuStatType"
}

func (t CpuStatType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	idleAttribute, ok := attributes["idle"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`idle is missing from object`)

		return nil, diags
	}

	idleVal, ok := idleAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`idle expected to be basetypes.NumberValue, was: %T`, idleAttribute))
	}

	interruptAttribute, ok := attributes["interrupt"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interrupt is missing from object`)

		return nil, diags
	}

	interruptVal, ok := interruptAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interrupt expected to be basetypes.NumberValue, was: %T`, interruptAttribute))
	}

	loadAvgAttribute, ok := attributes["load_avg"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`load_avg is missing from object`)

		return nil, diags
	}

	loadAvgVal, ok := loadAvgAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`load_avg expected to be basetypes.ListValue, was: %T`, loadAvgAttribute))
	}

	systemAttribute, ok := attributes["system"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`system is missing from object`)

		return nil, diags
	}

	systemVal, ok := systemAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`system expected to be basetypes.NumberValue, was: %T`, systemAttribute))
	}

	userAttribute, ok := attributes["user"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`user is missing from object`)

		return nil, diags
	}

	userVal, ok := userAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`user expected to be basetypes.NumberValue, was: %T`, userAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return CpuStatValue{
		Idle:      idleVal,
		Interrupt: interruptVal,
		LoadAvg:   loadAvgVal,
		System:    systemVal,
		User:      userVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewCpuStatValueNull() CpuStatValue {
	return CpuStatValue{
		state: attr.ValueStateNull,
	}
}

func NewCpuStatValueUnknown() CpuStatValue {
	return CpuStatValue{
		state: attr.ValueStateUnknown,
	}
}

func NewCpuStatValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (CpuStatValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing CpuStatValue Attribute Value",
				"While creating a CpuStatValue value, a missing attribute value was detected. "+
					"A CpuStatValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CpuStatValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid CpuStatValue Attribute Type",
				"While creating a CpuStatValue value, an invalid attribute value was detected. "+
					"A CpuStatValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CpuStatValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("CpuStatValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra CpuStatValue Attribute Value",
				"While creating a CpuStatValue value, an extra attribute value was detected. "+
					"A CpuStatValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra CpuStatValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewCpuStatValueUnknown(), diags
	}

	idleAttribute, ok := attributes["idle"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`idle is missing from object`)

		return NewCpuStatValueUnknown(), diags
	}

	idleVal, ok := idleAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`idle expected to be basetypes.NumberValue, was: %T`, idleAttribute))
	}

	interruptAttribute, ok := attributes["interrupt"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interrupt is missing from object`)

		return NewCpuStatValueUnknown(), diags
	}

	interruptVal, ok := interruptAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interrupt expected to be basetypes.NumberValue, was: %T`, interruptAttribute))
	}

	loadAvgAttribute, ok := attributes["load_avg"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`load_avg is missing from object`)

		return NewCpuStatValueUnknown(), diags
	}

	loadAvgVal, ok := loadAvgAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`load_avg expected to be basetypes.ListValue, was: %T`, loadAvgAttribute))
	}

	systemAttribute, ok := attributes["system"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`system is missing from object`)

		return NewCpuStatValueUnknown(), diags
	}

	systemVal, ok := systemAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`system expected to be basetypes.NumberValue, was: %T`, systemAttribute))
	}

	userAttribute, ok := attributes["user"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`user is missing from object`)

		return NewCpuStatValueUnknown(), diags
	}

	userVal, ok := userAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`user expected to be basetypes.NumberValue, was: %T`, userAttribute))
	}

	if diags.HasError() {
		return NewCpuStatValueUnknown(), diags
	}

	return CpuStatValue{
		Idle:      idleVal,
		Interrupt: interruptVal,
		LoadAvg:   loadAvgVal,
		System:    systemVal,
		User:      userVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewCpuStatValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) CpuStatValue {
	object, diags := NewCpuStatValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewCpuStatValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t CpuStatType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewCpuStatValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewCpuStatValueUnknown(), nil
	}

	if in.IsNull() {
		return NewCpuStatValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewCpuStatValueMust(CpuStatValue{}.AttributeTypes(ctx), attributes), nil
}

func (t CpuStatType) ValueType(ctx context.Context) attr.Value {
	return CpuStatValue{}
}

var _ basetypes.ObjectValuable = CpuStatValue{}

type CpuStatValue struct {
	Idle      basetypes.NumberValue `tfsdk:"idle"`
	Interrupt basetypes.NumberValue `tfsdk:"interrupt"`
	LoadAvg   basetypes.ListValue   `tfsdk:"load_avg"`
	System    basetypes.NumberValue `tfsdk:"system"`
	User      basetypes.NumberValue `tfsdk:"user"`
	state     attr.ValueState
}

func (v CpuStatValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["idle"] = basetypes.NumberType{}.TerraformType(ctx)
	attrTypes["interrupt"] = basetypes.NumberType{}.TerraformType(ctx)
	attrTypes["load_avg"] = basetypes.ListType{
		ElemType: types.NumberType,
	}.TerraformType(ctx)
	attrTypes["system"] = basetypes.NumberType{}.TerraformType(ctx)
	attrTypes["user"] = basetypes.NumberType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.Idle.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["idle"] = val

		val, err = v.Interrupt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["interrupt"] = val

		val, err = v.LoadAvg.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["load_avg"] = val

		val, err = v.System.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["system"] = val

		val, err = v.User.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["user"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v CpuStatValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v CpuStatValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v CpuStatValue) String() string {
	return "CpuStatValue"
}

func (v CpuStatValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	loadAvgVal, d := types.ListValue(types.NumberType, v.LoadAvg.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"idle":      basetypes.NumberType{},
			"interrupt": basetypes.NumberType{},
			"load_avg": basetypes.ListType{
				ElemType: types.NumberType,
			},
			"system": basetypes.NumberType{},
			"user":   basetypes.NumberType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"idle":      basetypes.NumberType{},
		"interrupt": basetypes.NumberType{},
		"load_avg": basetypes.ListType{
			ElemType: types.NumberType,
		},
		"system": basetypes.NumberType{},
		"user":   basetypes.NumberType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"idle":      v.Idle,
			"interrupt": v.Interrupt,
			"load_avg":  loadAvgVal,
			"system":    v.System,
			"user":      v.User,
		})

	return objVal, diags
}

func (v CpuStatValue) Equal(o attr.Value) bool {
	other, ok := o.(CpuStatValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Idle.Equal(other.Idle) {
		return false
	}

	if !v.Interrupt.Equal(other.Interrupt) {
		return false
	}

	if !v.LoadAvg.Equal(other.LoadAvg) {
		return false
	}

	if !v.System.Equal(other.System) {
		return false
	}

	if !v.User.Equal(other.User) {
		return false
	}

	return true
}

func (v CpuStatValue) Type(ctx context.Context) attr.Type {
	return CpuStatType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v CpuStatValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"idle":      basetypes.NumberType{},
		"interrupt": basetypes.NumberType{},
		"load_avg": basetypes.ListType{
			ElemType: types.NumberType,
		},
		"system": basetypes.NumberType{},
		"user":   basetypes.NumberType{},
	}
}






















var _ basetypes.ObjectTypable = DhcpdStatType{}

type DhcpdStatType struct {
	basetypes.ObjectType
}

func (t DhcpdStatType) Equal(o attr.Type) bool {
	other, ok := o.(DhcpdStatType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t DhcpdStatType) String() string {
	return "DhcpdStatType"
}

func (t DhcpdStatType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	numIpsAttribute, ok := attributes["num_ips"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`num_ips is missing from object`)

		return nil, diags
	}

	numIpsVal, ok := numIpsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`num_ips expected to be basetypes.Int64Value, was: %T`, numIpsAttribute))
	}

	numLeasedAttribute, ok := attributes["num_leased"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`num_leased is missing from object`)

		return nil, diags
	}

	numLeasedVal, ok := numLeasedAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`num_leased expected to be basetypes.Int64Value, was: %T`, numLeasedAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return DhcpdStatValue{
		NumIps:    numIpsVal,
		NumLeased: numLeasedVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewDhcpdStatValueNull() DhcpdStatValue {
	return DhcpdStatValue{
		state: attr.ValueStateNull,
	}
}

func NewDhcpdStatValueUnknown() DhcpdStatValue {
	return DhcpdStatValue{
		state: attr.ValueStateUnknown,
	}
}

func NewDhcpdStatValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (DhcpdStatValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing DhcpdStatValue Attribute Value",
				"While creating a DhcpdStatValue value, a missing attribute value was detected. "+
					"A DhcpdStatValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DhcpdStatValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid DhcpdStatValue Attribute Type",
				"While creating a DhcpdStatValue value, an invalid attribute value was detected. "+
					"A DhcpdStatValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DhcpdStatValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("DhcpdStatValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra DhcpdStatValue Attribute Value",
				"While creating a DhcpdStatValue value, an extra attribute value was detected. "+
					"A DhcpdStatValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra DhcpdStatValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewDhcpdStatValueUnknown(), diags
	}

	numIpsAttribute, ok := attributes["num_ips"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`num_ips is missing from object`)

		return NewDhcpdStatValueUnknown(), diags
	}

	numIpsVal, ok := numIpsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`num_ips expected to be basetypes.Int64Value, was: %T`, numIpsAttribute))
	}

	numLeasedAttribute, ok := attributes["num_leased"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`num_leased is missing from object`)

		return NewDhcpdStatValueUnknown(), diags
	}

	numLeasedVal, ok := numLeasedAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`num_leased expected to be basetypes.Int64Value, was: %T`, numLeasedAttribute))
	}

	if diags.HasError() {
		return NewDhcpdStatValueUnknown(), diags
	}

	return DhcpdStatValue{
		NumIps:    numIpsVal,
		NumLeased: numLeasedVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewDhcpdStatValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) DhcpdStatValue {
	object, diags := NewDhcpdStatValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewDhcpdStatValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t DhcpdStatType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewDhcpdStatValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewDhcpdStatValueUnknown(), nil
	}

	if in.IsNull() {
		return NewDhcpdStatValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewDhcpdStatValueMust(DhcpdStatValue{}.AttributeTypes(ctx), attributes), nil
}

func (t DhcpdStatType) ValueType(ctx context.Context) attr.Value {
	return DhcpdStatValue{}
}

var _ basetypes.ObjectValuable = DhcpdStatValue{}

type DhcpdStatValue struct {
	NumIps    basetypes.Int64Value `tfsdk:"num_ips"`
	NumLeased basetypes.Int64Value `tfsdk:"num_leased"`
	state     attr.ValueState
}

func (v DhcpdStatValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["num_ips"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["num_leased"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.NumIps.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["num_ips"] = val

		val, err = v.NumLeased.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["num_leased"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v DhcpdStatValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v DhcpdStatValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v DhcpdStatValue) String() string {
	return "DhcpdStatValue"
}

func (v DhcpdStatValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"num_ips":    basetypes.Int64Type{},
		"num_leased": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"num_ips":    v.NumIps,
			"num_leased": v.NumLeased,
		})

	return objVal, diags
}

func (v DhcpdStatValue) Equal(o attr.Value) bool {
	other, ok := o.(DhcpdStatValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.NumIps.Equal(other.NumIps) {
		return false
	}

	if !v.NumLeased.Equal(other.NumLeased) {
		return false
	}

	return true
}

func (v DhcpdStatValue) Type(ctx context.Context) attr.Type {
	return DhcpdStatType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v DhcpdStatValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"num_ips":    basetypes.Int64Type{},
		"num_leased": basetypes.Int64Type{},
	}
}






















var _ basetypes.ObjectTypable = FwupdateType{}

type FwupdateType struct {
	basetypes.ObjectType
}

func (t FwupdateType) Equal(o attr.Type) bool {
	other, ok := o.(FwupdateType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t FwupdateType) String() string {
	return "FwupdateType"
}

func (t FwupdateType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	progressAttribute, ok := attributes["progress"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`progress is missing from object`)

		return nil, diags
	}

	progressVal, ok := progressAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`progress expected to be basetypes.Int64Value, was: %T`, progressAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return nil, diags
	}

	statusVal, ok := statusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be basetypes.StringValue, was: %T`, statusAttribute))
	}

	statusIdAttribute, ok := attributes["status_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status_id is missing from object`)

		return nil, diags
	}

	statusIdVal, ok := statusIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status_id expected to be basetypes.Int64Value, was: %T`, statusIdAttribute))
	}

	timestampAttribute, ok := attributes["timestamp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`timestamp is missing from object`)

		return nil, diags
	}

	timestampVal, ok := timestampAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`timestamp expected to be basetypes.Float64Value, was: %T`, timestampAttribute))
	}

	willRetryAttribute, ok := attributes["will_retry"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`will_retry is missing from object`)

		return nil, diags
	}

	willRetryVal, ok := willRetryAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`will_retry expected to be basetypes.BoolValue, was: %T`, willRetryAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return FwupdateValue{
		Progress:  progressVal,
		Status:    statusVal,
		StatusId:  statusIdVal,
		Timestamp: timestampVal,
		WillRetry: willRetryVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewFwupdateValueNull() FwupdateValue {
	return FwupdateValue{
		state: attr.ValueStateNull,
	}
}

func NewFwupdateValueUnknown() FwupdateValue {
	return FwupdateValue{
		state: attr.ValueStateUnknown,
	}
}

func NewFwupdateValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (FwupdateValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing FwupdateValue Attribute Value",
				"While creating a FwupdateValue value, a missing attribute value was detected. "+
					"A FwupdateValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("FwupdateValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid FwupdateValue Attribute Type",
				"While creating a FwupdateValue value, an invalid attribute value was detected. "+
					"A FwupdateValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("FwupdateValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("FwupdateValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra FwupdateValue Attribute Value",
				"While creating a FwupdateValue value, an extra attribute value was detected. "+
					"A FwupdateValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra FwupdateValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewFwupdateValueUnknown(), diags
	}

	progressAttribute, ok := attributes["progress"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`progress is missing from object`)

		return NewFwupdateValueUnknown(), diags
	}

	progressVal, ok := progressAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`progress expected to be basetypes.Int64Value, was: %T`, progressAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return NewFwupdateValueUnknown(), diags
	}

	statusVal, ok := statusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be basetypes.StringValue, was: %T`, statusAttribute))
	}

	statusIdAttribute, ok := attributes["status_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status_id is missing from object`)

		return NewFwupdateValueUnknown(), diags
	}

	statusIdVal, ok := statusIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status_id expected to be basetypes.Int64Value, was: %T`, statusIdAttribute))
	}

	timestampAttribute, ok := attributes["timestamp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`timestamp is missing from object`)

		return NewFwupdateValueUnknown(), diags
	}

	timestampVal, ok := timestampAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`timestamp expected to be basetypes.Float64Value, was: %T`, timestampAttribute))
	}

	willRetryAttribute, ok := attributes["will_retry"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`will_retry is missing from object`)

		return NewFwupdateValueUnknown(), diags
	}

	willRetryVal, ok := willRetryAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`will_retry expected to be basetypes.BoolValue, was: %T`, willRetryAttribute))
	}

	if diags.HasError() {
		return NewFwupdateValueUnknown(), diags
	}

	return FwupdateValue{
		Progress:  progressVal,
		Status:    statusVal,
		StatusId:  statusIdVal,
		Timestamp: timestampVal,
		WillRetry: willRetryVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewFwupdateValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) FwupdateValue {
	object, diags := NewFwupdateValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewFwupdateValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t FwupdateType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewFwupdateValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewFwupdateValueUnknown(), nil
	}

	if in.IsNull() {
		return NewFwupdateValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewFwupdateValueMust(FwupdateValue{}.AttributeTypes(ctx), attributes), nil
}

func (t FwupdateType) ValueType(ctx context.Context) attr.Value {
	return FwupdateValue{}
}

var _ basetypes.ObjectValuable = FwupdateValue{}

type FwupdateValue struct {
	Progress  basetypes.Int64Value   `tfsdk:"progress"`
	Status    basetypes.StringValue  `tfsdk:"status"`
	StatusId  basetypes.Int64Value   `tfsdk:"status_id"`
	Timestamp basetypes.Float64Value `tfsdk:"timestamp"`
	WillRetry basetypes.BoolValue    `tfsdk:"will_retry"`
	state     attr.ValueState
}

func (v FwupdateValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["progress"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["status"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["status_id"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["timestamp"] = basetypes.Float64Type{}.TerraformType(ctx)
	attrTypes["will_retry"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.Progress.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["progress"] = val

		val, err = v.Status.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["status"] = val

		val, err = v.StatusId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["status_id"] = val

		val, err = v.Timestamp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["timestamp"] = val

		val, err = v.WillRetry.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["will_retry"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v FwupdateValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v FwupdateValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v FwupdateValue) String() string {
	return "FwupdateValue"
}

func (v FwupdateValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"progress":   basetypes.Int64Type{},
		"status":     basetypes.StringType{},
		"status_id":  basetypes.Int64Type{},
		"timestamp":  basetypes.Float64Type{},
		"will_retry": basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"progress":   v.Progress,
			"status":     v.Status,
			"status_id":  v.StatusId,
			"timestamp":  v.Timestamp,
			"will_retry": v.WillRetry,
		})

	return objVal, diags
}

func (v FwupdateValue) Equal(o attr.Value) bool {
	other, ok := o.(FwupdateValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Progress.Equal(other.Progress) {
		return false
	}

	if !v.Status.Equal(other.Status) {
		return false
	}

	if !v.StatusId.Equal(other.StatusId) {
		return false
	}

	if !v.Timestamp.Equal(other.Timestamp) {
		return false
	}

	if !v.WillRetry.Equal(other.WillRetry) {
		return false
	}

	return true
}

func (v FwupdateValue) Type(ctx context.Context) attr.Type {
	return FwupdateType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v FwupdateValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"progress":   basetypes.Int64Type{},
		"status":     basetypes.StringType{},
		"status_id":  basetypes.Int64Type{},
		"timestamp":  basetypes.Float64Type{},
		"will_retry": basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = IfStatType{}

type IfStatType struct {
	basetypes.ObjectType
}

func (t IfStatType) Equal(o attr.Type) bool {
	other, ok := o.(IfStatType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t IfStatType) String() string {
	return "IfStatType"
}

func (t IfStatType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	addressModeAttribute, ok := attributes["address_mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`address_mode is missing from object`)

		return nil, diags
	}

	addressModeVal, ok := addressModeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`address_mode expected to be basetypes.StringValue, was: %T`, addressModeAttribute))
	}

	ipsAttribute, ok := attributes["ips"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ips is missing from object`)

		return nil, diags
	}

	ipsVal, ok := ipsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ips expected to be basetypes.ListValue, was: %T`, ipsAttribute))
	}

	natAddressesAttribute, ok := attributes["nat_addresses"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`nat_addresses is missing from object`)

		return nil, diags
	}

	natAddressesVal, ok := natAddressesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`nat_addresses expected to be basetypes.ListValue, was: %T`, natAddressesAttribute))
	}

	networkNameAttribute, ok := attributes["network_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`network_name is missing from object`)

		return nil, diags
	}

	networkNameVal, ok := networkNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`network_name expected to be basetypes.StringValue, was: %T`, networkNameAttribute))
	}

	portIdAttribute, ok := attributes["port_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_id is missing from object`)

		return nil, diags
	}

	portIdVal, ok := portIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_id expected to be basetypes.StringValue, was: %T`, portIdAttribute))
	}

	portUsageAttribute, ok := attributes["port_usage"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_usage is missing from object`)

		return nil, diags
	}

	portUsageVal, ok := portUsageAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_usage expected to be basetypes.StringValue, was: %T`, portUsageAttribute))
	}

	redundancyStateAttribute, ok := attributes["redundancy_state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`redundancy_state is missing from object`)

		return nil, diags
	}

	redundancyStateVal, ok := redundancyStateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`redundancy_state expected to be basetypes.StringValue, was: %T`, redundancyStateAttribute))
	}

	rxBytesAttribute, ok := attributes["rx_bytes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rx_bytes is missing from object`)

		return nil, diags
	}

	rxBytesVal, ok := rxBytesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rx_bytes expected to be basetypes.Int64Value, was: %T`, rxBytesAttribute))
	}

	rxPktsAttribute, ok := attributes["rx_pkts"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rx_pkts is missing from object`)

		return nil, diags
	}

	rxPktsVal, ok := rxPktsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rx_pkts expected to be basetypes.Int64Value, was: %T`, rxPktsAttribute))
	}

	servpInfoAttribute, ok := attributes["servp_info"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`servp_info is missing from object`)

		return nil, diags
	}

	servpInfoVal, ok := servpInfoAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`servp_info expected to be basetypes.ObjectValue, was: %T`, servpInfoAttribute))
	}

	txBytesAttribute, ok := attributes["tx_bytes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tx_bytes is missing from object`)

		return nil, diags
	}

	txBytesVal, ok := txBytesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tx_bytes expected to be basetypes.Int64Value, was: %T`, txBytesAttribute))
	}

	txPktsAttribute, ok := attributes["tx_pkts"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tx_pkts is missing from object`)

		return nil, diags
	}

	txPktsVal, ok := txPktsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tx_pkts expected to be basetypes.Int64Value, was: %T`, txPktsAttribute))
	}

	upAttribute, ok := attributes["up"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`up is missing from object`)

		return nil, diags
	}

	upVal, ok := upAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`up expected to be basetypes.BoolValue, was: %T`, upAttribute))
	}

	vlanAttribute, ok := attributes["vlan"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan is missing from object`)

		return nil, diags
	}

	vlanVal, ok := vlanAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan expected to be basetypes.Int64Value, was: %T`, vlanAttribute))
	}

	wanNameAttribute, ok := attributes["wan_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wan_name is missing from object`)

		return nil, diags
	}

	wanNameVal, ok := wanNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wan_name expected to be basetypes.StringValue, was: %T`, wanNameAttribute))
	}

	wanTypeAttribute, ok := attributes["wan_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wan_type is missing from object`)

		return nil, diags
	}

	wanTypeVal, ok := wanTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wan_type expected to be basetypes.StringValue, was: %T`, wanTypeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return IfStatValue{
		AddressMode:     addressModeVal,
		Ips:             ipsVal,
		NatAddresses:    natAddressesVal,
		NetworkName:     networkNameVal,
		PortId:          portIdVal,
		PortUsage:       portUsageVal,
		RedundancyState: redundancyStateVal,
		RxBytes:         rxBytesVal,
		RxPkts:          rxPktsVal,
		ServpInfo:       servpInfoVal,
		TxBytes:         txBytesVal,
		TxPkts:          txPktsVal,
		Up:              upVal,
		Vlan:            vlanVal,
		WanName:         wanNameVal,
		WanType:         wanTypeVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewIfStatValueNull() IfStatValue {
	return IfStatValue{
		state: attr.ValueStateNull,
	}
}

func NewIfStatValueUnknown() IfStatValue {
	return IfStatValue{
		state: attr.ValueStateUnknown,
	}
}

func NewIfStatValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (IfStatValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing IfStatValue Attribute Value",
				"While creating a IfStatValue value, a missing attribute value was detected. "+
					"A IfStatValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("IfStatValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid IfStatValue Attribute Type",
				"While creating a IfStatValue value, an invalid attribute value was detected. "+
					"A IfStatValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("IfStatValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("IfStatValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra IfStatValue Attribute Value",
				"While creating a IfStatValue value, an extra attribute value was detected. "+
					"A IfStatValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra IfStatValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewIfStatValueUnknown(), diags
	}

	addressModeAttribute, ok := attributes["address_mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`address_mode is missing from object`)

		return NewIfStatValueUnknown(), diags
	}

	addressModeVal, ok := addressModeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`address_mode expected to be basetypes.StringValue, was: %T`, addressModeAttribute))
	}

	ipsAttribute, ok := attributes["ips"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ips is missing from object`)

		return NewIfStatValueUnknown(), diags
	}

	ipsVal, ok := ipsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ips expected to be basetypes.ListValue, was: %T`, ipsAttribute))
	}

	natAddressesAttribute, ok := attributes["nat_addresses"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`nat_addresses is missing from object`)

		return NewIfStatValueUnknown(), diags
	}

	natAddressesVal, ok := natAddressesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`nat_addresses expected to be basetypes.ListValue, was: %T`, natAddressesAttribute))
	}

	networkNameAttribute, ok := attributes["network_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`network_name is missing from object`)

		return NewIfStatValueUnknown(), diags
	}

	networkNameVal, ok := networkNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`network_name expected to be basetypes.StringValue, was: %T`, networkNameAttribute))
	}

	portIdAttribute, ok := attributes["port_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_id is missing from object`)

		return NewIfStatValueUnknown(), diags
	}

	portIdVal, ok := portIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_id expected to be basetypes.StringValue, was: %T`, portIdAttribute))
	}

	portUsageAttribute, ok := attributes["port_usage"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_usage is missing from object`)

		return NewIfStatValueUnknown(), diags
	}

	portUsageVal, ok := portUsageAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_usage expected to be basetypes.StringValue, was: %T`, portUsageAttribute))
	}

	redundancyStateAttribute, ok := attributes["redundancy_state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`redundancy_state is missing from object`)

		return NewIfStatValueUnknown(), diags
	}

	redundancyStateVal, ok := redundancyStateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`redundancy_state expected to be basetypes.StringValue, was: %T`, redundancyStateAttribute))
	}

	rxBytesAttribute, ok := attributes["rx_bytes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rx_bytes is missing from object`)

		return NewIfStatValueUnknown(), diags
	}

	rxBytesVal, ok := rxBytesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rx_bytes expected to be basetypes.Int64Value, was: %T`, rxBytesAttribute))
	}

	rxPktsAttribute, ok := attributes["rx_pkts"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rx_pkts is missing from object`)

		return NewIfStatValueUnknown(), diags
	}

	rxPktsVal, ok := rxPktsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rx_pkts expected to be basetypes.Int64Value, was: %T`, rxPktsAttribute))
	}

	servpInfoAttribute, ok := attributes["servp_info"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`servp_info is missing from object`)

		return NewIfStatValueUnknown(), diags
	}

	servpInfoVal, ok := servpInfoAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`servp_info expected to be basetypes.ObjectValue, was: %T`, servpInfoAttribute))
	}

	txBytesAttribute, ok := attributes["tx_bytes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tx_bytes is missing from object`)

		return NewIfStatValueUnknown(), diags
	}

	txBytesVal, ok := txBytesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tx_bytes expected to be basetypes.Int64Value, was: %T`, txBytesAttribute))
	}

	txPktsAttribute, ok := attributes["tx_pkts"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tx_pkts is missing from object`)

		return NewIfStatValueUnknown(), diags
	}

	txPktsVal, ok := txPktsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tx_pkts expected to be basetypes.Int64Value, was: %T`, txPktsAttribute))
	}

	upAttribute, ok := attributes["up"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`up is missing from object`)

		return NewIfStatValueUnknown(), diags
	}

	upVal, ok := upAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`up expected to be basetypes.BoolValue, was: %T`, upAttribute))
	}

	vlanAttribute, ok := attributes["vlan"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan is missing from object`)

		return NewIfStatValueUnknown(), diags
	}

	vlanVal, ok := vlanAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan expected to be basetypes.Int64Value, was: %T`, vlanAttribute))
	}

	wanNameAttribute, ok := attributes["wan_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wan_name is missing from object`)

		return NewIfStatValueUnknown(), diags
	}

	wanNameVal, ok := wanNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wan_name expected to be basetypes.StringValue, was: %T`, wanNameAttribute))
	}

	wanTypeAttribute, ok := attributes["wan_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wan_type is missing from object`)

		return NewIfStatValueUnknown(), diags
	}

	wanTypeVal, ok := wanTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wan_type expected to be basetypes.StringValue, was: %T`, wanTypeAttribute))
	}

	if diags.HasError() {
		return NewIfStatValueUnknown(), diags
	}

	return IfStatValue{
		AddressMode:     addressModeVal,
		Ips:             ipsVal,
		NatAddresses:    natAddressesVal,
		NetworkName:     networkNameVal,
		PortId:          portIdVal,
		PortUsage:       portUsageVal,
		RedundancyState: redundancyStateVal,
		RxBytes:         rxBytesVal,
		RxPkts:          rxPktsVal,
		ServpInfo:       servpInfoVal,
		TxBytes:         txBytesVal,
		TxPkts:          txPktsVal,
		Up:              upVal,
		Vlan:            vlanVal,
		WanName:         wanNameVal,
		WanType:         wanTypeVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewIfStatValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) IfStatValue {
	object, diags := NewIfStatValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewIfStatValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t IfStatType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewIfStatValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewIfStatValueUnknown(), nil
	}

	if in.IsNull() {
		return NewIfStatValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewIfStatValueMust(IfStatValue{}.AttributeTypes(ctx), attributes), nil
}

func (t IfStatType) ValueType(ctx context.Context) attr.Value {
	return IfStatValue{}
}

var _ basetypes.ObjectValuable = IfStatValue{}

type IfStatValue struct {
	AddressMode     basetypes.StringValue `tfsdk:"address_mode"`
	Ips             basetypes.ListValue   `tfsdk:"ips"`
	NatAddresses    basetypes.ListValue   `tfsdk:"nat_addresses"`
	NetworkName     basetypes.StringValue `tfsdk:"network_name"`
	PortId          basetypes.StringValue `tfsdk:"port_id"`
	PortUsage       basetypes.StringValue `tfsdk:"port_usage"`
	RedundancyState basetypes.StringValue `tfsdk:"redundancy_state"`
	RxBytes         basetypes.Int64Value  `tfsdk:"rx_bytes"`
	RxPkts          basetypes.Int64Value  `tfsdk:"rx_pkts"`
	ServpInfo       basetypes.ObjectValue `tfsdk:"servp_info"`
	TxBytes         basetypes.Int64Value  `tfsdk:"tx_bytes"`
	TxPkts          basetypes.Int64Value  `tfsdk:"tx_pkts"`
	Up              basetypes.BoolValue   `tfsdk:"up"`
	Vlan            basetypes.Int64Value  `tfsdk:"vlan"`
	WanName         basetypes.StringValue `tfsdk:"wan_name"`
	WanType         basetypes.StringValue `tfsdk:"wan_type"`
	state           attr.ValueState
}

func (v IfStatValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 16)

	var val tftypes.Value
	var err error

	attrTypes["address_mode"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ips"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["nat_addresses"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["network_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["port_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["port_usage"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["redundancy_state"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["rx_bytes"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["rx_pkts"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["servp_info"] = basetypes.ObjectType{
		AttrTypes: ServpInfoValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["tx_bytes"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["tx_pkts"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["up"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["vlan"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["wan_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["wan_type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 16)

		val, err = v.AddressMode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["address_mode"] = val

		val, err = v.Ips.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ips"] = val

		val, err = v.NatAddresses.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["nat_addresses"] = val

		val, err = v.NetworkName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["network_name"] = val

		val, err = v.PortId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port_id"] = val

		val, err = v.PortUsage.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port_usage"] = val

		val, err = v.RedundancyState.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["redundancy_state"] = val

		val, err = v.RxBytes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["rx_bytes"] = val

		val, err = v.RxPkts.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["rx_pkts"] = val

		val, err = v.ServpInfo.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["servp_info"] = val

		val, err = v.TxBytes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tx_bytes"] = val

		val, err = v.TxPkts.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tx_pkts"] = val

		val, err = v.Up.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["up"] = val

		val, err = v.Vlan.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vlan"] = val

		val, err = v.WanName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["wan_name"] = val

		val, err = v.WanType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["wan_type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v IfStatValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v IfStatValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v IfStatValue) String() string {
	return "IfStatValue"
}

func (v IfStatValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var servpInfo basetypes.ObjectValue

	if v.ServpInfo.IsNull() {
		servpInfo = types.ObjectNull(
			ServpInfoValue{}.AttributeTypes(ctx),
		)
	}

	if v.ServpInfo.IsUnknown() {
		servpInfo = types.ObjectUnknown(
			ServpInfoValue{}.AttributeTypes(ctx),
		)
	}

	if !v.ServpInfo.IsNull() && !v.ServpInfo.IsUnknown() {
		servpInfo = types.ObjectValueMust(
			ServpInfoValue{}.AttributeTypes(ctx),
			v.ServpInfo.Attributes(),
		)
	}

	ipsVal, d := types.ListValue(types.StringType, v.Ips.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"address_mode": basetypes.StringType{},
			"ips": basetypes.ListType{
				ElemType: types.StringType,
			},
			"nat_addresses": basetypes.ListType{
				ElemType: types.StringType,
			},
			"network_name":     basetypes.StringType{},
			"port_id":          basetypes.StringType{},
			"port_usage":       basetypes.StringType{},
			"redundancy_state": basetypes.StringType{},
			"rx_bytes":         basetypes.Int64Type{},
			"rx_pkts":          basetypes.Int64Type{},
			"servp_info": basetypes.ObjectType{
				AttrTypes: ServpInfoValue{}.AttributeTypes(ctx),
			},
			"tx_bytes": basetypes.Int64Type{},
			"tx_pkts":  basetypes.Int64Type{},
			"up":       basetypes.BoolType{},
			"vlan":     basetypes.Int64Type{},
			"wan_name": basetypes.StringType{},
			"wan_type": basetypes.StringType{},
		}), diags
	}

	natAddressesVal, d := types.ListValue(types.StringType, v.NatAddresses.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"address_mode": basetypes.StringType{},
			"ips": basetypes.ListType{
				ElemType: types.StringType,
			},
			"nat_addresses": basetypes.ListType{
				ElemType: types.StringType,
			},
			"network_name":     basetypes.StringType{},
			"port_id":          basetypes.StringType{},
			"port_usage":       basetypes.StringType{},
			"redundancy_state": basetypes.StringType{},
			"rx_bytes":         basetypes.Int64Type{},
			"rx_pkts":          basetypes.Int64Type{},
			"servp_info": basetypes.ObjectType{
				AttrTypes: ServpInfoValue{}.AttributeTypes(ctx),
			},
			"tx_bytes": basetypes.Int64Type{},
			"tx_pkts":  basetypes.Int64Type{},
			"up":       basetypes.BoolType{},
			"vlan":     basetypes.Int64Type{},
			"wan_name": basetypes.StringType{},
			"wan_type": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"address_mode": basetypes.StringType{},
		"ips": basetypes.ListType{
			ElemType: types.StringType,
		},
		"nat_addresses": basetypes.ListType{
			ElemType: types.StringType,
		},
		"network_name":     basetypes.StringType{},
		"port_id":          basetypes.StringType{},
		"port_usage":       basetypes.StringType{},
		"redundancy_state": basetypes.StringType{},
		"rx_bytes":         basetypes.Int64Type{},
		"rx_pkts":          basetypes.Int64Type{},
		"servp_info": basetypes.ObjectType{
			AttrTypes: ServpInfoValue{}.AttributeTypes(ctx),
		},
		"tx_bytes": basetypes.Int64Type{},
		"tx_pkts":  basetypes.Int64Type{},
		"up":       basetypes.BoolType{},
		"vlan":     basetypes.Int64Type{},
		"wan_name": basetypes.StringType{},
		"wan_type": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"address_mode":     v.AddressMode,
			"ips":              ipsVal,
			"nat_addresses":    natAddressesVal,
			"network_name":     v.NetworkName,
			"port_id":          v.PortId,
			"port_usage":       v.PortUsage,
			"redundancy_state": v.RedundancyState,
			"rx_bytes":         v.RxBytes,
			"rx_pkts":          v.RxPkts,
			"servp_info":       servpInfo,
			"tx_bytes":         v.TxBytes,
			"tx_pkts":          v.TxPkts,
			"up":               v.Up,
			"vlan":             v.Vlan,
			"wan_name":         v.WanName,
			"wan_type":         v.WanType,
		})

	return objVal, diags
}

func (v IfStatValue) Equal(o attr.Value) bool {
	other, ok := o.(IfStatValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AddressMode.Equal(other.AddressMode) {
		return false
	}

	if !v.Ips.Equal(other.Ips) {
		return false
	}

	if !v.NatAddresses.Equal(other.NatAddresses) {
		return false
	}

	if !v.NetworkName.Equal(other.NetworkName) {
		return false
	}

	if !v.PortId.Equal(other.PortId) {
		return false
	}

	if !v.PortUsage.Equal(other.PortUsage) {
		return false
	}

	if !v.RedundancyState.Equal(other.RedundancyState) {
		return false
	}

	if !v.RxBytes.Equal(other.RxBytes) {
		return false
	}

	if !v.RxPkts.Equal(other.RxPkts) {
		return false
	}

	if !v.ServpInfo.Equal(other.ServpInfo) {
		return false
	}

	if !v.TxBytes.Equal(other.TxBytes) {
		return false
	}

	if !v.TxPkts.Equal(other.TxPkts) {
		return false
	}

	if !v.Up.Equal(other.Up) {
		return false
	}

	if !v.Vlan.Equal(other.Vlan) {
		return false
	}

	if !v.WanName.Equal(other.WanName) {
		return false
	}

	if !v.WanType.Equal(other.WanType) {
		return false
	}

	return true
}

func (v IfStatValue) Type(ctx context.Context) attr.Type {
	return IfStatType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v IfStatValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"address_mode": basetypes.StringType{},
		"ips": basetypes.ListType{
			ElemType: types.StringType,
		},
		"nat_addresses": basetypes.ListType{
			ElemType: types.StringType,
		},
		"network_name":     basetypes.StringType{},
		"port_id":          basetypes.StringType{},
		"port_usage":       basetypes.StringType{},
		"redundancy_state": basetypes.StringType{},
		"rx_bytes":         basetypes.Int64Type{},
		"rx_pkts":          basetypes.Int64Type{},
		"servp_info": basetypes.ObjectType{
			AttrTypes: ServpInfoValue{}.AttributeTypes(ctx),
		},
		"tx_bytes": basetypes.Int64Type{},
		"tx_pkts":  basetypes.Int64Type{},
		"up":       basetypes.BoolType{},
		"vlan":     basetypes.Int64Type{},
		"wan_name": basetypes.StringType{},
		"wan_type": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = ServpInfoType{}

type ServpInfoType struct {
	basetypes.ObjectType
}

func (t ServpInfoType) Equal(o attr.Type) bool {
	other, ok := o.(ServpInfoType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ServpInfoType) String() string {
	return "ServpInfoType"
}

func (t ServpInfoType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	asnAttribute, ok := attributes["asn"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`asn is missing from object`)

		return nil, diags
	}

	asnVal, ok := asnAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`asn expected to be basetypes.StringValue, was: %T`, asnAttribute))
	}

	cityAttribute, ok := attributes["city"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`city is missing from object`)

		return nil, diags
	}

	cityVal, ok := cityAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`city expected to be basetypes.StringValue, was: %T`, cityAttribute))
	}

	countryCodeAttribute, ok := attributes["country_code"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`country_code is missing from object`)

		return nil, diags
	}

	countryCodeVal, ok := countryCodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`country_code expected to be basetypes.StringValue, was: %T`, countryCodeAttribute))
	}

	latitudeAttribute, ok := attributes["latitude"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`latitude is missing from object`)

		return nil, diags
	}

	latitudeVal, ok := latitudeAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`latitude expected to be basetypes.NumberValue, was: %T`, latitudeAttribute))
	}

	longitudeAttribute, ok := attributes["longitude"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`longitude is missing from object`)

		return nil, diags
	}

	longitudeVal, ok := longitudeAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`longitude expected to be basetypes.NumberValue, was: %T`, longitudeAttribute))
	}

	orgAttribute, ok := attributes["org"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`org is missing from object`)

		return nil, diags
	}

	orgVal, ok := orgAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`org expected to be basetypes.StringValue, was: %T`, orgAttribute))
	}

	regionCodeAttribute, ok := attributes["region_code"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`region_code is missing from object`)

		return nil, diags
	}

	regionCodeVal, ok := regionCodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`region_code expected to be basetypes.StringValue, was: %T`, regionCodeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ServpInfoValue{
		Asn:         asnVal,
		City:        cityVal,
		CountryCode: countryCodeVal,
		Latitude:    latitudeVal,
		Longitude:   longitudeVal,
		Org:         orgVal,
		RegionCode:  regionCodeVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewServpInfoValueNull() ServpInfoValue {
	return ServpInfoValue{
		state: attr.ValueStateNull,
	}
}

func NewServpInfoValueUnknown() ServpInfoValue {
	return ServpInfoValue{
		state: attr.ValueStateUnknown,
	}
}

func NewServpInfoValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ServpInfoValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ServpInfoValue Attribute Value",
				"While creating a ServpInfoValue value, a missing attribute value was detected. "+
					"A ServpInfoValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ServpInfoValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ServpInfoValue Attribute Type",
				"While creating a ServpInfoValue value, an invalid attribute value was detected. "+
					"A ServpInfoValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ServpInfoValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ServpInfoValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ServpInfoValue Attribute Value",
				"While creating a ServpInfoValue value, an extra attribute value was detected. "+
					"A ServpInfoValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ServpInfoValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewServpInfoValueUnknown(), diags
	}

	asnAttribute, ok := attributes["asn"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`asn is missing from object`)

		return NewServpInfoValueUnknown(), diags
	}

	asnVal, ok := asnAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`asn expected to be basetypes.StringValue, was: %T`, asnAttribute))
	}

	cityAttribute, ok := attributes["city"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`city is missing from object`)

		return NewServpInfoValueUnknown(), diags
	}

	cityVal, ok := cityAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`city expected to be basetypes.StringValue, was: %T`, cityAttribute))
	}

	countryCodeAttribute, ok := attributes["country_code"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`country_code is missing from object`)

		return NewServpInfoValueUnknown(), diags
	}

	countryCodeVal, ok := countryCodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`country_code expected to be basetypes.StringValue, was: %T`, countryCodeAttribute))
	}

	latitudeAttribute, ok := attributes["latitude"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`latitude is missing from object`)

		return NewServpInfoValueUnknown(), diags
	}

	latitudeVal, ok := latitudeAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`latitude expected to be basetypes.NumberValue, was: %T`, latitudeAttribute))
	}

	longitudeAttribute, ok := attributes["longitude"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`longitude is missing from object`)

		return NewServpInfoValueUnknown(), diags
	}

	longitudeVal, ok := longitudeAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`longitude expected to be basetypes.NumberValue, was: %T`, longitudeAttribute))
	}

	orgAttribute, ok := attributes["org"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`org is missing from object`)

		return NewServpInfoValueUnknown(), diags
	}

	orgVal, ok := orgAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`org expected to be basetypes.StringValue, was: %T`, orgAttribute))
	}

	regionCodeAttribute, ok := attributes["region_code"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`region_code is missing from object`)

		return NewServpInfoValueUnknown(), diags
	}

	regionCodeVal, ok := regionCodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`region_code expected to be basetypes.StringValue, was: %T`, regionCodeAttribute))
	}

	if diags.HasError() {
		return NewServpInfoValueUnknown(), diags
	}

	return ServpInfoValue{
		Asn:         asnVal,
		City:        cityVal,
		CountryCode: countryCodeVal,
		Latitude:    latitudeVal,
		Longitude:   longitudeVal,
		Org:         orgVal,
		RegionCode:  regionCodeVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewServpInfoValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ServpInfoValue {
	object, diags := NewServpInfoValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewServpInfoValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ServpInfoType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewServpInfoValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewServpInfoValueUnknown(), nil
	}

	if in.IsNull() {
		return NewServpInfoValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewServpInfoValueMust(ServpInfoValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ServpInfoType) ValueType(ctx context.Context) attr.Value {
	return ServpInfoValue{}
}

var _ basetypes.ObjectValuable = ServpInfoValue{}

type ServpInfoValue struct {
	Asn         basetypes.StringValue `tfsdk:"asn"`
	City        basetypes.StringValue `tfsdk:"city"`
	CountryCode basetypes.StringValue `tfsdk:"country_code"`
	Latitude    basetypes.NumberValue `tfsdk:"latitude"`
	Longitude   basetypes.NumberValue `tfsdk:"longitude"`
	Org         basetypes.StringValue `tfsdk:"org"`
	RegionCode  basetypes.StringValue `tfsdk:"region_code"`
	state       attr.ValueState
}

func (v ServpInfoValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 7)

	var val tftypes.Value
	var err error

	attrTypes["asn"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["city"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["country_code"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["latitude"] = basetypes.NumberType{}.TerraformType(ctx)
	attrTypes["longitude"] = basetypes.NumberType{}.TerraformType(ctx)
	attrTypes["org"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["region_code"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 7)

		val, err = v.Asn.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["asn"] = val

		val, err = v.City.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["city"] = val

		val, err = v.CountryCode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["country_code"] = val

		val, err = v.Latitude.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["latitude"] = val

		val, err = v.Longitude.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["longitude"] = val

		val, err = v.Org.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["org"] = val

		val, err = v.RegionCode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["region_code"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ServpInfoValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ServpInfoValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ServpInfoValue) String() string {
	return "ServpInfoValue"
}

func (v ServpInfoValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"asn":          basetypes.StringType{},
		"city":         basetypes.StringType{},
		"country_code": basetypes.StringType{},
		"latitude":     basetypes.NumberType{},
		"longitude":    basetypes.NumberType{},
		"org":          basetypes.StringType{},
		"region_code":  basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"asn":          v.Asn,
			"city":         v.City,
			"country_code": v.CountryCode,
			"latitude":     v.Latitude,
			"longitude":    v.Longitude,
			"org":          v.Org,
			"region_code":  v.RegionCode,
		})

	return objVal, diags
}

func (v ServpInfoValue) Equal(o attr.Value) bool {
	other, ok := o.(ServpInfoValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Asn.Equal(other.Asn) {
		return false
	}

	if !v.City.Equal(other.City) {
		return false
	}

	if !v.CountryCode.Equal(other.CountryCode) {
		return false
	}

	if !v.Latitude.Equal(other.Latitude) {
		return false
	}

	if !v.Longitude.Equal(other.Longitude) {
		return false
	}

	if !v.Org.Equal(other.Org) {
		return false
	}

	if !v.RegionCode.Equal(other.RegionCode) {
		return false
	}

	return true
}

func (v ServpInfoValue) Type(ctx context.Context) attr.Type {
	return ServpInfoType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ServpInfoValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"asn":          basetypes.StringType{},
		"city":         basetypes.StringType{},
		"country_code": basetypes.StringType{},
		"latitude":     basetypes.NumberType{},
		"longitude":    basetypes.NumberType{},
		"org":          basetypes.StringType{},
		"region_code":  basetypes.StringType{},
	}
}











































var _ basetypes.ObjectTypable = IpStatType{}

type IpStatType struct {
	basetypes.ObjectType
}

func (t IpStatType) Equal(o attr.Type) bool {
	other, ok := o.(IpStatType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t IpStatType) String() string {
	return "IpStatType"
}

func (t IpStatType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	dhcpServerAttribute, ok := attributes["dhcp_server"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dhcp_server is missing from object`)

		return nil, diags
	}

	dhcpServerVal, ok := dhcpServerAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dhcp_server expected to be basetypes.StringValue, was: %T`, dhcpServerAttribute))
	}

	dnsAttribute, ok := attributes["dns"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dns is missing from object`)

		return nil, diags
	}

	dnsVal, ok := dnsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dns expected to be basetypes.ListValue, was: %T`, dnsAttribute))
	}

	dnsSuffixAttribute, ok := attributes["dns_suffix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dns_suffix is missing from object`)

		return nil, diags
	}

	dnsSuffixVal, ok := dnsSuffixAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dns_suffix expected to be basetypes.ListValue, was: %T`, dnsSuffixAttribute))
	}

	gatewayAttribute, ok := attributes["gateway"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gateway is missing from object`)

		return nil, diags
	}

	gatewayVal, ok := gatewayAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gateway expected to be basetypes.StringValue, was: %T`, gatewayAttribute))
	}

	gateway6Attribute, ok := attributes["gateway6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gateway6 is missing from object`)

		return nil, diags
	}

	gateway6Val, ok := gateway6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gateway6 expected to be basetypes.StringValue, was: %T`, gateway6Attribute))
	}

	ipAttribute, ok := attributes["ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip is missing from object`)

		return nil, diags
	}

	ipVal, ok := ipAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip expected to be basetypes.StringValue, was: %T`, ipAttribute))
	}

	ip6Attribute, ok := attributes["ip6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip6 is missing from object`)

		return nil, diags
	}

	ip6Val, ok := ip6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip6 expected to be basetypes.StringValue, was: %T`, ip6Attribute))
	}

	ipsAttribute, ok := attributes["ips"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ips is missing from object`)

		return nil, diags
	}

	ipsVal, ok := ipsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ips expected to be basetypes.MapValue, was: %T`, ipsAttribute))
	}

	netmaskAttribute, ok := attributes["netmask"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`netmask is missing from object`)

		return nil, diags
	}

	netmaskVal, ok := netmaskAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`netmask expected to be basetypes.StringValue, was: %T`, netmaskAttribute))
	}

	netmask6Attribute, ok := attributes["netmask6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`netmask6 is missing from object`)

		return nil, diags
	}

	netmask6Val, ok := netmask6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`netmask6 expected to be basetypes.StringValue, was: %T`, netmask6Attribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return IpStatValue{
		DhcpServer: dhcpServerVal,
		Dns:        dnsVal,
		DnsSuffix:  dnsSuffixVal,
		Gateway:    gatewayVal,
		Gateway6:   gateway6Val,
		Ip:         ipVal,
		Ip6:        ip6Val,
		Ips:        ipsVal,
		Netmask:    netmaskVal,
		Netmask6:   netmask6Val,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewIpStatValueNull() IpStatValue {
	return IpStatValue{
		state: attr.ValueStateNull,
	}
}

func NewIpStatValueUnknown() IpStatValue {
	return IpStatValue{
		state: attr.ValueStateUnknown,
	}
}

func NewIpStatValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (IpStatValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing IpStatValue Attribute Value",
				"While creating a IpStatValue value, a missing attribute value was detected. "+
					"A IpStatValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("IpStatValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid IpStatValue Attribute Type",
				"While creating a IpStatValue value, an invalid attribute value was detected. "+
					"A IpStatValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("IpStatValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("IpStatValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra IpStatValue Attribute Value",
				"While creating a IpStatValue value, an extra attribute value was detected. "+
					"A IpStatValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra IpStatValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewIpStatValueUnknown(), diags
	}

	dhcpServerAttribute, ok := attributes["dhcp_server"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dhcp_server is missing from object`)

		return NewIpStatValueUnknown(), diags
	}

	dhcpServerVal, ok := dhcpServerAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dhcp_server expected to be basetypes.StringValue, was: %T`, dhcpServerAttribute))
	}

	dnsAttribute, ok := attributes["dns"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dns is missing from object`)

		return NewIpStatValueUnknown(), diags
	}

	dnsVal, ok := dnsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dns expected to be basetypes.ListValue, was: %T`, dnsAttribute))
	}

	dnsSuffixAttribute, ok := attributes["dns_suffix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dns_suffix is missing from object`)

		return NewIpStatValueUnknown(), diags
	}

	dnsSuffixVal, ok := dnsSuffixAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dns_suffix expected to be basetypes.ListValue, was: %T`, dnsSuffixAttribute))
	}

	gatewayAttribute, ok := attributes["gateway"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gateway is missing from object`)

		return NewIpStatValueUnknown(), diags
	}

	gatewayVal, ok := gatewayAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gateway expected to be basetypes.StringValue, was: %T`, gatewayAttribute))
	}

	gateway6Attribute, ok := attributes["gateway6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gateway6 is missing from object`)

		return NewIpStatValueUnknown(), diags
	}

	gateway6Val, ok := gateway6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gateway6 expected to be basetypes.StringValue, was: %T`, gateway6Attribute))
	}

	ipAttribute, ok := attributes["ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip is missing from object`)

		return NewIpStatValueUnknown(), diags
	}

	ipVal, ok := ipAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip expected to be basetypes.StringValue, was: %T`, ipAttribute))
	}

	ip6Attribute, ok := attributes["ip6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip6 is missing from object`)

		return NewIpStatValueUnknown(), diags
	}

	ip6Val, ok := ip6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip6 expected to be basetypes.StringValue, was: %T`, ip6Attribute))
	}

	ipsAttribute, ok := attributes["ips"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ips is missing from object`)

		return NewIpStatValueUnknown(), diags
	}

	ipsVal, ok := ipsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ips expected to be basetypes.MapValue, was: %T`, ipsAttribute))
	}

	netmaskAttribute, ok := attributes["netmask"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`netmask is missing from object`)

		return NewIpStatValueUnknown(), diags
	}

	netmaskVal, ok := netmaskAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`netmask expected to be basetypes.StringValue, was: %T`, netmaskAttribute))
	}

	netmask6Attribute, ok := attributes["netmask6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`netmask6 is missing from object`)

		return NewIpStatValueUnknown(), diags
	}

	netmask6Val, ok := netmask6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`netmask6 expected to be basetypes.StringValue, was: %T`, netmask6Attribute))
	}

	if diags.HasError() {
		return NewIpStatValueUnknown(), diags
	}

	return IpStatValue{
		DhcpServer: dhcpServerVal,
		Dns:        dnsVal,
		DnsSuffix:  dnsSuffixVal,
		Gateway:    gatewayVal,
		Gateway6:   gateway6Val,
		Ip:         ipVal,
		Ip6:        ip6Val,
		Ips:        ipsVal,
		Netmask:    netmaskVal,
		Netmask6:   netmask6Val,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewIpStatValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) IpStatValue {
	object, diags := NewIpStatValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewIpStatValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t IpStatType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewIpStatValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewIpStatValueUnknown(), nil
	}

	if in.IsNull() {
		return NewIpStatValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewIpStatValueMust(IpStatValue{}.AttributeTypes(ctx), attributes), nil
}

func (t IpStatType) ValueType(ctx context.Context) attr.Value {
	return IpStatValue{}
}

var _ basetypes.ObjectValuable = IpStatValue{}

type IpStatValue struct {
	DhcpServer basetypes.StringValue `tfsdk:"dhcp_server"`
	Dns        basetypes.ListValue   `tfsdk:"dns"`
	DnsSuffix  basetypes.ListValue   `tfsdk:"dns_suffix"`
	Gateway    basetypes.StringValue `tfsdk:"gateway"`
	Gateway6   basetypes.StringValue `tfsdk:"gateway6"`
	Ip         basetypes.StringValue `tfsdk:"ip"`
	Ip6        basetypes.StringValue `tfsdk:"ip6"`
	Ips        basetypes.MapValue    `tfsdk:"ips"`
	Netmask    basetypes.StringValue `tfsdk:"netmask"`
	Netmask6   basetypes.StringValue `tfsdk:"netmask6"`
	state      attr.ValueState
}

func (v IpStatValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 10)

	var val tftypes.Value
	var err error

	attrTypes["dhcp_server"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["dns"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["dns_suffix"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["gateway"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["gateway6"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ip"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ip6"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ips"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["netmask"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["netmask6"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 10)

		val, err = v.DhcpServer.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dhcp_server"] = val

		val, err = v.Dns.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dns"] = val

		val, err = v.DnsSuffix.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dns_suffix"] = val

		val, err = v.Gateway.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["gateway"] = val

		val, err = v.Gateway6.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["gateway6"] = val

		val, err = v.Ip.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip"] = val

		val, err = v.Ip6.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip6"] = val

		val, err = v.Ips.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ips"] = val

		val, err = v.Netmask.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["netmask"] = val

		val, err = v.Netmask6.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["netmask6"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v IpStatValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v IpStatValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v IpStatValue) String() string {
	return "IpStatValue"
}

func (v IpStatValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	dnsVal, d := types.ListValue(types.StringType, v.Dns.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"dhcp_server": basetypes.StringType{},
			"dns": basetypes.ListType{
				ElemType: types.StringType,
			},
			"dns_suffix": basetypes.ListType{
				ElemType: types.StringType,
			},
			"gateway":  basetypes.StringType{},
			"gateway6": basetypes.StringType{},
			"ip":       basetypes.StringType{},
			"ip6":      basetypes.StringType{},
			"ips": basetypes.MapType{
				ElemType: types.StringType,
			},
			"netmask":  basetypes.StringType{},
			"netmask6": basetypes.StringType{},
		}), diags
	}

	dnsSuffixVal, d := types.ListValue(types.StringType, v.DnsSuffix.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"dhcp_server": basetypes.StringType{},
			"dns": basetypes.ListType{
				ElemType: types.StringType,
			},
			"dns_suffix": basetypes.ListType{
				ElemType: types.StringType,
			},
			"gateway":  basetypes.StringType{},
			"gateway6": basetypes.StringType{},
			"ip":       basetypes.StringType{},
			"ip6":      basetypes.StringType{},
			"ips": basetypes.MapType{
				ElemType: types.StringType,
			},
			"netmask":  basetypes.StringType{},
			"netmask6": basetypes.StringType{},
		}), diags
	}

	ipsVal, d := types.MapValue(types.StringType, v.Ips.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"dhcp_server": basetypes.StringType{},
			"dns": basetypes.ListType{
				ElemType: types.StringType,
			},
			"dns_suffix": basetypes.ListType{
				ElemType: types.StringType,
			},
			"gateway":  basetypes.StringType{},
			"gateway6": basetypes.StringType{},
			"ip":       basetypes.StringType{},
			"ip6":      basetypes.StringType{},
			"ips": basetypes.MapType{
				ElemType: types.StringType,
			},
			"netmask":  basetypes.StringType{},
			"netmask6": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"dhcp_server": basetypes.StringType{},
		"dns": basetypes.ListType{
			ElemType: types.StringType,
		},
		"dns_suffix": basetypes.ListType{
			ElemType: types.StringType,
		},
		"gateway":  basetypes.StringType{},
		"gateway6": basetypes.StringType{},
		"ip":       basetypes.StringType{},
		"ip6":      basetypes.StringType{},
		"ips": basetypes.MapType{
			ElemType: types.StringType,
		},
		"netmask":  basetypes.StringType{},
		"netmask6": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"dhcp_server": v.DhcpServer,
			"dns":         dnsVal,
			"dns_suffix":  dnsSuffixVal,
			"gateway":     v.Gateway,
			"gateway6":    v.Gateway6,
			"ip":          v.Ip,
			"ip6":         v.Ip6,
			"ips":         ipsVal,
			"netmask":     v.Netmask,
			"netmask6":    v.Netmask6,
		})

	return objVal, diags
}

func (v IpStatValue) Equal(o attr.Value) bool {
	other, ok := o.(IpStatValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.DhcpServer.Equal(other.DhcpServer) {
		return false
	}

	if !v.Dns.Equal(other.Dns) {
		return false
	}

	if !v.DnsSuffix.Equal(other.DnsSuffix) {
		return false
	}

	if !v.Gateway.Equal(other.Gateway) {
		return false
	}

	if !v.Gateway6.Equal(other.Gateway6) {
		return false
	}

	if !v.Ip.Equal(other.Ip) {
		return false
	}

	if !v.Ip6.Equal(other.Ip6) {
		return false
	}

	if !v.Ips.Equal(other.Ips) {
		return false
	}

	if !v.Netmask.Equal(other.Netmask) {
		return false
	}

	if !v.Netmask6.Equal(other.Netmask6) {
		return false
	}

	return true
}

func (v IpStatValue) Type(ctx context.Context) attr.Type {
	return IpStatType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v IpStatValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"dhcp_server": basetypes.StringType{},
		"dns": basetypes.ListType{
			ElemType: types.StringType,
		},
		"dns_suffix": basetypes.ListType{
			ElemType: types.StringType,
		},
		"gateway":  basetypes.StringType{},
		"gateway6": basetypes.StringType{},
		"ip":       basetypes.StringType{},
		"ip6":      basetypes.StringType{},
		"ips": basetypes.MapType{
			ElemType: types.StringType,
		},
		"netmask":  basetypes.StringType{},
		"netmask6": basetypes.StringType{},
	}
}






















var _ basetypes.ObjectTypable = MemoryStatType{}

type MemoryStatType struct {
	basetypes.ObjectType
}

func (t MemoryStatType) Equal(o attr.Type) bool {
	other, ok := o.(MemoryStatType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t MemoryStatType) String() string {
	return "MemoryStatType"
}

func (t MemoryStatType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	usageAttribute, ok := attributes["usage"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`usage is missing from object`)

		return nil, diags
	}

	usageVal, ok := usageAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`usage expected to be basetypes.NumberValue, was: %T`, usageAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return MemoryStatValue{
		Usage: usageVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewMemoryStatValueNull() MemoryStatValue {
	return MemoryStatValue{
		state: attr.ValueStateNull,
	}
}

func NewMemoryStatValueUnknown() MemoryStatValue {
	return MemoryStatValue{
		state: attr.ValueStateUnknown,
	}
}

func NewMemoryStatValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (MemoryStatValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing MemoryStatValue Attribute Value",
				"While creating a MemoryStatValue value, a missing attribute value was detected. "+
					"A MemoryStatValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MemoryStatValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid MemoryStatValue Attribute Type",
				"While creating a MemoryStatValue value, an invalid attribute value was detected. "+
					"A MemoryStatValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MemoryStatValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("MemoryStatValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra MemoryStatValue Attribute Value",
				"While creating a MemoryStatValue value, an extra attribute value was detected. "+
					"A MemoryStatValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra MemoryStatValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewMemoryStatValueUnknown(), diags
	}

	usageAttribute, ok := attributes["usage"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`usage is missing from object`)

		return NewMemoryStatValueUnknown(), diags
	}

	usageVal, ok := usageAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`usage expected to be basetypes.NumberValue, was: %T`, usageAttribute))
	}

	if diags.HasError() {
		return NewMemoryStatValueUnknown(), diags
	}

	return MemoryStatValue{
		Usage: usageVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewMemoryStatValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) MemoryStatValue {
	object, diags := NewMemoryStatValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewMemoryStatValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t MemoryStatType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewMemoryStatValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewMemoryStatValueUnknown(), nil
	}

	if in.IsNull() {
		return NewMemoryStatValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewMemoryStatValueMust(MemoryStatValue{}.AttributeTypes(ctx), attributes), nil
}

func (t MemoryStatType) ValueType(ctx context.Context) attr.Value {
	return MemoryStatValue{}
}

var _ basetypes.ObjectValuable = MemoryStatValue{}

type MemoryStatValue struct {
	Usage basetypes.NumberValue `tfsdk:"usage"`
	state attr.ValueState
}

func (v MemoryStatValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["usage"] = basetypes.NumberType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Usage.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["usage"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v MemoryStatValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v MemoryStatValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v MemoryStatValue) String() string {
	return "MemoryStatValue"
}

func (v MemoryStatValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"usage": basetypes.NumberType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"usage": v.Usage,
		})

	return objVal, diags
}

func (v MemoryStatValue) Equal(o attr.Value) bool {
	other, ok := o.(MemoryStatValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Usage.Equal(other.Usage) {
		return false
	}

	return true
}

func (v MemoryStatValue) Type(ctx context.Context) attr.Type {
	return MemoryStatType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v MemoryStatValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"usage": basetypes.NumberType{},
	}
}






















var _ basetypes.ObjectTypable = ModuleStatType{}

type ModuleStatType struct {
	basetypes.ObjectType
}

func (t ModuleStatType) Equal(o attr.Type) bool {
	other, ok := o.(ModuleStatType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ModuleStatType) String() string {
	return "ModuleStatType"
}

func (t ModuleStatType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	backupVersionAttribute, ok := attributes["backup_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`backup_version is missing from object`)

		return nil, diags
	}

	backupVersionVal, ok := backupVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`backup_version expected to be basetypes.StringValue, was: %T`, backupVersionAttribute))
	}

	biosVersionAttribute, ok := attributes["bios_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bios_version is missing from object`)

		return nil, diags
	}

	biosVersionVal, ok := biosVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bios_version expected to be basetypes.StringValue, was: %T`, biosVersionAttribute))
	}

	cpldVersionAttribute, ok := attributes["cpld_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cpld_version is missing from object`)

		return nil, diags
	}

	cpldVersionVal, ok := cpldVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cpld_version expected to be basetypes.StringValue, was: %T`, cpldVersionAttribute))
	}

	errorsAttribute, ok := attributes["errors"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`errors is missing from object`)

		return nil, diags
	}

	errorsVal, ok := errorsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`errors expected to be basetypes.ListValue, was: %T`, errorsAttribute))
	}

	fansAttribute, ok := attributes["fans"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fans is missing from object`)

		return nil, diags
	}

	fansVal, ok := fansAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fans expected to be basetypes.ListValue, was: %T`, fansAttribute))
	}

	fpgaVersionAttribute, ok := attributes["fpga_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fpga_version is missing from object`)

		return nil, diags
	}

	fpgaVersionVal, ok := fpgaVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fpga_version expected to be basetypes.StringValue, was: %T`, fpgaVersionAttribute))
	}

	lastSeenAttribute, ok := attributes["last_seen"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`last_seen is missing from object`)

		return nil, diags
	}

	lastSeenVal, ok := lastSeenAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`last_seen expected to be basetypes.NumberValue, was: %T`, lastSeenAttribute))
	}

	modelAttribute, ok := attributes["model"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`model is missing from object`)

		return nil, diags
	}

	modelVal, ok := modelAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`model expected to be basetypes.StringValue, was: %T`, modelAttribute))
	}

	opticsCpldVersionAttribute, ok := attributes["optics_cpld_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`optics_cpld_version is missing from object`)

		return nil, diags
	}

	opticsCpldVersionVal, ok := opticsCpldVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`optics_cpld_version expected to be basetypes.StringValue, was: %T`, opticsCpldVersionAttribute))
	}

	pendingVersionAttribute, ok := attributes["pending_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pending_version is missing from object`)

		return nil, diags
	}

	pendingVersionVal, ok := pendingVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pending_version expected to be basetypes.StringValue, was: %T`, pendingVersionAttribute))
	}

	picsAttribute, ok := attributes["pics"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pics is missing from object`)

		return nil, diags
	}

	picsVal, ok := picsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pics expected to be basetypes.ListValue, was: %T`, picsAttribute))
	}

	poeAttribute, ok := attributes["poe"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`poe is missing from object`)

		return nil, diags
	}

	poeVal, ok := poeAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`poe expected to be basetypes.ObjectValue, was: %T`, poeAttribute))
	}

	poeVersionAttribute, ok := attributes["poe_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`poe_version is missing from object`)

		return nil, diags
	}

	poeVersionVal, ok := poeVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`poe_version expected to be basetypes.StringValue, was: %T`, poeVersionAttribute))
	}

	powerCpldVersionAttribute, ok := attributes["power_cpld_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`power_cpld_version is missing from object`)

		return nil, diags
	}

	powerCpldVersionVal, ok := powerCpldVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`power_cpld_version expected to be basetypes.StringValue, was: %T`, powerCpldVersionAttribute))
	}

	psusAttribute, ok := attributes["psus"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`psus is missing from object`)

		return nil, diags
	}

	psusVal, ok := psusAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`psus expected to be basetypes.ListValue, was: %T`, psusAttribute))
	}

	reFpgaVersionAttribute, ok := attributes["re_fpga_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`re_fpga_version is missing from object`)

		return nil, diags
	}

	reFpgaVersionVal, ok := reFpgaVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`re_fpga_version expected to be basetypes.StringValue, was: %T`, reFpgaVersionAttribute))
	}

	recoveryVersionAttribute, ok := attributes["recovery_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`recovery_version is missing from object`)

		return nil, diags
	}

	recoveryVersionVal, ok := recoveryVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`recovery_version expected to be basetypes.StringValue, was: %T`, recoveryVersionAttribute))
	}

	serialAttribute, ok := attributes["serial"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`serial is missing from object`)

		return nil, diags
	}

	serialVal, ok := serialAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`serial expected to be basetypes.StringValue, was: %T`, serialAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return nil, diags
	}

	statusVal, ok := statusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be basetypes.StringValue, was: %T`, statusAttribute))
	}

	temperaturesAttribute, ok := attributes["temperatures"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`temperatures is missing from object`)

		return nil, diags
	}

	temperaturesVal, ok := temperaturesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`temperatures expected to be basetypes.ListValue, was: %T`, temperaturesAttribute))
	}

	tmcFpgaVersionAttribute, ok := attributes["tmc_fpga_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tmc_fpga_version is missing from object`)

		return nil, diags
	}

	tmcFpgaVersionVal, ok := tmcFpgaVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tmc_fpga_version expected to be basetypes.StringValue, was: %T`, tmcFpgaVersionAttribute))
	}

	ubootVersionAttribute, ok := attributes["uboot_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uboot_version is missing from object`)

		return nil, diags
	}

	ubootVersionVal, ok := ubootVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uboot_version expected to be basetypes.StringValue, was: %T`, ubootVersionAttribute))
	}

	uptimeAttribute, ok := attributes["uptime"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uptime is missing from object`)

		return nil, diags
	}

	uptimeVal, ok := uptimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uptime expected to be basetypes.Int64Value, was: %T`, uptimeAttribute))
	}

	vcLinksAttribute, ok := attributes["vc_links"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vc_links is missing from object`)

		return nil, diags
	}

	vcLinksVal, ok := vcLinksAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vc_links expected to be basetypes.ListValue, was: %T`, vcLinksAttribute))
	}

	vcModeAttribute, ok := attributes["vc_mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vc_mode is missing from object`)

		return nil, diags
	}

	vcModeVal, ok := vcModeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vc_mode expected to be basetypes.StringValue, was: %T`, vcModeAttribute))
	}

	vcRoleAttribute, ok := attributes["vc_role"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vc_role is missing from object`)

		return nil, diags
	}

	vcRoleVal, ok := vcRoleAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vc_role expected to be basetypes.StringValue, was: %T`, vcRoleAttribute))
	}

	vcStateAttribute, ok := attributes["vc_state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vc_state is missing from object`)

		return nil, diags
	}

	vcStateVal, ok := vcStateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vc_state expected to be basetypes.StringValue, was: %T`, vcStateAttribute))
	}

	versionAttribute, ok := attributes["version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`version is missing from object`)

		return nil, diags
	}

	versionVal, ok := versionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`version expected to be basetypes.StringValue, was: %T`, versionAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ModuleStatValue{
		BackupVersion:     backupVersionVal,
		BiosVersion:       biosVersionVal,
		CpldVersion:       cpldVersionVal,
		Errors:            errorsVal,
		Fans:              fansVal,
		FpgaVersion:       fpgaVersionVal,
		LastSeen:          lastSeenVal,
		Model:             modelVal,
		OpticsCpldVersion: opticsCpldVersionVal,
		PendingVersion:    pendingVersionVal,
		Pics:              picsVal,
		Poe:               poeVal,
		PoeVersion:        poeVersionVal,
		PowerCpldVersion:  powerCpldVersionVal,
		Psus:              psusVal,
		ReFpgaVersion:     reFpgaVersionVal,
		RecoveryVersion:   recoveryVersionVal,
		Serial:            serialVal,
		Status:            statusVal,
		Temperatures:      temperaturesVal,
		TmcFpgaVersion:    tmcFpgaVersionVal,
		UbootVersion:      ubootVersionVal,
		Uptime:            uptimeVal,
		VcLinks:           vcLinksVal,
		VcMode:            vcModeVal,
		VcRole:            vcRoleVal,
		VcState:           vcStateVal,
		Version:           versionVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewModuleStatValueNull() ModuleStatValue {
	return ModuleStatValue{
		state: attr.ValueStateNull,
	}
}

func NewModuleStatValueUnknown() ModuleStatValue {
	return ModuleStatValue{
		state: attr.ValueStateUnknown,
	}
}

func NewModuleStatValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ModuleStatValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ModuleStatValue Attribute Value",
				"While creating a ModuleStatValue value, a missing attribute value was detected. "+
					"A ModuleStatValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ModuleStatValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ModuleStatValue Attribute Type",
				"While creating a ModuleStatValue value, an invalid attribute value was detected. "+
					"A ModuleStatValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ModuleStatValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ModuleStatValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ModuleStatValue Attribute Value",
				"While creating a ModuleStatValue value, an extra attribute value was detected. "+
					"A ModuleStatValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ModuleStatValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewModuleStatValueUnknown(), diags
	}

	backupVersionAttribute, ok := attributes["backup_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`backup_version is missing from object`)

		return NewModuleStatValueUnknown(), diags
	}

	backupVersionVal, ok := backupVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`backup_version expected to be basetypes.StringValue, was: %T`, backupVersionAttribute))
	}

	biosVersionAttribute, ok := attributes["bios_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bios_version is missing from object`)

		return NewModuleStatValueUnknown(), diags
	}

	biosVersionVal, ok := biosVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bios_version expected to be basetypes.StringValue, was: %T`, biosVersionAttribute))
	}

	cpldVersionAttribute, ok := attributes["cpld_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cpld_version is missing from object`)

		return NewModuleStatValueUnknown(), diags
	}

	cpldVersionVal, ok := cpldVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cpld_version expected to be basetypes.StringValue, was: %T`, cpldVersionAttribute))
	}

	errorsAttribute, ok := attributes["errors"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`errors is missing from object`)

		return NewModuleStatValueUnknown(), diags
	}

	errorsVal, ok := errorsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`errors expected to be basetypes.ListValue, was: %T`, errorsAttribute))
	}

	fansAttribute, ok := attributes["fans"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fans is missing from object`)

		return NewModuleStatValueUnknown(), diags
	}

	fansVal, ok := fansAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fans expected to be basetypes.ListValue, was: %T`, fansAttribute))
	}

	fpgaVersionAttribute, ok := attributes["fpga_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fpga_version is missing from object`)

		return NewModuleStatValueUnknown(), diags
	}

	fpgaVersionVal, ok := fpgaVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fpga_version expected to be basetypes.StringValue, was: %T`, fpgaVersionAttribute))
	}

	lastSeenAttribute, ok := attributes["last_seen"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`last_seen is missing from object`)

		return NewModuleStatValueUnknown(), diags
	}

	lastSeenVal, ok := lastSeenAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`last_seen expected to be basetypes.NumberValue, was: %T`, lastSeenAttribute))
	}

	modelAttribute, ok := attributes["model"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`model is missing from object`)

		return NewModuleStatValueUnknown(), diags
	}

	modelVal, ok := modelAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`model expected to be basetypes.StringValue, was: %T`, modelAttribute))
	}

	opticsCpldVersionAttribute, ok := attributes["optics_cpld_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`optics_cpld_version is missing from object`)

		return NewModuleStatValueUnknown(), diags
	}

	opticsCpldVersionVal, ok := opticsCpldVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`optics_cpld_version expected to be basetypes.StringValue, was: %T`, opticsCpldVersionAttribute))
	}

	pendingVersionAttribute, ok := attributes["pending_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pending_version is missing from object`)

		return NewModuleStatValueUnknown(), diags
	}

	pendingVersionVal, ok := pendingVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pending_version expected to be basetypes.StringValue, was: %T`, pendingVersionAttribute))
	}

	picsAttribute, ok := attributes["pics"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pics is missing from object`)

		return NewModuleStatValueUnknown(), diags
	}

	picsVal, ok := picsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pics expected to be basetypes.ListValue, was: %T`, picsAttribute))
	}

	poeAttribute, ok := attributes["poe"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`poe is missing from object`)

		return NewModuleStatValueUnknown(), diags
	}

	poeVal, ok := poeAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`poe expected to be basetypes.ObjectValue, was: %T`, poeAttribute))
	}

	poeVersionAttribute, ok := attributes["poe_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`poe_version is missing from object`)

		return NewModuleStatValueUnknown(), diags
	}

	poeVersionVal, ok := poeVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`poe_version expected to be basetypes.StringValue, was: %T`, poeVersionAttribute))
	}

	powerCpldVersionAttribute, ok := attributes["power_cpld_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`power_cpld_version is missing from object`)

		return NewModuleStatValueUnknown(), diags
	}

	powerCpldVersionVal, ok := powerCpldVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`power_cpld_version expected to be basetypes.StringValue, was: %T`, powerCpldVersionAttribute))
	}

	psusAttribute, ok := attributes["psus"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`psus is missing from object`)

		return NewModuleStatValueUnknown(), diags
	}

	psusVal, ok := psusAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`psus expected to be basetypes.ListValue, was: %T`, psusAttribute))
	}

	reFpgaVersionAttribute, ok := attributes["re_fpga_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`re_fpga_version is missing from object`)

		return NewModuleStatValueUnknown(), diags
	}

	reFpgaVersionVal, ok := reFpgaVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`re_fpga_version expected to be basetypes.StringValue, was: %T`, reFpgaVersionAttribute))
	}

	recoveryVersionAttribute, ok := attributes["recovery_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`recovery_version is missing from object`)

		return NewModuleStatValueUnknown(), diags
	}

	recoveryVersionVal, ok := recoveryVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`recovery_version expected to be basetypes.StringValue, was: %T`, recoveryVersionAttribute))
	}

	serialAttribute, ok := attributes["serial"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`serial is missing from object`)

		return NewModuleStatValueUnknown(), diags
	}

	serialVal, ok := serialAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`serial expected to be basetypes.StringValue, was: %T`, serialAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return NewModuleStatValueUnknown(), diags
	}

	statusVal, ok := statusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be basetypes.StringValue, was: %T`, statusAttribute))
	}

	temperaturesAttribute, ok := attributes["temperatures"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`temperatures is missing from object`)

		return NewModuleStatValueUnknown(), diags
	}

	temperaturesVal, ok := temperaturesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`temperatures expected to be basetypes.ListValue, was: %T`, temperaturesAttribute))
	}

	tmcFpgaVersionAttribute, ok := attributes["tmc_fpga_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tmc_fpga_version is missing from object`)

		return NewModuleStatValueUnknown(), diags
	}

	tmcFpgaVersionVal, ok := tmcFpgaVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tmc_fpga_version expected to be basetypes.StringValue, was: %T`, tmcFpgaVersionAttribute))
	}

	ubootVersionAttribute, ok := attributes["uboot_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uboot_version is missing from object`)

		return NewModuleStatValueUnknown(), diags
	}

	ubootVersionVal, ok := ubootVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uboot_version expected to be basetypes.StringValue, was: %T`, ubootVersionAttribute))
	}

	uptimeAttribute, ok := attributes["uptime"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uptime is missing from object`)

		return NewModuleStatValueUnknown(), diags
	}

	uptimeVal, ok := uptimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uptime expected to be basetypes.Int64Value, was: %T`, uptimeAttribute))
	}

	vcLinksAttribute, ok := attributes["vc_links"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vc_links is missing from object`)

		return NewModuleStatValueUnknown(), diags
	}

	vcLinksVal, ok := vcLinksAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vc_links expected to be basetypes.ListValue, was: %T`, vcLinksAttribute))
	}

	vcModeAttribute, ok := attributes["vc_mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vc_mode is missing from object`)

		return NewModuleStatValueUnknown(), diags
	}

	vcModeVal, ok := vcModeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vc_mode expected to be basetypes.StringValue, was: %T`, vcModeAttribute))
	}

	vcRoleAttribute, ok := attributes["vc_role"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vc_role is missing from object`)

		return NewModuleStatValueUnknown(), diags
	}

	vcRoleVal, ok := vcRoleAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vc_role expected to be basetypes.StringValue, was: %T`, vcRoleAttribute))
	}

	vcStateAttribute, ok := attributes["vc_state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vc_state is missing from object`)

		return NewModuleStatValueUnknown(), diags
	}

	vcStateVal, ok := vcStateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vc_state expected to be basetypes.StringValue, was: %T`, vcStateAttribute))
	}

	versionAttribute, ok := attributes["version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`version is missing from object`)

		return NewModuleStatValueUnknown(), diags
	}

	versionVal, ok := versionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`version expected to be basetypes.StringValue, was: %T`, versionAttribute))
	}

	if diags.HasError() {
		return NewModuleStatValueUnknown(), diags
	}

	return ModuleStatValue{
		BackupVersion:     backupVersionVal,
		BiosVersion:       biosVersionVal,
		CpldVersion:       cpldVersionVal,
		Errors:            errorsVal,
		Fans:              fansVal,
		FpgaVersion:       fpgaVersionVal,
		LastSeen:          lastSeenVal,
		Model:             modelVal,
		OpticsCpldVersion: opticsCpldVersionVal,
		PendingVersion:    pendingVersionVal,
		Pics:              picsVal,
		Poe:               poeVal,
		PoeVersion:        poeVersionVal,
		PowerCpldVersion:  powerCpldVersionVal,
		Psus:              psusVal,
		ReFpgaVersion:     reFpgaVersionVal,
		RecoveryVersion:   recoveryVersionVal,
		Serial:            serialVal,
		Status:            statusVal,
		Temperatures:      temperaturesVal,
		TmcFpgaVersion:    tmcFpgaVersionVal,
		UbootVersion:      ubootVersionVal,
		Uptime:            uptimeVal,
		VcLinks:           vcLinksVal,
		VcMode:            vcModeVal,
		VcRole:            vcRoleVal,
		VcState:           vcStateVal,
		Version:           versionVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewModuleStatValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ModuleStatValue {
	object, diags := NewModuleStatValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewModuleStatValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ModuleStatType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewModuleStatValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewModuleStatValueUnknown(), nil
	}

	if in.IsNull() {
		return NewModuleStatValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewModuleStatValueMust(ModuleStatValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ModuleStatType) ValueType(ctx context.Context) attr.Value {
	return ModuleStatValue{}
}

var _ basetypes.ObjectValuable = ModuleStatValue{}

type ModuleStatValue struct {
	BackupVersion     basetypes.StringValue `tfsdk:"backup_version"`
	BiosVersion       basetypes.StringValue `tfsdk:"bios_version"`
	CpldVersion       basetypes.StringValue `tfsdk:"cpld_version"`
	Errors            basetypes.ListValue   `tfsdk:"errors"`
	Fans              basetypes.ListValue   `tfsdk:"fans"`
	FpgaVersion       basetypes.StringValue `tfsdk:"fpga_version"`
	LastSeen          basetypes.NumberValue `tfsdk:"last_seen"`
	Model             basetypes.StringValue `tfsdk:"model"`
	OpticsCpldVersion basetypes.StringValue `tfsdk:"optics_cpld_version"`
	PendingVersion    basetypes.StringValue `tfsdk:"pending_version"`
	Pics              basetypes.ListValue   `tfsdk:"pics"`
	Poe               basetypes.ObjectValue `tfsdk:"poe"`
	PoeVersion        basetypes.StringValue `tfsdk:"poe_version"`
	PowerCpldVersion  basetypes.StringValue `tfsdk:"power_cpld_version"`
	Psus              basetypes.ListValue   `tfsdk:"psus"`
	ReFpgaVersion     basetypes.StringValue `tfsdk:"re_fpga_version"`
	RecoveryVersion   basetypes.StringValue `tfsdk:"recovery_version"`
	Serial            basetypes.StringValue `tfsdk:"serial"`
	Status            basetypes.StringValue `tfsdk:"status"`
	Temperatures      basetypes.ListValue   `tfsdk:"temperatures"`
	TmcFpgaVersion    basetypes.StringValue `tfsdk:"tmc_fpga_version"`
	UbootVersion      basetypes.StringValue `tfsdk:"uboot_version"`
	Uptime            basetypes.Int64Value  `tfsdk:"uptime"`
	VcLinks           basetypes.ListValue   `tfsdk:"vc_links"`
	VcMode            basetypes.StringValue `tfsdk:"vc_mode"`
	VcRole            basetypes.StringValue `tfsdk:"vc_role"`
	VcState           basetypes.StringValue `tfsdk:"vc_state"`
	Version           basetypes.StringValue `tfsdk:"version"`
	state             attr.ValueState
}

func (v ModuleStatValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 28)

	var val tftypes.Value
	var err error

	attrTypes["backup_version"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["bios_version"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["cpld_version"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["errors"] = basetypes.ListType{
		ElemType: ErrorsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["fans"] = basetypes.ListType{
		ElemType: FansValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["fpga_version"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["last_seen"] = basetypes.NumberType{}.TerraformType(ctx)
	attrTypes["model"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["optics_cpld_version"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["pending_version"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["pics"] = basetypes.ListType{
		ElemType: PicsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["poe"] = basetypes.ObjectType{
		AttrTypes: PoeValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["poe_version"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["power_cpld_version"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["psus"] = basetypes.ListType{
		ElemType: PsusValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["re_fpga_version"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["recovery_version"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["serial"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["status"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["temperatures"] = basetypes.ListType{
		ElemType: TemperaturesValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["tmc_fpga_version"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["uboot_version"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["uptime"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["vc_links"] = basetypes.ListType{
		ElemType: VcLinksValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["vc_mode"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["vc_role"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["vc_state"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["version"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 28)

		val, err = v.BackupVersion.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["backup_version"] = val

		val, err = v.BiosVersion.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bios_version"] = val

		val, err = v.CpldVersion.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cpld_version"] = val

		val, err = v.Errors.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["errors"] = val

		val, err = v.Fans.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["fans"] = val

		val, err = v.FpgaVersion.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["fpga_version"] = val

		val, err = v.LastSeen.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["last_seen"] = val

		val, err = v.Model.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["model"] = val

		val, err = v.OpticsCpldVersion.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["optics_cpld_version"] = val

		val, err = v.PendingVersion.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["pending_version"] = val

		val, err = v.Pics.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["pics"] = val

		val, err = v.Poe.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["poe"] = val

		val, err = v.PoeVersion.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["poe_version"] = val

		val, err = v.PowerCpldVersion.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["power_cpld_version"] = val

		val, err = v.Psus.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["psus"] = val

		val, err = v.ReFpgaVersion.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["re_fpga_version"] = val

		val, err = v.RecoveryVersion.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["recovery_version"] = val

		val, err = v.Serial.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["serial"] = val

		val, err = v.Status.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["status"] = val

		val, err = v.Temperatures.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["temperatures"] = val

		val, err = v.TmcFpgaVersion.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tmc_fpga_version"] = val

		val, err = v.UbootVersion.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["uboot_version"] = val

		val, err = v.Uptime.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["uptime"] = val

		val, err = v.VcLinks.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vc_links"] = val

		val, err = v.VcMode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vc_mode"] = val

		val, err = v.VcRole.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vc_role"] = val

		val, err = v.VcState.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vc_state"] = val

		val, err = v.Version.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["version"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ModuleStatValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ModuleStatValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ModuleStatValue) String() string {
	return "ModuleStatValue"
}

func (v ModuleStatValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	errors := types.ListValueMust(
		ErrorsType{
			basetypes.ObjectType{
				AttrTypes: ErrorsValue{}.AttributeTypes(ctx),
			},
		},
		v.Errors.Elements(),
	)

	if v.Errors.IsNull() {
		errors = types.ListNull(
			ErrorsType{
				basetypes.ObjectType{
					AttrTypes: ErrorsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Errors.IsUnknown() {
		errors = types.ListUnknown(
			ErrorsType{
				basetypes.ObjectType{
					AttrTypes: ErrorsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	fans := types.ListValueMust(
		FansType{
			basetypes.ObjectType{
				AttrTypes: FansValue{}.AttributeTypes(ctx),
			},
		},
		v.Fans.Elements(),
	)

	if v.Fans.IsNull() {
		fans = types.ListNull(
			FansType{
				basetypes.ObjectType{
					AttrTypes: FansValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Fans.IsUnknown() {
		fans = types.ListUnknown(
			FansType{
				basetypes.ObjectType{
					AttrTypes: FansValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	pics := types.ListValueMust(
		PicsType{
			basetypes.ObjectType{
				AttrTypes: PicsValue{}.AttributeTypes(ctx),
			},
		},
		v.Pics.Elements(),
	)

	if v.Pics.IsNull() {
		pics = types.ListNull(
			PicsType{
				basetypes.ObjectType{
					AttrTypes: PicsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Pics.IsUnknown() {
		pics = types.ListUnknown(
			PicsType{
				basetypes.ObjectType{
					AttrTypes: PicsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var poe basetypes.ObjectValue

	if v.Poe.IsNull() {
		poe = types.ObjectNull(
			PoeValue{}.AttributeTypes(ctx),
		)
	}

	if v.Poe.IsUnknown() {
		poe = types.ObjectUnknown(
			PoeValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Poe.IsNull() && !v.Poe.IsUnknown() {
		poe = types.ObjectValueMust(
			PoeValue{}.AttributeTypes(ctx),
			v.Poe.Attributes(),
		)
	}

	psus := types.ListValueMust(
		PsusType{
			basetypes.ObjectType{
				AttrTypes: PsusValue{}.AttributeTypes(ctx),
			},
		},
		v.Psus.Elements(),
	)

	if v.Psus.IsNull() {
		psus = types.ListNull(
			PsusType{
				basetypes.ObjectType{
					AttrTypes: PsusValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Psus.IsUnknown() {
		psus = types.ListUnknown(
			PsusType{
				basetypes.ObjectType{
					AttrTypes: PsusValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	temperatures := types.ListValueMust(
		TemperaturesType{
			basetypes.ObjectType{
				AttrTypes: TemperaturesValue{}.AttributeTypes(ctx),
			},
		},
		v.Temperatures.Elements(),
	)

	if v.Temperatures.IsNull() {
		temperatures = types.ListNull(
			TemperaturesType{
				basetypes.ObjectType{
					AttrTypes: TemperaturesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Temperatures.IsUnknown() {
		temperatures = types.ListUnknown(
			TemperaturesType{
				basetypes.ObjectType{
					AttrTypes: TemperaturesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	vcLinks := types.ListValueMust(
		VcLinksType{
			basetypes.ObjectType{
				AttrTypes: VcLinksValue{}.AttributeTypes(ctx),
			},
		},
		v.VcLinks.Elements(),
	)

	if v.VcLinks.IsNull() {
		vcLinks = types.ListNull(
			VcLinksType{
				basetypes.ObjectType{
					AttrTypes: VcLinksValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.VcLinks.IsUnknown() {
		vcLinks = types.ListUnknown(
			VcLinksType{
				basetypes.ObjectType{
					AttrTypes: VcLinksValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"backup_version": basetypes.StringType{},
		"bios_version":   basetypes.StringType{},
		"cpld_version":   basetypes.StringType{},
		"errors": basetypes.ListType{
			ElemType: ErrorsValue{}.Type(ctx),
		},
		"fans": basetypes.ListType{
			ElemType: FansValue{}.Type(ctx),
		},
		"fpga_version":        basetypes.StringType{},
		"last_seen":           basetypes.NumberType{},
		"model":               basetypes.StringType{},
		"optics_cpld_version": basetypes.StringType{},
		"pending_version":     basetypes.StringType{},
		"pics": basetypes.ListType{
			ElemType: PicsValue{}.Type(ctx),
		},
		"poe": basetypes.ObjectType{
			AttrTypes: PoeValue{}.AttributeTypes(ctx),
		},
		"poe_version":        basetypes.StringType{},
		"power_cpld_version": basetypes.StringType{},
		"psus": basetypes.ListType{
			ElemType: PsusValue{}.Type(ctx),
		},
		"re_fpga_version":  basetypes.StringType{},
		"recovery_version": basetypes.StringType{},
		"serial":           basetypes.StringType{},
		"status":           basetypes.StringType{},
		"temperatures": basetypes.ListType{
			ElemType: TemperaturesValue{}.Type(ctx),
		},
		"tmc_fpga_version": basetypes.StringType{},
		"uboot_version":    basetypes.StringType{},
		"uptime":           basetypes.Int64Type{},
		"vc_links": basetypes.ListType{
			ElemType: VcLinksValue{}.Type(ctx),
		},
		"vc_mode":  basetypes.StringType{},
		"vc_role":  basetypes.StringType{},
		"vc_state": basetypes.StringType{},
		"version":  basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"backup_version":      v.BackupVersion,
			"bios_version":        v.BiosVersion,
			"cpld_version":        v.CpldVersion,
			"errors":              errors,
			"fans":                fans,
			"fpga_version":        v.FpgaVersion,
			"last_seen":           v.LastSeen,
			"model":               v.Model,
			"optics_cpld_version": v.OpticsCpldVersion,
			"pending_version":     v.PendingVersion,
			"pics":                pics,
			"poe":                 poe,
			"poe_version":         v.PoeVersion,
			"power_cpld_version":  v.PowerCpldVersion,
			"psus":                psus,
			"re_fpga_version":     v.ReFpgaVersion,
			"recovery_version":    v.RecoveryVersion,
			"serial":              v.Serial,
			"status":              v.Status,
			"temperatures":        temperatures,
			"tmc_fpga_version":    v.TmcFpgaVersion,
			"uboot_version":       v.UbootVersion,
			"uptime":              v.Uptime,
			"vc_links":            vcLinks,
			"vc_mode":             v.VcMode,
			"vc_role":             v.VcRole,
			"vc_state":            v.VcState,
			"version":             v.Version,
		})

	return objVal, diags
}

func (v ModuleStatValue) Equal(o attr.Value) bool {
	other, ok := o.(ModuleStatValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.BackupVersion.Equal(other.BackupVersion) {
		return false
	}

	if !v.BiosVersion.Equal(other.BiosVersion) {
		return false
	}

	if !v.CpldVersion.Equal(other.CpldVersion) {
		return false
	}

	if !v.Errors.Equal(other.Errors) {
		return false
	}

	if !v.Fans.Equal(other.Fans) {
		return false
	}

	if !v.FpgaVersion.Equal(other.FpgaVersion) {
		return false
	}

	if !v.LastSeen.Equal(other.LastSeen) {
		return false
	}

	if !v.Model.Equal(other.Model) {
		return false
	}

	if !v.OpticsCpldVersion.Equal(other.OpticsCpldVersion) {
		return false
	}

	if !v.PendingVersion.Equal(other.PendingVersion) {
		return false
	}

	if !v.Pics.Equal(other.Pics) {
		return false
	}

	if !v.Poe.Equal(other.Poe) {
		return false
	}

	if !v.PoeVersion.Equal(other.PoeVersion) {
		return false
	}

	if !v.PowerCpldVersion.Equal(other.PowerCpldVersion) {
		return false
	}

	if !v.Psus.Equal(other.Psus) {
		return false
	}

	if !v.ReFpgaVersion.Equal(other.ReFpgaVersion) {
		return false
	}

	if !v.RecoveryVersion.Equal(other.RecoveryVersion) {
		return false
	}

	if !v.Serial.Equal(other.Serial) {
		return false
	}

	if !v.Status.Equal(other.Status) {
		return false
	}

	if !v.Temperatures.Equal(other.Temperatures) {
		return false
	}

	if !v.TmcFpgaVersion.Equal(other.TmcFpgaVersion) {
		return false
	}

	if !v.UbootVersion.Equal(other.UbootVersion) {
		return false
	}

	if !v.Uptime.Equal(other.Uptime) {
		return false
	}

	if !v.VcLinks.Equal(other.VcLinks) {
		return false
	}

	if !v.VcMode.Equal(other.VcMode) {
		return false
	}

	if !v.VcRole.Equal(other.VcRole) {
		return false
	}

	if !v.VcState.Equal(other.VcState) {
		return false
	}

	if !v.Version.Equal(other.Version) {
		return false
	}

	return true
}

func (v ModuleStatValue) Type(ctx context.Context) attr.Type {
	return ModuleStatType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ModuleStatValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"backup_version": basetypes.StringType{},
		"bios_version":   basetypes.StringType{},
		"cpld_version":   basetypes.StringType{},
		"errors": basetypes.ListType{
			ElemType: ErrorsValue{}.Type(ctx),
		},
		"fans": basetypes.ListType{
			ElemType: FansValue{}.Type(ctx),
		},
		"fpga_version":        basetypes.StringType{},
		"last_seen":           basetypes.NumberType{},
		"model":               basetypes.StringType{},
		"optics_cpld_version": basetypes.StringType{},
		"pending_version":     basetypes.StringType{},
		"pics": basetypes.ListType{
			ElemType: PicsValue{}.Type(ctx),
		},
		"poe": basetypes.ObjectType{
			AttrTypes: PoeValue{}.AttributeTypes(ctx),
		},
		"poe_version":        basetypes.StringType{},
		"power_cpld_version": basetypes.StringType{},
		"psus": basetypes.ListType{
			ElemType: PsusValue{}.Type(ctx),
		},
		"re_fpga_version":  basetypes.StringType{},
		"recovery_version": basetypes.StringType{},
		"serial":           basetypes.StringType{},
		"status":           basetypes.StringType{},
		"temperatures": basetypes.ListType{
			ElemType: TemperaturesValue{}.Type(ctx),
		},
		"tmc_fpga_version": basetypes.StringType{},
		"uboot_version":    basetypes.StringType{},
		"uptime":           basetypes.Int64Type{},
		"vc_links": basetypes.ListType{
			ElemType: VcLinksValue{}.Type(ctx),
		},
		"vc_mode":  basetypes.StringType{},
		"vc_role":  basetypes.StringType{},
		"vc_state": basetypes.StringType{},
		"version":  basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = ErrorsType{}

type ErrorsType struct {
	basetypes.ObjectType
}

func (t ErrorsType) Equal(o attr.Type) bool {
	other, ok := o.(ErrorsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ErrorsType) String() string {
	return "ErrorsType"
}

func (t ErrorsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	featureAttribute, ok := attributes["feature"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`feature is missing from object`)

		return nil, diags
	}

	featureVal, ok := featureAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`feature expected to be basetypes.StringValue, was: %T`, featureAttribute))
	}

	minimumVersionAttribute, ok := attributes["minimum_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`minimum_version is missing from object`)

		return nil, diags
	}

	minimumVersionVal, ok := minimumVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`minimum_version expected to be basetypes.StringValue, was: %T`, minimumVersionAttribute))
	}

	reasonAttribute, ok := attributes["reason"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`reason is missing from object`)

		return nil, diags
	}

	reasonVal, ok := reasonAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`reason expected to be basetypes.StringValue, was: %T`, reasonAttribute))
	}

	sinceAttribute, ok := attributes["since"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`since is missing from object`)

		return nil, diags
	}

	sinceVal, ok := sinceAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`since expected to be basetypes.Int64Value, was: %T`, sinceAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ErrorsValue{
		Feature:        featureVal,
		MinimumVersion: minimumVersionVal,
		Reason:         reasonVal,
		Since:          sinceVal,
		ErrorsType:     typeVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewErrorsValueNull() ErrorsValue {
	return ErrorsValue{
		state: attr.ValueStateNull,
	}
}

func NewErrorsValueUnknown() ErrorsValue {
	return ErrorsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewErrorsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ErrorsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ErrorsValue Attribute Value",
				"While creating a ErrorsValue value, a missing attribute value was detected. "+
					"A ErrorsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ErrorsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ErrorsValue Attribute Type",
				"While creating a ErrorsValue value, an invalid attribute value was detected. "+
					"A ErrorsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ErrorsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ErrorsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ErrorsValue Attribute Value",
				"While creating a ErrorsValue value, an extra attribute value was detected. "+
					"A ErrorsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ErrorsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewErrorsValueUnknown(), diags
	}

	featureAttribute, ok := attributes["feature"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`feature is missing from object`)

		return NewErrorsValueUnknown(), diags
	}

	featureVal, ok := featureAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`feature expected to be basetypes.StringValue, was: %T`, featureAttribute))
	}

	minimumVersionAttribute, ok := attributes["minimum_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`minimum_version is missing from object`)

		return NewErrorsValueUnknown(), diags
	}

	minimumVersionVal, ok := minimumVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`minimum_version expected to be basetypes.StringValue, was: %T`, minimumVersionAttribute))
	}

	reasonAttribute, ok := attributes["reason"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`reason is missing from object`)

		return NewErrorsValueUnknown(), diags
	}

	reasonVal, ok := reasonAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`reason expected to be basetypes.StringValue, was: %T`, reasonAttribute))
	}

	sinceAttribute, ok := attributes["since"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`since is missing from object`)

		return NewErrorsValueUnknown(), diags
	}

	sinceVal, ok := sinceAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`since expected to be basetypes.Int64Value, was: %T`, sinceAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewErrorsValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return NewErrorsValueUnknown(), diags
	}

	return ErrorsValue{
		Feature:        featureVal,
		MinimumVersion: minimumVersionVal,
		Reason:         reasonVal,
		Since:          sinceVal,
		ErrorsType:     typeVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewErrorsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ErrorsValue {
	object, diags := NewErrorsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewErrorsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ErrorsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewErrorsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewErrorsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewErrorsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewErrorsValueMust(ErrorsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ErrorsType) ValueType(ctx context.Context) attr.Value {
	return ErrorsValue{}
}

var _ basetypes.ObjectValuable = ErrorsValue{}

type ErrorsValue struct {
	Feature        basetypes.StringValue `tfsdk:"feature"`
	MinimumVersion basetypes.StringValue `tfsdk:"minimum_version"`
	Reason         basetypes.StringValue `tfsdk:"reason"`
	Since          basetypes.Int64Value  `tfsdk:"since"`
	ErrorsType     basetypes.StringValue `tfsdk:"type"`
	state          attr.ValueState
}

func (v ErrorsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["feature"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["minimum_version"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["reason"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["since"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.Feature.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["feature"] = val

		val, err = v.MinimumVersion.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["minimum_version"] = val

		val, err = v.Reason.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["reason"] = val

		val, err = v.Since.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["since"] = val

		val, err = v.ErrorsType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ErrorsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ErrorsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ErrorsValue) String() string {
	return "ErrorsValue"
}

func (v ErrorsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"feature":         basetypes.StringType{},
		"minimum_version": basetypes.StringType{},
		"reason":          basetypes.StringType{},
		"since":           basetypes.Int64Type{},
		"type":            basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"feature":         v.Feature,
			"minimum_version": v.MinimumVersion,
			"reason":          v.Reason,
			"since":           v.Since,
			"type":            v.ErrorsType,
		})

	return objVal, diags
}

func (v ErrorsValue) Equal(o attr.Value) bool {
	other, ok := o.(ErrorsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Feature.Equal(other.Feature) {
		return false
	}

	if !v.MinimumVersion.Equal(other.MinimumVersion) {
		return false
	}

	if !v.Reason.Equal(other.Reason) {
		return false
	}

	if !v.Since.Equal(other.Since) {
		return false
	}

	if !v.ErrorsType.Equal(other.ErrorsType) {
		return false
	}

	return true
}

func (v ErrorsValue) Type(ctx context.Context) attr.Type {
	return ErrorsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ErrorsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"feature":         basetypes.StringType{},
		"minimum_version": basetypes.StringType{},
		"reason":          basetypes.StringType{},
		"since":           basetypes.Int64Type{},
		"type":            basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = FansType{}

type FansType struct {
	basetypes.ObjectType
}

func (t FansType) Equal(o attr.Type) bool {
	other, ok := o.(FansType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t FansType) String() string {
	return "FansType"
}

func (t FansType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	airflowAttribute, ok := attributes["airflow"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`airflow is missing from object`)

		return nil, diags
	}

	airflowVal, ok := airflowAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`airflow expected to be basetypes.StringValue, was: %T`, airflowAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return nil, diags
	}

	statusVal, ok := statusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be basetypes.StringValue, was: %T`, statusAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return FansValue{
		Airflow: airflowVal,
		Name:    nameVal,
		Status:  statusVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewFansValueNull() FansValue {
	return FansValue{
		state: attr.ValueStateNull,
	}
}

func NewFansValueUnknown() FansValue {
	return FansValue{
		state: attr.ValueStateUnknown,
	}
}

func NewFansValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (FansValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing FansValue Attribute Value",
				"While creating a FansValue value, a missing attribute value was detected. "+
					"A FansValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("FansValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid FansValue Attribute Type",
				"While creating a FansValue value, an invalid attribute value was detected. "+
					"A FansValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("FansValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("FansValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra FansValue Attribute Value",
				"While creating a FansValue value, an extra attribute value was detected. "+
					"A FansValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra FansValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewFansValueUnknown(), diags
	}

	airflowAttribute, ok := attributes["airflow"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`airflow is missing from object`)

		return NewFansValueUnknown(), diags
	}

	airflowVal, ok := airflowAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`airflow expected to be basetypes.StringValue, was: %T`, airflowAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewFansValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return NewFansValueUnknown(), diags
	}

	statusVal, ok := statusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be basetypes.StringValue, was: %T`, statusAttribute))
	}

	if diags.HasError() {
		return NewFansValueUnknown(), diags
	}

	return FansValue{
		Airflow: airflowVal,
		Name:    nameVal,
		Status:  statusVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewFansValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) FansValue {
	object, diags := NewFansValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewFansValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t FansType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewFansValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewFansValueUnknown(), nil
	}

	if in.IsNull() {
		return NewFansValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewFansValueMust(FansValue{}.AttributeTypes(ctx), attributes), nil
}

func (t FansType) ValueType(ctx context.Context) attr.Value {
	return FansValue{}
}

var _ basetypes.ObjectValuable = FansValue{}

type FansValue struct {
	Airflow basetypes.StringValue `tfsdk:"airflow"`
	Name    basetypes.StringValue `tfsdk:"name"`
	Status  basetypes.StringValue `tfsdk:"status"`
	state   attr.ValueState
}

func (v FansValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["airflow"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["status"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Airflow.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["airflow"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Status.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["status"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v FansValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v FansValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v FansValue) String() string {
	return "FansValue"
}

func (v FansValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"airflow": basetypes.StringType{},
		"name":    basetypes.StringType{},
		"status":  basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"airflow": v.Airflow,
			"name":    v.Name,
			"status":  v.Status,
		})

	return objVal, diags
}

func (v FansValue) Equal(o attr.Value) bool {
	other, ok := o.(FansValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Airflow.Equal(other.Airflow) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Status.Equal(other.Status) {
		return false
	}

	return true
}

func (v FansValue) Type(ctx context.Context) attr.Type {
	return FansType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v FansValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"airflow": basetypes.StringType{},
		"name":    basetypes.StringType{},
		"status":  basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = PicsType{}

type PicsType struct {
	basetypes.ObjectType
}

func (t PicsType) Equal(o attr.Type) bool {
	other, ok := o.(PicsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PicsType) String() string {
	return "PicsType"
}

func (t PicsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	indexAttribute, ok := attributes["index"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`index is missing from object`)

		return nil, diags
	}

	indexVal, ok := indexAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`index expected to be basetypes.Int64Value, was: %T`, indexAttribute))
	}

	modelNumberAttribute, ok := attributes["model_number"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`model_number is missing from object`)

		return nil, diags
	}

	modelNumberVal, ok := modelNumberAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`model_number expected to be basetypes.StringValue, was: %T`, modelNumberAttribute))
	}

	portGroupsAttribute, ok := attributes["port_groups"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_groups is missing from object`)

		return nil, diags
	}

	portGroupsVal, ok := portGroupsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_groups expected to be basetypes.ListValue, was: %T`, portGroupsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PicsValue{
		Index:       indexVal,
		ModelNumber: modelNumberVal,
		PortGroups:  portGroupsVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewPicsValueNull() PicsValue {
	return PicsValue{
		state: attr.ValueStateNull,
	}
}

func NewPicsValueUnknown() PicsValue {
	return PicsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPicsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PicsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PicsValue Attribute Value",
				"While creating a PicsValue value, a missing attribute value was detected. "+
					"A PicsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PicsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PicsValue Attribute Type",
				"While creating a PicsValue value, an invalid attribute value was detected. "+
					"A PicsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PicsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PicsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PicsValue Attribute Value",
				"While creating a PicsValue value, an extra attribute value was detected. "+
					"A PicsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PicsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPicsValueUnknown(), diags
	}

	indexAttribute, ok := attributes["index"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`index is missing from object`)

		return NewPicsValueUnknown(), diags
	}

	indexVal, ok := indexAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`index expected to be basetypes.Int64Value, was: %T`, indexAttribute))
	}

	modelNumberAttribute, ok := attributes["model_number"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`model_number is missing from object`)

		return NewPicsValueUnknown(), diags
	}

	modelNumberVal, ok := modelNumberAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`model_number expected to be basetypes.StringValue, was: %T`, modelNumberAttribute))
	}

	portGroupsAttribute, ok := attributes["port_groups"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_groups is missing from object`)

		return NewPicsValueUnknown(), diags
	}

	portGroupsVal, ok := portGroupsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_groups expected to be basetypes.ListValue, was: %T`, portGroupsAttribute))
	}

	if diags.HasError() {
		return NewPicsValueUnknown(), diags
	}

	return PicsValue{
		Index:       indexVal,
		ModelNumber: modelNumberVal,
		PortGroups:  portGroupsVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewPicsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PicsValue {
	object, diags := NewPicsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPicsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PicsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPicsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPicsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPicsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPicsValueMust(PicsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PicsType) ValueType(ctx context.Context) attr.Value {
	return PicsValue{}
}

var _ basetypes.ObjectValuable = PicsValue{}

type PicsValue struct {
	Index       basetypes.Int64Value  `tfsdk:"index"`
	ModelNumber basetypes.StringValue `tfsdk:"model_number"`
	PortGroups  basetypes.ListValue   `tfsdk:"port_groups"`
	state       attr.ValueState
}

func (v PicsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["index"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["model_number"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["port_groups"] = basetypes.ListType{
		ElemType: PortGroupsValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Index.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["index"] = val

		val, err = v.ModelNumber.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["model_number"] = val

		val, err = v.PortGroups.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port_groups"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PicsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PicsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PicsValue) String() string {
	return "PicsValue"
}

func (v PicsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	portGroups := types.ListValueMust(
		PortGroupsType{
			basetypes.ObjectType{
				AttrTypes: PortGroupsValue{}.AttributeTypes(ctx),
			},
		},
		v.PortGroups.Elements(),
	)

	if v.PortGroups.IsNull() {
		portGroups = types.ListNull(
			PortGroupsType{
				basetypes.ObjectType{
					AttrTypes: PortGroupsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.PortGroups.IsUnknown() {
		portGroups = types.ListUnknown(
			PortGroupsType{
				basetypes.ObjectType{
					AttrTypes: PortGroupsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"index":        basetypes.Int64Type{},
		"model_number": basetypes.StringType{},
		"port_groups": basetypes.ListType{
			ElemType: PortGroupsValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"index":        v.Index,
			"model_number": v.ModelNumber,
			"port_groups":  portGroups,
		})

	return objVal, diags
}

func (v PicsValue) Equal(o attr.Value) bool {
	other, ok := o.(PicsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Index.Equal(other.Index) {
		return false
	}

	if !v.ModelNumber.Equal(other.ModelNumber) {
		return false
	}

	if !v.PortGroups.Equal(other.PortGroups) {
		return false
	}

	return true
}

func (v PicsValue) Type(ctx context.Context) attr.Type {
	return PicsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PicsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"index":        basetypes.Int64Type{},
		"model_number": basetypes.StringType{},
		"port_groups": basetypes.ListType{
			ElemType: PortGroupsValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = PortGroupsType{}

type PortGroupsType struct {
	basetypes.ObjectType
}

func (t PortGroupsType) Equal(o attr.Type) bool {
	other, ok := o.(PortGroupsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PortGroupsType) String() string {
	return "PortGroupsType"
}

func (t PortGroupsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	countAttribute, ok := attributes["count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`count is missing from object`)

		return nil, diags
	}

	countVal, ok := countAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`count expected to be basetypes.Int64Value, was: %T`, countAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PortGroupsValue{
		Count:          countVal,
		PortGroupsType: typeVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewPortGroupsValueNull() PortGroupsValue {
	return PortGroupsValue{
		state: attr.ValueStateNull,
	}
}

func NewPortGroupsValueUnknown() PortGroupsValue {
	return PortGroupsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPortGroupsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PortGroupsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PortGroupsValue Attribute Value",
				"While creating a PortGroupsValue value, a missing attribute value was detected. "+
					"A PortGroupsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PortGroupsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PortGroupsValue Attribute Type",
				"While creating a PortGroupsValue value, an invalid attribute value was detected. "+
					"A PortGroupsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PortGroupsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PortGroupsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PortGroupsValue Attribute Value",
				"While creating a PortGroupsValue value, an extra attribute value was detected. "+
					"A PortGroupsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PortGroupsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPortGroupsValueUnknown(), diags
	}

	countAttribute, ok := attributes["count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`count is missing from object`)

		return NewPortGroupsValueUnknown(), diags
	}

	countVal, ok := countAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`count expected to be basetypes.Int64Value, was: %T`, countAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewPortGroupsValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return NewPortGroupsValueUnknown(), diags
	}

	return PortGroupsValue{
		Count:          countVal,
		PortGroupsType: typeVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewPortGroupsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PortGroupsValue {
	object, diags := NewPortGroupsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPortGroupsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PortGroupsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPortGroupsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPortGroupsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPortGroupsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPortGroupsValueMust(PortGroupsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PortGroupsType) ValueType(ctx context.Context) attr.Value {
	return PortGroupsValue{}
}

var _ basetypes.ObjectValuable = PortGroupsValue{}

type PortGroupsValue struct {
	Count          basetypes.Int64Value  `tfsdk:"count"`
	PortGroupsType basetypes.StringValue `tfsdk:"type"`
	state          attr.ValueState
}

func (v PortGroupsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["count"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Count.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["count"] = val

		val, err = v.PortGroupsType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PortGroupsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PortGroupsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PortGroupsValue) String() string {
	return "PortGroupsValue"
}

func (v PortGroupsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"count": basetypes.Int64Type{},
		"type":  basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"count": v.Count,
			"type":  v.PortGroupsType,
		})

	return objVal, diags
}

func (v PortGroupsValue) Equal(o attr.Value) bool {
	other, ok := o.(PortGroupsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Count.Equal(other.Count) {
		return false
	}

	if !v.PortGroupsType.Equal(other.PortGroupsType) {
		return false
	}

	return true
}

func (v PortGroupsValue) Type(ctx context.Context) attr.Type {
	return PortGroupsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PortGroupsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"count": basetypes.Int64Type{},
		"type":  basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = PoeType{}

type PoeType struct {
	basetypes.ObjectType
}

func (t PoeType) Equal(o attr.Type) bool {
	other, ok := o.(PoeType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PoeType) String() string {
	return "PoeType"
}

func (t PoeType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	maxPowerAttribute, ok := attributes["max_power"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_power is missing from object`)

		return nil, diags
	}

	maxPowerVal, ok := maxPowerAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_power expected to be basetypes.NumberValue, was: %T`, maxPowerAttribute))
	}

	powerDrawAttribute, ok := attributes["power_draw"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`power_draw is missing from object`)

		return nil, diags
	}

	powerDrawVal, ok := powerDrawAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`power_draw expected to be basetypes.NumberValue, was: %T`, powerDrawAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PoeValue{
		MaxPower:  maxPowerVal,
		PowerDraw: powerDrawVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewPoeValueNull() PoeValue {
	return PoeValue{
		state: attr.ValueStateNull,
	}
}

func NewPoeValueUnknown() PoeValue {
	return PoeValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPoeValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PoeValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PoeValue Attribute Value",
				"While creating a PoeValue value, a missing attribute value was detected. "+
					"A PoeValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PoeValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PoeValue Attribute Type",
				"While creating a PoeValue value, an invalid attribute value was detected. "+
					"A PoeValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PoeValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PoeValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PoeValue Attribute Value",
				"While creating a PoeValue value, an extra attribute value was detected. "+
					"A PoeValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PoeValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPoeValueUnknown(), diags
	}

	maxPowerAttribute, ok := attributes["max_power"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_power is missing from object`)

		return NewPoeValueUnknown(), diags
	}

	maxPowerVal, ok := maxPowerAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_power expected to be basetypes.NumberValue, was: %T`, maxPowerAttribute))
	}

	powerDrawAttribute, ok := attributes["power_draw"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`power_draw is missing from object`)

		return NewPoeValueUnknown(), diags
	}

	powerDrawVal, ok := powerDrawAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`power_draw expected to be basetypes.NumberValue, was: %T`, powerDrawAttribute))
	}

	if diags.HasError() {
		return NewPoeValueUnknown(), diags
	}

	return PoeValue{
		MaxPower:  maxPowerVal,
		PowerDraw: powerDrawVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewPoeValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PoeValue {
	object, diags := NewPoeValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPoeValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PoeType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPoeValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPoeValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPoeValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPoeValueMust(PoeValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PoeType) ValueType(ctx context.Context) attr.Value {
	return PoeValue{}
}

var _ basetypes.ObjectValuable = PoeValue{}

type PoeValue struct {
	MaxPower  basetypes.NumberValue `tfsdk:"max_power"`
	PowerDraw basetypes.NumberValue `tfsdk:"power_draw"`
	state     attr.ValueState
}

func (v PoeValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["max_power"] = basetypes.NumberType{}.TerraformType(ctx)
	attrTypes["power_draw"] = basetypes.NumberType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.MaxPower.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_power"] = val

		val, err = v.PowerDraw.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["power_draw"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PoeValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PoeValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PoeValue) String() string {
	return "PoeValue"
}

func (v PoeValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"max_power":  basetypes.NumberType{},
		"power_draw": basetypes.NumberType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"max_power":  v.MaxPower,
			"power_draw": v.PowerDraw,
		})

	return objVal, diags
}

func (v PoeValue) Equal(o attr.Value) bool {
	other, ok := o.(PoeValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.MaxPower.Equal(other.MaxPower) {
		return false
	}

	if !v.PowerDraw.Equal(other.PowerDraw) {
		return false
	}

	return true
}

func (v PoeValue) Type(ctx context.Context) attr.Type {
	return PoeType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PoeValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"max_power":  basetypes.NumberType{},
		"power_draw": basetypes.NumberType{},
	}
}

var _ basetypes.ObjectTypable = PsusType{}

type PsusType struct {
	basetypes.ObjectType
}

func (t PsusType) Equal(o attr.Type) bool {
	other, ok := o.(PsusType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PsusType) String() string {
	return "PsusType"
}

func (t PsusType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return nil, diags
	}

	statusVal, ok := statusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be basetypes.StringValue, was: %T`, statusAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PsusValue{
		Name:   nameVal,
		Status: statusVal,
		state:  attr.ValueStateKnown,
	}, diags
}

func NewPsusValueNull() PsusValue {
	return PsusValue{
		state: attr.ValueStateNull,
	}
}

func NewPsusValueUnknown() PsusValue {
	return PsusValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPsusValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PsusValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PsusValue Attribute Value",
				"While creating a PsusValue value, a missing attribute value was detected. "+
					"A PsusValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PsusValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PsusValue Attribute Type",
				"While creating a PsusValue value, an invalid attribute value was detected. "+
					"A PsusValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PsusValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PsusValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PsusValue Attribute Value",
				"While creating a PsusValue value, an extra attribute value was detected. "+
					"A PsusValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PsusValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPsusValueUnknown(), diags
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewPsusValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return NewPsusValueUnknown(), diags
	}

	statusVal, ok := statusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be basetypes.StringValue, was: %T`, statusAttribute))
	}

	if diags.HasError() {
		return NewPsusValueUnknown(), diags
	}

	return PsusValue{
		Name:   nameVal,
		Status: statusVal,
		state:  attr.ValueStateKnown,
	}, diags
}

func NewPsusValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PsusValue {
	object, diags := NewPsusValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPsusValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PsusType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPsusValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPsusValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPsusValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPsusValueMust(PsusValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PsusType) ValueType(ctx context.Context) attr.Value {
	return PsusValue{}
}

var _ basetypes.ObjectValuable = PsusValue{}

type PsusValue struct {
	Name   basetypes.StringValue `tfsdk:"name"`
	Status basetypes.StringValue `tfsdk:"status"`
	state  attr.ValueState
}

func (v PsusValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["status"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Status.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["status"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PsusValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PsusValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PsusValue) String() string {
	return "PsusValue"
}

func (v PsusValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"name":   basetypes.StringType{},
		"status": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"name":   v.Name,
			"status": v.Status,
		})

	return objVal, diags
}

func (v PsusValue) Equal(o attr.Value) bool {
	other, ok := o.(PsusValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Status.Equal(other.Status) {
		return false
	}

	return true
}

func (v PsusValue) Type(ctx context.Context) attr.Type {
	return PsusType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PsusValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"name":   basetypes.StringType{},
		"status": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = TemperaturesType{}

type TemperaturesType struct {
	basetypes.ObjectType
}

func (t TemperaturesType) Equal(o attr.Type) bool {
	other, ok := o.(TemperaturesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t TemperaturesType) String() string {
	return "TemperaturesType"
}

func (t TemperaturesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	celsiusAttribute, ok := attributes["celsius"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`celsius is missing from object`)

		return nil, diags
	}

	celsiusVal, ok := celsiusAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`celsius expected to be basetypes.NumberValue, was: %T`, celsiusAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return nil, diags
	}

	statusVal, ok := statusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be basetypes.StringValue, was: %T`, statusAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return TemperaturesValue{
		Celsius: celsiusVal,
		Name:    nameVal,
		Status:  statusVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewTemperaturesValueNull() TemperaturesValue {
	return TemperaturesValue{
		state: attr.ValueStateNull,
	}
}

func NewTemperaturesValueUnknown() TemperaturesValue {
	return TemperaturesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewTemperaturesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (TemperaturesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing TemperaturesValue Attribute Value",
				"While creating a TemperaturesValue value, a missing attribute value was detected. "+
					"A TemperaturesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TemperaturesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid TemperaturesValue Attribute Type",
				"While creating a TemperaturesValue value, an invalid attribute value was detected. "+
					"A TemperaturesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TemperaturesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("TemperaturesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra TemperaturesValue Attribute Value",
				"While creating a TemperaturesValue value, an extra attribute value was detected. "+
					"A TemperaturesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra TemperaturesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewTemperaturesValueUnknown(), diags
	}

	celsiusAttribute, ok := attributes["celsius"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`celsius is missing from object`)

		return NewTemperaturesValueUnknown(), diags
	}

	celsiusVal, ok := celsiusAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`celsius expected to be basetypes.NumberValue, was: %T`, celsiusAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewTemperaturesValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return NewTemperaturesValueUnknown(), diags
	}

	statusVal, ok := statusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be basetypes.StringValue, was: %T`, statusAttribute))
	}

	if diags.HasError() {
		return NewTemperaturesValueUnknown(), diags
	}

	return TemperaturesValue{
		Celsius: celsiusVal,
		Name:    nameVal,
		Status:  statusVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewTemperaturesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) TemperaturesValue {
	object, diags := NewTemperaturesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewTemperaturesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t TemperaturesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewTemperaturesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewTemperaturesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewTemperaturesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewTemperaturesValueMust(TemperaturesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t TemperaturesType) ValueType(ctx context.Context) attr.Value {
	return TemperaturesValue{}
}

var _ basetypes.ObjectValuable = TemperaturesValue{}

type TemperaturesValue struct {
	Celsius basetypes.NumberValue `tfsdk:"celsius"`
	Name    basetypes.StringValue `tfsdk:"name"`
	Status  basetypes.StringValue `tfsdk:"status"`
	state   attr.ValueState
}

func (v TemperaturesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["celsius"] = basetypes.NumberType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["status"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Celsius.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["celsius"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Status.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["status"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v TemperaturesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v TemperaturesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v TemperaturesValue) String() string {
	return "TemperaturesValue"
}

func (v TemperaturesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"celsius": basetypes.NumberType{},
		"name":    basetypes.StringType{},
		"status":  basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"celsius": v.Celsius,
			"name":    v.Name,
			"status":  v.Status,
		})

	return objVal, diags
}

func (v TemperaturesValue) Equal(o attr.Value) bool {
	other, ok := o.(TemperaturesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Celsius.Equal(other.Celsius) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Status.Equal(other.Status) {
		return false
	}

	return true
}

func (v TemperaturesValue) Type(ctx context.Context) attr.Type {
	return TemperaturesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v TemperaturesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"celsius": basetypes.NumberType{},
		"name":    basetypes.StringType{},
		"status":  basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = VcLinksType{}

type VcLinksType struct {
	basetypes.ObjectType
}

func (t VcLinksType) Equal(o attr.Type) bool {
	other, ok := o.(VcLinksType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t VcLinksType) String() string {
	return "VcLinksType"
}

func (t VcLinksType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	neighborModuleIdxAttribute, ok := attributes["neighbor_module_idx"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`neighbor_module_idx is missing from object`)

		return nil, diags
	}

	neighborModuleIdxVal, ok := neighborModuleIdxAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`neighbor_module_idx expected to be basetypes.Int64Value, was: %T`, neighborModuleIdxAttribute))
	}

	neighborPortIdAttribute, ok := attributes["neighbor_port_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`neighbor_port_id is missing from object`)

		return nil, diags
	}

	neighborPortIdVal, ok := neighborPortIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`neighbor_port_id expected to be basetypes.StringValue, was: %T`, neighborPortIdAttribute))
	}

	portIdAttribute, ok := attributes["port_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_id is missing from object`)

		return nil, diags
	}

	portIdVal, ok := portIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_id expected to be basetypes.StringValue, was: %T`, portIdAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return VcLinksValue{
		NeighborModuleIdx: neighborModuleIdxVal,
		NeighborPortId:    neighborPortIdVal,
		PortId:            portIdVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewVcLinksValueNull() VcLinksValue {
	return VcLinksValue{
		state: attr.ValueStateNull,
	}
}

func NewVcLinksValueUnknown() VcLinksValue {
	return VcLinksValue{
		state: attr.ValueStateUnknown,
	}
}

func NewVcLinksValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (VcLinksValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing VcLinksValue Attribute Value",
				"While creating a VcLinksValue value, a missing attribute value was detected. "+
					"A VcLinksValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VcLinksValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid VcLinksValue Attribute Type",
				"While creating a VcLinksValue value, an invalid attribute value was detected. "+
					"A VcLinksValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VcLinksValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("VcLinksValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra VcLinksValue Attribute Value",
				"While creating a VcLinksValue value, an extra attribute value was detected. "+
					"A VcLinksValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra VcLinksValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewVcLinksValueUnknown(), diags
	}

	neighborModuleIdxAttribute, ok := attributes["neighbor_module_idx"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`neighbor_module_idx is missing from object`)

		return NewVcLinksValueUnknown(), diags
	}

	neighborModuleIdxVal, ok := neighborModuleIdxAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`neighbor_module_idx expected to be basetypes.Int64Value, was: %T`, neighborModuleIdxAttribute))
	}

	neighborPortIdAttribute, ok := attributes["neighbor_port_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`neighbor_port_id is missing from object`)

		return NewVcLinksValueUnknown(), diags
	}

	neighborPortIdVal, ok := neighborPortIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`neighbor_port_id expected to be basetypes.StringValue, was: %T`, neighborPortIdAttribute))
	}

	portIdAttribute, ok := attributes["port_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_id is missing from object`)

		return NewVcLinksValueUnknown(), diags
	}

	portIdVal, ok := portIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_id expected to be basetypes.StringValue, was: %T`, portIdAttribute))
	}

	if diags.HasError() {
		return NewVcLinksValueUnknown(), diags
	}

	return VcLinksValue{
		NeighborModuleIdx: neighborModuleIdxVal,
		NeighborPortId:    neighborPortIdVal,
		PortId:            portIdVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewVcLinksValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) VcLinksValue {
	object, diags := NewVcLinksValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewVcLinksValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t VcLinksType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewVcLinksValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewVcLinksValueUnknown(), nil
	}

	if in.IsNull() {
		return NewVcLinksValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewVcLinksValueMust(VcLinksValue{}.AttributeTypes(ctx), attributes), nil
}

func (t VcLinksType) ValueType(ctx context.Context) attr.Value {
	return VcLinksValue{}
}

var _ basetypes.ObjectValuable = VcLinksValue{}

type VcLinksValue struct {
	NeighborModuleIdx basetypes.Int64Value  `tfsdk:"neighbor_module_idx"`
	NeighborPortId    basetypes.StringValue `tfsdk:"neighbor_port_id"`
	PortId            basetypes.StringValue `tfsdk:"port_id"`
	state             attr.ValueState
}

func (v VcLinksValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["neighbor_module_idx"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["neighbor_port_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["port_id"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.NeighborModuleIdx.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["neighbor_module_idx"] = val

		val, err = v.NeighborPortId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["neighbor_port_id"] = val

		val, err = v.PortId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port_id"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v VcLinksValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v VcLinksValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v VcLinksValue) String() string {
	return "VcLinksValue"
}

func (v VcLinksValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"neighbor_module_idx": basetypes.Int64Type{},
		"neighbor_port_id":    basetypes.StringType{},
		"port_id":             basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"neighbor_module_idx": v.NeighborModuleIdx,
			"neighbor_port_id":    v.NeighborPortId,
			"port_id":             v.PortId,
		})

	return objVal, diags
}

func (v VcLinksValue) Equal(o attr.Value) bool {
	other, ok := o.(VcLinksValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.NeighborModuleIdx.Equal(other.NeighborModuleIdx) {
		return false
	}

	if !v.NeighborPortId.Equal(other.NeighborPortId) {
		return false
	}

	if !v.PortId.Equal(other.PortId) {
		return false
	}

	return true
}

func (v VcLinksValue) Type(ctx context.Context) attr.Type {
	return VcLinksType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v VcLinksValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"neighbor_module_idx": basetypes.Int64Type{},
		"neighbor_port_id":    basetypes.StringType{},
		"port_id":             basetypes.StringType{},
	}
}






























































































































































































var _ basetypes.ObjectTypable = RouteSummaryStatsType{}

type RouteSummaryStatsType struct {
	basetypes.ObjectType
}

func (t RouteSummaryStatsType) Equal(o attr.Type) bool {
	other, ok := o.(RouteSummaryStatsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t RouteSummaryStatsType) String() string {
	return "RouteSummaryStatsType"
}

func (t RouteSummaryStatsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	fibRoutesAttribute, ok := attributes["fib_routes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fib_routes is missing from object`)

		return nil, diags
	}

	fibRoutesVal, ok := fibRoutesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fib_routes expected to be basetypes.Int64Value, was: %T`, fibRoutesAttribute))
	}

	maxUnicastRoutesSupportedAttribute, ok := attributes["max_unicast_routes_supported"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_unicast_routes_supported is missing from object`)

		return nil, diags
	}

	maxUnicastRoutesSupportedVal, ok := maxUnicastRoutesSupportedAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_unicast_routes_supported expected to be basetypes.Int64Value, was: %T`, maxUnicastRoutesSupportedAttribute))
	}

	ribRoutesAttribute, ok := attributes["rib_routes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rib_routes is missing from object`)

		return nil, diags
	}

	ribRoutesVal, ok := ribRoutesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rib_routes expected to be basetypes.Int64Value, was: %T`, ribRoutesAttribute))
	}

	totalRoutesAttribute, ok := attributes["total_routes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`total_routes is missing from object`)

		return nil, diags
	}

	totalRoutesVal, ok := totalRoutesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`total_routes expected to be basetypes.Int64Value, was: %T`, totalRoutesAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return RouteSummaryStatsValue{
		FibRoutes:                 fibRoutesVal,
		MaxUnicastRoutesSupported: maxUnicastRoutesSupportedVal,
		RibRoutes:                 ribRoutesVal,
		TotalRoutes:               totalRoutesVal,
		state:                     attr.ValueStateKnown,
	}, diags
}

func NewRouteSummaryStatsValueNull() RouteSummaryStatsValue {
	return RouteSummaryStatsValue{
		state: attr.ValueStateNull,
	}
}

func NewRouteSummaryStatsValueUnknown() RouteSummaryStatsValue {
	return RouteSummaryStatsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewRouteSummaryStatsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (RouteSummaryStatsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing RouteSummaryStatsValue Attribute Value",
				"While creating a RouteSummaryStatsValue value, a missing attribute value was detected. "+
					"A RouteSummaryStatsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RouteSummaryStatsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid RouteSummaryStatsValue Attribute Type",
				"While creating a RouteSummaryStatsValue value, an invalid attribute value was detected. "+
					"A RouteSummaryStatsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RouteSummaryStatsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("RouteSummaryStatsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra RouteSummaryStatsValue Attribute Value",
				"While creating a RouteSummaryStatsValue value, an extra attribute value was detected. "+
					"A RouteSummaryStatsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra RouteSummaryStatsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewRouteSummaryStatsValueUnknown(), diags
	}

	fibRoutesAttribute, ok := attributes["fib_routes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fib_routes is missing from object`)

		return NewRouteSummaryStatsValueUnknown(), diags
	}

	fibRoutesVal, ok := fibRoutesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fib_routes expected to be basetypes.Int64Value, was: %T`, fibRoutesAttribute))
	}

	maxUnicastRoutesSupportedAttribute, ok := attributes["max_unicast_routes_supported"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_unicast_routes_supported is missing from object`)

		return NewRouteSummaryStatsValueUnknown(), diags
	}

	maxUnicastRoutesSupportedVal, ok := maxUnicastRoutesSupportedAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_unicast_routes_supported expected to be basetypes.Int64Value, was: %T`, maxUnicastRoutesSupportedAttribute))
	}

	ribRoutesAttribute, ok := attributes["rib_routes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rib_routes is missing from object`)

		return NewRouteSummaryStatsValueUnknown(), diags
	}

	ribRoutesVal, ok := ribRoutesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rib_routes expected to be basetypes.Int64Value, was: %T`, ribRoutesAttribute))
	}

	totalRoutesAttribute, ok := attributes["total_routes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`total_routes is missing from object`)

		return NewRouteSummaryStatsValueUnknown(), diags
	}

	totalRoutesVal, ok := totalRoutesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`total_routes expected to be basetypes.Int64Value, was: %T`, totalRoutesAttribute))
	}

	if diags.HasError() {
		return NewRouteSummaryStatsValueUnknown(), diags
	}

	return RouteSummaryStatsValue{
		FibRoutes:                 fibRoutesVal,
		MaxUnicastRoutesSupported: maxUnicastRoutesSupportedVal,
		RibRoutes:                 ribRoutesVal,
		TotalRoutes:               totalRoutesVal,
		state:                     attr.ValueStateKnown,
	}, diags
}

func NewRouteSummaryStatsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) RouteSummaryStatsValue {
	object, diags := NewRouteSummaryStatsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewRouteSummaryStatsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t RouteSummaryStatsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewRouteSummaryStatsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewRouteSummaryStatsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewRouteSummaryStatsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewRouteSummaryStatsValueMust(RouteSummaryStatsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t RouteSummaryStatsType) ValueType(ctx context.Context) attr.Value {
	return RouteSummaryStatsValue{}
}

var _ basetypes.ObjectValuable = RouteSummaryStatsValue{}

type RouteSummaryStatsValue struct {
	FibRoutes                 basetypes.Int64Value `tfsdk:"fib_routes"`
	MaxUnicastRoutesSupported basetypes.Int64Value `tfsdk:"max_unicast_routes_supported"`
	RibRoutes                 basetypes.Int64Value `tfsdk:"rib_routes"`
	TotalRoutes               basetypes.Int64Value `tfsdk:"total_routes"`
	state                     attr.ValueState
}

func (v RouteSummaryStatsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["fib_routes"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["max_unicast_routes_supported"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["rib_routes"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["total_routes"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.FibRoutes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["fib_routes"] = val

		val, err = v.MaxUnicastRoutesSupported.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_unicast_routes_supported"] = val

		val, err = v.RibRoutes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["rib_routes"] = val

		val, err = v.TotalRoutes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["total_routes"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v RouteSummaryStatsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v RouteSummaryStatsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v RouteSummaryStatsValue) String() string {
	return "RouteSummaryStatsValue"
}

func (v RouteSummaryStatsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"fib_routes":                   basetypes.Int64Type{},
		"max_unicast_routes_supported": basetypes.Int64Type{},
		"rib_routes":                   basetypes.Int64Type{},
		"total_routes":                 basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"fib_routes":                   v.FibRoutes,
			"max_unicast_routes_supported": v.MaxUnicastRoutesSupported,
			"rib_routes":                   v.RibRoutes,
			"total_routes":                 v.TotalRoutes,
		})

	return objVal, diags
}

func (v RouteSummaryStatsValue) Equal(o attr.Value) bool {
	other, ok := o.(RouteSummaryStatsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.FibRoutes.Equal(other.FibRoutes) {
		return false
	}

	if !v.MaxUnicastRoutesSupported.Equal(other.MaxUnicastRoutesSupported) {
		return false
	}

	if !v.RibRoutes.Equal(other.RibRoutes) {
		return false
	}

	if !v.TotalRoutes.Equal(other.TotalRoutes) {
		return false
	}

	return true
}

func (v RouteSummaryStatsValue) Type(ctx context.Context) attr.Type {
	return RouteSummaryStatsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v RouteSummaryStatsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"fib_routes":                   basetypes.Int64Type{},
		"max_unicast_routes_supported": basetypes.Int64Type{},
		"rib_routes":                   basetypes.Int64Type{},
		"total_routes":                 basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = ServiceStatType{}

type ServiceStatType struct {
	basetypes.ObjectType
}

func (t ServiceStatType) Equal(o attr.Type) bool {
	other, ok := o.(ServiceStatType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ServiceStatType) String() string {
	return "ServiceStatType"
}

func (t ServiceStatType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	ashVersionAttribute, ok := attributes["ash_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ash_version is missing from object`)

		return nil, diags
	}

	ashVersionVal, ok := ashVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ash_version expected to be basetypes.StringValue, was: %T`, ashVersionAttribute))
	}

	ciaVersionAttribute, ok := attributes["cia_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cia_version is missing from object`)

		return nil, diags
	}

	ciaVersionVal, ok := ciaVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cia_version expected to be basetypes.StringValue, was: %T`, ciaVersionAttribute))
	}

	emberVersionAttribute, ok := attributes["ember_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ember_version is missing from object`)

		return nil, diags
	}

	emberVersionVal, ok := emberVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ember_version expected to be basetypes.StringValue, was: %T`, emberVersionAttribute))
	}

	ipsecClientVersionAttribute, ok := attributes["ipsec_client_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipsec_client_version is missing from object`)

		return nil, diags
	}

	ipsecClientVersionVal, ok := ipsecClientVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipsec_client_version expected to be basetypes.StringValue, was: %T`, ipsecClientVersionAttribute))
	}

	mistAgentVersionAttribute, ok := attributes["mist_agent_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mist_agent_version is missing from object`)

		return nil, diags
	}

	mistAgentVersionVal, ok := mistAgentVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mist_agent_version expected to be basetypes.StringValue, was: %T`, mistAgentVersionAttribute))
	}

	packageVersionAttribute, ok := attributes["package_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`package_version is missing from object`)

		return nil, diags
	}

	packageVersionVal, ok := packageVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`package_version expected to be basetypes.StringValue, was: %T`, packageVersionAttribute))
	}

	testingToolsVersionAttribute, ok := attributes["testing_tools_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`testing_tools_version is missing from object`)

		return nil, diags
	}

	testingToolsVersionVal, ok := testingToolsVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`testing_tools_version expected to be basetypes.StringValue, was: %T`, testingToolsVersionAttribute))
	}

	wheeljackVersionAttribute, ok := attributes["wheeljack_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wheeljack_version is missing from object`)

		return nil, diags
	}

	wheeljackVersionVal, ok := wheeljackVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wheeljack_version expected to be basetypes.StringValue, was: %T`, wheeljackVersionAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ServiceStatValue{
		AshVersion:          ashVersionVal,
		CiaVersion:          ciaVersionVal,
		EmberVersion:        emberVersionVal,
		IpsecClientVersion:  ipsecClientVersionVal,
		MistAgentVersion:    mistAgentVersionVal,
		PackageVersion:      packageVersionVal,
		TestingToolsVersion: testingToolsVersionVal,
		WheeljackVersion:    wheeljackVersionVal,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewServiceStatValueNull() ServiceStatValue {
	return ServiceStatValue{
		state: attr.ValueStateNull,
	}
}

func NewServiceStatValueUnknown() ServiceStatValue {
	return ServiceStatValue{
		state: attr.ValueStateUnknown,
	}
}

func NewServiceStatValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ServiceStatValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ServiceStatValue Attribute Value",
				"While creating a ServiceStatValue value, a missing attribute value was detected. "+
					"A ServiceStatValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ServiceStatValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ServiceStatValue Attribute Type",
				"While creating a ServiceStatValue value, an invalid attribute value was detected. "+
					"A ServiceStatValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ServiceStatValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ServiceStatValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ServiceStatValue Attribute Value",
				"While creating a ServiceStatValue value, an extra attribute value was detected. "+
					"A ServiceStatValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ServiceStatValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewServiceStatValueUnknown(), diags
	}

	ashVersionAttribute, ok := attributes["ash_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ash_version is missing from object`)

		return NewServiceStatValueUnknown(), diags
	}

	ashVersionVal, ok := ashVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ash_version expected to be basetypes.StringValue, was: %T`, ashVersionAttribute))
	}

	ciaVersionAttribute, ok := attributes["cia_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cia_version is missing from object`)

		return NewServiceStatValueUnknown(), diags
	}

	ciaVersionVal, ok := ciaVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cia_version expected to be basetypes.StringValue, was: %T`, ciaVersionAttribute))
	}

	emberVersionAttribute, ok := attributes["ember_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ember_version is missing from object`)

		return NewServiceStatValueUnknown(), diags
	}

	emberVersionVal, ok := emberVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ember_version expected to be basetypes.StringValue, was: %T`, emberVersionAttribute))
	}

	ipsecClientVersionAttribute, ok := attributes["ipsec_client_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipsec_client_version is missing from object`)

		return NewServiceStatValueUnknown(), diags
	}

	ipsecClientVersionVal, ok := ipsecClientVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipsec_client_version expected to be basetypes.StringValue, was: %T`, ipsecClientVersionAttribute))
	}

	mistAgentVersionAttribute, ok := attributes["mist_agent_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mist_agent_version is missing from object`)

		return NewServiceStatValueUnknown(), diags
	}

	mistAgentVersionVal, ok := mistAgentVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mist_agent_version expected to be basetypes.StringValue, was: %T`, mistAgentVersionAttribute))
	}

	packageVersionAttribute, ok := attributes["package_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`package_version is missing from object`)

		return NewServiceStatValueUnknown(), diags
	}

	packageVersionVal, ok := packageVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`package_version expected to be basetypes.StringValue, was: %T`, packageVersionAttribute))
	}

	testingToolsVersionAttribute, ok := attributes["testing_tools_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`testing_tools_version is missing from object`)

		return NewServiceStatValueUnknown(), diags
	}

	testingToolsVersionVal, ok := testingToolsVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`testing_tools_version expected to be basetypes.StringValue, was: %T`, testingToolsVersionAttribute))
	}

	wheeljackVersionAttribute, ok := attributes["wheeljack_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wheeljack_version is missing from object`)

		return NewServiceStatValueUnknown(), diags
	}

	wheeljackVersionVal, ok := wheeljackVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wheeljack_version expected to be basetypes.StringValue, was: %T`, wheeljackVersionAttribute))
	}

	if diags.HasError() {
		return NewServiceStatValueUnknown(), diags
	}

	return ServiceStatValue{
		AshVersion:          ashVersionVal,
		CiaVersion:          ciaVersionVal,
		EmberVersion:        emberVersionVal,
		IpsecClientVersion:  ipsecClientVersionVal,
		MistAgentVersion:    mistAgentVersionVal,
		PackageVersion:      packageVersionVal,
		TestingToolsVersion: testingToolsVersionVal,
		WheeljackVersion:    wheeljackVersionVal,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewServiceStatValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ServiceStatValue {
	object, diags := NewServiceStatValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewServiceStatValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ServiceStatType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewServiceStatValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewServiceStatValueUnknown(), nil
	}

	if in.IsNull() {
		return NewServiceStatValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewServiceStatValueMust(ServiceStatValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ServiceStatType) ValueType(ctx context.Context) attr.Value {
	return ServiceStatValue{}
}

var _ basetypes.ObjectValuable = ServiceStatValue{}

type ServiceStatValue struct {
	AshVersion          basetypes.StringValue `tfsdk:"ash_version"`
	CiaVersion          basetypes.StringValue `tfsdk:"cia_version"`
	EmberVersion        basetypes.StringValue `tfsdk:"ember_version"`
	IpsecClientVersion  basetypes.StringValue `tfsdk:"ipsec_client_version"`
	MistAgentVersion    basetypes.StringValue `tfsdk:"mist_agent_version"`
	PackageVersion      basetypes.StringValue `tfsdk:"package_version"`
	TestingToolsVersion basetypes.StringValue `tfsdk:"testing_tools_version"`
	WheeljackVersion    basetypes.StringValue `tfsdk:"wheeljack_version"`
	state               attr.ValueState
}

func (v ServiceStatValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 8)

	var val tftypes.Value
	var err error

	attrTypes["ash_version"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["cia_version"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ember_version"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ipsec_client_version"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["mist_agent_version"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["package_version"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["testing_tools_version"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["wheeljack_version"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 8)

		val, err = v.AshVersion.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ash_version"] = val

		val, err = v.CiaVersion.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cia_version"] = val

		val, err = v.EmberVersion.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ember_version"] = val

		val, err = v.IpsecClientVersion.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ipsec_client_version"] = val

		val, err = v.MistAgentVersion.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mist_agent_version"] = val

		val, err = v.PackageVersion.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["package_version"] = val

		val, err = v.TestingToolsVersion.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["testing_tools_version"] = val

		val, err = v.WheeljackVersion.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["wheeljack_version"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ServiceStatValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ServiceStatValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ServiceStatValue) String() string {
	return "ServiceStatValue"
}

func (v ServiceStatValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"ash_version":           basetypes.StringType{},
		"cia_version":           basetypes.StringType{},
		"ember_version":         basetypes.StringType{},
		"ipsec_client_version":  basetypes.StringType{},
		"mist_agent_version":    basetypes.StringType{},
		"package_version":       basetypes.StringType{},
		"testing_tools_version": basetypes.StringType{},
		"wheeljack_version":     basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"ash_version":           v.AshVersion,
			"cia_version":           v.CiaVersion,
			"ember_version":         v.EmberVersion,
			"ipsec_client_version":  v.IpsecClientVersion,
			"mist_agent_version":    v.MistAgentVersion,
			"package_version":       v.PackageVersion,
			"testing_tools_version": v.TestingToolsVersion,
			"wheeljack_version":     v.WheeljackVersion,
		})

	return objVal, diags
}

func (v ServiceStatValue) Equal(o attr.Value) bool {
	other, ok := o.(ServiceStatValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AshVersion.Equal(other.AshVersion) {
		return false
	}

	if !v.CiaVersion.Equal(other.CiaVersion) {
		return false
	}

	if !v.EmberVersion.Equal(other.EmberVersion) {
		return false
	}

	if !v.IpsecClientVersion.Equal(other.IpsecClientVersion) {
		return false
	}

	if !v.MistAgentVersion.Equal(other.MistAgentVersion) {
		return false
	}

	if !v.PackageVersion.Equal(other.PackageVersion) {
		return false
	}

	if !v.TestingToolsVersion.Equal(other.TestingToolsVersion) {
		return false
	}

	if !v.WheeljackVersion.Equal(other.WheeljackVersion) {
		return false
	}

	return true
}

func (v ServiceStatValue) Type(ctx context.Context) attr.Type {
	return ServiceStatType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ServiceStatValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"ash_version":           basetypes.StringType{},
		"cia_version":           basetypes.StringType{},
		"ember_version":         basetypes.StringType{},
		"ipsec_client_version":  basetypes.StringType{},
		"mist_agent_version":    basetypes.StringType{},
		"package_version":       basetypes.StringType{},
		"testing_tools_version": basetypes.StringType{},
		"wheeljack_version":     basetypes.StringType{},
	}
}






















var _ basetypes.ObjectTypable = ServiceStatusType{}

type ServiceStatusType struct {
	basetypes.ObjectType
}

func (t ServiceStatusType) Equal(o attr.Type) bool {
	other, ok := o.(ServiceStatusType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ServiceStatusType) String() string {
	return "ServiceStatusType"
}

func (t ServiceStatusType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	appidInstallResultAttribute, ok := attributes["appid_install_result"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`appid_install_result is missing from object`)

		return nil, diags
	}

	appidInstallResultVal, ok := appidInstallResultAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`appid_install_result expected to be basetypes.StringValue, was: %T`, appidInstallResultAttribute))
	}

	appidInstallTimestampAttribute, ok := attributes["appid_install_timestamp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`appid_install_timestamp is missing from object`)

		return nil, diags
	}

	appidInstallTimestampVal, ok := appidInstallTimestampAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`appid_install_timestamp expected to be basetypes.StringValue, was: %T`, appidInstallTimestampAttribute))
	}

	appidStatusAttribute, ok := attributes["appid_status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`appid_status is missing from object`)

		return nil, diags
	}

	appidStatusVal, ok := appidStatusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`appid_status expected to be basetypes.StringValue, was: %T`, appidStatusAttribute))
	}

	appidVersionAttribute, ok := attributes["appid_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`appid_version is missing from object`)

		return nil, diags
	}

	appidVersionVal, ok := appidVersionAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`appid_version expected to be basetypes.Int64Value, was: %T`, appidVersionAttribute))
	}

	ewfStatusAttribute, ok := attributes["ewf_status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ewf_status is missing from object`)

		return nil, diags
	}

	ewfStatusVal, ok := ewfStatusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ewf_status expected to be basetypes.StringValue, was: %T`, ewfStatusAttribute))
	}

	idpInstallResultAttribute, ok := attributes["idp_install_result"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`idp_install_result is missing from object`)

		return nil, diags
	}

	idpInstallResultVal, ok := idpInstallResultAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`idp_install_result expected to be basetypes.StringValue, was: %T`, idpInstallResultAttribute))
	}

	idpInstallTimestampAttribute, ok := attributes["idp_install_timestamp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`idp_install_timestamp is missing from object`)

		return nil, diags
	}

	idpInstallTimestampVal, ok := idpInstallTimestampAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`idp_install_timestamp expected to be basetypes.StringValue, was: %T`, idpInstallTimestampAttribute))
	}

	idpPolicyAttribute, ok := attributes["idp_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`idp_policy is missing from object`)

		return nil, diags
	}

	idpPolicyVal, ok := idpPolicyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`idp_policy expected to be basetypes.StringValue, was: %T`, idpPolicyAttribute))
	}

	idpStatusAttribute, ok := attributes["idp_status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`idp_status is missing from object`)

		return nil, diags
	}

	idpStatusVal, ok := idpStatusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`idp_status expected to be basetypes.StringValue, was: %T`, idpStatusAttribute))
	}

	idpUpdateTimestampAttribute, ok := attributes["idp_update_timestamp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`idp_update_timestamp is missing from object`)

		return nil, diags
	}

	idpUpdateTimestampVal, ok := idpUpdateTimestampAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`idp_update_timestamp expected to be basetypes.StringValue, was: %T`, idpUpdateTimestampAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ServiceStatusValue{
		AppidInstallResult:    appidInstallResultVal,
		AppidInstallTimestamp: appidInstallTimestampVal,
		AppidStatus:           appidStatusVal,
		AppidVersion:          appidVersionVal,
		EwfStatus:             ewfStatusVal,
		IdpInstallResult:      idpInstallResultVal,
		IdpInstallTimestamp:   idpInstallTimestampVal,
		IdpPolicy:             idpPolicyVal,
		IdpStatus:             idpStatusVal,
		IdpUpdateTimestamp:    idpUpdateTimestampVal,
		state:                 attr.ValueStateKnown,
	}, diags
}

func NewServiceStatusValueNull() ServiceStatusValue {
	return ServiceStatusValue{
		state: attr.ValueStateNull,
	}
}

func NewServiceStatusValueUnknown() ServiceStatusValue {
	return ServiceStatusValue{
		state: attr.ValueStateUnknown,
	}
}

func NewServiceStatusValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ServiceStatusValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ServiceStatusValue Attribute Value",
				"While creating a ServiceStatusValue value, a missing attribute value was detected. "+
					"A ServiceStatusValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ServiceStatusValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ServiceStatusValue Attribute Type",
				"While creating a ServiceStatusValue value, an invalid attribute value was detected. "+
					"A ServiceStatusValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ServiceStatusValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ServiceStatusValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ServiceStatusValue Attribute Value",
				"While creating a ServiceStatusValue value, an extra attribute value was detected. "+
					"A ServiceStatusValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ServiceStatusValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewServiceStatusValueUnknown(), diags
	}

	appidInstallResultAttribute, ok := attributes["appid_install_result"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`appid_install_result is missing from object`)

		return NewServiceStatusValueUnknown(), diags
	}

	appidInstallResultVal, ok := appidInstallResultAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`appid_install_result expected to be basetypes.StringValue, was: %T`, appidInstallResultAttribute))
	}

	appidInstallTimestampAttribute, ok := attributes["appid_install_timestamp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`appid_install_timestamp is missing from object`)

		return NewServiceStatusValueUnknown(), diags
	}

	appidInstallTimestampVal, ok := appidInstallTimestampAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`appid_install_timestamp expected to be basetypes.StringValue, was: %T`, appidInstallTimestampAttribute))
	}

	appidStatusAttribute, ok := attributes["appid_status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`appid_status is missing from object`)

		return NewServiceStatusValueUnknown(), diags
	}

	appidStatusVal, ok := appidStatusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`appid_status expected to be basetypes.StringValue, was: %T`, appidStatusAttribute))
	}

	appidVersionAttribute, ok := attributes["appid_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`appid_version is missing from object`)

		return NewServiceStatusValueUnknown(), diags
	}

	appidVersionVal, ok := appidVersionAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`appid_version expected to be basetypes.Int64Value, was: %T`, appidVersionAttribute))
	}

	ewfStatusAttribute, ok := attributes["ewf_status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ewf_status is missing from object`)

		return NewServiceStatusValueUnknown(), diags
	}

	ewfStatusVal, ok := ewfStatusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ewf_status expected to be basetypes.StringValue, was: %T`, ewfStatusAttribute))
	}

	idpInstallResultAttribute, ok := attributes["idp_install_result"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`idp_install_result is missing from object`)

		return NewServiceStatusValueUnknown(), diags
	}

	idpInstallResultVal, ok := idpInstallResultAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`idp_install_result expected to be basetypes.StringValue, was: %T`, idpInstallResultAttribute))
	}

	idpInstallTimestampAttribute, ok := attributes["idp_install_timestamp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`idp_install_timestamp is missing from object`)

		return NewServiceStatusValueUnknown(), diags
	}

	idpInstallTimestampVal, ok := idpInstallTimestampAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`idp_install_timestamp expected to be basetypes.StringValue, was: %T`, idpInstallTimestampAttribute))
	}

	idpPolicyAttribute, ok := attributes["idp_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`idp_policy is missing from object`)

		return NewServiceStatusValueUnknown(), diags
	}

	idpPolicyVal, ok := idpPolicyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`idp_policy expected to be basetypes.StringValue, was: %T`, idpPolicyAttribute))
	}

	idpStatusAttribute, ok := attributes["idp_status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`idp_status is missing from object`)

		return NewServiceStatusValueUnknown(), diags
	}

	idpStatusVal, ok := idpStatusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`idp_status expected to be basetypes.StringValue, was: %T`, idpStatusAttribute))
	}

	idpUpdateTimestampAttribute, ok := attributes["idp_update_timestamp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`idp_update_timestamp is missing from object`)

		return NewServiceStatusValueUnknown(), diags
	}

	idpUpdateTimestampVal, ok := idpUpdateTimestampAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`idp_update_timestamp expected to be basetypes.StringValue, was: %T`, idpUpdateTimestampAttribute))
	}

	if diags.HasError() {
		return NewServiceStatusValueUnknown(), diags
	}

	return ServiceStatusValue{
		AppidInstallResult:    appidInstallResultVal,
		AppidInstallTimestamp: appidInstallTimestampVal,
		AppidStatus:           appidStatusVal,
		AppidVersion:          appidVersionVal,
		EwfStatus:             ewfStatusVal,
		IdpInstallResult:      idpInstallResultVal,
		IdpInstallTimestamp:   idpInstallTimestampVal,
		IdpPolicy:             idpPolicyVal,
		IdpStatus:             idpStatusVal,
		IdpUpdateTimestamp:    idpUpdateTimestampVal,
		state:                 attr.ValueStateKnown,
	}, diags
}

func NewServiceStatusValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ServiceStatusValue {
	object, diags := NewServiceStatusValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewServiceStatusValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ServiceStatusType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewServiceStatusValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewServiceStatusValueUnknown(), nil
	}

	if in.IsNull() {
		return NewServiceStatusValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewServiceStatusValueMust(ServiceStatusValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ServiceStatusType) ValueType(ctx context.Context) attr.Value {
	return ServiceStatusValue{}
}

var _ basetypes.ObjectValuable = ServiceStatusValue{}

type ServiceStatusValue struct {
	AppidInstallResult    basetypes.StringValue `tfsdk:"appid_install_result"`
	AppidInstallTimestamp basetypes.StringValue `tfsdk:"appid_install_timestamp"`
	AppidStatus           basetypes.StringValue `tfsdk:"appid_status"`
	AppidVersion          basetypes.Int64Value  `tfsdk:"appid_version"`
	EwfStatus             basetypes.StringValue `tfsdk:"ewf_status"`
	IdpInstallResult      basetypes.StringValue `tfsdk:"idp_install_result"`
	IdpInstallTimestamp   basetypes.StringValue `tfsdk:"idp_install_timestamp"`
	IdpPolicy             basetypes.StringValue `tfsdk:"idp_policy"`
	IdpStatus             basetypes.StringValue `tfsdk:"idp_status"`
	IdpUpdateTimestamp    basetypes.StringValue `tfsdk:"idp_update_timestamp"`
	state                 attr.ValueState
}

func (v ServiceStatusValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 10)

	var val tftypes.Value
	var err error

	attrTypes["appid_install_result"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["appid_install_timestamp"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["appid_status"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["appid_version"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["ewf_status"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["idp_install_result"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["idp_install_timestamp"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["idp_policy"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["idp_status"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["idp_update_timestamp"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 10)

		val, err = v.AppidInstallResult.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["appid_install_result"] = val

		val, err = v.AppidInstallTimestamp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["appid_install_timestamp"] = val

		val, err = v.AppidStatus.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["appid_status"] = val

		val, err = v.AppidVersion.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["appid_version"] = val

		val, err = v.EwfStatus.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ewf_status"] = val

		val, err = v.IdpInstallResult.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["idp_install_result"] = val

		val, err = v.IdpInstallTimestamp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["idp_install_timestamp"] = val

		val, err = v.IdpPolicy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["idp_policy"] = val

		val, err = v.IdpStatus.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["idp_status"] = val

		val, err = v.IdpUpdateTimestamp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["idp_update_timestamp"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ServiceStatusValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ServiceStatusValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ServiceStatusValue) String() string {
	return "ServiceStatusValue"
}

func (v ServiceStatusValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"appid_install_result":    basetypes.StringType{},
		"appid_install_timestamp": basetypes.StringType{},
		"appid_status":            basetypes.StringType{},
		"appid_version":           basetypes.Int64Type{},
		"ewf_status":              basetypes.StringType{},
		"idp_install_result":      basetypes.StringType{},
		"idp_install_timestamp":   basetypes.StringType{},
		"idp_policy":              basetypes.StringType{},
		"idp_status":              basetypes.StringType{},
		"idp_update_timestamp":    basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"appid_install_result":    v.AppidInstallResult,
			"appid_install_timestamp": v.AppidInstallTimestamp,
			"appid_status":            v.AppidStatus,
			"appid_version":           v.AppidVersion,
			"ewf_status":              v.EwfStatus,
			"idp_install_result":      v.IdpInstallResult,
			"idp_install_timestamp":   v.IdpInstallTimestamp,
			"idp_policy":              v.IdpPolicy,
			"idp_status":              v.IdpStatus,
			"idp_update_timestamp":    v.IdpUpdateTimestamp,
		})

	return objVal, diags
}

func (v ServiceStatusValue) Equal(o attr.Value) bool {
	other, ok := o.(ServiceStatusValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AppidInstallResult.Equal(other.AppidInstallResult) {
		return false
	}

	if !v.AppidInstallTimestamp.Equal(other.AppidInstallTimestamp) {
		return false
	}

	if !v.AppidStatus.Equal(other.AppidStatus) {
		return false
	}

	if !v.AppidVersion.Equal(other.AppidVersion) {
		return false
	}

	if !v.EwfStatus.Equal(other.EwfStatus) {
		return false
	}

	if !v.IdpInstallResult.Equal(other.IdpInstallResult) {
		return false
	}

	if !v.IdpInstallTimestamp.Equal(other.IdpInstallTimestamp) {
		return false
	}

	if !v.IdpPolicy.Equal(other.IdpPolicy) {
		return false
	}

	if !v.IdpStatus.Equal(other.IdpStatus) {
		return false
	}

	if !v.IdpUpdateTimestamp.Equal(other.IdpUpdateTimestamp) {
		return false
	}

	return true
}

func (v ServiceStatusValue) Type(ctx context.Context) attr.Type {
	return ServiceStatusType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ServiceStatusValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"appid_install_result":    basetypes.StringType{},
		"appid_install_timestamp": basetypes.StringType{},
		"appid_status":            basetypes.StringType{},
		"appid_version":           basetypes.Int64Type{},
		"ewf_status":              basetypes.StringType{},
		"idp_install_result":      basetypes.StringType{},
		"idp_install_timestamp":   basetypes.StringType{},
		"idp_policy":              basetypes.StringType{},
		"idp_status":              basetypes.StringType{},
		"idp_update_timestamp":    basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = SpuStatType{}

type SpuStatType struct {
	basetypes.ObjectType
}

func (t SpuStatType) Equal(o attr.Type) bool {
	other, ok := o.(SpuStatType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SpuStatType) String() string {
	return "SpuStatType"
}

func (t SpuStatType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	spuCpuAttribute, ok := attributes["spu_cpu"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`spu_cpu is missing from object`)

		return nil, diags
	}

	spuCpuVal, ok := spuCpuAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`spu_cpu expected to be basetypes.Int64Value, was: %T`, spuCpuAttribute))
	}

	spuCurrentSessionAttribute, ok := attributes["spu_current_session"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`spu_current_session is missing from object`)

		return nil, diags
	}

	spuCurrentSessionVal, ok := spuCurrentSessionAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`spu_current_session expected to be basetypes.Int64Value, was: %T`, spuCurrentSessionAttribute))
	}

	spuMaxSessionAttribute, ok := attributes["spu_max_session"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`spu_max_session is missing from object`)

		return nil, diags
	}

	spuMaxSessionVal, ok := spuMaxSessionAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`spu_max_session expected to be basetypes.Int64Value, was: %T`, spuMaxSessionAttribute))
	}

	spuMemoryAttribute, ok := attributes["spu_memory"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`spu_memory is missing from object`)

		return nil, diags
	}

	spuMemoryVal, ok := spuMemoryAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`spu_memory expected to be basetypes.Int64Value, was: %T`, spuMemoryAttribute))
	}

	spuPendingSessionAttribute, ok := attributes["spu_pending_session"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`spu_pending_session is missing from object`)

		return nil, diags
	}

	spuPendingSessionVal, ok := spuPendingSessionAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`spu_pending_session expected to be basetypes.Int64Value, was: %T`, spuPendingSessionAttribute))
	}

	spuValidSessionAttribute, ok := attributes["spu_valid_session"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`spu_valid_session is missing from object`)

		return nil, diags
	}

	spuValidSessionVal, ok := spuValidSessionAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`spu_valid_session expected to be basetypes.Int64Value, was: %T`, spuValidSessionAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SpuStatValue{
		SpuCpu:            spuCpuVal,
		SpuCurrentSession: spuCurrentSessionVal,
		SpuMaxSession:     spuMaxSessionVal,
		SpuMemory:         spuMemoryVal,
		SpuPendingSession: spuPendingSessionVal,
		SpuValidSession:   spuValidSessionVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewSpuStatValueNull() SpuStatValue {
	return SpuStatValue{
		state: attr.ValueStateNull,
	}
}

func NewSpuStatValueUnknown() SpuStatValue {
	return SpuStatValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSpuStatValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SpuStatValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SpuStatValue Attribute Value",
				"While creating a SpuStatValue value, a missing attribute value was detected. "+
					"A SpuStatValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpuStatValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SpuStatValue Attribute Type",
				"While creating a SpuStatValue value, an invalid attribute value was detected. "+
					"A SpuStatValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpuStatValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SpuStatValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SpuStatValue Attribute Value",
				"While creating a SpuStatValue value, an extra attribute value was detected. "+
					"A SpuStatValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SpuStatValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSpuStatValueUnknown(), diags
	}

	spuCpuAttribute, ok := attributes["spu_cpu"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`spu_cpu is missing from object`)

		return NewSpuStatValueUnknown(), diags
	}

	spuCpuVal, ok := spuCpuAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`spu_cpu expected to be basetypes.Int64Value, was: %T`, spuCpuAttribute))
	}

	spuCurrentSessionAttribute, ok := attributes["spu_current_session"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`spu_current_session is missing from object`)

		return NewSpuStatValueUnknown(), diags
	}

	spuCurrentSessionVal, ok := spuCurrentSessionAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`spu_current_session expected to be basetypes.Int64Value, was: %T`, spuCurrentSessionAttribute))
	}

	spuMaxSessionAttribute, ok := attributes["spu_max_session"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`spu_max_session is missing from object`)

		return NewSpuStatValueUnknown(), diags
	}

	spuMaxSessionVal, ok := spuMaxSessionAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`spu_max_session expected to be basetypes.Int64Value, was: %T`, spuMaxSessionAttribute))
	}

	spuMemoryAttribute, ok := attributes["spu_memory"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`spu_memory is missing from object`)

		return NewSpuStatValueUnknown(), diags
	}

	spuMemoryVal, ok := spuMemoryAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`spu_memory expected to be basetypes.Int64Value, was: %T`, spuMemoryAttribute))
	}

	spuPendingSessionAttribute, ok := attributes["spu_pending_session"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`spu_pending_session is missing from object`)

		return NewSpuStatValueUnknown(), diags
	}

	spuPendingSessionVal, ok := spuPendingSessionAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`spu_pending_session expected to be basetypes.Int64Value, was: %T`, spuPendingSessionAttribute))
	}

	spuValidSessionAttribute, ok := attributes["spu_valid_session"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`spu_valid_session is missing from object`)

		return NewSpuStatValueUnknown(), diags
	}

	spuValidSessionVal, ok := spuValidSessionAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`spu_valid_session expected to be basetypes.Int64Value, was: %T`, spuValidSessionAttribute))
	}

	if diags.HasError() {
		return NewSpuStatValueUnknown(), diags
	}

	return SpuStatValue{
		SpuCpu:            spuCpuVal,
		SpuCurrentSession: spuCurrentSessionVal,
		SpuMaxSession:     spuMaxSessionVal,
		SpuMemory:         spuMemoryVal,
		SpuPendingSession: spuPendingSessionVal,
		SpuValidSession:   spuValidSessionVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewSpuStatValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SpuStatValue {
	object, diags := NewSpuStatValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSpuStatValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SpuStatType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSpuStatValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSpuStatValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSpuStatValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSpuStatValueMust(SpuStatValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SpuStatType) ValueType(ctx context.Context) attr.Value {
	return SpuStatValue{}
}

var _ basetypes.ObjectValuable = SpuStatValue{}

type SpuStatValue struct {
	SpuCpu            basetypes.Int64Value `tfsdk:"spu_cpu"`
	SpuCurrentSession basetypes.Int64Value `tfsdk:"spu_current_session"`
	SpuMaxSession     basetypes.Int64Value `tfsdk:"spu_max_session"`
	SpuMemory         basetypes.Int64Value `tfsdk:"spu_memory"`
	SpuPendingSession basetypes.Int64Value `tfsdk:"spu_pending_session"`
	SpuValidSession   basetypes.Int64Value `tfsdk:"spu_valid_session"`
	state             attr.ValueState
}

func (v SpuStatValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 6)

	var val tftypes.Value
	var err error

	attrTypes["spu_cpu"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["spu_current_session"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["spu_max_session"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["spu_memory"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["spu_pending_session"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["spu_valid_session"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 6)

		val, err = v.SpuCpu.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["spu_cpu"] = val

		val, err = v.SpuCurrentSession.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["spu_current_session"] = val

		val, err = v.SpuMaxSession.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["spu_max_session"] = val

		val, err = v.SpuMemory.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["spu_memory"] = val

		val, err = v.SpuPendingSession.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["spu_pending_session"] = val

		val, err = v.SpuValidSession.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["spu_valid_session"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SpuStatValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SpuStatValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SpuStatValue) String() string {
	return "SpuStatValue"
}

func (v SpuStatValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"spu_cpu":             basetypes.Int64Type{},
		"spu_current_session": basetypes.Int64Type{},
		"spu_max_session":     basetypes.Int64Type{},
		"spu_memory":          basetypes.Int64Type{},
		"spu_pending_session": basetypes.Int64Type{},
		"spu_valid_session":   basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"spu_cpu":             v.SpuCpu,
			"spu_current_session": v.SpuCurrentSession,
			"spu_max_session":     v.SpuMaxSession,
			"spu_memory":          v.SpuMemory,
			"spu_pending_session": v.SpuPendingSession,
			"spu_valid_session":   v.SpuValidSession,
		})

	return objVal, diags
}

func (v SpuStatValue) Equal(o attr.Value) bool {
	other, ok := o.(SpuStatValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.SpuCpu.Equal(other.SpuCpu) {
		return false
	}

	if !v.SpuCurrentSession.Equal(other.SpuCurrentSession) {
		return false
	}

	if !v.SpuMaxSession.Equal(other.SpuMaxSession) {
		return false
	}

	if !v.SpuMemory.Equal(other.SpuMemory) {
		return false
	}

	if !v.SpuPendingSession.Equal(other.SpuPendingSession) {
		return false
	}

	if !v.SpuValidSession.Equal(other.SpuValidSession) {
		return false
	}

	return true
}

func (v SpuStatValue) Type(ctx context.Context) attr.Type {
	return SpuStatType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SpuStatValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"spu_cpu":             basetypes.Int64Type{},
		"spu_current_session": basetypes.Int64Type{},
		"spu_max_session":     basetypes.Int64Type{},
		"spu_memory":          basetypes.Int64Type{},
		"spu_pending_session": basetypes.Int64Type{},
		"spu_valid_session":   basetypes.Int64Type{},
	}
}





















