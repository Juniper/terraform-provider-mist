// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package datasource_device_gateway_stats

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework-validators/mapvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/datasource/schema"
)

func DeviceGatewayStatsDataSourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"device_gateway_stats": schema.SetNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"ap_redundancy": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"modules": schema.MapNestedAttribute{
									NestedObject: schema.NestedAttributeObject{
										Attributes: map[string]schema.Attribute{
											"num_aps": schema.Int64Attribute{
												Computed: true,
											},
											"num_aps_with_switch_redundancy": schema.Int64Attribute{
												Computed: true,
											},
										},
										CustomType: ModulesType{
											ObjectType: types.ObjectType{
												AttrTypes: ModulesValue{}.AttributeTypes(ctx),
											},
										},
									},
									Computed:            true,
									Description:         "Property key is the node id",
									MarkdownDescription: "Property key is the node id",
									Validators: []validator.Map{
										mapvalidator.SizeAtLeast(1),
									},
								},
								"num_aps": schema.Int64Attribute{
									Computed: true,
								},
								"num_aps_with_switch_redundancy": schema.Int64Attribute{
									Computed: true,
								},
							},
							CustomType: ApRedundancyType{
								ObjectType: types.ObjectType{
									AttrTypes: ApRedundancyValue{}.AttributeTypes(ctx),
								},
							},
							Computed: true,
						},
						"arp_table_stats": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"arp_table_count": schema.Int64Attribute{
									Computed: true,
								},
								"max_entries_supported": schema.Int64Attribute{
									Computed: true,
								},
							},
							CustomType: ArpTableStatsType{
								ObjectType: types.ObjectType{
									AttrTypes: ArpTableStatsValue{}.AttributeTypes(ctx),
								},
							},
							Computed: true,
						},
						"bgp_peers": schema.ListNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"evpn_overlay": schema.BoolAttribute{
										Computed:            true,
										Description:         "If this is created for evpn overlay",
										MarkdownDescription: "If this is created for evpn overlay",
									},
									"for_overlay": schema.BoolAttribute{
										Computed:            true,
										Description:         "If this is created for overlay",
										MarkdownDescription: "If this is created for overlay",
									},
									"local_as": schema.Int64Attribute{
										Computed:            true,
										Description:         "AS",
										MarkdownDescription: "AS",
									},
									"neighbor": schema.StringAttribute{
										Computed: true,
									},
									"neighbor_as": schema.Int64Attribute{
										Computed: true,
									},
									"neighbor_mac": schema.StringAttribute{
										Computed:            true,
										Description:         "If it's another device in the same org",
										MarkdownDescription: "If it's another device in the same org",
									},
									"node": schema.StringAttribute{
										Computed:            true,
										Description:         "Node0/node1",
										MarkdownDescription: "Node0/node1",
									},
									"rx_pkts": schema.Int64Attribute{
										Computed: true,
									},
									"rx_routes": schema.Int64Attribute{
										Computed:            true,
										Description:         "Number of received routes",
										MarkdownDescription: "Number of received routes",
									},
									"state": schema.StringAttribute{
										Computed:            true,
										Description:         "enum: `active`, `connect`, `established`, `idle`, `open_config`, `open_sent`",
										MarkdownDescription: "enum: `active`, `connect`, `established`, `idle`, `open_config`, `open_sent`",
									},
									"timestamp": schema.Float64Attribute{
										Computed:            true,
										Description:         "Epoch (seconds)",
										MarkdownDescription: "Epoch (seconds)",
									},
									"tx_pkts": schema.Int64Attribute{
										Computed: true,
									},
									"tx_routes": schema.Int64Attribute{
										Computed: true,
									},
									"up": schema.BoolAttribute{
										Computed: true,
									},
									"uptime": schema.Int64Attribute{
										Computed: true,
									},
									"vrf_name": schema.StringAttribute{
										Computed: true,
									},
								},
								CustomType: BgpPeersType{
									ObjectType: types.ObjectType{
										AttrTypes: BgpPeersValue{}.AttributeTypes(ctx),
									},
								},
							},
							Computed:            true,
							Description:         "Only present when `bgp_peers` in `fields` query parameter. Each port object is same as `GET /api/v1/sites/{site_id}/stats/bgp_peers/search` result object, except that org_id, site_id, mac, model are removed",
							MarkdownDescription: "Only present when `bgp_peers` in `fields` query parameter. Each port object is same as `GET /api/v1/sites/{site_id}/stats/bgp_peers/search` result object, except that org_id, site_id, mac, model are removed",
						},
						"cert_expiry": schema.Int64Attribute{
							Computed: true,
						},
						"cluster_config": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"configuration": schema.StringAttribute{
									Computed: true,
								},
								"control_link_info": schema.SingleNestedAttribute{
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											Computed: true,
										},
										"status": schema.StringAttribute{
											Computed: true,
										},
									},
									CustomType: ControlLinkInfoType{
										ObjectType: types.ObjectType{
											AttrTypes: ControlLinkInfoValue{}.AttributeTypes(ctx),
										},
									},
									Computed: true,
								},
								"ethernet_connection": schema.ListNestedAttribute{
									NestedObject: schema.NestedAttributeObject{
										Attributes: map[string]schema.Attribute{
											"name": schema.StringAttribute{
												Computed: true,
											},
											"status": schema.StringAttribute{
												Computed: true,
											},
										},
										CustomType: EthernetConnectionType{
											ObjectType: types.ObjectType{
												AttrTypes: EthernetConnectionValue{}.AttributeTypes(ctx),
											},
										},
									},
									Computed: true,
								},
								"fabric_link_info": schema.SingleNestedAttribute{
									Attributes: map[string]schema.Attribute{
										"data_plane_notified_status": schema.StringAttribute{
											Computed: true,
										},
										"interface": schema.ListAttribute{
											ElementType: types.StringType,
											Computed:    true,
										},
										"internal_status": schema.StringAttribute{
											Computed: true,
										},
										"state": schema.StringAttribute{
											Computed: true,
										},
										"status": schema.StringAttribute{
											Computed: true,
										},
									},
									CustomType: FabricLinkInfoType{
										ObjectType: types.ObjectType{
											AttrTypes: FabricLinkInfoValue{}.AttributeTypes(ctx),
										},
									},
									Computed: true,
								},
								"last_status_change_reason": schema.StringAttribute{
									Computed: true,
								},
								"operational": schema.StringAttribute{
									Computed: true,
								},
								"primary_node_health": schema.StringAttribute{
									Computed: true,
								},
								"redundancy_group_information": schema.ListNestedAttribute{
									NestedObject: schema.NestedAttributeObject{
										Attributes: map[string]schema.Attribute{
											"id": schema.Int64Attribute{
												Computed: true,
											},
											"monitoring_failure": schema.StringAttribute{
												Computed: true,
											},
											"threshold": schema.Int64Attribute{
												Computed: true,
											},
										},
										CustomType: RedundancyGroupInformationType{
											ObjectType: types.ObjectType{
												AttrTypes: RedundancyGroupInformationValue{}.AttributeTypes(ctx),
											},
										},
									},
									Computed: true,
								},
								"secondary_node_health": schema.StringAttribute{
									Computed: true,
								},
								"status": schema.StringAttribute{
									Computed: true,
								},
							},
							CustomType: ClusterConfigType{
								ObjectType: types.ObjectType{
									AttrTypes: ClusterConfigValue{}.AttributeTypes(ctx),
								},
							},
							Computed: true,
						},
						"cluster_stat": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"state": schema.StringAttribute{
									Computed: true,
								},
							},
							CustomType: ClusterStatType{
								ObjectType: types.ObjectType{
									AttrTypes: ClusterStatValue{}.AttributeTypes(ctx),
								},
							},
							Computed: true,
						},
						"conductor_name": schema.StringAttribute{
							Computed: true,
						},
						"config_status": schema.StringAttribute{
							Computed: true,
						},
						"cpu2_stat": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"idle": schema.NumberAttribute{
									Computed:            true,
									Description:         "Percentage of CPU time that is idle",
									MarkdownDescription: "Percentage of CPU time that is idle",
								},
								"interrupt": schema.NumberAttribute{
									Computed:            true,
									Description:         "Percentage of CPU time being used by interrupts",
									MarkdownDescription: "Percentage of CPU time being used by interrupts",
								},
								"load_avg": schema.ListAttribute{
									ElementType:         types.NumberType,
									Computed:            true,
									Description:         "Load averages for the last 1, 5, and 15 minutes",
									MarkdownDescription: "Load averages for the last 1, 5, and 15 minutes",
								},
								"system": schema.NumberAttribute{
									Computed:            true,
									Description:         "Percentage of CPU time being used by system processes",
									MarkdownDescription: "Percentage of CPU time being used by system processes",
								},
								"user": schema.NumberAttribute{
									Computed:            true,
									Description:         "Percentage of CPU time being used by user processe",
									MarkdownDescription: "Percentage of CPU time being used by user processe",
								},
							},
							CustomType: CpuStatType{
								ObjectType: types.ObjectType{
									AttrTypes: CpuStatValue{}.AttributeTypes(ctx),
								},
							},
							Computed: true,
						},
						"cpu_stat": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"idle": schema.NumberAttribute{
									Computed:            true,
									Description:         "Percentage of CPU time that is idle",
									MarkdownDescription: "Percentage of CPU time that is idle",
								},
								"interrupt": schema.NumberAttribute{
									Computed:            true,
									Description:         "Percentage of CPU time being used by interrupts",
									MarkdownDescription: "Percentage of CPU time being used by interrupts",
								},
								"load_avg": schema.ListAttribute{
									ElementType:         types.NumberType,
									Computed:            true,
									Description:         "Load averages for the last 1, 5, and 15 minutes",
									MarkdownDescription: "Load averages for the last 1, 5, and 15 minutes",
								},
								"system": schema.NumberAttribute{
									Computed:            true,
									Description:         "Percentage of CPU time being used by system processes",
									MarkdownDescription: "Percentage of CPU time being used by system processes",
								},
								"user": schema.NumberAttribute{
									Computed:            true,
									Description:         "Percentage of CPU time being used by user processe",
									MarkdownDescription: "Percentage of CPU time being used by user processe",
								},
							},
							CustomType: CpuStatType{
								ObjectType: types.ObjectType{
									AttrTypes: CpuStatValue{}.AttributeTypes(ctx),
								},
							},
							Computed: true,
						},
						"created_time": schema.Float64Attribute{
							Computed:            true,
							Description:         "When the object has been created, in epoch",
							MarkdownDescription: "When the object has been created, in epoch",
						},
						"deviceprofile_id": schema.StringAttribute{
							Computed: true,
						},
						"dhcpd2_stat": schema.MapNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"num_ips": schema.Int64Attribute{
										Computed: true,
									},
									"num_leased": schema.Int64Attribute{
										Computed: true,
									},
								},
								CustomType: DhcpdStatType{
									ObjectType: types.ObjectType{
										AttrTypes: DhcpdStatValue{}.AttributeTypes(ctx),
									},
								},
							},
							Computed:            true,
							Description:         "Property key is the network name",
							MarkdownDescription: "Property key is the network name",
							Validators: []validator.Map{
								mapvalidator.SizeAtLeast(1),
							},
						},
						"dhcpd_stat": schema.MapNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"num_ips": schema.Int64Attribute{
										Computed: true,
									},
									"num_leased": schema.Int64Attribute{
										Computed: true,
									},
								},
								CustomType: DhcpdStatType{
									ObjectType: types.ObjectType{
										AttrTypes: DhcpdStatValue{}.AttributeTypes(ctx),
									},
								},
							},
							Computed:            true,
							Description:         "Property key is the network name",
							MarkdownDescription: "Property key is the network name",
							Validators: []validator.Map{
								mapvalidator.SizeAtLeast(1),
							},
						},
						"ext_ip": schema.StringAttribute{
							Computed:            true,
							Description:         "IP address",
							MarkdownDescription: "IP address",
						},
						"fwupdate": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"progress": schema.Int64Attribute{
									Computed: true,
								},
								"status": schema.StringAttribute{
									Computed:            true,
									Description:         "enum: `inprogress`, `failed`, `upgraded`",
									MarkdownDescription: "enum: `inprogress`, `failed`, `upgraded`",
								},
								"status_id": schema.Int64Attribute{
									Computed: true,
								},
								"timestamp": schema.Float64Attribute{
									Computed:            true,
									Description:         "Epoch (seconds)",
									MarkdownDescription: "Epoch (seconds)",
								},
								"will_retry": schema.BoolAttribute{
									Computed: true,
								},
							},
							CustomType: FwupdateType{
								ObjectType: types.ObjectType{
									AttrTypes: FwupdateValue{}.AttributeTypes(ctx),
								},
							},
							Computed: true,
						},
						"has_pcap": schema.BoolAttribute{
							Computed: true,
						},
						"hostname": schema.StringAttribute{
							Computed:            true,
							Description:         "Hostname reported by the device",
							MarkdownDescription: "Hostname reported by the device",
						},
						"id": schema.StringAttribute{
							Computed:            true,
							Description:         "Unique ID of the object instance in the Mist Organization",
							MarkdownDescription: "Unique ID of the object instance in the Mist Organization",
						},
						"if2_stat": schema.MapNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"address_mode": schema.StringAttribute{
										Computed: true,
									},
									"ips": schema.ListAttribute{
										ElementType: types.StringType,
										Computed:    true,
									},
									"nat_addresses": schema.ListAttribute{
										ElementType: types.StringType,
										Computed:    true,
									},
									"network_name": schema.StringAttribute{
										Computed: true,
									},
									"port_id": schema.StringAttribute{
										Computed: true,
									},
									"port_usage": schema.StringAttribute{
										Computed: true,
									},
									"redundancy_state": schema.StringAttribute{
										Computed: true,
									},
									"rx_bytes": schema.Int64Attribute{
										Computed: true,
									},
									"rx_pkts": schema.Int64Attribute{
										Computed: true,
									},
									"servp_info": schema.SingleNestedAttribute{
										Attributes: map[string]schema.Attribute{
											"asn": schema.StringAttribute{
												Computed: true,
											},
											"city": schema.StringAttribute{
												Computed: true,
											},
											"country_code": schema.StringAttribute{
												Computed: true,
											},
											"latitude": schema.NumberAttribute{
												Computed: true,
											},
											"longitude": schema.NumberAttribute{
												Computed: true,
											},
											"org": schema.StringAttribute{
												Computed: true,
											},
											"region_code": schema.StringAttribute{
												Computed: true,
											},
										},
										CustomType: ServpInfoType{
											ObjectType: types.ObjectType{
												AttrTypes: ServpInfoValue{}.AttributeTypes(ctx),
											},
										},
										Computed: true,
									},
									"tx_bytes": schema.Int64Attribute{
										Computed: true,
									},
									"tx_pkts": schema.Int64Attribute{
										Computed: true,
									},
									"up": schema.BoolAttribute{
										Computed: true,
									},
									"vlan": schema.Int64Attribute{
										Computed: true,
									},
									"wan_name": schema.StringAttribute{
										Computed: true,
									},
									"wan_type": schema.StringAttribute{
										Computed: true,
									},
								},
								CustomType: IfStatType{
									ObjectType: types.ObjectType{
										AttrTypes: IfStatValue{}.AttributeTypes(ctx),
									},
								},
							},
							Computed:            true,
							Description:         "Property key is the interface name",
							MarkdownDescription: "Property key is the interface name",
							Validators: []validator.Map{
								mapvalidator.SizeAtLeast(1),
							},
						},
						"if_stat": schema.MapNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"address_mode": schema.StringAttribute{
										Computed: true,
									},
									"ips": schema.ListAttribute{
										ElementType: types.StringType,
										Computed:    true,
									},
									"nat_addresses": schema.ListAttribute{
										ElementType: types.StringType,
										Computed:    true,
									},
									"network_name": schema.StringAttribute{
										Computed: true,
									},
									"port_id": schema.StringAttribute{
										Computed: true,
									},
									"port_usage": schema.StringAttribute{
										Computed: true,
									},
									"redundancy_state": schema.StringAttribute{
										Computed: true,
									},
									"rx_bytes": schema.Int64Attribute{
										Computed: true,
									},
									"rx_pkts": schema.Int64Attribute{
										Computed: true,
									},
									"servp_info": schema.SingleNestedAttribute{
										Attributes: map[string]schema.Attribute{
											"asn": schema.StringAttribute{
												Computed: true,
											},
											"city": schema.StringAttribute{
												Computed: true,
											},
											"country_code": schema.StringAttribute{
												Computed: true,
											},
											"latitude": schema.NumberAttribute{
												Computed: true,
											},
											"longitude": schema.NumberAttribute{
												Computed: true,
											},
											"org": schema.StringAttribute{
												Computed: true,
											},
											"region_code": schema.StringAttribute{
												Computed: true,
											},
										},
										CustomType: ServpInfoType{
											ObjectType: types.ObjectType{
												AttrTypes: ServpInfoValue{}.AttributeTypes(ctx),
											},
										},
										Computed: true,
									},
									"tx_bytes": schema.Int64Attribute{
										Computed: true,
									},
									"tx_pkts": schema.Int64Attribute{
										Computed: true,
									},
									"up": schema.BoolAttribute{
										Computed: true,
									},
									"vlan": schema.Int64Attribute{
										Computed: true,
									},
									"wan_name": schema.StringAttribute{
										Computed: true,
									},
									"wan_type": schema.StringAttribute{
										Computed: true,
									},
								},
								CustomType: IfStatType{
									ObjectType: types.ObjectType{
										AttrTypes: IfStatValue{}.AttributeTypes(ctx),
									},
								},
							},
							Computed:            true,
							Description:         "Property key is the interface name",
							MarkdownDescription: "Property key is the interface name",
							Validators: []validator.Map{
								mapvalidator.SizeAtLeast(1),
							},
						},
						"ip": schema.StringAttribute{
							Computed:            true,
							Description:         "IP address",
							MarkdownDescription: "IP address",
						},
						"ip2_stat": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"dhcp_server": schema.StringAttribute{
									Computed: true,
								},
								"dns": schema.ListAttribute{
									ElementType: types.StringType,
									Computed:    true,
								},
								"dns_suffix": schema.ListAttribute{
									ElementType: types.StringType,
									Computed:    true,
								},
								"gateway": schema.StringAttribute{
									Computed: true,
								},
								"gateway6": schema.StringAttribute{
									Computed: true,
								},
								"ip": schema.StringAttribute{
									Computed: true,
								},
								"ip6": schema.StringAttribute{
									Computed: true,
								},
								"ips": schema.MapAttribute{
									ElementType: types.StringType,
									Computed:    true,
								},
								"netmask": schema.StringAttribute{
									Computed: true,
								},
								"netmask6": schema.StringAttribute{
									Computed: true,
								},
							},
							CustomType: IpStatType{
								ObjectType: types.ObjectType{
									AttrTypes: IpStatValue{}.AttributeTypes(ctx),
								},
							},
							Computed: true,
						},
						"ip_stat": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"dhcp_server": schema.StringAttribute{
									Computed: true,
								},
								"dns": schema.ListAttribute{
									ElementType: types.StringType,
									Computed:    true,
								},
								"dns_suffix": schema.ListAttribute{
									ElementType: types.StringType,
									Computed:    true,
								},
								"gateway": schema.StringAttribute{
									Computed: true,
								},
								"gateway6": schema.StringAttribute{
									Computed: true,
								},
								"ip": schema.StringAttribute{
									Computed: true,
								},
								"ip6": schema.StringAttribute{
									Computed: true,
								},
								"ips": schema.MapAttribute{
									ElementType: types.StringType,
									Computed:    true,
								},
								"netmask": schema.StringAttribute{
									Computed: true,
								},
								"netmask6": schema.StringAttribute{
									Computed: true,
								},
							},
							CustomType: IpStatType{
								ObjectType: types.ObjectType{
									AttrTypes: IpStatValue{}.AttributeTypes(ctx),
								},
							},
							Computed: true,
						},
						"is_ha": schema.BoolAttribute{
							Computed: true,
						},
						"last_seen": schema.Float64Attribute{
							Computed:            true,
							Description:         "Last seen timestamp",
							MarkdownDescription: "Last seen timestamp",
						},
						"mac": schema.StringAttribute{
							Computed:            true,
							Description:         "Device mac",
							MarkdownDescription: "Device mac",
						},
						"map_id": schema.StringAttribute{
							Computed:            true,
							Description:         "Serial Number",
							MarkdownDescription: "Serial Number",
						},
						"memory2_stat": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"usage": schema.NumberAttribute{
									Computed: true,
								},
							},
							CustomType: MemoryStatType{
								ObjectType: types.ObjectType{
									AttrTypes: MemoryStatValue{}.AttributeTypes(ctx),
								},
							},
							Computed:            true,
							Description:         "Memory usage stat (for virtual chassis, memory usage of master RE)",
							MarkdownDescription: "Memory usage stat (for virtual chassis, memory usage of master RE)",
						},
						"memory_stat": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"usage": schema.NumberAttribute{
									Computed: true,
								},
							},
							CustomType: MemoryStatType{
								ObjectType: types.ObjectType{
									AttrTypes: MemoryStatValue{}.AttributeTypes(ctx),
								},
							},
							Computed:            true,
							Description:         "Memory usage stat (for virtual chassis, memory usage of master RE)",
							MarkdownDescription: "Memory usage stat (for virtual chassis, memory usage of master RE)",
						},
						"model": schema.StringAttribute{
							Computed:            true,
							Description:         "Device model",
							MarkdownDescription: "Device model",
						},
						"modified_time": schema.Float64Attribute{
							Computed:            true,
							Description:         "When the object has been modified for the last time, in epoch",
							MarkdownDescription: "When the object has been modified for the last time, in epoch",
						},
						"module2_stat": schema.ListNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"backup_version": schema.StringAttribute{
										Computed: true,
									},
									"bios_version": schema.StringAttribute{
										Computed: true,
									},
									"cpld_version": schema.StringAttribute{
										Computed: true,
									},
									"fans": schema.ListNestedAttribute{
										NestedObject: schema.NestedAttributeObject{
											Attributes: map[string]schema.Attribute{
												"airflow": schema.StringAttribute{
													Computed: true,
												},
												"name": schema.StringAttribute{
													Computed: true,
												},
												"status": schema.StringAttribute{
													Computed: true,
												},
											},
											CustomType: FansType{
												ObjectType: types.ObjectType{
													AttrTypes: FansValue{}.AttributeTypes(ctx),
												},
											},
										},
										Computed: true,
									},
									"fpga_version": schema.StringAttribute{
										Computed: true,
									},
									"last_seen": schema.Float64Attribute{
										Computed:            true,
										Description:         "Last seen timestamp",
										MarkdownDescription: "Last seen timestamp",
									},
									"locating": schema.BoolAttribute{
										Computed: true,
									},
									"mac": schema.StringAttribute{
										Computed: true,
									},
									"model": schema.StringAttribute{
										Computed: true,
									},
									"optics_cpld_version": schema.StringAttribute{
										Computed: true,
									},
									"pending_version": schema.StringAttribute{
										Computed: true,
									},
									"poe": schema.SingleNestedAttribute{
										Attributes: map[string]schema.Attribute{
											"max_power": schema.NumberAttribute{
												Computed: true,
											},
											"power_draw": schema.NumberAttribute{
												Computed: true,
											},
										},
										CustomType: PoeType{
											ObjectType: types.ObjectType{
												AttrTypes: PoeValue{}.AttributeTypes(ctx),
											},
										},
										Computed: true,
									},
									"poe_version": schema.StringAttribute{
										Computed: true,
									},
									"power_cpld_version": schema.StringAttribute{
										Computed: true,
									},
									"psus": schema.ListNestedAttribute{
										NestedObject: schema.NestedAttributeObject{
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													Computed: true,
												},
												"status": schema.StringAttribute{
													Computed: true,
												},
											},
											CustomType: PsusType{
												ObjectType: types.ObjectType{
													AttrTypes: PsusValue{}.AttributeTypes(ctx),
												},
											},
										},
										Computed: true,
									},
									"re_fpga_version": schema.StringAttribute{
										Computed: true,
									},
									"recovery_version": schema.StringAttribute{
										Computed: true,
									},
									"serial": schema.StringAttribute{
										Computed: true,
									},
									"status": schema.StringAttribute{
										Computed: true,
									},
									"temperatures": schema.ListNestedAttribute{
										NestedObject: schema.NestedAttributeObject{
											Attributes: map[string]schema.Attribute{
												"celsius": schema.NumberAttribute{
													Computed: true,
												},
												"name": schema.StringAttribute{
													Computed: true,
												},
												"status": schema.StringAttribute{
													Computed: true,
												},
											},
											CustomType: TemperaturesType{
												ObjectType: types.ObjectType{
													AttrTypes: TemperaturesValue{}.AttributeTypes(ctx),
												},
											},
										},
										Computed: true,
									},
									"tmc_fpga_version": schema.StringAttribute{
										Computed: true,
									},
									"uboot_version": schema.StringAttribute{
										Computed: true,
									},
									"uptime": schema.Int64Attribute{
										Computed: true,
									},
									"vc_links": schema.ListNestedAttribute{
										NestedObject: schema.NestedAttributeObject{
											Attributes: map[string]schema.Attribute{
												"neighbor_module_idx": schema.Int64Attribute{
													Computed: true,
												},
												"neighbor_port_id": schema.StringAttribute{
													Computed: true,
												},
												"port_id": schema.StringAttribute{
													Computed: true,
												},
											},
											CustomType: VcLinksType{
												ObjectType: types.ObjectType{
													AttrTypes: VcLinksValue{}.AttributeTypes(ctx),
												},
											},
										},
										Computed: true,
									},
									"vc_mode": schema.StringAttribute{
										Computed: true,
									},
									"vc_role": schema.StringAttribute{
										Computed:            true,
										Description:         "enum: `master`, `backup`, `linecard`",
										MarkdownDescription: "enum: `master`, `backup`, `linecard`",
									},
									"vc_state": schema.StringAttribute{
										Computed: true,
									},
									"version": schema.StringAttribute{
										Computed: true,
									},
								},
								CustomType: ModuleStatType{
									ObjectType: types.ObjectType{
										AttrTypes: ModuleStatValue{}.AttributeTypes(ctx),
									},
								},
							},
							Computed: true,
						},
						"module_stat": schema.ListNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"backup_version": schema.StringAttribute{
										Computed: true,
									},
									"bios_version": schema.StringAttribute{
										Computed: true,
									},
									"cpld_version": schema.StringAttribute{
										Computed: true,
									},
									"fans": schema.ListNestedAttribute{
										NestedObject: schema.NestedAttributeObject{
											Attributes: map[string]schema.Attribute{
												"airflow": schema.StringAttribute{
													Computed: true,
												},
												"name": schema.StringAttribute{
													Computed: true,
												},
												"status": schema.StringAttribute{
													Computed: true,
												},
											},
											CustomType: FansType{
												ObjectType: types.ObjectType{
													AttrTypes: FansValue{}.AttributeTypes(ctx),
												},
											},
										},
										Computed: true,
									},
									"fpga_version": schema.StringAttribute{
										Computed: true,
									},
									"last_seen": schema.Float64Attribute{
										Computed:            true,
										Description:         "Last seen timestamp",
										MarkdownDescription: "Last seen timestamp",
									},
									"locating": schema.BoolAttribute{
										Computed: true,
									},
									"mac": schema.StringAttribute{
										Computed: true,
									},
									"model": schema.StringAttribute{
										Computed: true,
									},
									"optics_cpld_version": schema.StringAttribute{
										Computed: true,
									},
									"pending_version": schema.StringAttribute{
										Computed: true,
									},
									"poe": schema.SingleNestedAttribute{
										Attributes: map[string]schema.Attribute{
											"max_power": schema.NumberAttribute{
												Computed: true,
											},
											"power_draw": schema.NumberAttribute{
												Computed: true,
											},
										},
										CustomType: PoeType{
											ObjectType: types.ObjectType{
												AttrTypes: PoeValue{}.AttributeTypes(ctx),
											},
										},
										Computed: true,
									},
									"poe_version": schema.StringAttribute{
										Computed: true,
									},
									"power_cpld_version": schema.StringAttribute{
										Computed: true,
									},
									"psus": schema.ListNestedAttribute{
										NestedObject: schema.NestedAttributeObject{
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													Computed: true,
												},
												"status": schema.StringAttribute{
													Computed: true,
												},
											},
											CustomType: PsusType{
												ObjectType: types.ObjectType{
													AttrTypes: PsusValue{}.AttributeTypes(ctx),
												},
											},
										},
										Computed: true,
									},
									"re_fpga_version": schema.StringAttribute{
										Computed: true,
									},
									"recovery_version": schema.StringAttribute{
										Computed: true,
									},
									"serial": schema.StringAttribute{
										Computed: true,
									},
									"status": schema.StringAttribute{
										Computed: true,
									},
									"temperatures": schema.ListNestedAttribute{
										NestedObject: schema.NestedAttributeObject{
											Attributes: map[string]schema.Attribute{
												"celsius": schema.NumberAttribute{
													Computed: true,
												},
												"name": schema.StringAttribute{
													Computed: true,
												},
												"status": schema.StringAttribute{
													Computed: true,
												},
											},
											CustomType: TemperaturesType{
												ObjectType: types.ObjectType{
													AttrTypes: TemperaturesValue{}.AttributeTypes(ctx),
												},
											},
										},
										Computed: true,
									},
									"tmc_fpga_version": schema.StringAttribute{
										Computed: true,
									},
									"uboot_version": schema.StringAttribute{
										Computed: true,
									},
									"uptime": schema.Int64Attribute{
										Computed: true,
									},
									"vc_links": schema.ListNestedAttribute{
										NestedObject: schema.NestedAttributeObject{
											Attributes: map[string]schema.Attribute{
												"neighbor_module_idx": schema.Int64Attribute{
													Computed: true,
												},
												"neighbor_port_id": schema.StringAttribute{
													Computed: true,
												},
												"port_id": schema.StringAttribute{
													Computed: true,
												},
											},
											CustomType: VcLinksType{
												ObjectType: types.ObjectType{
													AttrTypes: VcLinksValue{}.AttributeTypes(ctx),
												},
											},
										},
										Computed: true,
									},
									"vc_mode": schema.StringAttribute{
										Computed: true,
									},
									"vc_role": schema.StringAttribute{
										Computed:            true,
										Description:         "enum: `master`, `backup`, `linecard`",
										MarkdownDescription: "enum: `master`, `backup`, `linecard`",
									},
									"vc_state": schema.StringAttribute{
										Computed: true,
									},
									"version": schema.StringAttribute{
										Computed: true,
									},
								},
								CustomType: ModuleStatType{
									ObjectType: types.ObjectType{
										AttrTypes: ModuleStatValue{}.AttributeTypes(ctx),
									},
								},
							},
							Computed: true,
						},
						"name": schema.StringAttribute{
							Computed:            true,
							Description:         "Device name if configured",
							MarkdownDescription: "Device name if configured",
						},
						"node_name": schema.StringAttribute{
							Computed: true,
						},
						"org_id": schema.StringAttribute{
							Computed: true,
						},
						"ports": schema.ListNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"active": schema.BoolAttribute{
										Computed:            true,
										Description:         "Indicates if interface is active/inactive",
										MarkdownDescription: "Indicates if interface is active/inactive",
									},
									"auth_state": schema.StringAttribute{
										Computed:            true,
										Description:         "if `up`==`true` and has Authenticator role. enum: `authenticated`, `authenticating`, `held`, `init`",
										MarkdownDescription: "if `up`==`true` and has Authenticator role. enum: `authenticated`, `authenticating`, `held`, `init`",
									},
									"disabled": schema.BoolAttribute{
										Computed:            true,
										Description:         "Indicates if interface is disabled",
										MarkdownDescription: "Indicates if interface is disabled",
									},
									"for_site": schema.BoolAttribute{
										Computed: true,
									},
									"full_duplex": schema.BoolAttribute{
										Computed:            true,
										Description:         "Indicates full or half duplex",
										MarkdownDescription: "Indicates full or half duplex",
									},
									"jitter": schema.NumberAttribute{
										Computed:            true,
										Description:         "Last sampled jitter of the interface",
										MarkdownDescription: "Last sampled jitter of the interface",
									},
									"latency": schema.NumberAttribute{
										Computed:            true,
										Description:         "Last sampled latency of the interface",
										MarkdownDescription: "Last sampled latency of the interface",
									},
									"loss": schema.NumberAttribute{
										Computed:            true,
										Description:         "Last sampled loss of the interface",
										MarkdownDescription: "Last sampled loss of the interface",
									},
									"lte_iccid": schema.StringAttribute{
										Computed:            true,
										Description:         "LTE ICCID value, Check for null/empty",
										MarkdownDescription: "LTE ICCID value, Check for null/empty",
									},
									"lte_imei": schema.StringAttribute{
										Computed:            true,
										Description:         "LTE IMEI value, Check for null/empty",
										MarkdownDescription: "LTE IMEI value, Check for null/empty",
									},
									"lte_imsi": schema.StringAttribute{
										Computed:            true,
										Description:         "LTE IMSI value, Check for null/empty",
										MarkdownDescription: "LTE IMSI value, Check for null/empty",
									},
									"mac_count": schema.Int64Attribute{
										Computed:            true,
										Description:         "Number of mac addresses in the forwarding table",
										MarkdownDescription: "Number of mac addresses in the forwarding table",
									},
									"mac_limit": schema.Int64Attribute{
										Computed:            true,
										Description:         "Limit on number of dynamically learned macs",
										MarkdownDescription: "Limit on number of dynamically learned macs",
									},
									"neighbor_mac": schema.StringAttribute{
										Computed:            true,
										Description:         "chassis identifier of the chassis type listed",
										MarkdownDescription: "chassis identifier of the chassis type listed",
									},
									"neighbor_port_desc": schema.StringAttribute{
										Computed:            true,
										Description:         "Description supplied by the system on the interface E.g. \"GigabitEthernet2/0/39\"",
										MarkdownDescription: "Description supplied by the system on the interface E.g. \"GigabitEthernet2/0/39\"",
									},
									"neighbor_system_name": schema.StringAttribute{
										Computed:            true,
										Description:         "Name supplied by the system on the interface E.g. neighbor system name E.g. \"Kumar-Acc-SW.mist.local\"",
										MarkdownDescription: "Name supplied by the system on the interface E.g. neighbor system name E.g. \"Kumar-Acc-SW.mist.local\"",
									},
									"poe_disabled": schema.BoolAttribute{
										Computed:            true,
										Description:         "Is the POE configured not be disabled.",
										MarkdownDescription: "Is the POE configured not be disabled.",
									},
									"poe_mode": schema.StringAttribute{
										Computed:            true,
										Description:         "enum: `802.3af`, `802.3at`, `802.3bt`",
										MarkdownDescription: "enum: `802.3af`, `802.3at`, `802.3bt`",
									},
									"poe_on": schema.BoolAttribute{
										Computed:            true,
										Description:         "Is the device attached to POE",
										MarkdownDescription: "Is the device attached to POE",
									},
									"port_id": schema.StringAttribute{
										Computed: true,
									},
									"port_mac": schema.StringAttribute{
										Computed:            true,
										Description:         "Interface mac address",
										MarkdownDescription: "Interface mac address",
									},
									"port_usage": schema.StringAttribute{
										Computed:            true,
										Description:         "gateway port usage. enum: `lan`",
										MarkdownDescription: "gateway port usage. enum: `lan`",
									},
									"power_draw": schema.NumberAttribute{
										Computed:            true,
										Description:         "Amount of power being used by the interface at the time the command is executed. Unit in watts.",
										MarkdownDescription: "Amount of power being used by the interface at the time the command is executed. Unit in watts.",
									},
									"rx_bcast_pkts": schema.Int64Attribute{
										Computed:            true,
										Description:         "Broadcast input packets",
										MarkdownDescription: "Broadcast input packets",
									},
									"rx_bps": schema.Int64Attribute{
										Computed:            true,
										Description:         "Input rate",
										MarkdownDescription: "Input rate",
									},
									"rx_bytes": schema.Int64Attribute{
										Computed:            true,
										Description:         "Rx bytes",
										MarkdownDescription: "Rx bytes",
									},
									"rx_errors": schema.Int64Attribute{
										Computed:            true,
										Description:         "Input errors",
										MarkdownDescription: "Input errors",
									},
									"rx_mcast_pkts": schema.Int64Attribute{
										Computed:            true,
										Description:         "Multicast input packets",
										MarkdownDescription: "Multicast input packets",
									},
									"rx_pkts": schema.Int64Attribute{
										Computed:            true,
										Description:         "Rx packets",
										MarkdownDescription: "Rx packets",
									},
									"speed": schema.Int64Attribute{
										Computed:            true,
										Description:         "Port speed",
										MarkdownDescription: "Port speed",
									},
									"stp_role": schema.StringAttribute{
										Computed:            true,
										Description:         "if `up`==`true`. enum: `alternate`, `backup`, `designated`, `root`, `root-prevented`",
										MarkdownDescription: "if `up`==`true`. enum: `alternate`, `backup`, `designated`, `root`, `root-prevented`",
									},
									"stp_state": schema.StringAttribute{
										Computed:            true,
										Description:         "if `up`==`true`. enum: `blocking`, `disabled`, `forwarding`, `learning`, `listening`",
										MarkdownDescription: "if `up`==`true`. enum: `blocking`, `disabled`, `forwarding`, `learning`, `listening`",
									},
									"tx_bcast_pkts": schema.Int64Attribute{
										Computed:            true,
										Description:         "Broadcast output packets",
										MarkdownDescription: "Broadcast output packets",
									},
									"tx_bps": schema.Int64Attribute{
										Computed:            true,
										Description:         "Output rate",
										MarkdownDescription: "Output rate",
									},
									"tx_bytes": schema.Int64Attribute{
										Computed:            true,
										Description:         "Tx bytes",
										MarkdownDescription: "Tx bytes",
									},
									"tx_errors": schema.Int64Attribute{
										Computed:            true,
										Description:         "Output errors",
										MarkdownDescription: "Output errors",
									},
									"tx_mcast_pkts": schema.Int64Attribute{
										Computed:            true,
										Description:         "Multicast output packets",
										MarkdownDescription: "Multicast output packets",
									},
									"tx_pkts": schema.Int64Attribute{
										Computed:            true,
										Description:         "Tx packets",
										MarkdownDescription: "Tx packets",
									},
									"type": schema.StringAttribute{
										Computed:            true,
										Description:         "device type. enum: `ap`, `ble`, `gateway`, `mxedge`, `nac`, `switch`",
										MarkdownDescription: "device type. enum: `ap`, `ble`, `gateway`, `mxedge`, `nac`, `switch`",
									},
									"unconfigured": schema.BoolAttribute{
										Computed:            true,
										Description:         "Indicates if interface is unconfigured",
										MarkdownDescription: "Indicates if interface is unconfigured",
									},
									"up": schema.BoolAttribute{
										Computed:            true,
										Description:         "Indicates if interface is up",
										MarkdownDescription: "Indicates if interface is up",
									},
									"xcvr_model": schema.StringAttribute{
										Computed:            true,
										Description:         "Optic Slot ModelName, Check for null/empty",
										MarkdownDescription: "Optic Slot ModelName, Check for null/empty",
									},
									"xcvr_part_number": schema.StringAttribute{
										Computed:            true,
										Description:         "Optic Slot Partnumber, Check for null/empty",
										MarkdownDescription: "Optic Slot Partnumber, Check for null/empty",
									},
									"xcvr_serial": schema.StringAttribute{
										Computed:            true,
										Description:         "Optic Slot SerialNumber, Check for null/empty",
										MarkdownDescription: "Optic Slot SerialNumber, Check for null/empty",
									},
								},
								CustomType: PortsType{
									ObjectType: types.ObjectType{
										AttrTypes: PortsValue{}.AttributeTypes(ctx),
									},
								},
							},
							Computed:            true,
							Description:         "Only present when `ports` in `fields` query parameter. Each port object is same as `GET /api/v1/sites/{site_id}/stats/ports/search` result object, except that org_id, site_id, mac, model are removed",
							MarkdownDescription: "Only present when `ports` in `fields` query parameter. Each port object is same as `GET /api/v1/sites/{site_id}/stats/ports/search` result object, except that org_id, site_id, mac, model are removed",
						},
						"route_summary_stats": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"fib_routes": schema.Int64Attribute{
									Computed: true,
								},
								"max_unicast_routes_supported": schema.Int64Attribute{
									Computed: true,
								},
								"rib_routes": schema.Int64Attribute{
									Computed: true,
								},
								"total_routes": schema.Int64Attribute{
									Computed: true,
								},
							},
							CustomType: RouteSummaryStatsType{
								ObjectType: types.ObjectType{
									AttrTypes: RouteSummaryStatsValue{}.AttributeTypes(ctx),
								},
							},
							Computed: true,
						},
						"router_name": schema.StringAttribute{
							Computed:            true,
							Description:         "Device name if configured",
							MarkdownDescription: "Device name if configured",
						},
						"serial": schema.StringAttribute{
							Computed:            true,
							Description:         "Serial Number",
							MarkdownDescription: "Serial Number",
						},
						"service2_stat": schema.MapNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"ash_version": schema.StringAttribute{
										Computed: true,
									},
									"cia_version": schema.StringAttribute{
										Computed: true,
									},
									"ember_version": schema.StringAttribute{
										Computed: true,
									},
									"ipsec_client_version": schema.StringAttribute{
										Computed: true,
									},
									"mist_agent_version": schema.StringAttribute{
										Computed: true,
									},
									"package_version": schema.StringAttribute{
										Computed: true,
									},
									"testing_tools_version": schema.StringAttribute{
										Computed: true,
									},
									"wheeljack_version": schema.StringAttribute{
										Computed: true,
									},
								},
								CustomType: ServiceStatType{
									ObjectType: types.ObjectType{
										AttrTypes: ServiceStatValue{}.AttributeTypes(ctx),
									},
								},
							},
							Computed: true,
							Validators: []validator.Map{
								mapvalidator.SizeAtLeast(1),
							},
						},
						"service_stat": schema.MapNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"ash_version": schema.StringAttribute{
										Computed: true,
									},
									"cia_version": schema.StringAttribute{
										Computed: true,
									},
									"ember_version": schema.StringAttribute{
										Computed: true,
									},
									"ipsec_client_version": schema.StringAttribute{
										Computed: true,
									},
									"mist_agent_version": schema.StringAttribute{
										Computed: true,
									},
									"package_version": schema.StringAttribute{
										Computed: true,
									},
									"testing_tools_version": schema.StringAttribute{
										Computed: true,
									},
									"wheeljack_version": schema.StringAttribute{
										Computed: true,
									},
								},
								CustomType: ServiceStatType{
									ObjectType: types.ObjectType{
										AttrTypes: ServiceStatValue{}.AttributeTypes(ctx),
									},
								},
							},
							Computed: true,
							Validators: []validator.Map{
								mapvalidator.SizeAtLeast(1),
							},
						},
						"service_status": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"appid_install_result": schema.StringAttribute{
									Computed: true,
								},
								"appid_install_timestamp": schema.StringAttribute{
									Computed: true,
								},
								"appid_status": schema.StringAttribute{
									Computed: true,
								},
								"appid_version": schema.Int64Attribute{
									Computed: true,
								},
								"ewf_status": schema.StringAttribute{
									Computed: true,
								},
								"idp_install_result": schema.StringAttribute{
									Computed: true,
								},
								"idp_install_timestamp": schema.StringAttribute{
									Computed: true,
								},
								"idp_policy": schema.StringAttribute{
									Computed: true,
								},
								"idp_status": schema.StringAttribute{
									Computed: true,
								},
								"idp_update_timestamp": schema.StringAttribute{
									Computed: true,
								},
							},
							CustomType: ServiceStatusType{
								ObjectType: types.ObjectType{
									AttrTypes: ServiceStatusValue{}.AttributeTypes(ctx),
								},
							},
							Computed: true,
						},
						"site_id": schema.StringAttribute{
							Computed: true,
						},
						"spu2_stat": schema.ListNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"spu_cpu": schema.Int64Attribute{
										Computed: true,
									},
									"spu_current_session": schema.Int64Attribute{
										Computed: true,
									},
									"spu_max_session": schema.Int64Attribute{
										Computed: true,
									},
									"spu_memory": schema.Int64Attribute{
										Computed: true,
									},
									"spu_pending_session": schema.Int64Attribute{
										Computed: true,
									},
									"spu_valid_session": schema.Int64Attribute{
										Computed: true,
									},
								},
								CustomType: SpuStatType{
									ObjectType: types.ObjectType{
										AttrTypes: SpuStatValue{}.AttributeTypes(ctx),
									},
								},
							},
							Computed: true,
						},
						"spu_stat": schema.ListNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"spu_cpu": schema.Int64Attribute{
										Computed: true,
									},
									"spu_current_session": schema.Int64Attribute{
										Computed: true,
									},
									"spu_max_session": schema.Int64Attribute{
										Computed: true,
									},
									"spu_memory": schema.Int64Attribute{
										Computed: true,
									},
									"spu_pending_session": schema.Int64Attribute{
										Computed: true,
									},
									"spu_valid_session": schema.Int64Attribute{
										Computed: true,
									},
								},
								CustomType: SpuStatType{
									ObjectType: types.ObjectType{
										AttrTypes: SpuStatValue{}.AttributeTypes(ctx),
									},
								},
							},
							Computed: true,
						},
						"status": schema.StringAttribute{
							Computed: true,
						},
						"tunnels": schema.ListNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"auth_algo": schema.StringAttribute{
										Computed:            true,
										Description:         "Authentication algorithm",
										MarkdownDescription: "Authentication algorithm",
									},
									"encrypt_algo": schema.StringAttribute{
										Computed:            true,
										Description:         "Encryption algorithm",
										MarkdownDescription: "Encryption algorithm",
									},
									"ike_version": schema.StringAttribute{
										Computed:            true,
										Description:         "IKE version",
										MarkdownDescription: "IKE version",
									},
									"ip": schema.StringAttribute{
										Computed:            true,
										Description:         "IPaddress",
										MarkdownDescription: "IPaddress",
									},
									"last_event": schema.StringAttribute{
										Computed:            true,
										Description:         "Reason of why the tunnel is down",
										MarkdownDescription: "Reason of why the tunnel is down",
									},
									"last_flapped": schema.Float64Attribute{
										Computed:            true,
										Description:         "Indicates when the port was last flapped",
										MarkdownDescription: "Indicates when the port was last flapped",
									},
									"node": schema.StringAttribute{
										Computed:            true,
										Description:         "Node0/node1",
										MarkdownDescription: "Node0/node1",
									},
									"peer_host": schema.StringAttribute{
										Computed:            true,
										Description:         "Peer host",
										MarkdownDescription: "Peer host",
									},
									"peer_ip": schema.StringAttribute{
										Computed:            true,
										Description:         "Peer ip address",
										MarkdownDescription: "Peer ip address",
									},
									"priority": schema.StringAttribute{
										Computed:            true,
										Description:         "enum: `primary`, `secondary`",
										MarkdownDescription: "enum: `primary`, `secondary`",
									},
									"protocol": schema.StringAttribute{
										Computed:            true,
										Description:         "enum: `gre`, `ipsec`",
										MarkdownDescription: "enum: `gre`, `ipsec`",
									},
									"rx_bytes": schema.Int64Attribute{
										Computed: true,
									},
									"rx_pkts": schema.Int64Attribute{
										Computed: true,
									},
									"tunnel_name": schema.StringAttribute{
										Computed:            true,
										Description:         "Mist Tunnel Name",
										MarkdownDescription: "Mist Tunnel Name",
									},
									"tx_bytes": schema.Int64Attribute{
										Computed: true,
									},
									"tx_pkts": schema.Int64Attribute{
										Computed: true,
									},
									"up": schema.BoolAttribute{
										Computed: true,
									},
									"uptime": schema.Int64Attribute{
										Computed:            true,
										Description:         "Duration from first (or last) SA was established",
										MarkdownDescription: "Duration from first (or last) SA was established",
									},
									"wan_name": schema.StringAttribute{
										Computed:            true,
										Description:         "WAN interface name",
										MarkdownDescription: "WAN interface name",
									},
								},
								CustomType: TunnelsType{
									ObjectType: types.ObjectType{
										AttrTypes: TunnelsValue{}.AttributeTypes(ctx),
									},
								},
							},
							Computed:            true,
							Description:         "Only present when `tunnels` in `fields` query parameter. Each port object is same as `GET /api/v1/sites/{site_id}/stats/tunnels/search` result object, except that org_id, site_id, mac, model are removed",
							MarkdownDescription: "Only present when `tunnels` in `fields` query parameter. Each port object is same as `GET /api/v1/sites/{site_id}/stats/tunnels/search` result object, except that org_id, site_id, mac, model are removed",
						},
						"uptime": schema.NumberAttribute{
							Computed: true,
						},
						"version": schema.StringAttribute{
							Computed: true,
						},
						"vpn_peers": schema.ListNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"is_active": schema.BoolAttribute{
										Computed:            true,
										Description:         "Redundancy status of the associated interface",
										MarkdownDescription: "Redundancy status of the associated interface",
									},
									"last_seen": schema.Float64Attribute{
										Computed:            true,
										Description:         "Last seen timestamp",
										MarkdownDescription: "Last seen timestamp",
									},
									"latency": schema.NumberAttribute{
										Computed: true,
									},
									"mos": schema.NumberAttribute{
										Computed: true,
									},
									"mtu": schema.Int64Attribute{
										Computed: true,
									},
									"peer_mac": schema.StringAttribute{
										Computed:            true,
										Description:         "Peer router mac address",
										MarkdownDescription: "Peer router mac address",
									},
									"peer_port_id": schema.StringAttribute{
										Computed:            true,
										Description:         "Peer router device interface",
										MarkdownDescription: "Peer router device interface",
									},
									"peer_router_name": schema.StringAttribute{
										Computed: true,
									},
									"peer_site_id": schema.StringAttribute{
										Computed: true,
									},
									"port_id": schema.StringAttribute{
										Computed:            true,
										Description:         "Router device interface",
										MarkdownDescription: "Router device interface",
									},
									"router_name": schema.StringAttribute{
										Computed: true,
									},
									"type": schema.StringAttribute{
										Computed:            true,
										Description:         "`ipsec`for SRX, `svr` for 128T",
										MarkdownDescription: "`ipsec`for SRX, `svr` for 128T",
									},
									"up": schema.BoolAttribute{
										Computed: true,
									},
									"uptime": schema.Int64Attribute{
										Computed: true,
									},
								},
								CustomType: VpnPeersType{
									ObjectType: types.ObjectType{
										AttrTypes: VpnPeersValue{}.AttributeTypes(ctx),
									},
								},
							},
							Computed:            true,
							Description:         "Only present when `vpn_peers` in `fields` query parameter. Each port object is same as `GET /api/v1/sites/{site_id}/stats/vpn_peers/search` result object, except that org_id, site_id, mac, model are removed",
							MarkdownDescription: "Only present when `vpn_peers` in `fields` query parameter. Each port object is same as `GET /api/v1/sites/{site_id}/stats/vpn_peers/search` result object, except that org_id, site_id, mac, model are removed",
						},
					},
					CustomType: DeviceGatewayStatsType{
						ObjectType: types.ObjectType{
							AttrTypes: DeviceGatewayStatsValue{}.AttributeTypes(ctx),
						},
					},
				},
				Computed: true,
			},
			"duration": schema.StringAttribute{
				Optional:            true,
				Description:         "Duration like 7d, 2w",
				MarkdownDescription: "Duration like 7d, 2w",
			},
			"end": schema.Int64Attribute{
				Optional:            true,
				Description:         "End datetime, can be epoch or relative time like -1d, -2h; now if not specified",
				MarkdownDescription: "End datetime, can be epoch or relative time like -1d, -2h; now if not specified",
			},
			"mac": schema.StringAttribute{
				Optional: true,
			},
			"org_id": schema.StringAttribute{
				Required: true,
			},
			"site_id": schema.StringAttribute{
				Optional: true,
			},
			"start": schema.Int64Attribute{
				Optional:            true,
				Description:         "Start datetime, can be epoch or relative time like -1d, -1w; -1d if not specified",
				MarkdownDescription: "Start datetime, can be epoch or relative time like -1d, -1w; -1d if not specified",
			},
			"status": schema.StringAttribute{
				Optional:            true,
				Description:         "enum: `all`, `connected`, `disconnected`",
				MarkdownDescription: "enum: `all`, `connected`, `disconnected`",
				Validators: []validator.String{
					stringvalidator.OneOf(
						"",
						"all",
						"connected",
						"disconnected",
					),
				},
			},
		},
	}
}

type DeviceGatewayStatsModel struct {
	DeviceGatewayStats types.Set    `tfsdk:"device_gateway_stats"`
	Duration           types.String `tfsdk:"duration"`
	End                types.Int64  `tfsdk:"end"`
	Mac                types.String `tfsdk:"mac"`
	OrgId              types.String `tfsdk:"org_id"`
	SiteId             types.String `tfsdk:"site_id"`
	Start              types.Int64  `tfsdk:"start"`
	Status             types.String `tfsdk:"status"`
}

var _ basetypes.ObjectTypable = DeviceGatewayStatsType{}

type DeviceGatewayStatsType struct {
	basetypes.ObjectType
}

func (t DeviceGatewayStatsType) Equal(o attr.Type) bool {
	other, ok := o.(DeviceGatewayStatsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t DeviceGatewayStatsType) String() string {
	return "DeviceGatewayStatsType"
}

func (t DeviceGatewayStatsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	apRedundancyAttribute, ok := attributes["ap_redundancy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ap_redundancy is missing from object`)

		return nil, diags
	}

	apRedundancyVal, ok := apRedundancyAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ap_redundancy expected to be basetypes.ObjectValue, was: %T`, apRedundancyAttribute))
	}

	arpTableStatsAttribute, ok := attributes["arp_table_stats"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`arp_table_stats is missing from object`)

		return nil, diags
	}

	arpTableStatsVal, ok := arpTableStatsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`arp_table_stats expected to be basetypes.ObjectValue, was: %T`, arpTableStatsAttribute))
	}

	bgpPeersAttribute, ok := attributes["bgp_peers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bgp_peers is missing from object`)

		return nil, diags
	}

	bgpPeersVal, ok := bgpPeersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bgp_peers expected to be basetypes.ListValue, was: %T`, bgpPeersAttribute))
	}

	certExpiryAttribute, ok := attributes["cert_expiry"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cert_expiry is missing from object`)

		return nil, diags
	}

	certExpiryVal, ok := certExpiryAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cert_expiry expected to be basetypes.Int64Value, was: %T`, certExpiryAttribute))
	}

	clusterConfigAttribute, ok := attributes["cluster_config"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cluster_config is missing from object`)

		return nil, diags
	}

	clusterConfigVal, ok := clusterConfigAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cluster_config expected to be basetypes.ObjectValue, was: %T`, clusterConfigAttribute))
	}

	clusterStatAttribute, ok := attributes["cluster_stat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cluster_stat is missing from object`)

		return nil, diags
	}

	clusterStatVal, ok := clusterStatAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cluster_stat expected to be basetypes.ObjectValue, was: %T`, clusterStatAttribute))
	}

	conductorNameAttribute, ok := attributes["conductor_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`conductor_name is missing from object`)

		return nil, diags
	}

	conductorNameVal, ok := conductorNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`conductor_name expected to be basetypes.StringValue, was: %T`, conductorNameAttribute))
	}

	configStatusAttribute, ok := attributes["config_status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`config_status is missing from object`)

		return nil, diags
	}

	configStatusVal, ok := configStatusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`config_status expected to be basetypes.StringValue, was: %T`, configStatusAttribute))
	}

	cpu2StatAttribute, ok := attributes["cpu2_stat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cpu2_stat is missing from object`)

		return nil, diags
	}

	cpu2StatVal, ok := cpu2StatAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cpu2_stat expected to be basetypes.ObjectValue, was: %T`, cpu2StatAttribute))
	}

	cpuStatAttribute, ok := attributes["cpu_stat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cpu_stat is missing from object`)

		return nil, diags
	}

	cpuStatVal, ok := cpuStatAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cpu_stat expected to be basetypes.ObjectValue, was: %T`, cpuStatAttribute))
	}

	createdTimeAttribute, ok := attributes["created_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_time is missing from object`)

		return nil, diags
	}

	createdTimeVal, ok := createdTimeAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_time expected to be basetypes.Float64Value, was: %T`, createdTimeAttribute))
	}

	deviceprofileIdAttribute, ok := attributes["deviceprofile_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`deviceprofile_id is missing from object`)

		return nil, diags
	}

	deviceprofileIdVal, ok := deviceprofileIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`deviceprofile_id expected to be basetypes.StringValue, was: %T`, deviceprofileIdAttribute))
	}

	dhcpd2StatAttribute, ok := attributes["dhcpd2_stat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dhcpd2_stat is missing from object`)

		return nil, diags
	}

	dhcpd2StatVal, ok := dhcpd2StatAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dhcpd2_stat expected to be basetypes.MapValue, was: %T`, dhcpd2StatAttribute))
	}

	dhcpdStatAttribute, ok := attributes["dhcpd_stat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dhcpd_stat is missing from object`)

		return nil, diags
	}

	dhcpdStatVal, ok := dhcpdStatAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dhcpd_stat expected to be basetypes.MapValue, was: %T`, dhcpdStatAttribute))
	}

	extIpAttribute, ok := attributes["ext_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ext_ip is missing from object`)

		return nil, diags
	}

	extIpVal, ok := extIpAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ext_ip expected to be basetypes.StringValue, was: %T`, extIpAttribute))
	}

	fwupdateAttribute, ok := attributes["fwupdate"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fwupdate is missing from object`)

		return nil, diags
	}

	fwupdateVal, ok := fwupdateAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fwupdate expected to be basetypes.ObjectValue, was: %T`, fwupdateAttribute))
	}

	hasPcapAttribute, ok := attributes["has_pcap"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`has_pcap is missing from object`)

		return nil, diags
	}

	hasPcapVal, ok := hasPcapAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`has_pcap expected to be basetypes.BoolValue, was: %T`, hasPcapAttribute))
	}

	hostnameAttribute, ok := attributes["hostname"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`hostname is missing from object`)

		return nil, diags
	}

	hostnameVal, ok := hostnameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`hostname expected to be basetypes.StringValue, was: %T`, hostnameAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	if2StatAttribute, ok := attributes["if2_stat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`if2_stat is missing from object`)

		return nil, diags
	}

	if2StatVal, ok := if2StatAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`if2_stat expected to be basetypes.MapValue, was: %T`, if2StatAttribute))
	}

	ifStatAttribute, ok := attributes["if_stat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`if_stat is missing from object`)

		return nil, diags
	}

	ifStatVal, ok := ifStatAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`if_stat expected to be basetypes.MapValue, was: %T`, ifStatAttribute))
	}

	ipAttribute, ok := attributes["ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip is missing from object`)

		return nil, diags
	}

	ipVal, ok := ipAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip expected to be basetypes.StringValue, was: %T`, ipAttribute))
	}

	ip2StatAttribute, ok := attributes["ip2_stat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip2_stat is missing from object`)

		return nil, diags
	}

	ip2StatVal, ok := ip2StatAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip2_stat expected to be basetypes.ObjectValue, was: %T`, ip2StatAttribute))
	}

	ipStatAttribute, ok := attributes["ip_stat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_stat is missing from object`)

		return nil, diags
	}

	ipStatVal, ok := ipStatAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_stat expected to be basetypes.ObjectValue, was: %T`, ipStatAttribute))
	}

	isHaAttribute, ok := attributes["is_ha"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`is_ha is missing from object`)

		return nil, diags
	}

	isHaVal, ok := isHaAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`is_ha expected to be basetypes.BoolValue, was: %T`, isHaAttribute))
	}

	lastSeenAttribute, ok := attributes["last_seen"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`last_seen is missing from object`)

		return nil, diags
	}

	lastSeenVal, ok := lastSeenAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`last_seen expected to be basetypes.Float64Value, was: %T`, lastSeenAttribute))
	}

	macAttribute, ok := attributes["mac"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mac is missing from object`)

		return nil, diags
	}

	macVal, ok := macAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mac expected to be basetypes.StringValue, was: %T`, macAttribute))
	}

	mapIdAttribute, ok := attributes["map_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`map_id is missing from object`)

		return nil, diags
	}

	mapIdVal, ok := mapIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`map_id expected to be basetypes.StringValue, was: %T`, mapIdAttribute))
	}

	memory2StatAttribute, ok := attributes["memory2_stat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`memory2_stat is missing from object`)

		return nil, diags
	}

	memory2StatVal, ok := memory2StatAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`memory2_stat expected to be basetypes.ObjectValue, was: %T`, memory2StatAttribute))
	}

	memoryStatAttribute, ok := attributes["memory_stat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`memory_stat is missing from object`)

		return nil, diags
	}

	memoryStatVal, ok := memoryStatAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`memory_stat expected to be basetypes.ObjectValue, was: %T`, memoryStatAttribute))
	}

	modelAttribute, ok := attributes["model"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`model is missing from object`)

		return nil, diags
	}

	modelVal, ok := modelAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`model expected to be basetypes.StringValue, was: %T`, modelAttribute))
	}

	modifiedTimeAttribute, ok := attributes["modified_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`modified_time is missing from object`)

		return nil, diags
	}

	modifiedTimeVal, ok := modifiedTimeAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`modified_time expected to be basetypes.Float64Value, was: %T`, modifiedTimeAttribute))
	}

	module2StatAttribute, ok := attributes["module2_stat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`module2_stat is missing from object`)

		return nil, diags
	}

	module2StatVal, ok := module2StatAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`module2_stat expected to be basetypes.ListValue, was: %T`, module2StatAttribute))
	}

	moduleStatAttribute, ok := attributes["module_stat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`module_stat is missing from object`)

		return nil, diags
	}

	moduleStatVal, ok := moduleStatAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`module_stat expected to be basetypes.ListValue, was: %T`, moduleStatAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	nodeNameAttribute, ok := attributes["node_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node_name is missing from object`)

		return nil, diags
	}

	nodeNameVal, ok := nodeNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node_name expected to be basetypes.StringValue, was: %T`, nodeNameAttribute))
	}

	orgIdAttribute, ok := attributes["org_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`org_id is missing from object`)

		return nil, diags
	}

	orgIdVal, ok := orgIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`org_id expected to be basetypes.StringValue, was: %T`, orgIdAttribute))
	}

	portsAttribute, ok := attributes["ports"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ports is missing from object`)

		return nil, diags
	}

	portsVal, ok := portsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ports expected to be basetypes.ListValue, was: %T`, portsAttribute))
	}

	routeSummaryStatsAttribute, ok := attributes["route_summary_stats"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`route_summary_stats is missing from object`)

		return nil, diags
	}

	routeSummaryStatsVal, ok := routeSummaryStatsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`route_summary_stats expected to be basetypes.ObjectValue, was: %T`, routeSummaryStatsAttribute))
	}

	routerNameAttribute, ok := attributes["router_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`router_name is missing from object`)

		return nil, diags
	}

	routerNameVal, ok := routerNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`router_name expected to be basetypes.StringValue, was: %T`, routerNameAttribute))
	}

	serialAttribute, ok := attributes["serial"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`serial is missing from object`)

		return nil, diags
	}

	serialVal, ok := serialAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`serial expected to be basetypes.StringValue, was: %T`, serialAttribute))
	}

	service2StatAttribute, ok := attributes["service2_stat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`service2_stat is missing from object`)

		return nil, diags
	}

	service2StatVal, ok := service2StatAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`service2_stat expected to be basetypes.MapValue, was: %T`, service2StatAttribute))
	}

	serviceStatAttribute, ok := attributes["service_stat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`service_stat is missing from object`)

		return nil, diags
	}

	serviceStatVal, ok := serviceStatAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`service_stat expected to be basetypes.MapValue, was: %T`, serviceStatAttribute))
	}

	serviceStatusAttribute, ok := attributes["service_status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`service_status is missing from object`)

		return nil, diags
	}

	serviceStatusVal, ok := serviceStatusAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`service_status expected to be basetypes.ObjectValue, was: %T`, serviceStatusAttribute))
	}

	siteIdAttribute, ok := attributes["site_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`site_id is missing from object`)

		return nil, diags
	}

	siteIdVal, ok := siteIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`site_id expected to be basetypes.StringValue, was: %T`, siteIdAttribute))
	}

	spu2StatAttribute, ok := attributes["spu2_stat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`spu2_stat is missing from object`)

		return nil, diags
	}

	spu2StatVal, ok := spu2StatAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`spu2_stat expected to be basetypes.ListValue, was: %T`, spu2StatAttribute))
	}

	spuStatAttribute, ok := attributes["spu_stat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`spu_stat is missing from object`)

		return nil, diags
	}

	spuStatVal, ok := spuStatAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`spu_stat expected to be basetypes.ListValue, was: %T`, spuStatAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return nil, diags
	}

	statusVal, ok := statusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be basetypes.StringValue, was: %T`, statusAttribute))
	}

	tunnelsAttribute, ok := attributes["tunnels"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tunnels is missing from object`)

		return nil, diags
	}

	tunnelsVal, ok := tunnelsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tunnels expected to be basetypes.ListValue, was: %T`, tunnelsAttribute))
	}

	uptimeAttribute, ok := attributes["uptime"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uptime is missing from object`)

		return nil, diags
	}

	uptimeVal, ok := uptimeAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uptime expected to be basetypes.NumberValue, was: %T`, uptimeAttribute))
	}

	versionAttribute, ok := attributes["version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`version is missing from object`)

		return nil, diags
	}

	versionVal, ok := versionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`version expected to be basetypes.StringValue, was: %T`, versionAttribute))
	}

	vpnPeersAttribute, ok := attributes["vpn_peers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vpn_peers is missing from object`)

		return nil, diags
	}

	vpnPeersVal, ok := vpnPeersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vpn_peers expected to be basetypes.ListValue, was: %T`, vpnPeersAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return DeviceGatewayStatsValue{
		ApRedundancy:      apRedundancyVal,
		ArpTableStats:     arpTableStatsVal,
		BgpPeers:          bgpPeersVal,
		CertExpiry:        certExpiryVal,
		ClusterConfig:     clusterConfigVal,
		ClusterStat:       clusterStatVal,
		ConductorName:     conductorNameVal,
		ConfigStatus:      configStatusVal,
		Cpu2Stat:          cpu2StatVal,
		CpuStat:           cpuStatVal,
		CreatedTime:       createdTimeVal,
		DeviceprofileId:   deviceprofileIdVal,
		Dhcpd2Stat:        dhcpd2StatVal,
		DhcpdStat:         dhcpdStatVal,
		ExtIp:             extIpVal,
		Fwupdate:          fwupdateVal,
		HasPcap:           hasPcapVal,
		Hostname:          hostnameVal,
		Id:                idVal,
		If2Stat:           if2StatVal,
		IfStat:            ifStatVal,
		Ip:                ipVal,
		Ip2Stat:           ip2StatVal,
		IpStat:            ipStatVal,
		IsHa:              isHaVal,
		LastSeen:          lastSeenVal,
		Mac:               macVal,
		MapId:             mapIdVal,
		Memory2Stat:       memory2StatVal,
		MemoryStat:        memoryStatVal,
		Model:             modelVal,
		ModifiedTime:      modifiedTimeVal,
		Module2Stat:       module2StatVal,
		ModuleStat:        moduleStatVal,
		Name:              nameVal,
		NodeName:          nodeNameVal,
		OrgId:             orgIdVal,
		Ports:             portsVal,
		RouteSummaryStats: routeSummaryStatsVal,
		RouterName:        routerNameVal,
		Serial:            serialVal,
		Service2Stat:      service2StatVal,
		ServiceStat:       serviceStatVal,
		ServiceStatus:     serviceStatusVal,
		SiteId:            siteIdVal,
		Spu2Stat:          spu2StatVal,
		SpuStat:           spuStatVal,
		Status:            statusVal,
		Tunnels:           tunnelsVal,
		Uptime:            uptimeVal,
		Version:           versionVal,
		VpnPeers:          vpnPeersVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewDeviceGatewayStatsValueNull() DeviceGatewayStatsValue {
	return DeviceGatewayStatsValue{
		state: attr.ValueStateNull,
	}
}

func NewDeviceGatewayStatsValueUnknown() DeviceGatewayStatsValue {
	return DeviceGatewayStatsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewDeviceGatewayStatsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (DeviceGatewayStatsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing DeviceGatewayStatsValue Attribute Value",
				"While creating a DeviceGatewayStatsValue value, a missing attribute value was detected. "+
					"A DeviceGatewayStatsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DeviceGatewayStatsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid DeviceGatewayStatsValue Attribute Type",
				"While creating a DeviceGatewayStatsValue value, an invalid attribute value was detected. "+
					"A DeviceGatewayStatsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DeviceGatewayStatsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("DeviceGatewayStatsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra DeviceGatewayStatsValue Attribute Value",
				"While creating a DeviceGatewayStatsValue value, an extra attribute value was detected. "+
					"A DeviceGatewayStatsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra DeviceGatewayStatsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewDeviceGatewayStatsValueUnknown(), diags
	}

	apRedundancyAttribute, ok := attributes["ap_redundancy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ap_redundancy is missing from object`)

		return NewDeviceGatewayStatsValueUnknown(), diags
	}

	apRedundancyVal, ok := apRedundancyAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ap_redundancy expected to be basetypes.ObjectValue, was: %T`, apRedundancyAttribute))
	}

	arpTableStatsAttribute, ok := attributes["arp_table_stats"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`arp_table_stats is missing from object`)

		return NewDeviceGatewayStatsValueUnknown(), diags
	}

	arpTableStatsVal, ok := arpTableStatsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`arp_table_stats expected to be basetypes.ObjectValue, was: %T`, arpTableStatsAttribute))
	}

	bgpPeersAttribute, ok := attributes["bgp_peers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bgp_peers is missing from object`)

		return NewDeviceGatewayStatsValueUnknown(), diags
	}

	bgpPeersVal, ok := bgpPeersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bgp_peers expected to be basetypes.ListValue, was: %T`, bgpPeersAttribute))
	}

	certExpiryAttribute, ok := attributes["cert_expiry"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cert_expiry is missing from object`)

		return NewDeviceGatewayStatsValueUnknown(), diags
	}

	certExpiryVal, ok := certExpiryAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cert_expiry expected to be basetypes.Int64Value, was: %T`, certExpiryAttribute))
	}

	clusterConfigAttribute, ok := attributes["cluster_config"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cluster_config is missing from object`)

		return NewDeviceGatewayStatsValueUnknown(), diags
	}

	clusterConfigVal, ok := clusterConfigAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cluster_config expected to be basetypes.ObjectValue, was: %T`, clusterConfigAttribute))
	}

	clusterStatAttribute, ok := attributes["cluster_stat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cluster_stat is missing from object`)

		return NewDeviceGatewayStatsValueUnknown(), diags
	}

	clusterStatVal, ok := clusterStatAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cluster_stat expected to be basetypes.ObjectValue, was: %T`, clusterStatAttribute))
	}

	conductorNameAttribute, ok := attributes["conductor_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`conductor_name is missing from object`)

		return NewDeviceGatewayStatsValueUnknown(), diags
	}

	conductorNameVal, ok := conductorNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`conductor_name expected to be basetypes.StringValue, was: %T`, conductorNameAttribute))
	}

	configStatusAttribute, ok := attributes["config_status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`config_status is missing from object`)

		return NewDeviceGatewayStatsValueUnknown(), diags
	}

	configStatusVal, ok := configStatusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`config_status expected to be basetypes.StringValue, was: %T`, configStatusAttribute))
	}

	cpu2StatAttribute, ok := attributes["cpu2_stat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cpu2_stat is missing from object`)

		return NewDeviceGatewayStatsValueUnknown(), diags
	}

	cpu2StatVal, ok := cpu2StatAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cpu2_stat expected to be basetypes.ObjectValue, was: %T`, cpu2StatAttribute))
	}

	cpuStatAttribute, ok := attributes["cpu_stat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cpu_stat is missing from object`)

		return NewDeviceGatewayStatsValueUnknown(), diags
	}

	cpuStatVal, ok := cpuStatAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cpu_stat expected to be basetypes.ObjectValue, was: %T`, cpuStatAttribute))
	}

	createdTimeAttribute, ok := attributes["created_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_time is missing from object`)

		return NewDeviceGatewayStatsValueUnknown(), diags
	}

	createdTimeVal, ok := createdTimeAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_time expected to be basetypes.Float64Value, was: %T`, createdTimeAttribute))
	}

	deviceprofileIdAttribute, ok := attributes["deviceprofile_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`deviceprofile_id is missing from object`)

		return NewDeviceGatewayStatsValueUnknown(), diags
	}

	deviceprofileIdVal, ok := deviceprofileIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`deviceprofile_id expected to be basetypes.StringValue, was: %T`, deviceprofileIdAttribute))
	}

	dhcpd2StatAttribute, ok := attributes["dhcpd2_stat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dhcpd2_stat is missing from object`)

		return NewDeviceGatewayStatsValueUnknown(), diags
	}

	dhcpd2StatVal, ok := dhcpd2StatAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dhcpd2_stat expected to be basetypes.MapValue, was: %T`, dhcpd2StatAttribute))
	}

	dhcpdStatAttribute, ok := attributes["dhcpd_stat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dhcpd_stat is missing from object`)

		return NewDeviceGatewayStatsValueUnknown(), diags
	}

	dhcpdStatVal, ok := dhcpdStatAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dhcpd_stat expected to be basetypes.MapValue, was: %T`, dhcpdStatAttribute))
	}

	extIpAttribute, ok := attributes["ext_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ext_ip is missing from object`)

		return NewDeviceGatewayStatsValueUnknown(), diags
	}

	extIpVal, ok := extIpAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ext_ip expected to be basetypes.StringValue, was: %T`, extIpAttribute))
	}

	fwupdateAttribute, ok := attributes["fwupdate"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fwupdate is missing from object`)

		return NewDeviceGatewayStatsValueUnknown(), diags
	}

	fwupdateVal, ok := fwupdateAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fwupdate expected to be basetypes.ObjectValue, was: %T`, fwupdateAttribute))
	}

	hasPcapAttribute, ok := attributes["has_pcap"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`has_pcap is missing from object`)

		return NewDeviceGatewayStatsValueUnknown(), diags
	}

	hasPcapVal, ok := hasPcapAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`has_pcap expected to be basetypes.BoolValue, was: %T`, hasPcapAttribute))
	}

	hostnameAttribute, ok := attributes["hostname"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`hostname is missing from object`)

		return NewDeviceGatewayStatsValueUnknown(), diags
	}

	hostnameVal, ok := hostnameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`hostname expected to be basetypes.StringValue, was: %T`, hostnameAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewDeviceGatewayStatsValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	if2StatAttribute, ok := attributes["if2_stat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`if2_stat is missing from object`)

		return NewDeviceGatewayStatsValueUnknown(), diags
	}

	if2StatVal, ok := if2StatAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`if2_stat expected to be basetypes.MapValue, was: %T`, if2StatAttribute))
	}

	ifStatAttribute, ok := attributes["if_stat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`if_stat is missing from object`)

		return NewDeviceGatewayStatsValueUnknown(), diags
	}

	ifStatVal, ok := ifStatAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`if_stat expected to be basetypes.MapValue, was: %T`, ifStatAttribute))
	}

	ipAttribute, ok := attributes["ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip is missing from object`)

		return NewDeviceGatewayStatsValueUnknown(), diags
	}

	ipVal, ok := ipAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip expected to be basetypes.StringValue, was: %T`, ipAttribute))
	}

	ip2StatAttribute, ok := attributes["ip2_stat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip2_stat is missing from object`)

		return NewDeviceGatewayStatsValueUnknown(), diags
	}

	ip2StatVal, ok := ip2StatAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip2_stat expected to be basetypes.ObjectValue, was: %T`, ip2StatAttribute))
	}

	ipStatAttribute, ok := attributes["ip_stat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_stat is missing from object`)

		return NewDeviceGatewayStatsValueUnknown(), diags
	}

	ipStatVal, ok := ipStatAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_stat expected to be basetypes.ObjectValue, was: %T`, ipStatAttribute))
	}

	isHaAttribute, ok := attributes["is_ha"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`is_ha is missing from object`)

		return NewDeviceGatewayStatsValueUnknown(), diags
	}

	isHaVal, ok := isHaAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`is_ha expected to be basetypes.BoolValue, was: %T`, isHaAttribute))
	}

	lastSeenAttribute, ok := attributes["last_seen"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`last_seen is missing from object`)

		return NewDeviceGatewayStatsValueUnknown(), diags
	}

	lastSeenVal, ok := lastSeenAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`last_seen expected to be basetypes.Float64Value, was: %T`, lastSeenAttribute))
	}

	macAttribute, ok := attributes["mac"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mac is missing from object`)

		return NewDeviceGatewayStatsValueUnknown(), diags
	}

	macVal, ok := macAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mac expected to be basetypes.StringValue, was: %T`, macAttribute))
	}

	mapIdAttribute, ok := attributes["map_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`map_id is missing from object`)

		return NewDeviceGatewayStatsValueUnknown(), diags
	}

	mapIdVal, ok := mapIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`map_id expected to be basetypes.StringValue, was: %T`, mapIdAttribute))
	}

	memory2StatAttribute, ok := attributes["memory2_stat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`memory2_stat is missing from object`)

		return NewDeviceGatewayStatsValueUnknown(), diags
	}

	memory2StatVal, ok := memory2StatAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`memory2_stat expected to be basetypes.ObjectValue, was: %T`, memory2StatAttribute))
	}

	memoryStatAttribute, ok := attributes["memory_stat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`memory_stat is missing from object`)

		return NewDeviceGatewayStatsValueUnknown(), diags
	}

	memoryStatVal, ok := memoryStatAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`memory_stat expected to be basetypes.ObjectValue, was: %T`, memoryStatAttribute))
	}

	modelAttribute, ok := attributes["model"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`model is missing from object`)

		return NewDeviceGatewayStatsValueUnknown(), diags
	}

	modelVal, ok := modelAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`model expected to be basetypes.StringValue, was: %T`, modelAttribute))
	}

	modifiedTimeAttribute, ok := attributes["modified_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`modified_time is missing from object`)

		return NewDeviceGatewayStatsValueUnknown(), diags
	}

	modifiedTimeVal, ok := modifiedTimeAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`modified_time expected to be basetypes.Float64Value, was: %T`, modifiedTimeAttribute))
	}

	module2StatAttribute, ok := attributes["module2_stat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`module2_stat is missing from object`)

		return NewDeviceGatewayStatsValueUnknown(), diags
	}

	module2StatVal, ok := module2StatAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`module2_stat expected to be basetypes.ListValue, was: %T`, module2StatAttribute))
	}

	moduleStatAttribute, ok := attributes["module_stat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`module_stat is missing from object`)

		return NewDeviceGatewayStatsValueUnknown(), diags
	}

	moduleStatVal, ok := moduleStatAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`module_stat expected to be basetypes.ListValue, was: %T`, moduleStatAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewDeviceGatewayStatsValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	nodeNameAttribute, ok := attributes["node_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node_name is missing from object`)

		return NewDeviceGatewayStatsValueUnknown(), diags
	}

	nodeNameVal, ok := nodeNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node_name expected to be basetypes.StringValue, was: %T`, nodeNameAttribute))
	}

	orgIdAttribute, ok := attributes["org_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`org_id is missing from object`)

		return NewDeviceGatewayStatsValueUnknown(), diags
	}

	orgIdVal, ok := orgIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`org_id expected to be basetypes.StringValue, was: %T`, orgIdAttribute))
	}

	portsAttribute, ok := attributes["ports"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ports is missing from object`)

		return NewDeviceGatewayStatsValueUnknown(), diags
	}

	portsVal, ok := portsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ports expected to be basetypes.ListValue, was: %T`, portsAttribute))
	}

	routeSummaryStatsAttribute, ok := attributes["route_summary_stats"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`route_summary_stats is missing from object`)

		return NewDeviceGatewayStatsValueUnknown(), diags
	}

	routeSummaryStatsVal, ok := routeSummaryStatsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`route_summary_stats expected to be basetypes.ObjectValue, was: %T`, routeSummaryStatsAttribute))
	}

	routerNameAttribute, ok := attributes["router_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`router_name is missing from object`)

		return NewDeviceGatewayStatsValueUnknown(), diags
	}

	routerNameVal, ok := routerNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`router_name expected to be basetypes.StringValue, was: %T`, routerNameAttribute))
	}

	serialAttribute, ok := attributes["serial"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`serial is missing from object`)

		return NewDeviceGatewayStatsValueUnknown(), diags
	}

	serialVal, ok := serialAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`serial expected to be basetypes.StringValue, was: %T`, serialAttribute))
	}

	service2StatAttribute, ok := attributes["service2_stat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`service2_stat is missing from object`)

		return NewDeviceGatewayStatsValueUnknown(), diags
	}

	service2StatVal, ok := service2StatAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`service2_stat expected to be basetypes.MapValue, was: %T`, service2StatAttribute))
	}

	serviceStatAttribute, ok := attributes["service_stat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`service_stat is missing from object`)

		return NewDeviceGatewayStatsValueUnknown(), diags
	}

	serviceStatVal, ok := serviceStatAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`service_stat expected to be basetypes.MapValue, was: %T`, serviceStatAttribute))
	}

	serviceStatusAttribute, ok := attributes["service_status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`service_status is missing from object`)

		return NewDeviceGatewayStatsValueUnknown(), diags
	}

	serviceStatusVal, ok := serviceStatusAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`service_status expected to be basetypes.ObjectValue, was: %T`, serviceStatusAttribute))
	}

	siteIdAttribute, ok := attributes["site_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`site_id is missing from object`)

		return NewDeviceGatewayStatsValueUnknown(), diags
	}

	siteIdVal, ok := siteIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`site_id expected to be basetypes.StringValue, was: %T`, siteIdAttribute))
	}

	spu2StatAttribute, ok := attributes["spu2_stat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`spu2_stat is missing from object`)

		return NewDeviceGatewayStatsValueUnknown(), diags
	}

	spu2StatVal, ok := spu2StatAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`spu2_stat expected to be basetypes.ListValue, was: %T`, spu2StatAttribute))
	}

	spuStatAttribute, ok := attributes["spu_stat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`spu_stat is missing from object`)

		return NewDeviceGatewayStatsValueUnknown(), diags
	}

	spuStatVal, ok := spuStatAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`spu_stat expected to be basetypes.ListValue, was: %T`, spuStatAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return NewDeviceGatewayStatsValueUnknown(), diags
	}

	statusVal, ok := statusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be basetypes.StringValue, was: %T`, statusAttribute))
	}

	tunnelsAttribute, ok := attributes["tunnels"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tunnels is missing from object`)

		return NewDeviceGatewayStatsValueUnknown(), diags
	}

	tunnelsVal, ok := tunnelsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tunnels expected to be basetypes.ListValue, was: %T`, tunnelsAttribute))
	}

	uptimeAttribute, ok := attributes["uptime"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uptime is missing from object`)

		return NewDeviceGatewayStatsValueUnknown(), diags
	}

	uptimeVal, ok := uptimeAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uptime expected to be basetypes.NumberValue, was: %T`, uptimeAttribute))
	}

	versionAttribute, ok := attributes["version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`version is missing from object`)

		return NewDeviceGatewayStatsValueUnknown(), diags
	}

	versionVal, ok := versionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`version expected to be basetypes.StringValue, was: %T`, versionAttribute))
	}

	vpnPeersAttribute, ok := attributes["vpn_peers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vpn_peers is missing from object`)

		return NewDeviceGatewayStatsValueUnknown(), diags
	}

	vpnPeersVal, ok := vpnPeersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vpn_peers expected to be basetypes.ListValue, was: %T`, vpnPeersAttribute))
	}

	if diags.HasError() {
		return NewDeviceGatewayStatsValueUnknown(), diags
	}

	return DeviceGatewayStatsValue{
		ApRedundancy:      apRedundancyVal,
		ArpTableStats:     arpTableStatsVal,
		BgpPeers:          bgpPeersVal,
		CertExpiry:        certExpiryVal,
		ClusterConfig:     clusterConfigVal,
		ClusterStat:       clusterStatVal,
		ConductorName:     conductorNameVal,
		ConfigStatus:      configStatusVal,
		Cpu2Stat:          cpu2StatVal,
		CpuStat:           cpuStatVal,
		CreatedTime:       createdTimeVal,
		DeviceprofileId:   deviceprofileIdVal,
		Dhcpd2Stat:        dhcpd2StatVal,
		DhcpdStat:         dhcpdStatVal,
		ExtIp:             extIpVal,
		Fwupdate:          fwupdateVal,
		HasPcap:           hasPcapVal,
		Hostname:          hostnameVal,
		Id:                idVal,
		If2Stat:           if2StatVal,
		IfStat:            ifStatVal,
		Ip:                ipVal,
		Ip2Stat:           ip2StatVal,
		IpStat:            ipStatVal,
		IsHa:              isHaVal,
		LastSeen:          lastSeenVal,
		Mac:               macVal,
		MapId:             mapIdVal,
		Memory2Stat:       memory2StatVal,
		MemoryStat:        memoryStatVal,
		Model:             modelVal,
		ModifiedTime:      modifiedTimeVal,
		Module2Stat:       module2StatVal,
		ModuleStat:        moduleStatVal,
		Name:              nameVal,
		NodeName:          nodeNameVal,
		OrgId:             orgIdVal,
		Ports:             portsVal,
		RouteSummaryStats: routeSummaryStatsVal,
		RouterName:        routerNameVal,
		Serial:            serialVal,
		Service2Stat:      service2StatVal,
		ServiceStat:       serviceStatVal,
		ServiceStatus:     serviceStatusVal,
		SiteId:            siteIdVal,
		Spu2Stat:          spu2StatVal,
		SpuStat:           spuStatVal,
		Status:            statusVal,
		Tunnels:           tunnelsVal,
		Uptime:            uptimeVal,
		Version:           versionVal,
		VpnPeers:          vpnPeersVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewDeviceGatewayStatsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) DeviceGatewayStatsValue {
	object, diags := NewDeviceGatewayStatsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewDeviceGatewayStatsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t DeviceGatewayStatsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewDeviceGatewayStatsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewDeviceGatewayStatsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewDeviceGatewayStatsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewDeviceGatewayStatsValueMust(DeviceGatewayStatsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t DeviceGatewayStatsType) ValueType(ctx context.Context) attr.Value {
	return DeviceGatewayStatsValue{}
}

var _ basetypes.ObjectValuable = DeviceGatewayStatsValue{}

type DeviceGatewayStatsValue struct {
	ApRedundancy      basetypes.ObjectValue  `tfsdk:"ap_redundancy"`
	ArpTableStats     basetypes.ObjectValue  `tfsdk:"arp_table_stats"`
	BgpPeers          basetypes.ListValue    `tfsdk:"bgp_peers"`
	CertExpiry        basetypes.Int64Value   `tfsdk:"cert_expiry"`
	ClusterConfig     basetypes.ObjectValue  `tfsdk:"cluster_config"`
	ClusterStat       basetypes.ObjectValue  `tfsdk:"cluster_stat"`
	ConductorName     basetypes.StringValue  `tfsdk:"conductor_name"`
	ConfigStatus      basetypes.StringValue  `tfsdk:"config_status"`
	Cpu2Stat          basetypes.ObjectValue  `tfsdk:"cpu2_stat"`
	CpuStat           basetypes.ObjectValue  `tfsdk:"cpu_stat"`
	CreatedTime       basetypes.Float64Value `tfsdk:"created_time"`
	DeviceprofileId   basetypes.StringValue  `tfsdk:"deviceprofile_id"`
	Dhcpd2Stat        basetypes.MapValue     `tfsdk:"dhcpd2_stat"`
	DhcpdStat         basetypes.MapValue     `tfsdk:"dhcpd_stat"`
	ExtIp             basetypes.StringValue  `tfsdk:"ext_ip"`
	Fwupdate          basetypes.ObjectValue  `tfsdk:"fwupdate"`
	HasPcap           basetypes.BoolValue    `tfsdk:"has_pcap"`
	Hostname          basetypes.StringValue  `tfsdk:"hostname"`
	Id                basetypes.StringValue  `tfsdk:"id"`
	If2Stat           basetypes.MapValue     `tfsdk:"if2_stat"`
	IfStat            basetypes.MapValue     `tfsdk:"if_stat"`
	Ip                basetypes.StringValue  `tfsdk:"ip"`
	Ip2Stat           basetypes.ObjectValue  `tfsdk:"ip2_stat"`
	IpStat            basetypes.ObjectValue  `tfsdk:"ip_stat"`
	IsHa              basetypes.BoolValue    `tfsdk:"is_ha"`
	LastSeen          basetypes.Float64Value `tfsdk:"last_seen"`
	Mac               basetypes.StringValue  `tfsdk:"mac"`
	MapId             basetypes.StringValue  `tfsdk:"map_id"`
	Memory2Stat       basetypes.ObjectValue  `tfsdk:"memory2_stat"`
	MemoryStat        basetypes.ObjectValue  `tfsdk:"memory_stat"`
	Model             basetypes.StringValue  `tfsdk:"model"`
	ModifiedTime      basetypes.Float64Value `tfsdk:"modified_time"`
	Module2Stat       basetypes.ListValue    `tfsdk:"module2_stat"`
	ModuleStat        basetypes.ListValue    `tfsdk:"module_stat"`
	Name              basetypes.StringValue  `tfsdk:"name"`
	NodeName          basetypes.StringValue  `tfsdk:"node_name"`
	OrgId             basetypes.StringValue  `tfsdk:"org_id"`
	Ports             basetypes.ListValue    `tfsdk:"ports"`
	RouteSummaryStats basetypes.ObjectValue  `tfsdk:"route_summary_stats"`
	RouterName        basetypes.StringValue  `tfsdk:"router_name"`
	Serial            basetypes.StringValue  `tfsdk:"serial"`
	Service2Stat      basetypes.MapValue     `tfsdk:"service2_stat"`
	ServiceStat       basetypes.MapValue     `tfsdk:"service_stat"`
	ServiceStatus     basetypes.ObjectValue  `tfsdk:"service_status"`
	SiteId            basetypes.StringValue  `tfsdk:"site_id"`
	Spu2Stat          basetypes.ListValue    `tfsdk:"spu2_stat"`
	SpuStat           basetypes.ListValue    `tfsdk:"spu_stat"`
	Status            basetypes.StringValue  `tfsdk:"status"`
	Tunnels           basetypes.ListValue    `tfsdk:"tunnels"`
	Uptime            basetypes.NumberValue  `tfsdk:"uptime"`
	Version           basetypes.StringValue  `tfsdk:"version"`
	VpnPeers          basetypes.ListValue    `tfsdk:"vpn_peers"`
	state             attr.ValueState
}

func (v DeviceGatewayStatsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 52)

	var val tftypes.Value
	var err error

	attrTypes["ap_redundancy"] = basetypes.ObjectType{
		AttrTypes: ApRedundancyValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["arp_table_stats"] = basetypes.ObjectType{
		AttrTypes: ArpTableStatsValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["bgp_peers"] = basetypes.ListType{
		ElemType: BgpPeersValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["cert_expiry"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["cluster_config"] = basetypes.ObjectType{
		AttrTypes: ClusterConfigValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["cluster_stat"] = basetypes.ObjectType{
		AttrTypes: ClusterStatValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["conductor_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["config_status"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["cpu2_stat"] = basetypes.ObjectType{
		AttrTypes: CpuStatValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["cpu_stat"] = basetypes.ObjectType{
		AttrTypes: CpuStatValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["created_time"] = basetypes.Float64Type{}.TerraformType(ctx)
	attrTypes["deviceprofile_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["dhcpd2_stat"] = basetypes.MapType{
		ElemType: DhcpdStatValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["dhcpd_stat"] = basetypes.MapType{
		ElemType: DhcpdStatValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["ext_ip"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["fwupdate"] = basetypes.ObjectType{
		AttrTypes: FwupdateValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["has_pcap"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["hostname"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["if2_stat"] = basetypes.MapType{
		ElemType: IfStatValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["if_stat"] = basetypes.MapType{
		ElemType: IfStatValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["ip"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ip2_stat"] = basetypes.ObjectType{
		AttrTypes: IpStatValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["ip_stat"] = basetypes.ObjectType{
		AttrTypes: IpStatValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["is_ha"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["last_seen"] = basetypes.Float64Type{}.TerraformType(ctx)
	attrTypes["mac"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["map_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["memory2_stat"] = basetypes.ObjectType{
		AttrTypes: MemoryStatValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["memory_stat"] = basetypes.ObjectType{
		AttrTypes: MemoryStatValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["model"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["modified_time"] = basetypes.Float64Type{}.TerraformType(ctx)
	attrTypes["module2_stat"] = basetypes.ListType{
		ElemType: ModuleStatValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["module_stat"] = basetypes.ListType{
		ElemType: ModuleStatValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["node_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["org_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ports"] = basetypes.ListType{
		ElemType: PortsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["route_summary_stats"] = basetypes.ObjectType{
		AttrTypes: RouteSummaryStatsValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["router_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["serial"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["service2_stat"] = basetypes.MapType{
		ElemType: ServiceStatValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["service_stat"] = basetypes.MapType{
		ElemType: ServiceStatValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["service_status"] = basetypes.ObjectType{
		AttrTypes: ServiceStatusValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["site_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["spu2_stat"] = basetypes.ListType{
		ElemType: SpuStatValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["spu_stat"] = basetypes.ListType{
		ElemType: SpuStatValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["status"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["tunnels"] = basetypes.ListType{
		ElemType: TunnelsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["uptime"] = basetypes.NumberType{}.TerraformType(ctx)
	attrTypes["version"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["vpn_peers"] = basetypes.ListType{
		ElemType: VpnPeersValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 52)

		val, err = v.ApRedundancy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ap_redundancy"] = val

		val, err = v.ArpTableStats.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["arp_table_stats"] = val

		val, err = v.BgpPeers.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bgp_peers"] = val

		val, err = v.CertExpiry.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cert_expiry"] = val

		val, err = v.ClusterConfig.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cluster_config"] = val

		val, err = v.ClusterStat.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cluster_stat"] = val

		val, err = v.ConductorName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["conductor_name"] = val

		val, err = v.ConfigStatus.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["config_status"] = val

		val, err = v.Cpu2Stat.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cpu2_stat"] = val

		val, err = v.CpuStat.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cpu_stat"] = val

		val, err = v.CreatedTime.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["created_time"] = val

		val, err = v.DeviceprofileId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["deviceprofile_id"] = val

		val, err = v.Dhcpd2Stat.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dhcpd2_stat"] = val

		val, err = v.DhcpdStat.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dhcpd_stat"] = val

		val, err = v.ExtIp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ext_ip"] = val

		val, err = v.Fwupdate.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["fwupdate"] = val

		val, err = v.HasPcap.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["has_pcap"] = val

		val, err = v.Hostname.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["hostname"] = val

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.If2Stat.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["if2_stat"] = val

		val, err = v.IfStat.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["if_stat"] = val

		val, err = v.Ip.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip"] = val

		val, err = v.Ip2Stat.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip2_stat"] = val

		val, err = v.IpStat.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip_stat"] = val

		val, err = v.IsHa.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["is_ha"] = val

		val, err = v.LastSeen.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["last_seen"] = val

		val, err = v.Mac.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mac"] = val

		val, err = v.MapId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["map_id"] = val

		val, err = v.Memory2Stat.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["memory2_stat"] = val

		val, err = v.MemoryStat.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["memory_stat"] = val

		val, err = v.Model.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["model"] = val

		val, err = v.ModifiedTime.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["modified_time"] = val

		val, err = v.Module2Stat.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["module2_stat"] = val

		val, err = v.ModuleStat.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["module_stat"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.NodeName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["node_name"] = val

		val, err = v.OrgId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["org_id"] = val

		val, err = v.Ports.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ports"] = val

		val, err = v.RouteSummaryStats.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["route_summary_stats"] = val

		val, err = v.RouterName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["router_name"] = val

		val, err = v.Serial.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["serial"] = val

		val, err = v.Service2Stat.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["service2_stat"] = val

		val, err = v.ServiceStat.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["service_stat"] = val

		val, err = v.ServiceStatus.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["service_status"] = val

		val, err = v.SiteId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["site_id"] = val

		val, err = v.Spu2Stat.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["spu2_stat"] = val

		val, err = v.SpuStat.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["spu_stat"] = val

		val, err = v.Status.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["status"] = val

		val, err = v.Tunnels.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tunnels"] = val

		val, err = v.Uptime.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["uptime"] = val

		val, err = v.Version.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["version"] = val

		val, err = v.VpnPeers.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vpn_peers"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v DeviceGatewayStatsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v DeviceGatewayStatsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v DeviceGatewayStatsValue) String() string {
	return "DeviceGatewayStatsValue"
}

func (v DeviceGatewayStatsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var apRedundancy basetypes.ObjectValue

	if v.ApRedundancy.IsNull() {
		apRedundancy = types.ObjectNull(
			ApRedundancyValue{}.AttributeTypes(ctx),
		)
	}

	if v.ApRedundancy.IsUnknown() {
		apRedundancy = types.ObjectUnknown(
			ApRedundancyValue{}.AttributeTypes(ctx),
		)
	}

	if !v.ApRedundancy.IsNull() && !v.ApRedundancy.IsUnknown() {
		apRedundancy = types.ObjectValueMust(
			ApRedundancyValue{}.AttributeTypes(ctx),
			v.ApRedundancy.Attributes(),
		)
	}

	var arpTableStats basetypes.ObjectValue

	if v.ArpTableStats.IsNull() {
		arpTableStats = types.ObjectNull(
			ArpTableStatsValue{}.AttributeTypes(ctx),
		)
	}

	if v.ArpTableStats.IsUnknown() {
		arpTableStats = types.ObjectUnknown(
			ArpTableStatsValue{}.AttributeTypes(ctx),
		)
	}

	if !v.ArpTableStats.IsNull() && !v.ArpTableStats.IsUnknown() {
		arpTableStats = types.ObjectValueMust(
			ArpTableStatsValue{}.AttributeTypes(ctx),
			v.ArpTableStats.Attributes(),
		)
	}

	bgpPeers := types.ListValueMust(
		BgpPeersType{
			basetypes.ObjectType{
				AttrTypes: BgpPeersValue{}.AttributeTypes(ctx),
			},
		},
		v.BgpPeers.Elements(),
	)

	if v.BgpPeers.IsNull() {
		bgpPeers = types.ListNull(
			BgpPeersType{
				basetypes.ObjectType{
					AttrTypes: BgpPeersValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.BgpPeers.IsUnknown() {
		bgpPeers = types.ListUnknown(
			BgpPeersType{
				basetypes.ObjectType{
					AttrTypes: BgpPeersValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var clusterConfig basetypes.ObjectValue

	if v.ClusterConfig.IsNull() {
		clusterConfig = types.ObjectNull(
			ClusterConfigValue{}.AttributeTypes(ctx),
		)
	}

	if v.ClusterConfig.IsUnknown() {
		clusterConfig = types.ObjectUnknown(
			ClusterConfigValue{}.AttributeTypes(ctx),
		)
	}

	if !v.ClusterConfig.IsNull() && !v.ClusterConfig.IsUnknown() {
		clusterConfig = types.ObjectValueMust(
			ClusterConfigValue{}.AttributeTypes(ctx),
			v.ClusterConfig.Attributes(),
		)
	}

	var clusterStat basetypes.ObjectValue

	if v.ClusterStat.IsNull() {
		clusterStat = types.ObjectNull(
			ClusterStatValue{}.AttributeTypes(ctx),
		)
	}

	if v.ClusterStat.IsUnknown() {
		clusterStat = types.ObjectUnknown(
			ClusterStatValue{}.AttributeTypes(ctx),
		)
	}

	if !v.ClusterStat.IsNull() && !v.ClusterStat.IsUnknown() {
		clusterStat = types.ObjectValueMust(
			ClusterStatValue{}.AttributeTypes(ctx),
			v.ClusterStat.Attributes(),
		)
	}

	var cpu2Stat basetypes.ObjectValue

	if v.Cpu2Stat.IsNull() {
		cpu2Stat = types.ObjectNull(
			CpuStatValue{}.AttributeTypes(ctx),
		)
	}

	if v.Cpu2Stat.IsUnknown() {
		cpu2Stat = types.ObjectUnknown(
			CpuStatValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Cpu2Stat.IsNull() && !v.Cpu2Stat.IsUnknown() {
		cpu2Stat = types.ObjectValueMust(
			CpuStatValue{}.AttributeTypes(ctx),
			v.Cpu2Stat.Attributes(),
		)
	}

	var cpuStat basetypes.ObjectValue

	if v.CpuStat.IsNull() {
		cpuStat = types.ObjectNull(
			CpuStatValue{}.AttributeTypes(ctx),
		)
	}

	if v.CpuStat.IsUnknown() {
		cpuStat = types.ObjectUnknown(
			CpuStatValue{}.AttributeTypes(ctx),
		)
	}

	if !v.CpuStat.IsNull() && !v.CpuStat.IsUnknown() {
		cpuStat = types.ObjectValueMust(
			CpuStatValue{}.AttributeTypes(ctx),
			v.CpuStat.Attributes(),
		)
	}

	dhcpd2Stat := types.MapValueMust(
		DhcpdStatType{
			basetypes.ObjectType{
				AttrTypes: DhcpdStatValue{}.AttributeTypes(ctx),
			},
		},
		v.Dhcpd2Stat.Elements(),
	)

	if v.Dhcpd2Stat.IsNull() {
		dhcpd2Stat = types.MapNull(
			DhcpdStatType{
				basetypes.ObjectType{
					AttrTypes: DhcpdStatValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Dhcpd2Stat.IsUnknown() {
		dhcpd2Stat = types.MapUnknown(
			DhcpdStatType{
				basetypes.ObjectType{
					AttrTypes: DhcpdStatValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	dhcpdStat := types.MapValueMust(
		DhcpdStatType{
			basetypes.ObjectType{
				AttrTypes: DhcpdStatValue{}.AttributeTypes(ctx),
			},
		},
		v.DhcpdStat.Elements(),
	)

	if v.DhcpdStat.IsNull() {
		dhcpdStat = types.MapNull(
			DhcpdStatType{
				basetypes.ObjectType{
					AttrTypes: DhcpdStatValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.DhcpdStat.IsUnknown() {
		dhcpdStat = types.MapUnknown(
			DhcpdStatType{
				basetypes.ObjectType{
					AttrTypes: DhcpdStatValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var fwupdate basetypes.ObjectValue

	if v.Fwupdate.IsNull() {
		fwupdate = types.ObjectNull(
			FwupdateValue{}.AttributeTypes(ctx),
		)
	}

	if v.Fwupdate.IsUnknown() {
		fwupdate = types.ObjectUnknown(
			FwupdateValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Fwupdate.IsNull() && !v.Fwupdate.IsUnknown() {
		fwupdate = types.ObjectValueMust(
			FwupdateValue{}.AttributeTypes(ctx),
			v.Fwupdate.Attributes(),
		)
	}

	if2Stat := types.MapValueMust(
		IfStatType{
			basetypes.ObjectType{
				AttrTypes: IfStatValue{}.AttributeTypes(ctx),
			},
		},
		v.If2Stat.Elements(),
	)

	if v.If2Stat.IsNull() {
		if2Stat = types.MapNull(
			IfStatType{
				basetypes.ObjectType{
					AttrTypes: IfStatValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.If2Stat.IsUnknown() {
		if2Stat = types.MapUnknown(
			IfStatType{
				basetypes.ObjectType{
					AttrTypes: IfStatValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	ifStat := types.MapValueMust(
		IfStatType{
			basetypes.ObjectType{
				AttrTypes: IfStatValue{}.AttributeTypes(ctx),
			},
		},
		v.IfStat.Elements(),
	)

	if v.IfStat.IsNull() {
		ifStat = types.MapNull(
			IfStatType{
				basetypes.ObjectType{
					AttrTypes: IfStatValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.IfStat.IsUnknown() {
		ifStat = types.MapUnknown(
			IfStatType{
				basetypes.ObjectType{
					AttrTypes: IfStatValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var ip2Stat basetypes.ObjectValue

	if v.Ip2Stat.IsNull() {
		ip2Stat = types.ObjectNull(
			IpStatValue{}.AttributeTypes(ctx),
		)
	}

	if v.Ip2Stat.IsUnknown() {
		ip2Stat = types.ObjectUnknown(
			IpStatValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Ip2Stat.IsNull() && !v.Ip2Stat.IsUnknown() {
		ip2Stat = types.ObjectValueMust(
			IpStatValue{}.AttributeTypes(ctx),
			v.Ip2Stat.Attributes(),
		)
	}

	var ipStat basetypes.ObjectValue

	if v.IpStat.IsNull() {
		ipStat = types.ObjectNull(
			IpStatValue{}.AttributeTypes(ctx),
		)
	}

	if v.IpStat.IsUnknown() {
		ipStat = types.ObjectUnknown(
			IpStatValue{}.AttributeTypes(ctx),
		)
	}

	if !v.IpStat.IsNull() && !v.IpStat.IsUnknown() {
		ipStat = types.ObjectValueMust(
			IpStatValue{}.AttributeTypes(ctx),
			v.IpStat.Attributes(),
		)
	}

	var memory2Stat basetypes.ObjectValue

	if v.Memory2Stat.IsNull() {
		memory2Stat = types.ObjectNull(
			MemoryStatValue{}.AttributeTypes(ctx),
		)
	}

	if v.Memory2Stat.IsUnknown() {
		memory2Stat = types.ObjectUnknown(
			MemoryStatValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Memory2Stat.IsNull() && !v.Memory2Stat.IsUnknown() {
		memory2Stat = types.ObjectValueMust(
			MemoryStatValue{}.AttributeTypes(ctx),
			v.Memory2Stat.Attributes(),
		)
	}

	var memoryStat basetypes.ObjectValue

	if v.MemoryStat.IsNull() {
		memoryStat = types.ObjectNull(
			MemoryStatValue{}.AttributeTypes(ctx),
		)
	}

	if v.MemoryStat.IsUnknown() {
		memoryStat = types.ObjectUnknown(
			MemoryStatValue{}.AttributeTypes(ctx),
		)
	}

	if !v.MemoryStat.IsNull() && !v.MemoryStat.IsUnknown() {
		memoryStat = types.ObjectValueMust(
			MemoryStatValue{}.AttributeTypes(ctx),
			v.MemoryStat.Attributes(),
		)
	}

	module2Stat := types.ListValueMust(
		ModuleStatType{
			basetypes.ObjectType{
				AttrTypes: ModuleStatValue{}.AttributeTypes(ctx),
			},
		},
		v.Module2Stat.Elements(),
	)

	if v.Module2Stat.IsNull() {
		module2Stat = types.ListNull(
			ModuleStatType{
				basetypes.ObjectType{
					AttrTypes: ModuleStatValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Module2Stat.IsUnknown() {
		module2Stat = types.ListUnknown(
			ModuleStatType{
				basetypes.ObjectType{
					AttrTypes: ModuleStatValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	moduleStat := types.ListValueMust(
		ModuleStatType{
			basetypes.ObjectType{
				AttrTypes: ModuleStatValue{}.AttributeTypes(ctx),
			},
		},
		v.ModuleStat.Elements(),
	)

	if v.ModuleStat.IsNull() {
		moduleStat = types.ListNull(
			ModuleStatType{
				basetypes.ObjectType{
					AttrTypes: ModuleStatValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.ModuleStat.IsUnknown() {
		moduleStat = types.ListUnknown(
			ModuleStatType{
				basetypes.ObjectType{
					AttrTypes: ModuleStatValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	ports := types.ListValueMust(
		PortsType{
			basetypes.ObjectType{
				AttrTypes: PortsValue{}.AttributeTypes(ctx),
			},
		},
		v.Ports.Elements(),
	)

	if v.Ports.IsNull() {
		ports = types.ListNull(
			PortsType{
				basetypes.ObjectType{
					AttrTypes: PortsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Ports.IsUnknown() {
		ports = types.ListUnknown(
			PortsType{
				basetypes.ObjectType{
					AttrTypes: PortsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var routeSummaryStats basetypes.ObjectValue

	if v.RouteSummaryStats.IsNull() {
		routeSummaryStats = types.ObjectNull(
			RouteSummaryStatsValue{}.AttributeTypes(ctx),
		)
	}

	if v.RouteSummaryStats.IsUnknown() {
		routeSummaryStats = types.ObjectUnknown(
			RouteSummaryStatsValue{}.AttributeTypes(ctx),
		)
	}

	if !v.RouteSummaryStats.IsNull() && !v.RouteSummaryStats.IsUnknown() {
		routeSummaryStats = types.ObjectValueMust(
			RouteSummaryStatsValue{}.AttributeTypes(ctx),
			v.RouteSummaryStats.Attributes(),
		)
	}

	service2Stat := types.MapValueMust(
		ServiceStatType{
			basetypes.ObjectType{
				AttrTypes: ServiceStatValue{}.AttributeTypes(ctx),
			},
		},
		v.Service2Stat.Elements(),
	)

	if v.Service2Stat.IsNull() {
		service2Stat = types.MapNull(
			ServiceStatType{
				basetypes.ObjectType{
					AttrTypes: ServiceStatValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Service2Stat.IsUnknown() {
		service2Stat = types.MapUnknown(
			ServiceStatType{
				basetypes.ObjectType{
					AttrTypes: ServiceStatValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	serviceStat := types.MapValueMust(
		ServiceStatType{
			basetypes.ObjectType{
				AttrTypes: ServiceStatValue{}.AttributeTypes(ctx),
			},
		},
		v.ServiceStat.Elements(),
	)

	if v.ServiceStat.IsNull() {
		serviceStat = types.MapNull(
			ServiceStatType{
				basetypes.ObjectType{
					AttrTypes: ServiceStatValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.ServiceStat.IsUnknown() {
		serviceStat = types.MapUnknown(
			ServiceStatType{
				basetypes.ObjectType{
					AttrTypes: ServiceStatValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var serviceStatus basetypes.ObjectValue

	if v.ServiceStatus.IsNull() {
		serviceStatus = types.ObjectNull(
			ServiceStatusValue{}.AttributeTypes(ctx),
		)
	}

	if v.ServiceStatus.IsUnknown() {
		serviceStatus = types.ObjectUnknown(
			ServiceStatusValue{}.AttributeTypes(ctx),
		)
	}

	if !v.ServiceStatus.IsNull() && !v.ServiceStatus.IsUnknown() {
		serviceStatus = types.ObjectValueMust(
			ServiceStatusValue{}.AttributeTypes(ctx),
			v.ServiceStatus.Attributes(),
		)
	}

	spu2Stat := types.ListValueMust(
		SpuStatType{
			basetypes.ObjectType{
				AttrTypes: SpuStatValue{}.AttributeTypes(ctx),
			},
		},
		v.Spu2Stat.Elements(),
	)

	if v.Spu2Stat.IsNull() {
		spu2Stat = types.ListNull(
			SpuStatType{
				basetypes.ObjectType{
					AttrTypes: SpuStatValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Spu2Stat.IsUnknown() {
		spu2Stat = types.ListUnknown(
			SpuStatType{
				basetypes.ObjectType{
					AttrTypes: SpuStatValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	spuStat := types.ListValueMust(
		SpuStatType{
			basetypes.ObjectType{
				AttrTypes: SpuStatValue{}.AttributeTypes(ctx),
			},
		},
		v.SpuStat.Elements(),
	)

	if v.SpuStat.IsNull() {
		spuStat = types.ListNull(
			SpuStatType{
				basetypes.ObjectType{
					AttrTypes: SpuStatValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.SpuStat.IsUnknown() {
		spuStat = types.ListUnknown(
			SpuStatType{
				basetypes.ObjectType{
					AttrTypes: SpuStatValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	tunnels := types.ListValueMust(
		TunnelsType{
			basetypes.ObjectType{
				AttrTypes: TunnelsValue{}.AttributeTypes(ctx),
			},
		},
		v.Tunnels.Elements(),
	)

	if v.Tunnels.IsNull() {
		tunnels = types.ListNull(
			TunnelsType{
				basetypes.ObjectType{
					AttrTypes: TunnelsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Tunnels.IsUnknown() {
		tunnels = types.ListUnknown(
			TunnelsType{
				basetypes.ObjectType{
					AttrTypes: TunnelsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	vpnPeers := types.ListValueMust(
		VpnPeersType{
			basetypes.ObjectType{
				AttrTypes: VpnPeersValue{}.AttributeTypes(ctx),
			},
		},
		v.VpnPeers.Elements(),
	)

	if v.VpnPeers.IsNull() {
		vpnPeers = types.ListNull(
			VpnPeersType{
				basetypes.ObjectType{
					AttrTypes: VpnPeersValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.VpnPeers.IsUnknown() {
		vpnPeers = types.ListUnknown(
			VpnPeersType{
				basetypes.ObjectType{
					AttrTypes: VpnPeersValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"ap_redundancy": basetypes.ObjectType{
			AttrTypes: ApRedundancyValue{}.AttributeTypes(ctx),
		},
		"arp_table_stats": basetypes.ObjectType{
			AttrTypes: ArpTableStatsValue{}.AttributeTypes(ctx),
		},
		"bgp_peers": basetypes.ListType{
			ElemType: BgpPeersValue{}.Type(ctx),
		},
		"cert_expiry": basetypes.Int64Type{},
		"cluster_config": basetypes.ObjectType{
			AttrTypes: ClusterConfigValue{}.AttributeTypes(ctx),
		},
		"cluster_stat": basetypes.ObjectType{
			AttrTypes: ClusterStatValue{}.AttributeTypes(ctx),
		},
		"conductor_name": basetypes.StringType{},
		"config_status":  basetypes.StringType{},
		"cpu2_stat": basetypes.ObjectType{
			AttrTypes: CpuStatValue{}.AttributeTypes(ctx),
		},
		"cpu_stat": basetypes.ObjectType{
			AttrTypes: CpuStatValue{}.AttributeTypes(ctx),
		},
		"created_time":     basetypes.Float64Type{},
		"deviceprofile_id": basetypes.StringType{},
		"dhcpd2_stat": basetypes.MapType{
			ElemType: DhcpdStatValue{}.Type(ctx),
		},
		"dhcpd_stat": basetypes.MapType{
			ElemType: DhcpdStatValue{}.Type(ctx),
		},
		"ext_ip": basetypes.StringType{},
		"fwupdate": basetypes.ObjectType{
			AttrTypes: FwupdateValue{}.AttributeTypes(ctx),
		},
		"has_pcap": basetypes.BoolType{},
		"hostname": basetypes.StringType{},
		"id":       basetypes.StringType{},
		"if2_stat": basetypes.MapType{
			ElemType: IfStatValue{}.Type(ctx),
		},
		"if_stat": basetypes.MapType{
			ElemType: IfStatValue{}.Type(ctx),
		},
		"ip": basetypes.StringType{},
		"ip2_stat": basetypes.ObjectType{
			AttrTypes: IpStatValue{}.AttributeTypes(ctx),
		},
		"ip_stat": basetypes.ObjectType{
			AttrTypes: IpStatValue{}.AttributeTypes(ctx),
		},
		"is_ha":     basetypes.BoolType{},
		"last_seen": basetypes.Float64Type{},
		"mac":       basetypes.StringType{},
		"map_id":    basetypes.StringType{},
		"memory2_stat": basetypes.ObjectType{
			AttrTypes: MemoryStatValue{}.AttributeTypes(ctx),
		},
		"memory_stat": basetypes.ObjectType{
			AttrTypes: MemoryStatValue{}.AttributeTypes(ctx),
		},
		"model":         basetypes.StringType{},
		"modified_time": basetypes.Float64Type{},
		"module2_stat": basetypes.ListType{
			ElemType: ModuleStatValue{}.Type(ctx),
		},
		"module_stat": basetypes.ListType{
			ElemType: ModuleStatValue{}.Type(ctx),
		},
		"name":      basetypes.StringType{},
		"node_name": basetypes.StringType{},
		"org_id":    basetypes.StringType{},
		"ports": basetypes.ListType{
			ElemType: PortsValue{}.Type(ctx),
		},
		"route_summary_stats": basetypes.ObjectType{
			AttrTypes: RouteSummaryStatsValue{}.AttributeTypes(ctx),
		},
		"router_name": basetypes.StringType{},
		"serial":      basetypes.StringType{},
		"service2_stat": basetypes.MapType{
			ElemType: ServiceStatValue{}.Type(ctx),
		},
		"service_stat": basetypes.MapType{
			ElemType: ServiceStatValue{}.Type(ctx),
		},
		"service_status": basetypes.ObjectType{
			AttrTypes: ServiceStatusValue{}.AttributeTypes(ctx),
		},
		"site_id": basetypes.StringType{},
		"spu2_stat": basetypes.ListType{
			ElemType: SpuStatValue{}.Type(ctx),
		},
		"spu_stat": basetypes.ListType{
			ElemType: SpuStatValue{}.Type(ctx),
		},
		"status": basetypes.StringType{},
		"tunnels": basetypes.ListType{
			ElemType: TunnelsValue{}.Type(ctx),
		},
		"uptime":  basetypes.NumberType{},
		"version": basetypes.StringType{},
		"vpn_peers": basetypes.ListType{
			ElemType: VpnPeersValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"ap_redundancy":       apRedundancy,
			"arp_table_stats":     arpTableStats,
			"bgp_peers":           bgpPeers,
			"cert_expiry":         v.CertExpiry,
			"cluster_config":      clusterConfig,
			"cluster_stat":        clusterStat,
			"conductor_name":      v.ConductorName,
			"config_status":       v.ConfigStatus,
			"cpu2_stat":           cpu2Stat,
			"cpu_stat":            cpuStat,
			"created_time":        v.CreatedTime,
			"deviceprofile_id":    v.DeviceprofileId,
			"dhcpd2_stat":         dhcpd2Stat,
			"dhcpd_stat":          dhcpdStat,
			"ext_ip":              v.ExtIp,
			"fwupdate":            fwupdate,
			"has_pcap":            v.HasPcap,
			"hostname":            v.Hostname,
			"id":                  v.Id,
			"if2_stat":            if2Stat,
			"if_stat":             ifStat,
			"ip":                  v.Ip,
			"ip2_stat":            ip2Stat,
			"ip_stat":             ipStat,
			"is_ha":               v.IsHa,
			"last_seen":           v.LastSeen,
			"mac":                 v.Mac,
			"map_id":              v.MapId,
			"memory2_stat":        memory2Stat,
			"memory_stat":         memoryStat,
			"model":               v.Model,
			"modified_time":       v.ModifiedTime,
			"module2_stat":        module2Stat,
			"module_stat":         moduleStat,
			"name":                v.Name,
			"node_name":           v.NodeName,
			"org_id":              v.OrgId,
			"ports":               ports,
			"route_summary_stats": routeSummaryStats,
			"router_name":         v.RouterName,
			"serial":              v.Serial,
			"service2_stat":       service2Stat,
			"service_stat":        serviceStat,
			"service_status":      serviceStatus,
			"site_id":             v.SiteId,
			"spu2_stat":           spu2Stat,
			"spu_stat":            spuStat,
			"status":              v.Status,
			"tunnels":             tunnels,
			"uptime":              v.Uptime,
			"version":             v.Version,
			"vpn_peers":           vpnPeers,
		})

	return objVal, diags
}

func (v DeviceGatewayStatsValue) Equal(o attr.Value) bool {
	other, ok := o.(DeviceGatewayStatsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.ApRedundancy.Equal(other.ApRedundancy) {
		return false
	}

	if !v.ArpTableStats.Equal(other.ArpTableStats) {
		return false
	}

	if !v.BgpPeers.Equal(other.BgpPeers) {
		return false
	}

	if !v.CertExpiry.Equal(other.CertExpiry) {
		return false
	}

	if !v.ClusterConfig.Equal(other.ClusterConfig) {
		return false
	}

	if !v.ClusterStat.Equal(other.ClusterStat) {
		return false
	}

	if !v.ConductorName.Equal(other.ConductorName) {
		return false
	}

	if !v.ConfigStatus.Equal(other.ConfigStatus) {
		return false
	}

	if !v.Cpu2Stat.Equal(other.Cpu2Stat) {
		return false
	}

	if !v.CpuStat.Equal(other.CpuStat) {
		return false
	}

	if !v.CreatedTime.Equal(other.CreatedTime) {
		return false
	}

	if !v.DeviceprofileId.Equal(other.DeviceprofileId) {
		return false
	}

	if !v.Dhcpd2Stat.Equal(other.Dhcpd2Stat) {
		return false
	}

	if !v.DhcpdStat.Equal(other.DhcpdStat) {
		return false
	}

	if !v.ExtIp.Equal(other.ExtIp) {
		return false
	}

	if !v.Fwupdate.Equal(other.Fwupdate) {
		return false
	}

	if !v.HasPcap.Equal(other.HasPcap) {
		return false
	}

	if !v.Hostname.Equal(other.Hostname) {
		return false
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.If2Stat.Equal(other.If2Stat) {
		return false
	}

	if !v.IfStat.Equal(other.IfStat) {
		return false
	}

	if !v.Ip.Equal(other.Ip) {
		return false
	}

	if !v.Ip2Stat.Equal(other.Ip2Stat) {
		return false
	}

	if !v.IpStat.Equal(other.IpStat) {
		return false
	}

	if !v.IsHa.Equal(other.IsHa) {
		return false
	}

	if !v.LastSeen.Equal(other.LastSeen) {
		return false
	}

	if !v.Mac.Equal(other.Mac) {
		return false
	}

	if !v.MapId.Equal(other.MapId) {
		return false
	}

	if !v.Memory2Stat.Equal(other.Memory2Stat) {
		return false
	}

	if !v.MemoryStat.Equal(other.MemoryStat) {
		return false
	}

	if !v.Model.Equal(other.Model) {
		return false
	}

	if !v.ModifiedTime.Equal(other.ModifiedTime) {
		return false
	}

	if !v.Module2Stat.Equal(other.Module2Stat) {
		return false
	}

	if !v.ModuleStat.Equal(other.ModuleStat) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.NodeName.Equal(other.NodeName) {
		return false
	}

	if !v.OrgId.Equal(other.OrgId) {
		return false
	}

	if !v.Ports.Equal(other.Ports) {
		return false
	}

	if !v.RouteSummaryStats.Equal(other.RouteSummaryStats) {
		return false
	}

	if !v.RouterName.Equal(other.RouterName) {
		return false
	}

	if !v.Serial.Equal(other.Serial) {
		return false
	}

	if !v.Service2Stat.Equal(other.Service2Stat) {
		return false
	}

	if !v.ServiceStat.Equal(other.ServiceStat) {
		return false
	}

	if !v.ServiceStatus.Equal(other.ServiceStatus) {
		return false
	}

	if !v.SiteId.Equal(other.SiteId) {
		return false
	}

	if !v.Spu2Stat.Equal(other.Spu2Stat) {
		return false
	}

	if !v.SpuStat.Equal(other.SpuStat) {
		return false
	}

	if !v.Status.Equal(other.Status) {
		return false
	}

	if !v.Tunnels.Equal(other.Tunnels) {
		return false
	}

	if !v.Uptime.Equal(other.Uptime) {
		return false
	}

	if !v.Version.Equal(other.Version) {
		return false
	}

	if !v.VpnPeers.Equal(other.VpnPeers) {
		return false
	}

	return true
}

func (v DeviceGatewayStatsValue) Type(ctx context.Context) attr.Type {
	return DeviceGatewayStatsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v DeviceGatewayStatsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"ap_redundancy": basetypes.ObjectType{
			AttrTypes: ApRedundancyValue{}.AttributeTypes(ctx),
		},
		"arp_table_stats": basetypes.ObjectType{
			AttrTypes: ArpTableStatsValue{}.AttributeTypes(ctx),
		},
		"bgp_peers": basetypes.ListType{
			ElemType: BgpPeersValue{}.Type(ctx),
		},
		"cert_expiry": basetypes.Int64Type{},
		"cluster_config": basetypes.ObjectType{
			AttrTypes: ClusterConfigValue{}.AttributeTypes(ctx),
		},
		"cluster_stat": basetypes.ObjectType{
			AttrTypes: ClusterStatValue{}.AttributeTypes(ctx),
		},
		"conductor_name": basetypes.StringType{},
		"config_status":  basetypes.StringType{},
		"cpu2_stat": basetypes.ObjectType{
			AttrTypes: CpuStatValue{}.AttributeTypes(ctx),
		},
		"cpu_stat": basetypes.ObjectType{
			AttrTypes: CpuStatValue{}.AttributeTypes(ctx),
		},
		"created_time":     basetypes.Float64Type{},
		"deviceprofile_id": basetypes.StringType{},
		"dhcpd2_stat": basetypes.MapType{
			ElemType: DhcpdStatValue{}.Type(ctx),
		},
		"dhcpd_stat": basetypes.MapType{
			ElemType: DhcpdStatValue{}.Type(ctx),
		},
		"ext_ip": basetypes.StringType{},
		"fwupdate": basetypes.ObjectType{
			AttrTypes: FwupdateValue{}.AttributeTypes(ctx),
		},
		"has_pcap": basetypes.BoolType{},
		"hostname": basetypes.StringType{},
		"id":       basetypes.StringType{},
		"if2_stat": basetypes.MapType{
			ElemType: IfStatValue{}.Type(ctx),
		},
		"if_stat": basetypes.MapType{
			ElemType: IfStatValue{}.Type(ctx),
		},
		"ip": basetypes.StringType{},
		"ip2_stat": basetypes.ObjectType{
			AttrTypes: IpStatValue{}.AttributeTypes(ctx),
		},
		"ip_stat": basetypes.ObjectType{
			AttrTypes: IpStatValue{}.AttributeTypes(ctx),
		},
		"is_ha":     basetypes.BoolType{},
		"last_seen": basetypes.Float64Type{},
		"mac":       basetypes.StringType{},
		"map_id":    basetypes.StringType{},
		"memory2_stat": basetypes.ObjectType{
			AttrTypes: MemoryStatValue{}.AttributeTypes(ctx),
		},
		"memory_stat": basetypes.ObjectType{
			AttrTypes: MemoryStatValue{}.AttributeTypes(ctx),
		},
		"model":         basetypes.StringType{},
		"modified_time": basetypes.Float64Type{},
		"module2_stat": basetypes.ListType{
			ElemType: ModuleStatValue{}.Type(ctx),
		},
		"module_stat": basetypes.ListType{
			ElemType: ModuleStatValue{}.Type(ctx),
		},
		"name":      basetypes.StringType{},
		"node_name": basetypes.StringType{},
		"org_id":    basetypes.StringType{},
		"ports": basetypes.ListType{
			ElemType: PortsValue{}.Type(ctx),
		},
		"route_summary_stats": basetypes.ObjectType{
			AttrTypes: RouteSummaryStatsValue{}.AttributeTypes(ctx),
		},
		"router_name": basetypes.StringType{},
		"serial":      basetypes.StringType{},
		"service2_stat": basetypes.MapType{
			ElemType: ServiceStatValue{}.Type(ctx),
		},
		"service_stat": basetypes.MapType{
			ElemType: ServiceStatValue{}.Type(ctx),
		},
		"service_status": basetypes.ObjectType{
			AttrTypes: ServiceStatusValue{}.AttributeTypes(ctx),
		},
		"site_id": basetypes.StringType{},
		"spu2_stat": basetypes.ListType{
			ElemType: SpuStatValue{}.Type(ctx),
		},
		"spu_stat": basetypes.ListType{
			ElemType: SpuStatValue{}.Type(ctx),
		},
		"status": basetypes.StringType{},
		"tunnels": basetypes.ListType{
			ElemType: TunnelsValue{}.Type(ctx),
		},
		"uptime":  basetypes.NumberType{},
		"version": basetypes.StringType{},
		"vpn_peers": basetypes.ListType{
			ElemType: VpnPeersValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = ApRedundancyType{}

type ApRedundancyType struct {
	basetypes.ObjectType
}

func (t ApRedundancyType) Equal(o attr.Type) bool {
	other, ok := o.(ApRedundancyType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ApRedundancyType) String() string {
	return "ApRedundancyType"
}

func (t ApRedundancyType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	modulesAttribute, ok := attributes["modules"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`modules is missing from object`)

		return nil, diags
	}

	modulesVal, ok := modulesAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`modules expected to be basetypes.MapValue, was: %T`, modulesAttribute))
	}

	numApsAttribute, ok := attributes["num_aps"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`num_aps is missing from object`)

		return nil, diags
	}

	numApsVal, ok := numApsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`num_aps expected to be basetypes.Int64Value, was: %T`, numApsAttribute))
	}

	numApsWithSwitchRedundancyAttribute, ok := attributes["num_aps_with_switch_redundancy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`num_aps_with_switch_redundancy is missing from object`)

		return nil, diags
	}

	numApsWithSwitchRedundancyVal, ok := numApsWithSwitchRedundancyAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`num_aps_with_switch_redundancy expected to be basetypes.Int64Value, was: %T`, numApsWithSwitchRedundancyAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ApRedundancyValue{
		Modules:                    modulesVal,
		NumAps:                     numApsVal,
		NumApsWithSwitchRedundancy: numApsWithSwitchRedundancyVal,
		state:                      attr.ValueStateKnown,
	}, diags
}

func NewApRedundancyValueNull() ApRedundancyValue {
	return ApRedundancyValue{
		state: attr.ValueStateNull,
	}
}

func NewApRedundancyValueUnknown() ApRedundancyValue {
	return ApRedundancyValue{
		state: attr.ValueStateUnknown,
	}
}

func NewApRedundancyValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ApRedundancyValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ApRedundancyValue Attribute Value",
				"While creating a ApRedundancyValue value, a missing attribute value was detected. "+
					"A ApRedundancyValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ApRedundancyValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ApRedundancyValue Attribute Type",
				"While creating a ApRedundancyValue value, an invalid attribute value was detected. "+
					"A ApRedundancyValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ApRedundancyValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ApRedundancyValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ApRedundancyValue Attribute Value",
				"While creating a ApRedundancyValue value, an extra attribute value was detected. "+
					"A ApRedundancyValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ApRedundancyValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewApRedundancyValueUnknown(), diags
	}

	modulesAttribute, ok := attributes["modules"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`modules is missing from object`)

		return NewApRedundancyValueUnknown(), diags
	}

	modulesVal, ok := modulesAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`modules expected to be basetypes.MapValue, was: %T`, modulesAttribute))
	}

	numApsAttribute, ok := attributes["num_aps"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`num_aps is missing from object`)

		return NewApRedundancyValueUnknown(), diags
	}

	numApsVal, ok := numApsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`num_aps expected to be basetypes.Int64Value, was: %T`, numApsAttribute))
	}

	numApsWithSwitchRedundancyAttribute, ok := attributes["num_aps_with_switch_redundancy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`num_aps_with_switch_redundancy is missing from object`)

		return NewApRedundancyValueUnknown(), diags
	}

	numApsWithSwitchRedundancyVal, ok := numApsWithSwitchRedundancyAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`num_aps_with_switch_redundancy expected to be basetypes.Int64Value, was: %T`, numApsWithSwitchRedundancyAttribute))
	}

	if diags.HasError() {
		return NewApRedundancyValueUnknown(), diags
	}

	return ApRedundancyValue{
		Modules:                    modulesVal,
		NumAps:                     numApsVal,
		NumApsWithSwitchRedundancy: numApsWithSwitchRedundancyVal,
		state:                      attr.ValueStateKnown,
	}, diags
}

func NewApRedundancyValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ApRedundancyValue {
	object, diags := NewApRedundancyValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewApRedundancyValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ApRedundancyType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewApRedundancyValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewApRedundancyValueUnknown(), nil
	}

	if in.IsNull() {
		return NewApRedundancyValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewApRedundancyValueMust(ApRedundancyValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ApRedundancyType) ValueType(ctx context.Context) attr.Value {
	return ApRedundancyValue{}
}

var _ basetypes.ObjectValuable = ApRedundancyValue{}

type ApRedundancyValue struct {
	Modules                    basetypes.MapValue   `tfsdk:"modules"`
	NumAps                     basetypes.Int64Value `tfsdk:"num_aps"`
	NumApsWithSwitchRedundancy basetypes.Int64Value `tfsdk:"num_aps_with_switch_redundancy"`
	state                      attr.ValueState
}

func (v ApRedundancyValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["modules"] = basetypes.MapType{
		ElemType: ModulesValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["num_aps"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["num_aps_with_switch_redundancy"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Modules.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["modules"] = val

		val, err = v.NumAps.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["num_aps"] = val

		val, err = v.NumApsWithSwitchRedundancy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["num_aps_with_switch_redundancy"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ApRedundancyValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ApRedundancyValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ApRedundancyValue) String() string {
	return "ApRedundancyValue"
}

func (v ApRedundancyValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	modules := types.MapValueMust(
		ModulesType{
			basetypes.ObjectType{
				AttrTypes: ModulesValue{}.AttributeTypes(ctx),
			},
		},
		v.Modules.Elements(),
	)

	if v.Modules.IsNull() {
		modules = types.MapNull(
			ModulesType{
				basetypes.ObjectType{
					AttrTypes: ModulesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Modules.IsUnknown() {
		modules = types.MapUnknown(
			ModulesType{
				basetypes.ObjectType{
					AttrTypes: ModulesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"modules": basetypes.MapType{
			ElemType: ModulesValue{}.Type(ctx),
		},
		"num_aps":                        basetypes.Int64Type{},
		"num_aps_with_switch_redundancy": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"modules":                        modules,
			"num_aps":                        v.NumAps,
			"num_aps_with_switch_redundancy": v.NumApsWithSwitchRedundancy,
		})

	return objVal, diags
}

func (v ApRedundancyValue) Equal(o attr.Value) bool {
	other, ok := o.(ApRedundancyValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Modules.Equal(other.Modules) {
		return false
	}

	if !v.NumAps.Equal(other.NumAps) {
		return false
	}

	if !v.NumApsWithSwitchRedundancy.Equal(other.NumApsWithSwitchRedundancy) {
		return false
	}

	return true
}

func (v ApRedundancyValue) Type(ctx context.Context) attr.Type {
	return ApRedundancyType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ApRedundancyValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"modules": basetypes.MapType{
			ElemType: ModulesValue{}.Type(ctx),
		},
		"num_aps":                        basetypes.Int64Type{},
		"num_aps_with_switch_redundancy": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = ModulesType{}

type ModulesType struct {
	basetypes.ObjectType
}

func (t ModulesType) Equal(o attr.Type) bool {
	other, ok := o.(ModulesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ModulesType) String() string {
	return "ModulesType"
}

func (t ModulesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	numApsAttribute, ok := attributes["num_aps"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`num_aps is missing from object`)

		return nil, diags
	}

	numApsVal, ok := numApsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`num_aps expected to be basetypes.Int64Value, was: %T`, numApsAttribute))
	}

	numApsWithSwitchRedundancyAttribute, ok := attributes["num_aps_with_switch_redundancy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`num_aps_with_switch_redundancy is missing from object`)

		return nil, diags
	}

	numApsWithSwitchRedundancyVal, ok := numApsWithSwitchRedundancyAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`num_aps_with_switch_redundancy expected to be basetypes.Int64Value, was: %T`, numApsWithSwitchRedundancyAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ModulesValue{
		NumAps:                     numApsVal,
		NumApsWithSwitchRedundancy: numApsWithSwitchRedundancyVal,
		state:                      attr.ValueStateKnown,
	}, diags
}

func NewModulesValueNull() ModulesValue {
	return ModulesValue{
		state: attr.ValueStateNull,
	}
}

func NewModulesValueUnknown() ModulesValue {
	return ModulesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewModulesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ModulesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ModulesValue Attribute Value",
				"While creating a ModulesValue value, a missing attribute value was detected. "+
					"A ModulesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ModulesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ModulesValue Attribute Type",
				"While creating a ModulesValue value, an invalid attribute value was detected. "+
					"A ModulesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ModulesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ModulesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ModulesValue Attribute Value",
				"While creating a ModulesValue value, an extra attribute value was detected. "+
					"A ModulesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ModulesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewModulesValueUnknown(), diags
	}

	numApsAttribute, ok := attributes["num_aps"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`num_aps is missing from object`)

		return NewModulesValueUnknown(), diags
	}

	numApsVal, ok := numApsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`num_aps expected to be basetypes.Int64Value, was: %T`, numApsAttribute))
	}

	numApsWithSwitchRedundancyAttribute, ok := attributes["num_aps_with_switch_redundancy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`num_aps_with_switch_redundancy is missing from object`)

		return NewModulesValueUnknown(), diags
	}

	numApsWithSwitchRedundancyVal, ok := numApsWithSwitchRedundancyAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`num_aps_with_switch_redundancy expected to be basetypes.Int64Value, was: %T`, numApsWithSwitchRedundancyAttribute))
	}

	if diags.HasError() {
		return NewModulesValueUnknown(), diags
	}

	return ModulesValue{
		NumAps:                     numApsVal,
		NumApsWithSwitchRedundancy: numApsWithSwitchRedundancyVal,
		state:                      attr.ValueStateKnown,
	}, diags
}

func NewModulesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ModulesValue {
	object, diags := NewModulesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewModulesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ModulesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewModulesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewModulesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewModulesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewModulesValueMust(ModulesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ModulesType) ValueType(ctx context.Context) attr.Value {
	return ModulesValue{}
}

var _ basetypes.ObjectValuable = ModulesValue{}

type ModulesValue struct {
	NumAps                     basetypes.Int64Value `tfsdk:"num_aps"`
	NumApsWithSwitchRedundancy basetypes.Int64Value `tfsdk:"num_aps_with_switch_redundancy"`
	state                      attr.ValueState
}

func (v ModulesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["num_aps"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["num_aps_with_switch_redundancy"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.NumAps.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["num_aps"] = val

		val, err = v.NumApsWithSwitchRedundancy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["num_aps_with_switch_redundancy"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ModulesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ModulesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ModulesValue) String() string {
	return "ModulesValue"
}

func (v ModulesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"num_aps":                        basetypes.Int64Type{},
		"num_aps_with_switch_redundancy": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"num_aps":                        v.NumAps,
			"num_aps_with_switch_redundancy": v.NumApsWithSwitchRedundancy,
		})

	return objVal, diags
}

func (v ModulesValue) Equal(o attr.Value) bool {
	other, ok := o.(ModulesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.NumAps.Equal(other.NumAps) {
		return false
	}

	if !v.NumApsWithSwitchRedundancy.Equal(other.NumApsWithSwitchRedundancy) {
		return false
	}

	return true
}

func (v ModulesValue) Type(ctx context.Context) attr.Type {
	return ModulesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ModulesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"num_aps":                        basetypes.Int64Type{},
		"num_aps_with_switch_redundancy": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = ArpTableStatsType{}

type ArpTableStatsType struct {
	basetypes.ObjectType
}

func (t ArpTableStatsType) Equal(o attr.Type) bool {
	other, ok := o.(ArpTableStatsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ArpTableStatsType) String() string {
	return "ArpTableStatsType"
}

func (t ArpTableStatsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	arpTableCountAttribute, ok := attributes["arp_table_count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`arp_table_count is missing from object`)

		return nil, diags
	}

	arpTableCountVal, ok := arpTableCountAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`arp_table_count expected to be basetypes.Int64Value, was: %T`, arpTableCountAttribute))
	}

	maxEntriesSupportedAttribute, ok := attributes["max_entries_supported"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_entries_supported is missing from object`)

		return nil, diags
	}

	maxEntriesSupportedVal, ok := maxEntriesSupportedAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_entries_supported expected to be basetypes.Int64Value, was: %T`, maxEntriesSupportedAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ArpTableStatsValue{
		ArpTableCount:       arpTableCountVal,
		MaxEntriesSupported: maxEntriesSupportedVal,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewArpTableStatsValueNull() ArpTableStatsValue {
	return ArpTableStatsValue{
		state: attr.ValueStateNull,
	}
}

func NewArpTableStatsValueUnknown() ArpTableStatsValue {
	return ArpTableStatsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewArpTableStatsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ArpTableStatsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ArpTableStatsValue Attribute Value",
				"While creating a ArpTableStatsValue value, a missing attribute value was detected. "+
					"A ArpTableStatsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ArpTableStatsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ArpTableStatsValue Attribute Type",
				"While creating a ArpTableStatsValue value, an invalid attribute value was detected. "+
					"A ArpTableStatsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ArpTableStatsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ArpTableStatsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ArpTableStatsValue Attribute Value",
				"While creating a ArpTableStatsValue value, an extra attribute value was detected. "+
					"A ArpTableStatsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ArpTableStatsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewArpTableStatsValueUnknown(), diags
	}

	arpTableCountAttribute, ok := attributes["arp_table_count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`arp_table_count is missing from object`)

		return NewArpTableStatsValueUnknown(), diags
	}

	arpTableCountVal, ok := arpTableCountAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`arp_table_count expected to be basetypes.Int64Value, was: %T`, arpTableCountAttribute))
	}

	maxEntriesSupportedAttribute, ok := attributes["max_entries_supported"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_entries_supported is missing from object`)

		return NewArpTableStatsValueUnknown(), diags
	}

	maxEntriesSupportedVal, ok := maxEntriesSupportedAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_entries_supported expected to be basetypes.Int64Value, was: %T`, maxEntriesSupportedAttribute))
	}

	if diags.HasError() {
		return NewArpTableStatsValueUnknown(), diags
	}

	return ArpTableStatsValue{
		ArpTableCount:       arpTableCountVal,
		MaxEntriesSupported: maxEntriesSupportedVal,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewArpTableStatsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ArpTableStatsValue {
	object, diags := NewArpTableStatsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewArpTableStatsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ArpTableStatsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewArpTableStatsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewArpTableStatsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewArpTableStatsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewArpTableStatsValueMust(ArpTableStatsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ArpTableStatsType) ValueType(ctx context.Context) attr.Value {
	return ArpTableStatsValue{}
}

var _ basetypes.ObjectValuable = ArpTableStatsValue{}

type ArpTableStatsValue struct {
	ArpTableCount       basetypes.Int64Value `tfsdk:"arp_table_count"`
	MaxEntriesSupported basetypes.Int64Value `tfsdk:"max_entries_supported"`
	state               attr.ValueState
}

func (v ArpTableStatsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["arp_table_count"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["max_entries_supported"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.ArpTableCount.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["arp_table_count"] = val

		val, err = v.MaxEntriesSupported.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_entries_supported"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ArpTableStatsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ArpTableStatsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ArpTableStatsValue) String() string {
	return "ArpTableStatsValue"
}

func (v ArpTableStatsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"arp_table_count":       basetypes.Int64Type{},
		"max_entries_supported": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"arp_table_count":       v.ArpTableCount,
			"max_entries_supported": v.MaxEntriesSupported,
		})

	return objVal, diags
}

func (v ArpTableStatsValue) Equal(o attr.Value) bool {
	other, ok := o.(ArpTableStatsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.ArpTableCount.Equal(other.ArpTableCount) {
		return false
	}

	if !v.MaxEntriesSupported.Equal(other.MaxEntriesSupported) {
		return false
	}

	return true
}

func (v ArpTableStatsValue) Type(ctx context.Context) attr.Type {
	return ArpTableStatsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ArpTableStatsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"arp_table_count":       basetypes.Int64Type{},
		"max_entries_supported": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = BgpPeersType{}

type BgpPeersType struct {
	basetypes.ObjectType
}

func (t BgpPeersType) Equal(o attr.Type) bool {
	other, ok := o.(BgpPeersType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t BgpPeersType) String() string {
	return "BgpPeersType"
}

func (t BgpPeersType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	evpnOverlayAttribute, ok := attributes["evpn_overlay"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`evpn_overlay is missing from object`)

		return nil, diags
	}

	evpnOverlayVal, ok := evpnOverlayAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`evpn_overlay expected to be basetypes.BoolValue, was: %T`, evpnOverlayAttribute))
	}

	forOverlayAttribute, ok := attributes["for_overlay"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`for_overlay is missing from object`)

		return nil, diags
	}

	forOverlayVal, ok := forOverlayAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`for_overlay expected to be basetypes.BoolValue, was: %T`, forOverlayAttribute))
	}

	localAsAttribute, ok := attributes["local_as"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`local_as is missing from object`)

		return nil, diags
	}

	localAsVal, ok := localAsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`local_as expected to be basetypes.Int64Value, was: %T`, localAsAttribute))
	}

	neighborAttribute, ok := attributes["neighbor"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`neighbor is missing from object`)

		return nil, diags
	}

	neighborVal, ok := neighborAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`neighbor expected to be basetypes.StringValue, was: %T`, neighborAttribute))
	}

	neighborAsAttribute, ok := attributes["neighbor_as"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`neighbor_as is missing from object`)

		return nil, diags
	}

	neighborAsVal, ok := neighborAsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`neighbor_as expected to be basetypes.Int64Value, was: %T`, neighborAsAttribute))
	}

	neighborMacAttribute, ok := attributes["neighbor_mac"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`neighbor_mac is missing from object`)

		return nil, diags
	}

	neighborMacVal, ok := neighborMacAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`neighbor_mac expected to be basetypes.StringValue, was: %T`, neighborMacAttribute))
	}

	nodeAttribute, ok := attributes["node"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node is missing from object`)

		return nil, diags
	}

	nodeVal, ok := nodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node expected to be basetypes.StringValue, was: %T`, nodeAttribute))
	}

	rxPktsAttribute, ok := attributes["rx_pkts"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rx_pkts is missing from object`)

		return nil, diags
	}

	rxPktsVal, ok := rxPktsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rx_pkts expected to be basetypes.Int64Value, was: %T`, rxPktsAttribute))
	}

	rxRoutesAttribute, ok := attributes["rx_routes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rx_routes is missing from object`)

		return nil, diags
	}

	rxRoutesVal, ok := rxRoutesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rx_routes expected to be basetypes.Int64Value, was: %T`, rxRoutesAttribute))
	}

	stateAttribute, ok := attributes["state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`state is missing from object`)

		return nil, diags
	}

	stateVal, ok := stateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`state expected to be basetypes.StringValue, was: %T`, stateAttribute))
	}

	timestampAttribute, ok := attributes["timestamp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`timestamp is missing from object`)

		return nil, diags
	}

	timestampVal, ok := timestampAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`timestamp expected to be basetypes.Float64Value, was: %T`, timestampAttribute))
	}

	txPktsAttribute, ok := attributes["tx_pkts"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tx_pkts is missing from object`)

		return nil, diags
	}

	txPktsVal, ok := txPktsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tx_pkts expected to be basetypes.Int64Value, was: %T`, txPktsAttribute))
	}

	txRoutesAttribute, ok := attributes["tx_routes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tx_routes is missing from object`)

		return nil, diags
	}

	txRoutesVal, ok := txRoutesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tx_routes expected to be basetypes.Int64Value, was: %T`, txRoutesAttribute))
	}

	upAttribute, ok := attributes["up"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`up is missing from object`)

		return nil, diags
	}

	upVal, ok := upAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`up expected to be basetypes.BoolValue, was: %T`, upAttribute))
	}

	uptimeAttribute, ok := attributes["uptime"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uptime is missing from object`)

		return nil, diags
	}

	uptimeVal, ok := uptimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uptime expected to be basetypes.Int64Value, was: %T`, uptimeAttribute))
	}

	vrfNameAttribute, ok := attributes["vrf_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vrf_name is missing from object`)

		return nil, diags
	}

	vrfNameVal, ok := vrfNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vrf_name expected to be basetypes.StringValue, was: %T`, vrfNameAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return BgpPeersValue{
		EvpnOverlay: evpnOverlayVal,
		ForOverlay:  forOverlayVal,
		LocalAs:     localAsVal,
		Neighbor:    neighborVal,
		NeighborAs:  neighborAsVal,
		NeighborMac: neighborMacVal,
		Node:        nodeVal,
		RxPkts:      rxPktsVal,
		RxRoutes:    rxRoutesVal,
		State:       stateVal,
		Timestamp:   timestampVal,
		TxPkts:      txPktsVal,
		TxRoutes:    txRoutesVal,
		Up:          upVal,
		Uptime:      uptimeVal,
		VrfName:     vrfNameVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewBgpPeersValueNull() BgpPeersValue {
	return BgpPeersValue{
		state: attr.ValueStateNull,
	}
}

func NewBgpPeersValueUnknown() BgpPeersValue {
	return BgpPeersValue{
		state: attr.ValueStateUnknown,
	}
}

func NewBgpPeersValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (BgpPeersValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing BgpPeersValue Attribute Value",
				"While creating a BgpPeersValue value, a missing attribute value was detected. "+
					"A BgpPeersValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("BgpPeersValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid BgpPeersValue Attribute Type",
				"While creating a BgpPeersValue value, an invalid attribute value was detected. "+
					"A BgpPeersValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("BgpPeersValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("BgpPeersValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra BgpPeersValue Attribute Value",
				"While creating a BgpPeersValue value, an extra attribute value was detected. "+
					"A BgpPeersValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra BgpPeersValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewBgpPeersValueUnknown(), diags
	}

	evpnOverlayAttribute, ok := attributes["evpn_overlay"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`evpn_overlay is missing from object`)

		return NewBgpPeersValueUnknown(), diags
	}

	evpnOverlayVal, ok := evpnOverlayAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`evpn_overlay expected to be basetypes.BoolValue, was: %T`, evpnOverlayAttribute))
	}

	forOverlayAttribute, ok := attributes["for_overlay"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`for_overlay is missing from object`)

		return NewBgpPeersValueUnknown(), diags
	}

	forOverlayVal, ok := forOverlayAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`for_overlay expected to be basetypes.BoolValue, was: %T`, forOverlayAttribute))
	}

	localAsAttribute, ok := attributes["local_as"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`local_as is missing from object`)

		return NewBgpPeersValueUnknown(), diags
	}

	localAsVal, ok := localAsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`local_as expected to be basetypes.Int64Value, was: %T`, localAsAttribute))
	}

	neighborAttribute, ok := attributes["neighbor"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`neighbor is missing from object`)

		return NewBgpPeersValueUnknown(), diags
	}

	neighborVal, ok := neighborAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`neighbor expected to be basetypes.StringValue, was: %T`, neighborAttribute))
	}

	neighborAsAttribute, ok := attributes["neighbor_as"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`neighbor_as is missing from object`)

		return NewBgpPeersValueUnknown(), diags
	}

	neighborAsVal, ok := neighborAsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`neighbor_as expected to be basetypes.Int64Value, was: %T`, neighborAsAttribute))
	}

	neighborMacAttribute, ok := attributes["neighbor_mac"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`neighbor_mac is missing from object`)

		return NewBgpPeersValueUnknown(), diags
	}

	neighborMacVal, ok := neighborMacAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`neighbor_mac expected to be basetypes.StringValue, was: %T`, neighborMacAttribute))
	}

	nodeAttribute, ok := attributes["node"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node is missing from object`)

		return NewBgpPeersValueUnknown(), diags
	}

	nodeVal, ok := nodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node expected to be basetypes.StringValue, was: %T`, nodeAttribute))
	}

	rxPktsAttribute, ok := attributes["rx_pkts"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rx_pkts is missing from object`)

		return NewBgpPeersValueUnknown(), diags
	}

	rxPktsVal, ok := rxPktsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rx_pkts expected to be basetypes.Int64Value, was: %T`, rxPktsAttribute))
	}

	rxRoutesAttribute, ok := attributes["rx_routes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rx_routes is missing from object`)

		return NewBgpPeersValueUnknown(), diags
	}

	rxRoutesVal, ok := rxRoutesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rx_routes expected to be basetypes.Int64Value, was: %T`, rxRoutesAttribute))
	}

	stateAttribute, ok := attributes["state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`state is missing from object`)

		return NewBgpPeersValueUnknown(), diags
	}

	stateVal, ok := stateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`state expected to be basetypes.StringValue, was: %T`, stateAttribute))
	}

	timestampAttribute, ok := attributes["timestamp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`timestamp is missing from object`)

		return NewBgpPeersValueUnknown(), diags
	}

	timestampVal, ok := timestampAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`timestamp expected to be basetypes.Float64Value, was: %T`, timestampAttribute))
	}

	txPktsAttribute, ok := attributes["tx_pkts"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tx_pkts is missing from object`)

		return NewBgpPeersValueUnknown(), diags
	}

	txPktsVal, ok := txPktsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tx_pkts expected to be basetypes.Int64Value, was: %T`, txPktsAttribute))
	}

	txRoutesAttribute, ok := attributes["tx_routes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tx_routes is missing from object`)

		return NewBgpPeersValueUnknown(), diags
	}

	txRoutesVal, ok := txRoutesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tx_routes expected to be basetypes.Int64Value, was: %T`, txRoutesAttribute))
	}

	upAttribute, ok := attributes["up"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`up is missing from object`)

		return NewBgpPeersValueUnknown(), diags
	}

	upVal, ok := upAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`up expected to be basetypes.BoolValue, was: %T`, upAttribute))
	}

	uptimeAttribute, ok := attributes["uptime"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uptime is missing from object`)

		return NewBgpPeersValueUnknown(), diags
	}

	uptimeVal, ok := uptimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uptime expected to be basetypes.Int64Value, was: %T`, uptimeAttribute))
	}

	vrfNameAttribute, ok := attributes["vrf_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vrf_name is missing from object`)

		return NewBgpPeersValueUnknown(), diags
	}

	vrfNameVal, ok := vrfNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vrf_name expected to be basetypes.StringValue, was: %T`, vrfNameAttribute))
	}

	if diags.HasError() {
		return NewBgpPeersValueUnknown(), diags
	}

	return BgpPeersValue{
		EvpnOverlay: evpnOverlayVal,
		ForOverlay:  forOverlayVal,
		LocalAs:     localAsVal,
		Neighbor:    neighborVal,
		NeighborAs:  neighborAsVal,
		NeighborMac: neighborMacVal,
		Node:        nodeVal,
		RxPkts:      rxPktsVal,
		RxRoutes:    rxRoutesVal,
		State:       stateVal,
		Timestamp:   timestampVal,
		TxPkts:      txPktsVal,
		TxRoutes:    txRoutesVal,
		Up:          upVal,
		Uptime:      uptimeVal,
		VrfName:     vrfNameVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewBgpPeersValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) BgpPeersValue {
	object, diags := NewBgpPeersValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewBgpPeersValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t BgpPeersType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewBgpPeersValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewBgpPeersValueUnknown(), nil
	}

	if in.IsNull() {
		return NewBgpPeersValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewBgpPeersValueMust(BgpPeersValue{}.AttributeTypes(ctx), attributes), nil
}

func (t BgpPeersType) ValueType(ctx context.Context) attr.Value {
	return BgpPeersValue{}
}

var _ basetypes.ObjectValuable = BgpPeersValue{}

type BgpPeersValue struct {
	EvpnOverlay basetypes.BoolValue    `tfsdk:"evpn_overlay"`
	ForOverlay  basetypes.BoolValue    `tfsdk:"for_overlay"`
	LocalAs     basetypes.Int64Value   `tfsdk:"local_as"`
	Neighbor    basetypes.StringValue  `tfsdk:"neighbor"`
	NeighborAs  basetypes.Int64Value   `tfsdk:"neighbor_as"`
	NeighborMac basetypes.StringValue  `tfsdk:"neighbor_mac"`
	Node        basetypes.StringValue  `tfsdk:"node"`
	RxPkts      basetypes.Int64Value   `tfsdk:"rx_pkts"`
	RxRoutes    basetypes.Int64Value   `tfsdk:"rx_routes"`
	State       basetypes.StringValue  `tfsdk:"state"`
	Timestamp   basetypes.Float64Value `tfsdk:"timestamp"`
	TxPkts      basetypes.Int64Value   `tfsdk:"tx_pkts"`
	TxRoutes    basetypes.Int64Value   `tfsdk:"tx_routes"`
	Up          basetypes.BoolValue    `tfsdk:"up"`
	Uptime      basetypes.Int64Value   `tfsdk:"uptime"`
	VrfName     basetypes.StringValue  `tfsdk:"vrf_name"`
	state       attr.ValueState
}

func (v BgpPeersValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 16)

	var val tftypes.Value
	var err error

	attrTypes["evpn_overlay"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["for_overlay"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["local_as"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["neighbor"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["neighbor_as"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["neighbor_mac"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["node"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["rx_pkts"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["rx_routes"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["state"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["timestamp"] = basetypes.Float64Type{}.TerraformType(ctx)
	attrTypes["tx_pkts"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["tx_routes"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["up"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["uptime"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["vrf_name"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 16)

		val, err = v.EvpnOverlay.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["evpn_overlay"] = val

		val, err = v.ForOverlay.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["for_overlay"] = val

		val, err = v.LocalAs.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["local_as"] = val

		val, err = v.Neighbor.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["neighbor"] = val

		val, err = v.NeighborAs.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["neighbor_as"] = val

		val, err = v.NeighborMac.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["neighbor_mac"] = val

		val, err = v.Node.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["node"] = val

		val, err = v.RxPkts.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["rx_pkts"] = val

		val, err = v.RxRoutes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["rx_routes"] = val

		val, err = v.State.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["state"] = val

		val, err = v.Timestamp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["timestamp"] = val

		val, err = v.TxPkts.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tx_pkts"] = val

		val, err = v.TxRoutes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tx_routes"] = val

		val, err = v.Up.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["up"] = val

		val, err = v.Uptime.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["uptime"] = val

		val, err = v.VrfName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vrf_name"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v BgpPeersValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v BgpPeersValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v BgpPeersValue) String() string {
	return "BgpPeersValue"
}

func (v BgpPeersValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"evpn_overlay": basetypes.BoolType{},
		"for_overlay":  basetypes.BoolType{},
		"local_as":     basetypes.Int64Type{},
		"neighbor":     basetypes.StringType{},
		"neighbor_as":  basetypes.Int64Type{},
		"neighbor_mac": basetypes.StringType{},
		"node":         basetypes.StringType{},
		"rx_pkts":      basetypes.Int64Type{},
		"rx_routes":    basetypes.Int64Type{},
		"state":        basetypes.StringType{},
		"timestamp":    basetypes.Float64Type{},
		"tx_pkts":      basetypes.Int64Type{},
		"tx_routes":    basetypes.Int64Type{},
		"up":           basetypes.BoolType{},
		"uptime":       basetypes.Int64Type{},
		"vrf_name":     basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"evpn_overlay": v.EvpnOverlay,
			"for_overlay":  v.ForOverlay,
			"local_as":     v.LocalAs,
			"neighbor":     v.Neighbor,
			"neighbor_as":  v.NeighborAs,
			"neighbor_mac": v.NeighborMac,
			"node":         v.Node,
			"rx_pkts":      v.RxPkts,
			"rx_routes":    v.RxRoutes,
			"state":        v.State,
			"timestamp":    v.Timestamp,
			"tx_pkts":      v.TxPkts,
			"tx_routes":    v.TxRoutes,
			"up":           v.Up,
			"uptime":       v.Uptime,
			"vrf_name":     v.VrfName,
		})

	return objVal, diags
}

func (v BgpPeersValue) Equal(o attr.Value) bool {
	other, ok := o.(BgpPeersValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.EvpnOverlay.Equal(other.EvpnOverlay) {
		return false
	}

	if !v.ForOverlay.Equal(other.ForOverlay) {
		return false
	}

	if !v.LocalAs.Equal(other.LocalAs) {
		return false
	}

	if !v.Neighbor.Equal(other.Neighbor) {
		return false
	}

	if !v.NeighborAs.Equal(other.NeighborAs) {
		return false
	}

	if !v.NeighborMac.Equal(other.NeighborMac) {
		return false
	}

	if !v.Node.Equal(other.Node) {
		return false
	}

	if !v.RxPkts.Equal(other.RxPkts) {
		return false
	}

	if !v.RxRoutes.Equal(other.RxRoutes) {
		return false
	}

	if !v.State.Equal(other.State) {
		return false
	}

	if !v.Timestamp.Equal(other.Timestamp) {
		return false
	}

	if !v.TxPkts.Equal(other.TxPkts) {
		return false
	}

	if !v.TxRoutes.Equal(other.TxRoutes) {
		return false
	}

	if !v.Up.Equal(other.Up) {
		return false
	}

	if !v.Uptime.Equal(other.Uptime) {
		return false
	}

	if !v.VrfName.Equal(other.VrfName) {
		return false
	}

	return true
}

func (v BgpPeersValue) Type(ctx context.Context) attr.Type {
	return BgpPeersType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v BgpPeersValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"evpn_overlay": basetypes.BoolType{},
		"for_overlay":  basetypes.BoolType{},
		"local_as":     basetypes.Int64Type{},
		"neighbor":     basetypes.StringType{},
		"neighbor_as":  basetypes.Int64Type{},
		"neighbor_mac": basetypes.StringType{},
		"node":         basetypes.StringType{},
		"rx_pkts":      basetypes.Int64Type{},
		"rx_routes":    basetypes.Int64Type{},
		"state":        basetypes.StringType{},
		"timestamp":    basetypes.Float64Type{},
		"tx_pkts":      basetypes.Int64Type{},
		"tx_routes":    basetypes.Int64Type{},
		"up":           basetypes.BoolType{},
		"uptime":       basetypes.Int64Type{},
		"vrf_name":     basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = ClusterConfigType{}

type ClusterConfigType struct {
	basetypes.ObjectType
}

func (t ClusterConfigType) Equal(o attr.Type) bool {
	other, ok := o.(ClusterConfigType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ClusterConfigType) String() string {
	return "ClusterConfigType"
}

func (t ClusterConfigType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	configurationAttribute, ok := attributes["configuration"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`configuration is missing from object`)

		return nil, diags
	}

	configurationVal, ok := configurationAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`configuration expected to be basetypes.StringValue, was: %T`, configurationAttribute))
	}

	controlLinkInfoAttribute, ok := attributes["control_link_info"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`control_link_info is missing from object`)

		return nil, diags
	}

	controlLinkInfoVal, ok := controlLinkInfoAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`control_link_info expected to be basetypes.ObjectValue, was: %T`, controlLinkInfoAttribute))
	}

	ethernetConnectionAttribute, ok := attributes["ethernet_connection"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ethernet_connection is missing from object`)

		return nil, diags
	}

	ethernetConnectionVal, ok := ethernetConnectionAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ethernet_connection expected to be basetypes.ListValue, was: %T`, ethernetConnectionAttribute))
	}

	fabricLinkInfoAttribute, ok := attributes["fabric_link_info"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fabric_link_info is missing from object`)

		return nil, diags
	}

	fabricLinkInfoVal, ok := fabricLinkInfoAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fabric_link_info expected to be basetypes.ObjectValue, was: %T`, fabricLinkInfoAttribute))
	}

	lastStatusChangeReasonAttribute, ok := attributes["last_status_change_reason"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`last_status_change_reason is missing from object`)

		return nil, diags
	}

	lastStatusChangeReasonVal, ok := lastStatusChangeReasonAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`last_status_change_reason expected to be basetypes.StringValue, was: %T`, lastStatusChangeReasonAttribute))
	}

	operationalAttribute, ok := attributes["operational"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`operational is missing from object`)

		return nil, diags
	}

	operationalVal, ok := operationalAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`operational expected to be basetypes.StringValue, was: %T`, operationalAttribute))
	}

	primaryNodeHealthAttribute, ok := attributes["primary_node_health"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`primary_node_health is missing from object`)

		return nil, diags
	}

	primaryNodeHealthVal, ok := primaryNodeHealthAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`primary_node_health expected to be basetypes.StringValue, was: %T`, primaryNodeHealthAttribute))
	}

	redundancyGroupInformationAttribute, ok := attributes["redundancy_group_information"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`redundancy_group_information is missing from object`)

		return nil, diags
	}

	redundancyGroupInformationVal, ok := redundancyGroupInformationAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`redundancy_group_information expected to be basetypes.ListValue, was: %T`, redundancyGroupInformationAttribute))
	}

	secondaryNodeHealthAttribute, ok := attributes["secondary_node_health"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`secondary_node_health is missing from object`)

		return nil, diags
	}

	secondaryNodeHealthVal, ok := secondaryNodeHealthAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`secondary_node_health expected to be basetypes.StringValue, was: %T`, secondaryNodeHealthAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return nil, diags
	}

	statusVal, ok := statusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be basetypes.StringValue, was: %T`, statusAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ClusterConfigValue{
		Configuration:              configurationVal,
		ControlLinkInfo:            controlLinkInfoVal,
		EthernetConnection:         ethernetConnectionVal,
		FabricLinkInfo:             fabricLinkInfoVal,
		LastStatusChangeReason:     lastStatusChangeReasonVal,
		Operational:                operationalVal,
		PrimaryNodeHealth:          primaryNodeHealthVal,
		RedundancyGroupInformation: redundancyGroupInformationVal,
		SecondaryNodeHealth:        secondaryNodeHealthVal,
		Status:                     statusVal,
		state:                      attr.ValueStateKnown,
	}, diags
}

func NewClusterConfigValueNull() ClusterConfigValue {
	return ClusterConfigValue{
		state: attr.ValueStateNull,
	}
}

func NewClusterConfigValueUnknown() ClusterConfigValue {
	return ClusterConfigValue{
		state: attr.ValueStateUnknown,
	}
}

func NewClusterConfigValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ClusterConfigValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ClusterConfigValue Attribute Value",
				"While creating a ClusterConfigValue value, a missing attribute value was detected. "+
					"A ClusterConfigValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ClusterConfigValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ClusterConfigValue Attribute Type",
				"While creating a ClusterConfigValue value, an invalid attribute value was detected. "+
					"A ClusterConfigValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ClusterConfigValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ClusterConfigValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ClusterConfigValue Attribute Value",
				"While creating a ClusterConfigValue value, an extra attribute value was detected. "+
					"A ClusterConfigValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ClusterConfigValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewClusterConfigValueUnknown(), diags
	}

	configurationAttribute, ok := attributes["configuration"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`configuration is missing from object`)

		return NewClusterConfigValueUnknown(), diags
	}

	configurationVal, ok := configurationAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`configuration expected to be basetypes.StringValue, was: %T`, configurationAttribute))
	}

	controlLinkInfoAttribute, ok := attributes["control_link_info"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`control_link_info is missing from object`)

		return NewClusterConfigValueUnknown(), diags
	}

	controlLinkInfoVal, ok := controlLinkInfoAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`control_link_info expected to be basetypes.ObjectValue, was: %T`, controlLinkInfoAttribute))
	}

	ethernetConnectionAttribute, ok := attributes["ethernet_connection"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ethernet_connection is missing from object`)

		return NewClusterConfigValueUnknown(), diags
	}

	ethernetConnectionVal, ok := ethernetConnectionAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ethernet_connection expected to be basetypes.ListValue, was: %T`, ethernetConnectionAttribute))
	}

	fabricLinkInfoAttribute, ok := attributes["fabric_link_info"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fabric_link_info is missing from object`)

		return NewClusterConfigValueUnknown(), diags
	}

	fabricLinkInfoVal, ok := fabricLinkInfoAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fabric_link_info expected to be basetypes.ObjectValue, was: %T`, fabricLinkInfoAttribute))
	}

	lastStatusChangeReasonAttribute, ok := attributes["last_status_change_reason"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`last_status_change_reason is missing from object`)

		return NewClusterConfigValueUnknown(), diags
	}

	lastStatusChangeReasonVal, ok := lastStatusChangeReasonAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`last_status_change_reason expected to be basetypes.StringValue, was: %T`, lastStatusChangeReasonAttribute))
	}

	operationalAttribute, ok := attributes["operational"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`operational is missing from object`)

		return NewClusterConfigValueUnknown(), diags
	}

	operationalVal, ok := operationalAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`operational expected to be basetypes.StringValue, was: %T`, operationalAttribute))
	}

	primaryNodeHealthAttribute, ok := attributes["primary_node_health"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`primary_node_health is missing from object`)

		return NewClusterConfigValueUnknown(), diags
	}

	primaryNodeHealthVal, ok := primaryNodeHealthAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`primary_node_health expected to be basetypes.StringValue, was: %T`, primaryNodeHealthAttribute))
	}

	redundancyGroupInformationAttribute, ok := attributes["redundancy_group_information"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`redundancy_group_information is missing from object`)

		return NewClusterConfigValueUnknown(), diags
	}

	redundancyGroupInformationVal, ok := redundancyGroupInformationAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`redundancy_group_information expected to be basetypes.ListValue, was: %T`, redundancyGroupInformationAttribute))
	}

	secondaryNodeHealthAttribute, ok := attributes["secondary_node_health"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`secondary_node_health is missing from object`)

		return NewClusterConfigValueUnknown(), diags
	}

	secondaryNodeHealthVal, ok := secondaryNodeHealthAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`secondary_node_health expected to be basetypes.StringValue, was: %T`, secondaryNodeHealthAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return NewClusterConfigValueUnknown(), diags
	}

	statusVal, ok := statusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be basetypes.StringValue, was: %T`, statusAttribute))
	}

	if diags.HasError() {
		return NewClusterConfigValueUnknown(), diags
	}

	return ClusterConfigValue{
		Configuration:              configurationVal,
		ControlLinkInfo:            controlLinkInfoVal,
		EthernetConnection:         ethernetConnectionVal,
		FabricLinkInfo:             fabricLinkInfoVal,
		LastStatusChangeReason:     lastStatusChangeReasonVal,
		Operational:                operationalVal,
		PrimaryNodeHealth:          primaryNodeHealthVal,
		RedundancyGroupInformation: redundancyGroupInformationVal,
		SecondaryNodeHealth:        secondaryNodeHealthVal,
		Status:                     statusVal,
		state:                      attr.ValueStateKnown,
	}, diags
}

func NewClusterConfigValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ClusterConfigValue {
	object, diags := NewClusterConfigValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewClusterConfigValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ClusterConfigType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewClusterConfigValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewClusterConfigValueUnknown(), nil
	}

	if in.IsNull() {
		return NewClusterConfigValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewClusterConfigValueMust(ClusterConfigValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ClusterConfigType) ValueType(ctx context.Context) attr.Value {
	return ClusterConfigValue{}
}

var _ basetypes.ObjectValuable = ClusterConfigValue{}

type ClusterConfigValue struct {
	Configuration              basetypes.StringValue `tfsdk:"configuration"`
	ControlLinkInfo            basetypes.ObjectValue `tfsdk:"control_link_info"`
	EthernetConnection         basetypes.ListValue   `tfsdk:"ethernet_connection"`
	FabricLinkInfo             basetypes.ObjectValue `tfsdk:"fabric_link_info"`
	LastStatusChangeReason     basetypes.StringValue `tfsdk:"last_status_change_reason"`
	Operational                basetypes.StringValue `tfsdk:"operational"`
	PrimaryNodeHealth          basetypes.StringValue `tfsdk:"primary_node_health"`
	RedundancyGroupInformation basetypes.ListValue   `tfsdk:"redundancy_group_information"`
	SecondaryNodeHealth        basetypes.StringValue `tfsdk:"secondary_node_health"`
	Status                     basetypes.StringValue `tfsdk:"status"`
	state                      attr.ValueState
}

func (v ClusterConfigValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 10)

	var val tftypes.Value
	var err error

	attrTypes["configuration"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["control_link_info"] = basetypes.ObjectType{
		AttrTypes: ControlLinkInfoValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["ethernet_connection"] = basetypes.ListType{
		ElemType: EthernetConnectionValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["fabric_link_info"] = basetypes.ObjectType{
		AttrTypes: FabricLinkInfoValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["last_status_change_reason"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["operational"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["primary_node_health"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["redundancy_group_information"] = basetypes.ListType{
		ElemType: RedundancyGroupInformationValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["secondary_node_health"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["status"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 10)

		val, err = v.Configuration.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["configuration"] = val

		val, err = v.ControlLinkInfo.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["control_link_info"] = val

		val, err = v.EthernetConnection.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ethernet_connection"] = val

		val, err = v.FabricLinkInfo.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["fabric_link_info"] = val

		val, err = v.LastStatusChangeReason.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["last_status_change_reason"] = val

		val, err = v.Operational.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["operational"] = val

		val, err = v.PrimaryNodeHealth.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["primary_node_health"] = val

		val, err = v.RedundancyGroupInformation.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["redundancy_group_information"] = val

		val, err = v.SecondaryNodeHealth.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["secondary_node_health"] = val

		val, err = v.Status.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["status"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ClusterConfigValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ClusterConfigValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ClusterConfigValue) String() string {
	return "ClusterConfigValue"
}

func (v ClusterConfigValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var controlLinkInfo basetypes.ObjectValue

	if v.ControlLinkInfo.IsNull() {
		controlLinkInfo = types.ObjectNull(
			ControlLinkInfoValue{}.AttributeTypes(ctx),
		)
	}

	if v.ControlLinkInfo.IsUnknown() {
		controlLinkInfo = types.ObjectUnknown(
			ControlLinkInfoValue{}.AttributeTypes(ctx),
		)
	}

	if !v.ControlLinkInfo.IsNull() && !v.ControlLinkInfo.IsUnknown() {
		controlLinkInfo = types.ObjectValueMust(
			ControlLinkInfoValue{}.AttributeTypes(ctx),
			v.ControlLinkInfo.Attributes(),
		)
	}

	ethernetConnection := types.ListValueMust(
		EthernetConnectionType{
			basetypes.ObjectType{
				AttrTypes: EthernetConnectionValue{}.AttributeTypes(ctx),
			},
		},
		v.EthernetConnection.Elements(),
	)

	if v.EthernetConnection.IsNull() {
		ethernetConnection = types.ListNull(
			EthernetConnectionType{
				basetypes.ObjectType{
					AttrTypes: EthernetConnectionValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.EthernetConnection.IsUnknown() {
		ethernetConnection = types.ListUnknown(
			EthernetConnectionType{
				basetypes.ObjectType{
					AttrTypes: EthernetConnectionValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var fabricLinkInfo basetypes.ObjectValue

	if v.FabricLinkInfo.IsNull() {
		fabricLinkInfo = types.ObjectNull(
			FabricLinkInfoValue{}.AttributeTypes(ctx),
		)
	}

	if v.FabricLinkInfo.IsUnknown() {
		fabricLinkInfo = types.ObjectUnknown(
			FabricLinkInfoValue{}.AttributeTypes(ctx),
		)
	}

	if !v.FabricLinkInfo.IsNull() && !v.FabricLinkInfo.IsUnknown() {
		fabricLinkInfo = types.ObjectValueMust(
			FabricLinkInfoValue{}.AttributeTypes(ctx),
			v.FabricLinkInfo.Attributes(),
		)
	}

	redundancyGroupInformation := types.ListValueMust(
		RedundancyGroupInformationType{
			basetypes.ObjectType{
				AttrTypes: RedundancyGroupInformationValue{}.AttributeTypes(ctx),
			},
		},
		v.RedundancyGroupInformation.Elements(),
	)

	if v.RedundancyGroupInformation.IsNull() {
		redundancyGroupInformation = types.ListNull(
			RedundancyGroupInformationType{
				basetypes.ObjectType{
					AttrTypes: RedundancyGroupInformationValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.RedundancyGroupInformation.IsUnknown() {
		redundancyGroupInformation = types.ListUnknown(
			RedundancyGroupInformationType{
				basetypes.ObjectType{
					AttrTypes: RedundancyGroupInformationValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"configuration": basetypes.StringType{},
		"control_link_info": basetypes.ObjectType{
			AttrTypes: ControlLinkInfoValue{}.AttributeTypes(ctx),
		},
		"ethernet_connection": basetypes.ListType{
			ElemType: EthernetConnectionValue{}.Type(ctx),
		},
		"fabric_link_info": basetypes.ObjectType{
			AttrTypes: FabricLinkInfoValue{}.AttributeTypes(ctx),
		},
		"last_status_change_reason": basetypes.StringType{},
		"operational":               basetypes.StringType{},
		"primary_node_health":       basetypes.StringType{},
		"redundancy_group_information": basetypes.ListType{
			ElemType: RedundancyGroupInformationValue{}.Type(ctx),
		},
		"secondary_node_health": basetypes.StringType{},
		"status":                basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"configuration":                v.Configuration,
			"control_link_info":            controlLinkInfo,
			"ethernet_connection":          ethernetConnection,
			"fabric_link_info":             fabricLinkInfo,
			"last_status_change_reason":    v.LastStatusChangeReason,
			"operational":                  v.Operational,
			"primary_node_health":          v.PrimaryNodeHealth,
			"redundancy_group_information": redundancyGroupInformation,
			"secondary_node_health":        v.SecondaryNodeHealth,
			"status":                       v.Status,
		})

	return objVal, diags
}

func (v ClusterConfigValue) Equal(o attr.Value) bool {
	other, ok := o.(ClusterConfigValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Configuration.Equal(other.Configuration) {
		return false
	}

	if !v.ControlLinkInfo.Equal(other.ControlLinkInfo) {
		return false
	}

	if !v.EthernetConnection.Equal(other.EthernetConnection) {
		return false
	}

	if !v.FabricLinkInfo.Equal(other.FabricLinkInfo) {
		return false
	}

	if !v.LastStatusChangeReason.Equal(other.LastStatusChangeReason) {
		return false
	}

	if !v.Operational.Equal(other.Operational) {
		return false
	}

	if !v.PrimaryNodeHealth.Equal(other.PrimaryNodeHealth) {
		return false
	}

	if !v.RedundancyGroupInformation.Equal(other.RedundancyGroupInformation) {
		return false
	}

	if !v.SecondaryNodeHealth.Equal(other.SecondaryNodeHealth) {
		return false
	}

	if !v.Status.Equal(other.Status) {
		return false
	}

	return true
}

func (v ClusterConfigValue) Type(ctx context.Context) attr.Type {
	return ClusterConfigType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ClusterConfigValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"configuration": basetypes.StringType{},
		"control_link_info": basetypes.ObjectType{
			AttrTypes: ControlLinkInfoValue{}.AttributeTypes(ctx),
		},
		"ethernet_connection": basetypes.ListType{
			ElemType: EthernetConnectionValue{}.Type(ctx),
		},
		"fabric_link_info": basetypes.ObjectType{
			AttrTypes: FabricLinkInfoValue{}.AttributeTypes(ctx),
		},
		"last_status_change_reason": basetypes.StringType{},
		"operational":               basetypes.StringType{},
		"primary_node_health":       basetypes.StringType{},
		"redundancy_group_information": basetypes.ListType{
			ElemType: RedundancyGroupInformationValue{}.Type(ctx),
		},
		"secondary_node_health": basetypes.StringType{},
		"status":                basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = ControlLinkInfoType{}

type ControlLinkInfoType struct {
	basetypes.ObjectType
}

func (t ControlLinkInfoType) Equal(o attr.Type) bool {
	other, ok := o.(ControlLinkInfoType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ControlLinkInfoType) String() string {
	return "ControlLinkInfoType"
}

func (t ControlLinkInfoType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return nil, diags
	}

	statusVal, ok := statusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be basetypes.StringValue, was: %T`, statusAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ControlLinkInfoValue{
		Name:   nameVal,
		Status: statusVal,
		state:  attr.ValueStateKnown,
	}, diags
}

func NewControlLinkInfoValueNull() ControlLinkInfoValue {
	return ControlLinkInfoValue{
		state: attr.ValueStateNull,
	}
}

func NewControlLinkInfoValueUnknown() ControlLinkInfoValue {
	return ControlLinkInfoValue{
		state: attr.ValueStateUnknown,
	}
}

func NewControlLinkInfoValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ControlLinkInfoValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ControlLinkInfoValue Attribute Value",
				"While creating a ControlLinkInfoValue value, a missing attribute value was detected. "+
					"A ControlLinkInfoValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ControlLinkInfoValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ControlLinkInfoValue Attribute Type",
				"While creating a ControlLinkInfoValue value, an invalid attribute value was detected. "+
					"A ControlLinkInfoValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ControlLinkInfoValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ControlLinkInfoValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ControlLinkInfoValue Attribute Value",
				"While creating a ControlLinkInfoValue value, an extra attribute value was detected. "+
					"A ControlLinkInfoValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ControlLinkInfoValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewControlLinkInfoValueUnknown(), diags
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewControlLinkInfoValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return NewControlLinkInfoValueUnknown(), diags
	}

	statusVal, ok := statusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be basetypes.StringValue, was: %T`, statusAttribute))
	}

	if diags.HasError() {
		return NewControlLinkInfoValueUnknown(), diags
	}

	return ControlLinkInfoValue{
		Name:   nameVal,
		Status: statusVal,
		state:  attr.ValueStateKnown,
	}, diags
}

func NewControlLinkInfoValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ControlLinkInfoValue {
	object, diags := NewControlLinkInfoValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewControlLinkInfoValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ControlLinkInfoType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewControlLinkInfoValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewControlLinkInfoValueUnknown(), nil
	}

	if in.IsNull() {
		return NewControlLinkInfoValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewControlLinkInfoValueMust(ControlLinkInfoValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ControlLinkInfoType) ValueType(ctx context.Context) attr.Value {
	return ControlLinkInfoValue{}
}

var _ basetypes.ObjectValuable = ControlLinkInfoValue{}

type ControlLinkInfoValue struct {
	Name   basetypes.StringValue `tfsdk:"name"`
	Status basetypes.StringValue `tfsdk:"status"`
	state  attr.ValueState
}

func (v ControlLinkInfoValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["status"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Status.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["status"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ControlLinkInfoValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ControlLinkInfoValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ControlLinkInfoValue) String() string {
	return "ControlLinkInfoValue"
}

func (v ControlLinkInfoValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"name":   basetypes.StringType{},
		"status": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"name":   v.Name,
			"status": v.Status,
		})

	return objVal, diags
}

func (v ControlLinkInfoValue) Equal(o attr.Value) bool {
	other, ok := o.(ControlLinkInfoValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Status.Equal(other.Status) {
		return false
	}

	return true
}

func (v ControlLinkInfoValue) Type(ctx context.Context) attr.Type {
	return ControlLinkInfoType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ControlLinkInfoValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"name":   basetypes.StringType{},
		"status": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = EthernetConnectionType{}

type EthernetConnectionType struct {
	basetypes.ObjectType
}

func (t EthernetConnectionType) Equal(o attr.Type) bool {
	other, ok := o.(EthernetConnectionType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t EthernetConnectionType) String() string {
	return "EthernetConnectionType"
}

func (t EthernetConnectionType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return nil, diags
	}

	statusVal, ok := statusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be basetypes.StringValue, was: %T`, statusAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return EthernetConnectionValue{
		Name:   nameVal,
		Status: statusVal,
		state:  attr.ValueStateKnown,
	}, diags
}

func NewEthernetConnectionValueNull() EthernetConnectionValue {
	return EthernetConnectionValue{
		state: attr.ValueStateNull,
	}
}

func NewEthernetConnectionValueUnknown() EthernetConnectionValue {
	return EthernetConnectionValue{
		state: attr.ValueStateUnknown,
	}
}

func NewEthernetConnectionValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (EthernetConnectionValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing EthernetConnectionValue Attribute Value",
				"While creating a EthernetConnectionValue value, a missing attribute value was detected. "+
					"A EthernetConnectionValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("EthernetConnectionValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid EthernetConnectionValue Attribute Type",
				"While creating a EthernetConnectionValue value, an invalid attribute value was detected. "+
					"A EthernetConnectionValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("EthernetConnectionValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("EthernetConnectionValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra EthernetConnectionValue Attribute Value",
				"While creating a EthernetConnectionValue value, an extra attribute value was detected. "+
					"A EthernetConnectionValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra EthernetConnectionValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewEthernetConnectionValueUnknown(), diags
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewEthernetConnectionValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return NewEthernetConnectionValueUnknown(), diags
	}

	statusVal, ok := statusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be basetypes.StringValue, was: %T`, statusAttribute))
	}

	if diags.HasError() {
		return NewEthernetConnectionValueUnknown(), diags
	}

	return EthernetConnectionValue{
		Name:   nameVal,
		Status: statusVal,
		state:  attr.ValueStateKnown,
	}, diags
}

func NewEthernetConnectionValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) EthernetConnectionValue {
	object, diags := NewEthernetConnectionValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewEthernetConnectionValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t EthernetConnectionType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewEthernetConnectionValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewEthernetConnectionValueUnknown(), nil
	}

	if in.IsNull() {
		return NewEthernetConnectionValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewEthernetConnectionValueMust(EthernetConnectionValue{}.AttributeTypes(ctx), attributes), nil
}

func (t EthernetConnectionType) ValueType(ctx context.Context) attr.Value {
	return EthernetConnectionValue{}
}

var _ basetypes.ObjectValuable = EthernetConnectionValue{}

type EthernetConnectionValue struct {
	Name   basetypes.StringValue `tfsdk:"name"`
	Status basetypes.StringValue `tfsdk:"status"`
	state  attr.ValueState
}

func (v EthernetConnectionValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["status"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Status.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["status"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v EthernetConnectionValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v EthernetConnectionValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v EthernetConnectionValue) String() string {
	return "EthernetConnectionValue"
}

func (v EthernetConnectionValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"name":   basetypes.StringType{},
		"status": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"name":   v.Name,
			"status": v.Status,
		})

	return objVal, diags
}

func (v EthernetConnectionValue) Equal(o attr.Value) bool {
	other, ok := o.(EthernetConnectionValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Status.Equal(other.Status) {
		return false
	}

	return true
}

func (v EthernetConnectionValue) Type(ctx context.Context) attr.Type {
	return EthernetConnectionType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v EthernetConnectionValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"name":   basetypes.StringType{},
		"status": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = FabricLinkInfoType{}

type FabricLinkInfoType struct {
	basetypes.ObjectType
}

func (t FabricLinkInfoType) Equal(o attr.Type) bool {
	other, ok := o.(FabricLinkInfoType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t FabricLinkInfoType) String() string {
	return "FabricLinkInfoType"
}

func (t FabricLinkInfoType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	dataPlaneNotifiedStatusAttribute, ok := attributes["data_plane_notified_status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`data_plane_notified_status is missing from object`)

		return nil, diags
	}

	dataPlaneNotifiedStatusVal, ok := dataPlaneNotifiedStatusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`data_plane_notified_status expected to be basetypes.StringValue, was: %T`, dataPlaneNotifiedStatusAttribute))
	}

	interfaceAttribute, ok := attributes["interface"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface is missing from object`)

		return nil, diags
	}

	interfaceVal, ok := interfaceAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface expected to be basetypes.ListValue, was: %T`, interfaceAttribute))
	}

	internalStatusAttribute, ok := attributes["internal_status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`internal_status is missing from object`)

		return nil, diags
	}

	internalStatusVal, ok := internalStatusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`internal_status expected to be basetypes.StringValue, was: %T`, internalStatusAttribute))
	}

	stateAttribute, ok := attributes["state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`state is missing from object`)

		return nil, diags
	}

	stateVal, ok := stateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`state expected to be basetypes.StringValue, was: %T`, stateAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return nil, diags
	}

	statusVal, ok := statusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be basetypes.StringValue, was: %T`, statusAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return FabricLinkInfoValue{
		DataPlaneNotifiedStatus: dataPlaneNotifiedStatusVal,
		Interface:               interfaceVal,
		InternalStatus:          internalStatusVal,
		State:                   stateVal,
		Status:                  statusVal,
		state:                   attr.ValueStateKnown,
	}, diags
}

func NewFabricLinkInfoValueNull() FabricLinkInfoValue {
	return FabricLinkInfoValue{
		state: attr.ValueStateNull,
	}
}

func NewFabricLinkInfoValueUnknown() FabricLinkInfoValue {
	return FabricLinkInfoValue{
		state: attr.ValueStateUnknown,
	}
}

func NewFabricLinkInfoValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (FabricLinkInfoValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing FabricLinkInfoValue Attribute Value",
				"While creating a FabricLinkInfoValue value, a missing attribute value was detected. "+
					"A FabricLinkInfoValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("FabricLinkInfoValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid FabricLinkInfoValue Attribute Type",
				"While creating a FabricLinkInfoValue value, an invalid attribute value was detected. "+
					"A FabricLinkInfoValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("FabricLinkInfoValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("FabricLinkInfoValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra FabricLinkInfoValue Attribute Value",
				"While creating a FabricLinkInfoValue value, an extra attribute value was detected. "+
					"A FabricLinkInfoValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra FabricLinkInfoValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewFabricLinkInfoValueUnknown(), diags
	}

	dataPlaneNotifiedStatusAttribute, ok := attributes["data_plane_notified_status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`data_plane_notified_status is missing from object`)

		return NewFabricLinkInfoValueUnknown(), diags
	}

	dataPlaneNotifiedStatusVal, ok := dataPlaneNotifiedStatusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`data_plane_notified_status expected to be basetypes.StringValue, was: %T`, dataPlaneNotifiedStatusAttribute))
	}

	interfaceAttribute, ok := attributes["interface"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface is missing from object`)

		return NewFabricLinkInfoValueUnknown(), diags
	}

	interfaceVal, ok := interfaceAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface expected to be basetypes.ListValue, was: %T`, interfaceAttribute))
	}

	internalStatusAttribute, ok := attributes["internal_status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`internal_status is missing from object`)

		return NewFabricLinkInfoValueUnknown(), diags
	}

	internalStatusVal, ok := internalStatusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`internal_status expected to be basetypes.StringValue, was: %T`, internalStatusAttribute))
	}

	stateAttribute, ok := attributes["state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`state is missing from object`)

		return NewFabricLinkInfoValueUnknown(), diags
	}

	stateVal, ok := stateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`state expected to be basetypes.StringValue, was: %T`, stateAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return NewFabricLinkInfoValueUnknown(), diags
	}

	statusVal, ok := statusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be basetypes.StringValue, was: %T`, statusAttribute))
	}

	if diags.HasError() {
		return NewFabricLinkInfoValueUnknown(), diags
	}

	return FabricLinkInfoValue{
		DataPlaneNotifiedStatus: dataPlaneNotifiedStatusVal,
		Interface:               interfaceVal,
		InternalStatus:          internalStatusVal,
		State:                   stateVal,
		Status:                  statusVal,
		state:                   attr.ValueStateKnown,
	}, diags
}

func NewFabricLinkInfoValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) FabricLinkInfoValue {
	object, diags := NewFabricLinkInfoValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewFabricLinkInfoValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t FabricLinkInfoType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewFabricLinkInfoValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewFabricLinkInfoValueUnknown(), nil
	}

	if in.IsNull() {
		return NewFabricLinkInfoValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewFabricLinkInfoValueMust(FabricLinkInfoValue{}.AttributeTypes(ctx), attributes), nil
}

func (t FabricLinkInfoType) ValueType(ctx context.Context) attr.Value {
	return FabricLinkInfoValue{}
}

var _ basetypes.ObjectValuable = FabricLinkInfoValue{}

type FabricLinkInfoValue struct {
	DataPlaneNotifiedStatus basetypes.StringValue `tfsdk:"data_plane_notified_status"`
	Interface               basetypes.ListValue   `tfsdk:"interface"`
	InternalStatus          basetypes.StringValue `tfsdk:"internal_status"`
	State                   basetypes.StringValue `tfsdk:"state"`
	Status                  basetypes.StringValue `tfsdk:"status"`
	state                   attr.ValueState
}

func (v FabricLinkInfoValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["data_plane_notified_status"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["interface"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["internal_status"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["state"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["status"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.DataPlaneNotifiedStatus.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["data_plane_notified_status"] = val

		val, err = v.Interface.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["interface"] = val

		val, err = v.InternalStatus.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["internal_status"] = val

		val, err = v.State.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["state"] = val

		val, err = v.Status.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["status"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v FabricLinkInfoValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v FabricLinkInfoValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v FabricLinkInfoValue) String() string {
	return "FabricLinkInfoValue"
}

func (v FabricLinkInfoValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	interfaceVal, d := types.ListValue(types.StringType, v.Interface.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"data_plane_notified_status": basetypes.StringType{},
			"interface": basetypes.ListType{
				ElemType: types.StringType,
			},
			"internal_status": basetypes.StringType{},
			"state":           basetypes.StringType{},
			"status":          basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"data_plane_notified_status": basetypes.StringType{},
		"interface": basetypes.ListType{
			ElemType: types.StringType,
		},
		"internal_status": basetypes.StringType{},
		"state":           basetypes.StringType{},
		"status":          basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"data_plane_notified_status": v.DataPlaneNotifiedStatus,
			"interface":                  interfaceVal,
			"internal_status":            v.InternalStatus,
			"state":                      v.State,
			"status":                     v.Status,
		})

	return objVal, diags
}

func (v FabricLinkInfoValue) Equal(o attr.Value) bool {
	other, ok := o.(FabricLinkInfoValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.DataPlaneNotifiedStatus.Equal(other.DataPlaneNotifiedStatus) {
		return false
	}

	if !v.Interface.Equal(other.Interface) {
		return false
	}

	if !v.InternalStatus.Equal(other.InternalStatus) {
		return false
	}

	if !v.State.Equal(other.State) {
		return false
	}

	if !v.Status.Equal(other.Status) {
		return false
	}

	return true
}

func (v FabricLinkInfoValue) Type(ctx context.Context) attr.Type {
	return FabricLinkInfoType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v FabricLinkInfoValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"data_plane_notified_status": basetypes.StringType{},
		"interface": basetypes.ListType{
			ElemType: types.StringType,
		},
		"internal_status": basetypes.StringType{},
		"state":           basetypes.StringType{},
		"status":          basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = RedundancyGroupInformationType{}

type RedundancyGroupInformationType struct {
	basetypes.ObjectType
}

func (t RedundancyGroupInformationType) Equal(o attr.Type) bool {
	other, ok := o.(RedundancyGroupInformationType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t RedundancyGroupInformationType) String() string {
	return "RedundancyGroupInformationType"
}

func (t RedundancyGroupInformationType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	monitoringFailureAttribute, ok := attributes["monitoring_failure"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`monitoring_failure is missing from object`)

		return nil, diags
	}

	monitoringFailureVal, ok := monitoringFailureAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`monitoring_failure expected to be basetypes.StringValue, was: %T`, monitoringFailureAttribute))
	}

	thresholdAttribute, ok := attributes["threshold"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`threshold is missing from object`)

		return nil, diags
	}

	thresholdVal, ok := thresholdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`threshold expected to be basetypes.Int64Value, was: %T`, thresholdAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return RedundancyGroupInformationValue{
		Id:                idVal,
		MonitoringFailure: monitoringFailureVal,
		Threshold:         thresholdVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewRedundancyGroupInformationValueNull() RedundancyGroupInformationValue {
	return RedundancyGroupInformationValue{
		state: attr.ValueStateNull,
	}
}

func NewRedundancyGroupInformationValueUnknown() RedundancyGroupInformationValue {
	return RedundancyGroupInformationValue{
		state: attr.ValueStateUnknown,
	}
}

func NewRedundancyGroupInformationValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (RedundancyGroupInformationValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing RedundancyGroupInformationValue Attribute Value",
				"While creating a RedundancyGroupInformationValue value, a missing attribute value was detected. "+
					"A RedundancyGroupInformationValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RedundancyGroupInformationValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid RedundancyGroupInformationValue Attribute Type",
				"While creating a RedundancyGroupInformationValue value, an invalid attribute value was detected. "+
					"A RedundancyGroupInformationValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RedundancyGroupInformationValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("RedundancyGroupInformationValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra RedundancyGroupInformationValue Attribute Value",
				"While creating a RedundancyGroupInformationValue value, an extra attribute value was detected. "+
					"A RedundancyGroupInformationValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra RedundancyGroupInformationValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewRedundancyGroupInformationValueUnknown(), diags
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewRedundancyGroupInformationValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	monitoringFailureAttribute, ok := attributes["monitoring_failure"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`monitoring_failure is missing from object`)

		return NewRedundancyGroupInformationValueUnknown(), diags
	}

	monitoringFailureVal, ok := monitoringFailureAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`monitoring_failure expected to be basetypes.StringValue, was: %T`, monitoringFailureAttribute))
	}

	thresholdAttribute, ok := attributes["threshold"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`threshold is missing from object`)

		return NewRedundancyGroupInformationValueUnknown(), diags
	}

	thresholdVal, ok := thresholdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`threshold expected to be basetypes.Int64Value, was: %T`, thresholdAttribute))
	}

	if diags.HasError() {
		return NewRedundancyGroupInformationValueUnknown(), diags
	}

	return RedundancyGroupInformationValue{
		Id:                idVal,
		MonitoringFailure: monitoringFailureVal,
		Threshold:         thresholdVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewRedundancyGroupInformationValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) RedundancyGroupInformationValue {
	object, diags := NewRedundancyGroupInformationValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewRedundancyGroupInformationValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t RedundancyGroupInformationType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewRedundancyGroupInformationValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewRedundancyGroupInformationValueUnknown(), nil
	}

	if in.IsNull() {
		return NewRedundancyGroupInformationValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewRedundancyGroupInformationValueMust(RedundancyGroupInformationValue{}.AttributeTypes(ctx), attributes), nil
}

func (t RedundancyGroupInformationType) ValueType(ctx context.Context) attr.Value {
	return RedundancyGroupInformationValue{}
}

var _ basetypes.ObjectValuable = RedundancyGroupInformationValue{}

type RedundancyGroupInformationValue struct {
	Id                basetypes.Int64Value  `tfsdk:"id"`
	MonitoringFailure basetypes.StringValue `tfsdk:"monitoring_failure"`
	Threshold         basetypes.Int64Value  `tfsdk:"threshold"`
	state             attr.ValueState
}

func (v RedundancyGroupInformationValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["id"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["monitoring_failure"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["threshold"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.MonitoringFailure.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["monitoring_failure"] = val

		val, err = v.Threshold.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["threshold"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v RedundancyGroupInformationValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v RedundancyGroupInformationValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v RedundancyGroupInformationValue) String() string {
	return "RedundancyGroupInformationValue"
}

func (v RedundancyGroupInformationValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"id":                 basetypes.Int64Type{},
		"monitoring_failure": basetypes.StringType{},
		"threshold":          basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"id":                 v.Id,
			"monitoring_failure": v.MonitoringFailure,
			"threshold":          v.Threshold,
		})

	return objVal, diags
}

func (v RedundancyGroupInformationValue) Equal(o attr.Value) bool {
	other, ok := o.(RedundancyGroupInformationValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.MonitoringFailure.Equal(other.MonitoringFailure) {
		return false
	}

	if !v.Threshold.Equal(other.Threshold) {
		return false
	}

	return true
}

func (v RedundancyGroupInformationValue) Type(ctx context.Context) attr.Type {
	return RedundancyGroupInformationType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v RedundancyGroupInformationValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"id":                 basetypes.Int64Type{},
		"monitoring_failure": basetypes.StringType{},
		"threshold":          basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = ClusterStatType{}

type ClusterStatType struct {
	basetypes.ObjectType
}

func (t ClusterStatType) Equal(o attr.Type) bool {
	other, ok := o.(ClusterStatType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ClusterStatType) String() string {
	return "ClusterStatType"
}

func (t ClusterStatType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	stateAttribute, ok := attributes["state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`state is missing from object`)

		return nil, diags
	}

	stateVal, ok := stateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`state expected to be basetypes.StringValue, was: %T`, stateAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ClusterStatValue{
		State: stateVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewClusterStatValueNull() ClusterStatValue {
	return ClusterStatValue{
		state: attr.ValueStateNull,
	}
}

func NewClusterStatValueUnknown() ClusterStatValue {
	return ClusterStatValue{
		state: attr.ValueStateUnknown,
	}
}

func NewClusterStatValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ClusterStatValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ClusterStatValue Attribute Value",
				"While creating a ClusterStatValue value, a missing attribute value was detected. "+
					"A ClusterStatValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ClusterStatValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ClusterStatValue Attribute Type",
				"While creating a ClusterStatValue value, an invalid attribute value was detected. "+
					"A ClusterStatValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ClusterStatValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ClusterStatValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ClusterStatValue Attribute Value",
				"While creating a ClusterStatValue value, an extra attribute value was detected. "+
					"A ClusterStatValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ClusterStatValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewClusterStatValueUnknown(), diags
	}

	stateAttribute, ok := attributes["state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`state is missing from object`)

		return NewClusterStatValueUnknown(), diags
	}

	stateVal, ok := stateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`state expected to be basetypes.StringValue, was: %T`, stateAttribute))
	}

	if diags.HasError() {
		return NewClusterStatValueUnknown(), diags
	}

	return ClusterStatValue{
		State: stateVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewClusterStatValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ClusterStatValue {
	object, diags := NewClusterStatValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewClusterStatValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ClusterStatType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewClusterStatValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewClusterStatValueUnknown(), nil
	}

	if in.IsNull() {
		return NewClusterStatValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewClusterStatValueMust(ClusterStatValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ClusterStatType) ValueType(ctx context.Context) attr.Value {
	return ClusterStatValue{}
}

var _ basetypes.ObjectValuable = ClusterStatValue{}

type ClusterStatValue struct {
	State basetypes.StringValue `tfsdk:"state"`
	state attr.ValueState
}

func (v ClusterStatValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["state"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.State.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["state"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ClusterStatValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ClusterStatValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ClusterStatValue) String() string {
	return "ClusterStatValue"
}

func (v ClusterStatValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"state": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"state": v.State,
		})

	return objVal, diags
}

func (v ClusterStatValue) Equal(o attr.Value) bool {
	other, ok := o.(ClusterStatValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.State.Equal(other.State) {
		return false
	}

	return true
}

func (v ClusterStatValue) Type(ctx context.Context) attr.Type {
	return ClusterStatType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ClusterStatValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"state": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = CpuStatType{}

type CpuStatType struct {
	basetypes.ObjectType
}

func (t CpuStatType) Equal(o attr.Type) bool {
	other, ok := o.(CpuStatType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t CpuStatType) String() string {
	return "CpuStatType"
}

func (t CpuStatType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	idleAttribute, ok := attributes["idle"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`idle is missing from object`)

		return nil, diags
	}

	idleVal, ok := idleAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`idle expected to be basetypes.NumberValue, was: %T`, idleAttribute))
	}

	interruptAttribute, ok := attributes["interrupt"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interrupt is missing from object`)

		return nil, diags
	}

	interruptVal, ok := interruptAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interrupt expected to be basetypes.NumberValue, was: %T`, interruptAttribute))
	}

	loadAvgAttribute, ok := attributes["load_avg"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`load_avg is missing from object`)

		return nil, diags
	}

	loadAvgVal, ok := loadAvgAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`load_avg expected to be basetypes.ListValue, was: %T`, loadAvgAttribute))
	}

	systemAttribute, ok := attributes["system"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`system is missing from object`)

		return nil, diags
	}

	systemVal, ok := systemAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`system expected to be basetypes.NumberValue, was: %T`, systemAttribute))
	}

	userAttribute, ok := attributes["user"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`user is missing from object`)

		return nil, diags
	}

	userVal, ok := userAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`user expected to be basetypes.NumberValue, was: %T`, userAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return CpuStatValue{
		Idle:      idleVal,
		Interrupt: interruptVal,
		LoadAvg:   loadAvgVal,
		System:    systemVal,
		User:      userVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewCpuStatValueNull() CpuStatValue {
	return CpuStatValue{
		state: attr.ValueStateNull,
	}
}

func NewCpuStatValueUnknown() CpuStatValue {
	return CpuStatValue{
		state: attr.ValueStateUnknown,
	}
}

func NewCpuStatValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (CpuStatValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing CpuStatValue Attribute Value",
				"While creating a CpuStatValue value, a missing attribute value was detected. "+
					"A CpuStatValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CpuStatValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid CpuStatValue Attribute Type",
				"While creating a CpuStatValue value, an invalid attribute value was detected. "+
					"A CpuStatValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CpuStatValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("CpuStatValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra CpuStatValue Attribute Value",
				"While creating a CpuStatValue value, an extra attribute value was detected. "+
					"A CpuStatValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra CpuStatValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewCpuStatValueUnknown(), diags
	}

	idleAttribute, ok := attributes["idle"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`idle is missing from object`)

		return NewCpuStatValueUnknown(), diags
	}

	idleVal, ok := idleAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`idle expected to be basetypes.NumberValue, was: %T`, idleAttribute))
	}

	interruptAttribute, ok := attributes["interrupt"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interrupt is missing from object`)

		return NewCpuStatValueUnknown(), diags
	}

	interruptVal, ok := interruptAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interrupt expected to be basetypes.NumberValue, was: %T`, interruptAttribute))
	}

	loadAvgAttribute, ok := attributes["load_avg"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`load_avg is missing from object`)

		return NewCpuStatValueUnknown(), diags
	}

	loadAvgVal, ok := loadAvgAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`load_avg expected to be basetypes.ListValue, was: %T`, loadAvgAttribute))
	}

	systemAttribute, ok := attributes["system"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`system is missing from object`)

		return NewCpuStatValueUnknown(), diags
	}

	systemVal, ok := systemAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`system expected to be basetypes.NumberValue, was: %T`, systemAttribute))
	}

	userAttribute, ok := attributes["user"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`user is missing from object`)

		return NewCpuStatValueUnknown(), diags
	}

	userVal, ok := userAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`user expected to be basetypes.NumberValue, was: %T`, userAttribute))
	}

	if diags.HasError() {
		return NewCpuStatValueUnknown(), diags
	}

	return CpuStatValue{
		Idle:      idleVal,
		Interrupt: interruptVal,
		LoadAvg:   loadAvgVal,
		System:    systemVal,
		User:      userVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewCpuStatValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) CpuStatValue {
	object, diags := NewCpuStatValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewCpuStatValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t CpuStatType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewCpuStatValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewCpuStatValueUnknown(), nil
	}

	if in.IsNull() {
		return NewCpuStatValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewCpuStatValueMust(CpuStatValue{}.AttributeTypes(ctx), attributes), nil
}

func (t CpuStatType) ValueType(ctx context.Context) attr.Value {
	return CpuStatValue{}
}

var _ basetypes.ObjectValuable = CpuStatValue{}

type CpuStatValue struct {
	Idle      basetypes.NumberValue `tfsdk:"idle"`
	Interrupt basetypes.NumberValue `tfsdk:"interrupt"`
	LoadAvg   basetypes.ListValue   `tfsdk:"load_avg"`
	System    basetypes.NumberValue `tfsdk:"system"`
	User      basetypes.NumberValue `tfsdk:"user"`
	state     attr.ValueState
}

func (v CpuStatValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["idle"] = basetypes.NumberType{}.TerraformType(ctx)
	attrTypes["interrupt"] = basetypes.NumberType{}.TerraformType(ctx)
	attrTypes["load_avg"] = basetypes.ListType{
		ElemType: types.NumberType,
	}.TerraformType(ctx)
	attrTypes["system"] = basetypes.NumberType{}.TerraformType(ctx)
	attrTypes["user"] = basetypes.NumberType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.Idle.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["idle"] = val

		val, err = v.Interrupt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["interrupt"] = val

		val, err = v.LoadAvg.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["load_avg"] = val

		val, err = v.System.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["system"] = val

		val, err = v.User.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["user"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v CpuStatValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v CpuStatValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v CpuStatValue) String() string {
	return "CpuStatValue"
}

func (v CpuStatValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	loadAvgVal, d := types.ListValue(types.NumberType, v.LoadAvg.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"idle":      basetypes.NumberType{},
			"interrupt": basetypes.NumberType{},
			"load_avg": basetypes.ListType{
				ElemType: types.NumberType,
			},
			"system": basetypes.NumberType{},
			"user":   basetypes.NumberType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"idle":      basetypes.NumberType{},
		"interrupt": basetypes.NumberType{},
		"load_avg": basetypes.ListType{
			ElemType: types.NumberType,
		},
		"system": basetypes.NumberType{},
		"user":   basetypes.NumberType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"idle":      v.Idle,
			"interrupt": v.Interrupt,
			"load_avg":  loadAvgVal,
			"system":    v.System,
			"user":      v.User,
		})

	return objVal, diags
}

func (v CpuStatValue) Equal(o attr.Value) bool {
	other, ok := o.(CpuStatValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Idle.Equal(other.Idle) {
		return false
	}

	if !v.Interrupt.Equal(other.Interrupt) {
		return false
	}

	if !v.LoadAvg.Equal(other.LoadAvg) {
		return false
	}

	if !v.System.Equal(other.System) {
		return false
	}

	if !v.User.Equal(other.User) {
		return false
	}

	return true
}

func (v CpuStatValue) Type(ctx context.Context) attr.Type {
	return CpuStatType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v CpuStatValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"idle":      basetypes.NumberType{},
		"interrupt": basetypes.NumberType{},
		"load_avg": basetypes.ListType{
			ElemType: types.NumberType,
		},
		"system": basetypes.NumberType{},
		"user":   basetypes.NumberType{},
	}
}

var _ basetypes.ObjectTypable = DhcpdStatType{}

type DhcpdStatType struct {
	basetypes.ObjectType
}

func (t DhcpdStatType) Equal(o attr.Type) bool {
	other, ok := o.(DhcpdStatType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t DhcpdStatType) String() string {
	return "DhcpdStatType"
}

func (t DhcpdStatType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	numIpsAttribute, ok := attributes["num_ips"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`num_ips is missing from object`)

		return nil, diags
	}

	numIpsVal, ok := numIpsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`num_ips expected to be basetypes.Int64Value, was: %T`, numIpsAttribute))
	}

	numLeasedAttribute, ok := attributes["num_leased"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`num_leased is missing from object`)

		return nil, diags
	}

	numLeasedVal, ok := numLeasedAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`num_leased expected to be basetypes.Int64Value, was: %T`, numLeasedAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return DhcpdStatValue{
		NumIps:    numIpsVal,
		NumLeased: numLeasedVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewDhcpdStatValueNull() DhcpdStatValue {
	return DhcpdStatValue{
		state: attr.ValueStateNull,
	}
}

func NewDhcpdStatValueUnknown() DhcpdStatValue {
	return DhcpdStatValue{
		state: attr.ValueStateUnknown,
	}
}

func NewDhcpdStatValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (DhcpdStatValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing DhcpdStatValue Attribute Value",
				"While creating a DhcpdStatValue value, a missing attribute value was detected. "+
					"A DhcpdStatValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DhcpdStatValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid DhcpdStatValue Attribute Type",
				"While creating a DhcpdStatValue value, an invalid attribute value was detected. "+
					"A DhcpdStatValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DhcpdStatValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("DhcpdStatValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra DhcpdStatValue Attribute Value",
				"While creating a DhcpdStatValue value, an extra attribute value was detected. "+
					"A DhcpdStatValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra DhcpdStatValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewDhcpdStatValueUnknown(), diags
	}

	numIpsAttribute, ok := attributes["num_ips"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`num_ips is missing from object`)

		return NewDhcpdStatValueUnknown(), diags
	}

	numIpsVal, ok := numIpsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`num_ips expected to be basetypes.Int64Value, was: %T`, numIpsAttribute))
	}

	numLeasedAttribute, ok := attributes["num_leased"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`num_leased is missing from object`)

		return NewDhcpdStatValueUnknown(), diags
	}

	numLeasedVal, ok := numLeasedAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`num_leased expected to be basetypes.Int64Value, was: %T`, numLeasedAttribute))
	}

	if diags.HasError() {
		return NewDhcpdStatValueUnknown(), diags
	}

	return DhcpdStatValue{
		NumIps:    numIpsVal,
		NumLeased: numLeasedVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewDhcpdStatValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) DhcpdStatValue {
	object, diags := NewDhcpdStatValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewDhcpdStatValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t DhcpdStatType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewDhcpdStatValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewDhcpdStatValueUnknown(), nil
	}

	if in.IsNull() {
		return NewDhcpdStatValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewDhcpdStatValueMust(DhcpdStatValue{}.AttributeTypes(ctx), attributes), nil
}

func (t DhcpdStatType) ValueType(ctx context.Context) attr.Value {
	return DhcpdStatValue{}
}

var _ basetypes.ObjectValuable = DhcpdStatValue{}

type DhcpdStatValue struct {
	NumIps    basetypes.Int64Value `tfsdk:"num_ips"`
	NumLeased basetypes.Int64Value `tfsdk:"num_leased"`
	state     attr.ValueState
}

func (v DhcpdStatValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["num_ips"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["num_leased"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.NumIps.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["num_ips"] = val

		val, err = v.NumLeased.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["num_leased"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v DhcpdStatValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v DhcpdStatValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v DhcpdStatValue) String() string {
	return "DhcpdStatValue"
}

func (v DhcpdStatValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"num_ips":    basetypes.Int64Type{},
		"num_leased": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"num_ips":    v.NumIps,
			"num_leased": v.NumLeased,
		})

	return objVal, diags
}

func (v DhcpdStatValue) Equal(o attr.Value) bool {
	other, ok := o.(DhcpdStatValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.NumIps.Equal(other.NumIps) {
		return false
	}

	if !v.NumLeased.Equal(other.NumLeased) {
		return false
	}

	return true
}

func (v DhcpdStatValue) Type(ctx context.Context) attr.Type {
	return DhcpdStatType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v DhcpdStatValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"num_ips":    basetypes.Int64Type{},
		"num_leased": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = FwupdateType{}

type FwupdateType struct {
	basetypes.ObjectType
}

func (t FwupdateType) Equal(o attr.Type) bool {
	other, ok := o.(FwupdateType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t FwupdateType) String() string {
	return "FwupdateType"
}

func (t FwupdateType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	progressAttribute, ok := attributes["progress"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`progress is missing from object`)

		return nil, diags
	}

	progressVal, ok := progressAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`progress expected to be basetypes.Int64Value, was: %T`, progressAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return nil, diags
	}

	statusVal, ok := statusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be basetypes.StringValue, was: %T`, statusAttribute))
	}

	statusIdAttribute, ok := attributes["status_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status_id is missing from object`)

		return nil, diags
	}

	statusIdVal, ok := statusIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status_id expected to be basetypes.Int64Value, was: %T`, statusIdAttribute))
	}

	timestampAttribute, ok := attributes["timestamp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`timestamp is missing from object`)

		return nil, diags
	}

	timestampVal, ok := timestampAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`timestamp expected to be basetypes.Float64Value, was: %T`, timestampAttribute))
	}

	willRetryAttribute, ok := attributes["will_retry"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`will_retry is missing from object`)

		return nil, diags
	}

	willRetryVal, ok := willRetryAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`will_retry expected to be basetypes.BoolValue, was: %T`, willRetryAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return FwupdateValue{
		Progress:  progressVal,
		Status:    statusVal,
		StatusId:  statusIdVal,
		Timestamp: timestampVal,
		WillRetry: willRetryVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewFwupdateValueNull() FwupdateValue {
	return FwupdateValue{
		state: attr.ValueStateNull,
	}
}

func NewFwupdateValueUnknown() FwupdateValue {
	return FwupdateValue{
		state: attr.ValueStateUnknown,
	}
}

func NewFwupdateValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (FwupdateValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing FwupdateValue Attribute Value",
				"While creating a FwupdateValue value, a missing attribute value was detected. "+
					"A FwupdateValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("FwupdateValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid FwupdateValue Attribute Type",
				"While creating a FwupdateValue value, an invalid attribute value was detected. "+
					"A FwupdateValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("FwupdateValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("FwupdateValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra FwupdateValue Attribute Value",
				"While creating a FwupdateValue value, an extra attribute value was detected. "+
					"A FwupdateValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra FwupdateValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewFwupdateValueUnknown(), diags
	}

	progressAttribute, ok := attributes["progress"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`progress is missing from object`)

		return NewFwupdateValueUnknown(), diags
	}

	progressVal, ok := progressAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`progress expected to be basetypes.Int64Value, was: %T`, progressAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return NewFwupdateValueUnknown(), diags
	}

	statusVal, ok := statusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be basetypes.StringValue, was: %T`, statusAttribute))
	}

	statusIdAttribute, ok := attributes["status_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status_id is missing from object`)

		return NewFwupdateValueUnknown(), diags
	}

	statusIdVal, ok := statusIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status_id expected to be basetypes.Int64Value, was: %T`, statusIdAttribute))
	}

	timestampAttribute, ok := attributes["timestamp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`timestamp is missing from object`)

		return NewFwupdateValueUnknown(), diags
	}

	timestampVal, ok := timestampAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`timestamp expected to be basetypes.Float64Value, was: %T`, timestampAttribute))
	}

	willRetryAttribute, ok := attributes["will_retry"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`will_retry is missing from object`)

		return NewFwupdateValueUnknown(), diags
	}

	willRetryVal, ok := willRetryAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`will_retry expected to be basetypes.BoolValue, was: %T`, willRetryAttribute))
	}

	if diags.HasError() {
		return NewFwupdateValueUnknown(), diags
	}

	return FwupdateValue{
		Progress:  progressVal,
		Status:    statusVal,
		StatusId:  statusIdVal,
		Timestamp: timestampVal,
		WillRetry: willRetryVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewFwupdateValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) FwupdateValue {
	object, diags := NewFwupdateValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewFwupdateValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t FwupdateType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewFwupdateValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewFwupdateValueUnknown(), nil
	}

	if in.IsNull() {
		return NewFwupdateValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewFwupdateValueMust(FwupdateValue{}.AttributeTypes(ctx), attributes), nil
}

func (t FwupdateType) ValueType(ctx context.Context) attr.Value {
	return FwupdateValue{}
}

var _ basetypes.ObjectValuable = FwupdateValue{}

type FwupdateValue struct {
	Progress  basetypes.Int64Value   `tfsdk:"progress"`
	Status    basetypes.StringValue  `tfsdk:"status"`
	StatusId  basetypes.Int64Value   `tfsdk:"status_id"`
	Timestamp basetypes.Float64Value `tfsdk:"timestamp"`
	WillRetry basetypes.BoolValue    `tfsdk:"will_retry"`
	state     attr.ValueState
}

func (v FwupdateValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["progress"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["status"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["status_id"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["timestamp"] = basetypes.Float64Type{}.TerraformType(ctx)
	attrTypes["will_retry"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.Progress.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["progress"] = val

		val, err = v.Status.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["status"] = val

		val, err = v.StatusId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["status_id"] = val

		val, err = v.Timestamp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["timestamp"] = val

		val, err = v.WillRetry.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["will_retry"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v FwupdateValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v FwupdateValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v FwupdateValue) String() string {
	return "FwupdateValue"
}

func (v FwupdateValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"progress":   basetypes.Int64Type{},
		"status":     basetypes.StringType{},
		"status_id":  basetypes.Int64Type{},
		"timestamp":  basetypes.Float64Type{},
		"will_retry": basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"progress":   v.Progress,
			"status":     v.Status,
			"status_id":  v.StatusId,
			"timestamp":  v.Timestamp,
			"will_retry": v.WillRetry,
		})

	return objVal, diags
}

func (v FwupdateValue) Equal(o attr.Value) bool {
	other, ok := o.(FwupdateValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Progress.Equal(other.Progress) {
		return false
	}

	if !v.Status.Equal(other.Status) {
		return false
	}

	if !v.StatusId.Equal(other.StatusId) {
		return false
	}

	if !v.Timestamp.Equal(other.Timestamp) {
		return false
	}

	if !v.WillRetry.Equal(other.WillRetry) {
		return false
	}

	return true
}

func (v FwupdateValue) Type(ctx context.Context) attr.Type {
	return FwupdateType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v FwupdateValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"progress":   basetypes.Int64Type{},
		"status":     basetypes.StringType{},
		"status_id":  basetypes.Int64Type{},
		"timestamp":  basetypes.Float64Type{},
		"will_retry": basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = IfStatType{}

type IfStatType struct {
	basetypes.ObjectType
}

func (t IfStatType) Equal(o attr.Type) bool {
	other, ok := o.(IfStatType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t IfStatType) String() string {
	return "IfStatType"
}

func (t IfStatType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	addressModeAttribute, ok := attributes["address_mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`address_mode is missing from object`)

		return nil, diags
	}

	addressModeVal, ok := addressModeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`address_mode expected to be basetypes.StringValue, was: %T`, addressModeAttribute))
	}

	ipsAttribute, ok := attributes["ips"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ips is missing from object`)

		return nil, diags
	}

	ipsVal, ok := ipsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ips expected to be basetypes.ListValue, was: %T`, ipsAttribute))
	}

	natAddressesAttribute, ok := attributes["nat_addresses"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`nat_addresses is missing from object`)

		return nil, diags
	}

	natAddressesVal, ok := natAddressesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`nat_addresses expected to be basetypes.ListValue, was: %T`, natAddressesAttribute))
	}

	networkNameAttribute, ok := attributes["network_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`network_name is missing from object`)

		return nil, diags
	}

	networkNameVal, ok := networkNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`network_name expected to be basetypes.StringValue, was: %T`, networkNameAttribute))
	}

	portIdAttribute, ok := attributes["port_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_id is missing from object`)

		return nil, diags
	}

	portIdVal, ok := portIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_id expected to be basetypes.StringValue, was: %T`, portIdAttribute))
	}

	portUsageAttribute, ok := attributes["port_usage"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_usage is missing from object`)

		return nil, diags
	}

	portUsageVal, ok := portUsageAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_usage expected to be basetypes.StringValue, was: %T`, portUsageAttribute))
	}

	redundancyStateAttribute, ok := attributes["redundancy_state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`redundancy_state is missing from object`)

		return nil, diags
	}

	redundancyStateVal, ok := redundancyStateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`redundancy_state expected to be basetypes.StringValue, was: %T`, redundancyStateAttribute))
	}

	rxBytesAttribute, ok := attributes["rx_bytes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rx_bytes is missing from object`)

		return nil, diags
	}

	rxBytesVal, ok := rxBytesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rx_bytes expected to be basetypes.Int64Value, was: %T`, rxBytesAttribute))
	}

	rxPktsAttribute, ok := attributes["rx_pkts"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rx_pkts is missing from object`)

		return nil, diags
	}

	rxPktsVal, ok := rxPktsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rx_pkts expected to be basetypes.Int64Value, was: %T`, rxPktsAttribute))
	}

	servpInfoAttribute, ok := attributes["servp_info"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`servp_info is missing from object`)

		return nil, diags
	}

	servpInfoVal, ok := servpInfoAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`servp_info expected to be basetypes.ObjectValue, was: %T`, servpInfoAttribute))
	}

	txBytesAttribute, ok := attributes["tx_bytes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tx_bytes is missing from object`)

		return nil, diags
	}

	txBytesVal, ok := txBytesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tx_bytes expected to be basetypes.Int64Value, was: %T`, txBytesAttribute))
	}

	txPktsAttribute, ok := attributes["tx_pkts"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tx_pkts is missing from object`)

		return nil, diags
	}

	txPktsVal, ok := txPktsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tx_pkts expected to be basetypes.Int64Value, was: %T`, txPktsAttribute))
	}

	upAttribute, ok := attributes["up"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`up is missing from object`)

		return nil, diags
	}

	upVal, ok := upAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`up expected to be basetypes.BoolValue, was: %T`, upAttribute))
	}

	vlanAttribute, ok := attributes["vlan"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan is missing from object`)

		return nil, diags
	}

	vlanVal, ok := vlanAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan expected to be basetypes.Int64Value, was: %T`, vlanAttribute))
	}

	wanNameAttribute, ok := attributes["wan_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wan_name is missing from object`)

		return nil, diags
	}

	wanNameVal, ok := wanNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wan_name expected to be basetypes.StringValue, was: %T`, wanNameAttribute))
	}

	wanTypeAttribute, ok := attributes["wan_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wan_type is missing from object`)

		return nil, diags
	}

	wanTypeVal, ok := wanTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wan_type expected to be basetypes.StringValue, was: %T`, wanTypeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return IfStatValue{
		AddressMode:     addressModeVal,
		Ips:             ipsVal,
		NatAddresses:    natAddressesVal,
		NetworkName:     networkNameVal,
		PortId:          portIdVal,
		PortUsage:       portUsageVal,
		RedundancyState: redundancyStateVal,
		RxBytes:         rxBytesVal,
		RxPkts:          rxPktsVal,
		ServpInfo:       servpInfoVal,
		TxBytes:         txBytesVal,
		TxPkts:          txPktsVal,
		Up:              upVal,
		Vlan:            vlanVal,
		WanName:         wanNameVal,
		WanType:         wanTypeVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewIfStatValueNull() IfStatValue {
	return IfStatValue{
		state: attr.ValueStateNull,
	}
}

func NewIfStatValueUnknown() IfStatValue {
	return IfStatValue{
		state: attr.ValueStateUnknown,
	}
}

func NewIfStatValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (IfStatValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing IfStatValue Attribute Value",
				"While creating a IfStatValue value, a missing attribute value was detected. "+
					"A IfStatValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("IfStatValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid IfStatValue Attribute Type",
				"While creating a IfStatValue value, an invalid attribute value was detected. "+
					"A IfStatValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("IfStatValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("IfStatValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra IfStatValue Attribute Value",
				"While creating a IfStatValue value, an extra attribute value was detected. "+
					"A IfStatValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra IfStatValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewIfStatValueUnknown(), diags
	}

	addressModeAttribute, ok := attributes["address_mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`address_mode is missing from object`)

		return NewIfStatValueUnknown(), diags
	}

	addressModeVal, ok := addressModeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`address_mode expected to be basetypes.StringValue, was: %T`, addressModeAttribute))
	}

	ipsAttribute, ok := attributes["ips"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ips is missing from object`)

		return NewIfStatValueUnknown(), diags
	}

	ipsVal, ok := ipsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ips expected to be basetypes.ListValue, was: %T`, ipsAttribute))
	}

	natAddressesAttribute, ok := attributes["nat_addresses"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`nat_addresses is missing from object`)

		return NewIfStatValueUnknown(), diags
	}

	natAddressesVal, ok := natAddressesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`nat_addresses expected to be basetypes.ListValue, was: %T`, natAddressesAttribute))
	}

	networkNameAttribute, ok := attributes["network_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`network_name is missing from object`)

		return NewIfStatValueUnknown(), diags
	}

	networkNameVal, ok := networkNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`network_name expected to be basetypes.StringValue, was: %T`, networkNameAttribute))
	}

	portIdAttribute, ok := attributes["port_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_id is missing from object`)

		return NewIfStatValueUnknown(), diags
	}

	portIdVal, ok := portIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_id expected to be basetypes.StringValue, was: %T`, portIdAttribute))
	}

	portUsageAttribute, ok := attributes["port_usage"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_usage is missing from object`)

		return NewIfStatValueUnknown(), diags
	}

	portUsageVal, ok := portUsageAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_usage expected to be basetypes.StringValue, was: %T`, portUsageAttribute))
	}

	redundancyStateAttribute, ok := attributes["redundancy_state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`redundancy_state is missing from object`)

		return NewIfStatValueUnknown(), diags
	}

	redundancyStateVal, ok := redundancyStateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`redundancy_state expected to be basetypes.StringValue, was: %T`, redundancyStateAttribute))
	}

	rxBytesAttribute, ok := attributes["rx_bytes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rx_bytes is missing from object`)

		return NewIfStatValueUnknown(), diags
	}

	rxBytesVal, ok := rxBytesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rx_bytes expected to be basetypes.Int64Value, was: %T`, rxBytesAttribute))
	}

	rxPktsAttribute, ok := attributes["rx_pkts"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rx_pkts is missing from object`)

		return NewIfStatValueUnknown(), diags
	}

	rxPktsVal, ok := rxPktsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rx_pkts expected to be basetypes.Int64Value, was: %T`, rxPktsAttribute))
	}

	servpInfoAttribute, ok := attributes["servp_info"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`servp_info is missing from object`)

		return NewIfStatValueUnknown(), diags
	}

	servpInfoVal, ok := servpInfoAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`servp_info expected to be basetypes.ObjectValue, was: %T`, servpInfoAttribute))
	}

	txBytesAttribute, ok := attributes["tx_bytes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tx_bytes is missing from object`)

		return NewIfStatValueUnknown(), diags
	}

	txBytesVal, ok := txBytesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tx_bytes expected to be basetypes.Int64Value, was: %T`, txBytesAttribute))
	}

	txPktsAttribute, ok := attributes["tx_pkts"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tx_pkts is missing from object`)

		return NewIfStatValueUnknown(), diags
	}

	txPktsVal, ok := txPktsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tx_pkts expected to be basetypes.Int64Value, was: %T`, txPktsAttribute))
	}

	upAttribute, ok := attributes["up"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`up is missing from object`)

		return NewIfStatValueUnknown(), diags
	}

	upVal, ok := upAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`up expected to be basetypes.BoolValue, was: %T`, upAttribute))
	}

	vlanAttribute, ok := attributes["vlan"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan is missing from object`)

		return NewIfStatValueUnknown(), diags
	}

	vlanVal, ok := vlanAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan expected to be basetypes.Int64Value, was: %T`, vlanAttribute))
	}

	wanNameAttribute, ok := attributes["wan_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wan_name is missing from object`)

		return NewIfStatValueUnknown(), diags
	}

	wanNameVal, ok := wanNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wan_name expected to be basetypes.StringValue, was: %T`, wanNameAttribute))
	}

	wanTypeAttribute, ok := attributes["wan_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wan_type is missing from object`)

		return NewIfStatValueUnknown(), diags
	}

	wanTypeVal, ok := wanTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wan_type expected to be basetypes.StringValue, was: %T`, wanTypeAttribute))
	}

	if diags.HasError() {
		return NewIfStatValueUnknown(), diags
	}

	return IfStatValue{
		AddressMode:     addressModeVal,
		Ips:             ipsVal,
		NatAddresses:    natAddressesVal,
		NetworkName:     networkNameVal,
		PortId:          portIdVal,
		PortUsage:       portUsageVal,
		RedundancyState: redundancyStateVal,
		RxBytes:         rxBytesVal,
		RxPkts:          rxPktsVal,
		ServpInfo:       servpInfoVal,
		TxBytes:         txBytesVal,
		TxPkts:          txPktsVal,
		Up:              upVal,
		Vlan:            vlanVal,
		WanName:         wanNameVal,
		WanType:         wanTypeVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewIfStatValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) IfStatValue {
	object, diags := NewIfStatValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewIfStatValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t IfStatType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewIfStatValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewIfStatValueUnknown(), nil
	}

	if in.IsNull() {
		return NewIfStatValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewIfStatValueMust(IfStatValue{}.AttributeTypes(ctx), attributes), nil
}

func (t IfStatType) ValueType(ctx context.Context) attr.Value {
	return IfStatValue{}
}

var _ basetypes.ObjectValuable = IfStatValue{}

type IfStatValue struct {
	AddressMode     basetypes.StringValue `tfsdk:"address_mode"`
	Ips             basetypes.ListValue   `tfsdk:"ips"`
	NatAddresses    basetypes.ListValue   `tfsdk:"nat_addresses"`
	NetworkName     basetypes.StringValue `tfsdk:"network_name"`
	PortId          basetypes.StringValue `tfsdk:"port_id"`
	PortUsage       basetypes.StringValue `tfsdk:"port_usage"`
	RedundancyState basetypes.StringValue `tfsdk:"redundancy_state"`
	RxBytes         basetypes.Int64Value  `tfsdk:"rx_bytes"`
	RxPkts          basetypes.Int64Value  `tfsdk:"rx_pkts"`
	ServpInfo       basetypes.ObjectValue `tfsdk:"servp_info"`
	TxBytes         basetypes.Int64Value  `tfsdk:"tx_bytes"`
	TxPkts          basetypes.Int64Value  `tfsdk:"tx_pkts"`
	Up              basetypes.BoolValue   `tfsdk:"up"`
	Vlan            basetypes.Int64Value  `tfsdk:"vlan"`
	WanName         basetypes.StringValue `tfsdk:"wan_name"`
	WanType         basetypes.StringValue `tfsdk:"wan_type"`
	state           attr.ValueState
}

func (v IfStatValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 16)

	var val tftypes.Value
	var err error

	attrTypes["address_mode"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ips"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["nat_addresses"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["network_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["port_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["port_usage"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["redundancy_state"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["rx_bytes"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["rx_pkts"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["servp_info"] = basetypes.ObjectType{
		AttrTypes: ServpInfoValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["tx_bytes"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["tx_pkts"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["up"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["vlan"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["wan_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["wan_type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 16)

		val, err = v.AddressMode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["address_mode"] = val

		val, err = v.Ips.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ips"] = val

		val, err = v.NatAddresses.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["nat_addresses"] = val

		val, err = v.NetworkName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["network_name"] = val

		val, err = v.PortId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port_id"] = val

		val, err = v.PortUsage.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port_usage"] = val

		val, err = v.RedundancyState.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["redundancy_state"] = val

		val, err = v.RxBytes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["rx_bytes"] = val

		val, err = v.RxPkts.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["rx_pkts"] = val

		val, err = v.ServpInfo.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["servp_info"] = val

		val, err = v.TxBytes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tx_bytes"] = val

		val, err = v.TxPkts.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tx_pkts"] = val

		val, err = v.Up.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["up"] = val

		val, err = v.Vlan.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vlan"] = val

		val, err = v.WanName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["wan_name"] = val

		val, err = v.WanType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["wan_type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v IfStatValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v IfStatValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v IfStatValue) String() string {
	return "IfStatValue"
}

func (v IfStatValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var servpInfo basetypes.ObjectValue

	if v.ServpInfo.IsNull() {
		servpInfo = types.ObjectNull(
			ServpInfoValue{}.AttributeTypes(ctx),
		)
	}

	if v.ServpInfo.IsUnknown() {
		servpInfo = types.ObjectUnknown(
			ServpInfoValue{}.AttributeTypes(ctx),
		)
	}

	if !v.ServpInfo.IsNull() && !v.ServpInfo.IsUnknown() {
		servpInfo = types.ObjectValueMust(
			ServpInfoValue{}.AttributeTypes(ctx),
			v.ServpInfo.Attributes(),
		)
	}

	ipsVal, d := types.ListValue(types.StringType, v.Ips.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"address_mode": basetypes.StringType{},
			"ips": basetypes.ListType{
				ElemType: types.StringType,
			},
			"nat_addresses": basetypes.ListType{
				ElemType: types.StringType,
			},
			"network_name":     basetypes.StringType{},
			"port_id":          basetypes.StringType{},
			"port_usage":       basetypes.StringType{},
			"redundancy_state": basetypes.StringType{},
			"rx_bytes":         basetypes.Int64Type{},
			"rx_pkts":          basetypes.Int64Type{},
			"servp_info": basetypes.ObjectType{
				AttrTypes: ServpInfoValue{}.AttributeTypes(ctx),
			},
			"tx_bytes": basetypes.Int64Type{},
			"tx_pkts":  basetypes.Int64Type{},
			"up":       basetypes.BoolType{},
			"vlan":     basetypes.Int64Type{},
			"wan_name": basetypes.StringType{},
			"wan_type": basetypes.StringType{},
		}), diags
	}

	natAddressesVal, d := types.ListValue(types.StringType, v.NatAddresses.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"address_mode": basetypes.StringType{},
			"ips": basetypes.ListType{
				ElemType: types.StringType,
			},
			"nat_addresses": basetypes.ListType{
				ElemType: types.StringType,
			},
			"network_name":     basetypes.StringType{},
			"port_id":          basetypes.StringType{},
			"port_usage":       basetypes.StringType{},
			"redundancy_state": basetypes.StringType{},
			"rx_bytes":         basetypes.Int64Type{},
			"rx_pkts":          basetypes.Int64Type{},
			"servp_info": basetypes.ObjectType{
				AttrTypes: ServpInfoValue{}.AttributeTypes(ctx),
			},
			"tx_bytes": basetypes.Int64Type{},
			"tx_pkts":  basetypes.Int64Type{},
			"up":       basetypes.BoolType{},
			"vlan":     basetypes.Int64Type{},
			"wan_name": basetypes.StringType{},
			"wan_type": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"address_mode": basetypes.StringType{},
		"ips": basetypes.ListType{
			ElemType: types.StringType,
		},
		"nat_addresses": basetypes.ListType{
			ElemType: types.StringType,
		},
		"network_name":     basetypes.StringType{},
		"port_id":          basetypes.StringType{},
		"port_usage":       basetypes.StringType{},
		"redundancy_state": basetypes.StringType{},
		"rx_bytes":         basetypes.Int64Type{},
		"rx_pkts":          basetypes.Int64Type{},
		"servp_info": basetypes.ObjectType{
			AttrTypes: ServpInfoValue{}.AttributeTypes(ctx),
		},
		"tx_bytes": basetypes.Int64Type{},
		"tx_pkts":  basetypes.Int64Type{},
		"up":       basetypes.BoolType{},
		"vlan":     basetypes.Int64Type{},
		"wan_name": basetypes.StringType{},
		"wan_type": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"address_mode":     v.AddressMode,
			"ips":              ipsVal,
			"nat_addresses":    natAddressesVal,
			"network_name":     v.NetworkName,
			"port_id":          v.PortId,
			"port_usage":       v.PortUsage,
			"redundancy_state": v.RedundancyState,
			"rx_bytes":         v.RxBytes,
			"rx_pkts":          v.RxPkts,
			"servp_info":       servpInfo,
			"tx_bytes":         v.TxBytes,
			"tx_pkts":          v.TxPkts,
			"up":               v.Up,
			"vlan":             v.Vlan,
			"wan_name":         v.WanName,
			"wan_type":         v.WanType,
		})

	return objVal, diags
}

func (v IfStatValue) Equal(o attr.Value) bool {
	other, ok := o.(IfStatValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AddressMode.Equal(other.AddressMode) {
		return false
	}

	if !v.Ips.Equal(other.Ips) {
		return false
	}

	if !v.NatAddresses.Equal(other.NatAddresses) {
		return false
	}

	if !v.NetworkName.Equal(other.NetworkName) {
		return false
	}

	if !v.PortId.Equal(other.PortId) {
		return false
	}

	if !v.PortUsage.Equal(other.PortUsage) {
		return false
	}

	if !v.RedundancyState.Equal(other.RedundancyState) {
		return false
	}

	if !v.RxBytes.Equal(other.RxBytes) {
		return false
	}

	if !v.RxPkts.Equal(other.RxPkts) {
		return false
	}

	if !v.ServpInfo.Equal(other.ServpInfo) {
		return false
	}

	if !v.TxBytes.Equal(other.TxBytes) {
		return false
	}

	if !v.TxPkts.Equal(other.TxPkts) {
		return false
	}

	if !v.Up.Equal(other.Up) {
		return false
	}

	if !v.Vlan.Equal(other.Vlan) {
		return false
	}

	if !v.WanName.Equal(other.WanName) {
		return false
	}

	if !v.WanType.Equal(other.WanType) {
		return false
	}

	return true
}

func (v IfStatValue) Type(ctx context.Context) attr.Type {
	return IfStatType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v IfStatValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"address_mode": basetypes.StringType{},
		"ips": basetypes.ListType{
			ElemType: types.StringType,
		},
		"nat_addresses": basetypes.ListType{
			ElemType: types.StringType,
		},
		"network_name":     basetypes.StringType{},
		"port_id":          basetypes.StringType{},
		"port_usage":       basetypes.StringType{},
		"redundancy_state": basetypes.StringType{},
		"rx_bytes":         basetypes.Int64Type{},
		"rx_pkts":          basetypes.Int64Type{},
		"servp_info": basetypes.ObjectType{
			AttrTypes: ServpInfoValue{}.AttributeTypes(ctx),
		},
		"tx_bytes": basetypes.Int64Type{},
		"tx_pkts":  basetypes.Int64Type{},
		"up":       basetypes.BoolType{},
		"vlan":     basetypes.Int64Type{},
		"wan_name": basetypes.StringType{},
		"wan_type": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = ServpInfoType{}

type ServpInfoType struct {
	basetypes.ObjectType
}

func (t ServpInfoType) Equal(o attr.Type) bool {
	other, ok := o.(ServpInfoType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ServpInfoType) String() string {
	return "ServpInfoType"
}

func (t ServpInfoType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	asnAttribute, ok := attributes["asn"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`asn is missing from object`)

		return nil, diags
	}

	asnVal, ok := asnAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`asn expected to be basetypes.StringValue, was: %T`, asnAttribute))
	}

	cityAttribute, ok := attributes["city"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`city is missing from object`)

		return nil, diags
	}

	cityVal, ok := cityAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`city expected to be basetypes.StringValue, was: %T`, cityAttribute))
	}

	countryCodeAttribute, ok := attributes["country_code"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`country_code is missing from object`)

		return nil, diags
	}

	countryCodeVal, ok := countryCodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`country_code expected to be basetypes.StringValue, was: %T`, countryCodeAttribute))
	}

	latitudeAttribute, ok := attributes["latitude"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`latitude is missing from object`)

		return nil, diags
	}

	latitudeVal, ok := latitudeAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`latitude expected to be basetypes.NumberValue, was: %T`, latitudeAttribute))
	}

	longitudeAttribute, ok := attributes["longitude"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`longitude is missing from object`)

		return nil, diags
	}

	longitudeVal, ok := longitudeAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`longitude expected to be basetypes.NumberValue, was: %T`, longitudeAttribute))
	}

	orgAttribute, ok := attributes["org"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`org is missing from object`)

		return nil, diags
	}

	orgVal, ok := orgAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`org expected to be basetypes.StringValue, was: %T`, orgAttribute))
	}

	regionCodeAttribute, ok := attributes["region_code"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`region_code is missing from object`)

		return nil, diags
	}

	regionCodeVal, ok := regionCodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`region_code expected to be basetypes.StringValue, was: %T`, regionCodeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ServpInfoValue{
		Asn:         asnVal,
		City:        cityVal,
		CountryCode: countryCodeVal,
		Latitude:    latitudeVal,
		Longitude:   longitudeVal,
		Org:         orgVal,
		RegionCode:  regionCodeVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewServpInfoValueNull() ServpInfoValue {
	return ServpInfoValue{
		state: attr.ValueStateNull,
	}
}

func NewServpInfoValueUnknown() ServpInfoValue {
	return ServpInfoValue{
		state: attr.ValueStateUnknown,
	}
}

func NewServpInfoValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ServpInfoValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ServpInfoValue Attribute Value",
				"While creating a ServpInfoValue value, a missing attribute value was detected. "+
					"A ServpInfoValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ServpInfoValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ServpInfoValue Attribute Type",
				"While creating a ServpInfoValue value, an invalid attribute value was detected. "+
					"A ServpInfoValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ServpInfoValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ServpInfoValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ServpInfoValue Attribute Value",
				"While creating a ServpInfoValue value, an extra attribute value was detected. "+
					"A ServpInfoValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ServpInfoValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewServpInfoValueUnknown(), diags
	}

	asnAttribute, ok := attributes["asn"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`asn is missing from object`)

		return NewServpInfoValueUnknown(), diags
	}

	asnVal, ok := asnAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`asn expected to be basetypes.StringValue, was: %T`, asnAttribute))
	}

	cityAttribute, ok := attributes["city"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`city is missing from object`)

		return NewServpInfoValueUnknown(), diags
	}

	cityVal, ok := cityAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`city expected to be basetypes.StringValue, was: %T`, cityAttribute))
	}

	countryCodeAttribute, ok := attributes["country_code"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`country_code is missing from object`)

		return NewServpInfoValueUnknown(), diags
	}

	countryCodeVal, ok := countryCodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`country_code expected to be basetypes.StringValue, was: %T`, countryCodeAttribute))
	}

	latitudeAttribute, ok := attributes["latitude"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`latitude is missing from object`)

		return NewServpInfoValueUnknown(), diags
	}

	latitudeVal, ok := latitudeAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`latitude expected to be basetypes.NumberValue, was: %T`, latitudeAttribute))
	}

	longitudeAttribute, ok := attributes["longitude"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`longitude is missing from object`)

		return NewServpInfoValueUnknown(), diags
	}

	longitudeVal, ok := longitudeAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`longitude expected to be basetypes.NumberValue, was: %T`, longitudeAttribute))
	}

	orgAttribute, ok := attributes["org"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`org is missing from object`)

		return NewServpInfoValueUnknown(), diags
	}

	orgVal, ok := orgAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`org expected to be basetypes.StringValue, was: %T`, orgAttribute))
	}

	regionCodeAttribute, ok := attributes["region_code"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`region_code is missing from object`)

		return NewServpInfoValueUnknown(), diags
	}

	regionCodeVal, ok := regionCodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`region_code expected to be basetypes.StringValue, was: %T`, regionCodeAttribute))
	}

	if diags.HasError() {
		return NewServpInfoValueUnknown(), diags
	}

	return ServpInfoValue{
		Asn:         asnVal,
		City:        cityVal,
		CountryCode: countryCodeVal,
		Latitude:    latitudeVal,
		Longitude:   longitudeVal,
		Org:         orgVal,
		RegionCode:  regionCodeVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewServpInfoValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ServpInfoValue {
	object, diags := NewServpInfoValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewServpInfoValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ServpInfoType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewServpInfoValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewServpInfoValueUnknown(), nil
	}

	if in.IsNull() {
		return NewServpInfoValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewServpInfoValueMust(ServpInfoValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ServpInfoType) ValueType(ctx context.Context) attr.Value {
	return ServpInfoValue{}
}

var _ basetypes.ObjectValuable = ServpInfoValue{}

type ServpInfoValue struct {
	Asn         basetypes.StringValue `tfsdk:"asn"`
	City        basetypes.StringValue `tfsdk:"city"`
	CountryCode basetypes.StringValue `tfsdk:"country_code"`
	Latitude    basetypes.NumberValue `tfsdk:"latitude"`
	Longitude   basetypes.NumberValue `tfsdk:"longitude"`
	Org         basetypes.StringValue `tfsdk:"org"`
	RegionCode  basetypes.StringValue `tfsdk:"region_code"`
	state       attr.ValueState
}

func (v ServpInfoValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 7)

	var val tftypes.Value
	var err error

	attrTypes["asn"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["city"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["country_code"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["latitude"] = basetypes.NumberType{}.TerraformType(ctx)
	attrTypes["longitude"] = basetypes.NumberType{}.TerraformType(ctx)
	attrTypes["org"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["region_code"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 7)

		val, err = v.Asn.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["asn"] = val

		val, err = v.City.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["city"] = val

		val, err = v.CountryCode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["country_code"] = val

		val, err = v.Latitude.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["latitude"] = val

		val, err = v.Longitude.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["longitude"] = val

		val, err = v.Org.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["org"] = val

		val, err = v.RegionCode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["region_code"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ServpInfoValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ServpInfoValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ServpInfoValue) String() string {
	return "ServpInfoValue"
}

func (v ServpInfoValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"asn":          basetypes.StringType{},
		"city":         basetypes.StringType{},
		"country_code": basetypes.StringType{},
		"latitude":     basetypes.NumberType{},
		"longitude":    basetypes.NumberType{},
		"org":          basetypes.StringType{},
		"region_code":  basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"asn":          v.Asn,
			"city":         v.City,
			"country_code": v.CountryCode,
			"latitude":     v.Latitude,
			"longitude":    v.Longitude,
			"org":          v.Org,
			"region_code":  v.RegionCode,
		})

	return objVal, diags
}

func (v ServpInfoValue) Equal(o attr.Value) bool {
	other, ok := o.(ServpInfoValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Asn.Equal(other.Asn) {
		return false
	}

	if !v.City.Equal(other.City) {
		return false
	}

	if !v.CountryCode.Equal(other.CountryCode) {
		return false
	}

	if !v.Latitude.Equal(other.Latitude) {
		return false
	}

	if !v.Longitude.Equal(other.Longitude) {
		return false
	}

	if !v.Org.Equal(other.Org) {
		return false
	}

	if !v.RegionCode.Equal(other.RegionCode) {
		return false
	}

	return true
}

func (v ServpInfoValue) Type(ctx context.Context) attr.Type {
	return ServpInfoType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ServpInfoValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"asn":          basetypes.StringType{},
		"city":         basetypes.StringType{},
		"country_code": basetypes.StringType{},
		"latitude":     basetypes.NumberType{},
		"longitude":    basetypes.NumberType{},
		"org":          basetypes.StringType{},
		"region_code":  basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = IpStatType{}

type IpStatType struct {
	basetypes.ObjectType
}

func (t IpStatType) Equal(o attr.Type) bool {
	other, ok := o.(IpStatType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t IpStatType) String() string {
	return "IpStatType"
}

func (t IpStatType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	dhcpServerAttribute, ok := attributes["dhcp_server"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dhcp_server is missing from object`)

		return nil, diags
	}

	dhcpServerVal, ok := dhcpServerAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dhcp_server expected to be basetypes.StringValue, was: %T`, dhcpServerAttribute))
	}

	dnsAttribute, ok := attributes["dns"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dns is missing from object`)

		return nil, diags
	}

	dnsVal, ok := dnsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dns expected to be basetypes.ListValue, was: %T`, dnsAttribute))
	}

	dnsSuffixAttribute, ok := attributes["dns_suffix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dns_suffix is missing from object`)

		return nil, diags
	}

	dnsSuffixVal, ok := dnsSuffixAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dns_suffix expected to be basetypes.ListValue, was: %T`, dnsSuffixAttribute))
	}

	gatewayAttribute, ok := attributes["gateway"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gateway is missing from object`)

		return nil, diags
	}

	gatewayVal, ok := gatewayAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gateway expected to be basetypes.StringValue, was: %T`, gatewayAttribute))
	}

	gateway6Attribute, ok := attributes["gateway6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gateway6 is missing from object`)

		return nil, diags
	}

	gateway6Val, ok := gateway6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gateway6 expected to be basetypes.StringValue, was: %T`, gateway6Attribute))
	}

	ipAttribute, ok := attributes["ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip is missing from object`)

		return nil, diags
	}

	ipVal, ok := ipAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip expected to be basetypes.StringValue, was: %T`, ipAttribute))
	}

	ip6Attribute, ok := attributes["ip6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip6 is missing from object`)

		return nil, diags
	}

	ip6Val, ok := ip6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip6 expected to be basetypes.StringValue, was: %T`, ip6Attribute))
	}

	ipsAttribute, ok := attributes["ips"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ips is missing from object`)

		return nil, diags
	}

	ipsVal, ok := ipsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ips expected to be basetypes.MapValue, was: %T`, ipsAttribute))
	}

	netmaskAttribute, ok := attributes["netmask"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`netmask is missing from object`)

		return nil, diags
	}

	netmaskVal, ok := netmaskAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`netmask expected to be basetypes.StringValue, was: %T`, netmaskAttribute))
	}

	netmask6Attribute, ok := attributes["netmask6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`netmask6 is missing from object`)

		return nil, diags
	}

	netmask6Val, ok := netmask6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`netmask6 expected to be basetypes.StringValue, was: %T`, netmask6Attribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return IpStatValue{
		DhcpServer: dhcpServerVal,
		Dns:        dnsVal,
		DnsSuffix:  dnsSuffixVal,
		Gateway:    gatewayVal,
		Gateway6:   gateway6Val,
		Ip:         ipVal,
		Ip6:        ip6Val,
		Ips:        ipsVal,
		Netmask:    netmaskVal,
		Netmask6:   netmask6Val,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewIpStatValueNull() IpStatValue {
	return IpStatValue{
		state: attr.ValueStateNull,
	}
}

func NewIpStatValueUnknown() IpStatValue {
	return IpStatValue{
		state: attr.ValueStateUnknown,
	}
}

func NewIpStatValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (IpStatValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing IpStatValue Attribute Value",
				"While creating a IpStatValue value, a missing attribute value was detected. "+
					"A IpStatValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("IpStatValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid IpStatValue Attribute Type",
				"While creating a IpStatValue value, an invalid attribute value was detected. "+
					"A IpStatValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("IpStatValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("IpStatValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra IpStatValue Attribute Value",
				"While creating a IpStatValue value, an extra attribute value was detected. "+
					"A IpStatValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra IpStatValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewIpStatValueUnknown(), diags
	}

	dhcpServerAttribute, ok := attributes["dhcp_server"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dhcp_server is missing from object`)

		return NewIpStatValueUnknown(), diags
	}

	dhcpServerVal, ok := dhcpServerAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dhcp_server expected to be basetypes.StringValue, was: %T`, dhcpServerAttribute))
	}

	dnsAttribute, ok := attributes["dns"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dns is missing from object`)

		return NewIpStatValueUnknown(), diags
	}

	dnsVal, ok := dnsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dns expected to be basetypes.ListValue, was: %T`, dnsAttribute))
	}

	dnsSuffixAttribute, ok := attributes["dns_suffix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dns_suffix is missing from object`)

		return NewIpStatValueUnknown(), diags
	}

	dnsSuffixVal, ok := dnsSuffixAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dns_suffix expected to be basetypes.ListValue, was: %T`, dnsSuffixAttribute))
	}

	gatewayAttribute, ok := attributes["gateway"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gateway is missing from object`)

		return NewIpStatValueUnknown(), diags
	}

	gatewayVal, ok := gatewayAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gateway expected to be basetypes.StringValue, was: %T`, gatewayAttribute))
	}

	gateway6Attribute, ok := attributes["gateway6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gateway6 is missing from object`)

		return NewIpStatValueUnknown(), diags
	}

	gateway6Val, ok := gateway6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gateway6 expected to be basetypes.StringValue, was: %T`, gateway6Attribute))
	}

	ipAttribute, ok := attributes["ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip is missing from object`)

		return NewIpStatValueUnknown(), diags
	}

	ipVal, ok := ipAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip expected to be basetypes.StringValue, was: %T`, ipAttribute))
	}

	ip6Attribute, ok := attributes["ip6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip6 is missing from object`)

		return NewIpStatValueUnknown(), diags
	}

	ip6Val, ok := ip6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip6 expected to be basetypes.StringValue, was: %T`, ip6Attribute))
	}

	ipsAttribute, ok := attributes["ips"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ips is missing from object`)

		return NewIpStatValueUnknown(), diags
	}

	ipsVal, ok := ipsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ips expected to be basetypes.MapValue, was: %T`, ipsAttribute))
	}

	netmaskAttribute, ok := attributes["netmask"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`netmask is missing from object`)

		return NewIpStatValueUnknown(), diags
	}

	netmaskVal, ok := netmaskAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`netmask expected to be basetypes.StringValue, was: %T`, netmaskAttribute))
	}

	netmask6Attribute, ok := attributes["netmask6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`netmask6 is missing from object`)

		return NewIpStatValueUnknown(), diags
	}

	netmask6Val, ok := netmask6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`netmask6 expected to be basetypes.StringValue, was: %T`, netmask6Attribute))
	}

	if diags.HasError() {
		return NewIpStatValueUnknown(), diags
	}

	return IpStatValue{
		DhcpServer: dhcpServerVal,
		Dns:        dnsVal,
		DnsSuffix:  dnsSuffixVal,
		Gateway:    gatewayVal,
		Gateway6:   gateway6Val,
		Ip:         ipVal,
		Ip6:        ip6Val,
		Ips:        ipsVal,
		Netmask:    netmaskVal,
		Netmask6:   netmask6Val,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewIpStatValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) IpStatValue {
	object, diags := NewIpStatValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewIpStatValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t IpStatType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewIpStatValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewIpStatValueUnknown(), nil
	}

	if in.IsNull() {
		return NewIpStatValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewIpStatValueMust(IpStatValue{}.AttributeTypes(ctx), attributes), nil
}

func (t IpStatType) ValueType(ctx context.Context) attr.Value {
	return IpStatValue{}
}

var _ basetypes.ObjectValuable = IpStatValue{}

type IpStatValue struct {
	DhcpServer basetypes.StringValue `tfsdk:"dhcp_server"`
	Dns        basetypes.ListValue   `tfsdk:"dns"`
	DnsSuffix  basetypes.ListValue   `tfsdk:"dns_suffix"`
	Gateway    basetypes.StringValue `tfsdk:"gateway"`
	Gateway6   basetypes.StringValue `tfsdk:"gateway6"`
	Ip         basetypes.StringValue `tfsdk:"ip"`
	Ip6        basetypes.StringValue `tfsdk:"ip6"`
	Ips        basetypes.MapValue    `tfsdk:"ips"`
	Netmask    basetypes.StringValue `tfsdk:"netmask"`
	Netmask6   basetypes.StringValue `tfsdk:"netmask6"`
	state      attr.ValueState
}

func (v IpStatValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 10)

	var val tftypes.Value
	var err error

	attrTypes["dhcp_server"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["dns"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["dns_suffix"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["gateway"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["gateway6"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ip"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ip6"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ips"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["netmask"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["netmask6"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 10)

		val, err = v.DhcpServer.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dhcp_server"] = val

		val, err = v.Dns.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dns"] = val

		val, err = v.DnsSuffix.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dns_suffix"] = val

		val, err = v.Gateway.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["gateway"] = val

		val, err = v.Gateway6.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["gateway6"] = val

		val, err = v.Ip.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip"] = val

		val, err = v.Ip6.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip6"] = val

		val, err = v.Ips.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ips"] = val

		val, err = v.Netmask.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["netmask"] = val

		val, err = v.Netmask6.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["netmask6"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v IpStatValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v IpStatValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v IpStatValue) String() string {
	return "IpStatValue"
}

func (v IpStatValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	dnsVal, d := types.ListValue(types.StringType, v.Dns.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"dhcp_server": basetypes.StringType{},
			"dns": basetypes.ListType{
				ElemType: types.StringType,
			},
			"dns_suffix": basetypes.ListType{
				ElemType: types.StringType,
			},
			"gateway":  basetypes.StringType{},
			"gateway6": basetypes.StringType{},
			"ip":       basetypes.StringType{},
			"ip6":      basetypes.StringType{},
			"ips": basetypes.MapType{
				ElemType: types.StringType,
			},
			"netmask":  basetypes.StringType{},
			"netmask6": basetypes.StringType{},
		}), diags
	}

	dnsSuffixVal, d := types.ListValue(types.StringType, v.DnsSuffix.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"dhcp_server": basetypes.StringType{},
			"dns": basetypes.ListType{
				ElemType: types.StringType,
			},
			"dns_suffix": basetypes.ListType{
				ElemType: types.StringType,
			},
			"gateway":  basetypes.StringType{},
			"gateway6": basetypes.StringType{},
			"ip":       basetypes.StringType{},
			"ip6":      basetypes.StringType{},
			"ips": basetypes.MapType{
				ElemType: types.StringType,
			},
			"netmask":  basetypes.StringType{},
			"netmask6": basetypes.StringType{},
		}), diags
	}

	ipsVal, d := types.MapValue(types.StringType, v.Ips.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"dhcp_server": basetypes.StringType{},
			"dns": basetypes.ListType{
				ElemType: types.StringType,
			},
			"dns_suffix": basetypes.ListType{
				ElemType: types.StringType,
			},
			"gateway":  basetypes.StringType{},
			"gateway6": basetypes.StringType{},
			"ip":       basetypes.StringType{},
			"ip6":      basetypes.StringType{},
			"ips": basetypes.MapType{
				ElemType: types.StringType,
			},
			"netmask":  basetypes.StringType{},
			"netmask6": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"dhcp_server": basetypes.StringType{},
		"dns": basetypes.ListType{
			ElemType: types.StringType,
		},
		"dns_suffix": basetypes.ListType{
			ElemType: types.StringType,
		},
		"gateway":  basetypes.StringType{},
		"gateway6": basetypes.StringType{},
		"ip":       basetypes.StringType{},
		"ip6":      basetypes.StringType{},
		"ips": basetypes.MapType{
			ElemType: types.StringType,
		},
		"netmask":  basetypes.StringType{},
		"netmask6": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"dhcp_server": v.DhcpServer,
			"dns":         dnsVal,
			"dns_suffix":  dnsSuffixVal,
			"gateway":     v.Gateway,
			"gateway6":    v.Gateway6,
			"ip":          v.Ip,
			"ip6":         v.Ip6,
			"ips":         ipsVal,
			"netmask":     v.Netmask,
			"netmask6":    v.Netmask6,
		})

	return objVal, diags
}

func (v IpStatValue) Equal(o attr.Value) bool {
	other, ok := o.(IpStatValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.DhcpServer.Equal(other.DhcpServer) {
		return false
	}

	if !v.Dns.Equal(other.Dns) {
		return false
	}

	if !v.DnsSuffix.Equal(other.DnsSuffix) {
		return false
	}

	if !v.Gateway.Equal(other.Gateway) {
		return false
	}

	if !v.Gateway6.Equal(other.Gateway6) {
		return false
	}

	if !v.Ip.Equal(other.Ip) {
		return false
	}

	if !v.Ip6.Equal(other.Ip6) {
		return false
	}

	if !v.Ips.Equal(other.Ips) {
		return false
	}

	if !v.Netmask.Equal(other.Netmask) {
		return false
	}

	if !v.Netmask6.Equal(other.Netmask6) {
		return false
	}

	return true
}

func (v IpStatValue) Type(ctx context.Context) attr.Type {
	return IpStatType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v IpStatValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"dhcp_server": basetypes.StringType{},
		"dns": basetypes.ListType{
			ElemType: types.StringType,
		},
		"dns_suffix": basetypes.ListType{
			ElemType: types.StringType,
		},
		"gateway":  basetypes.StringType{},
		"gateway6": basetypes.StringType{},
		"ip":       basetypes.StringType{},
		"ip6":      basetypes.StringType{},
		"ips": basetypes.MapType{
			ElemType: types.StringType,
		},
		"netmask":  basetypes.StringType{},
		"netmask6": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = MemoryStatType{}

type MemoryStatType struct {
	basetypes.ObjectType
}

func (t MemoryStatType) Equal(o attr.Type) bool {
	other, ok := o.(MemoryStatType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t MemoryStatType) String() string {
	return "MemoryStatType"
}

func (t MemoryStatType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	usageAttribute, ok := attributes["usage"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`usage is missing from object`)

		return nil, diags
	}

	usageVal, ok := usageAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`usage expected to be basetypes.NumberValue, was: %T`, usageAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return MemoryStatValue{
		Usage: usageVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewMemoryStatValueNull() MemoryStatValue {
	return MemoryStatValue{
		state: attr.ValueStateNull,
	}
}

func NewMemoryStatValueUnknown() MemoryStatValue {
	return MemoryStatValue{
		state: attr.ValueStateUnknown,
	}
}

func NewMemoryStatValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (MemoryStatValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing MemoryStatValue Attribute Value",
				"While creating a MemoryStatValue value, a missing attribute value was detected. "+
					"A MemoryStatValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MemoryStatValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid MemoryStatValue Attribute Type",
				"While creating a MemoryStatValue value, an invalid attribute value was detected. "+
					"A MemoryStatValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MemoryStatValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("MemoryStatValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra MemoryStatValue Attribute Value",
				"While creating a MemoryStatValue value, an extra attribute value was detected. "+
					"A MemoryStatValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra MemoryStatValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewMemoryStatValueUnknown(), diags
	}

	usageAttribute, ok := attributes["usage"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`usage is missing from object`)

		return NewMemoryStatValueUnknown(), diags
	}

	usageVal, ok := usageAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`usage expected to be basetypes.NumberValue, was: %T`, usageAttribute))
	}

	if diags.HasError() {
		return NewMemoryStatValueUnknown(), diags
	}

	return MemoryStatValue{
		Usage: usageVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewMemoryStatValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) MemoryStatValue {
	object, diags := NewMemoryStatValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewMemoryStatValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t MemoryStatType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewMemoryStatValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewMemoryStatValueUnknown(), nil
	}

	if in.IsNull() {
		return NewMemoryStatValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewMemoryStatValueMust(MemoryStatValue{}.AttributeTypes(ctx), attributes), nil
}

func (t MemoryStatType) ValueType(ctx context.Context) attr.Value {
	return MemoryStatValue{}
}

var _ basetypes.ObjectValuable = MemoryStatValue{}

type MemoryStatValue struct {
	Usage basetypes.NumberValue `tfsdk:"usage"`
	state attr.ValueState
}

func (v MemoryStatValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["usage"] = basetypes.NumberType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Usage.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["usage"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v MemoryStatValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v MemoryStatValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v MemoryStatValue) String() string {
	return "MemoryStatValue"
}

func (v MemoryStatValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"usage": basetypes.NumberType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"usage": v.Usage,
		})

	return objVal, diags
}

func (v MemoryStatValue) Equal(o attr.Value) bool {
	other, ok := o.(MemoryStatValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Usage.Equal(other.Usage) {
		return false
	}

	return true
}

func (v MemoryStatValue) Type(ctx context.Context) attr.Type {
	return MemoryStatType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v MemoryStatValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"usage": basetypes.NumberType{},
	}
}

var _ basetypes.ObjectTypable = ModuleStatType{}

type ModuleStatType struct {
	basetypes.ObjectType
}

func (t ModuleStatType) Equal(o attr.Type) bool {
	other, ok := o.(ModuleStatType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ModuleStatType) String() string {
	return "ModuleStatType"
}

func (t ModuleStatType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	backupVersionAttribute, ok := attributes["backup_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`backup_version is missing from object`)

		return nil, diags
	}

	backupVersionVal, ok := backupVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`backup_version expected to be basetypes.StringValue, was: %T`, backupVersionAttribute))
	}

	biosVersionAttribute, ok := attributes["bios_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bios_version is missing from object`)

		return nil, diags
	}

	biosVersionVal, ok := biosVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bios_version expected to be basetypes.StringValue, was: %T`, biosVersionAttribute))
	}

	cpldVersionAttribute, ok := attributes["cpld_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cpld_version is missing from object`)

		return nil, diags
	}

	cpldVersionVal, ok := cpldVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cpld_version expected to be basetypes.StringValue, was: %T`, cpldVersionAttribute))
	}

	fansAttribute, ok := attributes["fans"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fans is missing from object`)

		return nil, diags
	}

	fansVal, ok := fansAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fans expected to be basetypes.ListValue, was: %T`, fansAttribute))
	}

	fpgaVersionAttribute, ok := attributes["fpga_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fpga_version is missing from object`)

		return nil, diags
	}

	fpgaVersionVal, ok := fpgaVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fpga_version expected to be basetypes.StringValue, was: %T`, fpgaVersionAttribute))
	}

	lastSeenAttribute, ok := attributes["last_seen"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`last_seen is missing from object`)

		return nil, diags
	}

	lastSeenVal, ok := lastSeenAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`last_seen expected to be basetypes.Float64Value, was: %T`, lastSeenAttribute))
	}

	locatingAttribute, ok := attributes["locating"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`locating is missing from object`)

		return nil, diags
	}

	locatingVal, ok := locatingAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`locating expected to be basetypes.BoolValue, was: %T`, locatingAttribute))
	}

	macAttribute, ok := attributes["mac"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mac is missing from object`)

		return nil, diags
	}

	macVal, ok := macAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mac expected to be basetypes.StringValue, was: %T`, macAttribute))
	}

	modelAttribute, ok := attributes["model"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`model is missing from object`)

		return nil, diags
	}

	modelVal, ok := modelAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`model expected to be basetypes.StringValue, was: %T`, modelAttribute))
	}

	opticsCpldVersionAttribute, ok := attributes["optics_cpld_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`optics_cpld_version is missing from object`)

		return nil, diags
	}

	opticsCpldVersionVal, ok := opticsCpldVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`optics_cpld_version expected to be basetypes.StringValue, was: %T`, opticsCpldVersionAttribute))
	}

	pendingVersionAttribute, ok := attributes["pending_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pending_version is missing from object`)

		return nil, diags
	}

	pendingVersionVal, ok := pendingVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pending_version expected to be basetypes.StringValue, was: %T`, pendingVersionAttribute))
	}

	poeAttribute, ok := attributes["poe"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`poe is missing from object`)

		return nil, diags
	}

	poeVal, ok := poeAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`poe expected to be basetypes.ObjectValue, was: %T`, poeAttribute))
	}

	poeVersionAttribute, ok := attributes["poe_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`poe_version is missing from object`)

		return nil, diags
	}

	poeVersionVal, ok := poeVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`poe_version expected to be basetypes.StringValue, was: %T`, poeVersionAttribute))
	}

	powerCpldVersionAttribute, ok := attributes["power_cpld_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`power_cpld_version is missing from object`)

		return nil, diags
	}

	powerCpldVersionVal, ok := powerCpldVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`power_cpld_version expected to be basetypes.StringValue, was: %T`, powerCpldVersionAttribute))
	}

	psusAttribute, ok := attributes["psus"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`psus is missing from object`)

		return nil, diags
	}

	psusVal, ok := psusAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`psus expected to be basetypes.ListValue, was: %T`, psusAttribute))
	}

	reFpgaVersionAttribute, ok := attributes["re_fpga_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`re_fpga_version is missing from object`)

		return nil, diags
	}

	reFpgaVersionVal, ok := reFpgaVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`re_fpga_version expected to be basetypes.StringValue, was: %T`, reFpgaVersionAttribute))
	}

	recoveryVersionAttribute, ok := attributes["recovery_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`recovery_version is missing from object`)

		return nil, diags
	}

	recoveryVersionVal, ok := recoveryVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`recovery_version expected to be basetypes.StringValue, was: %T`, recoveryVersionAttribute))
	}

	serialAttribute, ok := attributes["serial"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`serial is missing from object`)

		return nil, diags
	}

	serialVal, ok := serialAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`serial expected to be basetypes.StringValue, was: %T`, serialAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return nil, diags
	}

	statusVal, ok := statusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be basetypes.StringValue, was: %T`, statusAttribute))
	}

	temperaturesAttribute, ok := attributes["temperatures"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`temperatures is missing from object`)

		return nil, diags
	}

	temperaturesVal, ok := temperaturesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`temperatures expected to be basetypes.ListValue, was: %T`, temperaturesAttribute))
	}

	tmcFpgaVersionAttribute, ok := attributes["tmc_fpga_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tmc_fpga_version is missing from object`)

		return nil, diags
	}

	tmcFpgaVersionVal, ok := tmcFpgaVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tmc_fpga_version expected to be basetypes.StringValue, was: %T`, tmcFpgaVersionAttribute))
	}

	ubootVersionAttribute, ok := attributes["uboot_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uboot_version is missing from object`)

		return nil, diags
	}

	ubootVersionVal, ok := ubootVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uboot_version expected to be basetypes.StringValue, was: %T`, ubootVersionAttribute))
	}

	uptimeAttribute, ok := attributes["uptime"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uptime is missing from object`)

		return nil, diags
	}

	uptimeVal, ok := uptimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uptime expected to be basetypes.Int64Value, was: %T`, uptimeAttribute))
	}

	vcLinksAttribute, ok := attributes["vc_links"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vc_links is missing from object`)

		return nil, diags
	}

	vcLinksVal, ok := vcLinksAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vc_links expected to be basetypes.ListValue, was: %T`, vcLinksAttribute))
	}

	vcModeAttribute, ok := attributes["vc_mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vc_mode is missing from object`)

		return nil, diags
	}

	vcModeVal, ok := vcModeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vc_mode expected to be basetypes.StringValue, was: %T`, vcModeAttribute))
	}

	vcRoleAttribute, ok := attributes["vc_role"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vc_role is missing from object`)

		return nil, diags
	}

	vcRoleVal, ok := vcRoleAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vc_role expected to be basetypes.StringValue, was: %T`, vcRoleAttribute))
	}

	vcStateAttribute, ok := attributes["vc_state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vc_state is missing from object`)

		return nil, diags
	}

	vcStateVal, ok := vcStateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vc_state expected to be basetypes.StringValue, was: %T`, vcStateAttribute))
	}

	versionAttribute, ok := attributes["version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`version is missing from object`)

		return nil, diags
	}

	versionVal, ok := versionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`version expected to be basetypes.StringValue, was: %T`, versionAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ModuleStatValue{
		BackupVersion:     backupVersionVal,
		BiosVersion:       biosVersionVal,
		CpldVersion:       cpldVersionVal,
		Fans:              fansVal,
		FpgaVersion:       fpgaVersionVal,
		LastSeen:          lastSeenVal,
		Locating:          locatingVal,
		Mac:               macVal,
		Model:             modelVal,
		OpticsCpldVersion: opticsCpldVersionVal,
		PendingVersion:    pendingVersionVal,
		Poe:               poeVal,
		PoeVersion:        poeVersionVal,
		PowerCpldVersion:  powerCpldVersionVal,
		Psus:              psusVal,
		ReFpgaVersion:     reFpgaVersionVal,
		RecoveryVersion:   recoveryVersionVal,
		Serial:            serialVal,
		Status:            statusVal,
		Temperatures:      temperaturesVal,
		TmcFpgaVersion:    tmcFpgaVersionVal,
		UbootVersion:      ubootVersionVal,
		Uptime:            uptimeVal,
		VcLinks:           vcLinksVal,
		VcMode:            vcModeVal,
		VcRole:            vcRoleVal,
		VcState:           vcStateVal,
		Version:           versionVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewModuleStatValueNull() ModuleStatValue {
	return ModuleStatValue{
		state: attr.ValueStateNull,
	}
}

func NewModuleStatValueUnknown() ModuleStatValue {
	return ModuleStatValue{
		state: attr.ValueStateUnknown,
	}
}

func NewModuleStatValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ModuleStatValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ModuleStatValue Attribute Value",
				"While creating a ModuleStatValue value, a missing attribute value was detected. "+
					"A ModuleStatValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ModuleStatValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ModuleStatValue Attribute Type",
				"While creating a ModuleStatValue value, an invalid attribute value was detected. "+
					"A ModuleStatValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ModuleStatValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ModuleStatValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ModuleStatValue Attribute Value",
				"While creating a ModuleStatValue value, an extra attribute value was detected. "+
					"A ModuleStatValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ModuleStatValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewModuleStatValueUnknown(), diags
	}

	backupVersionAttribute, ok := attributes["backup_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`backup_version is missing from object`)

		return NewModuleStatValueUnknown(), diags
	}

	backupVersionVal, ok := backupVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`backup_version expected to be basetypes.StringValue, was: %T`, backupVersionAttribute))
	}

	biosVersionAttribute, ok := attributes["bios_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bios_version is missing from object`)

		return NewModuleStatValueUnknown(), diags
	}

	biosVersionVal, ok := biosVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bios_version expected to be basetypes.StringValue, was: %T`, biosVersionAttribute))
	}

	cpldVersionAttribute, ok := attributes["cpld_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cpld_version is missing from object`)

		return NewModuleStatValueUnknown(), diags
	}

	cpldVersionVal, ok := cpldVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cpld_version expected to be basetypes.StringValue, was: %T`, cpldVersionAttribute))
	}

	fansAttribute, ok := attributes["fans"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fans is missing from object`)

		return NewModuleStatValueUnknown(), diags
	}

	fansVal, ok := fansAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fans expected to be basetypes.ListValue, was: %T`, fansAttribute))
	}

	fpgaVersionAttribute, ok := attributes["fpga_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fpga_version is missing from object`)

		return NewModuleStatValueUnknown(), diags
	}

	fpgaVersionVal, ok := fpgaVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fpga_version expected to be basetypes.StringValue, was: %T`, fpgaVersionAttribute))
	}

	lastSeenAttribute, ok := attributes["last_seen"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`last_seen is missing from object`)

		return NewModuleStatValueUnknown(), diags
	}

	lastSeenVal, ok := lastSeenAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`last_seen expected to be basetypes.Float64Value, was: %T`, lastSeenAttribute))
	}

	locatingAttribute, ok := attributes["locating"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`locating is missing from object`)

		return NewModuleStatValueUnknown(), diags
	}

	locatingVal, ok := locatingAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`locating expected to be basetypes.BoolValue, was: %T`, locatingAttribute))
	}

	macAttribute, ok := attributes["mac"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mac is missing from object`)

		return NewModuleStatValueUnknown(), diags
	}

	macVal, ok := macAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mac expected to be basetypes.StringValue, was: %T`, macAttribute))
	}

	modelAttribute, ok := attributes["model"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`model is missing from object`)

		return NewModuleStatValueUnknown(), diags
	}

	modelVal, ok := modelAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`model expected to be basetypes.StringValue, was: %T`, modelAttribute))
	}

	opticsCpldVersionAttribute, ok := attributes["optics_cpld_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`optics_cpld_version is missing from object`)

		return NewModuleStatValueUnknown(), diags
	}

	opticsCpldVersionVal, ok := opticsCpldVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`optics_cpld_version expected to be basetypes.StringValue, was: %T`, opticsCpldVersionAttribute))
	}

	pendingVersionAttribute, ok := attributes["pending_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pending_version is missing from object`)

		return NewModuleStatValueUnknown(), diags
	}

	pendingVersionVal, ok := pendingVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pending_version expected to be basetypes.StringValue, was: %T`, pendingVersionAttribute))
	}

	poeAttribute, ok := attributes["poe"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`poe is missing from object`)

		return NewModuleStatValueUnknown(), diags
	}

	poeVal, ok := poeAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`poe expected to be basetypes.ObjectValue, was: %T`, poeAttribute))
	}

	poeVersionAttribute, ok := attributes["poe_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`poe_version is missing from object`)

		return NewModuleStatValueUnknown(), diags
	}

	poeVersionVal, ok := poeVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`poe_version expected to be basetypes.StringValue, was: %T`, poeVersionAttribute))
	}

	powerCpldVersionAttribute, ok := attributes["power_cpld_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`power_cpld_version is missing from object`)

		return NewModuleStatValueUnknown(), diags
	}

	powerCpldVersionVal, ok := powerCpldVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`power_cpld_version expected to be basetypes.StringValue, was: %T`, powerCpldVersionAttribute))
	}

	psusAttribute, ok := attributes["psus"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`psus is missing from object`)

		return NewModuleStatValueUnknown(), diags
	}

	psusVal, ok := psusAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`psus expected to be basetypes.ListValue, was: %T`, psusAttribute))
	}

	reFpgaVersionAttribute, ok := attributes["re_fpga_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`re_fpga_version is missing from object`)

		return NewModuleStatValueUnknown(), diags
	}

	reFpgaVersionVal, ok := reFpgaVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`re_fpga_version expected to be basetypes.StringValue, was: %T`, reFpgaVersionAttribute))
	}

	recoveryVersionAttribute, ok := attributes["recovery_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`recovery_version is missing from object`)

		return NewModuleStatValueUnknown(), diags
	}

	recoveryVersionVal, ok := recoveryVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`recovery_version expected to be basetypes.StringValue, was: %T`, recoveryVersionAttribute))
	}

	serialAttribute, ok := attributes["serial"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`serial is missing from object`)

		return NewModuleStatValueUnknown(), diags
	}

	serialVal, ok := serialAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`serial expected to be basetypes.StringValue, was: %T`, serialAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return NewModuleStatValueUnknown(), diags
	}

	statusVal, ok := statusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be basetypes.StringValue, was: %T`, statusAttribute))
	}

	temperaturesAttribute, ok := attributes["temperatures"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`temperatures is missing from object`)

		return NewModuleStatValueUnknown(), diags
	}

	temperaturesVal, ok := temperaturesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`temperatures expected to be basetypes.ListValue, was: %T`, temperaturesAttribute))
	}

	tmcFpgaVersionAttribute, ok := attributes["tmc_fpga_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tmc_fpga_version is missing from object`)

		return NewModuleStatValueUnknown(), diags
	}

	tmcFpgaVersionVal, ok := tmcFpgaVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tmc_fpga_version expected to be basetypes.StringValue, was: %T`, tmcFpgaVersionAttribute))
	}

	ubootVersionAttribute, ok := attributes["uboot_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uboot_version is missing from object`)

		return NewModuleStatValueUnknown(), diags
	}

	ubootVersionVal, ok := ubootVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uboot_version expected to be basetypes.StringValue, was: %T`, ubootVersionAttribute))
	}

	uptimeAttribute, ok := attributes["uptime"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uptime is missing from object`)

		return NewModuleStatValueUnknown(), diags
	}

	uptimeVal, ok := uptimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uptime expected to be basetypes.Int64Value, was: %T`, uptimeAttribute))
	}

	vcLinksAttribute, ok := attributes["vc_links"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vc_links is missing from object`)

		return NewModuleStatValueUnknown(), diags
	}

	vcLinksVal, ok := vcLinksAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vc_links expected to be basetypes.ListValue, was: %T`, vcLinksAttribute))
	}

	vcModeAttribute, ok := attributes["vc_mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vc_mode is missing from object`)

		return NewModuleStatValueUnknown(), diags
	}

	vcModeVal, ok := vcModeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vc_mode expected to be basetypes.StringValue, was: %T`, vcModeAttribute))
	}

	vcRoleAttribute, ok := attributes["vc_role"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vc_role is missing from object`)

		return NewModuleStatValueUnknown(), diags
	}

	vcRoleVal, ok := vcRoleAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vc_role expected to be basetypes.StringValue, was: %T`, vcRoleAttribute))
	}

	vcStateAttribute, ok := attributes["vc_state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vc_state is missing from object`)

		return NewModuleStatValueUnknown(), diags
	}

	vcStateVal, ok := vcStateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vc_state expected to be basetypes.StringValue, was: %T`, vcStateAttribute))
	}

	versionAttribute, ok := attributes["version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`version is missing from object`)

		return NewModuleStatValueUnknown(), diags
	}

	versionVal, ok := versionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`version expected to be basetypes.StringValue, was: %T`, versionAttribute))
	}

	if diags.HasError() {
		return NewModuleStatValueUnknown(), diags
	}

	return ModuleStatValue{
		BackupVersion:     backupVersionVal,
		BiosVersion:       biosVersionVal,
		CpldVersion:       cpldVersionVal,
		Fans:              fansVal,
		FpgaVersion:       fpgaVersionVal,
		LastSeen:          lastSeenVal,
		Locating:          locatingVal,
		Mac:               macVal,
		Model:             modelVal,
		OpticsCpldVersion: opticsCpldVersionVal,
		PendingVersion:    pendingVersionVal,
		Poe:               poeVal,
		PoeVersion:        poeVersionVal,
		PowerCpldVersion:  powerCpldVersionVal,
		Psus:              psusVal,
		ReFpgaVersion:     reFpgaVersionVal,
		RecoveryVersion:   recoveryVersionVal,
		Serial:            serialVal,
		Status:            statusVal,
		Temperatures:      temperaturesVal,
		TmcFpgaVersion:    tmcFpgaVersionVal,
		UbootVersion:      ubootVersionVal,
		Uptime:            uptimeVal,
		VcLinks:           vcLinksVal,
		VcMode:            vcModeVal,
		VcRole:            vcRoleVal,
		VcState:           vcStateVal,
		Version:           versionVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewModuleStatValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ModuleStatValue {
	object, diags := NewModuleStatValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewModuleStatValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ModuleStatType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewModuleStatValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewModuleStatValueUnknown(), nil
	}

	if in.IsNull() {
		return NewModuleStatValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewModuleStatValueMust(ModuleStatValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ModuleStatType) ValueType(ctx context.Context) attr.Value {
	return ModuleStatValue{}
}

var _ basetypes.ObjectValuable = ModuleStatValue{}

type ModuleStatValue struct {
	BackupVersion     basetypes.StringValue  `tfsdk:"backup_version"`
	BiosVersion       basetypes.StringValue  `tfsdk:"bios_version"`
	CpldVersion       basetypes.StringValue  `tfsdk:"cpld_version"`
	Fans              basetypes.ListValue    `tfsdk:"fans"`
	FpgaVersion       basetypes.StringValue  `tfsdk:"fpga_version"`
	LastSeen          basetypes.Float64Value `tfsdk:"last_seen"`
	Locating          basetypes.BoolValue    `tfsdk:"locating"`
	Mac               basetypes.StringValue  `tfsdk:"mac"`
	Model             basetypes.StringValue  `tfsdk:"model"`
	OpticsCpldVersion basetypes.StringValue  `tfsdk:"optics_cpld_version"`
	PendingVersion    basetypes.StringValue  `tfsdk:"pending_version"`
	Poe               basetypes.ObjectValue  `tfsdk:"poe"`
	PoeVersion        basetypes.StringValue  `tfsdk:"poe_version"`
	PowerCpldVersion  basetypes.StringValue  `tfsdk:"power_cpld_version"`
	Psus              basetypes.ListValue    `tfsdk:"psus"`
	ReFpgaVersion     basetypes.StringValue  `tfsdk:"re_fpga_version"`
	RecoveryVersion   basetypes.StringValue  `tfsdk:"recovery_version"`
	Serial            basetypes.StringValue  `tfsdk:"serial"`
	Status            basetypes.StringValue  `tfsdk:"status"`
	Temperatures      basetypes.ListValue    `tfsdk:"temperatures"`
	TmcFpgaVersion    basetypes.StringValue  `tfsdk:"tmc_fpga_version"`
	UbootVersion      basetypes.StringValue  `tfsdk:"uboot_version"`
	Uptime            basetypes.Int64Value   `tfsdk:"uptime"`
	VcLinks           basetypes.ListValue    `tfsdk:"vc_links"`
	VcMode            basetypes.StringValue  `tfsdk:"vc_mode"`
	VcRole            basetypes.StringValue  `tfsdk:"vc_role"`
	VcState           basetypes.StringValue  `tfsdk:"vc_state"`
	Version           basetypes.StringValue  `tfsdk:"version"`
	state             attr.ValueState
}

func (v ModuleStatValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 28)

	var val tftypes.Value
	var err error

	attrTypes["backup_version"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["bios_version"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["cpld_version"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["fans"] = basetypes.ListType{
		ElemType: FansValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["fpga_version"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["last_seen"] = basetypes.Float64Type{}.TerraformType(ctx)
	attrTypes["locating"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["mac"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["model"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["optics_cpld_version"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["pending_version"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["poe"] = basetypes.ObjectType{
		AttrTypes: PoeValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["poe_version"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["power_cpld_version"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["psus"] = basetypes.ListType{
		ElemType: PsusValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["re_fpga_version"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["recovery_version"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["serial"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["status"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["temperatures"] = basetypes.ListType{
		ElemType: TemperaturesValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["tmc_fpga_version"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["uboot_version"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["uptime"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["vc_links"] = basetypes.ListType{
		ElemType: VcLinksValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["vc_mode"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["vc_role"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["vc_state"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["version"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 28)

		val, err = v.BackupVersion.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["backup_version"] = val

		val, err = v.BiosVersion.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bios_version"] = val

		val, err = v.CpldVersion.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cpld_version"] = val

		val, err = v.Fans.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["fans"] = val

		val, err = v.FpgaVersion.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["fpga_version"] = val

		val, err = v.LastSeen.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["last_seen"] = val

		val, err = v.Locating.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["locating"] = val

		val, err = v.Mac.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mac"] = val

		val, err = v.Model.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["model"] = val

		val, err = v.OpticsCpldVersion.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["optics_cpld_version"] = val

		val, err = v.PendingVersion.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["pending_version"] = val

		val, err = v.Poe.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["poe"] = val

		val, err = v.PoeVersion.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["poe_version"] = val

		val, err = v.PowerCpldVersion.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["power_cpld_version"] = val

		val, err = v.Psus.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["psus"] = val

		val, err = v.ReFpgaVersion.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["re_fpga_version"] = val

		val, err = v.RecoveryVersion.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["recovery_version"] = val

		val, err = v.Serial.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["serial"] = val

		val, err = v.Status.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["status"] = val

		val, err = v.Temperatures.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["temperatures"] = val

		val, err = v.TmcFpgaVersion.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tmc_fpga_version"] = val

		val, err = v.UbootVersion.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["uboot_version"] = val

		val, err = v.Uptime.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["uptime"] = val

		val, err = v.VcLinks.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vc_links"] = val

		val, err = v.VcMode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vc_mode"] = val

		val, err = v.VcRole.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vc_role"] = val

		val, err = v.VcState.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vc_state"] = val

		val, err = v.Version.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["version"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ModuleStatValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ModuleStatValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ModuleStatValue) String() string {
	return "ModuleStatValue"
}

func (v ModuleStatValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	fans := types.ListValueMust(
		FansType{
			basetypes.ObjectType{
				AttrTypes: FansValue{}.AttributeTypes(ctx),
			},
		},
		v.Fans.Elements(),
	)

	if v.Fans.IsNull() {
		fans = types.ListNull(
			FansType{
				basetypes.ObjectType{
					AttrTypes: FansValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Fans.IsUnknown() {
		fans = types.ListUnknown(
			FansType{
				basetypes.ObjectType{
					AttrTypes: FansValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var poe basetypes.ObjectValue

	if v.Poe.IsNull() {
		poe = types.ObjectNull(
			PoeValue{}.AttributeTypes(ctx),
		)
	}

	if v.Poe.IsUnknown() {
		poe = types.ObjectUnknown(
			PoeValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Poe.IsNull() && !v.Poe.IsUnknown() {
		poe = types.ObjectValueMust(
			PoeValue{}.AttributeTypes(ctx),
			v.Poe.Attributes(),
		)
	}

	psus := types.ListValueMust(
		PsusType{
			basetypes.ObjectType{
				AttrTypes: PsusValue{}.AttributeTypes(ctx),
			},
		},
		v.Psus.Elements(),
	)

	if v.Psus.IsNull() {
		psus = types.ListNull(
			PsusType{
				basetypes.ObjectType{
					AttrTypes: PsusValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Psus.IsUnknown() {
		psus = types.ListUnknown(
			PsusType{
				basetypes.ObjectType{
					AttrTypes: PsusValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	temperatures := types.ListValueMust(
		TemperaturesType{
			basetypes.ObjectType{
				AttrTypes: TemperaturesValue{}.AttributeTypes(ctx),
			},
		},
		v.Temperatures.Elements(),
	)

	if v.Temperatures.IsNull() {
		temperatures = types.ListNull(
			TemperaturesType{
				basetypes.ObjectType{
					AttrTypes: TemperaturesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Temperatures.IsUnknown() {
		temperatures = types.ListUnknown(
			TemperaturesType{
				basetypes.ObjectType{
					AttrTypes: TemperaturesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	vcLinks := types.ListValueMust(
		VcLinksType{
			basetypes.ObjectType{
				AttrTypes: VcLinksValue{}.AttributeTypes(ctx),
			},
		},
		v.VcLinks.Elements(),
	)

	if v.VcLinks.IsNull() {
		vcLinks = types.ListNull(
			VcLinksType{
				basetypes.ObjectType{
					AttrTypes: VcLinksValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.VcLinks.IsUnknown() {
		vcLinks = types.ListUnknown(
			VcLinksType{
				basetypes.ObjectType{
					AttrTypes: VcLinksValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"backup_version": basetypes.StringType{},
		"bios_version":   basetypes.StringType{},
		"cpld_version":   basetypes.StringType{},
		"fans": basetypes.ListType{
			ElemType: FansValue{}.Type(ctx),
		},
		"fpga_version":        basetypes.StringType{},
		"last_seen":           basetypes.Float64Type{},
		"locating":            basetypes.BoolType{},
		"mac":                 basetypes.StringType{},
		"model":               basetypes.StringType{},
		"optics_cpld_version": basetypes.StringType{},
		"pending_version":     basetypes.StringType{},
		"poe": basetypes.ObjectType{
			AttrTypes: PoeValue{}.AttributeTypes(ctx),
		},
		"poe_version":        basetypes.StringType{},
		"power_cpld_version": basetypes.StringType{},
		"psus": basetypes.ListType{
			ElemType: PsusValue{}.Type(ctx),
		},
		"re_fpga_version":  basetypes.StringType{},
		"recovery_version": basetypes.StringType{},
		"serial":           basetypes.StringType{},
		"status":           basetypes.StringType{},
		"temperatures": basetypes.ListType{
			ElemType: TemperaturesValue{}.Type(ctx),
		},
		"tmc_fpga_version": basetypes.StringType{},
		"uboot_version":    basetypes.StringType{},
		"uptime":           basetypes.Int64Type{},
		"vc_links": basetypes.ListType{
			ElemType: VcLinksValue{}.Type(ctx),
		},
		"vc_mode":  basetypes.StringType{},
		"vc_role":  basetypes.StringType{},
		"vc_state": basetypes.StringType{},
		"version":  basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"backup_version":      v.BackupVersion,
			"bios_version":        v.BiosVersion,
			"cpld_version":        v.CpldVersion,
			"fans":                fans,
			"fpga_version":        v.FpgaVersion,
			"last_seen":           v.LastSeen,
			"locating":            v.Locating,
			"mac":                 v.Mac,
			"model":               v.Model,
			"optics_cpld_version": v.OpticsCpldVersion,
			"pending_version":     v.PendingVersion,
			"poe":                 poe,
			"poe_version":         v.PoeVersion,
			"power_cpld_version":  v.PowerCpldVersion,
			"psus":                psus,
			"re_fpga_version":     v.ReFpgaVersion,
			"recovery_version":    v.RecoveryVersion,
			"serial":              v.Serial,
			"status":              v.Status,
			"temperatures":        temperatures,
			"tmc_fpga_version":    v.TmcFpgaVersion,
			"uboot_version":       v.UbootVersion,
			"uptime":              v.Uptime,
			"vc_links":            vcLinks,
			"vc_mode":             v.VcMode,
			"vc_role":             v.VcRole,
			"vc_state":            v.VcState,
			"version":             v.Version,
		})

	return objVal, diags
}

func (v ModuleStatValue) Equal(o attr.Value) bool {
	other, ok := o.(ModuleStatValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.BackupVersion.Equal(other.BackupVersion) {
		return false
	}

	if !v.BiosVersion.Equal(other.BiosVersion) {
		return false
	}

	if !v.CpldVersion.Equal(other.CpldVersion) {
		return false
	}

	if !v.Fans.Equal(other.Fans) {
		return false
	}

	if !v.FpgaVersion.Equal(other.FpgaVersion) {
		return false
	}

	if !v.LastSeen.Equal(other.LastSeen) {
		return false
	}

	if !v.Locating.Equal(other.Locating) {
		return false
	}

	if !v.Mac.Equal(other.Mac) {
		return false
	}

	if !v.Model.Equal(other.Model) {
		return false
	}

	if !v.OpticsCpldVersion.Equal(other.OpticsCpldVersion) {
		return false
	}

	if !v.PendingVersion.Equal(other.PendingVersion) {
		return false
	}

	if !v.Poe.Equal(other.Poe) {
		return false
	}

	if !v.PoeVersion.Equal(other.PoeVersion) {
		return false
	}

	if !v.PowerCpldVersion.Equal(other.PowerCpldVersion) {
		return false
	}

	if !v.Psus.Equal(other.Psus) {
		return false
	}

	if !v.ReFpgaVersion.Equal(other.ReFpgaVersion) {
		return false
	}

	if !v.RecoveryVersion.Equal(other.RecoveryVersion) {
		return false
	}

	if !v.Serial.Equal(other.Serial) {
		return false
	}

	if !v.Status.Equal(other.Status) {
		return false
	}

	if !v.Temperatures.Equal(other.Temperatures) {
		return false
	}

	if !v.TmcFpgaVersion.Equal(other.TmcFpgaVersion) {
		return false
	}

	if !v.UbootVersion.Equal(other.UbootVersion) {
		return false
	}

	if !v.Uptime.Equal(other.Uptime) {
		return false
	}

	if !v.VcLinks.Equal(other.VcLinks) {
		return false
	}

	if !v.VcMode.Equal(other.VcMode) {
		return false
	}

	if !v.VcRole.Equal(other.VcRole) {
		return false
	}

	if !v.VcState.Equal(other.VcState) {
		return false
	}

	if !v.Version.Equal(other.Version) {
		return false
	}

	return true
}

func (v ModuleStatValue) Type(ctx context.Context) attr.Type {
	return ModuleStatType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ModuleStatValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"backup_version": basetypes.StringType{},
		"bios_version":   basetypes.StringType{},
		"cpld_version":   basetypes.StringType{},
		"fans": basetypes.ListType{
			ElemType: FansValue{}.Type(ctx),
		},
		"fpga_version":        basetypes.StringType{},
		"last_seen":           basetypes.Float64Type{},
		"locating":            basetypes.BoolType{},
		"mac":                 basetypes.StringType{},
		"model":               basetypes.StringType{},
		"optics_cpld_version": basetypes.StringType{},
		"pending_version":     basetypes.StringType{},
		"poe": basetypes.ObjectType{
			AttrTypes: PoeValue{}.AttributeTypes(ctx),
		},
		"poe_version":        basetypes.StringType{},
		"power_cpld_version": basetypes.StringType{},
		"psus": basetypes.ListType{
			ElemType: PsusValue{}.Type(ctx),
		},
		"re_fpga_version":  basetypes.StringType{},
		"recovery_version": basetypes.StringType{},
		"serial":           basetypes.StringType{},
		"status":           basetypes.StringType{},
		"temperatures": basetypes.ListType{
			ElemType: TemperaturesValue{}.Type(ctx),
		},
		"tmc_fpga_version": basetypes.StringType{},
		"uboot_version":    basetypes.StringType{},
		"uptime":           basetypes.Int64Type{},
		"vc_links": basetypes.ListType{
			ElemType: VcLinksValue{}.Type(ctx),
		},
		"vc_mode":  basetypes.StringType{},
		"vc_role":  basetypes.StringType{},
		"vc_state": basetypes.StringType{},
		"version":  basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = FansType{}

type FansType struct {
	basetypes.ObjectType
}

func (t FansType) Equal(o attr.Type) bool {
	other, ok := o.(FansType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t FansType) String() string {
	return "FansType"
}

func (t FansType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	airflowAttribute, ok := attributes["airflow"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`airflow is missing from object`)

		return nil, diags
	}

	airflowVal, ok := airflowAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`airflow expected to be basetypes.StringValue, was: %T`, airflowAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return nil, diags
	}

	statusVal, ok := statusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be basetypes.StringValue, was: %T`, statusAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return FansValue{
		Airflow: airflowVal,
		Name:    nameVal,
		Status:  statusVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewFansValueNull() FansValue {
	return FansValue{
		state: attr.ValueStateNull,
	}
}

func NewFansValueUnknown() FansValue {
	return FansValue{
		state: attr.ValueStateUnknown,
	}
}

func NewFansValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (FansValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing FansValue Attribute Value",
				"While creating a FansValue value, a missing attribute value was detected. "+
					"A FansValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("FansValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid FansValue Attribute Type",
				"While creating a FansValue value, an invalid attribute value was detected. "+
					"A FansValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("FansValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("FansValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra FansValue Attribute Value",
				"While creating a FansValue value, an extra attribute value was detected. "+
					"A FansValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra FansValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewFansValueUnknown(), diags
	}

	airflowAttribute, ok := attributes["airflow"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`airflow is missing from object`)

		return NewFansValueUnknown(), diags
	}

	airflowVal, ok := airflowAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`airflow expected to be basetypes.StringValue, was: %T`, airflowAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewFansValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return NewFansValueUnknown(), diags
	}

	statusVal, ok := statusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be basetypes.StringValue, was: %T`, statusAttribute))
	}

	if diags.HasError() {
		return NewFansValueUnknown(), diags
	}

	return FansValue{
		Airflow: airflowVal,
		Name:    nameVal,
		Status:  statusVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewFansValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) FansValue {
	object, diags := NewFansValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewFansValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t FansType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewFansValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewFansValueUnknown(), nil
	}

	if in.IsNull() {
		return NewFansValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewFansValueMust(FansValue{}.AttributeTypes(ctx), attributes), nil
}

func (t FansType) ValueType(ctx context.Context) attr.Value {
	return FansValue{}
}

var _ basetypes.ObjectValuable = FansValue{}

type FansValue struct {
	Airflow basetypes.StringValue `tfsdk:"airflow"`
	Name    basetypes.StringValue `tfsdk:"name"`
	Status  basetypes.StringValue `tfsdk:"status"`
	state   attr.ValueState
}

func (v FansValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["airflow"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["status"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Airflow.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["airflow"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Status.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["status"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v FansValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v FansValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v FansValue) String() string {
	return "FansValue"
}

func (v FansValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"airflow": basetypes.StringType{},
		"name":    basetypes.StringType{},
		"status":  basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"airflow": v.Airflow,
			"name":    v.Name,
			"status":  v.Status,
		})

	return objVal, diags
}

func (v FansValue) Equal(o attr.Value) bool {
	other, ok := o.(FansValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Airflow.Equal(other.Airflow) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Status.Equal(other.Status) {
		return false
	}

	return true
}

func (v FansValue) Type(ctx context.Context) attr.Type {
	return FansType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v FansValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"airflow": basetypes.StringType{},
		"name":    basetypes.StringType{},
		"status":  basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = PoeType{}

type PoeType struct {
	basetypes.ObjectType
}

func (t PoeType) Equal(o attr.Type) bool {
	other, ok := o.(PoeType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PoeType) String() string {
	return "PoeType"
}

func (t PoeType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	maxPowerAttribute, ok := attributes["max_power"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_power is missing from object`)

		return nil, diags
	}

	maxPowerVal, ok := maxPowerAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_power expected to be basetypes.NumberValue, was: %T`, maxPowerAttribute))
	}

	powerDrawAttribute, ok := attributes["power_draw"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`power_draw is missing from object`)

		return nil, diags
	}

	powerDrawVal, ok := powerDrawAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`power_draw expected to be basetypes.NumberValue, was: %T`, powerDrawAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PoeValue{
		MaxPower:  maxPowerVal,
		PowerDraw: powerDrawVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewPoeValueNull() PoeValue {
	return PoeValue{
		state: attr.ValueStateNull,
	}
}

func NewPoeValueUnknown() PoeValue {
	return PoeValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPoeValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PoeValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PoeValue Attribute Value",
				"While creating a PoeValue value, a missing attribute value was detected. "+
					"A PoeValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PoeValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PoeValue Attribute Type",
				"While creating a PoeValue value, an invalid attribute value was detected. "+
					"A PoeValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PoeValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PoeValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PoeValue Attribute Value",
				"While creating a PoeValue value, an extra attribute value was detected. "+
					"A PoeValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PoeValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPoeValueUnknown(), diags
	}

	maxPowerAttribute, ok := attributes["max_power"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_power is missing from object`)

		return NewPoeValueUnknown(), diags
	}

	maxPowerVal, ok := maxPowerAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_power expected to be basetypes.NumberValue, was: %T`, maxPowerAttribute))
	}

	powerDrawAttribute, ok := attributes["power_draw"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`power_draw is missing from object`)

		return NewPoeValueUnknown(), diags
	}

	powerDrawVal, ok := powerDrawAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`power_draw expected to be basetypes.NumberValue, was: %T`, powerDrawAttribute))
	}

	if diags.HasError() {
		return NewPoeValueUnknown(), diags
	}

	return PoeValue{
		MaxPower:  maxPowerVal,
		PowerDraw: powerDrawVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewPoeValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PoeValue {
	object, diags := NewPoeValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPoeValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PoeType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPoeValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPoeValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPoeValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPoeValueMust(PoeValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PoeType) ValueType(ctx context.Context) attr.Value {
	return PoeValue{}
}

var _ basetypes.ObjectValuable = PoeValue{}

type PoeValue struct {
	MaxPower  basetypes.NumberValue `tfsdk:"max_power"`
	PowerDraw basetypes.NumberValue `tfsdk:"power_draw"`
	state     attr.ValueState
}

func (v PoeValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["max_power"] = basetypes.NumberType{}.TerraformType(ctx)
	attrTypes["power_draw"] = basetypes.NumberType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.MaxPower.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_power"] = val

		val, err = v.PowerDraw.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["power_draw"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PoeValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PoeValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PoeValue) String() string {
	return "PoeValue"
}

func (v PoeValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"max_power":  basetypes.NumberType{},
		"power_draw": basetypes.NumberType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"max_power":  v.MaxPower,
			"power_draw": v.PowerDraw,
		})

	return objVal, diags
}

func (v PoeValue) Equal(o attr.Value) bool {
	other, ok := o.(PoeValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.MaxPower.Equal(other.MaxPower) {
		return false
	}

	if !v.PowerDraw.Equal(other.PowerDraw) {
		return false
	}

	return true
}

func (v PoeValue) Type(ctx context.Context) attr.Type {
	return PoeType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PoeValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"max_power":  basetypes.NumberType{},
		"power_draw": basetypes.NumberType{},
	}
}

var _ basetypes.ObjectTypable = PsusType{}

type PsusType struct {
	basetypes.ObjectType
}

func (t PsusType) Equal(o attr.Type) bool {
	other, ok := o.(PsusType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PsusType) String() string {
	return "PsusType"
}

func (t PsusType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return nil, diags
	}

	statusVal, ok := statusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be basetypes.StringValue, was: %T`, statusAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PsusValue{
		Name:   nameVal,
		Status: statusVal,
		state:  attr.ValueStateKnown,
	}, diags
}

func NewPsusValueNull() PsusValue {
	return PsusValue{
		state: attr.ValueStateNull,
	}
}

func NewPsusValueUnknown() PsusValue {
	return PsusValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPsusValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PsusValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PsusValue Attribute Value",
				"While creating a PsusValue value, a missing attribute value was detected. "+
					"A PsusValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PsusValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PsusValue Attribute Type",
				"While creating a PsusValue value, an invalid attribute value was detected. "+
					"A PsusValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PsusValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PsusValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PsusValue Attribute Value",
				"While creating a PsusValue value, an extra attribute value was detected. "+
					"A PsusValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PsusValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPsusValueUnknown(), diags
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewPsusValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return NewPsusValueUnknown(), diags
	}

	statusVal, ok := statusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be basetypes.StringValue, was: %T`, statusAttribute))
	}

	if diags.HasError() {
		return NewPsusValueUnknown(), diags
	}

	return PsusValue{
		Name:   nameVal,
		Status: statusVal,
		state:  attr.ValueStateKnown,
	}, diags
}

func NewPsusValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PsusValue {
	object, diags := NewPsusValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPsusValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PsusType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPsusValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPsusValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPsusValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPsusValueMust(PsusValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PsusType) ValueType(ctx context.Context) attr.Value {
	return PsusValue{}
}

var _ basetypes.ObjectValuable = PsusValue{}

type PsusValue struct {
	Name   basetypes.StringValue `tfsdk:"name"`
	Status basetypes.StringValue `tfsdk:"status"`
	state  attr.ValueState
}

func (v PsusValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["status"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Status.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["status"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PsusValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PsusValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PsusValue) String() string {
	return "PsusValue"
}

func (v PsusValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"name":   basetypes.StringType{},
		"status": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"name":   v.Name,
			"status": v.Status,
		})

	return objVal, diags
}

func (v PsusValue) Equal(o attr.Value) bool {
	other, ok := o.(PsusValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Status.Equal(other.Status) {
		return false
	}

	return true
}

func (v PsusValue) Type(ctx context.Context) attr.Type {
	return PsusType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PsusValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"name":   basetypes.StringType{},
		"status": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = TemperaturesType{}

type TemperaturesType struct {
	basetypes.ObjectType
}

func (t TemperaturesType) Equal(o attr.Type) bool {
	other, ok := o.(TemperaturesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t TemperaturesType) String() string {
	return "TemperaturesType"
}

func (t TemperaturesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	celsiusAttribute, ok := attributes["celsius"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`celsius is missing from object`)

		return nil, diags
	}

	celsiusVal, ok := celsiusAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`celsius expected to be basetypes.NumberValue, was: %T`, celsiusAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return nil, diags
	}

	statusVal, ok := statusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be basetypes.StringValue, was: %T`, statusAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return TemperaturesValue{
		Celsius: celsiusVal,
		Name:    nameVal,
		Status:  statusVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewTemperaturesValueNull() TemperaturesValue {
	return TemperaturesValue{
		state: attr.ValueStateNull,
	}
}

func NewTemperaturesValueUnknown() TemperaturesValue {
	return TemperaturesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewTemperaturesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (TemperaturesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing TemperaturesValue Attribute Value",
				"While creating a TemperaturesValue value, a missing attribute value was detected. "+
					"A TemperaturesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TemperaturesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid TemperaturesValue Attribute Type",
				"While creating a TemperaturesValue value, an invalid attribute value was detected. "+
					"A TemperaturesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TemperaturesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("TemperaturesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra TemperaturesValue Attribute Value",
				"While creating a TemperaturesValue value, an extra attribute value was detected. "+
					"A TemperaturesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra TemperaturesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewTemperaturesValueUnknown(), diags
	}

	celsiusAttribute, ok := attributes["celsius"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`celsius is missing from object`)

		return NewTemperaturesValueUnknown(), diags
	}

	celsiusVal, ok := celsiusAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`celsius expected to be basetypes.NumberValue, was: %T`, celsiusAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewTemperaturesValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return NewTemperaturesValueUnknown(), diags
	}

	statusVal, ok := statusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be basetypes.StringValue, was: %T`, statusAttribute))
	}

	if diags.HasError() {
		return NewTemperaturesValueUnknown(), diags
	}

	return TemperaturesValue{
		Celsius: celsiusVal,
		Name:    nameVal,
		Status:  statusVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewTemperaturesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) TemperaturesValue {
	object, diags := NewTemperaturesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewTemperaturesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t TemperaturesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewTemperaturesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewTemperaturesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewTemperaturesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewTemperaturesValueMust(TemperaturesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t TemperaturesType) ValueType(ctx context.Context) attr.Value {
	return TemperaturesValue{}
}

var _ basetypes.ObjectValuable = TemperaturesValue{}

type TemperaturesValue struct {
	Celsius basetypes.NumberValue `tfsdk:"celsius"`
	Name    basetypes.StringValue `tfsdk:"name"`
	Status  basetypes.StringValue `tfsdk:"status"`
	state   attr.ValueState
}

func (v TemperaturesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["celsius"] = basetypes.NumberType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["status"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Celsius.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["celsius"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Status.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["status"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v TemperaturesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v TemperaturesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v TemperaturesValue) String() string {
	return "TemperaturesValue"
}

func (v TemperaturesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"celsius": basetypes.NumberType{},
		"name":    basetypes.StringType{},
		"status":  basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"celsius": v.Celsius,
			"name":    v.Name,
			"status":  v.Status,
		})

	return objVal, diags
}

func (v TemperaturesValue) Equal(o attr.Value) bool {
	other, ok := o.(TemperaturesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Celsius.Equal(other.Celsius) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Status.Equal(other.Status) {
		return false
	}

	return true
}

func (v TemperaturesValue) Type(ctx context.Context) attr.Type {
	return TemperaturesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v TemperaturesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"celsius": basetypes.NumberType{},
		"name":    basetypes.StringType{},
		"status":  basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = VcLinksType{}

type VcLinksType struct {
	basetypes.ObjectType
}

func (t VcLinksType) Equal(o attr.Type) bool {
	other, ok := o.(VcLinksType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t VcLinksType) String() string {
	return "VcLinksType"
}

func (t VcLinksType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	neighborModuleIdxAttribute, ok := attributes["neighbor_module_idx"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`neighbor_module_idx is missing from object`)

		return nil, diags
	}

	neighborModuleIdxVal, ok := neighborModuleIdxAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`neighbor_module_idx expected to be basetypes.Int64Value, was: %T`, neighborModuleIdxAttribute))
	}

	neighborPortIdAttribute, ok := attributes["neighbor_port_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`neighbor_port_id is missing from object`)

		return nil, diags
	}

	neighborPortIdVal, ok := neighborPortIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`neighbor_port_id expected to be basetypes.StringValue, was: %T`, neighborPortIdAttribute))
	}

	portIdAttribute, ok := attributes["port_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_id is missing from object`)

		return nil, diags
	}

	portIdVal, ok := portIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_id expected to be basetypes.StringValue, was: %T`, portIdAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return VcLinksValue{
		NeighborModuleIdx: neighborModuleIdxVal,
		NeighborPortId:    neighborPortIdVal,
		PortId:            portIdVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewVcLinksValueNull() VcLinksValue {
	return VcLinksValue{
		state: attr.ValueStateNull,
	}
}

func NewVcLinksValueUnknown() VcLinksValue {
	return VcLinksValue{
		state: attr.ValueStateUnknown,
	}
}

func NewVcLinksValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (VcLinksValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing VcLinksValue Attribute Value",
				"While creating a VcLinksValue value, a missing attribute value was detected. "+
					"A VcLinksValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VcLinksValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid VcLinksValue Attribute Type",
				"While creating a VcLinksValue value, an invalid attribute value was detected. "+
					"A VcLinksValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VcLinksValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("VcLinksValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra VcLinksValue Attribute Value",
				"While creating a VcLinksValue value, an extra attribute value was detected. "+
					"A VcLinksValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra VcLinksValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewVcLinksValueUnknown(), diags
	}

	neighborModuleIdxAttribute, ok := attributes["neighbor_module_idx"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`neighbor_module_idx is missing from object`)

		return NewVcLinksValueUnknown(), diags
	}

	neighborModuleIdxVal, ok := neighborModuleIdxAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`neighbor_module_idx expected to be basetypes.Int64Value, was: %T`, neighborModuleIdxAttribute))
	}

	neighborPortIdAttribute, ok := attributes["neighbor_port_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`neighbor_port_id is missing from object`)

		return NewVcLinksValueUnknown(), diags
	}

	neighborPortIdVal, ok := neighborPortIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`neighbor_port_id expected to be basetypes.StringValue, was: %T`, neighborPortIdAttribute))
	}

	portIdAttribute, ok := attributes["port_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_id is missing from object`)

		return NewVcLinksValueUnknown(), diags
	}

	portIdVal, ok := portIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_id expected to be basetypes.StringValue, was: %T`, portIdAttribute))
	}

	if diags.HasError() {
		return NewVcLinksValueUnknown(), diags
	}

	return VcLinksValue{
		NeighborModuleIdx: neighborModuleIdxVal,
		NeighborPortId:    neighborPortIdVal,
		PortId:            portIdVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewVcLinksValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) VcLinksValue {
	object, diags := NewVcLinksValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewVcLinksValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t VcLinksType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewVcLinksValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewVcLinksValueUnknown(), nil
	}

	if in.IsNull() {
		return NewVcLinksValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewVcLinksValueMust(VcLinksValue{}.AttributeTypes(ctx), attributes), nil
}

func (t VcLinksType) ValueType(ctx context.Context) attr.Value {
	return VcLinksValue{}
}

var _ basetypes.ObjectValuable = VcLinksValue{}

type VcLinksValue struct {
	NeighborModuleIdx basetypes.Int64Value  `tfsdk:"neighbor_module_idx"`
	NeighborPortId    basetypes.StringValue `tfsdk:"neighbor_port_id"`
	PortId            basetypes.StringValue `tfsdk:"port_id"`
	state             attr.ValueState
}

func (v VcLinksValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["neighbor_module_idx"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["neighbor_port_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["port_id"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.NeighborModuleIdx.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["neighbor_module_idx"] = val

		val, err = v.NeighborPortId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["neighbor_port_id"] = val

		val, err = v.PortId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port_id"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v VcLinksValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v VcLinksValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v VcLinksValue) String() string {
	return "VcLinksValue"
}

func (v VcLinksValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"neighbor_module_idx": basetypes.Int64Type{},
		"neighbor_port_id":    basetypes.StringType{},
		"port_id":             basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"neighbor_module_idx": v.NeighborModuleIdx,
			"neighbor_port_id":    v.NeighborPortId,
			"port_id":             v.PortId,
		})

	return objVal, diags
}

func (v VcLinksValue) Equal(o attr.Value) bool {
	other, ok := o.(VcLinksValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.NeighborModuleIdx.Equal(other.NeighborModuleIdx) {
		return false
	}

	if !v.NeighborPortId.Equal(other.NeighborPortId) {
		return false
	}

	if !v.PortId.Equal(other.PortId) {
		return false
	}

	return true
}

func (v VcLinksValue) Type(ctx context.Context) attr.Type {
	return VcLinksType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v VcLinksValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"neighbor_module_idx": basetypes.Int64Type{},
		"neighbor_port_id":    basetypes.StringType{},
		"port_id":             basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = PortsType{}

type PortsType struct {
	basetypes.ObjectType
}

func (t PortsType) Equal(o attr.Type) bool {
	other, ok := o.(PortsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PortsType) String() string {
	return "PortsType"
}

func (t PortsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	activeAttribute, ok := attributes["active"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`active is missing from object`)

		return nil, diags
	}

	activeVal, ok := activeAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`active expected to be basetypes.BoolValue, was: %T`, activeAttribute))
	}

	authStateAttribute, ok := attributes["auth_state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auth_state is missing from object`)

		return nil, diags
	}

	authStateVal, ok := authStateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auth_state expected to be basetypes.StringValue, was: %T`, authStateAttribute))
	}

	disabledAttribute, ok := attributes["disabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disabled is missing from object`)

		return nil, diags
	}

	disabledVal, ok := disabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disabled expected to be basetypes.BoolValue, was: %T`, disabledAttribute))
	}

	forSiteAttribute, ok := attributes["for_site"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`for_site is missing from object`)

		return nil, diags
	}

	forSiteVal, ok := forSiteAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`for_site expected to be basetypes.BoolValue, was: %T`, forSiteAttribute))
	}

	fullDuplexAttribute, ok := attributes["full_duplex"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`full_duplex is missing from object`)

		return nil, diags
	}

	fullDuplexVal, ok := fullDuplexAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`full_duplex expected to be basetypes.BoolValue, was: %T`, fullDuplexAttribute))
	}

	jitterAttribute, ok := attributes["jitter"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`jitter is missing from object`)

		return nil, diags
	}

	jitterVal, ok := jitterAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`jitter expected to be basetypes.NumberValue, was: %T`, jitterAttribute))
	}

	latencyAttribute, ok := attributes["latency"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`latency is missing from object`)

		return nil, diags
	}

	latencyVal, ok := latencyAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`latency expected to be basetypes.NumberValue, was: %T`, latencyAttribute))
	}

	lossAttribute, ok := attributes["loss"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`loss is missing from object`)

		return nil, diags
	}

	lossVal, ok := lossAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`loss expected to be basetypes.NumberValue, was: %T`, lossAttribute))
	}

	lteIccidAttribute, ok := attributes["lte_iccid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lte_iccid is missing from object`)

		return nil, diags
	}

	lteIccidVal, ok := lteIccidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lte_iccid expected to be basetypes.StringValue, was: %T`, lteIccidAttribute))
	}

	lteImeiAttribute, ok := attributes["lte_imei"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lte_imei is missing from object`)

		return nil, diags
	}

	lteImeiVal, ok := lteImeiAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lte_imei expected to be basetypes.StringValue, was: %T`, lteImeiAttribute))
	}

	lteImsiAttribute, ok := attributes["lte_imsi"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lte_imsi is missing from object`)

		return nil, diags
	}

	lteImsiVal, ok := lteImsiAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lte_imsi expected to be basetypes.StringValue, was: %T`, lteImsiAttribute))
	}

	macCountAttribute, ok := attributes["mac_count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mac_count is missing from object`)

		return nil, diags
	}

	macCountVal, ok := macCountAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mac_count expected to be basetypes.Int64Value, was: %T`, macCountAttribute))
	}

	macLimitAttribute, ok := attributes["mac_limit"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mac_limit is missing from object`)

		return nil, diags
	}

	macLimitVal, ok := macLimitAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mac_limit expected to be basetypes.Int64Value, was: %T`, macLimitAttribute))
	}

	neighborMacAttribute, ok := attributes["neighbor_mac"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`neighbor_mac is missing from object`)

		return nil, diags
	}

	neighborMacVal, ok := neighborMacAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`neighbor_mac expected to be basetypes.StringValue, was: %T`, neighborMacAttribute))
	}

	neighborPortDescAttribute, ok := attributes["neighbor_port_desc"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`neighbor_port_desc is missing from object`)

		return nil, diags
	}

	neighborPortDescVal, ok := neighborPortDescAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`neighbor_port_desc expected to be basetypes.StringValue, was: %T`, neighborPortDescAttribute))
	}

	neighborSystemNameAttribute, ok := attributes["neighbor_system_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`neighbor_system_name is missing from object`)

		return nil, diags
	}

	neighborSystemNameVal, ok := neighborSystemNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`neighbor_system_name expected to be basetypes.StringValue, was: %T`, neighborSystemNameAttribute))
	}

	poeDisabledAttribute, ok := attributes["poe_disabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`poe_disabled is missing from object`)

		return nil, diags
	}

	poeDisabledVal, ok := poeDisabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`poe_disabled expected to be basetypes.BoolValue, was: %T`, poeDisabledAttribute))
	}

	poeModeAttribute, ok := attributes["poe_mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`poe_mode is missing from object`)

		return nil, diags
	}

	poeModeVal, ok := poeModeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`poe_mode expected to be basetypes.StringValue, was: %T`, poeModeAttribute))
	}

	poeOnAttribute, ok := attributes["poe_on"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`poe_on is missing from object`)

		return nil, diags
	}

	poeOnVal, ok := poeOnAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`poe_on expected to be basetypes.BoolValue, was: %T`, poeOnAttribute))
	}

	portIdAttribute, ok := attributes["port_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_id is missing from object`)

		return nil, diags
	}

	portIdVal, ok := portIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_id expected to be basetypes.StringValue, was: %T`, portIdAttribute))
	}

	portMacAttribute, ok := attributes["port_mac"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_mac is missing from object`)

		return nil, diags
	}

	portMacVal, ok := portMacAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_mac expected to be basetypes.StringValue, was: %T`, portMacAttribute))
	}

	portUsageAttribute, ok := attributes["port_usage"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_usage is missing from object`)

		return nil, diags
	}

	portUsageVal, ok := portUsageAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_usage expected to be basetypes.StringValue, was: %T`, portUsageAttribute))
	}

	powerDrawAttribute, ok := attributes["power_draw"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`power_draw is missing from object`)

		return nil, diags
	}

	powerDrawVal, ok := powerDrawAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`power_draw expected to be basetypes.NumberValue, was: %T`, powerDrawAttribute))
	}

	rxBcastPktsAttribute, ok := attributes["rx_bcast_pkts"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rx_bcast_pkts is missing from object`)

		return nil, diags
	}

	rxBcastPktsVal, ok := rxBcastPktsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rx_bcast_pkts expected to be basetypes.Int64Value, was: %T`, rxBcastPktsAttribute))
	}

	rxBpsAttribute, ok := attributes["rx_bps"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rx_bps is missing from object`)

		return nil, diags
	}

	rxBpsVal, ok := rxBpsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rx_bps expected to be basetypes.Int64Value, was: %T`, rxBpsAttribute))
	}

	rxBytesAttribute, ok := attributes["rx_bytes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rx_bytes is missing from object`)

		return nil, diags
	}

	rxBytesVal, ok := rxBytesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rx_bytes expected to be basetypes.Int64Value, was: %T`, rxBytesAttribute))
	}

	rxErrorsAttribute, ok := attributes["rx_errors"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rx_errors is missing from object`)

		return nil, diags
	}

	rxErrorsVal, ok := rxErrorsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rx_errors expected to be basetypes.Int64Value, was: %T`, rxErrorsAttribute))
	}

	rxMcastPktsAttribute, ok := attributes["rx_mcast_pkts"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rx_mcast_pkts is missing from object`)

		return nil, diags
	}

	rxMcastPktsVal, ok := rxMcastPktsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rx_mcast_pkts expected to be basetypes.Int64Value, was: %T`, rxMcastPktsAttribute))
	}

	rxPktsAttribute, ok := attributes["rx_pkts"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rx_pkts is missing from object`)

		return nil, diags
	}

	rxPktsVal, ok := rxPktsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rx_pkts expected to be basetypes.Int64Value, was: %T`, rxPktsAttribute))
	}

	speedAttribute, ok := attributes["speed"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`speed is missing from object`)

		return nil, diags
	}

	speedVal, ok := speedAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`speed expected to be basetypes.Int64Value, was: %T`, speedAttribute))
	}

	stpRoleAttribute, ok := attributes["stp_role"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`stp_role is missing from object`)

		return nil, diags
	}

	stpRoleVal, ok := stpRoleAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`stp_role expected to be basetypes.StringValue, was: %T`, stpRoleAttribute))
	}

	stpStateAttribute, ok := attributes["stp_state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`stp_state is missing from object`)

		return nil, diags
	}

	stpStateVal, ok := stpStateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`stp_state expected to be basetypes.StringValue, was: %T`, stpStateAttribute))
	}

	txBcastPktsAttribute, ok := attributes["tx_bcast_pkts"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tx_bcast_pkts is missing from object`)

		return nil, diags
	}

	txBcastPktsVal, ok := txBcastPktsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tx_bcast_pkts expected to be basetypes.Int64Value, was: %T`, txBcastPktsAttribute))
	}

	txBpsAttribute, ok := attributes["tx_bps"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tx_bps is missing from object`)

		return nil, diags
	}

	txBpsVal, ok := txBpsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tx_bps expected to be basetypes.Int64Value, was: %T`, txBpsAttribute))
	}

	txBytesAttribute, ok := attributes["tx_bytes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tx_bytes is missing from object`)

		return nil, diags
	}

	txBytesVal, ok := txBytesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tx_bytes expected to be basetypes.Int64Value, was: %T`, txBytesAttribute))
	}

	txErrorsAttribute, ok := attributes["tx_errors"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tx_errors is missing from object`)

		return nil, diags
	}

	txErrorsVal, ok := txErrorsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tx_errors expected to be basetypes.Int64Value, was: %T`, txErrorsAttribute))
	}

	txMcastPktsAttribute, ok := attributes["tx_mcast_pkts"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tx_mcast_pkts is missing from object`)

		return nil, diags
	}

	txMcastPktsVal, ok := txMcastPktsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tx_mcast_pkts expected to be basetypes.Int64Value, was: %T`, txMcastPktsAttribute))
	}

	txPktsAttribute, ok := attributes["tx_pkts"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tx_pkts is missing from object`)

		return nil, diags
	}

	txPktsVal, ok := txPktsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tx_pkts expected to be basetypes.Int64Value, was: %T`, txPktsAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	unconfiguredAttribute, ok := attributes["unconfigured"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`unconfigured is missing from object`)

		return nil, diags
	}

	unconfiguredVal, ok := unconfiguredAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`unconfigured expected to be basetypes.BoolValue, was: %T`, unconfiguredAttribute))
	}

	upAttribute, ok := attributes["up"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`up is missing from object`)

		return nil, diags
	}

	upVal, ok := upAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`up expected to be basetypes.BoolValue, was: %T`, upAttribute))
	}

	xcvrModelAttribute, ok := attributes["xcvr_model"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`xcvr_model is missing from object`)

		return nil, diags
	}

	xcvrModelVal, ok := xcvrModelAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`xcvr_model expected to be basetypes.StringValue, was: %T`, xcvrModelAttribute))
	}

	xcvrPartNumberAttribute, ok := attributes["xcvr_part_number"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`xcvr_part_number is missing from object`)

		return nil, diags
	}

	xcvrPartNumberVal, ok := xcvrPartNumberAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`xcvr_part_number expected to be basetypes.StringValue, was: %T`, xcvrPartNumberAttribute))
	}

	xcvrSerialAttribute, ok := attributes["xcvr_serial"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`xcvr_serial is missing from object`)

		return nil, diags
	}

	xcvrSerialVal, ok := xcvrSerialAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`xcvr_serial expected to be basetypes.StringValue, was: %T`, xcvrSerialAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PortsValue{
		Active:             activeVal,
		AuthState:          authStateVal,
		Disabled:           disabledVal,
		ForSite:            forSiteVal,
		FullDuplex:         fullDuplexVal,
		Jitter:             jitterVal,
		Latency:            latencyVal,
		Loss:               lossVal,
		LteIccid:           lteIccidVal,
		LteImei:            lteImeiVal,
		LteImsi:            lteImsiVal,
		MacCount:           macCountVal,
		MacLimit:           macLimitVal,
		NeighborMac:        neighborMacVal,
		NeighborPortDesc:   neighborPortDescVal,
		NeighborSystemName: neighborSystemNameVal,
		PoeDisabled:        poeDisabledVal,
		PoeMode:            poeModeVal,
		PoeOn:              poeOnVal,
		PortId:             portIdVal,
		PortMac:            portMacVal,
		PortUsage:          portUsageVal,
		PowerDraw:          powerDrawVal,
		RxBcastPkts:        rxBcastPktsVal,
		RxBps:              rxBpsVal,
		RxBytes:            rxBytesVal,
		RxErrors:           rxErrorsVal,
		RxMcastPkts:        rxMcastPktsVal,
		RxPkts:             rxPktsVal,
		Speed:              speedVal,
		StpRole:            stpRoleVal,
		StpState:           stpStateVal,
		TxBcastPkts:        txBcastPktsVal,
		TxBps:              txBpsVal,
		TxBytes:            txBytesVal,
		TxErrors:           txErrorsVal,
		TxMcastPkts:        txMcastPktsVal,
		TxPkts:             txPktsVal,
		PortsType:          typeVal,
		Unconfigured:       unconfiguredVal,
		Up:                 upVal,
		XcvrModel:          xcvrModelVal,
		XcvrPartNumber:     xcvrPartNumberVal,
		XcvrSerial:         xcvrSerialVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewPortsValueNull() PortsValue {
	return PortsValue{
		state: attr.ValueStateNull,
	}
}

func NewPortsValueUnknown() PortsValue {
	return PortsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPortsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PortsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PortsValue Attribute Value",
				"While creating a PortsValue value, a missing attribute value was detected. "+
					"A PortsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PortsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PortsValue Attribute Type",
				"While creating a PortsValue value, an invalid attribute value was detected. "+
					"A PortsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PortsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PortsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PortsValue Attribute Value",
				"While creating a PortsValue value, an extra attribute value was detected. "+
					"A PortsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PortsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPortsValueUnknown(), diags
	}

	activeAttribute, ok := attributes["active"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`active is missing from object`)

		return NewPortsValueUnknown(), diags
	}

	activeVal, ok := activeAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`active expected to be basetypes.BoolValue, was: %T`, activeAttribute))
	}

	authStateAttribute, ok := attributes["auth_state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auth_state is missing from object`)

		return NewPortsValueUnknown(), diags
	}

	authStateVal, ok := authStateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auth_state expected to be basetypes.StringValue, was: %T`, authStateAttribute))
	}

	disabledAttribute, ok := attributes["disabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disabled is missing from object`)

		return NewPortsValueUnknown(), diags
	}

	disabledVal, ok := disabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disabled expected to be basetypes.BoolValue, was: %T`, disabledAttribute))
	}

	forSiteAttribute, ok := attributes["for_site"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`for_site is missing from object`)

		return NewPortsValueUnknown(), diags
	}

	forSiteVal, ok := forSiteAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`for_site expected to be basetypes.BoolValue, was: %T`, forSiteAttribute))
	}

	fullDuplexAttribute, ok := attributes["full_duplex"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`full_duplex is missing from object`)

		return NewPortsValueUnknown(), diags
	}

	fullDuplexVal, ok := fullDuplexAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`full_duplex expected to be basetypes.BoolValue, was: %T`, fullDuplexAttribute))
	}

	jitterAttribute, ok := attributes["jitter"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`jitter is missing from object`)

		return NewPortsValueUnknown(), diags
	}

	jitterVal, ok := jitterAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`jitter expected to be basetypes.NumberValue, was: %T`, jitterAttribute))
	}

	latencyAttribute, ok := attributes["latency"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`latency is missing from object`)

		return NewPortsValueUnknown(), diags
	}

	latencyVal, ok := latencyAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`latency expected to be basetypes.NumberValue, was: %T`, latencyAttribute))
	}

	lossAttribute, ok := attributes["loss"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`loss is missing from object`)

		return NewPortsValueUnknown(), diags
	}

	lossVal, ok := lossAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`loss expected to be basetypes.NumberValue, was: %T`, lossAttribute))
	}

	lteIccidAttribute, ok := attributes["lte_iccid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lte_iccid is missing from object`)

		return NewPortsValueUnknown(), diags
	}

	lteIccidVal, ok := lteIccidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lte_iccid expected to be basetypes.StringValue, was: %T`, lteIccidAttribute))
	}

	lteImeiAttribute, ok := attributes["lte_imei"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lte_imei is missing from object`)

		return NewPortsValueUnknown(), diags
	}

	lteImeiVal, ok := lteImeiAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lte_imei expected to be basetypes.StringValue, was: %T`, lteImeiAttribute))
	}

	lteImsiAttribute, ok := attributes["lte_imsi"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lte_imsi is missing from object`)

		return NewPortsValueUnknown(), diags
	}

	lteImsiVal, ok := lteImsiAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lte_imsi expected to be basetypes.StringValue, was: %T`, lteImsiAttribute))
	}

	macCountAttribute, ok := attributes["mac_count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mac_count is missing from object`)

		return NewPortsValueUnknown(), diags
	}

	macCountVal, ok := macCountAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mac_count expected to be basetypes.Int64Value, was: %T`, macCountAttribute))
	}

	macLimitAttribute, ok := attributes["mac_limit"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mac_limit is missing from object`)

		return NewPortsValueUnknown(), diags
	}

	macLimitVal, ok := macLimitAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mac_limit expected to be basetypes.Int64Value, was: %T`, macLimitAttribute))
	}

	neighborMacAttribute, ok := attributes["neighbor_mac"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`neighbor_mac is missing from object`)

		return NewPortsValueUnknown(), diags
	}

	neighborMacVal, ok := neighborMacAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`neighbor_mac expected to be basetypes.StringValue, was: %T`, neighborMacAttribute))
	}

	neighborPortDescAttribute, ok := attributes["neighbor_port_desc"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`neighbor_port_desc is missing from object`)

		return NewPortsValueUnknown(), diags
	}

	neighborPortDescVal, ok := neighborPortDescAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`neighbor_port_desc expected to be basetypes.StringValue, was: %T`, neighborPortDescAttribute))
	}

	neighborSystemNameAttribute, ok := attributes["neighbor_system_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`neighbor_system_name is missing from object`)

		return NewPortsValueUnknown(), diags
	}

	neighborSystemNameVal, ok := neighborSystemNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`neighbor_system_name expected to be basetypes.StringValue, was: %T`, neighborSystemNameAttribute))
	}

	poeDisabledAttribute, ok := attributes["poe_disabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`poe_disabled is missing from object`)

		return NewPortsValueUnknown(), diags
	}

	poeDisabledVal, ok := poeDisabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`poe_disabled expected to be basetypes.BoolValue, was: %T`, poeDisabledAttribute))
	}

	poeModeAttribute, ok := attributes["poe_mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`poe_mode is missing from object`)

		return NewPortsValueUnknown(), diags
	}

	poeModeVal, ok := poeModeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`poe_mode expected to be basetypes.StringValue, was: %T`, poeModeAttribute))
	}

	poeOnAttribute, ok := attributes["poe_on"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`poe_on is missing from object`)

		return NewPortsValueUnknown(), diags
	}

	poeOnVal, ok := poeOnAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`poe_on expected to be basetypes.BoolValue, was: %T`, poeOnAttribute))
	}

	portIdAttribute, ok := attributes["port_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_id is missing from object`)

		return NewPortsValueUnknown(), diags
	}

	portIdVal, ok := portIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_id expected to be basetypes.StringValue, was: %T`, portIdAttribute))
	}

	portMacAttribute, ok := attributes["port_mac"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_mac is missing from object`)

		return NewPortsValueUnknown(), diags
	}

	portMacVal, ok := portMacAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_mac expected to be basetypes.StringValue, was: %T`, portMacAttribute))
	}

	portUsageAttribute, ok := attributes["port_usage"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_usage is missing from object`)

		return NewPortsValueUnknown(), diags
	}

	portUsageVal, ok := portUsageAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_usage expected to be basetypes.StringValue, was: %T`, portUsageAttribute))
	}

	powerDrawAttribute, ok := attributes["power_draw"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`power_draw is missing from object`)

		return NewPortsValueUnknown(), diags
	}

	powerDrawVal, ok := powerDrawAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`power_draw expected to be basetypes.NumberValue, was: %T`, powerDrawAttribute))
	}

	rxBcastPktsAttribute, ok := attributes["rx_bcast_pkts"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rx_bcast_pkts is missing from object`)

		return NewPortsValueUnknown(), diags
	}

	rxBcastPktsVal, ok := rxBcastPktsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rx_bcast_pkts expected to be basetypes.Int64Value, was: %T`, rxBcastPktsAttribute))
	}

	rxBpsAttribute, ok := attributes["rx_bps"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rx_bps is missing from object`)

		return NewPortsValueUnknown(), diags
	}

	rxBpsVal, ok := rxBpsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rx_bps expected to be basetypes.Int64Value, was: %T`, rxBpsAttribute))
	}

	rxBytesAttribute, ok := attributes["rx_bytes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rx_bytes is missing from object`)

		return NewPortsValueUnknown(), diags
	}

	rxBytesVal, ok := rxBytesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rx_bytes expected to be basetypes.Int64Value, was: %T`, rxBytesAttribute))
	}

	rxErrorsAttribute, ok := attributes["rx_errors"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rx_errors is missing from object`)

		return NewPortsValueUnknown(), diags
	}

	rxErrorsVal, ok := rxErrorsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rx_errors expected to be basetypes.Int64Value, was: %T`, rxErrorsAttribute))
	}

	rxMcastPktsAttribute, ok := attributes["rx_mcast_pkts"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rx_mcast_pkts is missing from object`)

		return NewPortsValueUnknown(), diags
	}

	rxMcastPktsVal, ok := rxMcastPktsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rx_mcast_pkts expected to be basetypes.Int64Value, was: %T`, rxMcastPktsAttribute))
	}

	rxPktsAttribute, ok := attributes["rx_pkts"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rx_pkts is missing from object`)

		return NewPortsValueUnknown(), diags
	}

	rxPktsVal, ok := rxPktsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rx_pkts expected to be basetypes.Int64Value, was: %T`, rxPktsAttribute))
	}

	speedAttribute, ok := attributes["speed"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`speed is missing from object`)

		return NewPortsValueUnknown(), diags
	}

	speedVal, ok := speedAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`speed expected to be basetypes.Int64Value, was: %T`, speedAttribute))
	}

	stpRoleAttribute, ok := attributes["stp_role"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`stp_role is missing from object`)

		return NewPortsValueUnknown(), diags
	}

	stpRoleVal, ok := stpRoleAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`stp_role expected to be basetypes.StringValue, was: %T`, stpRoleAttribute))
	}

	stpStateAttribute, ok := attributes["stp_state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`stp_state is missing from object`)

		return NewPortsValueUnknown(), diags
	}

	stpStateVal, ok := stpStateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`stp_state expected to be basetypes.StringValue, was: %T`, stpStateAttribute))
	}

	txBcastPktsAttribute, ok := attributes["tx_bcast_pkts"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tx_bcast_pkts is missing from object`)

		return NewPortsValueUnknown(), diags
	}

	txBcastPktsVal, ok := txBcastPktsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tx_bcast_pkts expected to be basetypes.Int64Value, was: %T`, txBcastPktsAttribute))
	}

	txBpsAttribute, ok := attributes["tx_bps"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tx_bps is missing from object`)

		return NewPortsValueUnknown(), diags
	}

	txBpsVal, ok := txBpsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tx_bps expected to be basetypes.Int64Value, was: %T`, txBpsAttribute))
	}

	txBytesAttribute, ok := attributes["tx_bytes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tx_bytes is missing from object`)

		return NewPortsValueUnknown(), diags
	}

	txBytesVal, ok := txBytesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tx_bytes expected to be basetypes.Int64Value, was: %T`, txBytesAttribute))
	}

	txErrorsAttribute, ok := attributes["tx_errors"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tx_errors is missing from object`)

		return NewPortsValueUnknown(), diags
	}

	txErrorsVal, ok := txErrorsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tx_errors expected to be basetypes.Int64Value, was: %T`, txErrorsAttribute))
	}

	txMcastPktsAttribute, ok := attributes["tx_mcast_pkts"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tx_mcast_pkts is missing from object`)

		return NewPortsValueUnknown(), diags
	}

	txMcastPktsVal, ok := txMcastPktsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tx_mcast_pkts expected to be basetypes.Int64Value, was: %T`, txMcastPktsAttribute))
	}

	txPktsAttribute, ok := attributes["tx_pkts"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tx_pkts is missing from object`)

		return NewPortsValueUnknown(), diags
	}

	txPktsVal, ok := txPktsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tx_pkts expected to be basetypes.Int64Value, was: %T`, txPktsAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewPortsValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	unconfiguredAttribute, ok := attributes["unconfigured"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`unconfigured is missing from object`)

		return NewPortsValueUnknown(), diags
	}

	unconfiguredVal, ok := unconfiguredAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`unconfigured expected to be basetypes.BoolValue, was: %T`, unconfiguredAttribute))
	}

	upAttribute, ok := attributes["up"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`up is missing from object`)

		return NewPortsValueUnknown(), diags
	}

	upVal, ok := upAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`up expected to be basetypes.BoolValue, was: %T`, upAttribute))
	}

	xcvrModelAttribute, ok := attributes["xcvr_model"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`xcvr_model is missing from object`)

		return NewPortsValueUnknown(), diags
	}

	xcvrModelVal, ok := xcvrModelAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`xcvr_model expected to be basetypes.StringValue, was: %T`, xcvrModelAttribute))
	}

	xcvrPartNumberAttribute, ok := attributes["xcvr_part_number"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`xcvr_part_number is missing from object`)

		return NewPortsValueUnknown(), diags
	}

	xcvrPartNumberVal, ok := xcvrPartNumberAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`xcvr_part_number expected to be basetypes.StringValue, was: %T`, xcvrPartNumberAttribute))
	}

	xcvrSerialAttribute, ok := attributes["xcvr_serial"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`xcvr_serial is missing from object`)

		return NewPortsValueUnknown(), diags
	}

	xcvrSerialVal, ok := xcvrSerialAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`xcvr_serial expected to be basetypes.StringValue, was: %T`, xcvrSerialAttribute))
	}

	if diags.HasError() {
		return NewPortsValueUnknown(), diags
	}

	return PortsValue{
		Active:             activeVal,
		AuthState:          authStateVal,
		Disabled:           disabledVal,
		ForSite:            forSiteVal,
		FullDuplex:         fullDuplexVal,
		Jitter:             jitterVal,
		Latency:            latencyVal,
		Loss:               lossVal,
		LteIccid:           lteIccidVal,
		LteImei:            lteImeiVal,
		LteImsi:            lteImsiVal,
		MacCount:           macCountVal,
		MacLimit:           macLimitVal,
		NeighborMac:        neighborMacVal,
		NeighborPortDesc:   neighborPortDescVal,
		NeighborSystemName: neighborSystemNameVal,
		PoeDisabled:        poeDisabledVal,
		PoeMode:            poeModeVal,
		PoeOn:              poeOnVal,
		PortId:             portIdVal,
		PortMac:            portMacVal,
		PortUsage:          portUsageVal,
		PowerDraw:          powerDrawVal,
		RxBcastPkts:        rxBcastPktsVal,
		RxBps:              rxBpsVal,
		RxBytes:            rxBytesVal,
		RxErrors:           rxErrorsVal,
		RxMcastPkts:        rxMcastPktsVal,
		RxPkts:             rxPktsVal,
		Speed:              speedVal,
		StpRole:            stpRoleVal,
		StpState:           stpStateVal,
		TxBcastPkts:        txBcastPktsVal,
		TxBps:              txBpsVal,
		TxBytes:            txBytesVal,
		TxErrors:           txErrorsVal,
		TxMcastPkts:        txMcastPktsVal,
		TxPkts:             txPktsVal,
		PortsType:          typeVal,
		Unconfigured:       unconfiguredVal,
		Up:                 upVal,
		XcvrModel:          xcvrModelVal,
		XcvrPartNumber:     xcvrPartNumberVal,
		XcvrSerial:         xcvrSerialVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewPortsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PortsValue {
	object, diags := NewPortsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPortsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PortsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPortsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPortsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPortsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPortsValueMust(PortsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PortsType) ValueType(ctx context.Context) attr.Value {
	return PortsValue{}
}

var _ basetypes.ObjectValuable = PortsValue{}

type PortsValue struct {
	Active             basetypes.BoolValue   `tfsdk:"active"`
	AuthState          basetypes.StringValue `tfsdk:"auth_state"`
	Disabled           basetypes.BoolValue   `tfsdk:"disabled"`
	ForSite            basetypes.BoolValue   `tfsdk:"for_site"`
	FullDuplex         basetypes.BoolValue   `tfsdk:"full_duplex"`
	Jitter             basetypes.NumberValue `tfsdk:"jitter"`
	Latency            basetypes.NumberValue `tfsdk:"latency"`
	Loss               basetypes.NumberValue `tfsdk:"loss"`
	LteIccid           basetypes.StringValue `tfsdk:"lte_iccid"`
	LteImei            basetypes.StringValue `tfsdk:"lte_imei"`
	LteImsi            basetypes.StringValue `tfsdk:"lte_imsi"`
	MacCount           basetypes.Int64Value  `tfsdk:"mac_count"`
	MacLimit           basetypes.Int64Value  `tfsdk:"mac_limit"`
	NeighborMac        basetypes.StringValue `tfsdk:"neighbor_mac"`
	NeighborPortDesc   basetypes.StringValue `tfsdk:"neighbor_port_desc"`
	NeighborSystemName basetypes.StringValue `tfsdk:"neighbor_system_name"`
	PoeDisabled        basetypes.BoolValue   `tfsdk:"poe_disabled"`
	PoeMode            basetypes.StringValue `tfsdk:"poe_mode"`
	PoeOn              basetypes.BoolValue   `tfsdk:"poe_on"`
	PortId             basetypes.StringValue `tfsdk:"port_id"`
	PortMac            basetypes.StringValue `tfsdk:"port_mac"`
	PortUsage          basetypes.StringValue `tfsdk:"port_usage"`
	PowerDraw          basetypes.NumberValue `tfsdk:"power_draw"`
	RxBcastPkts        basetypes.Int64Value  `tfsdk:"rx_bcast_pkts"`
	RxBps              basetypes.Int64Value  `tfsdk:"rx_bps"`
	RxBytes            basetypes.Int64Value  `tfsdk:"rx_bytes"`
	RxErrors           basetypes.Int64Value  `tfsdk:"rx_errors"`
	RxMcastPkts        basetypes.Int64Value  `tfsdk:"rx_mcast_pkts"`
	RxPkts             basetypes.Int64Value  `tfsdk:"rx_pkts"`
	Speed              basetypes.Int64Value  `tfsdk:"speed"`
	StpRole            basetypes.StringValue `tfsdk:"stp_role"`
	StpState           basetypes.StringValue `tfsdk:"stp_state"`
	TxBcastPkts        basetypes.Int64Value  `tfsdk:"tx_bcast_pkts"`
	TxBps              basetypes.Int64Value  `tfsdk:"tx_bps"`
	TxBytes            basetypes.Int64Value  `tfsdk:"tx_bytes"`
	TxErrors           basetypes.Int64Value  `tfsdk:"tx_errors"`
	TxMcastPkts        basetypes.Int64Value  `tfsdk:"tx_mcast_pkts"`
	TxPkts             basetypes.Int64Value  `tfsdk:"tx_pkts"`
	PortsType          basetypes.StringValue `tfsdk:"type"`
	Unconfigured       basetypes.BoolValue   `tfsdk:"unconfigured"`
	Up                 basetypes.BoolValue   `tfsdk:"up"`
	XcvrModel          basetypes.StringValue `tfsdk:"xcvr_model"`
	XcvrPartNumber     basetypes.StringValue `tfsdk:"xcvr_part_number"`
	XcvrSerial         basetypes.StringValue `tfsdk:"xcvr_serial"`
	state              attr.ValueState
}

func (v PortsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 44)

	var val tftypes.Value
	var err error

	attrTypes["active"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["auth_state"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["disabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["for_site"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["full_duplex"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["jitter"] = basetypes.NumberType{}.TerraformType(ctx)
	attrTypes["latency"] = basetypes.NumberType{}.TerraformType(ctx)
	attrTypes["loss"] = basetypes.NumberType{}.TerraformType(ctx)
	attrTypes["lte_iccid"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["lte_imei"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["lte_imsi"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["mac_count"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["mac_limit"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["neighbor_mac"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["neighbor_port_desc"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["neighbor_system_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["poe_disabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["poe_mode"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["poe_on"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["port_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["port_mac"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["port_usage"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["power_draw"] = basetypes.NumberType{}.TerraformType(ctx)
	attrTypes["rx_bcast_pkts"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["rx_bps"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["rx_bytes"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["rx_errors"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["rx_mcast_pkts"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["rx_pkts"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["speed"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["stp_role"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["stp_state"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["tx_bcast_pkts"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["tx_bps"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["tx_bytes"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["tx_errors"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["tx_mcast_pkts"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["tx_pkts"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["unconfigured"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["up"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["xcvr_model"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["xcvr_part_number"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["xcvr_serial"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 44)

		val, err = v.Active.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["active"] = val

		val, err = v.AuthState.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["auth_state"] = val

		val, err = v.Disabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["disabled"] = val

		val, err = v.ForSite.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["for_site"] = val

		val, err = v.FullDuplex.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["full_duplex"] = val

		val, err = v.Jitter.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["jitter"] = val

		val, err = v.Latency.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["latency"] = val

		val, err = v.Loss.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["loss"] = val

		val, err = v.LteIccid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["lte_iccid"] = val

		val, err = v.LteImei.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["lte_imei"] = val

		val, err = v.LteImsi.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["lte_imsi"] = val

		val, err = v.MacCount.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mac_count"] = val

		val, err = v.MacLimit.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mac_limit"] = val

		val, err = v.NeighborMac.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["neighbor_mac"] = val

		val, err = v.NeighborPortDesc.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["neighbor_port_desc"] = val

		val, err = v.NeighborSystemName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["neighbor_system_name"] = val

		val, err = v.PoeDisabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["poe_disabled"] = val

		val, err = v.PoeMode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["poe_mode"] = val

		val, err = v.PoeOn.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["poe_on"] = val

		val, err = v.PortId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port_id"] = val

		val, err = v.PortMac.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port_mac"] = val

		val, err = v.PortUsage.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port_usage"] = val

		val, err = v.PowerDraw.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["power_draw"] = val

		val, err = v.RxBcastPkts.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["rx_bcast_pkts"] = val

		val, err = v.RxBps.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["rx_bps"] = val

		val, err = v.RxBytes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["rx_bytes"] = val

		val, err = v.RxErrors.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["rx_errors"] = val

		val, err = v.RxMcastPkts.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["rx_mcast_pkts"] = val

		val, err = v.RxPkts.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["rx_pkts"] = val

		val, err = v.Speed.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["speed"] = val

		val, err = v.StpRole.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["stp_role"] = val

		val, err = v.StpState.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["stp_state"] = val

		val, err = v.TxBcastPkts.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tx_bcast_pkts"] = val

		val, err = v.TxBps.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tx_bps"] = val

		val, err = v.TxBytes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tx_bytes"] = val

		val, err = v.TxErrors.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tx_errors"] = val

		val, err = v.TxMcastPkts.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tx_mcast_pkts"] = val

		val, err = v.TxPkts.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tx_pkts"] = val

		val, err = v.PortsType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		val, err = v.Unconfigured.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["unconfigured"] = val

		val, err = v.Up.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["up"] = val

		val, err = v.XcvrModel.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["xcvr_model"] = val

		val, err = v.XcvrPartNumber.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["xcvr_part_number"] = val

		val, err = v.XcvrSerial.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["xcvr_serial"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PortsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PortsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PortsValue) String() string {
	return "PortsValue"
}

func (v PortsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"active":               basetypes.BoolType{},
		"auth_state":           basetypes.StringType{},
		"disabled":             basetypes.BoolType{},
		"for_site":             basetypes.BoolType{},
		"full_duplex":          basetypes.BoolType{},
		"jitter":               basetypes.NumberType{},
		"latency":              basetypes.NumberType{},
		"loss":                 basetypes.NumberType{},
		"lte_iccid":            basetypes.StringType{},
		"lte_imei":             basetypes.StringType{},
		"lte_imsi":             basetypes.StringType{},
		"mac_count":            basetypes.Int64Type{},
		"mac_limit":            basetypes.Int64Type{},
		"neighbor_mac":         basetypes.StringType{},
		"neighbor_port_desc":   basetypes.StringType{},
		"neighbor_system_name": basetypes.StringType{},
		"poe_disabled":         basetypes.BoolType{},
		"poe_mode":             basetypes.StringType{},
		"poe_on":               basetypes.BoolType{},
		"port_id":              basetypes.StringType{},
		"port_mac":             basetypes.StringType{},
		"port_usage":           basetypes.StringType{},
		"power_draw":           basetypes.NumberType{},
		"rx_bcast_pkts":        basetypes.Int64Type{},
		"rx_bps":               basetypes.Int64Type{},
		"rx_bytes":             basetypes.Int64Type{},
		"rx_errors":            basetypes.Int64Type{},
		"rx_mcast_pkts":        basetypes.Int64Type{},
		"rx_pkts":              basetypes.Int64Type{},
		"speed":                basetypes.Int64Type{},
		"stp_role":             basetypes.StringType{},
		"stp_state":            basetypes.StringType{},
		"tx_bcast_pkts":        basetypes.Int64Type{},
		"tx_bps":               basetypes.Int64Type{},
		"tx_bytes":             basetypes.Int64Type{},
		"tx_errors":            basetypes.Int64Type{},
		"tx_mcast_pkts":        basetypes.Int64Type{},
		"tx_pkts":              basetypes.Int64Type{},
		"type":                 basetypes.StringType{},
		"unconfigured":         basetypes.BoolType{},
		"up":                   basetypes.BoolType{},
		"xcvr_model":           basetypes.StringType{},
		"xcvr_part_number":     basetypes.StringType{},
		"xcvr_serial":          basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"active":               v.Active,
			"auth_state":           v.AuthState,
			"disabled":             v.Disabled,
			"for_site":             v.ForSite,
			"full_duplex":          v.FullDuplex,
			"jitter":               v.Jitter,
			"latency":              v.Latency,
			"loss":                 v.Loss,
			"lte_iccid":            v.LteIccid,
			"lte_imei":             v.LteImei,
			"lte_imsi":             v.LteImsi,
			"mac_count":            v.MacCount,
			"mac_limit":            v.MacLimit,
			"neighbor_mac":         v.NeighborMac,
			"neighbor_port_desc":   v.NeighborPortDesc,
			"neighbor_system_name": v.NeighborSystemName,
			"poe_disabled":         v.PoeDisabled,
			"poe_mode":             v.PoeMode,
			"poe_on":               v.PoeOn,
			"port_id":              v.PortId,
			"port_mac":             v.PortMac,
			"port_usage":           v.PortUsage,
			"power_draw":           v.PowerDraw,
			"rx_bcast_pkts":        v.RxBcastPkts,
			"rx_bps":               v.RxBps,
			"rx_bytes":             v.RxBytes,
			"rx_errors":            v.RxErrors,
			"rx_mcast_pkts":        v.RxMcastPkts,
			"rx_pkts":              v.RxPkts,
			"speed":                v.Speed,
			"stp_role":             v.StpRole,
			"stp_state":            v.StpState,
			"tx_bcast_pkts":        v.TxBcastPkts,
			"tx_bps":               v.TxBps,
			"tx_bytes":             v.TxBytes,
			"tx_errors":            v.TxErrors,
			"tx_mcast_pkts":        v.TxMcastPkts,
			"tx_pkts":              v.TxPkts,
			"type":                 v.PortsType,
			"unconfigured":         v.Unconfigured,
			"up":                   v.Up,
			"xcvr_model":           v.XcvrModel,
			"xcvr_part_number":     v.XcvrPartNumber,
			"xcvr_serial":          v.XcvrSerial,
		})

	return objVal, diags
}

func (v PortsValue) Equal(o attr.Value) bool {
	other, ok := o.(PortsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Active.Equal(other.Active) {
		return false
	}

	if !v.AuthState.Equal(other.AuthState) {
		return false
	}

	if !v.Disabled.Equal(other.Disabled) {
		return false
	}

	if !v.ForSite.Equal(other.ForSite) {
		return false
	}

	if !v.FullDuplex.Equal(other.FullDuplex) {
		return false
	}

	if !v.Jitter.Equal(other.Jitter) {
		return false
	}

	if !v.Latency.Equal(other.Latency) {
		return false
	}

	if !v.Loss.Equal(other.Loss) {
		return false
	}

	if !v.LteIccid.Equal(other.LteIccid) {
		return false
	}

	if !v.LteImei.Equal(other.LteImei) {
		return false
	}

	if !v.LteImsi.Equal(other.LteImsi) {
		return false
	}

	if !v.MacCount.Equal(other.MacCount) {
		return false
	}

	if !v.MacLimit.Equal(other.MacLimit) {
		return false
	}

	if !v.NeighborMac.Equal(other.NeighborMac) {
		return false
	}

	if !v.NeighborPortDesc.Equal(other.NeighborPortDesc) {
		return false
	}

	if !v.NeighborSystemName.Equal(other.NeighborSystemName) {
		return false
	}

	if !v.PoeDisabled.Equal(other.PoeDisabled) {
		return false
	}

	if !v.PoeMode.Equal(other.PoeMode) {
		return false
	}

	if !v.PoeOn.Equal(other.PoeOn) {
		return false
	}

	if !v.PortId.Equal(other.PortId) {
		return false
	}

	if !v.PortMac.Equal(other.PortMac) {
		return false
	}

	if !v.PortUsage.Equal(other.PortUsage) {
		return false
	}

	if !v.PowerDraw.Equal(other.PowerDraw) {
		return false
	}

	if !v.RxBcastPkts.Equal(other.RxBcastPkts) {
		return false
	}

	if !v.RxBps.Equal(other.RxBps) {
		return false
	}

	if !v.RxBytes.Equal(other.RxBytes) {
		return false
	}

	if !v.RxErrors.Equal(other.RxErrors) {
		return false
	}

	if !v.RxMcastPkts.Equal(other.RxMcastPkts) {
		return false
	}

	if !v.RxPkts.Equal(other.RxPkts) {
		return false
	}

	if !v.Speed.Equal(other.Speed) {
		return false
	}

	if !v.StpRole.Equal(other.StpRole) {
		return false
	}

	if !v.StpState.Equal(other.StpState) {
		return false
	}

	if !v.TxBcastPkts.Equal(other.TxBcastPkts) {
		return false
	}

	if !v.TxBps.Equal(other.TxBps) {
		return false
	}

	if !v.TxBytes.Equal(other.TxBytes) {
		return false
	}

	if !v.TxErrors.Equal(other.TxErrors) {
		return false
	}

	if !v.TxMcastPkts.Equal(other.TxMcastPkts) {
		return false
	}

	if !v.TxPkts.Equal(other.TxPkts) {
		return false
	}

	if !v.PortsType.Equal(other.PortsType) {
		return false
	}

	if !v.Unconfigured.Equal(other.Unconfigured) {
		return false
	}

	if !v.Up.Equal(other.Up) {
		return false
	}

	if !v.XcvrModel.Equal(other.XcvrModel) {
		return false
	}

	if !v.XcvrPartNumber.Equal(other.XcvrPartNumber) {
		return false
	}

	if !v.XcvrSerial.Equal(other.XcvrSerial) {
		return false
	}

	return true
}

func (v PortsValue) Type(ctx context.Context) attr.Type {
	return PortsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PortsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"active":               basetypes.BoolType{},
		"auth_state":           basetypes.StringType{},
		"disabled":             basetypes.BoolType{},
		"for_site":             basetypes.BoolType{},
		"full_duplex":          basetypes.BoolType{},
		"jitter":               basetypes.NumberType{},
		"latency":              basetypes.NumberType{},
		"loss":                 basetypes.NumberType{},
		"lte_iccid":            basetypes.StringType{},
		"lte_imei":             basetypes.StringType{},
		"lte_imsi":             basetypes.StringType{},
		"mac_count":            basetypes.Int64Type{},
		"mac_limit":            basetypes.Int64Type{},
		"neighbor_mac":         basetypes.StringType{},
		"neighbor_port_desc":   basetypes.StringType{},
		"neighbor_system_name": basetypes.StringType{},
		"poe_disabled":         basetypes.BoolType{},
		"poe_mode":             basetypes.StringType{},
		"poe_on":               basetypes.BoolType{},
		"port_id":              basetypes.StringType{},
		"port_mac":             basetypes.StringType{},
		"port_usage":           basetypes.StringType{},
		"power_draw":           basetypes.NumberType{},
		"rx_bcast_pkts":        basetypes.Int64Type{},
		"rx_bps":               basetypes.Int64Type{},
		"rx_bytes":             basetypes.Int64Type{},
		"rx_errors":            basetypes.Int64Type{},
		"rx_mcast_pkts":        basetypes.Int64Type{},
		"rx_pkts":              basetypes.Int64Type{},
		"speed":                basetypes.Int64Type{},
		"stp_role":             basetypes.StringType{},
		"stp_state":            basetypes.StringType{},
		"tx_bcast_pkts":        basetypes.Int64Type{},
		"tx_bps":               basetypes.Int64Type{},
		"tx_bytes":             basetypes.Int64Type{},
		"tx_errors":            basetypes.Int64Type{},
		"tx_mcast_pkts":        basetypes.Int64Type{},
		"tx_pkts":              basetypes.Int64Type{},
		"type":                 basetypes.StringType{},
		"unconfigured":         basetypes.BoolType{},
		"up":                   basetypes.BoolType{},
		"xcvr_model":           basetypes.StringType{},
		"xcvr_part_number":     basetypes.StringType{},
		"xcvr_serial":          basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = RouteSummaryStatsType{}

type RouteSummaryStatsType struct {
	basetypes.ObjectType
}

func (t RouteSummaryStatsType) Equal(o attr.Type) bool {
	other, ok := o.(RouteSummaryStatsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t RouteSummaryStatsType) String() string {
	return "RouteSummaryStatsType"
}

func (t RouteSummaryStatsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	fibRoutesAttribute, ok := attributes["fib_routes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fib_routes is missing from object`)

		return nil, diags
	}

	fibRoutesVal, ok := fibRoutesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fib_routes expected to be basetypes.Int64Value, was: %T`, fibRoutesAttribute))
	}

	maxUnicastRoutesSupportedAttribute, ok := attributes["max_unicast_routes_supported"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_unicast_routes_supported is missing from object`)

		return nil, diags
	}

	maxUnicastRoutesSupportedVal, ok := maxUnicastRoutesSupportedAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_unicast_routes_supported expected to be basetypes.Int64Value, was: %T`, maxUnicastRoutesSupportedAttribute))
	}

	ribRoutesAttribute, ok := attributes["rib_routes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rib_routes is missing from object`)

		return nil, diags
	}

	ribRoutesVal, ok := ribRoutesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rib_routes expected to be basetypes.Int64Value, was: %T`, ribRoutesAttribute))
	}

	totalRoutesAttribute, ok := attributes["total_routes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`total_routes is missing from object`)

		return nil, diags
	}

	totalRoutesVal, ok := totalRoutesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`total_routes expected to be basetypes.Int64Value, was: %T`, totalRoutesAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return RouteSummaryStatsValue{
		FibRoutes:                 fibRoutesVal,
		MaxUnicastRoutesSupported: maxUnicastRoutesSupportedVal,
		RibRoutes:                 ribRoutesVal,
		TotalRoutes:               totalRoutesVal,
		state:                     attr.ValueStateKnown,
	}, diags
}

func NewRouteSummaryStatsValueNull() RouteSummaryStatsValue {
	return RouteSummaryStatsValue{
		state: attr.ValueStateNull,
	}
}

func NewRouteSummaryStatsValueUnknown() RouteSummaryStatsValue {
	return RouteSummaryStatsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewRouteSummaryStatsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (RouteSummaryStatsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing RouteSummaryStatsValue Attribute Value",
				"While creating a RouteSummaryStatsValue value, a missing attribute value was detected. "+
					"A RouteSummaryStatsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RouteSummaryStatsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid RouteSummaryStatsValue Attribute Type",
				"While creating a RouteSummaryStatsValue value, an invalid attribute value was detected. "+
					"A RouteSummaryStatsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RouteSummaryStatsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("RouteSummaryStatsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra RouteSummaryStatsValue Attribute Value",
				"While creating a RouteSummaryStatsValue value, an extra attribute value was detected. "+
					"A RouteSummaryStatsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra RouteSummaryStatsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewRouteSummaryStatsValueUnknown(), diags
	}

	fibRoutesAttribute, ok := attributes["fib_routes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fib_routes is missing from object`)

		return NewRouteSummaryStatsValueUnknown(), diags
	}

	fibRoutesVal, ok := fibRoutesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fib_routes expected to be basetypes.Int64Value, was: %T`, fibRoutesAttribute))
	}

	maxUnicastRoutesSupportedAttribute, ok := attributes["max_unicast_routes_supported"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_unicast_routes_supported is missing from object`)

		return NewRouteSummaryStatsValueUnknown(), diags
	}

	maxUnicastRoutesSupportedVal, ok := maxUnicastRoutesSupportedAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_unicast_routes_supported expected to be basetypes.Int64Value, was: %T`, maxUnicastRoutesSupportedAttribute))
	}

	ribRoutesAttribute, ok := attributes["rib_routes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rib_routes is missing from object`)

		return NewRouteSummaryStatsValueUnknown(), diags
	}

	ribRoutesVal, ok := ribRoutesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rib_routes expected to be basetypes.Int64Value, was: %T`, ribRoutesAttribute))
	}

	totalRoutesAttribute, ok := attributes["total_routes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`total_routes is missing from object`)

		return NewRouteSummaryStatsValueUnknown(), diags
	}

	totalRoutesVal, ok := totalRoutesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`total_routes expected to be basetypes.Int64Value, was: %T`, totalRoutesAttribute))
	}

	if diags.HasError() {
		return NewRouteSummaryStatsValueUnknown(), diags
	}

	return RouteSummaryStatsValue{
		FibRoutes:                 fibRoutesVal,
		MaxUnicastRoutesSupported: maxUnicastRoutesSupportedVal,
		RibRoutes:                 ribRoutesVal,
		TotalRoutes:               totalRoutesVal,
		state:                     attr.ValueStateKnown,
	}, diags
}

func NewRouteSummaryStatsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) RouteSummaryStatsValue {
	object, diags := NewRouteSummaryStatsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewRouteSummaryStatsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t RouteSummaryStatsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewRouteSummaryStatsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewRouteSummaryStatsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewRouteSummaryStatsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewRouteSummaryStatsValueMust(RouteSummaryStatsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t RouteSummaryStatsType) ValueType(ctx context.Context) attr.Value {
	return RouteSummaryStatsValue{}
}

var _ basetypes.ObjectValuable = RouteSummaryStatsValue{}

type RouteSummaryStatsValue struct {
	FibRoutes                 basetypes.Int64Value `tfsdk:"fib_routes"`
	MaxUnicastRoutesSupported basetypes.Int64Value `tfsdk:"max_unicast_routes_supported"`
	RibRoutes                 basetypes.Int64Value `tfsdk:"rib_routes"`
	TotalRoutes               basetypes.Int64Value `tfsdk:"total_routes"`
	state                     attr.ValueState
}

func (v RouteSummaryStatsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["fib_routes"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["max_unicast_routes_supported"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["rib_routes"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["total_routes"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.FibRoutes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["fib_routes"] = val

		val, err = v.MaxUnicastRoutesSupported.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_unicast_routes_supported"] = val

		val, err = v.RibRoutes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["rib_routes"] = val

		val, err = v.TotalRoutes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["total_routes"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v RouteSummaryStatsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v RouteSummaryStatsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v RouteSummaryStatsValue) String() string {
	return "RouteSummaryStatsValue"
}

func (v RouteSummaryStatsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"fib_routes":                   basetypes.Int64Type{},
		"max_unicast_routes_supported": basetypes.Int64Type{},
		"rib_routes":                   basetypes.Int64Type{},
		"total_routes":                 basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"fib_routes":                   v.FibRoutes,
			"max_unicast_routes_supported": v.MaxUnicastRoutesSupported,
			"rib_routes":                   v.RibRoutes,
			"total_routes":                 v.TotalRoutes,
		})

	return objVal, diags
}

func (v RouteSummaryStatsValue) Equal(o attr.Value) bool {
	other, ok := o.(RouteSummaryStatsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.FibRoutes.Equal(other.FibRoutes) {
		return false
	}

	if !v.MaxUnicastRoutesSupported.Equal(other.MaxUnicastRoutesSupported) {
		return false
	}

	if !v.RibRoutes.Equal(other.RibRoutes) {
		return false
	}

	if !v.TotalRoutes.Equal(other.TotalRoutes) {
		return false
	}

	return true
}

func (v RouteSummaryStatsValue) Type(ctx context.Context) attr.Type {
	return RouteSummaryStatsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v RouteSummaryStatsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"fib_routes":                   basetypes.Int64Type{},
		"max_unicast_routes_supported": basetypes.Int64Type{},
		"rib_routes":                   basetypes.Int64Type{},
		"total_routes":                 basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = ServiceStatType{}

type ServiceStatType struct {
	basetypes.ObjectType
}

func (t ServiceStatType) Equal(o attr.Type) bool {
	other, ok := o.(ServiceStatType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ServiceStatType) String() string {
	return "ServiceStatType"
}

func (t ServiceStatType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	ashVersionAttribute, ok := attributes["ash_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ash_version is missing from object`)

		return nil, diags
	}

	ashVersionVal, ok := ashVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ash_version expected to be basetypes.StringValue, was: %T`, ashVersionAttribute))
	}

	ciaVersionAttribute, ok := attributes["cia_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cia_version is missing from object`)

		return nil, diags
	}

	ciaVersionVal, ok := ciaVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cia_version expected to be basetypes.StringValue, was: %T`, ciaVersionAttribute))
	}

	emberVersionAttribute, ok := attributes["ember_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ember_version is missing from object`)

		return nil, diags
	}

	emberVersionVal, ok := emberVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ember_version expected to be basetypes.StringValue, was: %T`, emberVersionAttribute))
	}

	ipsecClientVersionAttribute, ok := attributes["ipsec_client_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipsec_client_version is missing from object`)

		return nil, diags
	}

	ipsecClientVersionVal, ok := ipsecClientVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipsec_client_version expected to be basetypes.StringValue, was: %T`, ipsecClientVersionAttribute))
	}

	mistAgentVersionAttribute, ok := attributes["mist_agent_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mist_agent_version is missing from object`)

		return nil, diags
	}

	mistAgentVersionVal, ok := mistAgentVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mist_agent_version expected to be basetypes.StringValue, was: %T`, mistAgentVersionAttribute))
	}

	packageVersionAttribute, ok := attributes["package_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`package_version is missing from object`)

		return nil, diags
	}

	packageVersionVal, ok := packageVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`package_version expected to be basetypes.StringValue, was: %T`, packageVersionAttribute))
	}

	testingToolsVersionAttribute, ok := attributes["testing_tools_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`testing_tools_version is missing from object`)

		return nil, diags
	}

	testingToolsVersionVal, ok := testingToolsVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`testing_tools_version expected to be basetypes.StringValue, was: %T`, testingToolsVersionAttribute))
	}

	wheeljackVersionAttribute, ok := attributes["wheeljack_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wheeljack_version is missing from object`)

		return nil, diags
	}

	wheeljackVersionVal, ok := wheeljackVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wheeljack_version expected to be basetypes.StringValue, was: %T`, wheeljackVersionAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ServiceStatValue{
		AshVersion:          ashVersionVal,
		CiaVersion:          ciaVersionVal,
		EmberVersion:        emberVersionVal,
		IpsecClientVersion:  ipsecClientVersionVal,
		MistAgentVersion:    mistAgentVersionVal,
		PackageVersion:      packageVersionVal,
		TestingToolsVersion: testingToolsVersionVal,
		WheeljackVersion:    wheeljackVersionVal,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewServiceStatValueNull() ServiceStatValue {
	return ServiceStatValue{
		state: attr.ValueStateNull,
	}
}

func NewServiceStatValueUnknown() ServiceStatValue {
	return ServiceStatValue{
		state: attr.ValueStateUnknown,
	}
}

func NewServiceStatValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ServiceStatValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ServiceStatValue Attribute Value",
				"While creating a ServiceStatValue value, a missing attribute value was detected. "+
					"A ServiceStatValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ServiceStatValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ServiceStatValue Attribute Type",
				"While creating a ServiceStatValue value, an invalid attribute value was detected. "+
					"A ServiceStatValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ServiceStatValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ServiceStatValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ServiceStatValue Attribute Value",
				"While creating a ServiceStatValue value, an extra attribute value was detected. "+
					"A ServiceStatValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ServiceStatValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewServiceStatValueUnknown(), diags
	}

	ashVersionAttribute, ok := attributes["ash_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ash_version is missing from object`)

		return NewServiceStatValueUnknown(), diags
	}

	ashVersionVal, ok := ashVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ash_version expected to be basetypes.StringValue, was: %T`, ashVersionAttribute))
	}

	ciaVersionAttribute, ok := attributes["cia_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cia_version is missing from object`)

		return NewServiceStatValueUnknown(), diags
	}

	ciaVersionVal, ok := ciaVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cia_version expected to be basetypes.StringValue, was: %T`, ciaVersionAttribute))
	}

	emberVersionAttribute, ok := attributes["ember_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ember_version is missing from object`)

		return NewServiceStatValueUnknown(), diags
	}

	emberVersionVal, ok := emberVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ember_version expected to be basetypes.StringValue, was: %T`, emberVersionAttribute))
	}

	ipsecClientVersionAttribute, ok := attributes["ipsec_client_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipsec_client_version is missing from object`)

		return NewServiceStatValueUnknown(), diags
	}

	ipsecClientVersionVal, ok := ipsecClientVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipsec_client_version expected to be basetypes.StringValue, was: %T`, ipsecClientVersionAttribute))
	}

	mistAgentVersionAttribute, ok := attributes["mist_agent_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mist_agent_version is missing from object`)

		return NewServiceStatValueUnknown(), diags
	}

	mistAgentVersionVal, ok := mistAgentVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mist_agent_version expected to be basetypes.StringValue, was: %T`, mistAgentVersionAttribute))
	}

	packageVersionAttribute, ok := attributes["package_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`package_version is missing from object`)

		return NewServiceStatValueUnknown(), diags
	}

	packageVersionVal, ok := packageVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`package_version expected to be basetypes.StringValue, was: %T`, packageVersionAttribute))
	}

	testingToolsVersionAttribute, ok := attributes["testing_tools_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`testing_tools_version is missing from object`)

		return NewServiceStatValueUnknown(), diags
	}

	testingToolsVersionVal, ok := testingToolsVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`testing_tools_version expected to be basetypes.StringValue, was: %T`, testingToolsVersionAttribute))
	}

	wheeljackVersionAttribute, ok := attributes["wheeljack_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wheeljack_version is missing from object`)

		return NewServiceStatValueUnknown(), diags
	}

	wheeljackVersionVal, ok := wheeljackVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wheeljack_version expected to be basetypes.StringValue, was: %T`, wheeljackVersionAttribute))
	}

	if diags.HasError() {
		return NewServiceStatValueUnknown(), diags
	}

	return ServiceStatValue{
		AshVersion:          ashVersionVal,
		CiaVersion:          ciaVersionVal,
		EmberVersion:        emberVersionVal,
		IpsecClientVersion:  ipsecClientVersionVal,
		MistAgentVersion:    mistAgentVersionVal,
		PackageVersion:      packageVersionVal,
		TestingToolsVersion: testingToolsVersionVal,
		WheeljackVersion:    wheeljackVersionVal,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewServiceStatValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ServiceStatValue {
	object, diags := NewServiceStatValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewServiceStatValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ServiceStatType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewServiceStatValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewServiceStatValueUnknown(), nil
	}

	if in.IsNull() {
		return NewServiceStatValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewServiceStatValueMust(ServiceStatValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ServiceStatType) ValueType(ctx context.Context) attr.Value {
	return ServiceStatValue{}
}

var _ basetypes.ObjectValuable = ServiceStatValue{}

type ServiceStatValue struct {
	AshVersion          basetypes.StringValue `tfsdk:"ash_version"`
	CiaVersion          basetypes.StringValue `tfsdk:"cia_version"`
	EmberVersion        basetypes.StringValue `tfsdk:"ember_version"`
	IpsecClientVersion  basetypes.StringValue `tfsdk:"ipsec_client_version"`
	MistAgentVersion    basetypes.StringValue `tfsdk:"mist_agent_version"`
	PackageVersion      basetypes.StringValue `tfsdk:"package_version"`
	TestingToolsVersion basetypes.StringValue `tfsdk:"testing_tools_version"`
	WheeljackVersion    basetypes.StringValue `tfsdk:"wheeljack_version"`
	state               attr.ValueState
}

func (v ServiceStatValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 8)

	var val tftypes.Value
	var err error

	attrTypes["ash_version"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["cia_version"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ember_version"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ipsec_client_version"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["mist_agent_version"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["package_version"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["testing_tools_version"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["wheeljack_version"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 8)

		val, err = v.AshVersion.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ash_version"] = val

		val, err = v.CiaVersion.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cia_version"] = val

		val, err = v.EmberVersion.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ember_version"] = val

		val, err = v.IpsecClientVersion.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ipsec_client_version"] = val

		val, err = v.MistAgentVersion.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mist_agent_version"] = val

		val, err = v.PackageVersion.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["package_version"] = val

		val, err = v.TestingToolsVersion.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["testing_tools_version"] = val

		val, err = v.WheeljackVersion.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["wheeljack_version"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ServiceStatValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ServiceStatValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ServiceStatValue) String() string {
	return "ServiceStatValue"
}

func (v ServiceStatValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"ash_version":           basetypes.StringType{},
		"cia_version":           basetypes.StringType{},
		"ember_version":         basetypes.StringType{},
		"ipsec_client_version":  basetypes.StringType{},
		"mist_agent_version":    basetypes.StringType{},
		"package_version":       basetypes.StringType{},
		"testing_tools_version": basetypes.StringType{},
		"wheeljack_version":     basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"ash_version":           v.AshVersion,
			"cia_version":           v.CiaVersion,
			"ember_version":         v.EmberVersion,
			"ipsec_client_version":  v.IpsecClientVersion,
			"mist_agent_version":    v.MistAgentVersion,
			"package_version":       v.PackageVersion,
			"testing_tools_version": v.TestingToolsVersion,
			"wheeljack_version":     v.WheeljackVersion,
		})

	return objVal, diags
}

func (v ServiceStatValue) Equal(o attr.Value) bool {
	other, ok := o.(ServiceStatValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AshVersion.Equal(other.AshVersion) {
		return false
	}

	if !v.CiaVersion.Equal(other.CiaVersion) {
		return false
	}

	if !v.EmberVersion.Equal(other.EmberVersion) {
		return false
	}

	if !v.IpsecClientVersion.Equal(other.IpsecClientVersion) {
		return false
	}

	if !v.MistAgentVersion.Equal(other.MistAgentVersion) {
		return false
	}

	if !v.PackageVersion.Equal(other.PackageVersion) {
		return false
	}

	if !v.TestingToolsVersion.Equal(other.TestingToolsVersion) {
		return false
	}

	if !v.WheeljackVersion.Equal(other.WheeljackVersion) {
		return false
	}

	return true
}

func (v ServiceStatValue) Type(ctx context.Context) attr.Type {
	return ServiceStatType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ServiceStatValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"ash_version":           basetypes.StringType{},
		"cia_version":           basetypes.StringType{},
		"ember_version":         basetypes.StringType{},
		"ipsec_client_version":  basetypes.StringType{},
		"mist_agent_version":    basetypes.StringType{},
		"package_version":       basetypes.StringType{},
		"testing_tools_version": basetypes.StringType{},
		"wheeljack_version":     basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = ServiceStatusType{}

type ServiceStatusType struct {
	basetypes.ObjectType
}

func (t ServiceStatusType) Equal(o attr.Type) bool {
	other, ok := o.(ServiceStatusType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ServiceStatusType) String() string {
	return "ServiceStatusType"
}

func (t ServiceStatusType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	appidInstallResultAttribute, ok := attributes["appid_install_result"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`appid_install_result is missing from object`)

		return nil, diags
	}

	appidInstallResultVal, ok := appidInstallResultAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`appid_install_result expected to be basetypes.StringValue, was: %T`, appidInstallResultAttribute))
	}

	appidInstallTimestampAttribute, ok := attributes["appid_install_timestamp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`appid_install_timestamp is missing from object`)

		return nil, diags
	}

	appidInstallTimestampVal, ok := appidInstallTimestampAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`appid_install_timestamp expected to be basetypes.StringValue, was: %T`, appidInstallTimestampAttribute))
	}

	appidStatusAttribute, ok := attributes["appid_status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`appid_status is missing from object`)

		return nil, diags
	}

	appidStatusVal, ok := appidStatusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`appid_status expected to be basetypes.StringValue, was: %T`, appidStatusAttribute))
	}

	appidVersionAttribute, ok := attributes["appid_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`appid_version is missing from object`)

		return nil, diags
	}

	appidVersionVal, ok := appidVersionAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`appid_version expected to be basetypes.Int64Value, was: %T`, appidVersionAttribute))
	}

	ewfStatusAttribute, ok := attributes["ewf_status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ewf_status is missing from object`)

		return nil, diags
	}

	ewfStatusVal, ok := ewfStatusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ewf_status expected to be basetypes.StringValue, was: %T`, ewfStatusAttribute))
	}

	idpInstallResultAttribute, ok := attributes["idp_install_result"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`idp_install_result is missing from object`)

		return nil, diags
	}

	idpInstallResultVal, ok := idpInstallResultAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`idp_install_result expected to be basetypes.StringValue, was: %T`, idpInstallResultAttribute))
	}

	idpInstallTimestampAttribute, ok := attributes["idp_install_timestamp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`idp_install_timestamp is missing from object`)

		return nil, diags
	}

	idpInstallTimestampVal, ok := idpInstallTimestampAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`idp_install_timestamp expected to be basetypes.StringValue, was: %T`, idpInstallTimestampAttribute))
	}

	idpPolicyAttribute, ok := attributes["idp_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`idp_policy is missing from object`)

		return nil, diags
	}

	idpPolicyVal, ok := idpPolicyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`idp_policy expected to be basetypes.StringValue, was: %T`, idpPolicyAttribute))
	}

	idpStatusAttribute, ok := attributes["idp_status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`idp_status is missing from object`)

		return nil, diags
	}

	idpStatusVal, ok := idpStatusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`idp_status expected to be basetypes.StringValue, was: %T`, idpStatusAttribute))
	}

	idpUpdateTimestampAttribute, ok := attributes["idp_update_timestamp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`idp_update_timestamp is missing from object`)

		return nil, diags
	}

	idpUpdateTimestampVal, ok := idpUpdateTimestampAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`idp_update_timestamp expected to be basetypes.StringValue, was: %T`, idpUpdateTimestampAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ServiceStatusValue{
		AppidInstallResult:    appidInstallResultVal,
		AppidInstallTimestamp: appidInstallTimestampVal,
		AppidStatus:           appidStatusVal,
		AppidVersion:          appidVersionVal,
		EwfStatus:             ewfStatusVal,
		IdpInstallResult:      idpInstallResultVal,
		IdpInstallTimestamp:   idpInstallTimestampVal,
		IdpPolicy:             idpPolicyVal,
		IdpStatus:             idpStatusVal,
		IdpUpdateTimestamp:    idpUpdateTimestampVal,
		state:                 attr.ValueStateKnown,
	}, diags
}

func NewServiceStatusValueNull() ServiceStatusValue {
	return ServiceStatusValue{
		state: attr.ValueStateNull,
	}
}

func NewServiceStatusValueUnknown() ServiceStatusValue {
	return ServiceStatusValue{
		state: attr.ValueStateUnknown,
	}
}

func NewServiceStatusValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ServiceStatusValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ServiceStatusValue Attribute Value",
				"While creating a ServiceStatusValue value, a missing attribute value was detected. "+
					"A ServiceStatusValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ServiceStatusValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ServiceStatusValue Attribute Type",
				"While creating a ServiceStatusValue value, an invalid attribute value was detected. "+
					"A ServiceStatusValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ServiceStatusValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ServiceStatusValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ServiceStatusValue Attribute Value",
				"While creating a ServiceStatusValue value, an extra attribute value was detected. "+
					"A ServiceStatusValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ServiceStatusValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewServiceStatusValueUnknown(), diags
	}

	appidInstallResultAttribute, ok := attributes["appid_install_result"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`appid_install_result is missing from object`)

		return NewServiceStatusValueUnknown(), diags
	}

	appidInstallResultVal, ok := appidInstallResultAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`appid_install_result expected to be basetypes.StringValue, was: %T`, appidInstallResultAttribute))
	}

	appidInstallTimestampAttribute, ok := attributes["appid_install_timestamp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`appid_install_timestamp is missing from object`)

		return NewServiceStatusValueUnknown(), diags
	}

	appidInstallTimestampVal, ok := appidInstallTimestampAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`appid_install_timestamp expected to be basetypes.StringValue, was: %T`, appidInstallTimestampAttribute))
	}

	appidStatusAttribute, ok := attributes["appid_status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`appid_status is missing from object`)

		return NewServiceStatusValueUnknown(), diags
	}

	appidStatusVal, ok := appidStatusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`appid_status expected to be basetypes.StringValue, was: %T`, appidStatusAttribute))
	}

	appidVersionAttribute, ok := attributes["appid_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`appid_version is missing from object`)

		return NewServiceStatusValueUnknown(), diags
	}

	appidVersionVal, ok := appidVersionAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`appid_version expected to be basetypes.Int64Value, was: %T`, appidVersionAttribute))
	}

	ewfStatusAttribute, ok := attributes["ewf_status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ewf_status is missing from object`)

		return NewServiceStatusValueUnknown(), diags
	}

	ewfStatusVal, ok := ewfStatusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ewf_status expected to be basetypes.StringValue, was: %T`, ewfStatusAttribute))
	}

	idpInstallResultAttribute, ok := attributes["idp_install_result"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`idp_install_result is missing from object`)

		return NewServiceStatusValueUnknown(), diags
	}

	idpInstallResultVal, ok := idpInstallResultAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`idp_install_result expected to be basetypes.StringValue, was: %T`, idpInstallResultAttribute))
	}

	idpInstallTimestampAttribute, ok := attributes["idp_install_timestamp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`idp_install_timestamp is missing from object`)

		return NewServiceStatusValueUnknown(), diags
	}

	idpInstallTimestampVal, ok := idpInstallTimestampAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`idp_install_timestamp expected to be basetypes.StringValue, was: %T`, idpInstallTimestampAttribute))
	}

	idpPolicyAttribute, ok := attributes["idp_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`idp_policy is missing from object`)

		return NewServiceStatusValueUnknown(), diags
	}

	idpPolicyVal, ok := idpPolicyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`idp_policy expected to be basetypes.StringValue, was: %T`, idpPolicyAttribute))
	}

	idpStatusAttribute, ok := attributes["idp_status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`idp_status is missing from object`)

		return NewServiceStatusValueUnknown(), diags
	}

	idpStatusVal, ok := idpStatusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`idp_status expected to be basetypes.StringValue, was: %T`, idpStatusAttribute))
	}

	idpUpdateTimestampAttribute, ok := attributes["idp_update_timestamp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`idp_update_timestamp is missing from object`)

		return NewServiceStatusValueUnknown(), diags
	}

	idpUpdateTimestampVal, ok := idpUpdateTimestampAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`idp_update_timestamp expected to be basetypes.StringValue, was: %T`, idpUpdateTimestampAttribute))
	}

	if diags.HasError() {
		return NewServiceStatusValueUnknown(), diags
	}

	return ServiceStatusValue{
		AppidInstallResult:    appidInstallResultVal,
		AppidInstallTimestamp: appidInstallTimestampVal,
		AppidStatus:           appidStatusVal,
		AppidVersion:          appidVersionVal,
		EwfStatus:             ewfStatusVal,
		IdpInstallResult:      idpInstallResultVal,
		IdpInstallTimestamp:   idpInstallTimestampVal,
		IdpPolicy:             idpPolicyVal,
		IdpStatus:             idpStatusVal,
		IdpUpdateTimestamp:    idpUpdateTimestampVal,
		state:                 attr.ValueStateKnown,
	}, diags
}

func NewServiceStatusValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ServiceStatusValue {
	object, diags := NewServiceStatusValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewServiceStatusValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ServiceStatusType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewServiceStatusValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewServiceStatusValueUnknown(), nil
	}

	if in.IsNull() {
		return NewServiceStatusValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewServiceStatusValueMust(ServiceStatusValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ServiceStatusType) ValueType(ctx context.Context) attr.Value {
	return ServiceStatusValue{}
}

var _ basetypes.ObjectValuable = ServiceStatusValue{}

type ServiceStatusValue struct {
	AppidInstallResult    basetypes.StringValue `tfsdk:"appid_install_result"`
	AppidInstallTimestamp basetypes.StringValue `tfsdk:"appid_install_timestamp"`
	AppidStatus           basetypes.StringValue `tfsdk:"appid_status"`
	AppidVersion          basetypes.Int64Value  `tfsdk:"appid_version"`
	EwfStatus             basetypes.StringValue `tfsdk:"ewf_status"`
	IdpInstallResult      basetypes.StringValue `tfsdk:"idp_install_result"`
	IdpInstallTimestamp   basetypes.StringValue `tfsdk:"idp_install_timestamp"`
	IdpPolicy             basetypes.StringValue `tfsdk:"idp_policy"`
	IdpStatus             basetypes.StringValue `tfsdk:"idp_status"`
	IdpUpdateTimestamp    basetypes.StringValue `tfsdk:"idp_update_timestamp"`
	state                 attr.ValueState
}

func (v ServiceStatusValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 10)

	var val tftypes.Value
	var err error

	attrTypes["appid_install_result"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["appid_install_timestamp"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["appid_status"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["appid_version"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["ewf_status"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["idp_install_result"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["idp_install_timestamp"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["idp_policy"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["idp_status"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["idp_update_timestamp"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 10)

		val, err = v.AppidInstallResult.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["appid_install_result"] = val

		val, err = v.AppidInstallTimestamp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["appid_install_timestamp"] = val

		val, err = v.AppidStatus.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["appid_status"] = val

		val, err = v.AppidVersion.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["appid_version"] = val

		val, err = v.EwfStatus.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ewf_status"] = val

		val, err = v.IdpInstallResult.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["idp_install_result"] = val

		val, err = v.IdpInstallTimestamp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["idp_install_timestamp"] = val

		val, err = v.IdpPolicy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["idp_policy"] = val

		val, err = v.IdpStatus.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["idp_status"] = val

		val, err = v.IdpUpdateTimestamp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["idp_update_timestamp"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ServiceStatusValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ServiceStatusValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ServiceStatusValue) String() string {
	return "ServiceStatusValue"
}

func (v ServiceStatusValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"appid_install_result":    basetypes.StringType{},
		"appid_install_timestamp": basetypes.StringType{},
		"appid_status":            basetypes.StringType{},
		"appid_version":           basetypes.Int64Type{},
		"ewf_status":              basetypes.StringType{},
		"idp_install_result":      basetypes.StringType{},
		"idp_install_timestamp":   basetypes.StringType{},
		"idp_policy":              basetypes.StringType{},
		"idp_status":              basetypes.StringType{},
		"idp_update_timestamp":    basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"appid_install_result":    v.AppidInstallResult,
			"appid_install_timestamp": v.AppidInstallTimestamp,
			"appid_status":            v.AppidStatus,
			"appid_version":           v.AppidVersion,
			"ewf_status":              v.EwfStatus,
			"idp_install_result":      v.IdpInstallResult,
			"idp_install_timestamp":   v.IdpInstallTimestamp,
			"idp_policy":              v.IdpPolicy,
			"idp_status":              v.IdpStatus,
			"idp_update_timestamp":    v.IdpUpdateTimestamp,
		})

	return objVal, diags
}

func (v ServiceStatusValue) Equal(o attr.Value) bool {
	other, ok := o.(ServiceStatusValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AppidInstallResult.Equal(other.AppidInstallResult) {
		return false
	}

	if !v.AppidInstallTimestamp.Equal(other.AppidInstallTimestamp) {
		return false
	}

	if !v.AppidStatus.Equal(other.AppidStatus) {
		return false
	}

	if !v.AppidVersion.Equal(other.AppidVersion) {
		return false
	}

	if !v.EwfStatus.Equal(other.EwfStatus) {
		return false
	}

	if !v.IdpInstallResult.Equal(other.IdpInstallResult) {
		return false
	}

	if !v.IdpInstallTimestamp.Equal(other.IdpInstallTimestamp) {
		return false
	}

	if !v.IdpPolicy.Equal(other.IdpPolicy) {
		return false
	}

	if !v.IdpStatus.Equal(other.IdpStatus) {
		return false
	}

	if !v.IdpUpdateTimestamp.Equal(other.IdpUpdateTimestamp) {
		return false
	}

	return true
}

func (v ServiceStatusValue) Type(ctx context.Context) attr.Type {
	return ServiceStatusType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ServiceStatusValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"appid_install_result":    basetypes.StringType{},
		"appid_install_timestamp": basetypes.StringType{},
		"appid_status":            basetypes.StringType{},
		"appid_version":           basetypes.Int64Type{},
		"ewf_status":              basetypes.StringType{},
		"idp_install_result":      basetypes.StringType{},
		"idp_install_timestamp":   basetypes.StringType{},
		"idp_policy":              basetypes.StringType{},
		"idp_status":              basetypes.StringType{},
		"idp_update_timestamp":    basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = SpuStatType{}

type SpuStatType struct {
	basetypes.ObjectType
}

func (t SpuStatType) Equal(o attr.Type) bool {
	other, ok := o.(SpuStatType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SpuStatType) String() string {
	return "SpuStatType"
}

func (t SpuStatType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	spuCpuAttribute, ok := attributes["spu_cpu"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`spu_cpu is missing from object`)

		return nil, diags
	}

	spuCpuVal, ok := spuCpuAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`spu_cpu expected to be basetypes.Int64Value, was: %T`, spuCpuAttribute))
	}

	spuCurrentSessionAttribute, ok := attributes["spu_current_session"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`spu_current_session is missing from object`)

		return nil, diags
	}

	spuCurrentSessionVal, ok := spuCurrentSessionAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`spu_current_session expected to be basetypes.Int64Value, was: %T`, spuCurrentSessionAttribute))
	}

	spuMaxSessionAttribute, ok := attributes["spu_max_session"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`spu_max_session is missing from object`)

		return nil, diags
	}

	spuMaxSessionVal, ok := spuMaxSessionAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`spu_max_session expected to be basetypes.Int64Value, was: %T`, spuMaxSessionAttribute))
	}

	spuMemoryAttribute, ok := attributes["spu_memory"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`spu_memory is missing from object`)

		return nil, diags
	}

	spuMemoryVal, ok := spuMemoryAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`spu_memory expected to be basetypes.Int64Value, was: %T`, spuMemoryAttribute))
	}

	spuPendingSessionAttribute, ok := attributes["spu_pending_session"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`spu_pending_session is missing from object`)

		return nil, diags
	}

	spuPendingSessionVal, ok := spuPendingSessionAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`spu_pending_session expected to be basetypes.Int64Value, was: %T`, spuPendingSessionAttribute))
	}

	spuValidSessionAttribute, ok := attributes["spu_valid_session"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`spu_valid_session is missing from object`)

		return nil, diags
	}

	spuValidSessionVal, ok := spuValidSessionAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`spu_valid_session expected to be basetypes.Int64Value, was: %T`, spuValidSessionAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SpuStatValue{
		SpuCpu:            spuCpuVal,
		SpuCurrentSession: spuCurrentSessionVal,
		SpuMaxSession:     spuMaxSessionVal,
		SpuMemory:         spuMemoryVal,
		SpuPendingSession: spuPendingSessionVal,
		SpuValidSession:   spuValidSessionVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewSpuStatValueNull() SpuStatValue {
	return SpuStatValue{
		state: attr.ValueStateNull,
	}
}

func NewSpuStatValueUnknown() SpuStatValue {
	return SpuStatValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSpuStatValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SpuStatValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SpuStatValue Attribute Value",
				"While creating a SpuStatValue value, a missing attribute value was detected. "+
					"A SpuStatValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpuStatValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SpuStatValue Attribute Type",
				"While creating a SpuStatValue value, an invalid attribute value was detected. "+
					"A SpuStatValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpuStatValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SpuStatValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SpuStatValue Attribute Value",
				"While creating a SpuStatValue value, an extra attribute value was detected. "+
					"A SpuStatValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SpuStatValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSpuStatValueUnknown(), diags
	}

	spuCpuAttribute, ok := attributes["spu_cpu"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`spu_cpu is missing from object`)

		return NewSpuStatValueUnknown(), diags
	}

	spuCpuVal, ok := spuCpuAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`spu_cpu expected to be basetypes.Int64Value, was: %T`, spuCpuAttribute))
	}

	spuCurrentSessionAttribute, ok := attributes["spu_current_session"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`spu_current_session is missing from object`)

		return NewSpuStatValueUnknown(), diags
	}

	spuCurrentSessionVal, ok := spuCurrentSessionAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`spu_current_session expected to be basetypes.Int64Value, was: %T`, spuCurrentSessionAttribute))
	}

	spuMaxSessionAttribute, ok := attributes["spu_max_session"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`spu_max_session is missing from object`)

		return NewSpuStatValueUnknown(), diags
	}

	spuMaxSessionVal, ok := spuMaxSessionAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`spu_max_session expected to be basetypes.Int64Value, was: %T`, spuMaxSessionAttribute))
	}

	spuMemoryAttribute, ok := attributes["spu_memory"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`spu_memory is missing from object`)

		return NewSpuStatValueUnknown(), diags
	}

	spuMemoryVal, ok := spuMemoryAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`spu_memory expected to be basetypes.Int64Value, was: %T`, spuMemoryAttribute))
	}

	spuPendingSessionAttribute, ok := attributes["spu_pending_session"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`spu_pending_session is missing from object`)

		return NewSpuStatValueUnknown(), diags
	}

	spuPendingSessionVal, ok := spuPendingSessionAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`spu_pending_session expected to be basetypes.Int64Value, was: %T`, spuPendingSessionAttribute))
	}

	spuValidSessionAttribute, ok := attributes["spu_valid_session"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`spu_valid_session is missing from object`)

		return NewSpuStatValueUnknown(), diags
	}

	spuValidSessionVal, ok := spuValidSessionAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`spu_valid_session expected to be basetypes.Int64Value, was: %T`, spuValidSessionAttribute))
	}

	if diags.HasError() {
		return NewSpuStatValueUnknown(), diags
	}

	return SpuStatValue{
		SpuCpu:            spuCpuVal,
		SpuCurrentSession: spuCurrentSessionVal,
		SpuMaxSession:     spuMaxSessionVal,
		SpuMemory:         spuMemoryVal,
		SpuPendingSession: spuPendingSessionVal,
		SpuValidSession:   spuValidSessionVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewSpuStatValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SpuStatValue {
	object, diags := NewSpuStatValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSpuStatValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SpuStatType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSpuStatValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSpuStatValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSpuStatValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSpuStatValueMust(SpuStatValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SpuStatType) ValueType(ctx context.Context) attr.Value {
	return SpuStatValue{}
}

var _ basetypes.ObjectValuable = SpuStatValue{}

type SpuStatValue struct {
	SpuCpu            basetypes.Int64Value `tfsdk:"spu_cpu"`
	SpuCurrentSession basetypes.Int64Value `tfsdk:"spu_current_session"`
	SpuMaxSession     basetypes.Int64Value `tfsdk:"spu_max_session"`
	SpuMemory         basetypes.Int64Value `tfsdk:"spu_memory"`
	SpuPendingSession basetypes.Int64Value `tfsdk:"spu_pending_session"`
	SpuValidSession   basetypes.Int64Value `tfsdk:"spu_valid_session"`
	state             attr.ValueState
}

func (v SpuStatValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 6)

	var val tftypes.Value
	var err error

	attrTypes["spu_cpu"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["spu_current_session"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["spu_max_session"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["spu_memory"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["spu_pending_session"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["spu_valid_session"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 6)

		val, err = v.SpuCpu.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["spu_cpu"] = val

		val, err = v.SpuCurrentSession.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["spu_current_session"] = val

		val, err = v.SpuMaxSession.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["spu_max_session"] = val

		val, err = v.SpuMemory.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["spu_memory"] = val

		val, err = v.SpuPendingSession.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["spu_pending_session"] = val

		val, err = v.SpuValidSession.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["spu_valid_session"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SpuStatValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SpuStatValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SpuStatValue) String() string {
	return "SpuStatValue"
}

func (v SpuStatValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"spu_cpu":             basetypes.Int64Type{},
		"spu_current_session": basetypes.Int64Type{},
		"spu_max_session":     basetypes.Int64Type{},
		"spu_memory":          basetypes.Int64Type{},
		"spu_pending_session": basetypes.Int64Type{},
		"spu_valid_session":   basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"spu_cpu":             v.SpuCpu,
			"spu_current_session": v.SpuCurrentSession,
			"spu_max_session":     v.SpuMaxSession,
			"spu_memory":          v.SpuMemory,
			"spu_pending_session": v.SpuPendingSession,
			"spu_valid_session":   v.SpuValidSession,
		})

	return objVal, diags
}

func (v SpuStatValue) Equal(o attr.Value) bool {
	other, ok := o.(SpuStatValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.SpuCpu.Equal(other.SpuCpu) {
		return false
	}

	if !v.SpuCurrentSession.Equal(other.SpuCurrentSession) {
		return false
	}

	if !v.SpuMaxSession.Equal(other.SpuMaxSession) {
		return false
	}

	if !v.SpuMemory.Equal(other.SpuMemory) {
		return false
	}

	if !v.SpuPendingSession.Equal(other.SpuPendingSession) {
		return false
	}

	if !v.SpuValidSession.Equal(other.SpuValidSession) {
		return false
	}

	return true
}

func (v SpuStatValue) Type(ctx context.Context) attr.Type {
	return SpuStatType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SpuStatValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"spu_cpu":             basetypes.Int64Type{},
		"spu_current_session": basetypes.Int64Type{},
		"spu_max_session":     basetypes.Int64Type{},
		"spu_memory":          basetypes.Int64Type{},
		"spu_pending_session": basetypes.Int64Type{},
		"spu_valid_session":   basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = TunnelsType{}

type TunnelsType struct {
	basetypes.ObjectType
}

func (t TunnelsType) Equal(o attr.Type) bool {
	other, ok := o.(TunnelsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t TunnelsType) String() string {
	return "TunnelsType"
}

func (t TunnelsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	authAlgoAttribute, ok := attributes["auth_algo"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auth_algo is missing from object`)

		return nil, diags
	}

	authAlgoVal, ok := authAlgoAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auth_algo expected to be basetypes.StringValue, was: %T`, authAlgoAttribute))
	}

	encryptAlgoAttribute, ok := attributes["encrypt_algo"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`encrypt_algo is missing from object`)

		return nil, diags
	}

	encryptAlgoVal, ok := encryptAlgoAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`encrypt_algo expected to be basetypes.StringValue, was: %T`, encryptAlgoAttribute))
	}

	ikeVersionAttribute, ok := attributes["ike_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ike_version is missing from object`)

		return nil, diags
	}

	ikeVersionVal, ok := ikeVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ike_version expected to be basetypes.StringValue, was: %T`, ikeVersionAttribute))
	}

	ipAttribute, ok := attributes["ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip is missing from object`)

		return nil, diags
	}

	ipVal, ok := ipAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip expected to be basetypes.StringValue, was: %T`, ipAttribute))
	}

	lastEventAttribute, ok := attributes["last_event"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`last_event is missing from object`)

		return nil, diags
	}

	lastEventVal, ok := lastEventAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`last_event expected to be basetypes.StringValue, was: %T`, lastEventAttribute))
	}

	lastFlappedAttribute, ok := attributes["last_flapped"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`last_flapped is missing from object`)

		return nil, diags
	}

	lastFlappedVal, ok := lastFlappedAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`last_flapped expected to be basetypes.Float64Value, was: %T`, lastFlappedAttribute))
	}

	nodeAttribute, ok := attributes["node"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node is missing from object`)

		return nil, diags
	}

	nodeVal, ok := nodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node expected to be basetypes.StringValue, was: %T`, nodeAttribute))
	}

	peerHostAttribute, ok := attributes["peer_host"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`peer_host is missing from object`)

		return nil, diags
	}

	peerHostVal, ok := peerHostAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`peer_host expected to be basetypes.StringValue, was: %T`, peerHostAttribute))
	}

	peerIpAttribute, ok := attributes["peer_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`peer_ip is missing from object`)

		return nil, diags
	}

	peerIpVal, ok := peerIpAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`peer_ip expected to be basetypes.StringValue, was: %T`, peerIpAttribute))
	}

	priorityAttribute, ok := attributes["priority"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`priority is missing from object`)

		return nil, diags
	}

	priorityVal, ok := priorityAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`priority expected to be basetypes.StringValue, was: %T`, priorityAttribute))
	}

	protocolAttribute, ok := attributes["protocol"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`protocol is missing from object`)

		return nil, diags
	}

	protocolVal, ok := protocolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`protocol expected to be basetypes.StringValue, was: %T`, protocolAttribute))
	}

	rxBytesAttribute, ok := attributes["rx_bytes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rx_bytes is missing from object`)

		return nil, diags
	}

	rxBytesVal, ok := rxBytesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rx_bytes expected to be basetypes.Int64Value, was: %T`, rxBytesAttribute))
	}

	rxPktsAttribute, ok := attributes["rx_pkts"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rx_pkts is missing from object`)

		return nil, diags
	}

	rxPktsVal, ok := rxPktsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rx_pkts expected to be basetypes.Int64Value, was: %T`, rxPktsAttribute))
	}

	tunnelNameAttribute, ok := attributes["tunnel_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tunnel_name is missing from object`)

		return nil, diags
	}

	tunnelNameVal, ok := tunnelNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tunnel_name expected to be basetypes.StringValue, was: %T`, tunnelNameAttribute))
	}

	txBytesAttribute, ok := attributes["tx_bytes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tx_bytes is missing from object`)

		return nil, diags
	}

	txBytesVal, ok := txBytesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tx_bytes expected to be basetypes.Int64Value, was: %T`, txBytesAttribute))
	}

	txPktsAttribute, ok := attributes["tx_pkts"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tx_pkts is missing from object`)

		return nil, diags
	}

	txPktsVal, ok := txPktsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tx_pkts expected to be basetypes.Int64Value, was: %T`, txPktsAttribute))
	}

	upAttribute, ok := attributes["up"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`up is missing from object`)

		return nil, diags
	}

	upVal, ok := upAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`up expected to be basetypes.BoolValue, was: %T`, upAttribute))
	}

	uptimeAttribute, ok := attributes["uptime"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uptime is missing from object`)

		return nil, diags
	}

	uptimeVal, ok := uptimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uptime expected to be basetypes.Int64Value, was: %T`, uptimeAttribute))
	}

	wanNameAttribute, ok := attributes["wan_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wan_name is missing from object`)

		return nil, diags
	}

	wanNameVal, ok := wanNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wan_name expected to be basetypes.StringValue, was: %T`, wanNameAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return TunnelsValue{
		AuthAlgo:    authAlgoVal,
		EncryptAlgo: encryptAlgoVal,
		IkeVersion:  ikeVersionVal,
		Ip:          ipVal,
		LastEvent:   lastEventVal,
		LastFlapped: lastFlappedVal,
		Node:        nodeVal,
		PeerHost:    peerHostVal,
		PeerIp:      peerIpVal,
		Priority:    priorityVal,
		Protocol:    protocolVal,
		RxBytes:     rxBytesVal,
		RxPkts:      rxPktsVal,
		TunnelName:  tunnelNameVal,
		TxBytes:     txBytesVal,
		TxPkts:      txPktsVal,
		Up:          upVal,
		Uptime:      uptimeVal,
		WanName:     wanNameVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewTunnelsValueNull() TunnelsValue {
	return TunnelsValue{
		state: attr.ValueStateNull,
	}
}

func NewTunnelsValueUnknown() TunnelsValue {
	return TunnelsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewTunnelsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (TunnelsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing TunnelsValue Attribute Value",
				"While creating a TunnelsValue value, a missing attribute value was detected. "+
					"A TunnelsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TunnelsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid TunnelsValue Attribute Type",
				"While creating a TunnelsValue value, an invalid attribute value was detected. "+
					"A TunnelsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TunnelsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("TunnelsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra TunnelsValue Attribute Value",
				"While creating a TunnelsValue value, an extra attribute value was detected. "+
					"A TunnelsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra TunnelsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewTunnelsValueUnknown(), diags
	}

	authAlgoAttribute, ok := attributes["auth_algo"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auth_algo is missing from object`)

		return NewTunnelsValueUnknown(), diags
	}

	authAlgoVal, ok := authAlgoAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auth_algo expected to be basetypes.StringValue, was: %T`, authAlgoAttribute))
	}

	encryptAlgoAttribute, ok := attributes["encrypt_algo"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`encrypt_algo is missing from object`)

		return NewTunnelsValueUnknown(), diags
	}

	encryptAlgoVal, ok := encryptAlgoAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`encrypt_algo expected to be basetypes.StringValue, was: %T`, encryptAlgoAttribute))
	}

	ikeVersionAttribute, ok := attributes["ike_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ike_version is missing from object`)

		return NewTunnelsValueUnknown(), diags
	}

	ikeVersionVal, ok := ikeVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ike_version expected to be basetypes.StringValue, was: %T`, ikeVersionAttribute))
	}

	ipAttribute, ok := attributes["ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip is missing from object`)

		return NewTunnelsValueUnknown(), diags
	}

	ipVal, ok := ipAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip expected to be basetypes.StringValue, was: %T`, ipAttribute))
	}

	lastEventAttribute, ok := attributes["last_event"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`last_event is missing from object`)

		return NewTunnelsValueUnknown(), diags
	}

	lastEventVal, ok := lastEventAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`last_event expected to be basetypes.StringValue, was: %T`, lastEventAttribute))
	}

	lastFlappedAttribute, ok := attributes["last_flapped"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`last_flapped is missing from object`)

		return NewTunnelsValueUnknown(), diags
	}

	lastFlappedVal, ok := lastFlappedAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`last_flapped expected to be basetypes.Float64Value, was: %T`, lastFlappedAttribute))
	}

	nodeAttribute, ok := attributes["node"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node is missing from object`)

		return NewTunnelsValueUnknown(), diags
	}

	nodeVal, ok := nodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node expected to be basetypes.StringValue, was: %T`, nodeAttribute))
	}

	peerHostAttribute, ok := attributes["peer_host"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`peer_host is missing from object`)

		return NewTunnelsValueUnknown(), diags
	}

	peerHostVal, ok := peerHostAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`peer_host expected to be basetypes.StringValue, was: %T`, peerHostAttribute))
	}

	peerIpAttribute, ok := attributes["peer_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`peer_ip is missing from object`)

		return NewTunnelsValueUnknown(), diags
	}

	peerIpVal, ok := peerIpAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`peer_ip expected to be basetypes.StringValue, was: %T`, peerIpAttribute))
	}

	priorityAttribute, ok := attributes["priority"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`priority is missing from object`)

		return NewTunnelsValueUnknown(), diags
	}

	priorityVal, ok := priorityAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`priority expected to be basetypes.StringValue, was: %T`, priorityAttribute))
	}

	protocolAttribute, ok := attributes["protocol"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`protocol is missing from object`)

		return NewTunnelsValueUnknown(), diags
	}

	protocolVal, ok := protocolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`protocol expected to be basetypes.StringValue, was: %T`, protocolAttribute))
	}

	rxBytesAttribute, ok := attributes["rx_bytes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rx_bytes is missing from object`)

		return NewTunnelsValueUnknown(), diags
	}

	rxBytesVal, ok := rxBytesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rx_bytes expected to be basetypes.Int64Value, was: %T`, rxBytesAttribute))
	}

	rxPktsAttribute, ok := attributes["rx_pkts"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rx_pkts is missing from object`)

		return NewTunnelsValueUnknown(), diags
	}

	rxPktsVal, ok := rxPktsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rx_pkts expected to be basetypes.Int64Value, was: %T`, rxPktsAttribute))
	}

	tunnelNameAttribute, ok := attributes["tunnel_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tunnel_name is missing from object`)

		return NewTunnelsValueUnknown(), diags
	}

	tunnelNameVal, ok := tunnelNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tunnel_name expected to be basetypes.StringValue, was: %T`, tunnelNameAttribute))
	}

	txBytesAttribute, ok := attributes["tx_bytes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tx_bytes is missing from object`)

		return NewTunnelsValueUnknown(), diags
	}

	txBytesVal, ok := txBytesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tx_bytes expected to be basetypes.Int64Value, was: %T`, txBytesAttribute))
	}

	txPktsAttribute, ok := attributes["tx_pkts"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tx_pkts is missing from object`)

		return NewTunnelsValueUnknown(), diags
	}

	txPktsVal, ok := txPktsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tx_pkts expected to be basetypes.Int64Value, was: %T`, txPktsAttribute))
	}

	upAttribute, ok := attributes["up"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`up is missing from object`)

		return NewTunnelsValueUnknown(), diags
	}

	upVal, ok := upAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`up expected to be basetypes.BoolValue, was: %T`, upAttribute))
	}

	uptimeAttribute, ok := attributes["uptime"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uptime is missing from object`)

		return NewTunnelsValueUnknown(), diags
	}

	uptimeVal, ok := uptimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uptime expected to be basetypes.Int64Value, was: %T`, uptimeAttribute))
	}

	wanNameAttribute, ok := attributes["wan_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wan_name is missing from object`)

		return NewTunnelsValueUnknown(), diags
	}

	wanNameVal, ok := wanNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wan_name expected to be basetypes.StringValue, was: %T`, wanNameAttribute))
	}

	if diags.HasError() {
		return NewTunnelsValueUnknown(), diags
	}

	return TunnelsValue{
		AuthAlgo:    authAlgoVal,
		EncryptAlgo: encryptAlgoVal,
		IkeVersion:  ikeVersionVal,
		Ip:          ipVal,
		LastEvent:   lastEventVal,
		LastFlapped: lastFlappedVal,
		Node:        nodeVal,
		PeerHost:    peerHostVal,
		PeerIp:      peerIpVal,
		Priority:    priorityVal,
		Protocol:    protocolVal,
		RxBytes:     rxBytesVal,
		RxPkts:      rxPktsVal,
		TunnelName:  tunnelNameVal,
		TxBytes:     txBytesVal,
		TxPkts:      txPktsVal,
		Up:          upVal,
		Uptime:      uptimeVal,
		WanName:     wanNameVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewTunnelsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) TunnelsValue {
	object, diags := NewTunnelsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewTunnelsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t TunnelsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewTunnelsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewTunnelsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewTunnelsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewTunnelsValueMust(TunnelsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t TunnelsType) ValueType(ctx context.Context) attr.Value {
	return TunnelsValue{}
}

var _ basetypes.ObjectValuable = TunnelsValue{}

type TunnelsValue struct {
	AuthAlgo    basetypes.StringValue  `tfsdk:"auth_algo"`
	EncryptAlgo basetypes.StringValue  `tfsdk:"encrypt_algo"`
	IkeVersion  basetypes.StringValue  `tfsdk:"ike_version"`
	Ip          basetypes.StringValue  `tfsdk:"ip"`
	LastEvent   basetypes.StringValue  `tfsdk:"last_event"`
	LastFlapped basetypes.Float64Value `tfsdk:"last_flapped"`
	Node        basetypes.StringValue  `tfsdk:"node"`
	PeerHost    basetypes.StringValue  `tfsdk:"peer_host"`
	PeerIp      basetypes.StringValue  `tfsdk:"peer_ip"`
	Priority    basetypes.StringValue  `tfsdk:"priority"`
	Protocol    basetypes.StringValue  `tfsdk:"protocol"`
	RxBytes     basetypes.Int64Value   `tfsdk:"rx_bytes"`
	RxPkts      basetypes.Int64Value   `tfsdk:"rx_pkts"`
	TunnelName  basetypes.StringValue  `tfsdk:"tunnel_name"`
	TxBytes     basetypes.Int64Value   `tfsdk:"tx_bytes"`
	TxPkts      basetypes.Int64Value   `tfsdk:"tx_pkts"`
	Up          basetypes.BoolValue    `tfsdk:"up"`
	Uptime      basetypes.Int64Value   `tfsdk:"uptime"`
	WanName     basetypes.StringValue  `tfsdk:"wan_name"`
	state       attr.ValueState
}

func (v TunnelsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 19)

	var val tftypes.Value
	var err error

	attrTypes["auth_algo"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["encrypt_algo"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ike_version"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ip"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["last_event"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["last_flapped"] = basetypes.Float64Type{}.TerraformType(ctx)
	attrTypes["node"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["peer_host"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["peer_ip"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["priority"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["protocol"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["rx_bytes"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["rx_pkts"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["tunnel_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["tx_bytes"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["tx_pkts"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["up"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["uptime"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["wan_name"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 19)

		val, err = v.AuthAlgo.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["auth_algo"] = val

		val, err = v.EncryptAlgo.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["encrypt_algo"] = val

		val, err = v.IkeVersion.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ike_version"] = val

		val, err = v.Ip.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip"] = val

		val, err = v.LastEvent.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["last_event"] = val

		val, err = v.LastFlapped.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["last_flapped"] = val

		val, err = v.Node.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["node"] = val

		val, err = v.PeerHost.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["peer_host"] = val

		val, err = v.PeerIp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["peer_ip"] = val

		val, err = v.Priority.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["priority"] = val

		val, err = v.Protocol.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["protocol"] = val

		val, err = v.RxBytes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["rx_bytes"] = val

		val, err = v.RxPkts.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["rx_pkts"] = val

		val, err = v.TunnelName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tunnel_name"] = val

		val, err = v.TxBytes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tx_bytes"] = val

		val, err = v.TxPkts.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tx_pkts"] = val

		val, err = v.Up.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["up"] = val

		val, err = v.Uptime.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["uptime"] = val

		val, err = v.WanName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["wan_name"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v TunnelsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v TunnelsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v TunnelsValue) String() string {
	return "TunnelsValue"
}

func (v TunnelsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"auth_algo":    basetypes.StringType{},
		"encrypt_algo": basetypes.StringType{},
		"ike_version":  basetypes.StringType{},
		"ip":           basetypes.StringType{},
		"last_event":   basetypes.StringType{},
		"last_flapped": basetypes.Float64Type{},
		"node":         basetypes.StringType{},
		"peer_host":    basetypes.StringType{},
		"peer_ip":      basetypes.StringType{},
		"priority":     basetypes.StringType{},
		"protocol":     basetypes.StringType{},
		"rx_bytes":     basetypes.Int64Type{},
		"rx_pkts":      basetypes.Int64Type{},
		"tunnel_name":  basetypes.StringType{},
		"tx_bytes":     basetypes.Int64Type{},
		"tx_pkts":      basetypes.Int64Type{},
		"up":           basetypes.BoolType{},
		"uptime":       basetypes.Int64Type{},
		"wan_name":     basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"auth_algo":    v.AuthAlgo,
			"encrypt_algo": v.EncryptAlgo,
			"ike_version":  v.IkeVersion,
			"ip":           v.Ip,
			"last_event":   v.LastEvent,
			"last_flapped": v.LastFlapped,
			"node":         v.Node,
			"peer_host":    v.PeerHost,
			"peer_ip":      v.PeerIp,
			"priority":     v.Priority,
			"protocol":     v.Protocol,
			"rx_bytes":     v.RxBytes,
			"rx_pkts":      v.RxPkts,
			"tunnel_name":  v.TunnelName,
			"tx_bytes":     v.TxBytes,
			"tx_pkts":      v.TxPkts,
			"up":           v.Up,
			"uptime":       v.Uptime,
			"wan_name":     v.WanName,
		})

	return objVal, diags
}

func (v TunnelsValue) Equal(o attr.Value) bool {
	other, ok := o.(TunnelsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AuthAlgo.Equal(other.AuthAlgo) {
		return false
	}

	if !v.EncryptAlgo.Equal(other.EncryptAlgo) {
		return false
	}

	if !v.IkeVersion.Equal(other.IkeVersion) {
		return false
	}

	if !v.Ip.Equal(other.Ip) {
		return false
	}

	if !v.LastEvent.Equal(other.LastEvent) {
		return false
	}

	if !v.LastFlapped.Equal(other.LastFlapped) {
		return false
	}

	if !v.Node.Equal(other.Node) {
		return false
	}

	if !v.PeerHost.Equal(other.PeerHost) {
		return false
	}

	if !v.PeerIp.Equal(other.PeerIp) {
		return false
	}

	if !v.Priority.Equal(other.Priority) {
		return false
	}

	if !v.Protocol.Equal(other.Protocol) {
		return false
	}

	if !v.RxBytes.Equal(other.RxBytes) {
		return false
	}

	if !v.RxPkts.Equal(other.RxPkts) {
		return false
	}

	if !v.TunnelName.Equal(other.TunnelName) {
		return false
	}

	if !v.TxBytes.Equal(other.TxBytes) {
		return false
	}

	if !v.TxPkts.Equal(other.TxPkts) {
		return false
	}

	if !v.Up.Equal(other.Up) {
		return false
	}

	if !v.Uptime.Equal(other.Uptime) {
		return false
	}

	if !v.WanName.Equal(other.WanName) {
		return false
	}

	return true
}

func (v TunnelsValue) Type(ctx context.Context) attr.Type {
	return TunnelsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v TunnelsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"auth_algo":    basetypes.StringType{},
		"encrypt_algo": basetypes.StringType{},
		"ike_version":  basetypes.StringType{},
		"ip":           basetypes.StringType{},
		"last_event":   basetypes.StringType{},
		"last_flapped": basetypes.Float64Type{},
		"node":         basetypes.StringType{},
		"peer_host":    basetypes.StringType{},
		"peer_ip":      basetypes.StringType{},
		"priority":     basetypes.StringType{},
		"protocol":     basetypes.StringType{},
		"rx_bytes":     basetypes.Int64Type{},
		"rx_pkts":      basetypes.Int64Type{},
		"tunnel_name":  basetypes.StringType{},
		"tx_bytes":     basetypes.Int64Type{},
		"tx_pkts":      basetypes.Int64Type{},
		"up":           basetypes.BoolType{},
		"uptime":       basetypes.Int64Type{},
		"wan_name":     basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = VpnPeersType{}

type VpnPeersType struct {
	basetypes.ObjectType
}

func (t VpnPeersType) Equal(o attr.Type) bool {
	other, ok := o.(VpnPeersType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t VpnPeersType) String() string {
	return "VpnPeersType"
}

func (t VpnPeersType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	isActiveAttribute, ok := attributes["is_active"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`is_active is missing from object`)

		return nil, diags
	}

	isActiveVal, ok := isActiveAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`is_active expected to be basetypes.BoolValue, was: %T`, isActiveAttribute))
	}

	lastSeenAttribute, ok := attributes["last_seen"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`last_seen is missing from object`)

		return nil, diags
	}

	lastSeenVal, ok := lastSeenAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`last_seen expected to be basetypes.Float64Value, was: %T`, lastSeenAttribute))
	}

	latencyAttribute, ok := attributes["latency"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`latency is missing from object`)

		return nil, diags
	}

	latencyVal, ok := latencyAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`latency expected to be basetypes.NumberValue, was: %T`, latencyAttribute))
	}

	mosAttribute, ok := attributes["mos"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mos is missing from object`)

		return nil, diags
	}

	mosVal, ok := mosAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mos expected to be basetypes.NumberValue, was: %T`, mosAttribute))
	}

	mtuAttribute, ok := attributes["mtu"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mtu is missing from object`)

		return nil, diags
	}

	mtuVal, ok := mtuAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mtu expected to be basetypes.Int64Value, was: %T`, mtuAttribute))
	}

	peerMacAttribute, ok := attributes["peer_mac"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`peer_mac is missing from object`)

		return nil, diags
	}

	peerMacVal, ok := peerMacAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`peer_mac expected to be basetypes.StringValue, was: %T`, peerMacAttribute))
	}

	peerPortIdAttribute, ok := attributes["peer_port_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`peer_port_id is missing from object`)

		return nil, diags
	}

	peerPortIdVal, ok := peerPortIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`peer_port_id expected to be basetypes.StringValue, was: %T`, peerPortIdAttribute))
	}

	peerRouterNameAttribute, ok := attributes["peer_router_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`peer_router_name is missing from object`)

		return nil, diags
	}

	peerRouterNameVal, ok := peerRouterNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`peer_router_name expected to be basetypes.StringValue, was: %T`, peerRouterNameAttribute))
	}

	peerSiteIdAttribute, ok := attributes["peer_site_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`peer_site_id is missing from object`)

		return nil, diags
	}

	peerSiteIdVal, ok := peerSiteIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`peer_site_id expected to be basetypes.StringValue, was: %T`, peerSiteIdAttribute))
	}

	portIdAttribute, ok := attributes["port_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_id is missing from object`)

		return nil, diags
	}

	portIdVal, ok := portIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_id expected to be basetypes.StringValue, was: %T`, portIdAttribute))
	}

	routerNameAttribute, ok := attributes["router_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`router_name is missing from object`)

		return nil, diags
	}

	routerNameVal, ok := routerNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`router_name expected to be basetypes.StringValue, was: %T`, routerNameAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	upAttribute, ok := attributes["up"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`up is missing from object`)

		return nil, diags
	}

	upVal, ok := upAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`up expected to be basetypes.BoolValue, was: %T`, upAttribute))
	}

	uptimeAttribute, ok := attributes["uptime"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uptime is missing from object`)

		return nil, diags
	}

	uptimeVal, ok := uptimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uptime expected to be basetypes.Int64Value, was: %T`, uptimeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return VpnPeersValue{
		IsActive:       isActiveVal,
		LastSeen:       lastSeenVal,
		Latency:        latencyVal,
		Mos:            mosVal,
		Mtu:            mtuVal,
		PeerMac:        peerMacVal,
		PeerPortId:     peerPortIdVal,
		PeerRouterName: peerRouterNameVal,
		PeerSiteId:     peerSiteIdVal,
		PortId:         portIdVal,
		RouterName:     routerNameVal,
		VpnPeersType:   typeVal,
		Up:             upVal,
		Uptime:         uptimeVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewVpnPeersValueNull() VpnPeersValue {
	return VpnPeersValue{
		state: attr.ValueStateNull,
	}
}

func NewVpnPeersValueUnknown() VpnPeersValue {
	return VpnPeersValue{
		state: attr.ValueStateUnknown,
	}
}

func NewVpnPeersValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (VpnPeersValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing VpnPeersValue Attribute Value",
				"While creating a VpnPeersValue value, a missing attribute value was detected. "+
					"A VpnPeersValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VpnPeersValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid VpnPeersValue Attribute Type",
				"While creating a VpnPeersValue value, an invalid attribute value was detected. "+
					"A VpnPeersValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VpnPeersValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("VpnPeersValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra VpnPeersValue Attribute Value",
				"While creating a VpnPeersValue value, an extra attribute value was detected. "+
					"A VpnPeersValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra VpnPeersValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewVpnPeersValueUnknown(), diags
	}

	isActiveAttribute, ok := attributes["is_active"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`is_active is missing from object`)

		return NewVpnPeersValueUnknown(), diags
	}

	isActiveVal, ok := isActiveAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`is_active expected to be basetypes.BoolValue, was: %T`, isActiveAttribute))
	}

	lastSeenAttribute, ok := attributes["last_seen"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`last_seen is missing from object`)

		return NewVpnPeersValueUnknown(), diags
	}

	lastSeenVal, ok := lastSeenAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`last_seen expected to be basetypes.Float64Value, was: %T`, lastSeenAttribute))
	}

	latencyAttribute, ok := attributes["latency"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`latency is missing from object`)

		return NewVpnPeersValueUnknown(), diags
	}

	latencyVal, ok := latencyAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`latency expected to be basetypes.NumberValue, was: %T`, latencyAttribute))
	}

	mosAttribute, ok := attributes["mos"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mos is missing from object`)

		return NewVpnPeersValueUnknown(), diags
	}

	mosVal, ok := mosAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mos expected to be basetypes.NumberValue, was: %T`, mosAttribute))
	}

	mtuAttribute, ok := attributes["mtu"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mtu is missing from object`)

		return NewVpnPeersValueUnknown(), diags
	}

	mtuVal, ok := mtuAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mtu expected to be basetypes.Int64Value, was: %T`, mtuAttribute))
	}

	peerMacAttribute, ok := attributes["peer_mac"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`peer_mac is missing from object`)

		return NewVpnPeersValueUnknown(), diags
	}

	peerMacVal, ok := peerMacAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`peer_mac expected to be basetypes.StringValue, was: %T`, peerMacAttribute))
	}

	peerPortIdAttribute, ok := attributes["peer_port_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`peer_port_id is missing from object`)

		return NewVpnPeersValueUnknown(), diags
	}

	peerPortIdVal, ok := peerPortIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`peer_port_id expected to be basetypes.StringValue, was: %T`, peerPortIdAttribute))
	}

	peerRouterNameAttribute, ok := attributes["peer_router_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`peer_router_name is missing from object`)

		return NewVpnPeersValueUnknown(), diags
	}

	peerRouterNameVal, ok := peerRouterNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`peer_router_name expected to be basetypes.StringValue, was: %T`, peerRouterNameAttribute))
	}

	peerSiteIdAttribute, ok := attributes["peer_site_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`peer_site_id is missing from object`)

		return NewVpnPeersValueUnknown(), diags
	}

	peerSiteIdVal, ok := peerSiteIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`peer_site_id expected to be basetypes.StringValue, was: %T`, peerSiteIdAttribute))
	}

	portIdAttribute, ok := attributes["port_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_id is missing from object`)

		return NewVpnPeersValueUnknown(), diags
	}

	portIdVal, ok := portIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_id expected to be basetypes.StringValue, was: %T`, portIdAttribute))
	}

	routerNameAttribute, ok := attributes["router_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`router_name is missing from object`)

		return NewVpnPeersValueUnknown(), diags
	}

	routerNameVal, ok := routerNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`router_name expected to be basetypes.StringValue, was: %T`, routerNameAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewVpnPeersValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	upAttribute, ok := attributes["up"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`up is missing from object`)

		return NewVpnPeersValueUnknown(), diags
	}

	upVal, ok := upAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`up expected to be basetypes.BoolValue, was: %T`, upAttribute))
	}

	uptimeAttribute, ok := attributes["uptime"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uptime is missing from object`)

		return NewVpnPeersValueUnknown(), diags
	}

	uptimeVal, ok := uptimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uptime expected to be basetypes.Int64Value, was: %T`, uptimeAttribute))
	}

	if diags.HasError() {
		return NewVpnPeersValueUnknown(), diags
	}

	return VpnPeersValue{
		IsActive:       isActiveVal,
		LastSeen:       lastSeenVal,
		Latency:        latencyVal,
		Mos:            mosVal,
		Mtu:            mtuVal,
		PeerMac:        peerMacVal,
		PeerPortId:     peerPortIdVal,
		PeerRouterName: peerRouterNameVal,
		PeerSiteId:     peerSiteIdVal,
		PortId:         portIdVal,
		RouterName:     routerNameVal,
		VpnPeersType:   typeVal,
		Up:             upVal,
		Uptime:         uptimeVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewVpnPeersValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) VpnPeersValue {
	object, diags := NewVpnPeersValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewVpnPeersValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t VpnPeersType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewVpnPeersValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewVpnPeersValueUnknown(), nil
	}

	if in.IsNull() {
		return NewVpnPeersValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewVpnPeersValueMust(VpnPeersValue{}.AttributeTypes(ctx), attributes), nil
}

func (t VpnPeersType) ValueType(ctx context.Context) attr.Value {
	return VpnPeersValue{}
}

var _ basetypes.ObjectValuable = VpnPeersValue{}

type VpnPeersValue struct {
	IsActive       basetypes.BoolValue    `tfsdk:"is_active"`
	LastSeen       basetypes.Float64Value `tfsdk:"last_seen"`
	Latency        basetypes.NumberValue  `tfsdk:"latency"`
	Mos            basetypes.NumberValue  `tfsdk:"mos"`
	Mtu            basetypes.Int64Value   `tfsdk:"mtu"`
	PeerMac        basetypes.StringValue  `tfsdk:"peer_mac"`
	PeerPortId     basetypes.StringValue  `tfsdk:"peer_port_id"`
	PeerRouterName basetypes.StringValue  `tfsdk:"peer_router_name"`
	PeerSiteId     basetypes.StringValue  `tfsdk:"peer_site_id"`
	PortId         basetypes.StringValue  `tfsdk:"port_id"`
	RouterName     basetypes.StringValue  `tfsdk:"router_name"`
	VpnPeersType   basetypes.StringValue  `tfsdk:"type"`
	Up             basetypes.BoolValue    `tfsdk:"up"`
	Uptime         basetypes.Int64Value   `tfsdk:"uptime"`
	state          attr.ValueState
}

func (v VpnPeersValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 14)

	var val tftypes.Value
	var err error

	attrTypes["is_active"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["last_seen"] = basetypes.Float64Type{}.TerraformType(ctx)
	attrTypes["latency"] = basetypes.NumberType{}.TerraformType(ctx)
	attrTypes["mos"] = basetypes.NumberType{}.TerraformType(ctx)
	attrTypes["mtu"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["peer_mac"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["peer_port_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["peer_router_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["peer_site_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["port_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["router_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["up"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["uptime"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 14)

		val, err = v.IsActive.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["is_active"] = val

		val, err = v.LastSeen.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["last_seen"] = val

		val, err = v.Latency.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["latency"] = val

		val, err = v.Mos.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mos"] = val

		val, err = v.Mtu.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mtu"] = val

		val, err = v.PeerMac.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["peer_mac"] = val

		val, err = v.PeerPortId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["peer_port_id"] = val

		val, err = v.PeerRouterName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["peer_router_name"] = val

		val, err = v.PeerSiteId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["peer_site_id"] = val

		val, err = v.PortId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port_id"] = val

		val, err = v.RouterName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["router_name"] = val

		val, err = v.VpnPeersType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		val, err = v.Up.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["up"] = val

		val, err = v.Uptime.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["uptime"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v VpnPeersValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v VpnPeersValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v VpnPeersValue) String() string {
	return "VpnPeersValue"
}

func (v VpnPeersValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"is_active":        basetypes.BoolType{},
		"last_seen":        basetypes.Float64Type{},
		"latency":          basetypes.NumberType{},
		"mos":              basetypes.NumberType{},
		"mtu":              basetypes.Int64Type{},
		"peer_mac":         basetypes.StringType{},
		"peer_port_id":     basetypes.StringType{},
		"peer_router_name": basetypes.StringType{},
		"peer_site_id":     basetypes.StringType{},
		"port_id":          basetypes.StringType{},
		"router_name":      basetypes.StringType{},
		"type":             basetypes.StringType{},
		"up":               basetypes.BoolType{},
		"uptime":           basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"is_active":        v.IsActive,
			"last_seen":        v.LastSeen,
			"latency":          v.Latency,
			"mos":              v.Mos,
			"mtu":              v.Mtu,
			"peer_mac":         v.PeerMac,
			"peer_port_id":     v.PeerPortId,
			"peer_router_name": v.PeerRouterName,
			"peer_site_id":     v.PeerSiteId,
			"port_id":          v.PortId,
			"router_name":      v.RouterName,
			"type":             v.VpnPeersType,
			"up":               v.Up,
			"uptime":           v.Uptime,
		})

	return objVal, diags
}

func (v VpnPeersValue) Equal(o attr.Value) bool {
	other, ok := o.(VpnPeersValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.IsActive.Equal(other.IsActive) {
		return false
	}

	if !v.LastSeen.Equal(other.LastSeen) {
		return false
	}

	if !v.Latency.Equal(other.Latency) {
		return false
	}

	if !v.Mos.Equal(other.Mos) {
		return false
	}

	if !v.Mtu.Equal(other.Mtu) {
		return false
	}

	if !v.PeerMac.Equal(other.PeerMac) {
		return false
	}

	if !v.PeerPortId.Equal(other.PeerPortId) {
		return false
	}

	if !v.PeerRouterName.Equal(other.PeerRouterName) {
		return false
	}

	if !v.PeerSiteId.Equal(other.PeerSiteId) {
		return false
	}

	if !v.PortId.Equal(other.PortId) {
		return false
	}

	if !v.RouterName.Equal(other.RouterName) {
		return false
	}

	if !v.VpnPeersType.Equal(other.VpnPeersType) {
		return false
	}

	if !v.Up.Equal(other.Up) {
		return false
	}

	if !v.Uptime.Equal(other.Uptime) {
		return false
	}

	return true
}

func (v VpnPeersValue) Type(ctx context.Context) attr.Type {
	return VpnPeersType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v VpnPeersValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"is_active":        basetypes.BoolType{},
		"last_seen":        basetypes.Float64Type{},
		"latency":          basetypes.NumberType{},
		"mos":              basetypes.NumberType{},
		"mtu":              basetypes.Int64Type{},
		"peer_mac":         basetypes.StringType{},
		"peer_port_id":     basetypes.StringType{},
		"peer_router_name": basetypes.StringType{},
		"peer_site_id":     basetypes.StringType{},
		"port_id":          basetypes.StringType{},
		"router_name":      basetypes.StringType{},
		"type":             basetypes.StringType{},
		"up":               basetypes.BoolType{},
		"uptime":           basetypes.Int64Type{},
	}
}
