// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package datasource_device_switch_stats

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/datasource/schema"
)

func DeviceSwitchStatsDataSourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"device_switch_stats": schema.SetNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"ap_redundancy": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"modules": schema.MapNestedAttribute{
									NestedObject: schema.NestedAttributeObject{
										Attributes: map[string]schema.Attribute{
											"num_aps": schema.Int64Attribute{
												Computed: true,
											},
											"num_aps_with_switch_redundancy": schema.Int64Attribute{
												Computed: true,
											},
										},
										CustomType: ModulesType{
											ObjectType: types.ObjectType{
												AttrTypes: ModulesValue{}.AttributeTypes(ctx),
											},
										},
									},
									Computed:            true,
									Description:         "for a VC / stacked switches.",
									MarkdownDescription: "for a VC / stacked switches.",
								},
								"num_aps": schema.Int64Attribute{
									Computed: true,
								},
								"num_aps_with_switch_redundancy": schema.Int64Attribute{
									Computed: true,
								},
							},
							CustomType: ApRedundancyType{
								ObjectType: types.ObjectType{
									AttrTypes: ApRedundancyValue{}.AttributeTypes(ctx),
								},
							},
							Computed: true,
						},
						"arp_table_stats": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"arp_table_count": schema.Int64Attribute{
									Computed: true,
								},
								"max_entries_supported": schema.Int64Attribute{
									Computed: true,
								},
							},
							CustomType: ArpTableStatsType{
								ObjectType: types.ObjectType{
									AttrTypes: ArpTableStatsValue{}.AttributeTypes(ctx),
								},
							},
							Computed: true,
						},
						"cert_expiry": schema.Int64Attribute{
							Computed: true,
						},
						"clients": schema.ListNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"device_mac": schema.StringAttribute{
										Computed: true,
									},
									"hostname": schema.StringAttribute{
										Computed: true,
									},
									"mac": schema.StringAttribute{
										Computed: true,
									},
									"port_id": schema.StringAttribute{
										Computed: true,
									},
								},
								CustomType: ClientsType{
									ObjectType: types.ObjectType{
										AttrTypes: ClientsValue{}.AttributeTypes(ctx),
									},
								},
							},
							Computed: true,
						},
						"clients_stats": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"total": schema.SingleNestedAttribute{
									Attributes: map[string]schema.Attribute{
										"num_aps": schema.ListAttribute{
											ElementType: types.Int64Type,
											Computed:    true,
										},
										"num_wired_clients": schema.Int64Attribute{
											Computed: true,
										},
									},
									CustomType: TotalType{
										ObjectType: types.ObjectType{
											AttrTypes: TotalValue{}.AttributeTypes(ctx),
										},
									},
									Computed: true,
								},
							},
							CustomType: ClientsStatsType{
								ObjectType: types.ObjectType{
									AttrTypes: ClientsStatsValue{}.AttributeTypes(ctx),
								},
							},
							Computed: true,
						},
						"config_status": schema.StringAttribute{
							Computed: true,
						},
						"cpu_stat": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"idle": schema.NumberAttribute{
									Computed:            true,
									Description:         "Percentage of CPU time that is idle",
									MarkdownDescription: "Percentage of CPU time that is idle",
								},
								"interrupt": schema.NumberAttribute{
									Computed:            true,
									Description:         "Percentage of CPU time being used by interrupts",
									MarkdownDescription: "Percentage of CPU time being used by interrupts",
								},
								"load_avg": schema.ListAttribute{
									ElementType:         types.NumberType,
									Computed:            true,
									Description:         "Load averages for the last 1, 5, and 15 minutes",
									MarkdownDescription: "Load averages for the last 1, 5, and 15 minutes",
								},
								"system": schema.NumberAttribute{
									Computed:            true,
									Description:         "Percentage of CPU time being used by system processes",
									MarkdownDescription: "Percentage of CPU time being used by system processes",
								},
								"user": schema.NumberAttribute{
									Computed:            true,
									Description:         "Percentage of CPU time being used by user processe",
									MarkdownDescription: "Percentage of CPU time being used by user processe",
								},
							},
							CustomType: CpuStatType{
								ObjectType: types.ObjectType{
									AttrTypes: CpuStatValue{}.AttributeTypes(ctx),
								},
							},
							Computed: true,
						},
						"created_time": schema.Int64Attribute{
							Computed: true,
						},
						"deviceprofile_id": schema.StringAttribute{
							Computed: true,
						},
						"dhcpd_stat": schema.MapNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"num_ips": schema.Int64Attribute{
										Computed: true,
									},
									"num_leased": schema.Int64Attribute{
										Computed: true,
									},
								},
								CustomType: DhcpdStatType{
									ObjectType: types.ObjectType{
										AttrTypes: DhcpdStatValue{}.AttributeTypes(ctx),
									},
								},
							},
							Computed:            true,
							Description:         "Property key is the network name",
							MarkdownDescription: "Property key is the network name",
						},
						"evpntopo_id": schema.StringAttribute{
							Computed: true,
						},
						"fw_versions_outofsync": schema.BoolAttribute{
							Computed: true,
						},
						"fwupdate": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"progress": schema.Int64Attribute{
									Computed: true,
								},
								"status": schema.StringAttribute{
									Computed: true,
								},
								"status_id": schema.Int64Attribute{
									Computed: true,
								},
								"timestamp": schema.Float64Attribute{
									Computed: true,
								},
								"will_retry": schema.BoolAttribute{
									Computed: true,
								},
							},
							CustomType: FwupdateType{
								ObjectType: types.ObjectType{
									AttrTypes: FwupdateValue{}.AttributeTypes(ctx),
								},
							},
							Computed: true,
						},
						"has_pcap": schema.BoolAttribute{
							Computed:            true,
							Description:         "whether the switch supports packet capture",
							MarkdownDescription: "whether the switch supports packet capture",
						},
						"hostname": schema.StringAttribute{
							Computed:            true,
							Description:         "hostname reported by the device",
							MarkdownDescription: "hostname reported by the device",
						},
						"hw_rev": schema.StringAttribute{
							Computed:            true,
							Description:         "device hardware revision number",
							MarkdownDescription: "device hardware revision number",
						},
						"id": schema.StringAttribute{
							Computed: true,
						},
						"if_stat": schema.MapNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"address_mode": schema.StringAttribute{
										Computed: true,
									},
									"ips": schema.ListAttribute{
										ElementType: types.StringType,
										Computed:    true,
									},
									"nat_addresses": schema.ListAttribute{
										ElementType: types.StringType,
										Computed:    true,
									},
									"network_name": schema.StringAttribute{
										Computed: true,
									},
									"port_id": schema.StringAttribute{
										Computed: true,
									},
									"port_usage": schema.StringAttribute{
										Computed: true,
									},
									"redundancy_state": schema.StringAttribute{
										Computed: true,
									},
									"rx_bytes": schema.Int64Attribute{
										Computed: true,
									},
									"rx_pkts": schema.Int64Attribute{
										Computed: true,
									},
									"servp_info": schema.SingleNestedAttribute{
										Attributes: map[string]schema.Attribute{
											"asn": schema.StringAttribute{
												Computed: true,
											},
											"city": schema.StringAttribute{
												Computed: true,
											},
											"country_code": schema.StringAttribute{
												Computed: true,
											},
											"latitude": schema.NumberAttribute{
												Computed: true,
											},
											"longitude": schema.NumberAttribute{
												Computed: true,
											},
											"org": schema.StringAttribute{
												Computed: true,
											},
											"region_code": schema.StringAttribute{
												Computed: true,
											},
										},
										CustomType: ServpInfoType{
											ObjectType: types.ObjectType{
												AttrTypes: ServpInfoValue{}.AttributeTypes(ctx),
											},
										},
										Computed: true,
									},
									"tx_bytes": schema.Int64Attribute{
										Computed: true,
									},
									"tx_pkts": schema.Int64Attribute{
										Computed: true,
									},
									"up": schema.BoolAttribute{
										Computed: true,
									},
									"vlan": schema.Int64Attribute{
										Computed: true,
									},
									"wan_name": schema.StringAttribute{
										Computed: true,
									},
									"wan_type": schema.StringAttribute{
										Computed: true,
									},
								},
								CustomType: IfStatType{
									ObjectType: types.ObjectType{
										AttrTypes: IfStatValue{}.AttributeTypes(ctx),
									},
								},
							},
							Computed:            true,
							Description:         "Property key is the interface name",
							MarkdownDescription: "Property key is the interface name",
						},
						"ip": schema.StringAttribute{
							Computed: true,
						},
						"ip_stat": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"dhcp_server": schema.StringAttribute{
									Computed: true,
								},
								"dns": schema.ListAttribute{
									ElementType: types.StringType,
									Computed:    true,
								},
								"dns_suffix": schema.ListAttribute{
									ElementType: types.StringType,
									Computed:    true,
								},
								"gateway": schema.StringAttribute{
									Computed: true,
								},
								"gateway6": schema.StringAttribute{
									Computed: true,
								},
								"ip": schema.StringAttribute{
									Computed: true,
								},
								"ip6": schema.StringAttribute{
									Computed: true,
								},
								"ips": schema.MapAttribute{
									ElementType: types.StringType,
									Computed:    true,
								},
								"netmask": schema.StringAttribute{
									Computed: true,
								},
								"netmask6": schema.StringAttribute{
									Computed: true,
								},
							},
							CustomType: IpStatType{
								ObjectType: types.ObjectType{
									AttrTypes: IpStatValue{}.AttributeTypes(ctx),
								},
							},
							Computed: true,
						},
						"last_seen": schema.NumberAttribute{
							Computed: true,
						},
						"last_trouble": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"code": schema.StringAttribute{
									Computed:            true,
									Description:         "Code definitions list at /api/v1/consts/ap_led_status",
									MarkdownDescription: "Code definitions list at /api/v1/consts/ap_led_status",
								},
								"timestamp": schema.Int64Attribute{
									Computed: true,
								},
							},
							CustomType: LastTroubleType{
								ObjectType: types.ObjectType{
									AttrTypes: LastTroubleValue{}.AttributeTypes(ctx),
								},
							},
							Computed:            true,
							Description:         "last trouble code of switch",
							MarkdownDescription: "last trouble code of switch",
						},
						"mac": schema.StringAttribute{
							Computed: true,
						},
						"mac_table_stats": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"mac_table_count": schema.Int64Attribute{
									Computed: true,
								},
								"max_mac_entries_supported": schema.Int64Attribute{
									Computed: true,
								},
							},
							CustomType: MacTableStatsType{
								ObjectType: types.ObjectType{
									AttrTypes: MacTableStatsValue{}.AttributeTypes(ctx),
								},
							},
							Computed: true,
						},
						"map_id": schema.StringAttribute{
							Computed: true,
						},
						"memory_stat": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"usage": schema.NumberAttribute{
									Computed: true,
								},
							},
							CustomType: MemoryStatType{
								ObjectType: types.ObjectType{
									AttrTypes: MemoryStatValue{}.AttributeTypes(ctx),
								},
							},
							Computed:            true,
							Description:         "memory usage stat (for virtual chassis, memory usage of master RE)",
							MarkdownDescription: "memory usage stat (for virtual chassis, memory usage of master RE)",
						},
						"model": schema.StringAttribute{
							Computed: true,
						},
						"modified_time": schema.Int64Attribute{
							Computed: true,
						},
						"module_stat": schema.ListNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"backup_version": schema.StringAttribute{
										Computed: true,
									},
									"bios_version": schema.StringAttribute{
										Computed: true,
									},
									"cpld_version": schema.StringAttribute{
										Computed: true,
									},
									"errors": schema.ListNestedAttribute{
										NestedObject: schema.NestedAttributeObject{
											Attributes: map[string]schema.Attribute{
												"feature": schema.StringAttribute{
													Computed: true,
												},
												"minimum_version": schema.StringAttribute{
													Computed: true,
												},
												"reason": schema.StringAttribute{
													Computed: true,
												},
												"since": schema.Int64Attribute{
													Computed: true,
												},
												"type": schema.StringAttribute{
													Computed: true,
												},
											},
											CustomType: ErrorsType{
												ObjectType: types.ObjectType{
													AttrTypes: ErrorsValue{}.AttributeTypes(ctx),
												},
											},
										},
										Computed:            true,
										Description:         "used to report all error states the device node is running into.\nAn error should always have `type` and `since` fields, and could have some other fields specific to that type.",
										MarkdownDescription: "used to report all error states the device node is running into.\nAn error should always have `type` and `since` fields, and could have some other fields specific to that type.",
									},
									"fans": schema.ListNestedAttribute{
										NestedObject: schema.NestedAttributeObject{
											Attributes: map[string]schema.Attribute{
												"airflow": schema.StringAttribute{
													Computed: true,
												},
												"name": schema.StringAttribute{
													Computed: true,
												},
												"status": schema.StringAttribute{
													Computed: true,
												},
											},
											CustomType: FansType{
												ObjectType: types.ObjectType{
													AttrTypes: FansValue{}.AttributeTypes(ctx),
												},
											},
										},
										Computed: true,
									},
									"fpc_idx": schema.Int64Attribute{
										Computed: true,
									},
									"fpga_version": schema.StringAttribute{
										Computed: true,
									},
									"last_seen": schema.NumberAttribute{
										Computed: true,
									},
									"model": schema.StringAttribute{
										Computed: true,
									},
									"optics_cpld_version": schema.StringAttribute{
										Computed: true,
									},
									"pending_version": schema.StringAttribute{
										Computed: true,
									},
									"pics": schema.ListNestedAttribute{
										NestedObject: schema.NestedAttributeObject{
											Attributes: map[string]schema.Attribute{
												"index": schema.Int64Attribute{
													Computed: true,
												},
												"model_number": schema.StringAttribute{
													Computed: true,
												},
												"port_groups": schema.ListNestedAttribute{
													NestedObject: schema.NestedAttributeObject{
														Attributes: map[string]schema.Attribute{
															"count": schema.Int64Attribute{
																Computed: true,
															},
															"type": schema.StringAttribute{
																Computed: true,
															},
														},
														CustomType: PortGroupsType{
															ObjectType: types.ObjectType{
																AttrTypes: PortGroupsValue{}.AttributeTypes(ctx),
															},
														},
													},
													Computed: true,
												},
											},
											CustomType: PicsType{
												ObjectType: types.ObjectType{
													AttrTypes: PicsValue{}.AttributeTypes(ctx),
												},
											},
										},
										Computed: true,
									},
									"poe": schema.SingleNestedAttribute{
										Attributes: map[string]schema.Attribute{
											"max_power": schema.NumberAttribute{
												Computed: true,
											},
											"power_draw": schema.NumberAttribute{
												Computed: true,
											},
										},
										CustomType: PoeType{
											ObjectType: types.ObjectType{
												AttrTypes: PoeValue{}.AttributeTypes(ctx),
											},
										},
										Computed: true,
									},
									"poe_version": schema.StringAttribute{
										Computed: true,
									},
									"power_cpld_version": schema.StringAttribute{
										Computed: true,
									},
									"psus": schema.ListNestedAttribute{
										NestedObject: schema.NestedAttributeObject{
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													Computed: true,
												},
												"status": schema.StringAttribute{
													Computed: true,
												},
											},
											CustomType: PsusType{
												ObjectType: types.ObjectType{
													AttrTypes: PsusValue{}.AttributeTypes(ctx),
												},
											},
										},
										Computed: true,
									},
									"re_fpga_version": schema.StringAttribute{
										Computed: true,
									},
									"recovery_version": schema.StringAttribute{
										Computed: true,
									},
									"serial": schema.StringAttribute{
										Computed: true,
									},
									"status": schema.StringAttribute{
										Computed: true,
									},
									"temperatures": schema.ListNestedAttribute{
										NestedObject: schema.NestedAttributeObject{
											Attributes: map[string]schema.Attribute{
												"celsius": schema.NumberAttribute{
													Computed: true,
												},
												"name": schema.StringAttribute{
													Computed: true,
												},
												"status": schema.StringAttribute{
													Computed: true,
												},
											},
											CustomType: TemperaturesType{
												ObjectType: types.ObjectType{
													AttrTypes: TemperaturesValue{}.AttributeTypes(ctx),
												},
											},
										},
										Computed: true,
									},
									"tmc_fpga_version": schema.StringAttribute{
										Computed: true,
									},
									"uboot_version": schema.StringAttribute{
										Computed: true,
									},
									"uptime": schema.Int64Attribute{
										Computed: true,
									},
									"vc_links": schema.ListNestedAttribute{
										NestedObject: schema.NestedAttributeObject{
											Attributes: map[string]schema.Attribute{
												"neighbor_module_idx": schema.Int64Attribute{
													Computed: true,
												},
												"neighbor_port_id": schema.StringAttribute{
													Computed: true,
												},
												"port_id": schema.StringAttribute{
													Computed: true,
												},
											},
											CustomType: VcLinksType{
												ObjectType: types.ObjectType{
													AttrTypes: VcLinksValue{}.AttributeTypes(ctx),
												},
											},
										},
										Computed: true,
									},
									"vc_mode": schema.StringAttribute{
										Computed: true,
									},
									"vc_role": schema.StringAttribute{
										Computed:            true,
										Description:         "master / backup / linecard",
										MarkdownDescription: "master / backup / linecard",
									},
									"vc_state": schema.StringAttribute{
										Computed: true,
									},
									"version": schema.StringAttribute{
										Computed: true,
									},
								},
								CustomType: ModuleStatType{
									ObjectType: types.ObjectType{
										AttrTypes: ModuleStatValue{}.AttributeTypes(ctx),
									},
								},
							},
							Computed: true,
						},
						"name": schema.StringAttribute{
							Computed:            true,
							Description:         "device name if configured",
							MarkdownDescription: "device name if configured",
						},
						"org_id": schema.StringAttribute{
							Computed: true,
						},
						"route_summary_stats": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"fib_routes": schema.Int64Attribute{
									Computed: true,
								},
								"max_unicast_routes_supported": schema.Int64Attribute{
									Computed: true,
								},
								"rib_routes": schema.Int64Attribute{
									Computed: true,
								},
								"total_routes": schema.Int64Attribute{
									Computed: true,
								},
							},
							CustomType: RouteSummaryStatsType{
								ObjectType: types.ObjectType{
									AttrTypes: RouteSummaryStatsValue{}.AttributeTypes(ctx),
								},
							},
							Computed: true,
						},
						"serial": schema.StringAttribute{
							Computed: true,
						},
						"service_stat": schema.MapNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"ash_version": schema.StringAttribute{
										Computed: true,
									},
									"cia_version": schema.StringAttribute{
										Computed: true,
									},
									"ember_version": schema.StringAttribute{
										Computed: true,
									},
									"ipsec_client_version": schema.StringAttribute{
										Computed: true,
									},
									"mist_agent_version": schema.StringAttribute{
										Computed: true,
									},
									"package_version": schema.StringAttribute{
										Computed: true,
									},
									"testing_tools_version": schema.StringAttribute{
										Computed: true,
									},
									"wheeljack_version": schema.StringAttribute{
										Computed: true,
									},
								},
								CustomType: ServiceStatType{
									ObjectType: types.ObjectType{
										AttrTypes: ServiceStatValue{}.AttributeTypes(ctx),
									},
								},
							},
							Computed: true,
						},
						"site_id": schema.StringAttribute{
							Computed: true,
						},
						"status": schema.StringAttribute{
							Computed: true,
						},
						"uptime": schema.NumberAttribute{
							Computed: true,
						},
						"vc_mac": schema.StringAttribute{
							Computed: true,
						},
						"vc_setup_info": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"config_type": schema.StringAttribute{
									Computed: true,
								},
								"err_missing_dev_id_fpc": schema.BoolAttribute{
									Computed: true,
								},
							},
							CustomType: VcSetupInfoType{
								ObjectType: types.ObjectType{
									AttrTypes: VcSetupInfoValue{}.AttributeTypes(ctx),
								},
							},
							Computed: true,
						},
						"version": schema.StringAttribute{
							Computed: true,
						},
					},
					CustomType: DeviceSwitchStatsType{
						ObjectType: types.ObjectType{
							AttrTypes: DeviceSwitchStatsValue{}.AttributeTypes(ctx),
						},
					},
				},
				Computed: true,
			},
			"duration": schema.StringAttribute{
				Optional:            true,
				Description:         "duration like 7d, 2w",
				MarkdownDescription: "duration like 7d, 2w",
			},
			"end": schema.Int64Attribute{
				Optional:            true,
				Description:         "end datetime, can be epoch or relative time like -1d, -2h; now if not specified",
				MarkdownDescription: "end datetime, can be epoch or relative time like -1d, -2h; now if not specified",
			},
			"evpn_unused": schema.StringAttribute{
				Optional:            true,
				Description:         "if `evpn_unused`==`true`, find EVPN eligible switches which don’t belong to any EVPN Topology yet",
				MarkdownDescription: "if `evpn_unused`==`true`, find EVPN eligible switches which don’t belong to any EVPN Topology yet",
			},
			"evpntopo_id": schema.StringAttribute{
				Optional:            true,
				Description:         "EVPN Topology ID",
				MarkdownDescription: "EVPN Topology ID",
			},
			"mac": schema.StringAttribute{
				Optional: true,
			},
			"org_id": schema.StringAttribute{
				Required: true,
			},
			"site_id": schema.StringAttribute{
				Optional: true,
			},
			"start": schema.Int64Attribute{
				Optional:            true,
				Description:         "start datetime, can be epoch or relative time like -1d, -1w; -1d if not specified",
				MarkdownDescription: "start datetime, can be epoch or relative time like -1d, -1w; -1d if not specified",
			},
			"status": schema.StringAttribute{
				Optional: true,
				Validators: []validator.String{
					stringvalidator.OneOf(
						"",
						"all",
						"connected",
						"disconnected",
					),
				},
			},
		},
	}
}

type DeviceSwitchStatsModel struct {
	DeviceSwitchStats types.Set    `tfsdk:"device_switch_stats"`
	Duration          types.String `tfsdk:"duration"`
	End               types.Int64  `tfsdk:"end"`
	EvpnUnused        types.String `tfsdk:"evpn_unused"`
	EvpntopoId        types.String `tfsdk:"evpntopo_id"`
	Mac               types.String `tfsdk:"mac"`
	OrgId             types.String `tfsdk:"org_id"`
	SiteId            types.String `tfsdk:"site_id"`
	Start             types.Int64  `tfsdk:"start"`
	Status            types.String `tfsdk:"status"`
}

var _ basetypes.ObjectTypable = DeviceSwitchStatsType{}

type DeviceSwitchStatsType struct {
	basetypes.ObjectType
}

func (t DeviceSwitchStatsType) Equal(o attr.Type) bool {
	other, ok := o.(DeviceSwitchStatsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t DeviceSwitchStatsType) String() string {
	return "DeviceSwitchStatsType"
}

func (t DeviceSwitchStatsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	apRedundancyAttribute, ok := attributes["ap_redundancy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ap_redundancy is missing from object`)

		return nil, diags
	}

	apRedundancyVal, ok := apRedundancyAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ap_redundancy expected to be basetypes.ObjectValue, was: %T`, apRedundancyAttribute))
	}

	arpTableStatsAttribute, ok := attributes["arp_table_stats"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`arp_table_stats is missing from object`)

		return nil, diags
	}

	arpTableStatsVal, ok := arpTableStatsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`arp_table_stats expected to be basetypes.ObjectValue, was: %T`, arpTableStatsAttribute))
	}

	certExpiryAttribute, ok := attributes["cert_expiry"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cert_expiry is missing from object`)

		return nil, diags
	}

	certExpiryVal, ok := certExpiryAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cert_expiry expected to be basetypes.Int64Value, was: %T`, certExpiryAttribute))
	}

	clientsAttribute, ok := attributes["clients"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`clients is missing from object`)

		return nil, diags
	}

	clientsVal, ok := clientsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`clients expected to be basetypes.ListValue, was: %T`, clientsAttribute))
	}

	clientsStatsAttribute, ok := attributes["clients_stats"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`clients_stats is missing from object`)

		return nil, diags
	}

	clientsStatsVal, ok := clientsStatsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`clients_stats expected to be basetypes.ObjectValue, was: %T`, clientsStatsAttribute))
	}

	configStatusAttribute, ok := attributes["config_status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`config_status is missing from object`)

		return nil, diags
	}

	configStatusVal, ok := configStatusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`config_status expected to be basetypes.StringValue, was: %T`, configStatusAttribute))
	}

	cpuStatAttribute, ok := attributes["cpu_stat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cpu_stat is missing from object`)

		return nil, diags
	}

	cpuStatVal, ok := cpuStatAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cpu_stat expected to be basetypes.ObjectValue, was: %T`, cpuStatAttribute))
	}

	createdTimeAttribute, ok := attributes["created_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_time is missing from object`)

		return nil, diags
	}

	createdTimeVal, ok := createdTimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_time expected to be basetypes.Int64Value, was: %T`, createdTimeAttribute))
	}

	deviceprofileIdAttribute, ok := attributes["deviceprofile_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`deviceprofile_id is missing from object`)

		return nil, diags
	}

	deviceprofileIdVal, ok := deviceprofileIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`deviceprofile_id expected to be basetypes.StringValue, was: %T`, deviceprofileIdAttribute))
	}

	dhcpdStatAttribute, ok := attributes["dhcpd_stat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dhcpd_stat is missing from object`)

		return nil, diags
	}

	dhcpdStatVal, ok := dhcpdStatAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dhcpd_stat expected to be basetypes.MapValue, was: %T`, dhcpdStatAttribute))
	}

	evpntopoIdAttribute, ok := attributes["evpntopo_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`evpntopo_id is missing from object`)

		return nil, diags
	}

	evpntopoIdVal, ok := evpntopoIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`evpntopo_id expected to be basetypes.StringValue, was: %T`, evpntopoIdAttribute))
	}

	fwVersionsOutofsyncAttribute, ok := attributes["fw_versions_outofsync"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fw_versions_outofsync is missing from object`)

		return nil, diags
	}

	fwVersionsOutofsyncVal, ok := fwVersionsOutofsyncAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fw_versions_outofsync expected to be basetypes.BoolValue, was: %T`, fwVersionsOutofsyncAttribute))
	}

	fwupdateAttribute, ok := attributes["fwupdate"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fwupdate is missing from object`)

		return nil, diags
	}

	fwupdateVal, ok := fwupdateAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fwupdate expected to be basetypes.ObjectValue, was: %T`, fwupdateAttribute))
	}

	hasPcapAttribute, ok := attributes["has_pcap"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`has_pcap is missing from object`)

		return nil, diags
	}

	hasPcapVal, ok := hasPcapAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`has_pcap expected to be basetypes.BoolValue, was: %T`, hasPcapAttribute))
	}

	hostnameAttribute, ok := attributes["hostname"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`hostname is missing from object`)

		return nil, diags
	}

	hostnameVal, ok := hostnameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`hostname expected to be basetypes.StringValue, was: %T`, hostnameAttribute))
	}

	hwRevAttribute, ok := attributes["hw_rev"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`hw_rev is missing from object`)

		return nil, diags
	}

	hwRevVal, ok := hwRevAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`hw_rev expected to be basetypes.StringValue, was: %T`, hwRevAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	ifStatAttribute, ok := attributes["if_stat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`if_stat is missing from object`)

		return nil, diags
	}

	ifStatVal, ok := ifStatAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`if_stat expected to be basetypes.MapValue, was: %T`, ifStatAttribute))
	}

	ipAttribute, ok := attributes["ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip is missing from object`)

		return nil, diags
	}

	ipVal, ok := ipAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip expected to be basetypes.StringValue, was: %T`, ipAttribute))
	}

	ipStatAttribute, ok := attributes["ip_stat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_stat is missing from object`)

		return nil, diags
	}

	ipStatVal, ok := ipStatAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_stat expected to be basetypes.ObjectValue, was: %T`, ipStatAttribute))
	}

	lastSeenAttribute, ok := attributes["last_seen"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`last_seen is missing from object`)

		return nil, diags
	}

	lastSeenVal, ok := lastSeenAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`last_seen expected to be basetypes.NumberValue, was: %T`, lastSeenAttribute))
	}

	lastTroubleAttribute, ok := attributes["last_trouble"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`last_trouble is missing from object`)

		return nil, diags
	}

	lastTroubleVal, ok := lastTroubleAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`last_trouble expected to be basetypes.ObjectValue, was: %T`, lastTroubleAttribute))
	}

	macAttribute, ok := attributes["mac"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mac is missing from object`)

		return nil, diags
	}

	macVal, ok := macAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mac expected to be basetypes.StringValue, was: %T`, macAttribute))
	}

	macTableStatsAttribute, ok := attributes["mac_table_stats"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mac_table_stats is missing from object`)

		return nil, diags
	}

	macTableStatsVal, ok := macTableStatsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mac_table_stats expected to be basetypes.ObjectValue, was: %T`, macTableStatsAttribute))
	}

	mapIdAttribute, ok := attributes["map_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`map_id is missing from object`)

		return nil, diags
	}

	mapIdVal, ok := mapIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`map_id expected to be basetypes.StringValue, was: %T`, mapIdAttribute))
	}

	memoryStatAttribute, ok := attributes["memory_stat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`memory_stat is missing from object`)

		return nil, diags
	}

	memoryStatVal, ok := memoryStatAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`memory_stat expected to be basetypes.ObjectValue, was: %T`, memoryStatAttribute))
	}

	modelAttribute, ok := attributes["model"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`model is missing from object`)

		return nil, diags
	}

	modelVal, ok := modelAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`model expected to be basetypes.StringValue, was: %T`, modelAttribute))
	}

	modifiedTimeAttribute, ok := attributes["modified_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`modified_time is missing from object`)

		return nil, diags
	}

	modifiedTimeVal, ok := modifiedTimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`modified_time expected to be basetypes.Int64Value, was: %T`, modifiedTimeAttribute))
	}

	moduleStatAttribute, ok := attributes["module_stat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`module_stat is missing from object`)

		return nil, diags
	}

	moduleStatVal, ok := moduleStatAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`module_stat expected to be basetypes.ListValue, was: %T`, moduleStatAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	orgIdAttribute, ok := attributes["org_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`org_id is missing from object`)

		return nil, diags
	}

	orgIdVal, ok := orgIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`org_id expected to be basetypes.StringValue, was: %T`, orgIdAttribute))
	}

	routeSummaryStatsAttribute, ok := attributes["route_summary_stats"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`route_summary_stats is missing from object`)

		return nil, diags
	}

	routeSummaryStatsVal, ok := routeSummaryStatsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`route_summary_stats expected to be basetypes.ObjectValue, was: %T`, routeSummaryStatsAttribute))
	}

	serialAttribute, ok := attributes["serial"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`serial is missing from object`)

		return nil, diags
	}

	serialVal, ok := serialAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`serial expected to be basetypes.StringValue, was: %T`, serialAttribute))
	}

	serviceStatAttribute, ok := attributes["service_stat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`service_stat is missing from object`)

		return nil, diags
	}

	serviceStatVal, ok := serviceStatAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`service_stat expected to be basetypes.MapValue, was: %T`, serviceStatAttribute))
	}

	siteIdAttribute, ok := attributes["site_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`site_id is missing from object`)

		return nil, diags
	}

	siteIdVal, ok := siteIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`site_id expected to be basetypes.StringValue, was: %T`, siteIdAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return nil, diags
	}

	statusVal, ok := statusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be basetypes.StringValue, was: %T`, statusAttribute))
	}

	uptimeAttribute, ok := attributes["uptime"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uptime is missing from object`)

		return nil, diags
	}

	uptimeVal, ok := uptimeAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uptime expected to be basetypes.NumberValue, was: %T`, uptimeAttribute))
	}

	vcMacAttribute, ok := attributes["vc_mac"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vc_mac is missing from object`)

		return nil, diags
	}

	vcMacVal, ok := vcMacAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vc_mac expected to be basetypes.StringValue, was: %T`, vcMacAttribute))
	}

	vcSetupInfoAttribute, ok := attributes["vc_setup_info"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vc_setup_info is missing from object`)

		return nil, diags
	}

	vcSetupInfoVal, ok := vcSetupInfoAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vc_setup_info expected to be basetypes.ObjectValue, was: %T`, vcSetupInfoAttribute))
	}

	versionAttribute, ok := attributes["version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`version is missing from object`)

		return nil, diags
	}

	versionVal, ok := versionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`version expected to be basetypes.StringValue, was: %T`, versionAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return DeviceSwitchStatsValue{
		ApRedundancy:        apRedundancyVal,
		ArpTableStats:       arpTableStatsVal,
		CertExpiry:          certExpiryVal,
		Clients:             clientsVal,
		ClientsStats:        clientsStatsVal,
		ConfigStatus:        configStatusVal,
		CpuStat:             cpuStatVal,
		CreatedTime:         createdTimeVal,
		DeviceprofileId:     deviceprofileIdVal,
		DhcpdStat:           dhcpdStatVal,
		EvpntopoId:          evpntopoIdVal,
		FwVersionsOutofsync: fwVersionsOutofsyncVal,
		Fwupdate:            fwupdateVal,
		HasPcap:             hasPcapVal,
		Hostname:            hostnameVal,
		HwRev:               hwRevVal,
		Id:                  idVal,
		IfStat:              ifStatVal,
		Ip:                  ipVal,
		IpStat:              ipStatVal,
		LastSeen:            lastSeenVal,
		LastTrouble:         lastTroubleVal,
		Mac:                 macVal,
		MacTableStats:       macTableStatsVal,
		MapId:               mapIdVal,
		MemoryStat:          memoryStatVal,
		Model:               modelVal,
		ModifiedTime:        modifiedTimeVal,
		ModuleStat:          moduleStatVal,
		Name:                nameVal,
		OrgId:               orgIdVal,
		RouteSummaryStats:   routeSummaryStatsVal,
		Serial:              serialVal,
		ServiceStat:         serviceStatVal,
		SiteId:              siteIdVal,
		Status:              statusVal,
		Uptime:              uptimeVal,
		VcMac:               vcMacVal,
		VcSetupInfo:         vcSetupInfoVal,
		Version:             versionVal,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewDeviceSwitchStatsValueNull() DeviceSwitchStatsValue {
	return DeviceSwitchStatsValue{
		state: attr.ValueStateNull,
	}
}

func NewDeviceSwitchStatsValueUnknown() DeviceSwitchStatsValue {
	return DeviceSwitchStatsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewDeviceSwitchStatsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (DeviceSwitchStatsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing DeviceSwitchStatsValue Attribute Value",
				"While creating a DeviceSwitchStatsValue value, a missing attribute value was detected. "+
					"A DeviceSwitchStatsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DeviceSwitchStatsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid DeviceSwitchStatsValue Attribute Type",
				"While creating a DeviceSwitchStatsValue value, an invalid attribute value was detected. "+
					"A DeviceSwitchStatsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DeviceSwitchStatsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("DeviceSwitchStatsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra DeviceSwitchStatsValue Attribute Value",
				"While creating a DeviceSwitchStatsValue value, an extra attribute value was detected. "+
					"A DeviceSwitchStatsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra DeviceSwitchStatsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewDeviceSwitchStatsValueUnknown(), diags
	}

	apRedundancyAttribute, ok := attributes["ap_redundancy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ap_redundancy is missing from object`)

		return NewDeviceSwitchStatsValueUnknown(), diags
	}

	apRedundancyVal, ok := apRedundancyAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ap_redundancy expected to be basetypes.ObjectValue, was: %T`, apRedundancyAttribute))
	}

	arpTableStatsAttribute, ok := attributes["arp_table_stats"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`arp_table_stats is missing from object`)

		return NewDeviceSwitchStatsValueUnknown(), diags
	}

	arpTableStatsVal, ok := arpTableStatsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`arp_table_stats expected to be basetypes.ObjectValue, was: %T`, arpTableStatsAttribute))
	}

	certExpiryAttribute, ok := attributes["cert_expiry"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cert_expiry is missing from object`)

		return NewDeviceSwitchStatsValueUnknown(), diags
	}

	certExpiryVal, ok := certExpiryAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cert_expiry expected to be basetypes.Int64Value, was: %T`, certExpiryAttribute))
	}

	clientsAttribute, ok := attributes["clients"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`clients is missing from object`)

		return NewDeviceSwitchStatsValueUnknown(), diags
	}

	clientsVal, ok := clientsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`clients expected to be basetypes.ListValue, was: %T`, clientsAttribute))
	}

	clientsStatsAttribute, ok := attributes["clients_stats"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`clients_stats is missing from object`)

		return NewDeviceSwitchStatsValueUnknown(), diags
	}

	clientsStatsVal, ok := clientsStatsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`clients_stats expected to be basetypes.ObjectValue, was: %T`, clientsStatsAttribute))
	}

	configStatusAttribute, ok := attributes["config_status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`config_status is missing from object`)

		return NewDeviceSwitchStatsValueUnknown(), diags
	}

	configStatusVal, ok := configStatusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`config_status expected to be basetypes.StringValue, was: %T`, configStatusAttribute))
	}

	cpuStatAttribute, ok := attributes["cpu_stat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cpu_stat is missing from object`)

		return NewDeviceSwitchStatsValueUnknown(), diags
	}

	cpuStatVal, ok := cpuStatAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cpu_stat expected to be basetypes.ObjectValue, was: %T`, cpuStatAttribute))
	}

	createdTimeAttribute, ok := attributes["created_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_time is missing from object`)

		return NewDeviceSwitchStatsValueUnknown(), diags
	}

	createdTimeVal, ok := createdTimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_time expected to be basetypes.Int64Value, was: %T`, createdTimeAttribute))
	}

	deviceprofileIdAttribute, ok := attributes["deviceprofile_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`deviceprofile_id is missing from object`)

		return NewDeviceSwitchStatsValueUnknown(), diags
	}

	deviceprofileIdVal, ok := deviceprofileIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`deviceprofile_id expected to be basetypes.StringValue, was: %T`, deviceprofileIdAttribute))
	}

	dhcpdStatAttribute, ok := attributes["dhcpd_stat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dhcpd_stat is missing from object`)

		return NewDeviceSwitchStatsValueUnknown(), diags
	}

	dhcpdStatVal, ok := dhcpdStatAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dhcpd_stat expected to be basetypes.MapValue, was: %T`, dhcpdStatAttribute))
	}

	evpntopoIdAttribute, ok := attributes["evpntopo_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`evpntopo_id is missing from object`)

		return NewDeviceSwitchStatsValueUnknown(), diags
	}

	evpntopoIdVal, ok := evpntopoIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`evpntopo_id expected to be basetypes.StringValue, was: %T`, evpntopoIdAttribute))
	}

	fwVersionsOutofsyncAttribute, ok := attributes["fw_versions_outofsync"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fw_versions_outofsync is missing from object`)

		return NewDeviceSwitchStatsValueUnknown(), diags
	}

	fwVersionsOutofsyncVal, ok := fwVersionsOutofsyncAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fw_versions_outofsync expected to be basetypes.BoolValue, was: %T`, fwVersionsOutofsyncAttribute))
	}

	fwupdateAttribute, ok := attributes["fwupdate"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fwupdate is missing from object`)

		return NewDeviceSwitchStatsValueUnknown(), diags
	}

	fwupdateVal, ok := fwupdateAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fwupdate expected to be basetypes.ObjectValue, was: %T`, fwupdateAttribute))
	}

	hasPcapAttribute, ok := attributes["has_pcap"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`has_pcap is missing from object`)

		return NewDeviceSwitchStatsValueUnknown(), diags
	}

	hasPcapVal, ok := hasPcapAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`has_pcap expected to be basetypes.BoolValue, was: %T`, hasPcapAttribute))
	}

	hostnameAttribute, ok := attributes["hostname"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`hostname is missing from object`)

		return NewDeviceSwitchStatsValueUnknown(), diags
	}

	hostnameVal, ok := hostnameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`hostname expected to be basetypes.StringValue, was: %T`, hostnameAttribute))
	}

	hwRevAttribute, ok := attributes["hw_rev"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`hw_rev is missing from object`)

		return NewDeviceSwitchStatsValueUnknown(), diags
	}

	hwRevVal, ok := hwRevAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`hw_rev expected to be basetypes.StringValue, was: %T`, hwRevAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewDeviceSwitchStatsValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	ifStatAttribute, ok := attributes["if_stat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`if_stat is missing from object`)

		return NewDeviceSwitchStatsValueUnknown(), diags
	}

	ifStatVal, ok := ifStatAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`if_stat expected to be basetypes.MapValue, was: %T`, ifStatAttribute))
	}

	ipAttribute, ok := attributes["ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip is missing from object`)

		return NewDeviceSwitchStatsValueUnknown(), diags
	}

	ipVal, ok := ipAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip expected to be basetypes.StringValue, was: %T`, ipAttribute))
	}

	ipStatAttribute, ok := attributes["ip_stat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_stat is missing from object`)

		return NewDeviceSwitchStatsValueUnknown(), diags
	}

	ipStatVal, ok := ipStatAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_stat expected to be basetypes.ObjectValue, was: %T`, ipStatAttribute))
	}

	lastSeenAttribute, ok := attributes["last_seen"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`last_seen is missing from object`)

		return NewDeviceSwitchStatsValueUnknown(), diags
	}

	lastSeenVal, ok := lastSeenAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`last_seen expected to be basetypes.NumberValue, was: %T`, lastSeenAttribute))
	}

	lastTroubleAttribute, ok := attributes["last_trouble"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`last_trouble is missing from object`)

		return NewDeviceSwitchStatsValueUnknown(), diags
	}

	lastTroubleVal, ok := lastTroubleAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`last_trouble expected to be basetypes.ObjectValue, was: %T`, lastTroubleAttribute))
	}

	macAttribute, ok := attributes["mac"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mac is missing from object`)

		return NewDeviceSwitchStatsValueUnknown(), diags
	}

	macVal, ok := macAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mac expected to be basetypes.StringValue, was: %T`, macAttribute))
	}

	macTableStatsAttribute, ok := attributes["mac_table_stats"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mac_table_stats is missing from object`)

		return NewDeviceSwitchStatsValueUnknown(), diags
	}

	macTableStatsVal, ok := macTableStatsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mac_table_stats expected to be basetypes.ObjectValue, was: %T`, macTableStatsAttribute))
	}

	mapIdAttribute, ok := attributes["map_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`map_id is missing from object`)

		return NewDeviceSwitchStatsValueUnknown(), diags
	}

	mapIdVal, ok := mapIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`map_id expected to be basetypes.StringValue, was: %T`, mapIdAttribute))
	}

	memoryStatAttribute, ok := attributes["memory_stat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`memory_stat is missing from object`)

		return NewDeviceSwitchStatsValueUnknown(), diags
	}

	memoryStatVal, ok := memoryStatAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`memory_stat expected to be basetypes.ObjectValue, was: %T`, memoryStatAttribute))
	}

	modelAttribute, ok := attributes["model"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`model is missing from object`)

		return NewDeviceSwitchStatsValueUnknown(), diags
	}

	modelVal, ok := modelAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`model expected to be basetypes.StringValue, was: %T`, modelAttribute))
	}

	modifiedTimeAttribute, ok := attributes["modified_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`modified_time is missing from object`)

		return NewDeviceSwitchStatsValueUnknown(), diags
	}

	modifiedTimeVal, ok := modifiedTimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`modified_time expected to be basetypes.Int64Value, was: %T`, modifiedTimeAttribute))
	}

	moduleStatAttribute, ok := attributes["module_stat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`module_stat is missing from object`)

		return NewDeviceSwitchStatsValueUnknown(), diags
	}

	moduleStatVal, ok := moduleStatAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`module_stat expected to be basetypes.ListValue, was: %T`, moduleStatAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewDeviceSwitchStatsValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	orgIdAttribute, ok := attributes["org_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`org_id is missing from object`)

		return NewDeviceSwitchStatsValueUnknown(), diags
	}

	orgIdVal, ok := orgIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`org_id expected to be basetypes.StringValue, was: %T`, orgIdAttribute))
	}

	routeSummaryStatsAttribute, ok := attributes["route_summary_stats"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`route_summary_stats is missing from object`)

		return NewDeviceSwitchStatsValueUnknown(), diags
	}

	routeSummaryStatsVal, ok := routeSummaryStatsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`route_summary_stats expected to be basetypes.ObjectValue, was: %T`, routeSummaryStatsAttribute))
	}

	serialAttribute, ok := attributes["serial"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`serial is missing from object`)

		return NewDeviceSwitchStatsValueUnknown(), diags
	}

	serialVal, ok := serialAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`serial expected to be basetypes.StringValue, was: %T`, serialAttribute))
	}

	serviceStatAttribute, ok := attributes["service_stat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`service_stat is missing from object`)

		return NewDeviceSwitchStatsValueUnknown(), diags
	}

	serviceStatVal, ok := serviceStatAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`service_stat expected to be basetypes.MapValue, was: %T`, serviceStatAttribute))
	}

	siteIdAttribute, ok := attributes["site_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`site_id is missing from object`)

		return NewDeviceSwitchStatsValueUnknown(), diags
	}

	siteIdVal, ok := siteIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`site_id expected to be basetypes.StringValue, was: %T`, siteIdAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return NewDeviceSwitchStatsValueUnknown(), diags
	}

	statusVal, ok := statusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be basetypes.StringValue, was: %T`, statusAttribute))
	}

	uptimeAttribute, ok := attributes["uptime"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uptime is missing from object`)

		return NewDeviceSwitchStatsValueUnknown(), diags
	}

	uptimeVal, ok := uptimeAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uptime expected to be basetypes.NumberValue, was: %T`, uptimeAttribute))
	}

	vcMacAttribute, ok := attributes["vc_mac"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vc_mac is missing from object`)

		return NewDeviceSwitchStatsValueUnknown(), diags
	}

	vcMacVal, ok := vcMacAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vc_mac expected to be basetypes.StringValue, was: %T`, vcMacAttribute))
	}

	vcSetupInfoAttribute, ok := attributes["vc_setup_info"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vc_setup_info is missing from object`)

		return NewDeviceSwitchStatsValueUnknown(), diags
	}

	vcSetupInfoVal, ok := vcSetupInfoAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vc_setup_info expected to be basetypes.ObjectValue, was: %T`, vcSetupInfoAttribute))
	}

	versionAttribute, ok := attributes["version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`version is missing from object`)

		return NewDeviceSwitchStatsValueUnknown(), diags
	}

	versionVal, ok := versionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`version expected to be basetypes.StringValue, was: %T`, versionAttribute))
	}

	if diags.HasError() {
		return NewDeviceSwitchStatsValueUnknown(), diags
	}

	return DeviceSwitchStatsValue{
		ApRedundancy:        apRedundancyVal,
		ArpTableStats:       arpTableStatsVal,
		CertExpiry:          certExpiryVal,
		Clients:             clientsVal,
		ClientsStats:        clientsStatsVal,
		ConfigStatus:        configStatusVal,
		CpuStat:             cpuStatVal,
		CreatedTime:         createdTimeVal,
		DeviceprofileId:     deviceprofileIdVal,
		DhcpdStat:           dhcpdStatVal,
		EvpntopoId:          evpntopoIdVal,
		FwVersionsOutofsync: fwVersionsOutofsyncVal,
		Fwupdate:            fwupdateVal,
		HasPcap:             hasPcapVal,
		Hostname:            hostnameVal,
		HwRev:               hwRevVal,
		Id:                  idVal,
		IfStat:              ifStatVal,
		Ip:                  ipVal,
		IpStat:              ipStatVal,
		LastSeen:            lastSeenVal,
		LastTrouble:         lastTroubleVal,
		Mac:                 macVal,
		MacTableStats:       macTableStatsVal,
		MapId:               mapIdVal,
		MemoryStat:          memoryStatVal,
		Model:               modelVal,
		ModifiedTime:        modifiedTimeVal,
		ModuleStat:          moduleStatVal,
		Name:                nameVal,
		OrgId:               orgIdVal,
		RouteSummaryStats:   routeSummaryStatsVal,
		Serial:              serialVal,
		ServiceStat:         serviceStatVal,
		SiteId:              siteIdVal,
		Status:              statusVal,
		Uptime:              uptimeVal,
		VcMac:               vcMacVal,
		VcSetupInfo:         vcSetupInfoVal,
		Version:             versionVal,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewDeviceSwitchStatsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) DeviceSwitchStatsValue {
	object, diags := NewDeviceSwitchStatsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewDeviceSwitchStatsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t DeviceSwitchStatsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewDeviceSwitchStatsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewDeviceSwitchStatsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewDeviceSwitchStatsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewDeviceSwitchStatsValueMust(DeviceSwitchStatsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t DeviceSwitchStatsType) ValueType(ctx context.Context) attr.Value {
	return DeviceSwitchStatsValue{}
}

var _ basetypes.ObjectValuable = DeviceSwitchStatsValue{}

type DeviceSwitchStatsValue struct {
	ApRedundancy        basetypes.ObjectValue `tfsdk:"ap_redundancy"`
	ArpTableStats       basetypes.ObjectValue `tfsdk:"arp_table_stats"`
	CertExpiry          basetypes.Int64Value  `tfsdk:"cert_expiry"`
	Clients             basetypes.ListValue   `tfsdk:"clients"`
	ClientsStats        basetypes.ObjectValue `tfsdk:"clients_stats"`
	ConfigStatus        basetypes.StringValue `tfsdk:"config_status"`
	CpuStat             basetypes.ObjectValue `tfsdk:"cpu_stat"`
	CreatedTime         basetypes.Int64Value  `tfsdk:"created_time"`
	DeviceprofileId     basetypes.StringValue `tfsdk:"deviceprofile_id"`
	DhcpdStat           basetypes.MapValue    `tfsdk:"dhcpd_stat"`
	EvpntopoId          basetypes.StringValue `tfsdk:"evpntopo_id"`
	FwVersionsOutofsync basetypes.BoolValue   `tfsdk:"fw_versions_outofsync"`
	Fwupdate            basetypes.ObjectValue `tfsdk:"fwupdate"`
	HasPcap             basetypes.BoolValue   `tfsdk:"has_pcap"`
	Hostname            basetypes.StringValue `tfsdk:"hostname"`
	HwRev               basetypes.StringValue `tfsdk:"hw_rev"`
	Id                  basetypes.StringValue `tfsdk:"id"`
	IfStat              basetypes.MapValue    `tfsdk:"if_stat"`
	Ip                  basetypes.StringValue `tfsdk:"ip"`
	IpStat              basetypes.ObjectValue `tfsdk:"ip_stat"`
	LastSeen            basetypes.NumberValue `tfsdk:"last_seen"`
	LastTrouble         basetypes.ObjectValue `tfsdk:"last_trouble"`
	Mac                 basetypes.StringValue `tfsdk:"mac"`
	MacTableStats       basetypes.ObjectValue `tfsdk:"mac_table_stats"`
	MapId               basetypes.StringValue `tfsdk:"map_id"`
	MemoryStat          basetypes.ObjectValue `tfsdk:"memory_stat"`
	Model               basetypes.StringValue `tfsdk:"model"`
	ModifiedTime        basetypes.Int64Value  `tfsdk:"modified_time"`
	ModuleStat          basetypes.ListValue   `tfsdk:"module_stat"`
	Name                basetypes.StringValue `tfsdk:"name"`
	OrgId               basetypes.StringValue `tfsdk:"org_id"`
	RouteSummaryStats   basetypes.ObjectValue `tfsdk:"route_summary_stats"`
	Serial              basetypes.StringValue `tfsdk:"serial"`
	ServiceStat         basetypes.MapValue    `tfsdk:"service_stat"`
	SiteId              basetypes.StringValue `tfsdk:"site_id"`
	Status              basetypes.StringValue `tfsdk:"status"`
	Uptime              basetypes.NumberValue `tfsdk:"uptime"`
	VcMac               basetypes.StringValue `tfsdk:"vc_mac"`
	VcSetupInfo         basetypes.ObjectValue `tfsdk:"vc_setup_info"`
	Version             basetypes.StringValue `tfsdk:"version"`
	state               attr.ValueState
}

func (v DeviceSwitchStatsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 40)

	var val tftypes.Value
	var err error

	attrTypes["ap_redundancy"] = basetypes.ObjectType{
		AttrTypes: ApRedundancyValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["arp_table_stats"] = basetypes.ObjectType{
		AttrTypes: ArpTableStatsValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["cert_expiry"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["clients"] = basetypes.ListType{
		ElemType: ClientsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["clients_stats"] = basetypes.ObjectType{
		AttrTypes: ClientsStatsValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["config_status"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["cpu_stat"] = basetypes.ObjectType{
		AttrTypes: CpuStatValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["created_time"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["deviceprofile_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["dhcpd_stat"] = basetypes.MapType{
		ElemType: DhcpdStatValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["evpntopo_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["fw_versions_outofsync"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["fwupdate"] = basetypes.ObjectType{
		AttrTypes: FwupdateValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["has_pcap"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["hostname"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["hw_rev"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["if_stat"] = basetypes.MapType{
		ElemType: IfStatValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["ip"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ip_stat"] = basetypes.ObjectType{
		AttrTypes: IpStatValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["last_seen"] = basetypes.NumberType{}.TerraformType(ctx)
	attrTypes["last_trouble"] = basetypes.ObjectType{
		AttrTypes: LastTroubleValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["mac"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["mac_table_stats"] = basetypes.ObjectType{
		AttrTypes: MacTableStatsValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["map_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["memory_stat"] = basetypes.ObjectType{
		AttrTypes: MemoryStatValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["model"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["modified_time"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["module_stat"] = basetypes.ListType{
		ElemType: ModuleStatValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["org_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["route_summary_stats"] = basetypes.ObjectType{
		AttrTypes: RouteSummaryStatsValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["serial"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["service_stat"] = basetypes.MapType{
		ElemType: ServiceStatValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["site_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["status"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["uptime"] = basetypes.NumberType{}.TerraformType(ctx)
	attrTypes["vc_mac"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["vc_setup_info"] = basetypes.ObjectType{
		AttrTypes: VcSetupInfoValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["version"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 40)

		val, err = v.ApRedundancy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ap_redundancy"] = val

		val, err = v.ArpTableStats.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["arp_table_stats"] = val

		val, err = v.CertExpiry.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cert_expiry"] = val

		val, err = v.Clients.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["clients"] = val

		val, err = v.ClientsStats.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["clients_stats"] = val

		val, err = v.ConfigStatus.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["config_status"] = val

		val, err = v.CpuStat.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cpu_stat"] = val

		val, err = v.CreatedTime.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["created_time"] = val

		val, err = v.DeviceprofileId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["deviceprofile_id"] = val

		val, err = v.DhcpdStat.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dhcpd_stat"] = val

		val, err = v.EvpntopoId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["evpntopo_id"] = val

		val, err = v.FwVersionsOutofsync.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["fw_versions_outofsync"] = val

		val, err = v.Fwupdate.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["fwupdate"] = val

		val, err = v.HasPcap.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["has_pcap"] = val

		val, err = v.Hostname.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["hostname"] = val

		val, err = v.HwRev.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["hw_rev"] = val

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.IfStat.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["if_stat"] = val

		val, err = v.Ip.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip"] = val

		val, err = v.IpStat.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip_stat"] = val

		val, err = v.LastSeen.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["last_seen"] = val

		val, err = v.LastTrouble.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["last_trouble"] = val

		val, err = v.Mac.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mac"] = val

		val, err = v.MacTableStats.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mac_table_stats"] = val

		val, err = v.MapId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["map_id"] = val

		val, err = v.MemoryStat.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["memory_stat"] = val

		val, err = v.Model.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["model"] = val

		val, err = v.ModifiedTime.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["modified_time"] = val

		val, err = v.ModuleStat.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["module_stat"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.OrgId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["org_id"] = val

		val, err = v.RouteSummaryStats.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["route_summary_stats"] = val

		val, err = v.Serial.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["serial"] = val

		val, err = v.ServiceStat.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["service_stat"] = val

		val, err = v.SiteId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["site_id"] = val

		val, err = v.Status.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["status"] = val

		val, err = v.Uptime.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["uptime"] = val

		val, err = v.VcMac.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vc_mac"] = val

		val, err = v.VcSetupInfo.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vc_setup_info"] = val

		val, err = v.Version.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["version"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v DeviceSwitchStatsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v DeviceSwitchStatsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v DeviceSwitchStatsValue) String() string {
	return "DeviceSwitchStatsValue"
}

func (v DeviceSwitchStatsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var apRedundancy basetypes.ObjectValue

	if v.ApRedundancy.IsNull() {
		apRedundancy = types.ObjectNull(
			ApRedundancyValue{}.AttributeTypes(ctx),
		)
	}

	if v.ApRedundancy.IsUnknown() {
		apRedundancy = types.ObjectUnknown(
			ApRedundancyValue{}.AttributeTypes(ctx),
		)
	}

	if !v.ApRedundancy.IsNull() && !v.ApRedundancy.IsUnknown() {
		apRedundancy = types.ObjectValueMust(
			ApRedundancyValue{}.AttributeTypes(ctx),
			v.ApRedundancy.Attributes(),
		)
	}

	var arpTableStats basetypes.ObjectValue

	if v.ArpTableStats.IsNull() {
		arpTableStats = types.ObjectNull(
			ArpTableStatsValue{}.AttributeTypes(ctx),
		)
	}

	if v.ArpTableStats.IsUnknown() {
		arpTableStats = types.ObjectUnknown(
			ArpTableStatsValue{}.AttributeTypes(ctx),
		)
	}

	if !v.ArpTableStats.IsNull() && !v.ArpTableStats.IsUnknown() {
		arpTableStats = types.ObjectValueMust(
			ArpTableStatsValue{}.AttributeTypes(ctx),
			v.ArpTableStats.Attributes(),
		)
	}

	clients := types.ListValueMust(
		ClientsType{
			basetypes.ObjectType{
				AttrTypes: ClientsValue{}.AttributeTypes(ctx),
			},
		},
		v.Clients.Elements(),
	)

	if v.Clients.IsNull() {
		clients = types.ListNull(
			ClientsType{
				basetypes.ObjectType{
					AttrTypes: ClientsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Clients.IsUnknown() {
		clients = types.ListUnknown(
			ClientsType{
				basetypes.ObjectType{
					AttrTypes: ClientsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var clientsStats basetypes.ObjectValue

	if v.ClientsStats.IsNull() {
		clientsStats = types.ObjectNull(
			ClientsStatsValue{}.AttributeTypes(ctx),
		)
	}

	if v.ClientsStats.IsUnknown() {
		clientsStats = types.ObjectUnknown(
			ClientsStatsValue{}.AttributeTypes(ctx),
		)
	}

	if !v.ClientsStats.IsNull() && !v.ClientsStats.IsUnknown() {
		clientsStats = types.ObjectValueMust(
			ClientsStatsValue{}.AttributeTypes(ctx),
			v.ClientsStats.Attributes(),
		)
	}

	var cpuStat basetypes.ObjectValue

	if v.CpuStat.IsNull() {
		cpuStat = types.ObjectNull(
			CpuStatValue{}.AttributeTypes(ctx),
		)
	}

	if v.CpuStat.IsUnknown() {
		cpuStat = types.ObjectUnknown(
			CpuStatValue{}.AttributeTypes(ctx),
		)
	}

	if !v.CpuStat.IsNull() && !v.CpuStat.IsUnknown() {
		cpuStat = types.ObjectValueMust(
			CpuStatValue{}.AttributeTypes(ctx),
			v.CpuStat.Attributes(),
		)
	}

	dhcpdStat := types.MapValueMust(
		DhcpdStatType{
			basetypes.ObjectType{
				AttrTypes: DhcpdStatValue{}.AttributeTypes(ctx),
			},
		},
		v.DhcpdStat.Elements(),
	)

	if v.DhcpdStat.IsNull() {
		dhcpdStat = types.MapNull(
			DhcpdStatType{
				basetypes.ObjectType{
					AttrTypes: DhcpdStatValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.DhcpdStat.IsUnknown() {
		dhcpdStat = types.MapUnknown(
			DhcpdStatType{
				basetypes.ObjectType{
					AttrTypes: DhcpdStatValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var fwupdate basetypes.ObjectValue

	if v.Fwupdate.IsNull() {
		fwupdate = types.ObjectNull(
			FwupdateValue{}.AttributeTypes(ctx),
		)
	}

	if v.Fwupdate.IsUnknown() {
		fwupdate = types.ObjectUnknown(
			FwupdateValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Fwupdate.IsNull() && !v.Fwupdate.IsUnknown() {
		fwupdate = types.ObjectValueMust(
			FwupdateValue{}.AttributeTypes(ctx),
			v.Fwupdate.Attributes(),
		)
	}

	ifStat := types.MapValueMust(
		IfStatType{
			basetypes.ObjectType{
				AttrTypes: IfStatValue{}.AttributeTypes(ctx),
			},
		},
		v.IfStat.Elements(),
	)

	if v.IfStat.IsNull() {
		ifStat = types.MapNull(
			IfStatType{
				basetypes.ObjectType{
					AttrTypes: IfStatValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.IfStat.IsUnknown() {
		ifStat = types.MapUnknown(
			IfStatType{
				basetypes.ObjectType{
					AttrTypes: IfStatValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var ipStat basetypes.ObjectValue

	if v.IpStat.IsNull() {
		ipStat = types.ObjectNull(
			IpStatValue{}.AttributeTypes(ctx),
		)
	}

	if v.IpStat.IsUnknown() {
		ipStat = types.ObjectUnknown(
			IpStatValue{}.AttributeTypes(ctx),
		)
	}

	if !v.IpStat.IsNull() && !v.IpStat.IsUnknown() {
		ipStat = types.ObjectValueMust(
			IpStatValue{}.AttributeTypes(ctx),
			v.IpStat.Attributes(),
		)
	}

	var lastTrouble basetypes.ObjectValue

	if v.LastTrouble.IsNull() {
		lastTrouble = types.ObjectNull(
			LastTroubleValue{}.AttributeTypes(ctx),
		)
	}

	if v.LastTrouble.IsUnknown() {
		lastTrouble = types.ObjectUnknown(
			LastTroubleValue{}.AttributeTypes(ctx),
		)
	}

	if !v.LastTrouble.IsNull() && !v.LastTrouble.IsUnknown() {
		lastTrouble = types.ObjectValueMust(
			LastTroubleValue{}.AttributeTypes(ctx),
			v.LastTrouble.Attributes(),
		)
	}

	var macTableStats basetypes.ObjectValue

	if v.MacTableStats.IsNull() {
		macTableStats = types.ObjectNull(
			MacTableStatsValue{}.AttributeTypes(ctx),
		)
	}

	if v.MacTableStats.IsUnknown() {
		macTableStats = types.ObjectUnknown(
			MacTableStatsValue{}.AttributeTypes(ctx),
		)
	}

	if !v.MacTableStats.IsNull() && !v.MacTableStats.IsUnknown() {
		macTableStats = types.ObjectValueMust(
			MacTableStatsValue{}.AttributeTypes(ctx),
			v.MacTableStats.Attributes(),
		)
	}

	var memoryStat basetypes.ObjectValue

	if v.MemoryStat.IsNull() {
		memoryStat = types.ObjectNull(
			MemoryStatValue{}.AttributeTypes(ctx),
		)
	}

	if v.MemoryStat.IsUnknown() {
		memoryStat = types.ObjectUnknown(
			MemoryStatValue{}.AttributeTypes(ctx),
		)
	}

	if !v.MemoryStat.IsNull() && !v.MemoryStat.IsUnknown() {
		memoryStat = types.ObjectValueMust(
			MemoryStatValue{}.AttributeTypes(ctx),
			v.MemoryStat.Attributes(),
		)
	}

	moduleStat := types.ListValueMust(
		ModuleStatType{
			basetypes.ObjectType{
				AttrTypes: ModuleStatValue{}.AttributeTypes(ctx),
			},
		},
		v.ModuleStat.Elements(),
	)

	if v.ModuleStat.IsNull() {
		moduleStat = types.ListNull(
			ModuleStatType{
				basetypes.ObjectType{
					AttrTypes: ModuleStatValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.ModuleStat.IsUnknown() {
		moduleStat = types.ListUnknown(
			ModuleStatType{
				basetypes.ObjectType{
					AttrTypes: ModuleStatValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var routeSummaryStats basetypes.ObjectValue

	if v.RouteSummaryStats.IsNull() {
		routeSummaryStats = types.ObjectNull(
			RouteSummaryStatsValue{}.AttributeTypes(ctx),
		)
	}

	if v.RouteSummaryStats.IsUnknown() {
		routeSummaryStats = types.ObjectUnknown(
			RouteSummaryStatsValue{}.AttributeTypes(ctx),
		)
	}

	if !v.RouteSummaryStats.IsNull() && !v.RouteSummaryStats.IsUnknown() {
		routeSummaryStats = types.ObjectValueMust(
			RouteSummaryStatsValue{}.AttributeTypes(ctx),
			v.RouteSummaryStats.Attributes(),
		)
	}

	serviceStat := types.MapValueMust(
		ServiceStatType{
			basetypes.ObjectType{
				AttrTypes: ServiceStatValue{}.AttributeTypes(ctx),
			},
		},
		v.ServiceStat.Elements(),
	)

	if v.ServiceStat.IsNull() {
		serviceStat = types.MapNull(
			ServiceStatType{
				basetypes.ObjectType{
					AttrTypes: ServiceStatValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.ServiceStat.IsUnknown() {
		serviceStat = types.MapUnknown(
			ServiceStatType{
				basetypes.ObjectType{
					AttrTypes: ServiceStatValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var vcSetupInfo basetypes.ObjectValue

	if v.VcSetupInfo.IsNull() {
		vcSetupInfo = types.ObjectNull(
			VcSetupInfoValue{}.AttributeTypes(ctx),
		)
	}

	if v.VcSetupInfo.IsUnknown() {
		vcSetupInfo = types.ObjectUnknown(
			VcSetupInfoValue{}.AttributeTypes(ctx),
		)
	}

	if !v.VcSetupInfo.IsNull() && !v.VcSetupInfo.IsUnknown() {
		vcSetupInfo = types.ObjectValueMust(
			VcSetupInfoValue{}.AttributeTypes(ctx),
			v.VcSetupInfo.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"ap_redundancy": basetypes.ObjectType{
			AttrTypes: ApRedundancyValue{}.AttributeTypes(ctx),
		},
		"arp_table_stats": basetypes.ObjectType{
			AttrTypes: ArpTableStatsValue{}.AttributeTypes(ctx),
		},
		"cert_expiry": basetypes.Int64Type{},
		"clients": basetypes.ListType{
			ElemType: ClientsValue{}.Type(ctx),
		},
		"clients_stats": basetypes.ObjectType{
			AttrTypes: ClientsStatsValue{}.AttributeTypes(ctx),
		},
		"config_status": basetypes.StringType{},
		"cpu_stat": basetypes.ObjectType{
			AttrTypes: CpuStatValue{}.AttributeTypes(ctx),
		},
		"created_time":     basetypes.Int64Type{},
		"deviceprofile_id": basetypes.StringType{},
		"dhcpd_stat": basetypes.MapType{
			ElemType: DhcpdStatValue{}.Type(ctx),
		},
		"evpntopo_id":           basetypes.StringType{},
		"fw_versions_outofsync": basetypes.BoolType{},
		"fwupdate": basetypes.ObjectType{
			AttrTypes: FwupdateValue{}.AttributeTypes(ctx),
		},
		"has_pcap": basetypes.BoolType{},
		"hostname": basetypes.StringType{},
		"hw_rev":   basetypes.StringType{},
		"id":       basetypes.StringType{},
		"if_stat": basetypes.MapType{
			ElemType: IfStatValue{}.Type(ctx),
		},
		"ip": basetypes.StringType{},
		"ip_stat": basetypes.ObjectType{
			AttrTypes: IpStatValue{}.AttributeTypes(ctx),
		},
		"last_seen": basetypes.NumberType{},
		"last_trouble": basetypes.ObjectType{
			AttrTypes: LastTroubleValue{}.AttributeTypes(ctx),
		},
		"mac": basetypes.StringType{},
		"mac_table_stats": basetypes.ObjectType{
			AttrTypes: MacTableStatsValue{}.AttributeTypes(ctx),
		},
		"map_id": basetypes.StringType{},
		"memory_stat": basetypes.ObjectType{
			AttrTypes: MemoryStatValue{}.AttributeTypes(ctx),
		},
		"model":         basetypes.StringType{},
		"modified_time": basetypes.Int64Type{},
		"module_stat": basetypes.ListType{
			ElemType: ModuleStatValue{}.Type(ctx),
		},
		"name":   basetypes.StringType{},
		"org_id": basetypes.StringType{},
		"route_summary_stats": basetypes.ObjectType{
			AttrTypes: RouteSummaryStatsValue{}.AttributeTypes(ctx),
		},
		"serial": basetypes.StringType{},
		"service_stat": basetypes.MapType{
			ElemType: ServiceStatValue{}.Type(ctx),
		},
		"site_id": basetypes.StringType{},
		"status":  basetypes.StringType{},
		"uptime":  basetypes.NumberType{},
		"vc_mac":  basetypes.StringType{},
		"vc_setup_info": basetypes.ObjectType{
			AttrTypes: VcSetupInfoValue{}.AttributeTypes(ctx),
		},
		"version": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"ap_redundancy":         apRedundancy,
			"arp_table_stats":       arpTableStats,
			"cert_expiry":           v.CertExpiry,
			"clients":               clients,
			"clients_stats":         clientsStats,
			"config_status":         v.ConfigStatus,
			"cpu_stat":              cpuStat,
			"created_time":          v.CreatedTime,
			"deviceprofile_id":      v.DeviceprofileId,
			"dhcpd_stat":            dhcpdStat,
			"evpntopo_id":           v.EvpntopoId,
			"fw_versions_outofsync": v.FwVersionsOutofsync,
			"fwupdate":              fwupdate,
			"has_pcap":              v.HasPcap,
			"hostname":              v.Hostname,
			"hw_rev":                v.HwRev,
			"id":                    v.Id,
			"if_stat":               ifStat,
			"ip":                    v.Ip,
			"ip_stat":               ipStat,
			"last_seen":             v.LastSeen,
			"last_trouble":          lastTrouble,
			"mac":                   v.Mac,
			"mac_table_stats":       macTableStats,
			"map_id":                v.MapId,
			"memory_stat":           memoryStat,
			"model":                 v.Model,
			"modified_time":         v.ModifiedTime,
			"module_stat":           moduleStat,
			"name":                  v.Name,
			"org_id":                v.OrgId,
			"route_summary_stats":   routeSummaryStats,
			"serial":                v.Serial,
			"service_stat":          serviceStat,
			"site_id":               v.SiteId,
			"status":                v.Status,
			"uptime":                v.Uptime,
			"vc_mac":                v.VcMac,
			"vc_setup_info":         vcSetupInfo,
			"version":               v.Version,
		})

	return objVal, diags
}

func (v DeviceSwitchStatsValue) Equal(o attr.Value) bool {
	other, ok := o.(DeviceSwitchStatsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.ApRedundancy.Equal(other.ApRedundancy) {
		return false
	}

	if !v.ArpTableStats.Equal(other.ArpTableStats) {
		return false
	}

	if !v.CertExpiry.Equal(other.CertExpiry) {
		return false
	}

	if !v.Clients.Equal(other.Clients) {
		return false
	}

	if !v.ClientsStats.Equal(other.ClientsStats) {
		return false
	}

	if !v.ConfigStatus.Equal(other.ConfigStatus) {
		return false
	}

	if !v.CpuStat.Equal(other.CpuStat) {
		return false
	}

	if !v.CreatedTime.Equal(other.CreatedTime) {
		return false
	}

	if !v.DeviceprofileId.Equal(other.DeviceprofileId) {
		return false
	}

	if !v.DhcpdStat.Equal(other.DhcpdStat) {
		return false
	}

	if !v.EvpntopoId.Equal(other.EvpntopoId) {
		return false
	}

	if !v.FwVersionsOutofsync.Equal(other.FwVersionsOutofsync) {
		return false
	}

	if !v.Fwupdate.Equal(other.Fwupdate) {
		return false
	}

	if !v.HasPcap.Equal(other.HasPcap) {
		return false
	}

	if !v.Hostname.Equal(other.Hostname) {
		return false
	}

	if !v.HwRev.Equal(other.HwRev) {
		return false
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.IfStat.Equal(other.IfStat) {
		return false
	}

	if !v.Ip.Equal(other.Ip) {
		return false
	}

	if !v.IpStat.Equal(other.IpStat) {
		return false
	}

	if !v.LastSeen.Equal(other.LastSeen) {
		return false
	}

	if !v.LastTrouble.Equal(other.LastTrouble) {
		return false
	}

	if !v.Mac.Equal(other.Mac) {
		return false
	}

	if !v.MacTableStats.Equal(other.MacTableStats) {
		return false
	}

	if !v.MapId.Equal(other.MapId) {
		return false
	}

	if !v.MemoryStat.Equal(other.MemoryStat) {
		return false
	}

	if !v.Model.Equal(other.Model) {
		return false
	}

	if !v.ModifiedTime.Equal(other.ModifiedTime) {
		return false
	}

	if !v.ModuleStat.Equal(other.ModuleStat) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.OrgId.Equal(other.OrgId) {
		return false
	}

	if !v.RouteSummaryStats.Equal(other.RouteSummaryStats) {
		return false
	}

	if !v.Serial.Equal(other.Serial) {
		return false
	}

	if !v.ServiceStat.Equal(other.ServiceStat) {
		return false
	}

	if !v.SiteId.Equal(other.SiteId) {
		return false
	}

	if !v.Status.Equal(other.Status) {
		return false
	}

	if !v.Uptime.Equal(other.Uptime) {
		return false
	}

	if !v.VcMac.Equal(other.VcMac) {
		return false
	}

	if !v.VcSetupInfo.Equal(other.VcSetupInfo) {
		return false
	}

	if !v.Version.Equal(other.Version) {
		return false
	}

	return true
}

func (v DeviceSwitchStatsValue) Type(ctx context.Context) attr.Type {
	return DeviceSwitchStatsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v DeviceSwitchStatsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"ap_redundancy": basetypes.ObjectType{
			AttrTypes: ApRedundancyValue{}.AttributeTypes(ctx),
		},
		"arp_table_stats": basetypes.ObjectType{
			AttrTypes: ArpTableStatsValue{}.AttributeTypes(ctx),
		},
		"cert_expiry": basetypes.Int64Type{},
		"clients": basetypes.ListType{
			ElemType: ClientsValue{}.Type(ctx),
		},
		"clients_stats": basetypes.ObjectType{
			AttrTypes: ClientsStatsValue{}.AttributeTypes(ctx),
		},
		"config_status": basetypes.StringType{},
		"cpu_stat": basetypes.ObjectType{
			AttrTypes: CpuStatValue{}.AttributeTypes(ctx),
		},
		"created_time":     basetypes.Int64Type{},
		"deviceprofile_id": basetypes.StringType{},
		"dhcpd_stat": basetypes.MapType{
			ElemType: DhcpdStatValue{}.Type(ctx),
		},
		"evpntopo_id":           basetypes.StringType{},
		"fw_versions_outofsync": basetypes.BoolType{},
		"fwupdate": basetypes.ObjectType{
			AttrTypes: FwupdateValue{}.AttributeTypes(ctx),
		},
		"has_pcap": basetypes.BoolType{},
		"hostname": basetypes.StringType{},
		"hw_rev":   basetypes.StringType{},
		"id":       basetypes.StringType{},
		"if_stat": basetypes.MapType{
			ElemType: IfStatValue{}.Type(ctx),
		},
		"ip": basetypes.StringType{},
		"ip_stat": basetypes.ObjectType{
			AttrTypes: IpStatValue{}.AttributeTypes(ctx),
		},
		"last_seen": basetypes.NumberType{},
		"last_trouble": basetypes.ObjectType{
			AttrTypes: LastTroubleValue{}.AttributeTypes(ctx),
		},
		"mac": basetypes.StringType{},
		"mac_table_stats": basetypes.ObjectType{
			AttrTypes: MacTableStatsValue{}.AttributeTypes(ctx),
		},
		"map_id": basetypes.StringType{},
		"memory_stat": basetypes.ObjectType{
			AttrTypes: MemoryStatValue{}.AttributeTypes(ctx),
		},
		"model":         basetypes.StringType{},
		"modified_time": basetypes.Int64Type{},
		"module_stat": basetypes.ListType{
			ElemType: ModuleStatValue{}.Type(ctx),
		},
		"name":   basetypes.StringType{},
		"org_id": basetypes.StringType{},
		"route_summary_stats": basetypes.ObjectType{
			AttrTypes: RouteSummaryStatsValue{}.AttributeTypes(ctx),
		},
		"serial": basetypes.StringType{},
		"service_stat": basetypes.MapType{
			ElemType: ServiceStatValue{}.Type(ctx),
		},
		"site_id": basetypes.StringType{},
		"status":  basetypes.StringType{},
		"uptime":  basetypes.NumberType{},
		"vc_mac":  basetypes.StringType{},
		"vc_setup_info": basetypes.ObjectType{
			AttrTypes: VcSetupInfoValue{}.AttributeTypes(ctx),
		},
		"version": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = ApRedundancyType{}

type ApRedundancyType struct {
	basetypes.ObjectType
}

func (t ApRedundancyType) Equal(o attr.Type) bool {
	other, ok := o.(ApRedundancyType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ApRedundancyType) String() string {
	return "ApRedundancyType"
}

func (t ApRedundancyType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	modulesAttribute, ok := attributes["modules"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`modules is missing from object`)

		return nil, diags
	}

	modulesVal, ok := modulesAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`modules expected to be basetypes.MapValue, was: %T`, modulesAttribute))
	}

	numApsAttribute, ok := attributes["num_aps"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`num_aps is missing from object`)

		return nil, diags
	}

	numApsVal, ok := numApsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`num_aps expected to be basetypes.Int64Value, was: %T`, numApsAttribute))
	}

	numApsWithSwitchRedundancyAttribute, ok := attributes["num_aps_with_switch_redundancy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`num_aps_with_switch_redundancy is missing from object`)

		return nil, diags
	}

	numApsWithSwitchRedundancyVal, ok := numApsWithSwitchRedundancyAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`num_aps_with_switch_redundancy expected to be basetypes.Int64Value, was: %T`, numApsWithSwitchRedundancyAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ApRedundancyValue{
		Modules:                    modulesVal,
		NumAps:                     numApsVal,
		NumApsWithSwitchRedundancy: numApsWithSwitchRedundancyVal,
		state:                      attr.ValueStateKnown,
	}, diags
}

func NewApRedundancyValueNull() ApRedundancyValue {
	return ApRedundancyValue{
		state: attr.ValueStateNull,
	}
}

func NewApRedundancyValueUnknown() ApRedundancyValue {
	return ApRedundancyValue{
		state: attr.ValueStateUnknown,
	}
}

func NewApRedundancyValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ApRedundancyValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ApRedundancyValue Attribute Value",
				"While creating a ApRedundancyValue value, a missing attribute value was detected. "+
					"A ApRedundancyValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ApRedundancyValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ApRedundancyValue Attribute Type",
				"While creating a ApRedundancyValue value, an invalid attribute value was detected. "+
					"A ApRedundancyValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ApRedundancyValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ApRedundancyValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ApRedundancyValue Attribute Value",
				"While creating a ApRedundancyValue value, an extra attribute value was detected. "+
					"A ApRedundancyValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ApRedundancyValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewApRedundancyValueUnknown(), diags
	}

	modulesAttribute, ok := attributes["modules"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`modules is missing from object`)

		return NewApRedundancyValueUnknown(), diags
	}

	modulesVal, ok := modulesAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`modules expected to be basetypes.MapValue, was: %T`, modulesAttribute))
	}

	numApsAttribute, ok := attributes["num_aps"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`num_aps is missing from object`)

		return NewApRedundancyValueUnknown(), diags
	}

	numApsVal, ok := numApsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`num_aps expected to be basetypes.Int64Value, was: %T`, numApsAttribute))
	}

	numApsWithSwitchRedundancyAttribute, ok := attributes["num_aps_with_switch_redundancy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`num_aps_with_switch_redundancy is missing from object`)

		return NewApRedundancyValueUnknown(), diags
	}

	numApsWithSwitchRedundancyVal, ok := numApsWithSwitchRedundancyAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`num_aps_with_switch_redundancy expected to be basetypes.Int64Value, was: %T`, numApsWithSwitchRedundancyAttribute))
	}

	if diags.HasError() {
		return NewApRedundancyValueUnknown(), diags
	}

	return ApRedundancyValue{
		Modules:                    modulesVal,
		NumAps:                     numApsVal,
		NumApsWithSwitchRedundancy: numApsWithSwitchRedundancyVal,
		state:                      attr.ValueStateKnown,
	}, diags
}

func NewApRedundancyValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ApRedundancyValue {
	object, diags := NewApRedundancyValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewApRedundancyValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ApRedundancyType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewApRedundancyValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewApRedundancyValueUnknown(), nil
	}

	if in.IsNull() {
		return NewApRedundancyValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewApRedundancyValueMust(ApRedundancyValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ApRedundancyType) ValueType(ctx context.Context) attr.Value {
	return ApRedundancyValue{}
}

var _ basetypes.ObjectValuable = ApRedundancyValue{}

type ApRedundancyValue struct {
	Modules                    basetypes.MapValue   `tfsdk:"modules"`
	NumAps                     basetypes.Int64Value `tfsdk:"num_aps"`
	NumApsWithSwitchRedundancy basetypes.Int64Value `tfsdk:"num_aps_with_switch_redundancy"`
	state                      attr.ValueState
}

func (v ApRedundancyValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["modules"] = basetypes.MapType{
		ElemType: ModulesValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["num_aps"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["num_aps_with_switch_redundancy"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Modules.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["modules"] = val

		val, err = v.NumAps.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["num_aps"] = val

		val, err = v.NumApsWithSwitchRedundancy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["num_aps_with_switch_redundancy"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ApRedundancyValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ApRedundancyValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ApRedundancyValue) String() string {
	return "ApRedundancyValue"
}

func (v ApRedundancyValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	modules := types.MapValueMust(
		ModulesType{
			basetypes.ObjectType{
				AttrTypes: ModulesValue{}.AttributeTypes(ctx),
			},
		},
		v.Modules.Elements(),
	)

	if v.Modules.IsNull() {
		modules = types.MapNull(
			ModulesType{
				basetypes.ObjectType{
					AttrTypes: ModulesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Modules.IsUnknown() {
		modules = types.MapUnknown(
			ModulesType{
				basetypes.ObjectType{
					AttrTypes: ModulesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"modules": basetypes.MapType{
			ElemType: ModulesValue{}.Type(ctx),
		},
		"num_aps":                        basetypes.Int64Type{},
		"num_aps_with_switch_redundancy": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"modules":                        modules,
			"num_aps":                        v.NumAps,
			"num_aps_with_switch_redundancy": v.NumApsWithSwitchRedundancy,
		})

	return objVal, diags
}

func (v ApRedundancyValue) Equal(o attr.Value) bool {
	other, ok := o.(ApRedundancyValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Modules.Equal(other.Modules) {
		return false
	}

	if !v.NumAps.Equal(other.NumAps) {
		return false
	}

	if !v.NumApsWithSwitchRedundancy.Equal(other.NumApsWithSwitchRedundancy) {
		return false
	}

	return true
}

func (v ApRedundancyValue) Type(ctx context.Context) attr.Type {
	return ApRedundancyType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ApRedundancyValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"modules": basetypes.MapType{
			ElemType: ModulesValue{}.Type(ctx),
		},
		"num_aps":                        basetypes.Int64Type{},
		"num_aps_with_switch_redundancy": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = ModulesType{}

type ModulesType struct {
	basetypes.ObjectType
}

func (t ModulesType) Equal(o attr.Type) bool {
	other, ok := o.(ModulesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ModulesType) String() string {
	return "ModulesType"
}

func (t ModulesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	numApsAttribute, ok := attributes["num_aps"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`num_aps is missing from object`)

		return nil, diags
	}

	numApsVal, ok := numApsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`num_aps expected to be basetypes.Int64Value, was: %T`, numApsAttribute))
	}

	numApsWithSwitchRedundancyAttribute, ok := attributes["num_aps_with_switch_redundancy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`num_aps_with_switch_redundancy is missing from object`)

		return nil, diags
	}

	numApsWithSwitchRedundancyVal, ok := numApsWithSwitchRedundancyAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`num_aps_with_switch_redundancy expected to be basetypes.Int64Value, was: %T`, numApsWithSwitchRedundancyAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ModulesValue{
		NumAps:                     numApsVal,
		NumApsWithSwitchRedundancy: numApsWithSwitchRedundancyVal,
		state:                      attr.ValueStateKnown,
	}, diags
}

func NewModulesValueNull() ModulesValue {
	return ModulesValue{
		state: attr.ValueStateNull,
	}
}

func NewModulesValueUnknown() ModulesValue {
	return ModulesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewModulesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ModulesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ModulesValue Attribute Value",
				"While creating a ModulesValue value, a missing attribute value was detected. "+
					"A ModulesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ModulesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ModulesValue Attribute Type",
				"While creating a ModulesValue value, an invalid attribute value was detected. "+
					"A ModulesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ModulesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ModulesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ModulesValue Attribute Value",
				"While creating a ModulesValue value, an extra attribute value was detected. "+
					"A ModulesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ModulesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewModulesValueUnknown(), diags
	}

	numApsAttribute, ok := attributes["num_aps"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`num_aps is missing from object`)

		return NewModulesValueUnknown(), diags
	}

	numApsVal, ok := numApsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`num_aps expected to be basetypes.Int64Value, was: %T`, numApsAttribute))
	}

	numApsWithSwitchRedundancyAttribute, ok := attributes["num_aps_with_switch_redundancy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`num_aps_with_switch_redundancy is missing from object`)

		return NewModulesValueUnknown(), diags
	}

	numApsWithSwitchRedundancyVal, ok := numApsWithSwitchRedundancyAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`num_aps_with_switch_redundancy expected to be basetypes.Int64Value, was: %T`, numApsWithSwitchRedundancyAttribute))
	}

	if diags.HasError() {
		return NewModulesValueUnknown(), diags
	}

	return ModulesValue{
		NumAps:                     numApsVal,
		NumApsWithSwitchRedundancy: numApsWithSwitchRedundancyVal,
		state:                      attr.ValueStateKnown,
	}, diags
}

func NewModulesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ModulesValue {
	object, diags := NewModulesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewModulesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ModulesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewModulesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewModulesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewModulesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewModulesValueMust(ModulesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ModulesType) ValueType(ctx context.Context) attr.Value {
	return ModulesValue{}
}

var _ basetypes.ObjectValuable = ModulesValue{}

type ModulesValue struct {
	NumAps                     basetypes.Int64Value `tfsdk:"num_aps"`
	NumApsWithSwitchRedundancy basetypes.Int64Value `tfsdk:"num_aps_with_switch_redundancy"`
	state                      attr.ValueState
}

func (v ModulesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["num_aps"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["num_aps_with_switch_redundancy"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.NumAps.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["num_aps"] = val

		val, err = v.NumApsWithSwitchRedundancy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["num_aps_with_switch_redundancy"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ModulesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ModulesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ModulesValue) String() string {
	return "ModulesValue"
}

func (v ModulesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"num_aps":                        basetypes.Int64Type{},
		"num_aps_with_switch_redundancy": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"num_aps":                        v.NumAps,
			"num_aps_with_switch_redundancy": v.NumApsWithSwitchRedundancy,
		})

	return objVal, diags
}

func (v ModulesValue) Equal(o attr.Value) bool {
	other, ok := o.(ModulesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.NumAps.Equal(other.NumAps) {
		return false
	}

	if !v.NumApsWithSwitchRedundancy.Equal(other.NumApsWithSwitchRedundancy) {
		return false
	}

	return true
}

func (v ModulesValue) Type(ctx context.Context) attr.Type {
	return ModulesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ModulesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"num_aps":                        basetypes.Int64Type{},
		"num_aps_with_switch_redundancy": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = ArpTableStatsType{}

type ArpTableStatsType struct {
	basetypes.ObjectType
}

func (t ArpTableStatsType) Equal(o attr.Type) bool {
	other, ok := o.(ArpTableStatsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ArpTableStatsType) String() string {
	return "ArpTableStatsType"
}

func (t ArpTableStatsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	arpTableCountAttribute, ok := attributes["arp_table_count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`arp_table_count is missing from object`)

		return nil, diags
	}

	arpTableCountVal, ok := arpTableCountAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`arp_table_count expected to be basetypes.Int64Value, was: %T`, arpTableCountAttribute))
	}

	maxEntriesSupportedAttribute, ok := attributes["max_entries_supported"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_entries_supported is missing from object`)

		return nil, diags
	}

	maxEntriesSupportedVal, ok := maxEntriesSupportedAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_entries_supported expected to be basetypes.Int64Value, was: %T`, maxEntriesSupportedAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ArpTableStatsValue{
		ArpTableCount:       arpTableCountVal,
		MaxEntriesSupported: maxEntriesSupportedVal,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewArpTableStatsValueNull() ArpTableStatsValue {
	return ArpTableStatsValue{
		state: attr.ValueStateNull,
	}
}

func NewArpTableStatsValueUnknown() ArpTableStatsValue {
	return ArpTableStatsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewArpTableStatsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ArpTableStatsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ArpTableStatsValue Attribute Value",
				"While creating a ArpTableStatsValue value, a missing attribute value was detected. "+
					"A ArpTableStatsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ArpTableStatsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ArpTableStatsValue Attribute Type",
				"While creating a ArpTableStatsValue value, an invalid attribute value was detected. "+
					"A ArpTableStatsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ArpTableStatsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ArpTableStatsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ArpTableStatsValue Attribute Value",
				"While creating a ArpTableStatsValue value, an extra attribute value was detected. "+
					"A ArpTableStatsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ArpTableStatsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewArpTableStatsValueUnknown(), diags
	}

	arpTableCountAttribute, ok := attributes["arp_table_count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`arp_table_count is missing from object`)

		return NewArpTableStatsValueUnknown(), diags
	}

	arpTableCountVal, ok := arpTableCountAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`arp_table_count expected to be basetypes.Int64Value, was: %T`, arpTableCountAttribute))
	}

	maxEntriesSupportedAttribute, ok := attributes["max_entries_supported"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_entries_supported is missing from object`)

		return NewArpTableStatsValueUnknown(), diags
	}

	maxEntriesSupportedVal, ok := maxEntriesSupportedAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_entries_supported expected to be basetypes.Int64Value, was: %T`, maxEntriesSupportedAttribute))
	}

	if diags.HasError() {
		return NewArpTableStatsValueUnknown(), diags
	}

	return ArpTableStatsValue{
		ArpTableCount:       arpTableCountVal,
		MaxEntriesSupported: maxEntriesSupportedVal,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewArpTableStatsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ArpTableStatsValue {
	object, diags := NewArpTableStatsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewArpTableStatsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ArpTableStatsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewArpTableStatsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewArpTableStatsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewArpTableStatsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewArpTableStatsValueMust(ArpTableStatsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ArpTableStatsType) ValueType(ctx context.Context) attr.Value {
	return ArpTableStatsValue{}
}

var _ basetypes.ObjectValuable = ArpTableStatsValue{}

type ArpTableStatsValue struct {
	ArpTableCount       basetypes.Int64Value `tfsdk:"arp_table_count"`
	MaxEntriesSupported basetypes.Int64Value `tfsdk:"max_entries_supported"`
	state               attr.ValueState
}

func (v ArpTableStatsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["arp_table_count"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["max_entries_supported"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.ArpTableCount.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["arp_table_count"] = val

		val, err = v.MaxEntriesSupported.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_entries_supported"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ArpTableStatsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ArpTableStatsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ArpTableStatsValue) String() string {
	return "ArpTableStatsValue"
}

func (v ArpTableStatsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"arp_table_count":       basetypes.Int64Type{},
		"max_entries_supported": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"arp_table_count":       v.ArpTableCount,
			"max_entries_supported": v.MaxEntriesSupported,
		})

	return objVal, diags
}

func (v ArpTableStatsValue) Equal(o attr.Value) bool {
	other, ok := o.(ArpTableStatsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.ArpTableCount.Equal(other.ArpTableCount) {
		return false
	}

	if !v.MaxEntriesSupported.Equal(other.MaxEntriesSupported) {
		return false
	}

	return true
}

func (v ArpTableStatsValue) Type(ctx context.Context) attr.Type {
	return ArpTableStatsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ArpTableStatsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"arp_table_count":       basetypes.Int64Type{},
		"max_entries_supported": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = ClientsType{}

type ClientsType struct {
	basetypes.ObjectType
}

func (t ClientsType) Equal(o attr.Type) bool {
	other, ok := o.(ClientsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ClientsType) String() string {
	return "ClientsType"
}

func (t ClientsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	deviceMacAttribute, ok := attributes["device_mac"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`device_mac is missing from object`)

		return nil, diags
	}

	deviceMacVal, ok := deviceMacAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`device_mac expected to be basetypes.StringValue, was: %T`, deviceMacAttribute))
	}

	hostnameAttribute, ok := attributes["hostname"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`hostname is missing from object`)

		return nil, diags
	}

	hostnameVal, ok := hostnameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`hostname expected to be basetypes.StringValue, was: %T`, hostnameAttribute))
	}

	macAttribute, ok := attributes["mac"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mac is missing from object`)

		return nil, diags
	}

	macVal, ok := macAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mac expected to be basetypes.StringValue, was: %T`, macAttribute))
	}

	portIdAttribute, ok := attributes["port_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_id is missing from object`)

		return nil, diags
	}

	portIdVal, ok := portIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_id expected to be basetypes.StringValue, was: %T`, portIdAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ClientsValue{
		DeviceMac: deviceMacVal,
		Hostname:  hostnameVal,
		Mac:       macVal,
		PortId:    portIdVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewClientsValueNull() ClientsValue {
	return ClientsValue{
		state: attr.ValueStateNull,
	}
}

func NewClientsValueUnknown() ClientsValue {
	return ClientsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewClientsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ClientsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ClientsValue Attribute Value",
				"While creating a ClientsValue value, a missing attribute value was detected. "+
					"A ClientsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ClientsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ClientsValue Attribute Type",
				"While creating a ClientsValue value, an invalid attribute value was detected. "+
					"A ClientsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ClientsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ClientsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ClientsValue Attribute Value",
				"While creating a ClientsValue value, an extra attribute value was detected. "+
					"A ClientsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ClientsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewClientsValueUnknown(), diags
	}

	deviceMacAttribute, ok := attributes["device_mac"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`device_mac is missing from object`)

		return NewClientsValueUnknown(), diags
	}

	deviceMacVal, ok := deviceMacAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`device_mac expected to be basetypes.StringValue, was: %T`, deviceMacAttribute))
	}

	hostnameAttribute, ok := attributes["hostname"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`hostname is missing from object`)

		return NewClientsValueUnknown(), diags
	}

	hostnameVal, ok := hostnameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`hostname expected to be basetypes.StringValue, was: %T`, hostnameAttribute))
	}

	macAttribute, ok := attributes["mac"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mac is missing from object`)

		return NewClientsValueUnknown(), diags
	}

	macVal, ok := macAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mac expected to be basetypes.StringValue, was: %T`, macAttribute))
	}

	portIdAttribute, ok := attributes["port_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_id is missing from object`)

		return NewClientsValueUnknown(), diags
	}

	portIdVal, ok := portIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_id expected to be basetypes.StringValue, was: %T`, portIdAttribute))
	}

	if diags.HasError() {
		return NewClientsValueUnknown(), diags
	}

	return ClientsValue{
		DeviceMac: deviceMacVal,
		Hostname:  hostnameVal,
		Mac:       macVal,
		PortId:    portIdVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewClientsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ClientsValue {
	object, diags := NewClientsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewClientsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ClientsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewClientsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewClientsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewClientsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewClientsValueMust(ClientsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ClientsType) ValueType(ctx context.Context) attr.Value {
	return ClientsValue{}
}

var _ basetypes.ObjectValuable = ClientsValue{}

type ClientsValue struct {
	DeviceMac basetypes.StringValue `tfsdk:"device_mac"`
	Hostname  basetypes.StringValue `tfsdk:"hostname"`
	Mac       basetypes.StringValue `tfsdk:"mac"`
	PortId    basetypes.StringValue `tfsdk:"port_id"`
	state     attr.ValueState
}

func (v ClientsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["device_mac"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["hostname"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["mac"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["port_id"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.DeviceMac.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["device_mac"] = val

		val, err = v.Hostname.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["hostname"] = val

		val, err = v.Mac.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mac"] = val

		val, err = v.PortId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port_id"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ClientsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ClientsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ClientsValue) String() string {
	return "ClientsValue"
}

func (v ClientsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"device_mac": basetypes.StringType{},
		"hostname":   basetypes.StringType{},
		"mac":        basetypes.StringType{},
		"port_id":    basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"device_mac": v.DeviceMac,
			"hostname":   v.Hostname,
			"mac":        v.Mac,
			"port_id":    v.PortId,
		})

	return objVal, diags
}

func (v ClientsValue) Equal(o attr.Value) bool {
	other, ok := o.(ClientsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.DeviceMac.Equal(other.DeviceMac) {
		return false
	}

	if !v.Hostname.Equal(other.Hostname) {
		return false
	}

	if !v.Mac.Equal(other.Mac) {
		return false
	}

	if !v.PortId.Equal(other.PortId) {
		return false
	}

	return true
}

func (v ClientsValue) Type(ctx context.Context) attr.Type {
	return ClientsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ClientsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"device_mac": basetypes.StringType{},
		"hostname":   basetypes.StringType{},
		"mac":        basetypes.StringType{},
		"port_id":    basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = ClientsStatsType{}

type ClientsStatsType struct {
	basetypes.ObjectType
}

func (t ClientsStatsType) Equal(o attr.Type) bool {
	other, ok := o.(ClientsStatsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ClientsStatsType) String() string {
	return "ClientsStatsType"
}

func (t ClientsStatsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	totalAttribute, ok := attributes["total"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`total is missing from object`)

		return nil, diags
	}

	totalVal, ok := totalAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`total expected to be basetypes.ObjectValue, was: %T`, totalAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ClientsStatsValue{
		Total: totalVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewClientsStatsValueNull() ClientsStatsValue {
	return ClientsStatsValue{
		state: attr.ValueStateNull,
	}
}

func NewClientsStatsValueUnknown() ClientsStatsValue {
	return ClientsStatsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewClientsStatsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ClientsStatsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ClientsStatsValue Attribute Value",
				"While creating a ClientsStatsValue value, a missing attribute value was detected. "+
					"A ClientsStatsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ClientsStatsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ClientsStatsValue Attribute Type",
				"While creating a ClientsStatsValue value, an invalid attribute value was detected. "+
					"A ClientsStatsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ClientsStatsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ClientsStatsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ClientsStatsValue Attribute Value",
				"While creating a ClientsStatsValue value, an extra attribute value was detected. "+
					"A ClientsStatsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ClientsStatsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewClientsStatsValueUnknown(), diags
	}

	totalAttribute, ok := attributes["total"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`total is missing from object`)

		return NewClientsStatsValueUnknown(), diags
	}

	totalVal, ok := totalAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`total expected to be basetypes.ObjectValue, was: %T`, totalAttribute))
	}

	if diags.HasError() {
		return NewClientsStatsValueUnknown(), diags
	}

	return ClientsStatsValue{
		Total: totalVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewClientsStatsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ClientsStatsValue {
	object, diags := NewClientsStatsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewClientsStatsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ClientsStatsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewClientsStatsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewClientsStatsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewClientsStatsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewClientsStatsValueMust(ClientsStatsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ClientsStatsType) ValueType(ctx context.Context) attr.Value {
	return ClientsStatsValue{}
}

var _ basetypes.ObjectValuable = ClientsStatsValue{}

type ClientsStatsValue struct {
	Total basetypes.ObjectValue `tfsdk:"total"`
	state attr.ValueState
}

func (v ClientsStatsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["total"] = basetypes.ObjectType{
		AttrTypes: TotalValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Total.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["total"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ClientsStatsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ClientsStatsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ClientsStatsValue) String() string {
	return "ClientsStatsValue"
}

func (v ClientsStatsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var total basetypes.ObjectValue

	if v.Total.IsNull() {
		total = types.ObjectNull(
			TotalValue{}.AttributeTypes(ctx),
		)
	}

	if v.Total.IsUnknown() {
		total = types.ObjectUnknown(
			TotalValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Total.IsNull() && !v.Total.IsUnknown() {
		total = types.ObjectValueMust(
			TotalValue{}.AttributeTypes(ctx),
			v.Total.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"total": basetypes.ObjectType{
			AttrTypes: TotalValue{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"total": total,
		})

	return objVal, diags
}

func (v ClientsStatsValue) Equal(o attr.Value) bool {
	other, ok := o.(ClientsStatsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Total.Equal(other.Total) {
		return false
	}

	return true
}

func (v ClientsStatsValue) Type(ctx context.Context) attr.Type {
	return ClientsStatsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ClientsStatsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"total": basetypes.ObjectType{
			AttrTypes: TotalValue{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = TotalType{}

type TotalType struct {
	basetypes.ObjectType
}

func (t TotalType) Equal(o attr.Type) bool {
	other, ok := o.(TotalType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t TotalType) String() string {
	return "TotalType"
}

func (t TotalType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	numApsAttribute, ok := attributes["num_aps"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`num_aps is missing from object`)

		return nil, diags
	}

	numApsVal, ok := numApsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`num_aps expected to be basetypes.ListValue, was: %T`, numApsAttribute))
	}

	numWiredClientsAttribute, ok := attributes["num_wired_clients"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`num_wired_clients is missing from object`)

		return nil, diags
	}

	numWiredClientsVal, ok := numWiredClientsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`num_wired_clients expected to be basetypes.Int64Value, was: %T`, numWiredClientsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return TotalValue{
		NumAps:          numApsVal,
		NumWiredClients: numWiredClientsVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewTotalValueNull() TotalValue {
	return TotalValue{
		state: attr.ValueStateNull,
	}
}

func NewTotalValueUnknown() TotalValue {
	return TotalValue{
		state: attr.ValueStateUnknown,
	}
}

func NewTotalValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (TotalValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing TotalValue Attribute Value",
				"While creating a TotalValue value, a missing attribute value was detected. "+
					"A TotalValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TotalValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid TotalValue Attribute Type",
				"While creating a TotalValue value, an invalid attribute value was detected. "+
					"A TotalValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TotalValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("TotalValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra TotalValue Attribute Value",
				"While creating a TotalValue value, an extra attribute value was detected. "+
					"A TotalValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra TotalValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewTotalValueUnknown(), diags
	}

	numApsAttribute, ok := attributes["num_aps"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`num_aps is missing from object`)

		return NewTotalValueUnknown(), diags
	}

	numApsVal, ok := numApsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`num_aps expected to be basetypes.ListValue, was: %T`, numApsAttribute))
	}

	numWiredClientsAttribute, ok := attributes["num_wired_clients"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`num_wired_clients is missing from object`)

		return NewTotalValueUnknown(), diags
	}

	numWiredClientsVal, ok := numWiredClientsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`num_wired_clients expected to be basetypes.Int64Value, was: %T`, numWiredClientsAttribute))
	}

	if diags.HasError() {
		return NewTotalValueUnknown(), diags
	}

	return TotalValue{
		NumAps:          numApsVal,
		NumWiredClients: numWiredClientsVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewTotalValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) TotalValue {
	object, diags := NewTotalValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewTotalValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t TotalType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewTotalValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewTotalValueUnknown(), nil
	}

	if in.IsNull() {
		return NewTotalValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewTotalValueMust(TotalValue{}.AttributeTypes(ctx), attributes), nil
}

func (t TotalType) ValueType(ctx context.Context) attr.Value {
	return TotalValue{}
}

var _ basetypes.ObjectValuable = TotalValue{}

type TotalValue struct {
	NumAps          basetypes.ListValue  `tfsdk:"num_aps"`
	NumWiredClients basetypes.Int64Value `tfsdk:"num_wired_clients"`
	state           attr.ValueState
}

func (v TotalValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["num_aps"] = basetypes.ListType{
		ElemType: types.Int64Type,
	}.TerraformType(ctx)
	attrTypes["num_wired_clients"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.NumAps.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["num_aps"] = val

		val, err = v.NumWiredClients.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["num_wired_clients"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v TotalValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v TotalValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v TotalValue) String() string {
	return "TotalValue"
}

func (v TotalValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	numApsVal, d := types.ListValue(types.Int64Type, v.NumAps.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"num_aps": basetypes.ListType{
				ElemType: types.Int64Type,
			},
			"num_wired_clients": basetypes.Int64Type{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"num_aps": basetypes.ListType{
			ElemType: types.Int64Type,
		},
		"num_wired_clients": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"num_aps":           numApsVal,
			"num_wired_clients": v.NumWiredClients,
		})

	return objVal, diags
}

func (v TotalValue) Equal(o attr.Value) bool {
	other, ok := o.(TotalValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.NumAps.Equal(other.NumAps) {
		return false
	}

	if !v.NumWiredClients.Equal(other.NumWiredClients) {
		return false
	}

	return true
}

func (v TotalValue) Type(ctx context.Context) attr.Type {
	return TotalType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v TotalValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"num_aps": basetypes.ListType{
			ElemType: types.Int64Type,
		},
		"num_wired_clients": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = CpuStatType{}

type CpuStatType struct {
	basetypes.ObjectType
}

func (t CpuStatType) Equal(o attr.Type) bool {
	other, ok := o.(CpuStatType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t CpuStatType) String() string {
	return "CpuStatType"
}

func (t CpuStatType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	idleAttribute, ok := attributes["idle"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`idle is missing from object`)

		return nil, diags
	}

	idleVal, ok := idleAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`idle expected to be basetypes.NumberValue, was: %T`, idleAttribute))
	}

	interruptAttribute, ok := attributes["interrupt"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interrupt is missing from object`)

		return nil, diags
	}

	interruptVal, ok := interruptAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interrupt expected to be basetypes.NumberValue, was: %T`, interruptAttribute))
	}

	loadAvgAttribute, ok := attributes["load_avg"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`load_avg is missing from object`)

		return nil, diags
	}

	loadAvgVal, ok := loadAvgAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`load_avg expected to be basetypes.ListValue, was: %T`, loadAvgAttribute))
	}

	systemAttribute, ok := attributes["system"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`system is missing from object`)

		return nil, diags
	}

	systemVal, ok := systemAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`system expected to be basetypes.NumberValue, was: %T`, systemAttribute))
	}

	userAttribute, ok := attributes["user"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`user is missing from object`)

		return nil, diags
	}

	userVal, ok := userAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`user expected to be basetypes.NumberValue, was: %T`, userAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return CpuStatValue{
		Idle:      idleVal,
		Interrupt: interruptVal,
		LoadAvg:   loadAvgVal,
		System:    systemVal,
		User:      userVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewCpuStatValueNull() CpuStatValue {
	return CpuStatValue{
		state: attr.ValueStateNull,
	}
}

func NewCpuStatValueUnknown() CpuStatValue {
	return CpuStatValue{
		state: attr.ValueStateUnknown,
	}
}

func NewCpuStatValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (CpuStatValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing CpuStatValue Attribute Value",
				"While creating a CpuStatValue value, a missing attribute value was detected. "+
					"A CpuStatValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CpuStatValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid CpuStatValue Attribute Type",
				"While creating a CpuStatValue value, an invalid attribute value was detected. "+
					"A CpuStatValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CpuStatValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("CpuStatValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra CpuStatValue Attribute Value",
				"While creating a CpuStatValue value, an extra attribute value was detected. "+
					"A CpuStatValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra CpuStatValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewCpuStatValueUnknown(), diags
	}

	idleAttribute, ok := attributes["idle"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`idle is missing from object`)

		return NewCpuStatValueUnknown(), diags
	}

	idleVal, ok := idleAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`idle expected to be basetypes.NumberValue, was: %T`, idleAttribute))
	}

	interruptAttribute, ok := attributes["interrupt"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interrupt is missing from object`)

		return NewCpuStatValueUnknown(), diags
	}

	interruptVal, ok := interruptAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interrupt expected to be basetypes.NumberValue, was: %T`, interruptAttribute))
	}

	loadAvgAttribute, ok := attributes["load_avg"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`load_avg is missing from object`)

		return NewCpuStatValueUnknown(), diags
	}

	loadAvgVal, ok := loadAvgAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`load_avg expected to be basetypes.ListValue, was: %T`, loadAvgAttribute))
	}

	systemAttribute, ok := attributes["system"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`system is missing from object`)

		return NewCpuStatValueUnknown(), diags
	}

	systemVal, ok := systemAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`system expected to be basetypes.NumberValue, was: %T`, systemAttribute))
	}

	userAttribute, ok := attributes["user"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`user is missing from object`)

		return NewCpuStatValueUnknown(), diags
	}

	userVal, ok := userAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`user expected to be basetypes.NumberValue, was: %T`, userAttribute))
	}

	if diags.HasError() {
		return NewCpuStatValueUnknown(), diags
	}

	return CpuStatValue{
		Idle:      idleVal,
		Interrupt: interruptVal,
		LoadAvg:   loadAvgVal,
		System:    systemVal,
		User:      userVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewCpuStatValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) CpuStatValue {
	object, diags := NewCpuStatValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewCpuStatValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t CpuStatType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewCpuStatValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewCpuStatValueUnknown(), nil
	}

	if in.IsNull() {
		return NewCpuStatValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewCpuStatValueMust(CpuStatValue{}.AttributeTypes(ctx), attributes), nil
}

func (t CpuStatType) ValueType(ctx context.Context) attr.Value {
	return CpuStatValue{}
}

var _ basetypes.ObjectValuable = CpuStatValue{}

type CpuStatValue struct {
	Idle      basetypes.NumberValue `tfsdk:"idle"`
	Interrupt basetypes.NumberValue `tfsdk:"interrupt"`
	LoadAvg   basetypes.ListValue   `tfsdk:"load_avg"`
	System    basetypes.NumberValue `tfsdk:"system"`
	User      basetypes.NumberValue `tfsdk:"user"`
	state     attr.ValueState
}

func (v CpuStatValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["idle"] = basetypes.NumberType{}.TerraformType(ctx)
	attrTypes["interrupt"] = basetypes.NumberType{}.TerraformType(ctx)
	attrTypes["load_avg"] = basetypes.ListType{
		ElemType: types.NumberType,
	}.TerraformType(ctx)
	attrTypes["system"] = basetypes.NumberType{}.TerraformType(ctx)
	attrTypes["user"] = basetypes.NumberType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.Idle.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["idle"] = val

		val, err = v.Interrupt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["interrupt"] = val

		val, err = v.LoadAvg.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["load_avg"] = val

		val, err = v.System.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["system"] = val

		val, err = v.User.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["user"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v CpuStatValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v CpuStatValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v CpuStatValue) String() string {
	return "CpuStatValue"
}

func (v CpuStatValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	loadAvgVal, d := types.ListValue(types.NumberType, v.LoadAvg.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"idle":      basetypes.NumberType{},
			"interrupt": basetypes.NumberType{},
			"load_avg": basetypes.ListType{
				ElemType: types.NumberType,
			},
			"system": basetypes.NumberType{},
			"user":   basetypes.NumberType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"idle":      basetypes.NumberType{},
		"interrupt": basetypes.NumberType{},
		"load_avg": basetypes.ListType{
			ElemType: types.NumberType,
		},
		"system": basetypes.NumberType{},
		"user":   basetypes.NumberType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"idle":      v.Idle,
			"interrupt": v.Interrupt,
			"load_avg":  loadAvgVal,
			"system":    v.System,
			"user":      v.User,
		})

	return objVal, diags
}

func (v CpuStatValue) Equal(o attr.Value) bool {
	other, ok := o.(CpuStatValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Idle.Equal(other.Idle) {
		return false
	}

	if !v.Interrupt.Equal(other.Interrupt) {
		return false
	}

	if !v.LoadAvg.Equal(other.LoadAvg) {
		return false
	}

	if !v.System.Equal(other.System) {
		return false
	}

	if !v.User.Equal(other.User) {
		return false
	}

	return true
}

func (v CpuStatValue) Type(ctx context.Context) attr.Type {
	return CpuStatType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v CpuStatValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"idle":      basetypes.NumberType{},
		"interrupt": basetypes.NumberType{},
		"load_avg": basetypes.ListType{
			ElemType: types.NumberType,
		},
		"system": basetypes.NumberType{},
		"user":   basetypes.NumberType{},
	}
}

var _ basetypes.ObjectTypable = DhcpdStatType{}

type DhcpdStatType struct {
	basetypes.ObjectType
}

func (t DhcpdStatType) Equal(o attr.Type) bool {
	other, ok := o.(DhcpdStatType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t DhcpdStatType) String() string {
	return "DhcpdStatType"
}

func (t DhcpdStatType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	numIpsAttribute, ok := attributes["num_ips"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`num_ips is missing from object`)

		return nil, diags
	}

	numIpsVal, ok := numIpsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`num_ips expected to be basetypes.Int64Value, was: %T`, numIpsAttribute))
	}

	numLeasedAttribute, ok := attributes["num_leased"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`num_leased is missing from object`)

		return nil, diags
	}

	numLeasedVal, ok := numLeasedAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`num_leased expected to be basetypes.Int64Value, was: %T`, numLeasedAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return DhcpdStatValue{
		NumIps:    numIpsVal,
		NumLeased: numLeasedVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewDhcpdStatValueNull() DhcpdStatValue {
	return DhcpdStatValue{
		state: attr.ValueStateNull,
	}
}

func NewDhcpdStatValueUnknown() DhcpdStatValue {
	return DhcpdStatValue{
		state: attr.ValueStateUnknown,
	}
}

func NewDhcpdStatValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (DhcpdStatValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing DhcpdStatValue Attribute Value",
				"While creating a DhcpdStatValue value, a missing attribute value was detected. "+
					"A DhcpdStatValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DhcpdStatValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid DhcpdStatValue Attribute Type",
				"While creating a DhcpdStatValue value, an invalid attribute value was detected. "+
					"A DhcpdStatValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DhcpdStatValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("DhcpdStatValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra DhcpdStatValue Attribute Value",
				"While creating a DhcpdStatValue value, an extra attribute value was detected. "+
					"A DhcpdStatValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra DhcpdStatValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewDhcpdStatValueUnknown(), diags
	}

	numIpsAttribute, ok := attributes["num_ips"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`num_ips is missing from object`)

		return NewDhcpdStatValueUnknown(), diags
	}

	numIpsVal, ok := numIpsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`num_ips expected to be basetypes.Int64Value, was: %T`, numIpsAttribute))
	}

	numLeasedAttribute, ok := attributes["num_leased"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`num_leased is missing from object`)

		return NewDhcpdStatValueUnknown(), diags
	}

	numLeasedVal, ok := numLeasedAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`num_leased expected to be basetypes.Int64Value, was: %T`, numLeasedAttribute))
	}

	if diags.HasError() {
		return NewDhcpdStatValueUnknown(), diags
	}

	return DhcpdStatValue{
		NumIps:    numIpsVal,
		NumLeased: numLeasedVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewDhcpdStatValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) DhcpdStatValue {
	object, diags := NewDhcpdStatValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewDhcpdStatValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t DhcpdStatType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewDhcpdStatValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewDhcpdStatValueUnknown(), nil
	}

	if in.IsNull() {
		return NewDhcpdStatValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewDhcpdStatValueMust(DhcpdStatValue{}.AttributeTypes(ctx), attributes), nil
}

func (t DhcpdStatType) ValueType(ctx context.Context) attr.Value {
	return DhcpdStatValue{}
}

var _ basetypes.ObjectValuable = DhcpdStatValue{}

type DhcpdStatValue struct {
	NumIps    basetypes.Int64Value `tfsdk:"num_ips"`
	NumLeased basetypes.Int64Value `tfsdk:"num_leased"`
	state     attr.ValueState
}

func (v DhcpdStatValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["num_ips"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["num_leased"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.NumIps.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["num_ips"] = val

		val, err = v.NumLeased.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["num_leased"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v DhcpdStatValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v DhcpdStatValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v DhcpdStatValue) String() string {
	return "DhcpdStatValue"
}

func (v DhcpdStatValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"num_ips":    basetypes.Int64Type{},
		"num_leased": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"num_ips":    v.NumIps,
			"num_leased": v.NumLeased,
		})

	return objVal, diags
}

func (v DhcpdStatValue) Equal(o attr.Value) bool {
	other, ok := o.(DhcpdStatValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.NumIps.Equal(other.NumIps) {
		return false
	}

	if !v.NumLeased.Equal(other.NumLeased) {
		return false
	}

	return true
}

func (v DhcpdStatValue) Type(ctx context.Context) attr.Type {
	return DhcpdStatType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v DhcpdStatValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"num_ips":    basetypes.Int64Type{},
		"num_leased": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = FwupdateType{}

type FwupdateType struct {
	basetypes.ObjectType
}

func (t FwupdateType) Equal(o attr.Type) bool {
	other, ok := o.(FwupdateType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t FwupdateType) String() string {
	return "FwupdateType"
}

func (t FwupdateType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	progressAttribute, ok := attributes["progress"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`progress is missing from object`)

		return nil, diags
	}

	progressVal, ok := progressAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`progress expected to be basetypes.Int64Value, was: %T`, progressAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return nil, diags
	}

	statusVal, ok := statusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be basetypes.StringValue, was: %T`, statusAttribute))
	}

	statusIdAttribute, ok := attributes["status_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status_id is missing from object`)

		return nil, diags
	}

	statusIdVal, ok := statusIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status_id expected to be basetypes.Int64Value, was: %T`, statusIdAttribute))
	}

	timestampAttribute, ok := attributes["timestamp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`timestamp is missing from object`)

		return nil, diags
	}

	timestampVal, ok := timestampAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`timestamp expected to be basetypes.Float64Value, was: %T`, timestampAttribute))
	}

	willRetryAttribute, ok := attributes["will_retry"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`will_retry is missing from object`)

		return nil, diags
	}

	willRetryVal, ok := willRetryAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`will_retry expected to be basetypes.BoolValue, was: %T`, willRetryAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return FwupdateValue{
		Progress:  progressVal,
		Status:    statusVal,
		StatusId:  statusIdVal,
		Timestamp: timestampVal,
		WillRetry: willRetryVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewFwupdateValueNull() FwupdateValue {
	return FwupdateValue{
		state: attr.ValueStateNull,
	}
}

func NewFwupdateValueUnknown() FwupdateValue {
	return FwupdateValue{
		state: attr.ValueStateUnknown,
	}
}

func NewFwupdateValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (FwupdateValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing FwupdateValue Attribute Value",
				"While creating a FwupdateValue value, a missing attribute value was detected. "+
					"A FwupdateValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("FwupdateValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid FwupdateValue Attribute Type",
				"While creating a FwupdateValue value, an invalid attribute value was detected. "+
					"A FwupdateValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("FwupdateValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("FwupdateValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra FwupdateValue Attribute Value",
				"While creating a FwupdateValue value, an extra attribute value was detected. "+
					"A FwupdateValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra FwupdateValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewFwupdateValueUnknown(), diags
	}

	progressAttribute, ok := attributes["progress"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`progress is missing from object`)

		return NewFwupdateValueUnknown(), diags
	}

	progressVal, ok := progressAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`progress expected to be basetypes.Int64Value, was: %T`, progressAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return NewFwupdateValueUnknown(), diags
	}

	statusVal, ok := statusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be basetypes.StringValue, was: %T`, statusAttribute))
	}

	statusIdAttribute, ok := attributes["status_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status_id is missing from object`)

		return NewFwupdateValueUnknown(), diags
	}

	statusIdVal, ok := statusIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status_id expected to be basetypes.Int64Value, was: %T`, statusIdAttribute))
	}

	timestampAttribute, ok := attributes["timestamp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`timestamp is missing from object`)

		return NewFwupdateValueUnknown(), diags
	}

	timestampVal, ok := timestampAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`timestamp expected to be basetypes.Float64Value, was: %T`, timestampAttribute))
	}

	willRetryAttribute, ok := attributes["will_retry"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`will_retry is missing from object`)

		return NewFwupdateValueUnknown(), diags
	}

	willRetryVal, ok := willRetryAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`will_retry expected to be basetypes.BoolValue, was: %T`, willRetryAttribute))
	}

	if diags.HasError() {
		return NewFwupdateValueUnknown(), diags
	}

	return FwupdateValue{
		Progress:  progressVal,
		Status:    statusVal,
		StatusId:  statusIdVal,
		Timestamp: timestampVal,
		WillRetry: willRetryVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewFwupdateValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) FwupdateValue {
	object, diags := NewFwupdateValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewFwupdateValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t FwupdateType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewFwupdateValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewFwupdateValueUnknown(), nil
	}

	if in.IsNull() {
		return NewFwupdateValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewFwupdateValueMust(FwupdateValue{}.AttributeTypes(ctx), attributes), nil
}

func (t FwupdateType) ValueType(ctx context.Context) attr.Value {
	return FwupdateValue{}
}

var _ basetypes.ObjectValuable = FwupdateValue{}

type FwupdateValue struct {
	Progress  basetypes.Int64Value   `tfsdk:"progress"`
	Status    basetypes.StringValue  `tfsdk:"status"`
	StatusId  basetypes.Int64Value   `tfsdk:"status_id"`
	Timestamp basetypes.Float64Value `tfsdk:"timestamp"`
	WillRetry basetypes.BoolValue    `tfsdk:"will_retry"`
	state     attr.ValueState
}

func (v FwupdateValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["progress"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["status"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["status_id"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["timestamp"] = basetypes.Float64Type{}.TerraformType(ctx)
	attrTypes["will_retry"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.Progress.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["progress"] = val

		val, err = v.Status.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["status"] = val

		val, err = v.StatusId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["status_id"] = val

		val, err = v.Timestamp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["timestamp"] = val

		val, err = v.WillRetry.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["will_retry"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v FwupdateValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v FwupdateValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v FwupdateValue) String() string {
	return "FwupdateValue"
}

func (v FwupdateValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"progress":   basetypes.Int64Type{},
		"status":     basetypes.StringType{},
		"status_id":  basetypes.Int64Type{},
		"timestamp":  basetypes.Float64Type{},
		"will_retry": basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"progress":   v.Progress,
			"status":     v.Status,
			"status_id":  v.StatusId,
			"timestamp":  v.Timestamp,
			"will_retry": v.WillRetry,
		})

	return objVal, diags
}

func (v FwupdateValue) Equal(o attr.Value) bool {
	other, ok := o.(FwupdateValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Progress.Equal(other.Progress) {
		return false
	}

	if !v.Status.Equal(other.Status) {
		return false
	}

	if !v.StatusId.Equal(other.StatusId) {
		return false
	}

	if !v.Timestamp.Equal(other.Timestamp) {
		return false
	}

	if !v.WillRetry.Equal(other.WillRetry) {
		return false
	}

	return true
}

func (v FwupdateValue) Type(ctx context.Context) attr.Type {
	return FwupdateType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v FwupdateValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"progress":   basetypes.Int64Type{},
		"status":     basetypes.StringType{},
		"status_id":  basetypes.Int64Type{},
		"timestamp":  basetypes.Float64Type{},
		"will_retry": basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = IfStatType{}

type IfStatType struct {
	basetypes.ObjectType
}

func (t IfStatType) Equal(o attr.Type) bool {
	other, ok := o.(IfStatType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t IfStatType) String() string {
	return "IfStatType"
}

func (t IfStatType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	addressModeAttribute, ok := attributes["address_mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`address_mode is missing from object`)

		return nil, diags
	}

	addressModeVal, ok := addressModeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`address_mode expected to be basetypes.StringValue, was: %T`, addressModeAttribute))
	}

	ipsAttribute, ok := attributes["ips"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ips is missing from object`)

		return nil, diags
	}

	ipsVal, ok := ipsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ips expected to be basetypes.ListValue, was: %T`, ipsAttribute))
	}

	natAddressesAttribute, ok := attributes["nat_addresses"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`nat_addresses is missing from object`)

		return nil, diags
	}

	natAddressesVal, ok := natAddressesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`nat_addresses expected to be basetypes.ListValue, was: %T`, natAddressesAttribute))
	}

	networkNameAttribute, ok := attributes["network_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`network_name is missing from object`)

		return nil, diags
	}

	networkNameVal, ok := networkNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`network_name expected to be basetypes.StringValue, was: %T`, networkNameAttribute))
	}

	portIdAttribute, ok := attributes["port_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_id is missing from object`)

		return nil, diags
	}

	portIdVal, ok := portIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_id expected to be basetypes.StringValue, was: %T`, portIdAttribute))
	}

	portUsageAttribute, ok := attributes["port_usage"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_usage is missing from object`)

		return nil, diags
	}

	portUsageVal, ok := portUsageAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_usage expected to be basetypes.StringValue, was: %T`, portUsageAttribute))
	}

	redundancyStateAttribute, ok := attributes["redundancy_state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`redundancy_state is missing from object`)

		return nil, diags
	}

	redundancyStateVal, ok := redundancyStateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`redundancy_state expected to be basetypes.StringValue, was: %T`, redundancyStateAttribute))
	}

	rxBytesAttribute, ok := attributes["rx_bytes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rx_bytes is missing from object`)

		return nil, diags
	}

	rxBytesVal, ok := rxBytesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rx_bytes expected to be basetypes.Int64Value, was: %T`, rxBytesAttribute))
	}

	rxPktsAttribute, ok := attributes["rx_pkts"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rx_pkts is missing from object`)

		return nil, diags
	}

	rxPktsVal, ok := rxPktsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rx_pkts expected to be basetypes.Int64Value, was: %T`, rxPktsAttribute))
	}

	servpInfoAttribute, ok := attributes["servp_info"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`servp_info is missing from object`)

		return nil, diags
	}

	servpInfoVal, ok := servpInfoAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`servp_info expected to be basetypes.ObjectValue, was: %T`, servpInfoAttribute))
	}

	txBytesAttribute, ok := attributes["tx_bytes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tx_bytes is missing from object`)

		return nil, diags
	}

	txBytesVal, ok := txBytesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tx_bytes expected to be basetypes.Int64Value, was: %T`, txBytesAttribute))
	}

	txPktsAttribute, ok := attributes["tx_pkts"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tx_pkts is missing from object`)

		return nil, diags
	}

	txPktsVal, ok := txPktsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tx_pkts expected to be basetypes.Int64Value, was: %T`, txPktsAttribute))
	}

	upAttribute, ok := attributes["up"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`up is missing from object`)

		return nil, diags
	}

	upVal, ok := upAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`up expected to be basetypes.BoolValue, was: %T`, upAttribute))
	}

	vlanAttribute, ok := attributes["vlan"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan is missing from object`)

		return nil, diags
	}

	vlanVal, ok := vlanAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan expected to be basetypes.Int64Value, was: %T`, vlanAttribute))
	}

	wanNameAttribute, ok := attributes["wan_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wan_name is missing from object`)

		return nil, diags
	}

	wanNameVal, ok := wanNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wan_name expected to be basetypes.StringValue, was: %T`, wanNameAttribute))
	}

	wanTypeAttribute, ok := attributes["wan_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wan_type is missing from object`)

		return nil, diags
	}

	wanTypeVal, ok := wanTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wan_type expected to be basetypes.StringValue, was: %T`, wanTypeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return IfStatValue{
		AddressMode:     addressModeVal,
		Ips:             ipsVal,
		NatAddresses:    natAddressesVal,
		NetworkName:     networkNameVal,
		PortId:          portIdVal,
		PortUsage:       portUsageVal,
		RedundancyState: redundancyStateVal,
		RxBytes:         rxBytesVal,
		RxPkts:          rxPktsVal,
		ServpInfo:       servpInfoVal,
		TxBytes:         txBytesVal,
		TxPkts:          txPktsVal,
		Up:              upVal,
		Vlan:            vlanVal,
		WanName:         wanNameVal,
		WanType:         wanTypeVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewIfStatValueNull() IfStatValue {
	return IfStatValue{
		state: attr.ValueStateNull,
	}
}

func NewIfStatValueUnknown() IfStatValue {
	return IfStatValue{
		state: attr.ValueStateUnknown,
	}
}

func NewIfStatValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (IfStatValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing IfStatValue Attribute Value",
				"While creating a IfStatValue value, a missing attribute value was detected. "+
					"A IfStatValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("IfStatValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid IfStatValue Attribute Type",
				"While creating a IfStatValue value, an invalid attribute value was detected. "+
					"A IfStatValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("IfStatValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("IfStatValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra IfStatValue Attribute Value",
				"While creating a IfStatValue value, an extra attribute value was detected. "+
					"A IfStatValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra IfStatValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewIfStatValueUnknown(), diags
	}

	addressModeAttribute, ok := attributes["address_mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`address_mode is missing from object`)

		return NewIfStatValueUnknown(), diags
	}

	addressModeVal, ok := addressModeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`address_mode expected to be basetypes.StringValue, was: %T`, addressModeAttribute))
	}

	ipsAttribute, ok := attributes["ips"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ips is missing from object`)

		return NewIfStatValueUnknown(), diags
	}

	ipsVal, ok := ipsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ips expected to be basetypes.ListValue, was: %T`, ipsAttribute))
	}

	natAddressesAttribute, ok := attributes["nat_addresses"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`nat_addresses is missing from object`)

		return NewIfStatValueUnknown(), diags
	}

	natAddressesVal, ok := natAddressesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`nat_addresses expected to be basetypes.ListValue, was: %T`, natAddressesAttribute))
	}

	networkNameAttribute, ok := attributes["network_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`network_name is missing from object`)

		return NewIfStatValueUnknown(), diags
	}

	networkNameVal, ok := networkNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`network_name expected to be basetypes.StringValue, was: %T`, networkNameAttribute))
	}

	portIdAttribute, ok := attributes["port_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_id is missing from object`)

		return NewIfStatValueUnknown(), diags
	}

	portIdVal, ok := portIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_id expected to be basetypes.StringValue, was: %T`, portIdAttribute))
	}

	portUsageAttribute, ok := attributes["port_usage"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_usage is missing from object`)

		return NewIfStatValueUnknown(), diags
	}

	portUsageVal, ok := portUsageAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_usage expected to be basetypes.StringValue, was: %T`, portUsageAttribute))
	}

	redundancyStateAttribute, ok := attributes["redundancy_state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`redundancy_state is missing from object`)

		return NewIfStatValueUnknown(), diags
	}

	redundancyStateVal, ok := redundancyStateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`redundancy_state expected to be basetypes.StringValue, was: %T`, redundancyStateAttribute))
	}

	rxBytesAttribute, ok := attributes["rx_bytes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rx_bytes is missing from object`)

		return NewIfStatValueUnknown(), diags
	}

	rxBytesVal, ok := rxBytesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rx_bytes expected to be basetypes.Int64Value, was: %T`, rxBytesAttribute))
	}

	rxPktsAttribute, ok := attributes["rx_pkts"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rx_pkts is missing from object`)

		return NewIfStatValueUnknown(), diags
	}

	rxPktsVal, ok := rxPktsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rx_pkts expected to be basetypes.Int64Value, was: %T`, rxPktsAttribute))
	}

	servpInfoAttribute, ok := attributes["servp_info"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`servp_info is missing from object`)

		return NewIfStatValueUnknown(), diags
	}

	servpInfoVal, ok := servpInfoAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`servp_info expected to be basetypes.ObjectValue, was: %T`, servpInfoAttribute))
	}

	txBytesAttribute, ok := attributes["tx_bytes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tx_bytes is missing from object`)

		return NewIfStatValueUnknown(), diags
	}

	txBytesVal, ok := txBytesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tx_bytes expected to be basetypes.Int64Value, was: %T`, txBytesAttribute))
	}

	txPktsAttribute, ok := attributes["tx_pkts"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tx_pkts is missing from object`)

		return NewIfStatValueUnknown(), diags
	}

	txPktsVal, ok := txPktsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tx_pkts expected to be basetypes.Int64Value, was: %T`, txPktsAttribute))
	}

	upAttribute, ok := attributes["up"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`up is missing from object`)

		return NewIfStatValueUnknown(), diags
	}

	upVal, ok := upAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`up expected to be basetypes.BoolValue, was: %T`, upAttribute))
	}

	vlanAttribute, ok := attributes["vlan"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan is missing from object`)

		return NewIfStatValueUnknown(), diags
	}

	vlanVal, ok := vlanAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan expected to be basetypes.Int64Value, was: %T`, vlanAttribute))
	}

	wanNameAttribute, ok := attributes["wan_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wan_name is missing from object`)

		return NewIfStatValueUnknown(), diags
	}

	wanNameVal, ok := wanNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wan_name expected to be basetypes.StringValue, was: %T`, wanNameAttribute))
	}

	wanTypeAttribute, ok := attributes["wan_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wan_type is missing from object`)

		return NewIfStatValueUnknown(), diags
	}

	wanTypeVal, ok := wanTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wan_type expected to be basetypes.StringValue, was: %T`, wanTypeAttribute))
	}

	if diags.HasError() {
		return NewIfStatValueUnknown(), diags
	}

	return IfStatValue{
		AddressMode:     addressModeVal,
		Ips:             ipsVal,
		NatAddresses:    natAddressesVal,
		NetworkName:     networkNameVal,
		PortId:          portIdVal,
		PortUsage:       portUsageVal,
		RedundancyState: redundancyStateVal,
		RxBytes:         rxBytesVal,
		RxPkts:          rxPktsVal,
		ServpInfo:       servpInfoVal,
		TxBytes:         txBytesVal,
		TxPkts:          txPktsVal,
		Up:              upVal,
		Vlan:            vlanVal,
		WanName:         wanNameVal,
		WanType:         wanTypeVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewIfStatValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) IfStatValue {
	object, diags := NewIfStatValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewIfStatValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t IfStatType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewIfStatValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewIfStatValueUnknown(), nil
	}

	if in.IsNull() {
		return NewIfStatValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewIfStatValueMust(IfStatValue{}.AttributeTypes(ctx), attributes), nil
}

func (t IfStatType) ValueType(ctx context.Context) attr.Value {
	return IfStatValue{}
}

var _ basetypes.ObjectValuable = IfStatValue{}

type IfStatValue struct {
	AddressMode     basetypes.StringValue `tfsdk:"address_mode"`
	Ips             basetypes.ListValue   `tfsdk:"ips"`
	NatAddresses    basetypes.ListValue   `tfsdk:"nat_addresses"`
	NetworkName     basetypes.StringValue `tfsdk:"network_name"`
	PortId          basetypes.StringValue `tfsdk:"port_id"`
	PortUsage       basetypes.StringValue `tfsdk:"port_usage"`
	RedundancyState basetypes.StringValue `tfsdk:"redundancy_state"`
	RxBytes         basetypes.Int64Value  `tfsdk:"rx_bytes"`
	RxPkts          basetypes.Int64Value  `tfsdk:"rx_pkts"`
	ServpInfo       basetypes.ObjectValue `tfsdk:"servp_info"`
	TxBytes         basetypes.Int64Value  `tfsdk:"tx_bytes"`
	TxPkts          basetypes.Int64Value  `tfsdk:"tx_pkts"`
	Up              basetypes.BoolValue   `tfsdk:"up"`
	Vlan            basetypes.Int64Value  `tfsdk:"vlan"`
	WanName         basetypes.StringValue `tfsdk:"wan_name"`
	WanType         basetypes.StringValue `tfsdk:"wan_type"`
	state           attr.ValueState
}

func (v IfStatValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 16)

	var val tftypes.Value
	var err error

	attrTypes["address_mode"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ips"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["nat_addresses"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["network_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["port_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["port_usage"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["redundancy_state"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["rx_bytes"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["rx_pkts"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["servp_info"] = basetypes.ObjectType{
		AttrTypes: ServpInfoValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["tx_bytes"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["tx_pkts"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["up"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["vlan"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["wan_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["wan_type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 16)

		val, err = v.AddressMode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["address_mode"] = val

		val, err = v.Ips.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ips"] = val

		val, err = v.NatAddresses.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["nat_addresses"] = val

		val, err = v.NetworkName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["network_name"] = val

		val, err = v.PortId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port_id"] = val

		val, err = v.PortUsage.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port_usage"] = val

		val, err = v.RedundancyState.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["redundancy_state"] = val

		val, err = v.RxBytes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["rx_bytes"] = val

		val, err = v.RxPkts.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["rx_pkts"] = val

		val, err = v.ServpInfo.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["servp_info"] = val

		val, err = v.TxBytes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tx_bytes"] = val

		val, err = v.TxPkts.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tx_pkts"] = val

		val, err = v.Up.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["up"] = val

		val, err = v.Vlan.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vlan"] = val

		val, err = v.WanName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["wan_name"] = val

		val, err = v.WanType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["wan_type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v IfStatValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v IfStatValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v IfStatValue) String() string {
	return "IfStatValue"
}

func (v IfStatValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var servpInfo basetypes.ObjectValue

	if v.ServpInfo.IsNull() {
		servpInfo = types.ObjectNull(
			ServpInfoValue{}.AttributeTypes(ctx),
		)
	}

	if v.ServpInfo.IsUnknown() {
		servpInfo = types.ObjectUnknown(
			ServpInfoValue{}.AttributeTypes(ctx),
		)
	}

	if !v.ServpInfo.IsNull() && !v.ServpInfo.IsUnknown() {
		servpInfo = types.ObjectValueMust(
			ServpInfoValue{}.AttributeTypes(ctx),
			v.ServpInfo.Attributes(),
		)
	}

	ipsVal, d := types.ListValue(types.StringType, v.Ips.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"address_mode": basetypes.StringType{},
			"ips": basetypes.ListType{
				ElemType: types.StringType,
			},
			"nat_addresses": basetypes.ListType{
				ElemType: types.StringType,
			},
			"network_name":     basetypes.StringType{},
			"port_id":          basetypes.StringType{},
			"port_usage":       basetypes.StringType{},
			"redundancy_state": basetypes.StringType{},
			"rx_bytes":         basetypes.Int64Type{},
			"rx_pkts":          basetypes.Int64Type{},
			"servp_info": basetypes.ObjectType{
				AttrTypes: ServpInfoValue{}.AttributeTypes(ctx),
			},
			"tx_bytes": basetypes.Int64Type{},
			"tx_pkts":  basetypes.Int64Type{},
			"up":       basetypes.BoolType{},
			"vlan":     basetypes.Int64Type{},
			"wan_name": basetypes.StringType{},
			"wan_type": basetypes.StringType{},
		}), diags
	}

	natAddressesVal, d := types.ListValue(types.StringType, v.NatAddresses.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"address_mode": basetypes.StringType{},
			"ips": basetypes.ListType{
				ElemType: types.StringType,
			},
			"nat_addresses": basetypes.ListType{
				ElemType: types.StringType,
			},
			"network_name":     basetypes.StringType{},
			"port_id":          basetypes.StringType{},
			"port_usage":       basetypes.StringType{},
			"redundancy_state": basetypes.StringType{},
			"rx_bytes":         basetypes.Int64Type{},
			"rx_pkts":          basetypes.Int64Type{},
			"servp_info": basetypes.ObjectType{
				AttrTypes: ServpInfoValue{}.AttributeTypes(ctx),
			},
			"tx_bytes": basetypes.Int64Type{},
			"tx_pkts":  basetypes.Int64Type{},
			"up":       basetypes.BoolType{},
			"vlan":     basetypes.Int64Type{},
			"wan_name": basetypes.StringType{},
			"wan_type": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"address_mode": basetypes.StringType{},
		"ips": basetypes.ListType{
			ElemType: types.StringType,
		},
		"nat_addresses": basetypes.ListType{
			ElemType: types.StringType,
		},
		"network_name":     basetypes.StringType{},
		"port_id":          basetypes.StringType{},
		"port_usage":       basetypes.StringType{},
		"redundancy_state": basetypes.StringType{},
		"rx_bytes":         basetypes.Int64Type{},
		"rx_pkts":          basetypes.Int64Type{},
		"servp_info": basetypes.ObjectType{
			AttrTypes: ServpInfoValue{}.AttributeTypes(ctx),
		},
		"tx_bytes": basetypes.Int64Type{},
		"tx_pkts":  basetypes.Int64Type{},
		"up":       basetypes.BoolType{},
		"vlan":     basetypes.Int64Type{},
		"wan_name": basetypes.StringType{},
		"wan_type": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"address_mode":     v.AddressMode,
			"ips":              ipsVal,
			"nat_addresses":    natAddressesVal,
			"network_name":     v.NetworkName,
			"port_id":          v.PortId,
			"port_usage":       v.PortUsage,
			"redundancy_state": v.RedundancyState,
			"rx_bytes":         v.RxBytes,
			"rx_pkts":          v.RxPkts,
			"servp_info":       servpInfo,
			"tx_bytes":         v.TxBytes,
			"tx_pkts":          v.TxPkts,
			"up":               v.Up,
			"vlan":             v.Vlan,
			"wan_name":         v.WanName,
			"wan_type":         v.WanType,
		})

	return objVal, diags
}

func (v IfStatValue) Equal(o attr.Value) bool {
	other, ok := o.(IfStatValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AddressMode.Equal(other.AddressMode) {
		return false
	}

	if !v.Ips.Equal(other.Ips) {
		return false
	}

	if !v.NatAddresses.Equal(other.NatAddresses) {
		return false
	}

	if !v.NetworkName.Equal(other.NetworkName) {
		return false
	}

	if !v.PortId.Equal(other.PortId) {
		return false
	}

	if !v.PortUsage.Equal(other.PortUsage) {
		return false
	}

	if !v.RedundancyState.Equal(other.RedundancyState) {
		return false
	}

	if !v.RxBytes.Equal(other.RxBytes) {
		return false
	}

	if !v.RxPkts.Equal(other.RxPkts) {
		return false
	}

	if !v.ServpInfo.Equal(other.ServpInfo) {
		return false
	}

	if !v.TxBytes.Equal(other.TxBytes) {
		return false
	}

	if !v.TxPkts.Equal(other.TxPkts) {
		return false
	}

	if !v.Up.Equal(other.Up) {
		return false
	}

	if !v.Vlan.Equal(other.Vlan) {
		return false
	}

	if !v.WanName.Equal(other.WanName) {
		return false
	}

	if !v.WanType.Equal(other.WanType) {
		return false
	}

	return true
}

func (v IfStatValue) Type(ctx context.Context) attr.Type {
	return IfStatType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v IfStatValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"address_mode": basetypes.StringType{},
		"ips": basetypes.ListType{
			ElemType: types.StringType,
		},
		"nat_addresses": basetypes.ListType{
			ElemType: types.StringType,
		},
		"network_name":     basetypes.StringType{},
		"port_id":          basetypes.StringType{},
		"port_usage":       basetypes.StringType{},
		"redundancy_state": basetypes.StringType{},
		"rx_bytes":         basetypes.Int64Type{},
		"rx_pkts":          basetypes.Int64Type{},
		"servp_info": basetypes.ObjectType{
			AttrTypes: ServpInfoValue{}.AttributeTypes(ctx),
		},
		"tx_bytes": basetypes.Int64Type{},
		"tx_pkts":  basetypes.Int64Type{},
		"up":       basetypes.BoolType{},
		"vlan":     basetypes.Int64Type{},
		"wan_name": basetypes.StringType{},
		"wan_type": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = ServpInfoType{}

type ServpInfoType struct {
	basetypes.ObjectType
}

func (t ServpInfoType) Equal(o attr.Type) bool {
	other, ok := o.(ServpInfoType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ServpInfoType) String() string {
	return "ServpInfoType"
}

func (t ServpInfoType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	asnAttribute, ok := attributes["asn"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`asn is missing from object`)

		return nil, diags
	}

	asnVal, ok := asnAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`asn expected to be basetypes.StringValue, was: %T`, asnAttribute))
	}

	cityAttribute, ok := attributes["city"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`city is missing from object`)

		return nil, diags
	}

	cityVal, ok := cityAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`city expected to be basetypes.StringValue, was: %T`, cityAttribute))
	}

	countryCodeAttribute, ok := attributes["country_code"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`country_code is missing from object`)

		return nil, diags
	}

	countryCodeVal, ok := countryCodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`country_code expected to be basetypes.StringValue, was: %T`, countryCodeAttribute))
	}

	latitudeAttribute, ok := attributes["latitude"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`latitude is missing from object`)

		return nil, diags
	}

	latitudeVal, ok := latitudeAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`latitude expected to be basetypes.NumberValue, was: %T`, latitudeAttribute))
	}

	longitudeAttribute, ok := attributes["longitude"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`longitude is missing from object`)

		return nil, diags
	}

	longitudeVal, ok := longitudeAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`longitude expected to be basetypes.NumberValue, was: %T`, longitudeAttribute))
	}

	orgAttribute, ok := attributes["org"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`org is missing from object`)

		return nil, diags
	}

	orgVal, ok := orgAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`org expected to be basetypes.StringValue, was: %T`, orgAttribute))
	}

	regionCodeAttribute, ok := attributes["region_code"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`region_code is missing from object`)

		return nil, diags
	}

	regionCodeVal, ok := regionCodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`region_code expected to be basetypes.StringValue, was: %T`, regionCodeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ServpInfoValue{
		Asn:         asnVal,
		City:        cityVal,
		CountryCode: countryCodeVal,
		Latitude:    latitudeVal,
		Longitude:   longitudeVal,
		Org:         orgVal,
		RegionCode:  regionCodeVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewServpInfoValueNull() ServpInfoValue {
	return ServpInfoValue{
		state: attr.ValueStateNull,
	}
}

func NewServpInfoValueUnknown() ServpInfoValue {
	return ServpInfoValue{
		state: attr.ValueStateUnknown,
	}
}

func NewServpInfoValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ServpInfoValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ServpInfoValue Attribute Value",
				"While creating a ServpInfoValue value, a missing attribute value was detected. "+
					"A ServpInfoValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ServpInfoValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ServpInfoValue Attribute Type",
				"While creating a ServpInfoValue value, an invalid attribute value was detected. "+
					"A ServpInfoValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ServpInfoValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ServpInfoValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ServpInfoValue Attribute Value",
				"While creating a ServpInfoValue value, an extra attribute value was detected. "+
					"A ServpInfoValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ServpInfoValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewServpInfoValueUnknown(), diags
	}

	asnAttribute, ok := attributes["asn"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`asn is missing from object`)

		return NewServpInfoValueUnknown(), diags
	}

	asnVal, ok := asnAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`asn expected to be basetypes.StringValue, was: %T`, asnAttribute))
	}

	cityAttribute, ok := attributes["city"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`city is missing from object`)

		return NewServpInfoValueUnknown(), diags
	}

	cityVal, ok := cityAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`city expected to be basetypes.StringValue, was: %T`, cityAttribute))
	}

	countryCodeAttribute, ok := attributes["country_code"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`country_code is missing from object`)

		return NewServpInfoValueUnknown(), diags
	}

	countryCodeVal, ok := countryCodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`country_code expected to be basetypes.StringValue, was: %T`, countryCodeAttribute))
	}

	latitudeAttribute, ok := attributes["latitude"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`latitude is missing from object`)

		return NewServpInfoValueUnknown(), diags
	}

	latitudeVal, ok := latitudeAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`latitude expected to be basetypes.NumberValue, was: %T`, latitudeAttribute))
	}

	longitudeAttribute, ok := attributes["longitude"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`longitude is missing from object`)

		return NewServpInfoValueUnknown(), diags
	}

	longitudeVal, ok := longitudeAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`longitude expected to be basetypes.NumberValue, was: %T`, longitudeAttribute))
	}

	orgAttribute, ok := attributes["org"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`org is missing from object`)

		return NewServpInfoValueUnknown(), diags
	}

	orgVal, ok := orgAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`org expected to be basetypes.StringValue, was: %T`, orgAttribute))
	}

	regionCodeAttribute, ok := attributes["region_code"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`region_code is missing from object`)

		return NewServpInfoValueUnknown(), diags
	}

	regionCodeVal, ok := regionCodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`region_code expected to be basetypes.StringValue, was: %T`, regionCodeAttribute))
	}

	if diags.HasError() {
		return NewServpInfoValueUnknown(), diags
	}

	return ServpInfoValue{
		Asn:         asnVal,
		City:        cityVal,
		CountryCode: countryCodeVal,
		Latitude:    latitudeVal,
		Longitude:   longitudeVal,
		Org:         orgVal,
		RegionCode:  regionCodeVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewServpInfoValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ServpInfoValue {
	object, diags := NewServpInfoValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewServpInfoValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ServpInfoType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewServpInfoValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewServpInfoValueUnknown(), nil
	}

	if in.IsNull() {
		return NewServpInfoValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewServpInfoValueMust(ServpInfoValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ServpInfoType) ValueType(ctx context.Context) attr.Value {
	return ServpInfoValue{}
}

var _ basetypes.ObjectValuable = ServpInfoValue{}

type ServpInfoValue struct {
	Asn         basetypes.StringValue `tfsdk:"asn"`
	City        basetypes.StringValue `tfsdk:"city"`
	CountryCode basetypes.StringValue `tfsdk:"country_code"`
	Latitude    basetypes.NumberValue `tfsdk:"latitude"`
	Longitude   basetypes.NumberValue `tfsdk:"longitude"`
	Org         basetypes.StringValue `tfsdk:"org"`
	RegionCode  basetypes.StringValue `tfsdk:"region_code"`
	state       attr.ValueState
}

func (v ServpInfoValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 7)

	var val tftypes.Value
	var err error

	attrTypes["asn"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["city"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["country_code"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["latitude"] = basetypes.NumberType{}.TerraformType(ctx)
	attrTypes["longitude"] = basetypes.NumberType{}.TerraformType(ctx)
	attrTypes["org"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["region_code"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 7)

		val, err = v.Asn.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["asn"] = val

		val, err = v.City.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["city"] = val

		val, err = v.CountryCode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["country_code"] = val

		val, err = v.Latitude.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["latitude"] = val

		val, err = v.Longitude.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["longitude"] = val

		val, err = v.Org.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["org"] = val

		val, err = v.RegionCode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["region_code"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ServpInfoValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ServpInfoValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ServpInfoValue) String() string {
	return "ServpInfoValue"
}

func (v ServpInfoValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"asn":          basetypes.StringType{},
		"city":         basetypes.StringType{},
		"country_code": basetypes.StringType{},
		"latitude":     basetypes.NumberType{},
		"longitude":    basetypes.NumberType{},
		"org":          basetypes.StringType{},
		"region_code":  basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"asn":          v.Asn,
			"city":         v.City,
			"country_code": v.CountryCode,
			"latitude":     v.Latitude,
			"longitude":    v.Longitude,
			"org":          v.Org,
			"region_code":  v.RegionCode,
		})

	return objVal, diags
}

func (v ServpInfoValue) Equal(o attr.Value) bool {
	other, ok := o.(ServpInfoValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Asn.Equal(other.Asn) {
		return false
	}

	if !v.City.Equal(other.City) {
		return false
	}

	if !v.CountryCode.Equal(other.CountryCode) {
		return false
	}

	if !v.Latitude.Equal(other.Latitude) {
		return false
	}

	if !v.Longitude.Equal(other.Longitude) {
		return false
	}

	if !v.Org.Equal(other.Org) {
		return false
	}

	if !v.RegionCode.Equal(other.RegionCode) {
		return false
	}

	return true
}

func (v ServpInfoValue) Type(ctx context.Context) attr.Type {
	return ServpInfoType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ServpInfoValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"asn":          basetypes.StringType{},
		"city":         basetypes.StringType{},
		"country_code": basetypes.StringType{},
		"latitude":     basetypes.NumberType{},
		"longitude":    basetypes.NumberType{},
		"org":          basetypes.StringType{},
		"region_code":  basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = IpStatType{}

type IpStatType struct {
	basetypes.ObjectType
}

func (t IpStatType) Equal(o attr.Type) bool {
	other, ok := o.(IpStatType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t IpStatType) String() string {
	return "IpStatType"
}

func (t IpStatType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	dhcpServerAttribute, ok := attributes["dhcp_server"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dhcp_server is missing from object`)

		return nil, diags
	}

	dhcpServerVal, ok := dhcpServerAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dhcp_server expected to be basetypes.StringValue, was: %T`, dhcpServerAttribute))
	}

	dnsAttribute, ok := attributes["dns"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dns is missing from object`)

		return nil, diags
	}

	dnsVal, ok := dnsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dns expected to be basetypes.ListValue, was: %T`, dnsAttribute))
	}

	dnsSuffixAttribute, ok := attributes["dns_suffix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dns_suffix is missing from object`)

		return nil, diags
	}

	dnsSuffixVal, ok := dnsSuffixAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dns_suffix expected to be basetypes.ListValue, was: %T`, dnsSuffixAttribute))
	}

	gatewayAttribute, ok := attributes["gateway"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gateway is missing from object`)

		return nil, diags
	}

	gatewayVal, ok := gatewayAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gateway expected to be basetypes.StringValue, was: %T`, gatewayAttribute))
	}

	gateway6Attribute, ok := attributes["gateway6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gateway6 is missing from object`)

		return nil, diags
	}

	gateway6Val, ok := gateway6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gateway6 expected to be basetypes.StringValue, was: %T`, gateway6Attribute))
	}

	ipAttribute, ok := attributes["ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip is missing from object`)

		return nil, diags
	}

	ipVal, ok := ipAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip expected to be basetypes.StringValue, was: %T`, ipAttribute))
	}

	ip6Attribute, ok := attributes["ip6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip6 is missing from object`)

		return nil, diags
	}

	ip6Val, ok := ip6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip6 expected to be basetypes.StringValue, was: %T`, ip6Attribute))
	}

	ipsAttribute, ok := attributes["ips"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ips is missing from object`)

		return nil, diags
	}

	ipsVal, ok := ipsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ips expected to be basetypes.MapValue, was: %T`, ipsAttribute))
	}

	netmaskAttribute, ok := attributes["netmask"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`netmask is missing from object`)

		return nil, diags
	}

	netmaskVal, ok := netmaskAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`netmask expected to be basetypes.StringValue, was: %T`, netmaskAttribute))
	}

	netmask6Attribute, ok := attributes["netmask6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`netmask6 is missing from object`)

		return nil, diags
	}

	netmask6Val, ok := netmask6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`netmask6 expected to be basetypes.StringValue, was: %T`, netmask6Attribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return IpStatValue{
		DhcpServer: dhcpServerVal,
		Dns:        dnsVal,
		DnsSuffix:  dnsSuffixVal,
		Gateway:    gatewayVal,
		Gateway6:   gateway6Val,
		Ip:         ipVal,
		Ip6:        ip6Val,
		Ips:        ipsVal,
		Netmask:    netmaskVal,
		Netmask6:   netmask6Val,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewIpStatValueNull() IpStatValue {
	return IpStatValue{
		state: attr.ValueStateNull,
	}
}

func NewIpStatValueUnknown() IpStatValue {
	return IpStatValue{
		state: attr.ValueStateUnknown,
	}
}

func NewIpStatValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (IpStatValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing IpStatValue Attribute Value",
				"While creating a IpStatValue value, a missing attribute value was detected. "+
					"A IpStatValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("IpStatValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid IpStatValue Attribute Type",
				"While creating a IpStatValue value, an invalid attribute value was detected. "+
					"A IpStatValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("IpStatValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("IpStatValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra IpStatValue Attribute Value",
				"While creating a IpStatValue value, an extra attribute value was detected. "+
					"A IpStatValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra IpStatValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewIpStatValueUnknown(), diags
	}

	dhcpServerAttribute, ok := attributes["dhcp_server"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dhcp_server is missing from object`)

		return NewIpStatValueUnknown(), diags
	}

	dhcpServerVal, ok := dhcpServerAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dhcp_server expected to be basetypes.StringValue, was: %T`, dhcpServerAttribute))
	}

	dnsAttribute, ok := attributes["dns"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dns is missing from object`)

		return NewIpStatValueUnknown(), diags
	}

	dnsVal, ok := dnsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dns expected to be basetypes.ListValue, was: %T`, dnsAttribute))
	}

	dnsSuffixAttribute, ok := attributes["dns_suffix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dns_suffix is missing from object`)

		return NewIpStatValueUnknown(), diags
	}

	dnsSuffixVal, ok := dnsSuffixAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dns_suffix expected to be basetypes.ListValue, was: %T`, dnsSuffixAttribute))
	}

	gatewayAttribute, ok := attributes["gateway"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gateway is missing from object`)

		return NewIpStatValueUnknown(), diags
	}

	gatewayVal, ok := gatewayAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gateway expected to be basetypes.StringValue, was: %T`, gatewayAttribute))
	}

	gateway6Attribute, ok := attributes["gateway6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gateway6 is missing from object`)

		return NewIpStatValueUnknown(), diags
	}

	gateway6Val, ok := gateway6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gateway6 expected to be basetypes.StringValue, was: %T`, gateway6Attribute))
	}

	ipAttribute, ok := attributes["ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip is missing from object`)

		return NewIpStatValueUnknown(), diags
	}

	ipVal, ok := ipAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip expected to be basetypes.StringValue, was: %T`, ipAttribute))
	}

	ip6Attribute, ok := attributes["ip6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip6 is missing from object`)

		return NewIpStatValueUnknown(), diags
	}

	ip6Val, ok := ip6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip6 expected to be basetypes.StringValue, was: %T`, ip6Attribute))
	}

	ipsAttribute, ok := attributes["ips"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ips is missing from object`)

		return NewIpStatValueUnknown(), diags
	}

	ipsVal, ok := ipsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ips expected to be basetypes.MapValue, was: %T`, ipsAttribute))
	}

	netmaskAttribute, ok := attributes["netmask"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`netmask is missing from object`)

		return NewIpStatValueUnknown(), diags
	}

	netmaskVal, ok := netmaskAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`netmask expected to be basetypes.StringValue, was: %T`, netmaskAttribute))
	}

	netmask6Attribute, ok := attributes["netmask6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`netmask6 is missing from object`)

		return NewIpStatValueUnknown(), diags
	}

	netmask6Val, ok := netmask6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`netmask6 expected to be basetypes.StringValue, was: %T`, netmask6Attribute))
	}

	if diags.HasError() {
		return NewIpStatValueUnknown(), diags
	}

	return IpStatValue{
		DhcpServer: dhcpServerVal,
		Dns:        dnsVal,
		DnsSuffix:  dnsSuffixVal,
		Gateway:    gatewayVal,
		Gateway6:   gateway6Val,
		Ip:         ipVal,
		Ip6:        ip6Val,
		Ips:        ipsVal,
		Netmask:    netmaskVal,
		Netmask6:   netmask6Val,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewIpStatValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) IpStatValue {
	object, diags := NewIpStatValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewIpStatValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t IpStatType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewIpStatValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewIpStatValueUnknown(), nil
	}

	if in.IsNull() {
		return NewIpStatValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewIpStatValueMust(IpStatValue{}.AttributeTypes(ctx), attributes), nil
}

func (t IpStatType) ValueType(ctx context.Context) attr.Value {
	return IpStatValue{}
}

var _ basetypes.ObjectValuable = IpStatValue{}

type IpStatValue struct {
	DhcpServer basetypes.StringValue `tfsdk:"dhcp_server"`
	Dns        basetypes.ListValue   `tfsdk:"dns"`
	DnsSuffix  basetypes.ListValue   `tfsdk:"dns_suffix"`
	Gateway    basetypes.StringValue `tfsdk:"gateway"`
	Gateway6   basetypes.StringValue `tfsdk:"gateway6"`
	Ip         basetypes.StringValue `tfsdk:"ip"`
	Ip6        basetypes.StringValue `tfsdk:"ip6"`
	Ips        basetypes.MapValue    `tfsdk:"ips"`
	Netmask    basetypes.StringValue `tfsdk:"netmask"`
	Netmask6   basetypes.StringValue `tfsdk:"netmask6"`
	state      attr.ValueState
}

func (v IpStatValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 10)

	var val tftypes.Value
	var err error

	attrTypes["dhcp_server"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["dns"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["dns_suffix"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["gateway"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["gateway6"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ip"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ip6"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ips"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["netmask"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["netmask6"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 10)

		val, err = v.DhcpServer.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dhcp_server"] = val

		val, err = v.Dns.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dns"] = val

		val, err = v.DnsSuffix.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dns_suffix"] = val

		val, err = v.Gateway.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["gateway"] = val

		val, err = v.Gateway6.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["gateway6"] = val

		val, err = v.Ip.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip"] = val

		val, err = v.Ip6.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip6"] = val

		val, err = v.Ips.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ips"] = val

		val, err = v.Netmask.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["netmask"] = val

		val, err = v.Netmask6.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["netmask6"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v IpStatValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v IpStatValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v IpStatValue) String() string {
	return "IpStatValue"
}

func (v IpStatValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	dnsVal, d := types.ListValue(types.StringType, v.Dns.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"dhcp_server": basetypes.StringType{},
			"dns": basetypes.ListType{
				ElemType: types.StringType,
			},
			"dns_suffix": basetypes.ListType{
				ElemType: types.StringType,
			},
			"gateway":  basetypes.StringType{},
			"gateway6": basetypes.StringType{},
			"ip":       basetypes.StringType{},
			"ip6":      basetypes.StringType{},
			"ips": basetypes.MapType{
				ElemType: types.StringType,
			},
			"netmask":  basetypes.StringType{},
			"netmask6": basetypes.StringType{},
		}), diags
	}

	dnsSuffixVal, d := types.ListValue(types.StringType, v.DnsSuffix.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"dhcp_server": basetypes.StringType{},
			"dns": basetypes.ListType{
				ElemType: types.StringType,
			},
			"dns_suffix": basetypes.ListType{
				ElemType: types.StringType,
			},
			"gateway":  basetypes.StringType{},
			"gateway6": basetypes.StringType{},
			"ip":       basetypes.StringType{},
			"ip6":      basetypes.StringType{},
			"ips": basetypes.MapType{
				ElemType: types.StringType,
			},
			"netmask":  basetypes.StringType{},
			"netmask6": basetypes.StringType{},
		}), diags
	}

	ipsVal, d := types.MapValue(types.StringType, v.Ips.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"dhcp_server": basetypes.StringType{},
			"dns": basetypes.ListType{
				ElemType: types.StringType,
			},
			"dns_suffix": basetypes.ListType{
				ElemType: types.StringType,
			},
			"gateway":  basetypes.StringType{},
			"gateway6": basetypes.StringType{},
			"ip":       basetypes.StringType{},
			"ip6":      basetypes.StringType{},
			"ips": basetypes.MapType{
				ElemType: types.StringType,
			},
			"netmask":  basetypes.StringType{},
			"netmask6": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"dhcp_server": basetypes.StringType{},
		"dns": basetypes.ListType{
			ElemType: types.StringType,
		},
		"dns_suffix": basetypes.ListType{
			ElemType: types.StringType,
		},
		"gateway":  basetypes.StringType{},
		"gateway6": basetypes.StringType{},
		"ip":       basetypes.StringType{},
		"ip6":      basetypes.StringType{},
		"ips": basetypes.MapType{
			ElemType: types.StringType,
		},
		"netmask":  basetypes.StringType{},
		"netmask6": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"dhcp_server": v.DhcpServer,
			"dns":         dnsVal,
			"dns_suffix":  dnsSuffixVal,
			"gateway":     v.Gateway,
			"gateway6":    v.Gateway6,
			"ip":          v.Ip,
			"ip6":         v.Ip6,
			"ips":         ipsVal,
			"netmask":     v.Netmask,
			"netmask6":    v.Netmask6,
		})

	return objVal, diags
}

func (v IpStatValue) Equal(o attr.Value) bool {
	other, ok := o.(IpStatValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.DhcpServer.Equal(other.DhcpServer) {
		return false
	}

	if !v.Dns.Equal(other.Dns) {
		return false
	}

	if !v.DnsSuffix.Equal(other.DnsSuffix) {
		return false
	}

	if !v.Gateway.Equal(other.Gateway) {
		return false
	}

	if !v.Gateway6.Equal(other.Gateway6) {
		return false
	}

	if !v.Ip.Equal(other.Ip) {
		return false
	}

	if !v.Ip6.Equal(other.Ip6) {
		return false
	}

	if !v.Ips.Equal(other.Ips) {
		return false
	}

	if !v.Netmask.Equal(other.Netmask) {
		return false
	}

	if !v.Netmask6.Equal(other.Netmask6) {
		return false
	}

	return true
}

func (v IpStatValue) Type(ctx context.Context) attr.Type {
	return IpStatType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v IpStatValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"dhcp_server": basetypes.StringType{},
		"dns": basetypes.ListType{
			ElemType: types.StringType,
		},
		"dns_suffix": basetypes.ListType{
			ElemType: types.StringType,
		},
		"gateway":  basetypes.StringType{},
		"gateway6": basetypes.StringType{},
		"ip":       basetypes.StringType{},
		"ip6":      basetypes.StringType{},
		"ips": basetypes.MapType{
			ElemType: types.StringType,
		},
		"netmask":  basetypes.StringType{},
		"netmask6": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = LastTroubleType{}

type LastTroubleType struct {
	basetypes.ObjectType
}

func (t LastTroubleType) Equal(o attr.Type) bool {
	other, ok := o.(LastTroubleType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t LastTroubleType) String() string {
	return "LastTroubleType"
}

func (t LastTroubleType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	codeAttribute, ok := attributes["code"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`code is missing from object`)

		return nil, diags
	}

	codeVal, ok := codeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`code expected to be basetypes.StringValue, was: %T`, codeAttribute))
	}

	timestampAttribute, ok := attributes["timestamp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`timestamp is missing from object`)

		return nil, diags
	}

	timestampVal, ok := timestampAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`timestamp expected to be basetypes.Int64Value, was: %T`, timestampAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return LastTroubleValue{
		Code:      codeVal,
		Timestamp: timestampVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewLastTroubleValueNull() LastTroubleValue {
	return LastTroubleValue{
		state: attr.ValueStateNull,
	}
}

func NewLastTroubleValueUnknown() LastTroubleValue {
	return LastTroubleValue{
		state: attr.ValueStateUnknown,
	}
}

func NewLastTroubleValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (LastTroubleValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing LastTroubleValue Attribute Value",
				"While creating a LastTroubleValue value, a missing attribute value was detected. "+
					"A LastTroubleValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("LastTroubleValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid LastTroubleValue Attribute Type",
				"While creating a LastTroubleValue value, an invalid attribute value was detected. "+
					"A LastTroubleValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("LastTroubleValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("LastTroubleValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra LastTroubleValue Attribute Value",
				"While creating a LastTroubleValue value, an extra attribute value was detected. "+
					"A LastTroubleValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra LastTroubleValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewLastTroubleValueUnknown(), diags
	}

	codeAttribute, ok := attributes["code"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`code is missing from object`)

		return NewLastTroubleValueUnknown(), diags
	}

	codeVal, ok := codeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`code expected to be basetypes.StringValue, was: %T`, codeAttribute))
	}

	timestampAttribute, ok := attributes["timestamp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`timestamp is missing from object`)

		return NewLastTroubleValueUnknown(), diags
	}

	timestampVal, ok := timestampAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`timestamp expected to be basetypes.Int64Value, was: %T`, timestampAttribute))
	}

	if diags.HasError() {
		return NewLastTroubleValueUnknown(), diags
	}

	return LastTroubleValue{
		Code:      codeVal,
		Timestamp: timestampVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewLastTroubleValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) LastTroubleValue {
	object, diags := NewLastTroubleValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewLastTroubleValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t LastTroubleType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewLastTroubleValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewLastTroubleValueUnknown(), nil
	}

	if in.IsNull() {
		return NewLastTroubleValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewLastTroubleValueMust(LastTroubleValue{}.AttributeTypes(ctx), attributes), nil
}

func (t LastTroubleType) ValueType(ctx context.Context) attr.Value {
	return LastTroubleValue{}
}

var _ basetypes.ObjectValuable = LastTroubleValue{}

type LastTroubleValue struct {
	Code      basetypes.StringValue `tfsdk:"code"`
	Timestamp basetypes.Int64Value  `tfsdk:"timestamp"`
	state     attr.ValueState
}

func (v LastTroubleValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["code"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["timestamp"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Code.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["code"] = val

		val, err = v.Timestamp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["timestamp"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v LastTroubleValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v LastTroubleValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v LastTroubleValue) String() string {
	return "LastTroubleValue"
}

func (v LastTroubleValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"code":      basetypes.StringType{},
		"timestamp": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"code":      v.Code,
			"timestamp": v.Timestamp,
		})

	return objVal, diags
}

func (v LastTroubleValue) Equal(o attr.Value) bool {
	other, ok := o.(LastTroubleValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Code.Equal(other.Code) {
		return false
	}

	if !v.Timestamp.Equal(other.Timestamp) {
		return false
	}

	return true
}

func (v LastTroubleValue) Type(ctx context.Context) attr.Type {
	return LastTroubleType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v LastTroubleValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"code":      basetypes.StringType{},
		"timestamp": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = MacTableStatsType{}

type MacTableStatsType struct {
	basetypes.ObjectType
}

func (t MacTableStatsType) Equal(o attr.Type) bool {
	other, ok := o.(MacTableStatsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t MacTableStatsType) String() string {
	return "MacTableStatsType"
}

func (t MacTableStatsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	macTableCountAttribute, ok := attributes["mac_table_count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mac_table_count is missing from object`)

		return nil, diags
	}

	macTableCountVal, ok := macTableCountAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mac_table_count expected to be basetypes.Int64Value, was: %T`, macTableCountAttribute))
	}

	maxMacEntriesSupportedAttribute, ok := attributes["max_mac_entries_supported"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_mac_entries_supported is missing from object`)

		return nil, diags
	}

	maxMacEntriesSupportedVal, ok := maxMacEntriesSupportedAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_mac_entries_supported expected to be basetypes.Int64Value, was: %T`, maxMacEntriesSupportedAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return MacTableStatsValue{
		MacTableCount:          macTableCountVal,
		MaxMacEntriesSupported: maxMacEntriesSupportedVal,
		state:                  attr.ValueStateKnown,
	}, diags
}

func NewMacTableStatsValueNull() MacTableStatsValue {
	return MacTableStatsValue{
		state: attr.ValueStateNull,
	}
}

func NewMacTableStatsValueUnknown() MacTableStatsValue {
	return MacTableStatsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewMacTableStatsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (MacTableStatsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing MacTableStatsValue Attribute Value",
				"While creating a MacTableStatsValue value, a missing attribute value was detected. "+
					"A MacTableStatsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MacTableStatsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid MacTableStatsValue Attribute Type",
				"While creating a MacTableStatsValue value, an invalid attribute value was detected. "+
					"A MacTableStatsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MacTableStatsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("MacTableStatsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra MacTableStatsValue Attribute Value",
				"While creating a MacTableStatsValue value, an extra attribute value was detected. "+
					"A MacTableStatsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra MacTableStatsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewMacTableStatsValueUnknown(), diags
	}

	macTableCountAttribute, ok := attributes["mac_table_count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mac_table_count is missing from object`)

		return NewMacTableStatsValueUnknown(), diags
	}

	macTableCountVal, ok := macTableCountAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mac_table_count expected to be basetypes.Int64Value, was: %T`, macTableCountAttribute))
	}

	maxMacEntriesSupportedAttribute, ok := attributes["max_mac_entries_supported"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_mac_entries_supported is missing from object`)

		return NewMacTableStatsValueUnknown(), diags
	}

	maxMacEntriesSupportedVal, ok := maxMacEntriesSupportedAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_mac_entries_supported expected to be basetypes.Int64Value, was: %T`, maxMacEntriesSupportedAttribute))
	}

	if diags.HasError() {
		return NewMacTableStatsValueUnknown(), diags
	}

	return MacTableStatsValue{
		MacTableCount:          macTableCountVal,
		MaxMacEntriesSupported: maxMacEntriesSupportedVal,
		state:                  attr.ValueStateKnown,
	}, diags
}

func NewMacTableStatsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) MacTableStatsValue {
	object, diags := NewMacTableStatsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewMacTableStatsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t MacTableStatsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewMacTableStatsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewMacTableStatsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewMacTableStatsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewMacTableStatsValueMust(MacTableStatsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t MacTableStatsType) ValueType(ctx context.Context) attr.Value {
	return MacTableStatsValue{}
}

var _ basetypes.ObjectValuable = MacTableStatsValue{}

type MacTableStatsValue struct {
	MacTableCount          basetypes.Int64Value `tfsdk:"mac_table_count"`
	MaxMacEntriesSupported basetypes.Int64Value `tfsdk:"max_mac_entries_supported"`
	state                  attr.ValueState
}

func (v MacTableStatsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["mac_table_count"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["max_mac_entries_supported"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.MacTableCount.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mac_table_count"] = val

		val, err = v.MaxMacEntriesSupported.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_mac_entries_supported"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v MacTableStatsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v MacTableStatsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v MacTableStatsValue) String() string {
	return "MacTableStatsValue"
}

func (v MacTableStatsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"mac_table_count":           basetypes.Int64Type{},
		"max_mac_entries_supported": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"mac_table_count":           v.MacTableCount,
			"max_mac_entries_supported": v.MaxMacEntriesSupported,
		})

	return objVal, diags
}

func (v MacTableStatsValue) Equal(o attr.Value) bool {
	other, ok := o.(MacTableStatsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.MacTableCount.Equal(other.MacTableCount) {
		return false
	}

	if !v.MaxMacEntriesSupported.Equal(other.MaxMacEntriesSupported) {
		return false
	}

	return true
}

func (v MacTableStatsValue) Type(ctx context.Context) attr.Type {
	return MacTableStatsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v MacTableStatsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"mac_table_count":           basetypes.Int64Type{},
		"max_mac_entries_supported": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = MemoryStatType{}

type MemoryStatType struct {
	basetypes.ObjectType
}

func (t MemoryStatType) Equal(o attr.Type) bool {
	other, ok := o.(MemoryStatType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t MemoryStatType) String() string {
	return "MemoryStatType"
}

func (t MemoryStatType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	usageAttribute, ok := attributes["usage"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`usage is missing from object`)

		return nil, diags
	}

	usageVal, ok := usageAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`usage expected to be basetypes.NumberValue, was: %T`, usageAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return MemoryStatValue{
		Usage: usageVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewMemoryStatValueNull() MemoryStatValue {
	return MemoryStatValue{
		state: attr.ValueStateNull,
	}
}

func NewMemoryStatValueUnknown() MemoryStatValue {
	return MemoryStatValue{
		state: attr.ValueStateUnknown,
	}
}

func NewMemoryStatValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (MemoryStatValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing MemoryStatValue Attribute Value",
				"While creating a MemoryStatValue value, a missing attribute value was detected. "+
					"A MemoryStatValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MemoryStatValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid MemoryStatValue Attribute Type",
				"While creating a MemoryStatValue value, an invalid attribute value was detected. "+
					"A MemoryStatValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MemoryStatValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("MemoryStatValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra MemoryStatValue Attribute Value",
				"While creating a MemoryStatValue value, an extra attribute value was detected. "+
					"A MemoryStatValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra MemoryStatValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewMemoryStatValueUnknown(), diags
	}

	usageAttribute, ok := attributes["usage"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`usage is missing from object`)

		return NewMemoryStatValueUnknown(), diags
	}

	usageVal, ok := usageAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`usage expected to be basetypes.NumberValue, was: %T`, usageAttribute))
	}

	if diags.HasError() {
		return NewMemoryStatValueUnknown(), diags
	}

	return MemoryStatValue{
		Usage: usageVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewMemoryStatValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) MemoryStatValue {
	object, diags := NewMemoryStatValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewMemoryStatValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t MemoryStatType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewMemoryStatValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewMemoryStatValueUnknown(), nil
	}

	if in.IsNull() {
		return NewMemoryStatValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewMemoryStatValueMust(MemoryStatValue{}.AttributeTypes(ctx), attributes), nil
}

func (t MemoryStatType) ValueType(ctx context.Context) attr.Value {
	return MemoryStatValue{}
}

var _ basetypes.ObjectValuable = MemoryStatValue{}

type MemoryStatValue struct {
	Usage basetypes.NumberValue `tfsdk:"usage"`
	state attr.ValueState
}

func (v MemoryStatValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["usage"] = basetypes.NumberType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Usage.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["usage"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v MemoryStatValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v MemoryStatValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v MemoryStatValue) String() string {
	return "MemoryStatValue"
}

func (v MemoryStatValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"usage": basetypes.NumberType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"usage": v.Usage,
		})

	return objVal, diags
}

func (v MemoryStatValue) Equal(o attr.Value) bool {
	other, ok := o.(MemoryStatValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Usage.Equal(other.Usage) {
		return false
	}

	return true
}

func (v MemoryStatValue) Type(ctx context.Context) attr.Type {
	return MemoryStatType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v MemoryStatValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"usage": basetypes.NumberType{},
	}
}

var _ basetypes.ObjectTypable = ModuleStatType{}

type ModuleStatType struct {
	basetypes.ObjectType
}

func (t ModuleStatType) Equal(o attr.Type) bool {
	other, ok := o.(ModuleStatType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ModuleStatType) String() string {
	return "ModuleStatType"
}

func (t ModuleStatType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	backupVersionAttribute, ok := attributes["backup_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`backup_version is missing from object`)

		return nil, diags
	}

	backupVersionVal, ok := backupVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`backup_version expected to be basetypes.StringValue, was: %T`, backupVersionAttribute))
	}

	biosVersionAttribute, ok := attributes["bios_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bios_version is missing from object`)

		return nil, diags
	}

	biosVersionVal, ok := biosVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bios_version expected to be basetypes.StringValue, was: %T`, biosVersionAttribute))
	}

	cpldVersionAttribute, ok := attributes["cpld_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cpld_version is missing from object`)

		return nil, diags
	}

	cpldVersionVal, ok := cpldVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cpld_version expected to be basetypes.StringValue, was: %T`, cpldVersionAttribute))
	}

	errorsAttribute, ok := attributes["errors"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`errors is missing from object`)

		return nil, diags
	}

	errorsVal, ok := errorsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`errors expected to be basetypes.ListValue, was: %T`, errorsAttribute))
	}

	fansAttribute, ok := attributes["fans"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fans is missing from object`)

		return nil, diags
	}

	fansVal, ok := fansAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fans expected to be basetypes.ListValue, was: %T`, fansAttribute))
	}

	fpcIdxAttribute, ok := attributes["fpc_idx"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fpc_idx is missing from object`)

		return nil, diags
	}

	fpcIdxVal, ok := fpcIdxAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fpc_idx expected to be basetypes.Int64Value, was: %T`, fpcIdxAttribute))
	}

	fpgaVersionAttribute, ok := attributes["fpga_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fpga_version is missing from object`)

		return nil, diags
	}

	fpgaVersionVal, ok := fpgaVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fpga_version expected to be basetypes.StringValue, was: %T`, fpgaVersionAttribute))
	}

	lastSeenAttribute, ok := attributes["last_seen"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`last_seen is missing from object`)

		return nil, diags
	}

	lastSeenVal, ok := lastSeenAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`last_seen expected to be basetypes.NumberValue, was: %T`, lastSeenAttribute))
	}

	modelAttribute, ok := attributes["model"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`model is missing from object`)

		return nil, diags
	}

	modelVal, ok := modelAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`model expected to be basetypes.StringValue, was: %T`, modelAttribute))
	}

	opticsCpldVersionAttribute, ok := attributes["optics_cpld_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`optics_cpld_version is missing from object`)

		return nil, diags
	}

	opticsCpldVersionVal, ok := opticsCpldVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`optics_cpld_version expected to be basetypes.StringValue, was: %T`, opticsCpldVersionAttribute))
	}

	pendingVersionAttribute, ok := attributes["pending_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pending_version is missing from object`)

		return nil, diags
	}

	pendingVersionVal, ok := pendingVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pending_version expected to be basetypes.StringValue, was: %T`, pendingVersionAttribute))
	}

	picsAttribute, ok := attributes["pics"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pics is missing from object`)

		return nil, diags
	}

	picsVal, ok := picsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pics expected to be basetypes.ListValue, was: %T`, picsAttribute))
	}

	poeAttribute, ok := attributes["poe"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`poe is missing from object`)

		return nil, diags
	}

	poeVal, ok := poeAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`poe expected to be basetypes.ObjectValue, was: %T`, poeAttribute))
	}

	poeVersionAttribute, ok := attributes["poe_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`poe_version is missing from object`)

		return nil, diags
	}

	poeVersionVal, ok := poeVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`poe_version expected to be basetypes.StringValue, was: %T`, poeVersionAttribute))
	}

	powerCpldVersionAttribute, ok := attributes["power_cpld_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`power_cpld_version is missing from object`)

		return nil, diags
	}

	powerCpldVersionVal, ok := powerCpldVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`power_cpld_version expected to be basetypes.StringValue, was: %T`, powerCpldVersionAttribute))
	}

	psusAttribute, ok := attributes["psus"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`psus is missing from object`)

		return nil, diags
	}

	psusVal, ok := psusAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`psus expected to be basetypes.ListValue, was: %T`, psusAttribute))
	}

	reFpgaVersionAttribute, ok := attributes["re_fpga_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`re_fpga_version is missing from object`)

		return nil, diags
	}

	reFpgaVersionVal, ok := reFpgaVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`re_fpga_version expected to be basetypes.StringValue, was: %T`, reFpgaVersionAttribute))
	}

	recoveryVersionAttribute, ok := attributes["recovery_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`recovery_version is missing from object`)

		return nil, diags
	}

	recoveryVersionVal, ok := recoveryVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`recovery_version expected to be basetypes.StringValue, was: %T`, recoveryVersionAttribute))
	}

	serialAttribute, ok := attributes["serial"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`serial is missing from object`)

		return nil, diags
	}

	serialVal, ok := serialAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`serial expected to be basetypes.StringValue, was: %T`, serialAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return nil, diags
	}

	statusVal, ok := statusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be basetypes.StringValue, was: %T`, statusAttribute))
	}

	temperaturesAttribute, ok := attributes["temperatures"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`temperatures is missing from object`)

		return nil, diags
	}

	temperaturesVal, ok := temperaturesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`temperatures expected to be basetypes.ListValue, was: %T`, temperaturesAttribute))
	}

	tmcFpgaVersionAttribute, ok := attributes["tmc_fpga_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tmc_fpga_version is missing from object`)

		return nil, diags
	}

	tmcFpgaVersionVal, ok := tmcFpgaVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tmc_fpga_version expected to be basetypes.StringValue, was: %T`, tmcFpgaVersionAttribute))
	}

	ubootVersionAttribute, ok := attributes["uboot_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uboot_version is missing from object`)

		return nil, diags
	}

	ubootVersionVal, ok := ubootVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uboot_version expected to be basetypes.StringValue, was: %T`, ubootVersionAttribute))
	}

	uptimeAttribute, ok := attributes["uptime"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uptime is missing from object`)

		return nil, diags
	}

	uptimeVal, ok := uptimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uptime expected to be basetypes.Int64Value, was: %T`, uptimeAttribute))
	}

	vcLinksAttribute, ok := attributes["vc_links"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vc_links is missing from object`)

		return nil, diags
	}

	vcLinksVal, ok := vcLinksAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vc_links expected to be basetypes.ListValue, was: %T`, vcLinksAttribute))
	}

	vcModeAttribute, ok := attributes["vc_mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vc_mode is missing from object`)

		return nil, diags
	}

	vcModeVal, ok := vcModeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vc_mode expected to be basetypes.StringValue, was: %T`, vcModeAttribute))
	}

	vcRoleAttribute, ok := attributes["vc_role"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vc_role is missing from object`)

		return nil, diags
	}

	vcRoleVal, ok := vcRoleAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vc_role expected to be basetypes.StringValue, was: %T`, vcRoleAttribute))
	}

	vcStateAttribute, ok := attributes["vc_state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vc_state is missing from object`)

		return nil, diags
	}

	vcStateVal, ok := vcStateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vc_state expected to be basetypes.StringValue, was: %T`, vcStateAttribute))
	}

	versionAttribute, ok := attributes["version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`version is missing from object`)

		return nil, diags
	}

	versionVal, ok := versionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`version expected to be basetypes.StringValue, was: %T`, versionAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ModuleStatValue{
		BackupVersion:     backupVersionVal,
		BiosVersion:       biosVersionVal,
		CpldVersion:       cpldVersionVal,
		Errors:            errorsVal,
		Fans:              fansVal,
		FpcIdx:            fpcIdxVal,
		FpgaVersion:       fpgaVersionVal,
		LastSeen:          lastSeenVal,
		Model:             modelVal,
		OpticsCpldVersion: opticsCpldVersionVal,
		PendingVersion:    pendingVersionVal,
		Pics:              picsVal,
		Poe:               poeVal,
		PoeVersion:        poeVersionVal,
		PowerCpldVersion:  powerCpldVersionVal,
		Psus:              psusVal,
		ReFpgaVersion:     reFpgaVersionVal,
		RecoveryVersion:   recoveryVersionVal,
		Serial:            serialVal,
		Status:            statusVal,
		Temperatures:      temperaturesVal,
		TmcFpgaVersion:    tmcFpgaVersionVal,
		UbootVersion:      ubootVersionVal,
		Uptime:            uptimeVal,
		VcLinks:           vcLinksVal,
		VcMode:            vcModeVal,
		VcRole:            vcRoleVal,
		VcState:           vcStateVal,
		Version:           versionVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewModuleStatValueNull() ModuleStatValue {
	return ModuleStatValue{
		state: attr.ValueStateNull,
	}
}

func NewModuleStatValueUnknown() ModuleStatValue {
	return ModuleStatValue{
		state: attr.ValueStateUnknown,
	}
}

func NewModuleStatValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ModuleStatValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ModuleStatValue Attribute Value",
				"While creating a ModuleStatValue value, a missing attribute value was detected. "+
					"A ModuleStatValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ModuleStatValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ModuleStatValue Attribute Type",
				"While creating a ModuleStatValue value, an invalid attribute value was detected. "+
					"A ModuleStatValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ModuleStatValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ModuleStatValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ModuleStatValue Attribute Value",
				"While creating a ModuleStatValue value, an extra attribute value was detected. "+
					"A ModuleStatValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ModuleStatValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewModuleStatValueUnknown(), diags
	}

	backupVersionAttribute, ok := attributes["backup_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`backup_version is missing from object`)

		return NewModuleStatValueUnknown(), diags
	}

	backupVersionVal, ok := backupVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`backup_version expected to be basetypes.StringValue, was: %T`, backupVersionAttribute))
	}

	biosVersionAttribute, ok := attributes["bios_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bios_version is missing from object`)

		return NewModuleStatValueUnknown(), diags
	}

	biosVersionVal, ok := biosVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bios_version expected to be basetypes.StringValue, was: %T`, biosVersionAttribute))
	}

	cpldVersionAttribute, ok := attributes["cpld_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cpld_version is missing from object`)

		return NewModuleStatValueUnknown(), diags
	}

	cpldVersionVal, ok := cpldVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cpld_version expected to be basetypes.StringValue, was: %T`, cpldVersionAttribute))
	}

	errorsAttribute, ok := attributes["errors"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`errors is missing from object`)

		return NewModuleStatValueUnknown(), diags
	}

	errorsVal, ok := errorsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`errors expected to be basetypes.ListValue, was: %T`, errorsAttribute))
	}

	fansAttribute, ok := attributes["fans"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fans is missing from object`)

		return NewModuleStatValueUnknown(), diags
	}

	fansVal, ok := fansAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fans expected to be basetypes.ListValue, was: %T`, fansAttribute))
	}

	fpcIdxAttribute, ok := attributes["fpc_idx"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fpc_idx is missing from object`)

		return NewModuleStatValueUnknown(), diags
	}

	fpcIdxVal, ok := fpcIdxAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fpc_idx expected to be basetypes.Int64Value, was: %T`, fpcIdxAttribute))
	}

	fpgaVersionAttribute, ok := attributes["fpga_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fpga_version is missing from object`)

		return NewModuleStatValueUnknown(), diags
	}

	fpgaVersionVal, ok := fpgaVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fpga_version expected to be basetypes.StringValue, was: %T`, fpgaVersionAttribute))
	}

	lastSeenAttribute, ok := attributes["last_seen"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`last_seen is missing from object`)

		return NewModuleStatValueUnknown(), diags
	}

	lastSeenVal, ok := lastSeenAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`last_seen expected to be basetypes.NumberValue, was: %T`, lastSeenAttribute))
	}

	modelAttribute, ok := attributes["model"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`model is missing from object`)

		return NewModuleStatValueUnknown(), diags
	}

	modelVal, ok := modelAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`model expected to be basetypes.StringValue, was: %T`, modelAttribute))
	}

	opticsCpldVersionAttribute, ok := attributes["optics_cpld_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`optics_cpld_version is missing from object`)

		return NewModuleStatValueUnknown(), diags
	}

	opticsCpldVersionVal, ok := opticsCpldVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`optics_cpld_version expected to be basetypes.StringValue, was: %T`, opticsCpldVersionAttribute))
	}

	pendingVersionAttribute, ok := attributes["pending_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pending_version is missing from object`)

		return NewModuleStatValueUnknown(), diags
	}

	pendingVersionVal, ok := pendingVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pending_version expected to be basetypes.StringValue, was: %T`, pendingVersionAttribute))
	}

	picsAttribute, ok := attributes["pics"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pics is missing from object`)

		return NewModuleStatValueUnknown(), diags
	}

	picsVal, ok := picsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pics expected to be basetypes.ListValue, was: %T`, picsAttribute))
	}

	poeAttribute, ok := attributes["poe"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`poe is missing from object`)

		return NewModuleStatValueUnknown(), diags
	}

	poeVal, ok := poeAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`poe expected to be basetypes.ObjectValue, was: %T`, poeAttribute))
	}

	poeVersionAttribute, ok := attributes["poe_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`poe_version is missing from object`)

		return NewModuleStatValueUnknown(), diags
	}

	poeVersionVal, ok := poeVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`poe_version expected to be basetypes.StringValue, was: %T`, poeVersionAttribute))
	}

	powerCpldVersionAttribute, ok := attributes["power_cpld_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`power_cpld_version is missing from object`)

		return NewModuleStatValueUnknown(), diags
	}

	powerCpldVersionVal, ok := powerCpldVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`power_cpld_version expected to be basetypes.StringValue, was: %T`, powerCpldVersionAttribute))
	}

	psusAttribute, ok := attributes["psus"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`psus is missing from object`)

		return NewModuleStatValueUnknown(), diags
	}

	psusVal, ok := psusAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`psus expected to be basetypes.ListValue, was: %T`, psusAttribute))
	}

	reFpgaVersionAttribute, ok := attributes["re_fpga_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`re_fpga_version is missing from object`)

		return NewModuleStatValueUnknown(), diags
	}

	reFpgaVersionVal, ok := reFpgaVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`re_fpga_version expected to be basetypes.StringValue, was: %T`, reFpgaVersionAttribute))
	}

	recoveryVersionAttribute, ok := attributes["recovery_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`recovery_version is missing from object`)

		return NewModuleStatValueUnknown(), diags
	}

	recoveryVersionVal, ok := recoveryVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`recovery_version expected to be basetypes.StringValue, was: %T`, recoveryVersionAttribute))
	}

	serialAttribute, ok := attributes["serial"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`serial is missing from object`)

		return NewModuleStatValueUnknown(), diags
	}

	serialVal, ok := serialAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`serial expected to be basetypes.StringValue, was: %T`, serialAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return NewModuleStatValueUnknown(), diags
	}

	statusVal, ok := statusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be basetypes.StringValue, was: %T`, statusAttribute))
	}

	temperaturesAttribute, ok := attributes["temperatures"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`temperatures is missing from object`)

		return NewModuleStatValueUnknown(), diags
	}

	temperaturesVal, ok := temperaturesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`temperatures expected to be basetypes.ListValue, was: %T`, temperaturesAttribute))
	}

	tmcFpgaVersionAttribute, ok := attributes["tmc_fpga_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tmc_fpga_version is missing from object`)

		return NewModuleStatValueUnknown(), diags
	}

	tmcFpgaVersionVal, ok := tmcFpgaVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tmc_fpga_version expected to be basetypes.StringValue, was: %T`, tmcFpgaVersionAttribute))
	}

	ubootVersionAttribute, ok := attributes["uboot_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uboot_version is missing from object`)

		return NewModuleStatValueUnknown(), diags
	}

	ubootVersionVal, ok := ubootVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uboot_version expected to be basetypes.StringValue, was: %T`, ubootVersionAttribute))
	}

	uptimeAttribute, ok := attributes["uptime"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uptime is missing from object`)

		return NewModuleStatValueUnknown(), diags
	}

	uptimeVal, ok := uptimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uptime expected to be basetypes.Int64Value, was: %T`, uptimeAttribute))
	}

	vcLinksAttribute, ok := attributes["vc_links"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vc_links is missing from object`)

		return NewModuleStatValueUnknown(), diags
	}

	vcLinksVal, ok := vcLinksAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vc_links expected to be basetypes.ListValue, was: %T`, vcLinksAttribute))
	}

	vcModeAttribute, ok := attributes["vc_mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vc_mode is missing from object`)

		return NewModuleStatValueUnknown(), diags
	}

	vcModeVal, ok := vcModeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vc_mode expected to be basetypes.StringValue, was: %T`, vcModeAttribute))
	}

	vcRoleAttribute, ok := attributes["vc_role"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vc_role is missing from object`)

		return NewModuleStatValueUnknown(), diags
	}

	vcRoleVal, ok := vcRoleAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vc_role expected to be basetypes.StringValue, was: %T`, vcRoleAttribute))
	}

	vcStateAttribute, ok := attributes["vc_state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vc_state is missing from object`)

		return NewModuleStatValueUnknown(), diags
	}

	vcStateVal, ok := vcStateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vc_state expected to be basetypes.StringValue, was: %T`, vcStateAttribute))
	}

	versionAttribute, ok := attributes["version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`version is missing from object`)

		return NewModuleStatValueUnknown(), diags
	}

	versionVal, ok := versionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`version expected to be basetypes.StringValue, was: %T`, versionAttribute))
	}

	if diags.HasError() {
		return NewModuleStatValueUnknown(), diags
	}

	return ModuleStatValue{
		BackupVersion:     backupVersionVal,
		BiosVersion:       biosVersionVal,
		CpldVersion:       cpldVersionVal,
		Errors:            errorsVal,
		Fans:              fansVal,
		FpcIdx:            fpcIdxVal,
		FpgaVersion:       fpgaVersionVal,
		LastSeen:          lastSeenVal,
		Model:             modelVal,
		OpticsCpldVersion: opticsCpldVersionVal,
		PendingVersion:    pendingVersionVal,
		Pics:              picsVal,
		Poe:               poeVal,
		PoeVersion:        poeVersionVal,
		PowerCpldVersion:  powerCpldVersionVal,
		Psus:              psusVal,
		ReFpgaVersion:     reFpgaVersionVal,
		RecoveryVersion:   recoveryVersionVal,
		Serial:            serialVal,
		Status:            statusVal,
		Temperatures:      temperaturesVal,
		TmcFpgaVersion:    tmcFpgaVersionVal,
		UbootVersion:      ubootVersionVal,
		Uptime:            uptimeVal,
		VcLinks:           vcLinksVal,
		VcMode:            vcModeVal,
		VcRole:            vcRoleVal,
		VcState:           vcStateVal,
		Version:           versionVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewModuleStatValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ModuleStatValue {
	object, diags := NewModuleStatValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewModuleStatValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ModuleStatType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewModuleStatValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewModuleStatValueUnknown(), nil
	}

	if in.IsNull() {
		return NewModuleStatValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewModuleStatValueMust(ModuleStatValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ModuleStatType) ValueType(ctx context.Context) attr.Value {
	return ModuleStatValue{}
}

var _ basetypes.ObjectValuable = ModuleStatValue{}

type ModuleStatValue struct {
	BackupVersion     basetypes.StringValue `tfsdk:"backup_version"`
	BiosVersion       basetypes.StringValue `tfsdk:"bios_version"`
	CpldVersion       basetypes.StringValue `tfsdk:"cpld_version"`
	Errors            basetypes.ListValue   `tfsdk:"errors"`
	Fans              basetypes.ListValue   `tfsdk:"fans"`
	FpcIdx            basetypes.Int64Value  `tfsdk:"fpc_idx"`
	FpgaVersion       basetypes.StringValue `tfsdk:"fpga_version"`
	LastSeen          basetypes.NumberValue `tfsdk:"last_seen"`
	Model             basetypes.StringValue `tfsdk:"model"`
	OpticsCpldVersion basetypes.StringValue `tfsdk:"optics_cpld_version"`
	PendingVersion    basetypes.StringValue `tfsdk:"pending_version"`
	Pics              basetypes.ListValue   `tfsdk:"pics"`
	Poe               basetypes.ObjectValue `tfsdk:"poe"`
	PoeVersion        basetypes.StringValue `tfsdk:"poe_version"`
	PowerCpldVersion  basetypes.StringValue `tfsdk:"power_cpld_version"`
	Psus              basetypes.ListValue   `tfsdk:"psus"`
	ReFpgaVersion     basetypes.StringValue `tfsdk:"re_fpga_version"`
	RecoveryVersion   basetypes.StringValue `tfsdk:"recovery_version"`
	Serial            basetypes.StringValue `tfsdk:"serial"`
	Status            basetypes.StringValue `tfsdk:"status"`
	Temperatures      basetypes.ListValue   `tfsdk:"temperatures"`
	TmcFpgaVersion    basetypes.StringValue `tfsdk:"tmc_fpga_version"`
	UbootVersion      basetypes.StringValue `tfsdk:"uboot_version"`
	Uptime            basetypes.Int64Value  `tfsdk:"uptime"`
	VcLinks           basetypes.ListValue   `tfsdk:"vc_links"`
	VcMode            basetypes.StringValue `tfsdk:"vc_mode"`
	VcRole            basetypes.StringValue `tfsdk:"vc_role"`
	VcState           basetypes.StringValue `tfsdk:"vc_state"`
	Version           basetypes.StringValue `tfsdk:"version"`
	state             attr.ValueState
}

func (v ModuleStatValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 29)

	var val tftypes.Value
	var err error

	attrTypes["backup_version"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["bios_version"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["cpld_version"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["errors"] = basetypes.ListType{
		ElemType: ErrorsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["fans"] = basetypes.ListType{
		ElemType: FansValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["fpc_idx"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["fpga_version"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["last_seen"] = basetypes.NumberType{}.TerraformType(ctx)
	attrTypes["model"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["optics_cpld_version"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["pending_version"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["pics"] = basetypes.ListType{
		ElemType: PicsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["poe"] = basetypes.ObjectType{
		AttrTypes: PoeValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["poe_version"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["power_cpld_version"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["psus"] = basetypes.ListType{
		ElemType: PsusValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["re_fpga_version"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["recovery_version"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["serial"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["status"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["temperatures"] = basetypes.ListType{
		ElemType: TemperaturesValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["tmc_fpga_version"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["uboot_version"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["uptime"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["vc_links"] = basetypes.ListType{
		ElemType: VcLinksValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["vc_mode"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["vc_role"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["vc_state"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["version"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 29)

		val, err = v.BackupVersion.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["backup_version"] = val

		val, err = v.BiosVersion.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bios_version"] = val

		val, err = v.CpldVersion.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cpld_version"] = val

		val, err = v.Errors.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["errors"] = val

		val, err = v.Fans.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["fans"] = val

		val, err = v.FpcIdx.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["fpc_idx"] = val

		val, err = v.FpgaVersion.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["fpga_version"] = val

		val, err = v.LastSeen.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["last_seen"] = val

		val, err = v.Model.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["model"] = val

		val, err = v.OpticsCpldVersion.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["optics_cpld_version"] = val

		val, err = v.PendingVersion.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["pending_version"] = val

		val, err = v.Pics.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["pics"] = val

		val, err = v.Poe.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["poe"] = val

		val, err = v.PoeVersion.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["poe_version"] = val

		val, err = v.PowerCpldVersion.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["power_cpld_version"] = val

		val, err = v.Psus.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["psus"] = val

		val, err = v.ReFpgaVersion.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["re_fpga_version"] = val

		val, err = v.RecoveryVersion.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["recovery_version"] = val

		val, err = v.Serial.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["serial"] = val

		val, err = v.Status.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["status"] = val

		val, err = v.Temperatures.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["temperatures"] = val

		val, err = v.TmcFpgaVersion.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tmc_fpga_version"] = val

		val, err = v.UbootVersion.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["uboot_version"] = val

		val, err = v.Uptime.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["uptime"] = val

		val, err = v.VcLinks.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vc_links"] = val

		val, err = v.VcMode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vc_mode"] = val

		val, err = v.VcRole.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vc_role"] = val

		val, err = v.VcState.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vc_state"] = val

		val, err = v.Version.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["version"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ModuleStatValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ModuleStatValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ModuleStatValue) String() string {
	return "ModuleStatValue"
}

func (v ModuleStatValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	errors := types.ListValueMust(
		ErrorsType{
			basetypes.ObjectType{
				AttrTypes: ErrorsValue{}.AttributeTypes(ctx),
			},
		},
		v.Errors.Elements(),
	)

	if v.Errors.IsNull() {
		errors = types.ListNull(
			ErrorsType{
				basetypes.ObjectType{
					AttrTypes: ErrorsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Errors.IsUnknown() {
		errors = types.ListUnknown(
			ErrorsType{
				basetypes.ObjectType{
					AttrTypes: ErrorsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	fans := types.ListValueMust(
		FansType{
			basetypes.ObjectType{
				AttrTypes: FansValue{}.AttributeTypes(ctx),
			},
		},
		v.Fans.Elements(),
	)

	if v.Fans.IsNull() {
		fans = types.ListNull(
			FansType{
				basetypes.ObjectType{
					AttrTypes: FansValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Fans.IsUnknown() {
		fans = types.ListUnknown(
			FansType{
				basetypes.ObjectType{
					AttrTypes: FansValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	pics := types.ListValueMust(
		PicsType{
			basetypes.ObjectType{
				AttrTypes: PicsValue{}.AttributeTypes(ctx),
			},
		},
		v.Pics.Elements(),
	)

	if v.Pics.IsNull() {
		pics = types.ListNull(
			PicsType{
				basetypes.ObjectType{
					AttrTypes: PicsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Pics.IsUnknown() {
		pics = types.ListUnknown(
			PicsType{
				basetypes.ObjectType{
					AttrTypes: PicsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var poe basetypes.ObjectValue

	if v.Poe.IsNull() {
		poe = types.ObjectNull(
			PoeValue{}.AttributeTypes(ctx),
		)
	}

	if v.Poe.IsUnknown() {
		poe = types.ObjectUnknown(
			PoeValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Poe.IsNull() && !v.Poe.IsUnknown() {
		poe = types.ObjectValueMust(
			PoeValue{}.AttributeTypes(ctx),
			v.Poe.Attributes(),
		)
	}

	psus := types.ListValueMust(
		PsusType{
			basetypes.ObjectType{
				AttrTypes: PsusValue{}.AttributeTypes(ctx),
			},
		},
		v.Psus.Elements(),
	)

	if v.Psus.IsNull() {
		psus = types.ListNull(
			PsusType{
				basetypes.ObjectType{
					AttrTypes: PsusValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Psus.IsUnknown() {
		psus = types.ListUnknown(
			PsusType{
				basetypes.ObjectType{
					AttrTypes: PsusValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	temperatures := types.ListValueMust(
		TemperaturesType{
			basetypes.ObjectType{
				AttrTypes: TemperaturesValue{}.AttributeTypes(ctx),
			},
		},
		v.Temperatures.Elements(),
	)

	if v.Temperatures.IsNull() {
		temperatures = types.ListNull(
			TemperaturesType{
				basetypes.ObjectType{
					AttrTypes: TemperaturesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Temperatures.IsUnknown() {
		temperatures = types.ListUnknown(
			TemperaturesType{
				basetypes.ObjectType{
					AttrTypes: TemperaturesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	vcLinks := types.ListValueMust(
		VcLinksType{
			basetypes.ObjectType{
				AttrTypes: VcLinksValue{}.AttributeTypes(ctx),
			},
		},
		v.VcLinks.Elements(),
	)

	if v.VcLinks.IsNull() {
		vcLinks = types.ListNull(
			VcLinksType{
				basetypes.ObjectType{
					AttrTypes: VcLinksValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.VcLinks.IsUnknown() {
		vcLinks = types.ListUnknown(
			VcLinksType{
				basetypes.ObjectType{
					AttrTypes: VcLinksValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"backup_version": basetypes.StringType{},
		"bios_version":   basetypes.StringType{},
		"cpld_version":   basetypes.StringType{},
		"errors": basetypes.ListType{
			ElemType: ErrorsValue{}.Type(ctx),
		},
		"fans": basetypes.ListType{
			ElemType: FansValue{}.Type(ctx),
		},
		"fpc_idx":             basetypes.Int64Type{},
		"fpga_version":        basetypes.StringType{},
		"last_seen":           basetypes.NumberType{},
		"model":               basetypes.StringType{},
		"optics_cpld_version": basetypes.StringType{},
		"pending_version":     basetypes.StringType{},
		"pics": basetypes.ListType{
			ElemType: PicsValue{}.Type(ctx),
		},
		"poe": basetypes.ObjectType{
			AttrTypes: PoeValue{}.AttributeTypes(ctx),
		},
		"poe_version":        basetypes.StringType{},
		"power_cpld_version": basetypes.StringType{},
		"psus": basetypes.ListType{
			ElemType: PsusValue{}.Type(ctx),
		},
		"re_fpga_version":  basetypes.StringType{},
		"recovery_version": basetypes.StringType{},
		"serial":           basetypes.StringType{},
		"status":           basetypes.StringType{},
		"temperatures": basetypes.ListType{
			ElemType: TemperaturesValue{}.Type(ctx),
		},
		"tmc_fpga_version": basetypes.StringType{},
		"uboot_version":    basetypes.StringType{},
		"uptime":           basetypes.Int64Type{},
		"vc_links": basetypes.ListType{
			ElemType: VcLinksValue{}.Type(ctx),
		},
		"vc_mode":  basetypes.StringType{},
		"vc_role":  basetypes.StringType{},
		"vc_state": basetypes.StringType{},
		"version":  basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"backup_version":      v.BackupVersion,
			"bios_version":        v.BiosVersion,
			"cpld_version":        v.CpldVersion,
			"errors":              errors,
			"fans":                fans,
			"fpc_idx":             v.FpcIdx,
			"fpga_version":        v.FpgaVersion,
			"last_seen":           v.LastSeen,
			"model":               v.Model,
			"optics_cpld_version": v.OpticsCpldVersion,
			"pending_version":     v.PendingVersion,
			"pics":                pics,
			"poe":                 poe,
			"poe_version":         v.PoeVersion,
			"power_cpld_version":  v.PowerCpldVersion,
			"psus":                psus,
			"re_fpga_version":     v.ReFpgaVersion,
			"recovery_version":    v.RecoveryVersion,
			"serial":              v.Serial,
			"status":              v.Status,
			"temperatures":        temperatures,
			"tmc_fpga_version":    v.TmcFpgaVersion,
			"uboot_version":       v.UbootVersion,
			"uptime":              v.Uptime,
			"vc_links":            vcLinks,
			"vc_mode":             v.VcMode,
			"vc_role":             v.VcRole,
			"vc_state":            v.VcState,
			"version":             v.Version,
		})

	return objVal, diags
}

func (v ModuleStatValue) Equal(o attr.Value) bool {
	other, ok := o.(ModuleStatValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.BackupVersion.Equal(other.BackupVersion) {
		return false
	}

	if !v.BiosVersion.Equal(other.BiosVersion) {
		return false
	}

	if !v.CpldVersion.Equal(other.CpldVersion) {
		return false
	}

	if !v.Errors.Equal(other.Errors) {
		return false
	}

	if !v.Fans.Equal(other.Fans) {
		return false
	}

	if !v.FpcIdx.Equal(other.FpcIdx) {
		return false
	}

	if !v.FpgaVersion.Equal(other.FpgaVersion) {
		return false
	}

	if !v.LastSeen.Equal(other.LastSeen) {
		return false
	}

	if !v.Model.Equal(other.Model) {
		return false
	}

	if !v.OpticsCpldVersion.Equal(other.OpticsCpldVersion) {
		return false
	}

	if !v.PendingVersion.Equal(other.PendingVersion) {
		return false
	}

	if !v.Pics.Equal(other.Pics) {
		return false
	}

	if !v.Poe.Equal(other.Poe) {
		return false
	}

	if !v.PoeVersion.Equal(other.PoeVersion) {
		return false
	}

	if !v.PowerCpldVersion.Equal(other.PowerCpldVersion) {
		return false
	}

	if !v.Psus.Equal(other.Psus) {
		return false
	}

	if !v.ReFpgaVersion.Equal(other.ReFpgaVersion) {
		return false
	}

	if !v.RecoveryVersion.Equal(other.RecoveryVersion) {
		return false
	}

	if !v.Serial.Equal(other.Serial) {
		return false
	}

	if !v.Status.Equal(other.Status) {
		return false
	}

	if !v.Temperatures.Equal(other.Temperatures) {
		return false
	}

	if !v.TmcFpgaVersion.Equal(other.TmcFpgaVersion) {
		return false
	}

	if !v.UbootVersion.Equal(other.UbootVersion) {
		return false
	}

	if !v.Uptime.Equal(other.Uptime) {
		return false
	}

	if !v.VcLinks.Equal(other.VcLinks) {
		return false
	}

	if !v.VcMode.Equal(other.VcMode) {
		return false
	}

	if !v.VcRole.Equal(other.VcRole) {
		return false
	}

	if !v.VcState.Equal(other.VcState) {
		return false
	}

	if !v.Version.Equal(other.Version) {
		return false
	}

	return true
}

func (v ModuleStatValue) Type(ctx context.Context) attr.Type {
	return ModuleStatType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ModuleStatValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"backup_version": basetypes.StringType{},
		"bios_version":   basetypes.StringType{},
		"cpld_version":   basetypes.StringType{},
		"errors": basetypes.ListType{
			ElemType: ErrorsValue{}.Type(ctx),
		},
		"fans": basetypes.ListType{
			ElemType: FansValue{}.Type(ctx),
		},
		"fpc_idx":             basetypes.Int64Type{},
		"fpga_version":        basetypes.StringType{},
		"last_seen":           basetypes.NumberType{},
		"model":               basetypes.StringType{},
		"optics_cpld_version": basetypes.StringType{},
		"pending_version":     basetypes.StringType{},
		"pics": basetypes.ListType{
			ElemType: PicsValue{}.Type(ctx),
		},
		"poe": basetypes.ObjectType{
			AttrTypes: PoeValue{}.AttributeTypes(ctx),
		},
		"poe_version":        basetypes.StringType{},
		"power_cpld_version": basetypes.StringType{},
		"psus": basetypes.ListType{
			ElemType: PsusValue{}.Type(ctx),
		},
		"re_fpga_version":  basetypes.StringType{},
		"recovery_version": basetypes.StringType{},
		"serial":           basetypes.StringType{},
		"status":           basetypes.StringType{},
		"temperatures": basetypes.ListType{
			ElemType: TemperaturesValue{}.Type(ctx),
		},
		"tmc_fpga_version": basetypes.StringType{},
		"uboot_version":    basetypes.StringType{},
		"uptime":           basetypes.Int64Type{},
		"vc_links": basetypes.ListType{
			ElemType: VcLinksValue{}.Type(ctx),
		},
		"vc_mode":  basetypes.StringType{},
		"vc_role":  basetypes.StringType{},
		"vc_state": basetypes.StringType{},
		"version":  basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = ErrorsType{}

type ErrorsType struct {
	basetypes.ObjectType
}

func (t ErrorsType) Equal(o attr.Type) bool {
	other, ok := o.(ErrorsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ErrorsType) String() string {
	return "ErrorsType"
}

func (t ErrorsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	featureAttribute, ok := attributes["feature"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`feature is missing from object`)

		return nil, diags
	}

	featureVal, ok := featureAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`feature expected to be basetypes.StringValue, was: %T`, featureAttribute))
	}

	minimumVersionAttribute, ok := attributes["minimum_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`minimum_version is missing from object`)

		return nil, diags
	}

	minimumVersionVal, ok := minimumVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`minimum_version expected to be basetypes.StringValue, was: %T`, minimumVersionAttribute))
	}

	reasonAttribute, ok := attributes["reason"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`reason is missing from object`)

		return nil, diags
	}

	reasonVal, ok := reasonAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`reason expected to be basetypes.StringValue, was: %T`, reasonAttribute))
	}

	sinceAttribute, ok := attributes["since"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`since is missing from object`)

		return nil, diags
	}

	sinceVal, ok := sinceAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`since expected to be basetypes.Int64Value, was: %T`, sinceAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ErrorsValue{
		Feature:        featureVal,
		MinimumVersion: minimumVersionVal,
		Reason:         reasonVal,
		Since:          sinceVal,
		ErrorsType:     typeVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewErrorsValueNull() ErrorsValue {
	return ErrorsValue{
		state: attr.ValueStateNull,
	}
}

func NewErrorsValueUnknown() ErrorsValue {
	return ErrorsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewErrorsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ErrorsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ErrorsValue Attribute Value",
				"While creating a ErrorsValue value, a missing attribute value was detected. "+
					"A ErrorsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ErrorsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ErrorsValue Attribute Type",
				"While creating a ErrorsValue value, an invalid attribute value was detected. "+
					"A ErrorsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ErrorsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ErrorsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ErrorsValue Attribute Value",
				"While creating a ErrorsValue value, an extra attribute value was detected. "+
					"A ErrorsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ErrorsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewErrorsValueUnknown(), diags
	}

	featureAttribute, ok := attributes["feature"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`feature is missing from object`)

		return NewErrorsValueUnknown(), diags
	}

	featureVal, ok := featureAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`feature expected to be basetypes.StringValue, was: %T`, featureAttribute))
	}

	minimumVersionAttribute, ok := attributes["minimum_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`minimum_version is missing from object`)

		return NewErrorsValueUnknown(), diags
	}

	minimumVersionVal, ok := minimumVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`minimum_version expected to be basetypes.StringValue, was: %T`, minimumVersionAttribute))
	}

	reasonAttribute, ok := attributes["reason"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`reason is missing from object`)

		return NewErrorsValueUnknown(), diags
	}

	reasonVal, ok := reasonAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`reason expected to be basetypes.StringValue, was: %T`, reasonAttribute))
	}

	sinceAttribute, ok := attributes["since"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`since is missing from object`)

		return NewErrorsValueUnknown(), diags
	}

	sinceVal, ok := sinceAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`since expected to be basetypes.Int64Value, was: %T`, sinceAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewErrorsValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return NewErrorsValueUnknown(), diags
	}

	return ErrorsValue{
		Feature:        featureVal,
		MinimumVersion: minimumVersionVal,
		Reason:         reasonVal,
		Since:          sinceVal,
		ErrorsType:     typeVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewErrorsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ErrorsValue {
	object, diags := NewErrorsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewErrorsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ErrorsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewErrorsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewErrorsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewErrorsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewErrorsValueMust(ErrorsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ErrorsType) ValueType(ctx context.Context) attr.Value {
	return ErrorsValue{}
}

var _ basetypes.ObjectValuable = ErrorsValue{}

type ErrorsValue struct {
	Feature        basetypes.StringValue `tfsdk:"feature"`
	MinimumVersion basetypes.StringValue `tfsdk:"minimum_version"`
	Reason         basetypes.StringValue `tfsdk:"reason"`
	Since          basetypes.Int64Value  `tfsdk:"since"`
	ErrorsType     basetypes.StringValue `tfsdk:"type"`
	state          attr.ValueState
}

func (v ErrorsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["feature"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["minimum_version"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["reason"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["since"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.Feature.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["feature"] = val

		val, err = v.MinimumVersion.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["minimum_version"] = val

		val, err = v.Reason.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["reason"] = val

		val, err = v.Since.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["since"] = val

		val, err = v.ErrorsType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ErrorsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ErrorsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ErrorsValue) String() string {
	return "ErrorsValue"
}

func (v ErrorsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"feature":         basetypes.StringType{},
		"minimum_version": basetypes.StringType{},
		"reason":          basetypes.StringType{},
		"since":           basetypes.Int64Type{},
		"type":            basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"feature":         v.Feature,
			"minimum_version": v.MinimumVersion,
			"reason":          v.Reason,
			"since":           v.Since,
			"type":            v.ErrorsType,
		})

	return objVal, diags
}

func (v ErrorsValue) Equal(o attr.Value) bool {
	other, ok := o.(ErrorsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Feature.Equal(other.Feature) {
		return false
	}

	if !v.MinimumVersion.Equal(other.MinimumVersion) {
		return false
	}

	if !v.Reason.Equal(other.Reason) {
		return false
	}

	if !v.Since.Equal(other.Since) {
		return false
	}

	if !v.ErrorsType.Equal(other.ErrorsType) {
		return false
	}

	return true
}

func (v ErrorsValue) Type(ctx context.Context) attr.Type {
	return ErrorsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ErrorsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"feature":         basetypes.StringType{},
		"minimum_version": basetypes.StringType{},
		"reason":          basetypes.StringType{},
		"since":           basetypes.Int64Type{},
		"type":            basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = FansType{}

type FansType struct {
	basetypes.ObjectType
}

func (t FansType) Equal(o attr.Type) bool {
	other, ok := o.(FansType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t FansType) String() string {
	return "FansType"
}

func (t FansType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	airflowAttribute, ok := attributes["airflow"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`airflow is missing from object`)

		return nil, diags
	}

	airflowVal, ok := airflowAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`airflow expected to be basetypes.StringValue, was: %T`, airflowAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return nil, diags
	}

	statusVal, ok := statusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be basetypes.StringValue, was: %T`, statusAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return FansValue{
		Airflow: airflowVal,
		Name:    nameVal,
		Status:  statusVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewFansValueNull() FansValue {
	return FansValue{
		state: attr.ValueStateNull,
	}
}

func NewFansValueUnknown() FansValue {
	return FansValue{
		state: attr.ValueStateUnknown,
	}
}

func NewFansValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (FansValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing FansValue Attribute Value",
				"While creating a FansValue value, a missing attribute value was detected. "+
					"A FansValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("FansValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid FansValue Attribute Type",
				"While creating a FansValue value, an invalid attribute value was detected. "+
					"A FansValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("FansValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("FansValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra FansValue Attribute Value",
				"While creating a FansValue value, an extra attribute value was detected. "+
					"A FansValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra FansValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewFansValueUnknown(), diags
	}

	airflowAttribute, ok := attributes["airflow"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`airflow is missing from object`)

		return NewFansValueUnknown(), diags
	}

	airflowVal, ok := airflowAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`airflow expected to be basetypes.StringValue, was: %T`, airflowAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewFansValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return NewFansValueUnknown(), diags
	}

	statusVal, ok := statusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be basetypes.StringValue, was: %T`, statusAttribute))
	}

	if diags.HasError() {
		return NewFansValueUnknown(), diags
	}

	return FansValue{
		Airflow: airflowVal,
		Name:    nameVal,
		Status:  statusVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewFansValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) FansValue {
	object, diags := NewFansValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewFansValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t FansType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewFansValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewFansValueUnknown(), nil
	}

	if in.IsNull() {
		return NewFansValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewFansValueMust(FansValue{}.AttributeTypes(ctx), attributes), nil
}

func (t FansType) ValueType(ctx context.Context) attr.Value {
	return FansValue{}
}

var _ basetypes.ObjectValuable = FansValue{}

type FansValue struct {
	Airflow basetypes.StringValue `tfsdk:"airflow"`
	Name    basetypes.StringValue `tfsdk:"name"`
	Status  basetypes.StringValue `tfsdk:"status"`
	state   attr.ValueState
}

func (v FansValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["airflow"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["status"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Airflow.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["airflow"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Status.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["status"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v FansValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v FansValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v FansValue) String() string {
	return "FansValue"
}

func (v FansValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"airflow": basetypes.StringType{},
		"name":    basetypes.StringType{},
		"status":  basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"airflow": v.Airflow,
			"name":    v.Name,
			"status":  v.Status,
		})

	return objVal, diags
}

func (v FansValue) Equal(o attr.Value) bool {
	other, ok := o.(FansValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Airflow.Equal(other.Airflow) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Status.Equal(other.Status) {
		return false
	}

	return true
}

func (v FansValue) Type(ctx context.Context) attr.Type {
	return FansType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v FansValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"airflow": basetypes.StringType{},
		"name":    basetypes.StringType{},
		"status":  basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = PicsType{}

type PicsType struct {
	basetypes.ObjectType
}

func (t PicsType) Equal(o attr.Type) bool {
	other, ok := o.(PicsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PicsType) String() string {
	return "PicsType"
}

func (t PicsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	indexAttribute, ok := attributes["index"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`index is missing from object`)

		return nil, diags
	}

	indexVal, ok := indexAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`index expected to be basetypes.Int64Value, was: %T`, indexAttribute))
	}

	modelNumberAttribute, ok := attributes["model_number"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`model_number is missing from object`)

		return nil, diags
	}

	modelNumberVal, ok := modelNumberAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`model_number expected to be basetypes.StringValue, was: %T`, modelNumberAttribute))
	}

	portGroupsAttribute, ok := attributes["port_groups"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_groups is missing from object`)

		return nil, diags
	}

	portGroupsVal, ok := portGroupsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_groups expected to be basetypes.ListValue, was: %T`, portGroupsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PicsValue{
		Index:       indexVal,
		ModelNumber: modelNumberVal,
		PortGroups:  portGroupsVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewPicsValueNull() PicsValue {
	return PicsValue{
		state: attr.ValueStateNull,
	}
}

func NewPicsValueUnknown() PicsValue {
	return PicsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPicsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PicsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PicsValue Attribute Value",
				"While creating a PicsValue value, a missing attribute value was detected. "+
					"A PicsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PicsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PicsValue Attribute Type",
				"While creating a PicsValue value, an invalid attribute value was detected. "+
					"A PicsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PicsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PicsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PicsValue Attribute Value",
				"While creating a PicsValue value, an extra attribute value was detected. "+
					"A PicsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PicsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPicsValueUnknown(), diags
	}

	indexAttribute, ok := attributes["index"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`index is missing from object`)

		return NewPicsValueUnknown(), diags
	}

	indexVal, ok := indexAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`index expected to be basetypes.Int64Value, was: %T`, indexAttribute))
	}

	modelNumberAttribute, ok := attributes["model_number"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`model_number is missing from object`)

		return NewPicsValueUnknown(), diags
	}

	modelNumberVal, ok := modelNumberAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`model_number expected to be basetypes.StringValue, was: %T`, modelNumberAttribute))
	}

	portGroupsAttribute, ok := attributes["port_groups"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_groups is missing from object`)

		return NewPicsValueUnknown(), diags
	}

	portGroupsVal, ok := portGroupsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_groups expected to be basetypes.ListValue, was: %T`, portGroupsAttribute))
	}

	if diags.HasError() {
		return NewPicsValueUnknown(), diags
	}

	return PicsValue{
		Index:       indexVal,
		ModelNumber: modelNumberVal,
		PortGroups:  portGroupsVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewPicsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PicsValue {
	object, diags := NewPicsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPicsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PicsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPicsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPicsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPicsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPicsValueMust(PicsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PicsType) ValueType(ctx context.Context) attr.Value {
	return PicsValue{}
}

var _ basetypes.ObjectValuable = PicsValue{}

type PicsValue struct {
	Index       basetypes.Int64Value  `tfsdk:"index"`
	ModelNumber basetypes.StringValue `tfsdk:"model_number"`
	PortGroups  basetypes.ListValue   `tfsdk:"port_groups"`
	state       attr.ValueState
}

func (v PicsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["index"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["model_number"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["port_groups"] = basetypes.ListType{
		ElemType: PortGroupsValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Index.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["index"] = val

		val, err = v.ModelNumber.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["model_number"] = val

		val, err = v.PortGroups.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port_groups"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PicsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PicsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PicsValue) String() string {
	return "PicsValue"
}

func (v PicsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	portGroups := types.ListValueMust(
		PortGroupsType{
			basetypes.ObjectType{
				AttrTypes: PortGroupsValue{}.AttributeTypes(ctx),
			},
		},
		v.PortGroups.Elements(),
	)

	if v.PortGroups.IsNull() {
		portGroups = types.ListNull(
			PortGroupsType{
				basetypes.ObjectType{
					AttrTypes: PortGroupsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.PortGroups.IsUnknown() {
		portGroups = types.ListUnknown(
			PortGroupsType{
				basetypes.ObjectType{
					AttrTypes: PortGroupsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"index":        basetypes.Int64Type{},
		"model_number": basetypes.StringType{},
		"port_groups": basetypes.ListType{
			ElemType: PortGroupsValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"index":        v.Index,
			"model_number": v.ModelNumber,
			"port_groups":  portGroups,
		})

	return objVal, diags
}

func (v PicsValue) Equal(o attr.Value) bool {
	other, ok := o.(PicsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Index.Equal(other.Index) {
		return false
	}

	if !v.ModelNumber.Equal(other.ModelNumber) {
		return false
	}

	if !v.PortGroups.Equal(other.PortGroups) {
		return false
	}

	return true
}

func (v PicsValue) Type(ctx context.Context) attr.Type {
	return PicsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PicsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"index":        basetypes.Int64Type{},
		"model_number": basetypes.StringType{},
		"port_groups": basetypes.ListType{
			ElemType: PortGroupsValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = PortGroupsType{}

type PortGroupsType struct {
	basetypes.ObjectType
}

func (t PortGroupsType) Equal(o attr.Type) bool {
	other, ok := o.(PortGroupsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PortGroupsType) String() string {
	return "PortGroupsType"
}

func (t PortGroupsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	countAttribute, ok := attributes["count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`count is missing from object`)

		return nil, diags
	}

	countVal, ok := countAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`count expected to be basetypes.Int64Value, was: %T`, countAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PortGroupsValue{
		Count:          countVal,
		PortGroupsType: typeVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewPortGroupsValueNull() PortGroupsValue {
	return PortGroupsValue{
		state: attr.ValueStateNull,
	}
}

func NewPortGroupsValueUnknown() PortGroupsValue {
	return PortGroupsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPortGroupsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PortGroupsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PortGroupsValue Attribute Value",
				"While creating a PortGroupsValue value, a missing attribute value was detected. "+
					"A PortGroupsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PortGroupsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PortGroupsValue Attribute Type",
				"While creating a PortGroupsValue value, an invalid attribute value was detected. "+
					"A PortGroupsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PortGroupsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PortGroupsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PortGroupsValue Attribute Value",
				"While creating a PortGroupsValue value, an extra attribute value was detected. "+
					"A PortGroupsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PortGroupsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPortGroupsValueUnknown(), diags
	}

	countAttribute, ok := attributes["count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`count is missing from object`)

		return NewPortGroupsValueUnknown(), diags
	}

	countVal, ok := countAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`count expected to be basetypes.Int64Value, was: %T`, countAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewPortGroupsValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return NewPortGroupsValueUnknown(), diags
	}

	return PortGroupsValue{
		Count:          countVal,
		PortGroupsType: typeVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewPortGroupsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PortGroupsValue {
	object, diags := NewPortGroupsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPortGroupsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PortGroupsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPortGroupsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPortGroupsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPortGroupsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPortGroupsValueMust(PortGroupsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PortGroupsType) ValueType(ctx context.Context) attr.Value {
	return PortGroupsValue{}
}

var _ basetypes.ObjectValuable = PortGroupsValue{}

type PortGroupsValue struct {
	Count          basetypes.Int64Value  `tfsdk:"count"`
	PortGroupsType basetypes.StringValue `tfsdk:"type"`
	state          attr.ValueState
}

func (v PortGroupsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["count"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Count.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["count"] = val

		val, err = v.PortGroupsType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PortGroupsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PortGroupsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PortGroupsValue) String() string {
	return "PortGroupsValue"
}

func (v PortGroupsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"count": basetypes.Int64Type{},
		"type":  basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"count": v.Count,
			"type":  v.PortGroupsType,
		})

	return objVal, diags
}

func (v PortGroupsValue) Equal(o attr.Value) bool {
	other, ok := o.(PortGroupsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Count.Equal(other.Count) {
		return false
	}

	if !v.PortGroupsType.Equal(other.PortGroupsType) {
		return false
	}

	return true
}

func (v PortGroupsValue) Type(ctx context.Context) attr.Type {
	return PortGroupsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PortGroupsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"count": basetypes.Int64Type{},
		"type":  basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = PoeType{}

type PoeType struct {
	basetypes.ObjectType
}

func (t PoeType) Equal(o attr.Type) bool {
	other, ok := o.(PoeType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PoeType) String() string {
	return "PoeType"
}

func (t PoeType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	maxPowerAttribute, ok := attributes["max_power"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_power is missing from object`)

		return nil, diags
	}

	maxPowerVal, ok := maxPowerAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_power expected to be basetypes.NumberValue, was: %T`, maxPowerAttribute))
	}

	powerDrawAttribute, ok := attributes["power_draw"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`power_draw is missing from object`)

		return nil, diags
	}

	powerDrawVal, ok := powerDrawAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`power_draw expected to be basetypes.NumberValue, was: %T`, powerDrawAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PoeValue{
		MaxPower:  maxPowerVal,
		PowerDraw: powerDrawVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewPoeValueNull() PoeValue {
	return PoeValue{
		state: attr.ValueStateNull,
	}
}

func NewPoeValueUnknown() PoeValue {
	return PoeValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPoeValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PoeValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PoeValue Attribute Value",
				"While creating a PoeValue value, a missing attribute value was detected. "+
					"A PoeValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PoeValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PoeValue Attribute Type",
				"While creating a PoeValue value, an invalid attribute value was detected. "+
					"A PoeValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PoeValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PoeValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PoeValue Attribute Value",
				"While creating a PoeValue value, an extra attribute value was detected. "+
					"A PoeValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PoeValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPoeValueUnknown(), diags
	}

	maxPowerAttribute, ok := attributes["max_power"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_power is missing from object`)

		return NewPoeValueUnknown(), diags
	}

	maxPowerVal, ok := maxPowerAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_power expected to be basetypes.NumberValue, was: %T`, maxPowerAttribute))
	}

	powerDrawAttribute, ok := attributes["power_draw"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`power_draw is missing from object`)

		return NewPoeValueUnknown(), diags
	}

	powerDrawVal, ok := powerDrawAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`power_draw expected to be basetypes.NumberValue, was: %T`, powerDrawAttribute))
	}

	if diags.HasError() {
		return NewPoeValueUnknown(), diags
	}

	return PoeValue{
		MaxPower:  maxPowerVal,
		PowerDraw: powerDrawVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewPoeValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PoeValue {
	object, diags := NewPoeValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPoeValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PoeType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPoeValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPoeValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPoeValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPoeValueMust(PoeValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PoeType) ValueType(ctx context.Context) attr.Value {
	return PoeValue{}
}

var _ basetypes.ObjectValuable = PoeValue{}

type PoeValue struct {
	MaxPower  basetypes.NumberValue `tfsdk:"max_power"`
	PowerDraw basetypes.NumberValue `tfsdk:"power_draw"`
	state     attr.ValueState
}

func (v PoeValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["max_power"] = basetypes.NumberType{}.TerraformType(ctx)
	attrTypes["power_draw"] = basetypes.NumberType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.MaxPower.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_power"] = val

		val, err = v.PowerDraw.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["power_draw"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PoeValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PoeValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PoeValue) String() string {
	return "PoeValue"
}

func (v PoeValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"max_power":  basetypes.NumberType{},
		"power_draw": basetypes.NumberType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"max_power":  v.MaxPower,
			"power_draw": v.PowerDraw,
		})

	return objVal, diags
}

func (v PoeValue) Equal(o attr.Value) bool {
	other, ok := o.(PoeValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.MaxPower.Equal(other.MaxPower) {
		return false
	}

	if !v.PowerDraw.Equal(other.PowerDraw) {
		return false
	}

	return true
}

func (v PoeValue) Type(ctx context.Context) attr.Type {
	return PoeType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PoeValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"max_power":  basetypes.NumberType{},
		"power_draw": basetypes.NumberType{},
	}
}

var _ basetypes.ObjectTypable = PsusType{}

type PsusType struct {
	basetypes.ObjectType
}

func (t PsusType) Equal(o attr.Type) bool {
	other, ok := o.(PsusType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PsusType) String() string {
	return "PsusType"
}

func (t PsusType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return nil, diags
	}

	statusVal, ok := statusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be basetypes.StringValue, was: %T`, statusAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PsusValue{
		Name:   nameVal,
		Status: statusVal,
		state:  attr.ValueStateKnown,
	}, diags
}

func NewPsusValueNull() PsusValue {
	return PsusValue{
		state: attr.ValueStateNull,
	}
}

func NewPsusValueUnknown() PsusValue {
	return PsusValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPsusValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PsusValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PsusValue Attribute Value",
				"While creating a PsusValue value, a missing attribute value was detected. "+
					"A PsusValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PsusValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PsusValue Attribute Type",
				"While creating a PsusValue value, an invalid attribute value was detected. "+
					"A PsusValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PsusValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PsusValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PsusValue Attribute Value",
				"While creating a PsusValue value, an extra attribute value was detected. "+
					"A PsusValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PsusValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPsusValueUnknown(), diags
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewPsusValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return NewPsusValueUnknown(), diags
	}

	statusVal, ok := statusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be basetypes.StringValue, was: %T`, statusAttribute))
	}

	if diags.HasError() {
		return NewPsusValueUnknown(), diags
	}

	return PsusValue{
		Name:   nameVal,
		Status: statusVal,
		state:  attr.ValueStateKnown,
	}, diags
}

func NewPsusValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PsusValue {
	object, diags := NewPsusValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPsusValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PsusType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPsusValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPsusValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPsusValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPsusValueMust(PsusValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PsusType) ValueType(ctx context.Context) attr.Value {
	return PsusValue{}
}

var _ basetypes.ObjectValuable = PsusValue{}

type PsusValue struct {
	Name   basetypes.StringValue `tfsdk:"name"`
	Status basetypes.StringValue `tfsdk:"status"`
	state  attr.ValueState
}

func (v PsusValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["status"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Status.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["status"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PsusValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PsusValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PsusValue) String() string {
	return "PsusValue"
}

func (v PsusValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"name":   basetypes.StringType{},
		"status": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"name":   v.Name,
			"status": v.Status,
		})

	return objVal, diags
}

func (v PsusValue) Equal(o attr.Value) bool {
	other, ok := o.(PsusValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Status.Equal(other.Status) {
		return false
	}

	return true
}

func (v PsusValue) Type(ctx context.Context) attr.Type {
	return PsusType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PsusValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"name":   basetypes.StringType{},
		"status": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = TemperaturesType{}

type TemperaturesType struct {
	basetypes.ObjectType
}

func (t TemperaturesType) Equal(o attr.Type) bool {
	other, ok := o.(TemperaturesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t TemperaturesType) String() string {
	return "TemperaturesType"
}

func (t TemperaturesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	celsiusAttribute, ok := attributes["celsius"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`celsius is missing from object`)

		return nil, diags
	}

	celsiusVal, ok := celsiusAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`celsius expected to be basetypes.NumberValue, was: %T`, celsiusAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return nil, diags
	}

	statusVal, ok := statusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be basetypes.StringValue, was: %T`, statusAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return TemperaturesValue{
		Celsius: celsiusVal,
		Name:    nameVal,
		Status:  statusVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewTemperaturesValueNull() TemperaturesValue {
	return TemperaturesValue{
		state: attr.ValueStateNull,
	}
}

func NewTemperaturesValueUnknown() TemperaturesValue {
	return TemperaturesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewTemperaturesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (TemperaturesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing TemperaturesValue Attribute Value",
				"While creating a TemperaturesValue value, a missing attribute value was detected. "+
					"A TemperaturesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TemperaturesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid TemperaturesValue Attribute Type",
				"While creating a TemperaturesValue value, an invalid attribute value was detected. "+
					"A TemperaturesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TemperaturesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("TemperaturesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra TemperaturesValue Attribute Value",
				"While creating a TemperaturesValue value, an extra attribute value was detected. "+
					"A TemperaturesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra TemperaturesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewTemperaturesValueUnknown(), diags
	}

	celsiusAttribute, ok := attributes["celsius"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`celsius is missing from object`)

		return NewTemperaturesValueUnknown(), diags
	}

	celsiusVal, ok := celsiusAttribute.(basetypes.NumberValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`celsius expected to be basetypes.NumberValue, was: %T`, celsiusAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewTemperaturesValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return NewTemperaturesValueUnknown(), diags
	}

	statusVal, ok := statusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be basetypes.StringValue, was: %T`, statusAttribute))
	}

	if diags.HasError() {
		return NewTemperaturesValueUnknown(), diags
	}

	return TemperaturesValue{
		Celsius: celsiusVal,
		Name:    nameVal,
		Status:  statusVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewTemperaturesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) TemperaturesValue {
	object, diags := NewTemperaturesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewTemperaturesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t TemperaturesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewTemperaturesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewTemperaturesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewTemperaturesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewTemperaturesValueMust(TemperaturesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t TemperaturesType) ValueType(ctx context.Context) attr.Value {
	return TemperaturesValue{}
}

var _ basetypes.ObjectValuable = TemperaturesValue{}

type TemperaturesValue struct {
	Celsius basetypes.NumberValue `tfsdk:"celsius"`
	Name    basetypes.StringValue `tfsdk:"name"`
	Status  basetypes.StringValue `tfsdk:"status"`
	state   attr.ValueState
}

func (v TemperaturesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["celsius"] = basetypes.NumberType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["status"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Celsius.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["celsius"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Status.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["status"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v TemperaturesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v TemperaturesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v TemperaturesValue) String() string {
	return "TemperaturesValue"
}

func (v TemperaturesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"celsius": basetypes.NumberType{},
		"name":    basetypes.StringType{},
		"status":  basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"celsius": v.Celsius,
			"name":    v.Name,
			"status":  v.Status,
		})

	return objVal, diags
}

func (v TemperaturesValue) Equal(o attr.Value) bool {
	other, ok := o.(TemperaturesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Celsius.Equal(other.Celsius) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Status.Equal(other.Status) {
		return false
	}

	return true
}

func (v TemperaturesValue) Type(ctx context.Context) attr.Type {
	return TemperaturesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v TemperaturesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"celsius": basetypes.NumberType{},
		"name":    basetypes.StringType{},
		"status":  basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = VcLinksType{}

type VcLinksType struct {
	basetypes.ObjectType
}

func (t VcLinksType) Equal(o attr.Type) bool {
	other, ok := o.(VcLinksType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t VcLinksType) String() string {
	return "VcLinksType"
}

func (t VcLinksType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	neighborModuleIdxAttribute, ok := attributes["neighbor_module_idx"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`neighbor_module_idx is missing from object`)

		return nil, diags
	}

	neighborModuleIdxVal, ok := neighborModuleIdxAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`neighbor_module_idx expected to be basetypes.Int64Value, was: %T`, neighborModuleIdxAttribute))
	}

	neighborPortIdAttribute, ok := attributes["neighbor_port_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`neighbor_port_id is missing from object`)

		return nil, diags
	}

	neighborPortIdVal, ok := neighborPortIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`neighbor_port_id expected to be basetypes.StringValue, was: %T`, neighborPortIdAttribute))
	}

	portIdAttribute, ok := attributes["port_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_id is missing from object`)

		return nil, diags
	}

	portIdVal, ok := portIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_id expected to be basetypes.StringValue, was: %T`, portIdAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return VcLinksValue{
		NeighborModuleIdx: neighborModuleIdxVal,
		NeighborPortId:    neighborPortIdVal,
		PortId:            portIdVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewVcLinksValueNull() VcLinksValue {
	return VcLinksValue{
		state: attr.ValueStateNull,
	}
}

func NewVcLinksValueUnknown() VcLinksValue {
	return VcLinksValue{
		state: attr.ValueStateUnknown,
	}
}

func NewVcLinksValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (VcLinksValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing VcLinksValue Attribute Value",
				"While creating a VcLinksValue value, a missing attribute value was detected. "+
					"A VcLinksValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VcLinksValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid VcLinksValue Attribute Type",
				"While creating a VcLinksValue value, an invalid attribute value was detected. "+
					"A VcLinksValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VcLinksValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("VcLinksValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra VcLinksValue Attribute Value",
				"While creating a VcLinksValue value, an extra attribute value was detected. "+
					"A VcLinksValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra VcLinksValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewVcLinksValueUnknown(), diags
	}

	neighborModuleIdxAttribute, ok := attributes["neighbor_module_idx"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`neighbor_module_idx is missing from object`)

		return NewVcLinksValueUnknown(), diags
	}

	neighborModuleIdxVal, ok := neighborModuleIdxAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`neighbor_module_idx expected to be basetypes.Int64Value, was: %T`, neighborModuleIdxAttribute))
	}

	neighborPortIdAttribute, ok := attributes["neighbor_port_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`neighbor_port_id is missing from object`)

		return NewVcLinksValueUnknown(), diags
	}

	neighborPortIdVal, ok := neighborPortIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`neighbor_port_id expected to be basetypes.StringValue, was: %T`, neighborPortIdAttribute))
	}

	portIdAttribute, ok := attributes["port_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_id is missing from object`)

		return NewVcLinksValueUnknown(), diags
	}

	portIdVal, ok := portIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_id expected to be basetypes.StringValue, was: %T`, portIdAttribute))
	}

	if diags.HasError() {
		return NewVcLinksValueUnknown(), diags
	}

	return VcLinksValue{
		NeighborModuleIdx: neighborModuleIdxVal,
		NeighborPortId:    neighborPortIdVal,
		PortId:            portIdVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewVcLinksValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) VcLinksValue {
	object, diags := NewVcLinksValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewVcLinksValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t VcLinksType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewVcLinksValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewVcLinksValueUnknown(), nil
	}

	if in.IsNull() {
		return NewVcLinksValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewVcLinksValueMust(VcLinksValue{}.AttributeTypes(ctx), attributes), nil
}

func (t VcLinksType) ValueType(ctx context.Context) attr.Value {
	return VcLinksValue{}
}

var _ basetypes.ObjectValuable = VcLinksValue{}

type VcLinksValue struct {
	NeighborModuleIdx basetypes.Int64Value  `tfsdk:"neighbor_module_idx"`
	NeighborPortId    basetypes.StringValue `tfsdk:"neighbor_port_id"`
	PortId            basetypes.StringValue `tfsdk:"port_id"`
	state             attr.ValueState
}

func (v VcLinksValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["neighbor_module_idx"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["neighbor_port_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["port_id"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.NeighborModuleIdx.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["neighbor_module_idx"] = val

		val, err = v.NeighborPortId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["neighbor_port_id"] = val

		val, err = v.PortId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port_id"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v VcLinksValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v VcLinksValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v VcLinksValue) String() string {
	return "VcLinksValue"
}

func (v VcLinksValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"neighbor_module_idx": basetypes.Int64Type{},
		"neighbor_port_id":    basetypes.StringType{},
		"port_id":             basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"neighbor_module_idx": v.NeighborModuleIdx,
			"neighbor_port_id":    v.NeighborPortId,
			"port_id":             v.PortId,
		})

	return objVal, diags
}

func (v VcLinksValue) Equal(o attr.Value) bool {
	other, ok := o.(VcLinksValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.NeighborModuleIdx.Equal(other.NeighborModuleIdx) {
		return false
	}

	if !v.NeighborPortId.Equal(other.NeighborPortId) {
		return false
	}

	if !v.PortId.Equal(other.PortId) {
		return false
	}

	return true
}

func (v VcLinksValue) Type(ctx context.Context) attr.Type {
	return VcLinksType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v VcLinksValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"neighbor_module_idx": basetypes.Int64Type{},
		"neighbor_port_id":    basetypes.StringType{},
		"port_id":             basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = RouteSummaryStatsType{}

type RouteSummaryStatsType struct {
	basetypes.ObjectType
}

func (t RouteSummaryStatsType) Equal(o attr.Type) bool {
	other, ok := o.(RouteSummaryStatsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t RouteSummaryStatsType) String() string {
	return "RouteSummaryStatsType"
}

func (t RouteSummaryStatsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	fibRoutesAttribute, ok := attributes["fib_routes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fib_routes is missing from object`)

		return nil, diags
	}

	fibRoutesVal, ok := fibRoutesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fib_routes expected to be basetypes.Int64Value, was: %T`, fibRoutesAttribute))
	}

	maxUnicastRoutesSupportedAttribute, ok := attributes["max_unicast_routes_supported"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_unicast_routes_supported is missing from object`)

		return nil, diags
	}

	maxUnicastRoutesSupportedVal, ok := maxUnicastRoutesSupportedAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_unicast_routes_supported expected to be basetypes.Int64Value, was: %T`, maxUnicastRoutesSupportedAttribute))
	}

	ribRoutesAttribute, ok := attributes["rib_routes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rib_routes is missing from object`)

		return nil, diags
	}

	ribRoutesVal, ok := ribRoutesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rib_routes expected to be basetypes.Int64Value, was: %T`, ribRoutesAttribute))
	}

	totalRoutesAttribute, ok := attributes["total_routes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`total_routes is missing from object`)

		return nil, diags
	}

	totalRoutesVal, ok := totalRoutesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`total_routes expected to be basetypes.Int64Value, was: %T`, totalRoutesAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return RouteSummaryStatsValue{
		FibRoutes:                 fibRoutesVal,
		MaxUnicastRoutesSupported: maxUnicastRoutesSupportedVal,
		RibRoutes:                 ribRoutesVal,
		TotalRoutes:               totalRoutesVal,
		state:                     attr.ValueStateKnown,
	}, diags
}

func NewRouteSummaryStatsValueNull() RouteSummaryStatsValue {
	return RouteSummaryStatsValue{
		state: attr.ValueStateNull,
	}
}

func NewRouteSummaryStatsValueUnknown() RouteSummaryStatsValue {
	return RouteSummaryStatsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewRouteSummaryStatsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (RouteSummaryStatsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing RouteSummaryStatsValue Attribute Value",
				"While creating a RouteSummaryStatsValue value, a missing attribute value was detected. "+
					"A RouteSummaryStatsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RouteSummaryStatsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid RouteSummaryStatsValue Attribute Type",
				"While creating a RouteSummaryStatsValue value, an invalid attribute value was detected. "+
					"A RouteSummaryStatsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RouteSummaryStatsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("RouteSummaryStatsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra RouteSummaryStatsValue Attribute Value",
				"While creating a RouteSummaryStatsValue value, an extra attribute value was detected. "+
					"A RouteSummaryStatsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra RouteSummaryStatsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewRouteSummaryStatsValueUnknown(), diags
	}

	fibRoutesAttribute, ok := attributes["fib_routes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fib_routes is missing from object`)

		return NewRouteSummaryStatsValueUnknown(), diags
	}

	fibRoutesVal, ok := fibRoutesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fib_routes expected to be basetypes.Int64Value, was: %T`, fibRoutesAttribute))
	}

	maxUnicastRoutesSupportedAttribute, ok := attributes["max_unicast_routes_supported"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_unicast_routes_supported is missing from object`)

		return NewRouteSummaryStatsValueUnknown(), diags
	}

	maxUnicastRoutesSupportedVal, ok := maxUnicastRoutesSupportedAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_unicast_routes_supported expected to be basetypes.Int64Value, was: %T`, maxUnicastRoutesSupportedAttribute))
	}

	ribRoutesAttribute, ok := attributes["rib_routes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rib_routes is missing from object`)

		return NewRouteSummaryStatsValueUnknown(), diags
	}

	ribRoutesVal, ok := ribRoutesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rib_routes expected to be basetypes.Int64Value, was: %T`, ribRoutesAttribute))
	}

	totalRoutesAttribute, ok := attributes["total_routes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`total_routes is missing from object`)

		return NewRouteSummaryStatsValueUnknown(), diags
	}

	totalRoutesVal, ok := totalRoutesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`total_routes expected to be basetypes.Int64Value, was: %T`, totalRoutesAttribute))
	}

	if diags.HasError() {
		return NewRouteSummaryStatsValueUnknown(), diags
	}

	return RouteSummaryStatsValue{
		FibRoutes:                 fibRoutesVal,
		MaxUnicastRoutesSupported: maxUnicastRoutesSupportedVal,
		RibRoutes:                 ribRoutesVal,
		TotalRoutes:               totalRoutesVal,
		state:                     attr.ValueStateKnown,
	}, diags
}

func NewRouteSummaryStatsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) RouteSummaryStatsValue {
	object, diags := NewRouteSummaryStatsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewRouteSummaryStatsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t RouteSummaryStatsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewRouteSummaryStatsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewRouteSummaryStatsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewRouteSummaryStatsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewRouteSummaryStatsValueMust(RouteSummaryStatsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t RouteSummaryStatsType) ValueType(ctx context.Context) attr.Value {
	return RouteSummaryStatsValue{}
}

var _ basetypes.ObjectValuable = RouteSummaryStatsValue{}

type RouteSummaryStatsValue struct {
	FibRoutes                 basetypes.Int64Value `tfsdk:"fib_routes"`
	MaxUnicastRoutesSupported basetypes.Int64Value `tfsdk:"max_unicast_routes_supported"`
	RibRoutes                 basetypes.Int64Value `tfsdk:"rib_routes"`
	TotalRoutes               basetypes.Int64Value `tfsdk:"total_routes"`
	state                     attr.ValueState
}

func (v RouteSummaryStatsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["fib_routes"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["max_unicast_routes_supported"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["rib_routes"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["total_routes"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.FibRoutes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["fib_routes"] = val

		val, err = v.MaxUnicastRoutesSupported.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_unicast_routes_supported"] = val

		val, err = v.RibRoutes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["rib_routes"] = val

		val, err = v.TotalRoutes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["total_routes"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v RouteSummaryStatsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v RouteSummaryStatsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v RouteSummaryStatsValue) String() string {
	return "RouteSummaryStatsValue"
}

func (v RouteSummaryStatsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"fib_routes":                   basetypes.Int64Type{},
		"max_unicast_routes_supported": basetypes.Int64Type{},
		"rib_routes":                   basetypes.Int64Type{},
		"total_routes":                 basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"fib_routes":                   v.FibRoutes,
			"max_unicast_routes_supported": v.MaxUnicastRoutesSupported,
			"rib_routes":                   v.RibRoutes,
			"total_routes":                 v.TotalRoutes,
		})

	return objVal, diags
}

func (v RouteSummaryStatsValue) Equal(o attr.Value) bool {
	other, ok := o.(RouteSummaryStatsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.FibRoutes.Equal(other.FibRoutes) {
		return false
	}

	if !v.MaxUnicastRoutesSupported.Equal(other.MaxUnicastRoutesSupported) {
		return false
	}

	if !v.RibRoutes.Equal(other.RibRoutes) {
		return false
	}

	if !v.TotalRoutes.Equal(other.TotalRoutes) {
		return false
	}

	return true
}

func (v RouteSummaryStatsValue) Type(ctx context.Context) attr.Type {
	return RouteSummaryStatsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v RouteSummaryStatsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"fib_routes":                   basetypes.Int64Type{},
		"max_unicast_routes_supported": basetypes.Int64Type{},
		"rib_routes":                   basetypes.Int64Type{},
		"total_routes":                 basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = ServiceStatType{}

type ServiceStatType struct {
	basetypes.ObjectType
}

func (t ServiceStatType) Equal(o attr.Type) bool {
	other, ok := o.(ServiceStatType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ServiceStatType) String() string {
	return "ServiceStatType"
}

func (t ServiceStatType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	ashVersionAttribute, ok := attributes["ash_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ash_version is missing from object`)

		return nil, diags
	}

	ashVersionVal, ok := ashVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ash_version expected to be basetypes.StringValue, was: %T`, ashVersionAttribute))
	}

	ciaVersionAttribute, ok := attributes["cia_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cia_version is missing from object`)

		return nil, diags
	}

	ciaVersionVal, ok := ciaVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cia_version expected to be basetypes.StringValue, was: %T`, ciaVersionAttribute))
	}

	emberVersionAttribute, ok := attributes["ember_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ember_version is missing from object`)

		return nil, diags
	}

	emberVersionVal, ok := emberVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ember_version expected to be basetypes.StringValue, was: %T`, emberVersionAttribute))
	}

	ipsecClientVersionAttribute, ok := attributes["ipsec_client_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipsec_client_version is missing from object`)

		return nil, diags
	}

	ipsecClientVersionVal, ok := ipsecClientVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipsec_client_version expected to be basetypes.StringValue, was: %T`, ipsecClientVersionAttribute))
	}

	mistAgentVersionAttribute, ok := attributes["mist_agent_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mist_agent_version is missing from object`)

		return nil, diags
	}

	mistAgentVersionVal, ok := mistAgentVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mist_agent_version expected to be basetypes.StringValue, was: %T`, mistAgentVersionAttribute))
	}

	packageVersionAttribute, ok := attributes["package_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`package_version is missing from object`)

		return nil, diags
	}

	packageVersionVal, ok := packageVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`package_version expected to be basetypes.StringValue, was: %T`, packageVersionAttribute))
	}

	testingToolsVersionAttribute, ok := attributes["testing_tools_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`testing_tools_version is missing from object`)

		return nil, diags
	}

	testingToolsVersionVal, ok := testingToolsVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`testing_tools_version expected to be basetypes.StringValue, was: %T`, testingToolsVersionAttribute))
	}

	wheeljackVersionAttribute, ok := attributes["wheeljack_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wheeljack_version is missing from object`)

		return nil, diags
	}

	wheeljackVersionVal, ok := wheeljackVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wheeljack_version expected to be basetypes.StringValue, was: %T`, wheeljackVersionAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ServiceStatValue{
		AshVersion:          ashVersionVal,
		CiaVersion:          ciaVersionVal,
		EmberVersion:        emberVersionVal,
		IpsecClientVersion:  ipsecClientVersionVal,
		MistAgentVersion:    mistAgentVersionVal,
		PackageVersion:      packageVersionVal,
		TestingToolsVersion: testingToolsVersionVal,
		WheeljackVersion:    wheeljackVersionVal,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewServiceStatValueNull() ServiceStatValue {
	return ServiceStatValue{
		state: attr.ValueStateNull,
	}
}

func NewServiceStatValueUnknown() ServiceStatValue {
	return ServiceStatValue{
		state: attr.ValueStateUnknown,
	}
}

func NewServiceStatValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ServiceStatValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ServiceStatValue Attribute Value",
				"While creating a ServiceStatValue value, a missing attribute value was detected. "+
					"A ServiceStatValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ServiceStatValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ServiceStatValue Attribute Type",
				"While creating a ServiceStatValue value, an invalid attribute value was detected. "+
					"A ServiceStatValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ServiceStatValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ServiceStatValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ServiceStatValue Attribute Value",
				"While creating a ServiceStatValue value, an extra attribute value was detected. "+
					"A ServiceStatValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ServiceStatValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewServiceStatValueUnknown(), diags
	}

	ashVersionAttribute, ok := attributes["ash_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ash_version is missing from object`)

		return NewServiceStatValueUnknown(), diags
	}

	ashVersionVal, ok := ashVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ash_version expected to be basetypes.StringValue, was: %T`, ashVersionAttribute))
	}

	ciaVersionAttribute, ok := attributes["cia_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cia_version is missing from object`)

		return NewServiceStatValueUnknown(), diags
	}

	ciaVersionVal, ok := ciaVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cia_version expected to be basetypes.StringValue, was: %T`, ciaVersionAttribute))
	}

	emberVersionAttribute, ok := attributes["ember_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ember_version is missing from object`)

		return NewServiceStatValueUnknown(), diags
	}

	emberVersionVal, ok := emberVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ember_version expected to be basetypes.StringValue, was: %T`, emberVersionAttribute))
	}

	ipsecClientVersionAttribute, ok := attributes["ipsec_client_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipsec_client_version is missing from object`)

		return NewServiceStatValueUnknown(), diags
	}

	ipsecClientVersionVal, ok := ipsecClientVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipsec_client_version expected to be basetypes.StringValue, was: %T`, ipsecClientVersionAttribute))
	}

	mistAgentVersionAttribute, ok := attributes["mist_agent_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mist_agent_version is missing from object`)

		return NewServiceStatValueUnknown(), diags
	}

	mistAgentVersionVal, ok := mistAgentVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mist_agent_version expected to be basetypes.StringValue, was: %T`, mistAgentVersionAttribute))
	}

	packageVersionAttribute, ok := attributes["package_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`package_version is missing from object`)

		return NewServiceStatValueUnknown(), diags
	}

	packageVersionVal, ok := packageVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`package_version expected to be basetypes.StringValue, was: %T`, packageVersionAttribute))
	}

	testingToolsVersionAttribute, ok := attributes["testing_tools_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`testing_tools_version is missing from object`)

		return NewServiceStatValueUnknown(), diags
	}

	testingToolsVersionVal, ok := testingToolsVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`testing_tools_version expected to be basetypes.StringValue, was: %T`, testingToolsVersionAttribute))
	}

	wheeljackVersionAttribute, ok := attributes["wheeljack_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wheeljack_version is missing from object`)

		return NewServiceStatValueUnknown(), diags
	}

	wheeljackVersionVal, ok := wheeljackVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wheeljack_version expected to be basetypes.StringValue, was: %T`, wheeljackVersionAttribute))
	}

	if diags.HasError() {
		return NewServiceStatValueUnknown(), diags
	}

	return ServiceStatValue{
		AshVersion:          ashVersionVal,
		CiaVersion:          ciaVersionVal,
		EmberVersion:        emberVersionVal,
		IpsecClientVersion:  ipsecClientVersionVal,
		MistAgentVersion:    mistAgentVersionVal,
		PackageVersion:      packageVersionVal,
		TestingToolsVersion: testingToolsVersionVal,
		WheeljackVersion:    wheeljackVersionVal,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewServiceStatValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ServiceStatValue {
	object, diags := NewServiceStatValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewServiceStatValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ServiceStatType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewServiceStatValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewServiceStatValueUnknown(), nil
	}

	if in.IsNull() {
		return NewServiceStatValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewServiceStatValueMust(ServiceStatValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ServiceStatType) ValueType(ctx context.Context) attr.Value {
	return ServiceStatValue{}
}

var _ basetypes.ObjectValuable = ServiceStatValue{}

type ServiceStatValue struct {
	AshVersion          basetypes.StringValue `tfsdk:"ash_version"`
	CiaVersion          basetypes.StringValue `tfsdk:"cia_version"`
	EmberVersion        basetypes.StringValue `tfsdk:"ember_version"`
	IpsecClientVersion  basetypes.StringValue `tfsdk:"ipsec_client_version"`
	MistAgentVersion    basetypes.StringValue `tfsdk:"mist_agent_version"`
	PackageVersion      basetypes.StringValue `tfsdk:"package_version"`
	TestingToolsVersion basetypes.StringValue `tfsdk:"testing_tools_version"`
	WheeljackVersion    basetypes.StringValue `tfsdk:"wheeljack_version"`
	state               attr.ValueState
}

func (v ServiceStatValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 8)

	var val tftypes.Value
	var err error

	attrTypes["ash_version"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["cia_version"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ember_version"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ipsec_client_version"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["mist_agent_version"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["package_version"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["testing_tools_version"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["wheeljack_version"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 8)

		val, err = v.AshVersion.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ash_version"] = val

		val, err = v.CiaVersion.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cia_version"] = val

		val, err = v.EmberVersion.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ember_version"] = val

		val, err = v.IpsecClientVersion.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ipsec_client_version"] = val

		val, err = v.MistAgentVersion.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mist_agent_version"] = val

		val, err = v.PackageVersion.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["package_version"] = val

		val, err = v.TestingToolsVersion.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["testing_tools_version"] = val

		val, err = v.WheeljackVersion.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["wheeljack_version"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ServiceStatValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ServiceStatValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ServiceStatValue) String() string {
	return "ServiceStatValue"
}

func (v ServiceStatValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"ash_version":           basetypes.StringType{},
		"cia_version":           basetypes.StringType{},
		"ember_version":         basetypes.StringType{},
		"ipsec_client_version":  basetypes.StringType{},
		"mist_agent_version":    basetypes.StringType{},
		"package_version":       basetypes.StringType{},
		"testing_tools_version": basetypes.StringType{},
		"wheeljack_version":     basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"ash_version":           v.AshVersion,
			"cia_version":           v.CiaVersion,
			"ember_version":         v.EmberVersion,
			"ipsec_client_version":  v.IpsecClientVersion,
			"mist_agent_version":    v.MistAgentVersion,
			"package_version":       v.PackageVersion,
			"testing_tools_version": v.TestingToolsVersion,
			"wheeljack_version":     v.WheeljackVersion,
		})

	return objVal, diags
}

func (v ServiceStatValue) Equal(o attr.Value) bool {
	other, ok := o.(ServiceStatValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AshVersion.Equal(other.AshVersion) {
		return false
	}

	if !v.CiaVersion.Equal(other.CiaVersion) {
		return false
	}

	if !v.EmberVersion.Equal(other.EmberVersion) {
		return false
	}

	if !v.IpsecClientVersion.Equal(other.IpsecClientVersion) {
		return false
	}

	if !v.MistAgentVersion.Equal(other.MistAgentVersion) {
		return false
	}

	if !v.PackageVersion.Equal(other.PackageVersion) {
		return false
	}

	if !v.TestingToolsVersion.Equal(other.TestingToolsVersion) {
		return false
	}

	if !v.WheeljackVersion.Equal(other.WheeljackVersion) {
		return false
	}

	return true
}

func (v ServiceStatValue) Type(ctx context.Context) attr.Type {
	return ServiceStatType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ServiceStatValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"ash_version":           basetypes.StringType{},
		"cia_version":           basetypes.StringType{},
		"ember_version":         basetypes.StringType{},
		"ipsec_client_version":  basetypes.StringType{},
		"mist_agent_version":    basetypes.StringType{},
		"package_version":       basetypes.StringType{},
		"testing_tools_version": basetypes.StringType{},
		"wheeljack_version":     basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = VcSetupInfoType{}

type VcSetupInfoType struct {
	basetypes.ObjectType
}

func (t VcSetupInfoType) Equal(o attr.Type) bool {
	other, ok := o.(VcSetupInfoType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t VcSetupInfoType) String() string {
	return "VcSetupInfoType"
}

func (t VcSetupInfoType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	configTypeAttribute, ok := attributes["config_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`config_type is missing from object`)

		return nil, diags
	}

	configTypeVal, ok := configTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`config_type expected to be basetypes.StringValue, was: %T`, configTypeAttribute))
	}

	errMissingDevIdFpcAttribute, ok := attributes["err_missing_dev_id_fpc"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`err_missing_dev_id_fpc is missing from object`)

		return nil, diags
	}

	errMissingDevIdFpcVal, ok := errMissingDevIdFpcAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`err_missing_dev_id_fpc expected to be basetypes.BoolValue, was: %T`, errMissingDevIdFpcAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return VcSetupInfoValue{
		ConfigType:         configTypeVal,
		ErrMissingDevIdFpc: errMissingDevIdFpcVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewVcSetupInfoValueNull() VcSetupInfoValue {
	return VcSetupInfoValue{
		state: attr.ValueStateNull,
	}
}

func NewVcSetupInfoValueUnknown() VcSetupInfoValue {
	return VcSetupInfoValue{
		state: attr.ValueStateUnknown,
	}
}

func NewVcSetupInfoValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (VcSetupInfoValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing VcSetupInfoValue Attribute Value",
				"While creating a VcSetupInfoValue value, a missing attribute value was detected. "+
					"A VcSetupInfoValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VcSetupInfoValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid VcSetupInfoValue Attribute Type",
				"While creating a VcSetupInfoValue value, an invalid attribute value was detected. "+
					"A VcSetupInfoValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VcSetupInfoValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("VcSetupInfoValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra VcSetupInfoValue Attribute Value",
				"While creating a VcSetupInfoValue value, an extra attribute value was detected. "+
					"A VcSetupInfoValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra VcSetupInfoValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewVcSetupInfoValueUnknown(), diags
	}

	configTypeAttribute, ok := attributes["config_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`config_type is missing from object`)

		return NewVcSetupInfoValueUnknown(), diags
	}

	configTypeVal, ok := configTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`config_type expected to be basetypes.StringValue, was: %T`, configTypeAttribute))
	}

	errMissingDevIdFpcAttribute, ok := attributes["err_missing_dev_id_fpc"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`err_missing_dev_id_fpc is missing from object`)

		return NewVcSetupInfoValueUnknown(), diags
	}

	errMissingDevIdFpcVal, ok := errMissingDevIdFpcAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`err_missing_dev_id_fpc expected to be basetypes.BoolValue, was: %T`, errMissingDevIdFpcAttribute))
	}

	if diags.HasError() {
		return NewVcSetupInfoValueUnknown(), diags
	}

	return VcSetupInfoValue{
		ConfigType:         configTypeVal,
		ErrMissingDevIdFpc: errMissingDevIdFpcVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewVcSetupInfoValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) VcSetupInfoValue {
	object, diags := NewVcSetupInfoValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewVcSetupInfoValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t VcSetupInfoType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewVcSetupInfoValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewVcSetupInfoValueUnknown(), nil
	}

	if in.IsNull() {
		return NewVcSetupInfoValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewVcSetupInfoValueMust(VcSetupInfoValue{}.AttributeTypes(ctx), attributes), nil
}

func (t VcSetupInfoType) ValueType(ctx context.Context) attr.Value {
	return VcSetupInfoValue{}
}

var _ basetypes.ObjectValuable = VcSetupInfoValue{}

type VcSetupInfoValue struct {
	ConfigType         basetypes.StringValue `tfsdk:"config_type"`
	ErrMissingDevIdFpc basetypes.BoolValue   `tfsdk:"err_missing_dev_id_fpc"`
	state              attr.ValueState
}

func (v VcSetupInfoValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["config_type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["err_missing_dev_id_fpc"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.ConfigType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["config_type"] = val

		val, err = v.ErrMissingDevIdFpc.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["err_missing_dev_id_fpc"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v VcSetupInfoValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v VcSetupInfoValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v VcSetupInfoValue) String() string {
	return "VcSetupInfoValue"
}

func (v VcSetupInfoValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"config_type":            basetypes.StringType{},
		"err_missing_dev_id_fpc": basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"config_type":            v.ConfigType,
			"err_missing_dev_id_fpc": v.ErrMissingDevIdFpc,
		})

	return objVal, diags
}

func (v VcSetupInfoValue) Equal(o attr.Value) bool {
	other, ok := o.(VcSetupInfoValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.ConfigType.Equal(other.ConfigType) {
		return false
	}

	if !v.ErrMissingDevIdFpc.Equal(other.ErrMissingDevIdFpc) {
		return false
	}

	return true
}

func (v VcSetupInfoValue) Type(ctx context.Context) attr.Type {
	return VcSetupInfoType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v VcSetupInfoValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"config_type":            basetypes.StringType{},
		"err_missing_dev_id_fpc": basetypes.BoolType{},
	}
}
