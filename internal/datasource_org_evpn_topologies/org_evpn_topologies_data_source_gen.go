// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package datasource_org_evpn_topologies

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework-validators/mapvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/datasource/schema"
)

func OrgEvpnTopologiesDataSourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"org_evpn_topologies": schema.SetNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"created_time": schema.Float64Attribute{
							Computed:            true,
							Description:         "When the object has been created, in epoch",
							MarkdownDescription: "When the object has been created, in epoch",
						},
						"evpn_options": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"auto_loopback_subnet": schema.StringAttribute{
									Computed:            true,
									Description:         "Optional, for dhcp_relay, unique loopback IPs are required for ERB or IPClos where we can set option-82 server_id-overrides",
									MarkdownDescription: "Optional, for dhcp_relay, unique loopback IPs are required for ERB or IPClos where we can set option-82 server_id-overrides",
								},
								"auto_loopback_subnet6": schema.StringAttribute{
									Computed:            true,
									Description:         "Optional, for dhcp_relay, unique loopback IPs are required for ERB or IPClos where we can set option-82 server_id-overrides",
									MarkdownDescription: "Optional, for dhcp_relay, unique loopback IPs are required for ERB or IPClos where we can set option-82 server_id-overrides",
								},
								"auto_router_id_subnet": schema.StringAttribute{
									Computed:            true,
									Description:         "Optional, this generates router_id automatically, if specified, `router_id_prefix` is ignored",
									MarkdownDescription: "Optional, this generates router_id automatically, if specified, `router_id_prefix` is ignored",
								},
								"auto_router_id_subnet6": schema.StringAttribute{
									Computed:            true,
									Description:         "Optional, this generates router_id automatically, if specified, `router_id_prefix` is ignored",
									MarkdownDescription: "Optional, this generates router_id automatically, if specified, `router_id_prefix` is ignored",
								},
								"core_as_border": schema.BoolAttribute{
									Computed:            true,
									Description:         "Optional, for ERB or CLOS, you can either use esilag to upstream routers or to also be the virtual-gateway. When `routed_at` != `core`, whether to do virtual-gateway at core as well",
									MarkdownDescription: "Optional, for ERB or CLOS, you can either use esilag to upstream routers or to also be the virtual-gateway. When `routed_at` != `core`, whether to do virtual-gateway at core as well",
								},
								"overlay": schema.SingleNestedAttribute{
									Attributes: map[string]schema.Attribute{
										"as": schema.Int64Attribute{
											Computed:            true,
											Description:         "Overlay BGP Local AS Number",
											MarkdownDescription: "Overlay BGP Local AS Number",
										},
									},
									CustomType: OverlayType{
										ObjectType: types.ObjectType{
											AttrTypes: OverlayValue{}.AttributeTypes(ctx),
										},
									},
									Computed: true,
								},
								"per_vlan_vga_v4_mac": schema.BoolAttribute{
									Computed:            true,
									Description:         "Only for by Core-Distribution architecture when `evpn_options.routed_at`==`core`. By default, JUNOS uses 00-00-5e-00-01-01 as the virtual-gateway-address's v4_mac. If enabled, 00-00-5e-00-0X-YY will be used (where XX=vlan_id/256, YY=vlan_id%256)",
									MarkdownDescription: "Only for by Core-Distribution architecture when `evpn_options.routed_at`==`core`. By default, JUNOS uses 00-00-5e-00-01-01 as the virtual-gateway-address's v4_mac. If enabled, 00-00-5e-00-0X-YY will be used (where XX=vlan_id/256, YY=vlan_id%256)",
								},
								"per_vlan_vga_v6_mac": schema.BoolAttribute{
									Computed:            true,
									Description:         "Only for by Core-Distribution architecture when `evpn_options.routed_at`==`core`. By default, JUNOS uses 00-00-5e-00-02-01 as the virtual-gateway-address's v6_mac. If enabled, 00-00-5e-00-1X-YY will be used (where XX=vlan_id/256, YY=vlan_id%256)",
									MarkdownDescription: "Only for by Core-Distribution architecture when `evpn_options.routed_at`==`core`. By default, JUNOS uses 00-00-5e-00-02-01 as the virtual-gateway-address's v6_mac. If enabled, 00-00-5e-00-1X-YY will be used (where XX=vlan_id/256, YY=vlan_id%256)",
								},
								"routed_at": schema.StringAttribute{
									Computed:            true,
									Description:         "optional, where virtual-gateway should reside. enum: `core`, `distribution`, `edge`",
									MarkdownDescription: "optional, where virtual-gateway should reside. enum: `core`, `distribution`, `edge`",
								},
								"underlay": schema.SingleNestedAttribute{
									Attributes: map[string]schema.Attribute{
										"as_base": schema.Int64Attribute{
											Computed:            true,
											Description:         "Underlay BGP Base AS Number",
											MarkdownDescription: "Underlay BGP Base AS Number",
										},
										"routed_id_prefix": schema.StringAttribute{
											Computed: true,
										},
										"subnet": schema.StringAttribute{
											Computed:            true,
											Description:         "Underlay subnet, by default, `10.255.240.0/20`, or `fd31:5700::/64` for ipv6",
											MarkdownDescription: "Underlay subnet, by default, `10.255.240.0/20`, or `fd31:5700::/64` for ipv6",
										},
										"use_ipv6": schema.BoolAttribute{
											Computed:            true,
											Description:         "If v6 is desired for underlay",
											MarkdownDescription: "If v6 is desired for underlay",
										},
									},
									CustomType: UnderlayType{
										ObjectType: types.ObjectType{
											AttrTypes: UnderlayValue{}.AttributeTypes(ctx),
										},
									},
									Computed: true,
								},
								"vs_instances": schema.MapNestedAttribute{
									NestedObject: schema.NestedAttributeObject{
										Attributes: map[string]schema.Attribute{
											"networks": schema.ListAttribute{
												ElementType: types.StringType,
												Computed:    true,
											},
										},
										CustomType: VsInstancesType{
											ObjectType: types.ObjectType{
												AttrTypes: VsInstancesValue{}.AttributeTypes(ctx),
											},
										},
									},
									Computed:            true,
									Description:         "Optional, for EX9200 only to segregate virtual-switches",
									MarkdownDescription: "Optional, for EX9200 only to segregate virtual-switches",
									Validators: []validator.Map{
										mapvalidator.SizeAtLeast(1),
									},
								},
							},
							CustomType: EvpnOptionsType{
								ObjectType: types.ObjectType{
									AttrTypes: EvpnOptionsValue{}.AttributeTypes(ctx),
								},
							},
							Computed:            true,
							Description:         "EVPN Options",
							MarkdownDescription: "EVPN Options",
						},
						"id": schema.StringAttribute{
							Computed:            true,
							Description:         "Unique ID of the object instance in the Mist Organization",
							MarkdownDescription: "Unique ID of the object instance in the Mist Organization",
						},
						"modified_time": schema.Float64Attribute{
							Computed:            true,
							Description:         "When the object has been modified for the last time, in epoch",
							MarkdownDescription: "When the object has been modified for the last time, in epoch",
						},
						"name": schema.StringAttribute{
							Computed: true,
						},
						"org_id": schema.StringAttribute{
							Computed: true,
						},
						"pod_names": schema.MapAttribute{
							ElementType:         types.StringType,
							Computed:            true,
							Description:         "Property key is the pod number",
							MarkdownDescription: "Property key is the pod number",
						},
					},
					CustomType: OrgEvpnTopologiesType{
						ObjectType: types.ObjectType{
							AttrTypes: OrgEvpnTopologiesValue{}.AttributeTypes(ctx),
						},
					},
				},
				Computed: true,
			},
			"org_id": schema.StringAttribute{
				Required: true,
			},
		},
	}
}

type OrgEvpnTopologiesModel struct {
	OrgEvpnTopologies types.Set    `tfsdk:"org_evpn_topologies"`
	OrgId             types.String `tfsdk:"org_id"`
}

var _ basetypes.ObjectTypable = OrgEvpnTopologiesType{}

type OrgEvpnTopologiesType struct {
	basetypes.ObjectType
}

func (t OrgEvpnTopologiesType) Equal(o attr.Type) bool {
	other, ok := o.(OrgEvpnTopologiesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t OrgEvpnTopologiesType) String() string {
	return "OrgEvpnTopologiesType"
}

func (t OrgEvpnTopologiesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	createdTimeAttribute, ok := attributes["created_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_time is missing from object`)

		return nil, diags
	}

	createdTimeVal, ok := createdTimeAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_time expected to be basetypes.Float64Value, was: %T`, createdTimeAttribute))
	}

	evpnOptionsAttribute, ok := attributes["evpn_options"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`evpn_options is missing from object`)

		return nil, diags
	}

	evpnOptionsVal, ok := evpnOptionsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`evpn_options expected to be basetypes.ObjectValue, was: %T`, evpnOptionsAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	modifiedTimeAttribute, ok := attributes["modified_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`modified_time is missing from object`)

		return nil, diags
	}

	modifiedTimeVal, ok := modifiedTimeAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`modified_time expected to be basetypes.Float64Value, was: %T`, modifiedTimeAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	orgIdAttribute, ok := attributes["org_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`org_id is missing from object`)

		return nil, diags
	}

	orgIdVal, ok := orgIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`org_id expected to be basetypes.StringValue, was: %T`, orgIdAttribute))
	}

	podNamesAttribute, ok := attributes["pod_names"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pod_names is missing from object`)

		return nil, diags
	}

	podNamesVal, ok := podNamesAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pod_names expected to be basetypes.MapValue, was: %T`, podNamesAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return OrgEvpnTopologiesValue{
		CreatedTime:  createdTimeVal,
		EvpnOptions:  evpnOptionsVal,
		Id:           idVal,
		ModifiedTime: modifiedTimeVal,
		Name:         nameVal,
		OrgId:        orgIdVal,
		PodNames:     podNamesVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewOrgEvpnTopologiesValueNull() OrgEvpnTopologiesValue {
	return OrgEvpnTopologiesValue{
		state: attr.ValueStateNull,
	}
}

func NewOrgEvpnTopologiesValueUnknown() OrgEvpnTopologiesValue {
	return OrgEvpnTopologiesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewOrgEvpnTopologiesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (OrgEvpnTopologiesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing OrgEvpnTopologiesValue Attribute Value",
				"While creating a OrgEvpnTopologiesValue value, a missing attribute value was detected. "+
					"A OrgEvpnTopologiesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OrgEvpnTopologiesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid OrgEvpnTopologiesValue Attribute Type",
				"While creating a OrgEvpnTopologiesValue value, an invalid attribute value was detected. "+
					"A OrgEvpnTopologiesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OrgEvpnTopologiesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("OrgEvpnTopologiesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra OrgEvpnTopologiesValue Attribute Value",
				"While creating a OrgEvpnTopologiesValue value, an extra attribute value was detected. "+
					"A OrgEvpnTopologiesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra OrgEvpnTopologiesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewOrgEvpnTopologiesValueUnknown(), diags
	}

	createdTimeAttribute, ok := attributes["created_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_time is missing from object`)

		return NewOrgEvpnTopologiesValueUnknown(), diags
	}

	createdTimeVal, ok := createdTimeAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_time expected to be basetypes.Float64Value, was: %T`, createdTimeAttribute))
	}

	evpnOptionsAttribute, ok := attributes["evpn_options"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`evpn_options is missing from object`)

		return NewOrgEvpnTopologiesValueUnknown(), diags
	}

	evpnOptionsVal, ok := evpnOptionsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`evpn_options expected to be basetypes.ObjectValue, was: %T`, evpnOptionsAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewOrgEvpnTopologiesValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	modifiedTimeAttribute, ok := attributes["modified_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`modified_time is missing from object`)

		return NewOrgEvpnTopologiesValueUnknown(), diags
	}

	modifiedTimeVal, ok := modifiedTimeAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`modified_time expected to be basetypes.Float64Value, was: %T`, modifiedTimeAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewOrgEvpnTopologiesValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	orgIdAttribute, ok := attributes["org_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`org_id is missing from object`)

		return NewOrgEvpnTopologiesValueUnknown(), diags
	}

	orgIdVal, ok := orgIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`org_id expected to be basetypes.StringValue, was: %T`, orgIdAttribute))
	}

	podNamesAttribute, ok := attributes["pod_names"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pod_names is missing from object`)

		return NewOrgEvpnTopologiesValueUnknown(), diags
	}

	podNamesVal, ok := podNamesAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pod_names expected to be basetypes.MapValue, was: %T`, podNamesAttribute))
	}

	if diags.HasError() {
		return NewOrgEvpnTopologiesValueUnknown(), diags
	}

	return OrgEvpnTopologiesValue{
		CreatedTime:  createdTimeVal,
		EvpnOptions:  evpnOptionsVal,
		Id:           idVal,
		ModifiedTime: modifiedTimeVal,
		Name:         nameVal,
		OrgId:        orgIdVal,
		PodNames:     podNamesVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewOrgEvpnTopologiesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) OrgEvpnTopologiesValue {
	object, diags := NewOrgEvpnTopologiesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewOrgEvpnTopologiesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t OrgEvpnTopologiesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewOrgEvpnTopologiesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewOrgEvpnTopologiesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewOrgEvpnTopologiesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewOrgEvpnTopologiesValueMust(OrgEvpnTopologiesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t OrgEvpnTopologiesType) ValueType(ctx context.Context) attr.Value {
	return OrgEvpnTopologiesValue{}
}

var _ basetypes.ObjectValuable = OrgEvpnTopologiesValue{}

type OrgEvpnTopologiesValue struct {
	CreatedTime  basetypes.Float64Value `tfsdk:"created_time"`
	EvpnOptions  basetypes.ObjectValue  `tfsdk:"evpn_options"`
	Id           basetypes.StringValue  `tfsdk:"id"`
	ModifiedTime basetypes.Float64Value `tfsdk:"modified_time"`
	Name         basetypes.StringValue  `tfsdk:"name"`
	OrgId        basetypes.StringValue  `tfsdk:"org_id"`
	PodNames     basetypes.MapValue     `tfsdk:"pod_names"`
	state        attr.ValueState
}

func (v OrgEvpnTopologiesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 7)

	var val tftypes.Value
	var err error

	attrTypes["created_time"] = basetypes.Float64Type{}.TerraformType(ctx)
	attrTypes["evpn_options"] = basetypes.ObjectType{
		AttrTypes: EvpnOptionsValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["modified_time"] = basetypes.Float64Type{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["org_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["pod_names"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 7)

		val, err = v.CreatedTime.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["created_time"] = val

		val, err = v.EvpnOptions.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["evpn_options"] = val

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.ModifiedTime.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["modified_time"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.OrgId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["org_id"] = val

		val, err = v.PodNames.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["pod_names"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v OrgEvpnTopologiesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v OrgEvpnTopologiesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v OrgEvpnTopologiesValue) String() string {
	return "OrgEvpnTopologiesValue"
}

func (v OrgEvpnTopologiesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var evpnOptions basetypes.ObjectValue

	if v.EvpnOptions.IsNull() {
		evpnOptions = types.ObjectNull(
			EvpnOptionsValue{}.AttributeTypes(ctx),
		)
	}

	if v.EvpnOptions.IsUnknown() {
		evpnOptions = types.ObjectUnknown(
			EvpnOptionsValue{}.AttributeTypes(ctx),
		)
	}

	if !v.EvpnOptions.IsNull() && !v.EvpnOptions.IsUnknown() {
		evpnOptions = types.ObjectValueMust(
			EvpnOptionsValue{}.AttributeTypes(ctx),
			v.EvpnOptions.Attributes(),
		)
	}

	podNamesVal, d := types.MapValue(types.StringType, v.PodNames.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"created_time": basetypes.Float64Type{},
			"evpn_options": basetypes.ObjectType{
				AttrTypes: EvpnOptionsValue{}.AttributeTypes(ctx),
			},
			"id":            basetypes.StringType{},
			"modified_time": basetypes.Float64Type{},
			"name":          basetypes.StringType{},
			"org_id":        basetypes.StringType{},
			"pod_names": basetypes.MapType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"created_time": basetypes.Float64Type{},
		"evpn_options": basetypes.ObjectType{
			AttrTypes: EvpnOptionsValue{}.AttributeTypes(ctx),
		},
		"id":            basetypes.StringType{},
		"modified_time": basetypes.Float64Type{},
		"name":          basetypes.StringType{},
		"org_id":        basetypes.StringType{},
		"pod_names": basetypes.MapType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"created_time":  v.CreatedTime,
			"evpn_options":  evpnOptions,
			"id":            v.Id,
			"modified_time": v.ModifiedTime,
			"name":          v.Name,
			"org_id":        v.OrgId,
			"pod_names":     podNamesVal,
		})

	return objVal, diags
}

func (v OrgEvpnTopologiesValue) Equal(o attr.Value) bool {
	other, ok := o.(OrgEvpnTopologiesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.CreatedTime.Equal(other.CreatedTime) {
		return false
	}

	if !v.EvpnOptions.Equal(other.EvpnOptions) {
		return false
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.ModifiedTime.Equal(other.ModifiedTime) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.OrgId.Equal(other.OrgId) {
		return false
	}

	if !v.PodNames.Equal(other.PodNames) {
		return false
	}

	return true
}

func (v OrgEvpnTopologiesValue) Type(ctx context.Context) attr.Type {
	return OrgEvpnTopologiesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v OrgEvpnTopologiesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"created_time": basetypes.Float64Type{},
		"evpn_options": basetypes.ObjectType{
			AttrTypes: EvpnOptionsValue{}.AttributeTypes(ctx),
		},
		"id":            basetypes.StringType{},
		"modified_time": basetypes.Float64Type{},
		"name":          basetypes.StringType{},
		"org_id":        basetypes.StringType{},
		"pod_names": basetypes.MapType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = EvpnOptionsType{}

type EvpnOptionsType struct {
	basetypes.ObjectType
}

func (t EvpnOptionsType) Equal(o attr.Type) bool {
	other, ok := o.(EvpnOptionsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t EvpnOptionsType) String() string {
	return "EvpnOptionsType"
}

func (t EvpnOptionsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	autoLoopbackSubnetAttribute, ok := attributes["auto_loopback_subnet"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auto_loopback_subnet is missing from object`)

		return nil, diags
	}

	autoLoopbackSubnetVal, ok := autoLoopbackSubnetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auto_loopback_subnet expected to be basetypes.StringValue, was: %T`, autoLoopbackSubnetAttribute))
	}

	autoLoopbackSubnet6Attribute, ok := attributes["auto_loopback_subnet6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auto_loopback_subnet6 is missing from object`)

		return nil, diags
	}

	autoLoopbackSubnet6Val, ok := autoLoopbackSubnet6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auto_loopback_subnet6 expected to be basetypes.StringValue, was: %T`, autoLoopbackSubnet6Attribute))
	}

	autoRouterIdSubnetAttribute, ok := attributes["auto_router_id_subnet"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auto_router_id_subnet is missing from object`)

		return nil, diags
	}

	autoRouterIdSubnetVal, ok := autoRouterIdSubnetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auto_router_id_subnet expected to be basetypes.StringValue, was: %T`, autoRouterIdSubnetAttribute))
	}

	autoRouterIdSubnet6Attribute, ok := attributes["auto_router_id_subnet6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auto_router_id_subnet6 is missing from object`)

		return nil, diags
	}

	autoRouterIdSubnet6Val, ok := autoRouterIdSubnet6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auto_router_id_subnet6 expected to be basetypes.StringValue, was: %T`, autoRouterIdSubnet6Attribute))
	}

	coreAsBorderAttribute, ok := attributes["core_as_border"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`core_as_border is missing from object`)

		return nil, diags
	}

	coreAsBorderVal, ok := coreAsBorderAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`core_as_border expected to be basetypes.BoolValue, was: %T`, coreAsBorderAttribute))
	}

	overlayAttribute, ok := attributes["overlay"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`overlay is missing from object`)

		return nil, diags
	}

	overlayVal, ok := overlayAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`overlay expected to be basetypes.ObjectValue, was: %T`, overlayAttribute))
	}

	perVlanVgaV4MacAttribute, ok := attributes["per_vlan_vga_v4_mac"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`per_vlan_vga_v4_mac is missing from object`)

		return nil, diags
	}

	perVlanVgaV4MacVal, ok := perVlanVgaV4MacAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`per_vlan_vga_v4_mac expected to be basetypes.BoolValue, was: %T`, perVlanVgaV4MacAttribute))
	}

	perVlanVgaV6MacAttribute, ok := attributes["per_vlan_vga_v6_mac"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`per_vlan_vga_v6_mac is missing from object`)

		return nil, diags
	}

	perVlanVgaV6MacVal, ok := perVlanVgaV6MacAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`per_vlan_vga_v6_mac expected to be basetypes.BoolValue, was: %T`, perVlanVgaV6MacAttribute))
	}

	routedAtAttribute, ok := attributes["routed_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`routed_at is missing from object`)

		return nil, diags
	}

	routedAtVal, ok := routedAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`routed_at expected to be basetypes.StringValue, was: %T`, routedAtAttribute))
	}

	underlayAttribute, ok := attributes["underlay"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`underlay is missing from object`)

		return nil, diags
	}

	underlayVal, ok := underlayAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`underlay expected to be basetypes.ObjectValue, was: %T`, underlayAttribute))
	}

	vsInstancesAttribute, ok := attributes["vs_instances"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vs_instances is missing from object`)

		return nil, diags
	}

	vsInstancesVal, ok := vsInstancesAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vs_instances expected to be basetypes.MapValue, was: %T`, vsInstancesAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return EvpnOptionsValue{
		AutoLoopbackSubnet:  autoLoopbackSubnetVal,
		AutoLoopbackSubnet6: autoLoopbackSubnet6Val,
		AutoRouterIdSubnet:  autoRouterIdSubnetVal,
		AutoRouterIdSubnet6: autoRouterIdSubnet6Val,
		CoreAsBorder:        coreAsBorderVal,
		Overlay:             overlayVal,
		PerVlanVgaV4Mac:     perVlanVgaV4MacVal,
		PerVlanVgaV6Mac:     perVlanVgaV6MacVal,
		RoutedAt:            routedAtVal,
		Underlay:            underlayVal,
		VsInstances:         vsInstancesVal,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewEvpnOptionsValueNull() EvpnOptionsValue {
	return EvpnOptionsValue{
		state: attr.ValueStateNull,
	}
}

func NewEvpnOptionsValueUnknown() EvpnOptionsValue {
	return EvpnOptionsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewEvpnOptionsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (EvpnOptionsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing EvpnOptionsValue Attribute Value",
				"While creating a EvpnOptionsValue value, a missing attribute value was detected. "+
					"A EvpnOptionsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("EvpnOptionsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid EvpnOptionsValue Attribute Type",
				"While creating a EvpnOptionsValue value, an invalid attribute value was detected. "+
					"A EvpnOptionsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("EvpnOptionsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("EvpnOptionsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra EvpnOptionsValue Attribute Value",
				"While creating a EvpnOptionsValue value, an extra attribute value was detected. "+
					"A EvpnOptionsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra EvpnOptionsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewEvpnOptionsValueUnknown(), diags
	}

	autoLoopbackSubnetAttribute, ok := attributes["auto_loopback_subnet"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auto_loopback_subnet is missing from object`)

		return NewEvpnOptionsValueUnknown(), diags
	}

	autoLoopbackSubnetVal, ok := autoLoopbackSubnetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auto_loopback_subnet expected to be basetypes.StringValue, was: %T`, autoLoopbackSubnetAttribute))
	}

	autoLoopbackSubnet6Attribute, ok := attributes["auto_loopback_subnet6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auto_loopback_subnet6 is missing from object`)

		return NewEvpnOptionsValueUnknown(), diags
	}

	autoLoopbackSubnet6Val, ok := autoLoopbackSubnet6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auto_loopback_subnet6 expected to be basetypes.StringValue, was: %T`, autoLoopbackSubnet6Attribute))
	}

	autoRouterIdSubnetAttribute, ok := attributes["auto_router_id_subnet"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auto_router_id_subnet is missing from object`)

		return NewEvpnOptionsValueUnknown(), diags
	}

	autoRouterIdSubnetVal, ok := autoRouterIdSubnetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auto_router_id_subnet expected to be basetypes.StringValue, was: %T`, autoRouterIdSubnetAttribute))
	}

	autoRouterIdSubnet6Attribute, ok := attributes["auto_router_id_subnet6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auto_router_id_subnet6 is missing from object`)

		return NewEvpnOptionsValueUnknown(), diags
	}

	autoRouterIdSubnet6Val, ok := autoRouterIdSubnet6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auto_router_id_subnet6 expected to be basetypes.StringValue, was: %T`, autoRouterIdSubnet6Attribute))
	}

	coreAsBorderAttribute, ok := attributes["core_as_border"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`core_as_border is missing from object`)

		return NewEvpnOptionsValueUnknown(), diags
	}

	coreAsBorderVal, ok := coreAsBorderAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`core_as_border expected to be basetypes.BoolValue, was: %T`, coreAsBorderAttribute))
	}

	overlayAttribute, ok := attributes["overlay"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`overlay is missing from object`)

		return NewEvpnOptionsValueUnknown(), diags
	}

	overlayVal, ok := overlayAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`overlay expected to be basetypes.ObjectValue, was: %T`, overlayAttribute))
	}

	perVlanVgaV4MacAttribute, ok := attributes["per_vlan_vga_v4_mac"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`per_vlan_vga_v4_mac is missing from object`)

		return NewEvpnOptionsValueUnknown(), diags
	}

	perVlanVgaV4MacVal, ok := perVlanVgaV4MacAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`per_vlan_vga_v4_mac expected to be basetypes.BoolValue, was: %T`, perVlanVgaV4MacAttribute))
	}

	perVlanVgaV6MacAttribute, ok := attributes["per_vlan_vga_v6_mac"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`per_vlan_vga_v6_mac is missing from object`)

		return NewEvpnOptionsValueUnknown(), diags
	}

	perVlanVgaV6MacVal, ok := perVlanVgaV6MacAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`per_vlan_vga_v6_mac expected to be basetypes.BoolValue, was: %T`, perVlanVgaV6MacAttribute))
	}

	routedAtAttribute, ok := attributes["routed_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`routed_at is missing from object`)

		return NewEvpnOptionsValueUnknown(), diags
	}

	routedAtVal, ok := routedAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`routed_at expected to be basetypes.StringValue, was: %T`, routedAtAttribute))
	}

	underlayAttribute, ok := attributes["underlay"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`underlay is missing from object`)

		return NewEvpnOptionsValueUnknown(), diags
	}

	underlayVal, ok := underlayAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`underlay expected to be basetypes.ObjectValue, was: %T`, underlayAttribute))
	}

	vsInstancesAttribute, ok := attributes["vs_instances"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vs_instances is missing from object`)

		return NewEvpnOptionsValueUnknown(), diags
	}

	vsInstancesVal, ok := vsInstancesAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vs_instances expected to be basetypes.MapValue, was: %T`, vsInstancesAttribute))
	}

	if diags.HasError() {
		return NewEvpnOptionsValueUnknown(), diags
	}

	return EvpnOptionsValue{
		AutoLoopbackSubnet:  autoLoopbackSubnetVal,
		AutoLoopbackSubnet6: autoLoopbackSubnet6Val,
		AutoRouterIdSubnet:  autoRouterIdSubnetVal,
		AutoRouterIdSubnet6: autoRouterIdSubnet6Val,
		CoreAsBorder:        coreAsBorderVal,
		Overlay:             overlayVal,
		PerVlanVgaV4Mac:     perVlanVgaV4MacVal,
		PerVlanVgaV6Mac:     perVlanVgaV6MacVal,
		RoutedAt:            routedAtVal,
		Underlay:            underlayVal,
		VsInstances:         vsInstancesVal,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewEvpnOptionsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) EvpnOptionsValue {
	object, diags := NewEvpnOptionsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewEvpnOptionsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t EvpnOptionsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewEvpnOptionsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewEvpnOptionsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewEvpnOptionsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewEvpnOptionsValueMust(EvpnOptionsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t EvpnOptionsType) ValueType(ctx context.Context) attr.Value {
	return EvpnOptionsValue{}
}

var _ basetypes.ObjectValuable = EvpnOptionsValue{}

type EvpnOptionsValue struct {
	AutoLoopbackSubnet  basetypes.StringValue `tfsdk:"auto_loopback_subnet"`
	AutoLoopbackSubnet6 basetypes.StringValue `tfsdk:"auto_loopback_subnet6"`
	AutoRouterIdSubnet  basetypes.StringValue `tfsdk:"auto_router_id_subnet"`
	AutoRouterIdSubnet6 basetypes.StringValue `tfsdk:"auto_router_id_subnet6"`
	CoreAsBorder        basetypes.BoolValue   `tfsdk:"core_as_border"`
	Overlay             basetypes.ObjectValue `tfsdk:"overlay"`
	PerVlanVgaV4Mac     basetypes.BoolValue   `tfsdk:"per_vlan_vga_v4_mac"`
	PerVlanVgaV6Mac     basetypes.BoolValue   `tfsdk:"per_vlan_vga_v6_mac"`
	RoutedAt            basetypes.StringValue `tfsdk:"routed_at"`
	Underlay            basetypes.ObjectValue `tfsdk:"underlay"`
	VsInstances         basetypes.MapValue    `tfsdk:"vs_instances"`
	state               attr.ValueState
}

func (v EvpnOptionsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 11)

	var val tftypes.Value
	var err error

	attrTypes["auto_loopback_subnet"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["auto_loopback_subnet6"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["auto_router_id_subnet"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["auto_router_id_subnet6"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["core_as_border"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["overlay"] = basetypes.ObjectType{
		AttrTypes: OverlayValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["per_vlan_vga_v4_mac"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["per_vlan_vga_v6_mac"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["routed_at"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["underlay"] = basetypes.ObjectType{
		AttrTypes: UnderlayValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["vs_instances"] = basetypes.MapType{
		ElemType: VsInstancesValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 11)

		val, err = v.AutoLoopbackSubnet.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["auto_loopback_subnet"] = val

		val, err = v.AutoLoopbackSubnet6.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["auto_loopback_subnet6"] = val

		val, err = v.AutoRouterIdSubnet.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["auto_router_id_subnet"] = val

		val, err = v.AutoRouterIdSubnet6.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["auto_router_id_subnet6"] = val

		val, err = v.CoreAsBorder.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["core_as_border"] = val

		val, err = v.Overlay.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["overlay"] = val

		val, err = v.PerVlanVgaV4Mac.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["per_vlan_vga_v4_mac"] = val

		val, err = v.PerVlanVgaV6Mac.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["per_vlan_vga_v6_mac"] = val

		val, err = v.RoutedAt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["routed_at"] = val

		val, err = v.Underlay.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["underlay"] = val

		val, err = v.VsInstances.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vs_instances"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v EvpnOptionsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v EvpnOptionsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v EvpnOptionsValue) String() string {
	return "EvpnOptionsValue"
}

func (v EvpnOptionsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var overlay basetypes.ObjectValue

	if v.Overlay.IsNull() {
		overlay = types.ObjectNull(
			OverlayValue{}.AttributeTypes(ctx),
		)
	}

	if v.Overlay.IsUnknown() {
		overlay = types.ObjectUnknown(
			OverlayValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Overlay.IsNull() && !v.Overlay.IsUnknown() {
		overlay = types.ObjectValueMust(
			OverlayValue{}.AttributeTypes(ctx),
			v.Overlay.Attributes(),
		)
	}

	var underlay basetypes.ObjectValue

	if v.Underlay.IsNull() {
		underlay = types.ObjectNull(
			UnderlayValue{}.AttributeTypes(ctx),
		)
	}

	if v.Underlay.IsUnknown() {
		underlay = types.ObjectUnknown(
			UnderlayValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Underlay.IsNull() && !v.Underlay.IsUnknown() {
		underlay = types.ObjectValueMust(
			UnderlayValue{}.AttributeTypes(ctx),
			v.Underlay.Attributes(),
		)
	}

	vsInstances := types.MapValueMust(
		VsInstancesType{
			basetypes.ObjectType{
				AttrTypes: VsInstancesValue{}.AttributeTypes(ctx),
			},
		},
		v.VsInstances.Elements(),
	)

	if v.VsInstances.IsNull() {
		vsInstances = types.MapNull(
			VsInstancesType{
				basetypes.ObjectType{
					AttrTypes: VsInstancesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.VsInstances.IsUnknown() {
		vsInstances = types.MapUnknown(
			VsInstancesType{
				basetypes.ObjectType{
					AttrTypes: VsInstancesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"auto_loopback_subnet":   basetypes.StringType{},
		"auto_loopback_subnet6":  basetypes.StringType{},
		"auto_router_id_subnet":  basetypes.StringType{},
		"auto_router_id_subnet6": basetypes.StringType{},
		"core_as_border":         basetypes.BoolType{},
		"overlay": basetypes.ObjectType{
			AttrTypes: OverlayValue{}.AttributeTypes(ctx),
		},
		"per_vlan_vga_v4_mac": basetypes.BoolType{},
		"per_vlan_vga_v6_mac": basetypes.BoolType{},
		"routed_at":           basetypes.StringType{},
		"underlay": basetypes.ObjectType{
			AttrTypes: UnderlayValue{}.AttributeTypes(ctx),
		},
		"vs_instances": basetypes.MapType{
			ElemType: VsInstancesValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"auto_loopback_subnet":   v.AutoLoopbackSubnet,
			"auto_loopback_subnet6":  v.AutoLoopbackSubnet6,
			"auto_router_id_subnet":  v.AutoRouterIdSubnet,
			"auto_router_id_subnet6": v.AutoRouterIdSubnet6,
			"core_as_border":         v.CoreAsBorder,
			"overlay":                overlay,
			"per_vlan_vga_v4_mac":    v.PerVlanVgaV4Mac,
			"per_vlan_vga_v6_mac":    v.PerVlanVgaV6Mac,
			"routed_at":              v.RoutedAt,
			"underlay":               underlay,
			"vs_instances":           vsInstances,
		})

	return objVal, diags
}

func (v EvpnOptionsValue) Equal(o attr.Value) bool {
	other, ok := o.(EvpnOptionsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AutoLoopbackSubnet.Equal(other.AutoLoopbackSubnet) {
		return false
	}

	if !v.AutoLoopbackSubnet6.Equal(other.AutoLoopbackSubnet6) {
		return false
	}

	if !v.AutoRouterIdSubnet.Equal(other.AutoRouterIdSubnet) {
		return false
	}

	if !v.AutoRouterIdSubnet6.Equal(other.AutoRouterIdSubnet6) {
		return false
	}

	if !v.CoreAsBorder.Equal(other.CoreAsBorder) {
		return false
	}

	if !v.Overlay.Equal(other.Overlay) {
		return false
	}

	if !v.PerVlanVgaV4Mac.Equal(other.PerVlanVgaV4Mac) {
		return false
	}

	if !v.PerVlanVgaV6Mac.Equal(other.PerVlanVgaV6Mac) {
		return false
	}

	if !v.RoutedAt.Equal(other.RoutedAt) {
		return false
	}

	if !v.Underlay.Equal(other.Underlay) {
		return false
	}

	if !v.VsInstances.Equal(other.VsInstances) {
		return false
	}

	return true
}

func (v EvpnOptionsValue) Type(ctx context.Context) attr.Type {
	return EvpnOptionsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v EvpnOptionsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"auto_loopback_subnet":   basetypes.StringType{},
		"auto_loopback_subnet6":  basetypes.StringType{},
		"auto_router_id_subnet":  basetypes.StringType{},
		"auto_router_id_subnet6": basetypes.StringType{},
		"core_as_border":         basetypes.BoolType{},
		"overlay": basetypes.ObjectType{
			AttrTypes: OverlayValue{}.AttributeTypes(ctx),
		},
		"per_vlan_vga_v4_mac": basetypes.BoolType{},
		"per_vlan_vga_v6_mac": basetypes.BoolType{},
		"routed_at":           basetypes.StringType{},
		"underlay": basetypes.ObjectType{
			AttrTypes: UnderlayValue{}.AttributeTypes(ctx),
		},
		"vs_instances": basetypes.MapType{
			ElemType: VsInstancesValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = OverlayType{}

type OverlayType struct {
	basetypes.ObjectType
}

func (t OverlayType) Equal(o attr.Type) bool {
	other, ok := o.(OverlayType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t OverlayType) String() string {
	return "OverlayType"
}

func (t OverlayType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	asAttribute, ok := attributes["as"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`as is missing from object`)

		return nil, diags
	}

	asVal, ok := asAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`as expected to be basetypes.Int64Value, was: %T`, asAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return OverlayValue{
		As:    asVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewOverlayValueNull() OverlayValue {
	return OverlayValue{
		state: attr.ValueStateNull,
	}
}

func NewOverlayValueUnknown() OverlayValue {
	return OverlayValue{
		state: attr.ValueStateUnknown,
	}
}

func NewOverlayValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (OverlayValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing OverlayValue Attribute Value",
				"While creating a OverlayValue value, a missing attribute value was detected. "+
					"A OverlayValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OverlayValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid OverlayValue Attribute Type",
				"While creating a OverlayValue value, an invalid attribute value was detected. "+
					"A OverlayValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OverlayValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("OverlayValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra OverlayValue Attribute Value",
				"While creating a OverlayValue value, an extra attribute value was detected. "+
					"A OverlayValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra OverlayValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewOverlayValueUnknown(), diags
	}

	asAttribute, ok := attributes["as"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`as is missing from object`)

		return NewOverlayValueUnknown(), diags
	}

	asVal, ok := asAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`as expected to be basetypes.Int64Value, was: %T`, asAttribute))
	}

	if diags.HasError() {
		return NewOverlayValueUnknown(), diags
	}

	return OverlayValue{
		As:    asVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewOverlayValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) OverlayValue {
	object, diags := NewOverlayValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewOverlayValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t OverlayType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewOverlayValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewOverlayValueUnknown(), nil
	}

	if in.IsNull() {
		return NewOverlayValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewOverlayValueMust(OverlayValue{}.AttributeTypes(ctx), attributes), nil
}

func (t OverlayType) ValueType(ctx context.Context) attr.Value {
	return OverlayValue{}
}

var _ basetypes.ObjectValuable = OverlayValue{}

type OverlayValue struct {
	As    basetypes.Int64Value `tfsdk:"as"`
	state attr.ValueState
}

func (v OverlayValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["as"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.As.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["as"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v OverlayValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v OverlayValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v OverlayValue) String() string {
	return "OverlayValue"
}

func (v OverlayValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"as": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"as": v.As,
		})

	return objVal, diags
}

func (v OverlayValue) Equal(o attr.Value) bool {
	other, ok := o.(OverlayValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.As.Equal(other.As) {
		return false
	}

	return true
}

func (v OverlayValue) Type(ctx context.Context) attr.Type {
	return OverlayType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v OverlayValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"as": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = UnderlayType{}

type UnderlayType struct {
	basetypes.ObjectType
}

func (t UnderlayType) Equal(o attr.Type) bool {
	other, ok := o.(UnderlayType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t UnderlayType) String() string {
	return "UnderlayType"
}

func (t UnderlayType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	asBaseAttribute, ok := attributes["as_base"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`as_base is missing from object`)

		return nil, diags
	}

	asBaseVal, ok := asBaseAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`as_base expected to be basetypes.Int64Value, was: %T`, asBaseAttribute))
	}

	routedIdPrefixAttribute, ok := attributes["routed_id_prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`routed_id_prefix is missing from object`)

		return nil, diags
	}

	routedIdPrefixVal, ok := routedIdPrefixAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`routed_id_prefix expected to be basetypes.StringValue, was: %T`, routedIdPrefixAttribute))
	}

	subnetAttribute, ok := attributes["subnet"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet is missing from object`)

		return nil, diags
	}

	subnetVal, ok := subnetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet expected to be basetypes.StringValue, was: %T`, subnetAttribute))
	}

	useIpv6Attribute, ok := attributes["use_ipv6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`use_ipv6 is missing from object`)

		return nil, diags
	}

	useIpv6Val, ok := useIpv6Attribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`use_ipv6 expected to be basetypes.BoolValue, was: %T`, useIpv6Attribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return UnderlayValue{
		AsBase:         asBaseVal,
		RoutedIdPrefix: routedIdPrefixVal,
		Subnet:         subnetVal,
		UseIpv6:        useIpv6Val,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewUnderlayValueNull() UnderlayValue {
	return UnderlayValue{
		state: attr.ValueStateNull,
	}
}

func NewUnderlayValueUnknown() UnderlayValue {
	return UnderlayValue{
		state: attr.ValueStateUnknown,
	}
}

func NewUnderlayValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (UnderlayValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing UnderlayValue Attribute Value",
				"While creating a UnderlayValue value, a missing attribute value was detected. "+
					"A UnderlayValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("UnderlayValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid UnderlayValue Attribute Type",
				"While creating a UnderlayValue value, an invalid attribute value was detected. "+
					"A UnderlayValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("UnderlayValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("UnderlayValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra UnderlayValue Attribute Value",
				"While creating a UnderlayValue value, an extra attribute value was detected. "+
					"A UnderlayValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra UnderlayValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewUnderlayValueUnknown(), diags
	}

	asBaseAttribute, ok := attributes["as_base"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`as_base is missing from object`)

		return NewUnderlayValueUnknown(), diags
	}

	asBaseVal, ok := asBaseAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`as_base expected to be basetypes.Int64Value, was: %T`, asBaseAttribute))
	}

	routedIdPrefixAttribute, ok := attributes["routed_id_prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`routed_id_prefix is missing from object`)

		return NewUnderlayValueUnknown(), diags
	}

	routedIdPrefixVal, ok := routedIdPrefixAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`routed_id_prefix expected to be basetypes.StringValue, was: %T`, routedIdPrefixAttribute))
	}

	subnetAttribute, ok := attributes["subnet"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet is missing from object`)

		return NewUnderlayValueUnknown(), diags
	}

	subnetVal, ok := subnetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet expected to be basetypes.StringValue, was: %T`, subnetAttribute))
	}

	useIpv6Attribute, ok := attributes["use_ipv6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`use_ipv6 is missing from object`)

		return NewUnderlayValueUnknown(), diags
	}

	useIpv6Val, ok := useIpv6Attribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`use_ipv6 expected to be basetypes.BoolValue, was: %T`, useIpv6Attribute))
	}

	if diags.HasError() {
		return NewUnderlayValueUnknown(), diags
	}

	return UnderlayValue{
		AsBase:         asBaseVal,
		RoutedIdPrefix: routedIdPrefixVal,
		Subnet:         subnetVal,
		UseIpv6:        useIpv6Val,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewUnderlayValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) UnderlayValue {
	object, diags := NewUnderlayValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewUnderlayValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t UnderlayType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewUnderlayValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewUnderlayValueUnknown(), nil
	}

	if in.IsNull() {
		return NewUnderlayValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewUnderlayValueMust(UnderlayValue{}.AttributeTypes(ctx), attributes), nil
}

func (t UnderlayType) ValueType(ctx context.Context) attr.Value {
	return UnderlayValue{}
}

var _ basetypes.ObjectValuable = UnderlayValue{}

type UnderlayValue struct {
	AsBase         basetypes.Int64Value  `tfsdk:"as_base"`
	RoutedIdPrefix basetypes.StringValue `tfsdk:"routed_id_prefix"`
	Subnet         basetypes.StringValue `tfsdk:"subnet"`
	UseIpv6        basetypes.BoolValue   `tfsdk:"use_ipv6"`
	state          attr.ValueState
}

func (v UnderlayValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["as_base"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["routed_id_prefix"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["subnet"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["use_ipv6"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.AsBase.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["as_base"] = val

		val, err = v.RoutedIdPrefix.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["routed_id_prefix"] = val

		val, err = v.Subnet.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["subnet"] = val

		val, err = v.UseIpv6.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["use_ipv6"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v UnderlayValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v UnderlayValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v UnderlayValue) String() string {
	return "UnderlayValue"
}

func (v UnderlayValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"as_base":          basetypes.Int64Type{},
		"routed_id_prefix": basetypes.StringType{},
		"subnet":           basetypes.StringType{},
		"use_ipv6":         basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"as_base":          v.AsBase,
			"routed_id_prefix": v.RoutedIdPrefix,
			"subnet":           v.Subnet,
			"use_ipv6":         v.UseIpv6,
		})

	return objVal, diags
}

func (v UnderlayValue) Equal(o attr.Value) bool {
	other, ok := o.(UnderlayValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AsBase.Equal(other.AsBase) {
		return false
	}

	if !v.RoutedIdPrefix.Equal(other.RoutedIdPrefix) {
		return false
	}

	if !v.Subnet.Equal(other.Subnet) {
		return false
	}

	if !v.UseIpv6.Equal(other.UseIpv6) {
		return false
	}

	return true
}

func (v UnderlayValue) Type(ctx context.Context) attr.Type {
	return UnderlayType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v UnderlayValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"as_base":          basetypes.Int64Type{},
		"routed_id_prefix": basetypes.StringType{},
		"subnet":           basetypes.StringType{},
		"use_ipv6":         basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = VsInstancesType{}

type VsInstancesType struct {
	basetypes.ObjectType
}

func (t VsInstancesType) Equal(o attr.Type) bool {
	other, ok := o.(VsInstancesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t VsInstancesType) String() string {
	return "VsInstancesType"
}

func (t VsInstancesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	networksAttribute, ok := attributes["networks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`networks is missing from object`)

		return nil, diags
	}

	networksVal, ok := networksAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`networks expected to be basetypes.ListValue, was: %T`, networksAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return VsInstancesValue{
		Networks: networksVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewVsInstancesValueNull() VsInstancesValue {
	return VsInstancesValue{
		state: attr.ValueStateNull,
	}
}

func NewVsInstancesValueUnknown() VsInstancesValue {
	return VsInstancesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewVsInstancesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (VsInstancesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing VsInstancesValue Attribute Value",
				"While creating a VsInstancesValue value, a missing attribute value was detected. "+
					"A VsInstancesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VsInstancesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid VsInstancesValue Attribute Type",
				"While creating a VsInstancesValue value, an invalid attribute value was detected. "+
					"A VsInstancesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VsInstancesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("VsInstancesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra VsInstancesValue Attribute Value",
				"While creating a VsInstancesValue value, an extra attribute value was detected. "+
					"A VsInstancesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra VsInstancesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewVsInstancesValueUnknown(), diags
	}

	networksAttribute, ok := attributes["networks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`networks is missing from object`)

		return NewVsInstancesValueUnknown(), diags
	}

	networksVal, ok := networksAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`networks expected to be basetypes.ListValue, was: %T`, networksAttribute))
	}

	if diags.HasError() {
		return NewVsInstancesValueUnknown(), diags
	}

	return VsInstancesValue{
		Networks: networksVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewVsInstancesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) VsInstancesValue {
	object, diags := NewVsInstancesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewVsInstancesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t VsInstancesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewVsInstancesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewVsInstancesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewVsInstancesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewVsInstancesValueMust(VsInstancesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t VsInstancesType) ValueType(ctx context.Context) attr.Value {
	return VsInstancesValue{}
}

var _ basetypes.ObjectValuable = VsInstancesValue{}

type VsInstancesValue struct {
	Networks basetypes.ListValue `tfsdk:"networks"`
	state    attr.ValueState
}

func (v VsInstancesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["networks"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Networks.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["networks"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v VsInstancesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v VsInstancesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v VsInstancesValue) String() string {
	return "VsInstancesValue"
}

func (v VsInstancesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	networksVal, d := types.ListValue(types.StringType, v.Networks.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"networks": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"networks": basetypes.ListType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"networks": networksVal,
		})

	return objVal, diags
}

func (v VsInstancesValue) Equal(o attr.Value) bool {
	other, ok := o.(VsInstancesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Networks.Equal(other.Networks) {
		return false
	}

	return true
}

func (v VsInstancesValue) Type(ctx context.Context) attr.Type {
	return VsInstancesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v VsInstancesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"networks": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}
