// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package datasource_org_sso_roles

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/datasource/schema"
)

func OrgSsoRolesDataSourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"org_id": schema.StringAttribute{
				Required: true,
			},
			"org_sso_roles": schema.SetNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"created_time": schema.Float64Attribute{
							Computed:            true,
							Description:         "when the object has been created, in epoch",
							MarkdownDescription: "when the object has been created, in epoch",
						},
						"id": schema.StringAttribute{
							Computed:            true,
							Description:         "Unique ID of the object instance in the Mist Organnization",
							MarkdownDescription: "Unique ID of the object instance in the Mist Organnization",
						},
						"modified_time": schema.Float64Attribute{
							Computed:            true,
							Description:         "when the object has been modified for the last time, in epoch",
							MarkdownDescription: "when the object has been modified for the last time, in epoch",
						},
						"name": schema.StringAttribute{
							Computed: true,
						},
						"org_id": schema.StringAttribute{
							Computed: true,
						},
						"privileges": schema.ListNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"role": schema.StringAttribute{
										Computed:            true,
										Description:         "access permissions. enum: `admin`, `helpdesk`, `installer`, `read`, `write`",
										MarkdownDescription: "access permissions. enum: `admin`, `helpdesk`, `installer`, `read`, `write`",
									},
									"scope": schema.StringAttribute{
										Computed:            true,
										Description:         "enum: `org`, `site`, `sitegroup`",
										MarkdownDescription: "enum: `org`, `site`, `sitegroup`",
									},
									"site_id": schema.StringAttribute{
										Computed:            true,
										Description:         "if `scope`==`site`",
										MarkdownDescription: "if `scope`==`site`",
									},
									"sitegroup_id": schema.StringAttribute{
										Computed:            true,
										Description:         "if `scope`==`sitegroup`",
										MarkdownDescription: "if `scope`==`sitegroup`",
									},
									"views": schema.StringAttribute{
										Computed:            true,
										Description:         "Custom roles restrict Org users to specific UI views. This is useful for limiting UI access of Org users. Custom roles restrict Org users to specific UI views. This is useful for limiting UI access of Org users.  \nYou can define custom roles by adding the `views` attribute along with `role` when assigning privileges.  \nBelow are the list of supported UI views. Note that this is UI only feature.  \n\n  | UI View | Required Role | Description |\n  | --- | --- | --- |\n  | `reporting` | `read` | full access to all analytics tools |\n  | `marketing` | `read` | can view analytics and location maps |\n  | `super_observer` | `read` | can view all the organization except the subscription page |\n  | `location` | `write` | can view and manage location maps, can view analytics |\n  | `security` | `write` | can view and manage site labels, policies and security |\n  | `switch_admin` | `helpdesk` | can view and manage Switch ports, can view wired clients |\n  | `mxedge_admin` | `admin` | can view and manage Mist edges and Mist tunnels |\n  | `lobby_admin` | `admin` | full access to Org and Site Pre-shared keys |",
										MarkdownDescription: "Custom roles restrict Org users to specific UI views. This is useful for limiting UI access of Org users. Custom roles restrict Org users to specific UI views. This is useful for limiting UI access of Org users.  \nYou can define custom roles by adding the `views` attribute along with `role` when assigning privileges.  \nBelow are the list of supported UI views. Note that this is UI only feature.  \n\n  | UI View | Required Role | Description |\n  | --- | --- | --- |\n  | `reporting` | `read` | full access to all analytics tools |\n  | `marketing` | `read` | can view analytics and location maps |\n  | `super_observer` | `read` | can view all the organization except the subscription page |\n  | `location` | `write` | can view and manage location maps, can view analytics |\n  | `security` | `write` | can view and manage site labels, policies and security |\n  | `switch_admin` | `helpdesk` | can view and manage Switch ports, can view wired clients |\n  | `mxedge_admin` | `admin` | can view and manage Mist edges and Mist tunnels |\n  | `lobby_admin` | `admin` | full access to Org and Site Pre-shared keys |",
									},
								},
								CustomType: PrivilegesType{
									ObjectType: types.ObjectType{
										AttrTypes: PrivilegesValue{}.AttributeTypes(ctx),
									},
								},
							},
							Computed: true,
						},
					},
					CustomType: OrgSsoRolesType{
						ObjectType: types.ObjectType{
							AttrTypes: OrgSsoRolesValue{}.AttributeTypes(ctx),
						},
					},
				},
				Computed: true,
			},
		},
	}
}

type OrgSsoRolesModel struct {
	OrgId       types.String `tfsdk:"org_id"`
	OrgSsoRoles types.Set    `tfsdk:"org_sso_roles"`
}

var _ basetypes.ObjectTypable = OrgSsoRolesType{}

type OrgSsoRolesType struct {
	basetypes.ObjectType
}

func (t OrgSsoRolesType) Equal(o attr.Type) bool {
	other, ok := o.(OrgSsoRolesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t OrgSsoRolesType) String() string {
	return "OrgSsoRolesType"
}

func (t OrgSsoRolesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	createdTimeAttribute, ok := attributes["created_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_time is missing from object`)

		return nil, diags
	}

	createdTimeVal, ok := createdTimeAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_time expected to be basetypes.Float64Value, was: %T`, createdTimeAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	modifiedTimeAttribute, ok := attributes["modified_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`modified_time is missing from object`)

		return nil, diags
	}

	modifiedTimeVal, ok := modifiedTimeAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`modified_time expected to be basetypes.Float64Value, was: %T`, modifiedTimeAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	orgIdAttribute, ok := attributes["org_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`org_id is missing from object`)

		return nil, diags
	}

	orgIdVal, ok := orgIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`org_id expected to be basetypes.StringValue, was: %T`, orgIdAttribute))
	}

	privilegesAttribute, ok := attributes["privileges"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`privileges is missing from object`)

		return nil, diags
	}

	privilegesVal, ok := privilegesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`privileges expected to be basetypes.ListValue, was: %T`, privilegesAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return OrgSsoRolesValue{
		CreatedTime:  createdTimeVal,
		Id:           idVal,
		ModifiedTime: modifiedTimeVal,
		Name:         nameVal,
		OrgId:        orgIdVal,
		Privileges:   privilegesVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewOrgSsoRolesValueNull() OrgSsoRolesValue {
	return OrgSsoRolesValue{
		state: attr.ValueStateNull,
	}
}

func NewOrgSsoRolesValueUnknown() OrgSsoRolesValue {
	return OrgSsoRolesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewOrgSsoRolesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (OrgSsoRolesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing OrgSsoRolesValue Attribute Value",
				"While creating a OrgSsoRolesValue value, a missing attribute value was detected. "+
					"A OrgSsoRolesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OrgSsoRolesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid OrgSsoRolesValue Attribute Type",
				"While creating a OrgSsoRolesValue value, an invalid attribute value was detected. "+
					"A OrgSsoRolesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OrgSsoRolesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("OrgSsoRolesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra OrgSsoRolesValue Attribute Value",
				"While creating a OrgSsoRolesValue value, an extra attribute value was detected. "+
					"A OrgSsoRolesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra OrgSsoRolesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewOrgSsoRolesValueUnknown(), diags
	}

	createdTimeAttribute, ok := attributes["created_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_time is missing from object`)

		return NewOrgSsoRolesValueUnknown(), diags
	}

	createdTimeVal, ok := createdTimeAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_time expected to be basetypes.Float64Value, was: %T`, createdTimeAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewOrgSsoRolesValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	modifiedTimeAttribute, ok := attributes["modified_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`modified_time is missing from object`)

		return NewOrgSsoRolesValueUnknown(), diags
	}

	modifiedTimeVal, ok := modifiedTimeAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`modified_time expected to be basetypes.Float64Value, was: %T`, modifiedTimeAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewOrgSsoRolesValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	orgIdAttribute, ok := attributes["org_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`org_id is missing from object`)

		return NewOrgSsoRolesValueUnknown(), diags
	}

	orgIdVal, ok := orgIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`org_id expected to be basetypes.StringValue, was: %T`, orgIdAttribute))
	}

	privilegesAttribute, ok := attributes["privileges"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`privileges is missing from object`)

		return NewOrgSsoRolesValueUnknown(), diags
	}

	privilegesVal, ok := privilegesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`privileges expected to be basetypes.ListValue, was: %T`, privilegesAttribute))
	}

	if diags.HasError() {
		return NewOrgSsoRolesValueUnknown(), diags
	}

	return OrgSsoRolesValue{
		CreatedTime:  createdTimeVal,
		Id:           idVal,
		ModifiedTime: modifiedTimeVal,
		Name:         nameVal,
		OrgId:        orgIdVal,
		Privileges:   privilegesVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewOrgSsoRolesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) OrgSsoRolesValue {
	object, diags := NewOrgSsoRolesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewOrgSsoRolesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t OrgSsoRolesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewOrgSsoRolesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewOrgSsoRolesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewOrgSsoRolesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewOrgSsoRolesValueMust(OrgSsoRolesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t OrgSsoRolesType) ValueType(ctx context.Context) attr.Value {
	return OrgSsoRolesValue{}
}

var _ basetypes.ObjectValuable = OrgSsoRolesValue{}

type OrgSsoRolesValue struct {
	CreatedTime  basetypes.Float64Value `tfsdk:"created_time"`
	Id           basetypes.StringValue  `tfsdk:"id"`
	ModifiedTime basetypes.Float64Value `tfsdk:"modified_time"`
	Name         basetypes.StringValue  `tfsdk:"name"`
	OrgId        basetypes.StringValue  `tfsdk:"org_id"`
	Privileges   basetypes.ListValue    `tfsdk:"privileges"`
	state        attr.ValueState
}

func (v OrgSsoRolesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 6)

	var val tftypes.Value
	var err error

	attrTypes["created_time"] = basetypes.Float64Type{}.TerraformType(ctx)
	attrTypes["id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["modified_time"] = basetypes.Float64Type{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["org_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["privileges"] = basetypes.ListType{
		ElemType: PrivilegesValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 6)

		val, err = v.CreatedTime.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["created_time"] = val

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.ModifiedTime.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["modified_time"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.OrgId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["org_id"] = val

		val, err = v.Privileges.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["privileges"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v OrgSsoRolesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v OrgSsoRolesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v OrgSsoRolesValue) String() string {
	return "OrgSsoRolesValue"
}

func (v OrgSsoRolesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	privileges := types.ListValueMust(
		PrivilegesType{
			basetypes.ObjectType{
				AttrTypes: PrivilegesValue{}.AttributeTypes(ctx),
			},
		},
		v.Privileges.Elements(),
	)

	if v.Privileges.IsNull() {
		privileges = types.ListNull(
			PrivilegesType{
				basetypes.ObjectType{
					AttrTypes: PrivilegesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Privileges.IsUnknown() {
		privileges = types.ListUnknown(
			PrivilegesType{
				basetypes.ObjectType{
					AttrTypes: PrivilegesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"created_time":  basetypes.Float64Type{},
		"id":            basetypes.StringType{},
		"modified_time": basetypes.Float64Type{},
		"name":          basetypes.StringType{},
		"org_id":        basetypes.StringType{},
		"privileges": basetypes.ListType{
			ElemType: PrivilegesValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"created_time":  v.CreatedTime,
			"id":            v.Id,
			"modified_time": v.ModifiedTime,
			"name":          v.Name,
			"org_id":        v.OrgId,
			"privileges":    privileges,
		})

	return objVal, diags
}

func (v OrgSsoRolesValue) Equal(o attr.Value) bool {
	other, ok := o.(OrgSsoRolesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.CreatedTime.Equal(other.CreatedTime) {
		return false
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.ModifiedTime.Equal(other.ModifiedTime) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.OrgId.Equal(other.OrgId) {
		return false
	}

	if !v.Privileges.Equal(other.Privileges) {
		return false
	}

	return true
}

func (v OrgSsoRolesValue) Type(ctx context.Context) attr.Type {
	return OrgSsoRolesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v OrgSsoRolesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"created_time":  basetypes.Float64Type{},
		"id":            basetypes.StringType{},
		"modified_time": basetypes.Float64Type{},
		"name":          basetypes.StringType{},
		"org_id":        basetypes.StringType{},
		"privileges": basetypes.ListType{
			ElemType: PrivilegesValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = PrivilegesType{}

type PrivilegesType struct {
	basetypes.ObjectType
}

func (t PrivilegesType) Equal(o attr.Type) bool {
	other, ok := o.(PrivilegesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PrivilegesType) String() string {
	return "PrivilegesType"
}

func (t PrivilegesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	roleAttribute, ok := attributes["role"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`role is missing from object`)

		return nil, diags
	}

	roleVal, ok := roleAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`role expected to be basetypes.StringValue, was: %T`, roleAttribute))
	}

	scopeAttribute, ok := attributes["scope"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`scope is missing from object`)

		return nil, diags
	}

	scopeVal, ok := scopeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`scope expected to be basetypes.StringValue, was: %T`, scopeAttribute))
	}

	siteIdAttribute, ok := attributes["site_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`site_id is missing from object`)

		return nil, diags
	}

	siteIdVal, ok := siteIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`site_id expected to be basetypes.StringValue, was: %T`, siteIdAttribute))
	}

	sitegroupIdAttribute, ok := attributes["sitegroup_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sitegroup_id is missing from object`)

		return nil, diags
	}

	sitegroupIdVal, ok := sitegroupIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sitegroup_id expected to be basetypes.StringValue, was: %T`, sitegroupIdAttribute))
	}

	viewsAttribute, ok := attributes["views"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`views is missing from object`)

		return nil, diags
	}

	viewsVal, ok := viewsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`views expected to be basetypes.StringValue, was: %T`, viewsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PrivilegesValue{
		Role:        roleVal,
		Scope:       scopeVal,
		SiteId:      siteIdVal,
		SitegroupId: sitegroupIdVal,
		Views:       viewsVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewPrivilegesValueNull() PrivilegesValue {
	return PrivilegesValue{
		state: attr.ValueStateNull,
	}
}

func NewPrivilegesValueUnknown() PrivilegesValue {
	return PrivilegesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPrivilegesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PrivilegesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PrivilegesValue Attribute Value",
				"While creating a PrivilegesValue value, a missing attribute value was detected. "+
					"A PrivilegesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PrivilegesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PrivilegesValue Attribute Type",
				"While creating a PrivilegesValue value, an invalid attribute value was detected. "+
					"A PrivilegesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PrivilegesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PrivilegesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PrivilegesValue Attribute Value",
				"While creating a PrivilegesValue value, an extra attribute value was detected. "+
					"A PrivilegesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PrivilegesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPrivilegesValueUnknown(), diags
	}

	roleAttribute, ok := attributes["role"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`role is missing from object`)

		return NewPrivilegesValueUnknown(), diags
	}

	roleVal, ok := roleAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`role expected to be basetypes.StringValue, was: %T`, roleAttribute))
	}

	scopeAttribute, ok := attributes["scope"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`scope is missing from object`)

		return NewPrivilegesValueUnknown(), diags
	}

	scopeVal, ok := scopeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`scope expected to be basetypes.StringValue, was: %T`, scopeAttribute))
	}

	siteIdAttribute, ok := attributes["site_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`site_id is missing from object`)

		return NewPrivilegesValueUnknown(), diags
	}

	siteIdVal, ok := siteIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`site_id expected to be basetypes.StringValue, was: %T`, siteIdAttribute))
	}

	sitegroupIdAttribute, ok := attributes["sitegroup_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sitegroup_id is missing from object`)

		return NewPrivilegesValueUnknown(), diags
	}

	sitegroupIdVal, ok := sitegroupIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sitegroup_id expected to be basetypes.StringValue, was: %T`, sitegroupIdAttribute))
	}

	viewsAttribute, ok := attributes["views"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`views is missing from object`)

		return NewPrivilegesValueUnknown(), diags
	}

	viewsVal, ok := viewsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`views expected to be basetypes.StringValue, was: %T`, viewsAttribute))
	}

	if diags.HasError() {
		return NewPrivilegesValueUnknown(), diags
	}

	return PrivilegesValue{
		Role:        roleVal,
		Scope:       scopeVal,
		SiteId:      siteIdVal,
		SitegroupId: sitegroupIdVal,
		Views:       viewsVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewPrivilegesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PrivilegesValue {
	object, diags := NewPrivilegesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPrivilegesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PrivilegesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPrivilegesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPrivilegesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPrivilegesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPrivilegesValueMust(PrivilegesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PrivilegesType) ValueType(ctx context.Context) attr.Value {
	return PrivilegesValue{}
}

var _ basetypes.ObjectValuable = PrivilegesValue{}

type PrivilegesValue struct {
	Role        basetypes.StringValue `tfsdk:"role"`
	Scope       basetypes.StringValue `tfsdk:"scope"`
	SiteId      basetypes.StringValue `tfsdk:"site_id"`
	SitegroupId basetypes.StringValue `tfsdk:"sitegroup_id"`
	Views       basetypes.StringValue `tfsdk:"views"`
	state       attr.ValueState
}

func (v PrivilegesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["role"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["scope"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["site_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["sitegroup_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["views"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.Role.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["role"] = val

		val, err = v.Scope.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["scope"] = val

		val, err = v.SiteId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["site_id"] = val

		val, err = v.SitegroupId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["sitegroup_id"] = val

		val, err = v.Views.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["views"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PrivilegesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PrivilegesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PrivilegesValue) String() string {
	return "PrivilegesValue"
}

func (v PrivilegesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"role":         basetypes.StringType{},
		"scope":        basetypes.StringType{},
		"site_id":      basetypes.StringType{},
		"sitegroup_id": basetypes.StringType{},
		"views":        basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"role":         v.Role,
			"scope":        v.Scope,
			"site_id":      v.SiteId,
			"sitegroup_id": v.SitegroupId,
			"views":        v.Views,
		})

	return objVal, diags
}

func (v PrivilegesValue) Equal(o attr.Value) bool {
	other, ok := o.(PrivilegesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Role.Equal(other.Role) {
		return false
	}

	if !v.Scope.Equal(other.Scope) {
		return false
	}

	if !v.SiteId.Equal(other.SiteId) {
		return false
	}

	if !v.SitegroupId.Equal(other.SitegroupId) {
		return false
	}

	if !v.Views.Equal(other.Views) {
		return false
	}

	return true
}

func (v PrivilegesValue) Type(ctx context.Context) attr.Type {
	return PrivilegesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PrivilegesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"role":         basetypes.StringType{},
		"scope":        basetypes.StringType{},
		"site_id":      basetypes.StringType{},
		"sitegroup_id": basetypes.StringType{},
		"views":        basetypes.StringType{},
	}
}
