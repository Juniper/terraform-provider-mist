// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package datasource_org_wlans

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework-validators/mapvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/datasource/schema"
)

func OrgWlansDataSourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"org_id": schema.StringAttribute{
				Required: true,
			},
			"org_wlans": schema.SetNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"acct_immediate_update": schema.BoolAttribute{
							Computed:            true,
							Description:         "Enable coa-immediate-update and address-change-immediate-update on the access profile.",
							MarkdownDescription: "Enable coa-immediate-update and address-change-immediate-update on the access profile.",
						},
						"acct_interim_interval": schema.Int64Attribute{
							Computed:            true,
							Description:         "How frequently should interim accounting be reported, 60-65535. default is 0 (use one specified in Access-Accept request from RADIUS Server). Very frequent messages can affect the performance of the radius server, 600 and up is recommended when enabled",
							MarkdownDescription: "How frequently should interim accounting be reported, 60-65535. default is 0 (use one specified in Access-Accept request from RADIUS Server). Very frequent messages can affect the performance of the radius server, 600 and up is recommended when enabled",
						},
						"acct_servers": schema.ListNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"host": schema.StringAttribute{
										Computed:            true,
										Description:         "IP/ hostname of RADIUS server",
										MarkdownDescription: "IP/ hostname of RADIUS server",
									},
									"keywrap_enabled": schema.BoolAttribute{
										Computed: true,
									},
									"keywrap_format": schema.StringAttribute{
										Computed:            true,
										Description:         "enum: `ascii`, `hex`",
										MarkdownDescription: "enum: `ascii`, `hex`",
									},
									"keywrap_kek": schema.StringAttribute{
										Computed: true,
									},
									"keywrap_mack": schema.StringAttribute{
										Computed: true,
									},
									"port": schema.Int64Attribute{
										Computed:            true,
										Description:         "Acct port of RADIUS server",
										MarkdownDescription: "Acct port of RADIUS server",
									},
									"secret": schema.StringAttribute{
										Computed:            true,
										Sensitive:           true,
										Description:         "Secretof RADIUS server",
										MarkdownDescription: "Secretof RADIUS server",
									},
								},
								CustomType: AcctServersType{
									ObjectType: types.ObjectType{
										AttrTypes: AcctServersValue{}.AttributeTypes(ctx),
									},
								},
							},
							Computed:            true,
							Description:         "List of RADIUS accounting servers, optional, order matters where the first one is treated as primary",
							MarkdownDescription: "List of RADIUS accounting servers, optional, order matters where the first one is treated as primary",
						},
						"airwatch": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"api_key": schema.StringAttribute{
									Computed:            true,
									Description:         "API Key",
									MarkdownDescription: "API Key",
								},
								"console_url": schema.StringAttribute{
									Computed:            true,
									Description:         "Console URL",
									MarkdownDescription: "Console URL",
								},
								"enabled": schema.BoolAttribute{
									Computed: true,
								},
								"password": schema.StringAttribute{
									Computed:            true,
									Sensitive:           true,
									Description:         "Password",
									MarkdownDescription: "Password",
								},
								"username": schema.StringAttribute{
									Computed:            true,
									Description:         "Username",
									MarkdownDescription: "Username",
								},
							},
							CustomType: AirwatchType{
								ObjectType: types.ObjectType{
									AttrTypes: AirwatchValue{}.AttributeTypes(ctx),
								},
							},
							Computed:            true,
							Description:         "Airwatch wlan settings",
							MarkdownDescription: "Airwatch wlan settings",
						},
						"allow_ipv6_ndp": schema.BoolAttribute{
							Computed:            true,
							Description:         "Only applicable when limit_bcast==true, which allows or disallows ipv6 Neighbor Discovery packets to go through",
							MarkdownDescription: "Only applicable when limit_bcast==true, which allows or disallows ipv6 Neighbor Discovery packets to go through",
						},
						"allow_mdns": schema.BoolAttribute{
							Computed:            true,
							Description:         "Only applicable when limit_bcast==true, which allows mDNS / Bonjour packets to go through",
							MarkdownDescription: "Only applicable when limit_bcast==true, which allows mDNS / Bonjour packets to go through",
						},
						"allow_ssdp": schema.BoolAttribute{
							Computed:            true,
							Description:         "Only applicable when `limit_bcast`==`true`, which allows SSDP",
							MarkdownDescription: "Only applicable when `limit_bcast`==`true`, which allows SSDP",
						},
						"ap_ids": schema.ListAttribute{
							ElementType:         types.StringType,
							Computed:            true,
							Description:         "List of device ids",
							MarkdownDescription: "List of device ids",
						},
						"app_limit": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"apps": schema.MapAttribute{
									ElementType:         types.Int64Type,
									Computed:            true,
									Description:         "Map from app key to bandwidth in kbps. \nProperty key is the app key, defined in Get Application List",
									MarkdownDescription: "Map from app key to bandwidth in kbps. \nProperty key is the app key, defined in Get Application List",
								},
								"enabled": schema.BoolAttribute{
									Computed: true,
								},
								"wxtag_ids": schema.MapAttribute{
									ElementType:         types.Int64Type,
									Computed:            true,
									Description:         "Map from wxtag_id of Hostname Wxlan Tags to bandwidth in kbps. Property key is the `wxtag_id`",
									MarkdownDescription: "Map from wxtag_id of Hostname Wxlan Tags to bandwidth in kbps. Property key is the `wxtag_id`",
								},
							},
							CustomType: AppLimitType{
								ObjectType: types.ObjectType{
									AttrTypes: AppLimitValue{}.AttributeTypes(ctx),
								},
							},
							Computed:            true,
							Description:         "Bandwidth limiting for apps (applies to up/down)",
							MarkdownDescription: "Bandwidth limiting for apps (applies to up/down)",
						},
						"app_qos": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"apps": schema.MapNestedAttribute{
									NestedObject: schema.NestedAttributeObject{
										Attributes: map[string]schema.Attribute{
											"dscp": schema.Int64Attribute{
												Computed: true,
											},
											"dst_subnet": schema.StringAttribute{
												Computed:            true,
												Description:         "Subnet filter is not required but helps AP to only inspect certain traffic (thus reducing AP load)",
												MarkdownDescription: "Subnet filter is not required but helps AP to only inspect certain traffic (thus reducing AP load)",
											},
											"src_subnet": schema.StringAttribute{
												Computed:            true,
												Description:         "Subnet filter is not required but helps AP to only inspect certain traffic (thus reducing AP load)",
												MarkdownDescription: "Subnet filter is not required but helps AP to only inspect certain traffic (thus reducing AP load)",
											},
										},
										CustomType: AppsType{
											ObjectType: types.ObjectType{
												AttrTypes: AppsValue{}.AttributeTypes(ctx),
											},
										},
									},
									Computed: true,
									Validators: []validator.Map{
										mapvalidator.SizeAtLeast(1),
									},
								},
								"enabled": schema.BoolAttribute{
									Computed: true,
								},
								"others": schema.ListNestedAttribute{
									NestedObject: schema.NestedAttributeObject{
										Attributes: map[string]schema.Attribute{
											"dscp": schema.Int64Attribute{
												Computed: true,
											},
											"dst_subnet": schema.StringAttribute{
												Computed: true,
											},
											"port_ranges": schema.StringAttribute{
												Computed: true,
											},
											"protocol": schema.StringAttribute{
												Computed: true,
											},
											"src_subnet": schema.StringAttribute{
												Computed: true,
											},
										},
										CustomType: OthersType{
											ObjectType: types.ObjectType{
												AttrTypes: OthersValue{}.AttributeTypes(ctx),
											},
										},
									},
									Computed: true,
								},
							},
							CustomType: AppQosType{
								ObjectType: types.ObjectType{
									AttrTypes: AppQosValue{}.AttributeTypes(ctx),
								},
							},
							Computed:            true,
							Description:         "APp qos wlan settings",
							MarkdownDescription: "APp qos wlan settings",
						},
						"apply_to": schema.StringAttribute{
							Computed:            true,
							Description:         "enum: `aps`, `site`, `wxtags`",
							MarkdownDescription: "enum: `aps`, `site`, `wxtags`",
						},
						"arp_filter": schema.BoolAttribute{
							Computed:            true,
							Description:         "Whether to enable smart arp filter",
							MarkdownDescription: "Whether to enable smart arp filter",
						},
						"auth": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"anticlog_threshold": schema.Int64Attribute{
									Computed:            true,
									Description:         "SAE anti-clogging token threshold",
									MarkdownDescription: "SAE anti-clogging token threshold",
								},
								"eap_reauth": schema.BoolAttribute{
									Computed:            true,
									Description:         "Whether to trigger EAP reauth when the session ends",
									MarkdownDescription: "Whether to trigger EAP reauth when the session ends",
								},
								"enable_mac_auth": schema.BoolAttribute{
									Computed:            true,
									Description:         "Whether to enable MAC Auth, uses the same auth_servers",
									MarkdownDescription: "Whether to enable MAC Auth, uses the same auth_servers",
								},
								"key_idx": schema.Int64Attribute{
									Computed:            true,
									Description:         "When `type`==`wep`",
									MarkdownDescription: "When `type`==`wep`",
								},
								"keys": schema.ListAttribute{
									ElementType:         types.StringType,
									Computed:            true,
									Description:         "When type=wep, four 10-character or 26-character hex string, null can be used. All keys, if provided, have to be in the same length",
									MarkdownDescription: "When type=wep, four 10-character or 26-character hex string, null can be used. All keys, if provided, have to be in the same length",
								},
								"multi_psk_only": schema.BoolAttribute{
									Computed:            true,
									Description:         "When `type`==`psk`, whether to only use multi_psk",
									MarkdownDescription: "When `type`==`psk`, whether to only use multi_psk",
								},
								"owe": schema.StringAttribute{
									Computed:            true,
									Description:         "if `type`==`open`. enum: `disabled`, `enabled` (means transition mode), `required`",
									MarkdownDescription: "if `type`==`open`. enum: `disabled`, `enabled` (means transition mode), `required`",
								},
								"pairwise": schema.ListAttribute{
									ElementType:         types.StringType,
									Computed:            true,
									Description:         "When `type`=`psk` or `type`=`eap`, one or more of `wpa1-ccmp`, `wpa1-tkip`, `wpa2-ccmp`, `wpa2-tkip`, `wpa3`",
									MarkdownDescription: "When `type`=`psk` or `type`=`eap`, one or more of `wpa1-ccmp`, `wpa1-tkip`, `wpa2-ccmp`, `wpa2-tkip`, `wpa3`",
								},
								"private_wlan": schema.BoolAttribute{
									Computed:            true,
									Description:         "When `multi_psk_only`==`true`, whether private wlan is enabled",
									MarkdownDescription: "When `multi_psk_only`==`true`, whether private wlan is enabled",
								},
								"psk": schema.StringAttribute{
									Computed:            true,
									Sensitive:           true,
									Description:         "When `type`==`psk`, 8-64 characters, or 64 hex characters",
									MarkdownDescription: "When `type`==`psk`, 8-64 characters, or 64 hex characters",
								},
								"type": schema.StringAttribute{
									Computed:            true,
									Description:         "enum: `eap`, `eap192`, `open`, `psk`, `psk-tkip`, `psk-wpa2-tkip`, `wep`",
									MarkdownDescription: "enum: `eap`, `eap192`, `open`, `psk`, `psk-tkip`, `psk-wpa2-tkip`, `wep`",
								},
								"wep_as_secondary_auth": schema.BoolAttribute{
									Computed:            true,
									Description:         "Enable WEP as secondary auth",
									MarkdownDescription: "Enable WEP as secondary auth",
								},
							},
							CustomType: AuthType{
								ObjectType: types.ObjectType{
									AttrTypes: AuthValue{}.AttributeTypes(ctx),
								},
							},
							Computed:            true,
							Description:         "Authentication wlan settings",
							MarkdownDescription: "Authentication wlan settings",
						},
						"auth_server_selection": schema.StringAttribute{
							Computed:            true,
							Description:         "When ordered, AP will prefer and go back to the first server if possible. enum: `ordered`, `unordered`",
							MarkdownDescription: "When ordered, AP will prefer and go back to the first server if possible. enum: `ordered`, `unordered`",
						},
						"auth_servers": schema.ListNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"host": schema.StringAttribute{
										Computed:            true,
										Description:         "IP/ hostname of RADIUS server",
										MarkdownDescription: "IP/ hostname of RADIUS server",
									},
									"keywrap_enabled": schema.BoolAttribute{
										Computed: true,
									},
									"keywrap_format": schema.StringAttribute{
										Computed:            true,
										Description:         "enum: `ascii`, `hex`",
										MarkdownDescription: "enum: `ascii`, `hex`",
									},
									"keywrap_kek": schema.StringAttribute{
										Computed: true,
									},
									"keywrap_mack": schema.StringAttribute{
										Computed: true,
									},
									"port": schema.Int64Attribute{
										Computed:            true,
										Description:         "Auth port of RADIUS server",
										MarkdownDescription: "Auth port of RADIUS server",
									},
									"require_message_authenticator": schema.BoolAttribute{
										Computed:            true,
										Description:         "Whether to require Message-Authenticator in requests",
										MarkdownDescription: "Whether to require Message-Authenticator in requests",
									},
									"secret": schema.StringAttribute{
										Computed:            true,
										Sensitive:           true,
										Description:         "Secretof RADIUS server",
										MarkdownDescription: "Secretof RADIUS server",
									},
								},
								CustomType: AuthServersType{
									ObjectType: types.ObjectType{
										AttrTypes: AuthServersValue{}.AttributeTypes(ctx),
									},
								},
							},
							Computed:            true,
							Description:         "List of RADIUS authentication servers, at least one is needed if `auth type`==`eap`, order matters where the first one is treated as primary",
							MarkdownDescription: "List of RADIUS authentication servers, at least one is needed if `auth type`==`eap`, order matters where the first one is treated as primary",
						},
						"auth_servers_nas_id": schema.StringAttribute{
							Computed:            true,
							Description:         "Optional, up to 48 bytes, will be dynamically generated if not provided. used only for authentication servers",
							MarkdownDescription: "Optional, up to 48 bytes, will be dynamically generated if not provided. used only for authentication servers",
						},
						"auth_servers_nas_ip": schema.StringAttribute{
							Computed:            true,
							Description:         "Optional, NAS-IP-ADDRESS to use",
							MarkdownDescription: "Optional, NAS-IP-ADDRESS to use",
						},
						"auth_servers_retries": schema.Int64Attribute{
							Computed:            true,
							Description:         "Radius auth session retries. Following fast timers are set if \"fast_dot1x_timers\" knob is enabled. ‘retries’  are set to value of auth_servers_retries. ‘max-requests’ is also set when setting auth_servers_retries and is set to default value to 3.",
							MarkdownDescription: "Radius auth session retries. Following fast timers are set if \"fast_dot1x_timers\" knob is enabled. ‘retries’  are set to value of auth_servers_retries. ‘max-requests’ is also set when setting auth_servers_retries and is set to default value to 3.",
						},
						"auth_servers_timeout": schema.Int64Attribute{
							Computed:            true,
							Description:         "Radius auth session timeout. Following fast timers are set if \"fast_dot1x_timers\" knob is enabled. ‘quite-period’  and ‘transmit-period’ are set to half the value of auth_servers_timeout. ‘supplicant-timeout’ is also set when setting auth_servers_timeout and is set to default value of 10.",
							MarkdownDescription: "Radius auth session timeout. Following fast timers are set if \"fast_dot1x_timers\" knob is enabled. ‘quite-period’  and ‘transmit-period’ are set to half the value of auth_servers_timeout. ‘supplicant-timeout’ is also set when setting auth_servers_timeout and is set to default value of 10.",
						},
						"band_steer": schema.BoolAttribute{
							Computed:            true,
							Description:         "Whether to enable band_steering, this works only when band==both",
							MarkdownDescription: "Whether to enable band_steering, this works only when band==both",
						},
						"band_steer_force_band5": schema.BoolAttribute{
							Computed:            true,
							Description:         "Force dual_band capable client to connect to 5G",
							MarkdownDescription: "Force dual_band capable client to connect to 5G",
						},
						"bands": schema.ListAttribute{
							ElementType:         types.StringType,
							Computed:            true,
							Description:         "List of radios that the wlan should apply to.",
							MarkdownDescription: "List of radios that the wlan should apply to.",
						},
						"block_blacklist_clients": schema.BoolAttribute{
							Computed:            true,
							Description:         "Whether to block the clients in the blacklist (up to first 256 macs)",
							MarkdownDescription: "Whether to block the clients in the blacklist (up to first 256 macs)",
						},
						"bonjour": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"additional_vlan_ids": schema.ListAttribute{
									ElementType:         types.StringType,
									Computed:            true,
									Description:         "additional VLAN IDs (on the LAN side or from other WLANs) should we be forwarding bonjour queries/responses",
									MarkdownDescription: "additional VLAN IDs (on the LAN side or from other WLANs) should we be forwarding bonjour queries/responses",
								},
								"enabled": schema.BoolAttribute{
									Computed:            true,
									Description:         "Whether to enable bonjour for this WLAN. Once enabled, limit_bcast is assumed true, allow_mdns is assumed false",
									MarkdownDescription: "Whether to enable bonjour for this WLAN. Once enabled, limit_bcast is assumed true, allow_mdns is assumed false",
								},
								"services": schema.MapNestedAttribute{
									NestedObject: schema.NestedAttributeObject{
										Attributes: map[string]schema.Attribute{
											"disable_local": schema.BoolAttribute{
												Computed:            true,
												Description:         "Whether to prevent wireless clients to discover bonjour devices on the same WLAN",
												MarkdownDescription: "Whether to prevent wireless clients to discover bonjour devices on the same WLAN",
											},
											"radius_groups": schema.ListAttribute{
												ElementType:         types.StringType,
												Computed:            true,
												Description:         "Optional, if the service is further restricted for certain RADIUS groups",
												MarkdownDescription: "Optional, if the service is further restricted for certain RADIUS groups",
											},
											"scope": schema.StringAttribute{
												Computed:            true,
												Description:         "how bonjour services should be discovered for the same WLAN. enum: `same_ap`, `same_map`, `same_site`",
												MarkdownDescription: "how bonjour services should be discovered for the same WLAN. enum: `same_ap`, `same_map`, `same_site`",
											},
										},
										CustomType: ServicesType{
											ObjectType: types.ObjectType{
												AttrTypes: ServicesValue{}.AttributeTypes(ctx),
											},
										},
									},
									Computed:            true,
									Description:         "What services are allowed. \nProperty key is the service name",
									MarkdownDescription: "What services are allowed. \nProperty key is the service name",
									Validators: []validator.Map{
										mapvalidator.SizeAtLeast(1),
									},
								},
							},
							CustomType: BonjourType{
								ObjectType: types.ObjectType{
									AttrTypes: BonjourValue{}.AttributeTypes(ctx),
								},
							},
							Computed:            true,
							Description:         "Bonjour gateway wlan settings",
							MarkdownDescription: "Bonjour gateway wlan settings",
						},
						"cisco_cwa": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"allowed_hostnames": schema.ListAttribute{
									ElementType:         types.StringType,
									Computed:            true,
									Description:         "List of hostnames without http(s):// (matched by substring)",
									MarkdownDescription: "List of hostnames without http(s):// (matched by substring)",
								},
								"allowed_subnets": schema.ListAttribute{
									ElementType:         types.StringType,
									Computed:            true,
									Description:         "List of CIDRs",
									MarkdownDescription: "List of CIDRs",
								},
								"blocked_subnets": schema.ListAttribute{
									ElementType:         types.StringType,
									Computed:            true,
									Description:         "List of blocked CIDRs",
									MarkdownDescription: "List of blocked CIDRs",
								},
								"enabled": schema.BoolAttribute{
									Computed: true,
								},
							},
							CustomType: CiscoCwaType{
								ObjectType: types.ObjectType{
									AttrTypes: CiscoCwaValue{}.AttributeTypes(ctx),
								},
							},
							Computed:            true,
							Description:         "Cisco CWA (central web authentication) required RADIUS with COA in order to work. See CWA: https://www.cisco.com/c/en/us/support/docs/security/identity-services-engine/115732-central-web-auth-00.html",
							MarkdownDescription: "Cisco CWA (central web authentication) required RADIUS with COA in order to work. See CWA: https://www.cisco.com/c/en/us/support/docs/security/identity-services-engine/115732-central-web-auth-00.html",
						},
						"client_limit_down": schema.Int64Attribute{
							Computed:            true,
							Description:         "In kbps",
							MarkdownDescription: "In kbps",
						},
						"client_limit_down_enabled": schema.BoolAttribute{
							Computed:            true,
							Description:         "If downlink limiting per-client is enabled",
							MarkdownDescription: "If downlink limiting per-client is enabled",
						},
						"client_limit_up": schema.Int64Attribute{
							Computed:            true,
							Description:         "In kbps",
							MarkdownDescription: "In kbps",
						},
						"client_limit_up_enabled": schema.BoolAttribute{
							Computed:            true,
							Description:         "If uplink limiting per-client is enabled",
							MarkdownDescription: "If uplink limiting per-client is enabled",
						},
						"coa_servers": schema.ListNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"disable_event_timestamp_check": schema.BoolAttribute{
										Computed:            true,
										Description:         "Whether to disable Event-Timestamp Check",
										MarkdownDescription: "Whether to disable Event-Timestamp Check",
									},
									"enabled": schema.BoolAttribute{
										Computed: true,
									},
									"ip": schema.StringAttribute{
										Computed: true,
									},
									"port": schema.Int64Attribute{
										Computed: true,
									},
									"secret": schema.StringAttribute{
										Computed:  true,
										Sensitive: true,
									},
								},
								CustomType: CoaServersType{
									ObjectType: types.ObjectType{
										AttrTypes: CoaServersValue{}.AttributeTypes(ctx),
									},
								},
							},
							Computed:            true,
							Description:         "List of COA (change of authorization) servers, optional",
							MarkdownDescription: "List of COA (change of authorization) servers, optional",
						},
						"created_time": schema.Float64Attribute{
							Computed:            true,
							Description:         "When the object has been created, in epoch",
							MarkdownDescription: "When the object has been created, in epoch",
						},
						"disable_11ax": schema.BoolAttribute{
							Computed:            true,
							Description:         "Some old WLAN drivers may not be compatible",
							MarkdownDescription: "Some old WLAN drivers may not be compatible",
						},
						"disable_ht_vht_rates": schema.BoolAttribute{
							Computed:            true,
							Description:         "To disable ht or vht rates",
							MarkdownDescription: "To disable ht or vht rates",
						},
						"disable_uapsd": schema.BoolAttribute{
							Computed:            true,
							Description:         "Whether to disable U-APSD",
							MarkdownDescription: "Whether to disable U-APSD",
						},
						"disable_v1_roam_notify": schema.BoolAttribute{
							Computed:            true,
							Description:         "Disable sending v2 roam notification messages",
							MarkdownDescription: "Disable sending v2 roam notification messages",
						},
						"disable_v2_roam_notify": schema.BoolAttribute{
							Computed:            true,
							Description:         "Disable sending v2 roam notification messages",
							MarkdownDescription: "Disable sending v2 roam notification messages",
						},
						"disable_when_gateway_unreachable": schema.BoolAttribute{
							Computed:            true,
							Description:         "When any of the following is true, this WLAN will be disabled\n   * cannot get IP\n   * cannot obtain default gateway\n   * cannot reach default gateway",
							MarkdownDescription: "When any of the following is true, this WLAN will be disabled\n   * cannot get IP\n   * cannot obtain default gateway\n   * cannot reach default gateway",
						},
						"disable_when_mxtunnel_down": schema.BoolAttribute{
							Computed: true,
						},
						"disable_wmm": schema.BoolAttribute{
							Computed:            true,
							Description:         "Whether to disable WMM",
							MarkdownDescription: "Whether to disable WMM",
						},
						"dns_server_rewrite": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"enabled": schema.BoolAttribute{
									Computed: true,
								},
								"radius_groups": schema.MapAttribute{
									ElementType:         types.StringType,
									Computed:            true,
									Description:         "Map between radius_group and the desired DNS server (IPv4 only). Property key is the RADIUS group, property value is the desired DNS Server",
									MarkdownDescription: "Map between radius_group and the desired DNS server (IPv4 only). Property key is the RADIUS group, property value is the desired DNS Server",
								},
							},
							CustomType: DnsServerRewriteType{
								ObjectType: types.ObjectType{
									AttrTypes: DnsServerRewriteValue{}.AttributeTypes(ctx),
								},
							},
							Computed:            true,
							Description:         "For radius_group-based DNS server (rewrite DNS request depending on the Group RADIUS server returns)",
							MarkdownDescription: "For radius_group-based DNS server (rewrite DNS request depending on the Group RADIUS server returns)",
						},
						"dtim": schema.Int64Attribute{
							Computed: true,
						},
						"dynamic_psk": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"default_psk": schema.StringAttribute{
									Computed:            true,
									Sensitive:           true,
									Description:         "Default PSK to use if cloud WLC is not available, 8-63 characters",
									MarkdownDescription: "Default PSK to use if cloud WLC is not available, 8-63 characters",
								},
								"default_vlan_id": schema.StringAttribute{
									Computed: true,
								},
								"enabled": schema.BoolAttribute{
									Computed: true,
								},
								"force_lookup": schema.BoolAttribute{
									Computed:            true,
									Description:         "When 11r is enabled, we'll try to use the cached PMK, this can be disabled. `false` means auto",
									MarkdownDescription: "When 11r is enabled, we'll try to use the cached PMK, this can be disabled. `false` means auto",
								},
								"source": schema.StringAttribute{
									Computed:            true,
									Description:         "enum: `cloud_psks`, `radius`",
									MarkdownDescription: "enum: `cloud_psks`, `radius`",
								},
							},
							CustomType: DynamicPskType{
								ObjectType: types.ObjectType{
									AttrTypes: DynamicPskValue{}.AttributeTypes(ctx),
								},
							},
							Computed:            true,
							Description:         "For dynamic PSK where we get per_user PSK from Radius. dynamic_psk allows PSK to be selected at runtime depending on context (wlan/site/user/...) thus following configurations are assumed (currently)\n  * PSK will come from RADIUS server\n  * AP sends client MAC as username and password (i.e. `enable_mac_auth` is assumed)\n  * AP sends BSSID:SSID as Caller-Station-ID\n  * `auth_servers` is required\n  * PSK will come from cloud WLC if source is cloud_psks\n  * default_psk will be used if cloud WLC is not available\n  * `multi_psk_only` and `psk` is ignored\n  * `pairwise` can only be wpa2-ccmp (for now, wpa3 support on the roadmap)",
							MarkdownDescription: "For dynamic PSK where we get per_user PSK from Radius. dynamic_psk allows PSK to be selected at runtime depending on context (wlan/site/user/...) thus following configurations are assumed (currently)\n  * PSK will come from RADIUS server\n  * AP sends client MAC as username and password (i.e. `enable_mac_auth` is assumed)\n  * AP sends BSSID:SSID as Caller-Station-ID\n  * `auth_servers` is required\n  * PSK will come from cloud WLC if source is cloud_psks\n  * default_psk will be used if cloud WLC is not available\n  * `multi_psk_only` and `psk` is ignored\n  * `pairwise` can only be wpa2-ccmp (for now, wpa3 support on the roadmap)",
						},
						"dynamic_vlan": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"default_vlan_ids": schema.ListAttribute{
									ElementType:         types.StringType,
									Computed:            true,
									Description:         "Default VLAN ID(s) can be a number, a range of VLAN IDs, a variable or multiple numbers, ranges or variables as a VLAN pool. Default VLAN as a pool of VLANS requires 0.14.x or newer firmware",
									MarkdownDescription: "Default VLAN ID(s) can be a number, a range of VLAN IDs, a variable or multiple numbers, ranges or variables as a VLAN pool. Default VLAN as a pool of VLANS requires 0.14.x or newer firmware",
								},
								"enabled": schema.BoolAttribute{
									Computed:            true,
									Description:         "Requires `vlan_enabled`==`true` to be set to `true`. Whether to enable dynamic vlan",
									MarkdownDescription: "Requires `vlan_enabled`==`true` to be set to `true`. Whether to enable dynamic vlan",
								},
								"local_vlan_ids": schema.ListAttribute{
									ElementType:         types.StringType,
									Computed:            true,
									Description:         "VLAN_ids to be locally bridged",
									MarkdownDescription: "VLAN_ids to be locally bridged",
								},
								"type": schema.StringAttribute{
									Computed:            true,
									Description:         "standard (using Tunnel-Private-Group-ID, widely supported), airespace-interface-name (Airespace/Cisco). enum: `airespace-interface-name`, `standard`",
									MarkdownDescription: "standard (using Tunnel-Private-Group-ID, widely supported), airespace-interface-name (Airespace/Cisco). enum: `airespace-interface-name`, `standard`",
								},
								"vlans": schema.MapAttribute{
									ElementType:         types.StringType,
									Computed:            true,
									Description:         "Map between vlan_id (as string) to airespace interface names (comma-separated) or null for stndard mapping\n  * if `dynamic_vlan.type`==`standard`, property key is the Vlan ID and property value is \\\"\\\"\n  * if `dynamic_vlan.type`==`airespace-interface-name`, property key is the Vlan ID and property value is the Airespace Interface Name",
									MarkdownDescription: "Map between vlan_id (as string) to airespace interface names (comma-separated) or null for stndard mapping\n  * if `dynamic_vlan.type`==`standard`, property key is the Vlan ID and property value is \\\"\\\"\n  * if `dynamic_vlan.type`==`airespace-interface-name`, property key is the Vlan ID and property value is the Airespace Interface Name",
								},
							},
							CustomType: DynamicVlanType{
								ObjectType: types.ObjectType{
									AttrTypes: DynamicVlanValue{}.AttributeTypes(ctx),
								},
							},
							Computed:            true,
							Description:         "For 802.1x",
							MarkdownDescription: "For 802.1x",
						},
						"enable_local_keycaching": schema.BoolAttribute{
							Computed:            true,
							Description:         "Enable AP-AP keycaching via multicast",
							MarkdownDescription: "Enable AP-AP keycaching via multicast",
						},
						"enable_wireless_bridging": schema.BoolAttribute{
							Computed:            true,
							Description:         "By default, we'd inspect all DHCP packets and drop those unrelated to the wireless client itself in the case where client is a wireless bridge (DHCP packets for other MACs will need to be orwarded), wireless_bridging can be enabled",
							MarkdownDescription: "By default, we'd inspect all DHCP packets and drop those unrelated to the wireless client itself in the case where client is a wireless bridge (DHCP packets for other MACs will need to be orwarded), wireless_bridging can be enabled",
						},
						"enable_wireless_bridging_dhcp_tracking": schema.BoolAttribute{
							Computed:            true,
							Description:         "If the client bridge is doing DHCP on behalf of other devices (L2-NAT), enable dhcp_tracking will cut down DHCP response packets to be forwarded to wireless",
							MarkdownDescription: "If the client bridge is doing DHCP on behalf of other devices (L2-NAT), enable dhcp_tracking will cut down DHCP response packets to be forwarded to wireless",
						},
						"enabled": schema.BoolAttribute{
							Computed:            true,
							Description:         "If this wlan is enabled",
							MarkdownDescription: "If this wlan is enabled",
						},
						"fast_dot1x_timers": schema.BoolAttribute{
							Computed:            true,
							Description:         "If set to true, sets default fast-timers with values calculated from ‘auth_servers_timeout’ and ‘auth_server_retries’ .",
							MarkdownDescription: "If set to true, sets default fast-timers with values calculated from ‘auth_servers_timeout’ and ‘auth_server_retries’ .",
						},
						"hide_ssid": schema.BoolAttribute{
							Computed:            true,
							Description:         "Whether to hide SSID in beacon",
							MarkdownDescription: "Whether to hide SSID in beacon",
						},
						"hostname_ie": schema.BoolAttribute{
							Computed:            true,
							Description:         "Include hostname inside IE in AP beacons / probe responses",
							MarkdownDescription: "Include hostname inside IE in AP beacons / probe responses",
						},
						"hotspot20": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"domain_name": schema.ListAttribute{
									ElementType: types.StringType,
									Computed:    true,
								},
								"enabled": schema.BoolAttribute{
									Computed:            true,
									Description:         "Whether to enable hotspot 2.0 config",
									MarkdownDescription: "Whether to enable hotspot 2.0 config",
								},
								"nai_realms": schema.ListAttribute{
									ElementType: types.StringType,
									Computed:    true,
								},
								"operators": schema.ListAttribute{
									ElementType:         types.StringType,
									Computed:            true,
									Description:         "List of operators to support",
									MarkdownDescription: "List of operators to support",
								},
								"rcoi": schema.ListAttribute{
									ElementType: types.StringType,
									Computed:    true,
								},
								"venue_name": schema.StringAttribute{
									Computed:            true,
									Description:         "Venue name, default is site name",
									MarkdownDescription: "Venue name, default is site name",
								},
							},
							CustomType: Hotspot20Type{
								ObjectType: types.ObjectType{
									AttrTypes: Hotspot20Value{}.AttributeTypes(ctx),
								},
							},
							Computed:            true,
							Description:         "Hostspot 2.0 wlan settings",
							MarkdownDescription: "Hostspot 2.0 wlan settings",
						},
						"id": schema.StringAttribute{
							Computed:            true,
							Description:         "Unique ID of the object instance in the Mist Organnization",
							MarkdownDescription: "Unique ID of the object instance in the Mist Organnization",
						},
						"inject_dhcp_option_82": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"circuit_id": schema.StringAttribute{
									Computed:            true,
									Description:         "Information to set in the `circuit_id` field of the DHCP Option 82. It is possible to use static string or the following variables (e.g. `{{SSID}}:{{AP_MAC}}`):\n  * {{AP_MAC}}\n  * {{AP_MAC_DASHED}}\n  * {{AP_MODEL}}\n  * {{AP_NAME}}\n  * {{SITE_NAME}}\n  * {{SSID}}",
									MarkdownDescription: "Information to set in the `circuit_id` field of the DHCP Option 82. It is possible to use static string or the following variables (e.g. `{{SSID}}:{{AP_MAC}}`):\n  * {{AP_MAC}}\n  * {{AP_MAC_DASHED}}\n  * {{AP_MODEL}}\n  * {{AP_NAME}}\n  * {{SITE_NAME}}\n  * {{SSID}}",
								},
								"enabled": schema.BoolAttribute{
									Computed:            true,
									Description:         "Whether to inject option 82 when forwarding DHCP packets",
									MarkdownDescription: "Whether to inject option 82 when forwarding DHCP packets",
								},
							},
							CustomType: InjectDhcpOption82Type{
								ObjectType: types.ObjectType{
									AttrTypes: InjectDhcpOption82Value{}.AttributeTypes(ctx),
								},
							},
							Computed: true,
						},
						"interface": schema.StringAttribute{
							Computed:            true,
							Description:         "where this WLAN will be connected to. enum: `all`, `eth0`, `eth1`, `eth2`, `eth3`, `mxtunnel`, `site_mxedge`, `wxtunnel`",
							MarkdownDescription: "where this WLAN will be connected to. enum: `all`, `eth0`, `eth1`, `eth2`, `eth3`, `mxtunnel`, `site_mxedge`, `wxtunnel`",
						},
						"isolation": schema.BoolAttribute{
							Computed:            true,
							Description:         "Whether to stop clients to talk to each other",
							MarkdownDescription: "Whether to stop clients to talk to each other",
						},
						"l2_isolation": schema.BoolAttribute{
							Computed:            true,
							Description:         "If isolation is enabled, whether to deny clients to talk to L2 on the LAN",
							MarkdownDescription: "If isolation is enabled, whether to deny clients to talk to L2 on the LAN",
						},
						"legacy_overds": schema.BoolAttribute{
							Computed:            true,
							Description:         "Legacy devices requires the Over-DS (for Fast BSS Transition) bit set (while our chip doesn’t support it). Warning! Enabling this will cause problem for iOS devices.",
							MarkdownDescription: "Legacy devices requires the Over-DS (for Fast BSS Transition) bit set (while our chip doesn’t support it). Warning! Enabling this will cause problem for iOS devices.",
						},
						"limit_bcast": schema.BoolAttribute{
							Computed:            true,
							Description:         "Whether to limit broadcast packets going to wireless (i.e. only allow certain bcast packets to go through)",
							MarkdownDescription: "Whether to limit broadcast packets going to wireless (i.e. only allow certain bcast packets to go through)",
						},
						"limit_probe_response": schema.BoolAttribute{
							Computed:            true,
							Description:         "Limit probe response base on some heuristic rules",
							MarkdownDescription: "Limit probe response base on some heuristic rules",
						},
						"max_idletime": schema.Int64Attribute{
							Computed:            true,
							Description:         "Max idle time in seconds",
							MarkdownDescription: "Max idle time in seconds",
						},
						"max_num_clients": schema.Int64Attribute{
							Computed:            true,
							Description:         "Maximum number of client connected to the SSID. `0` means unlimited",
							MarkdownDescription: "Maximum number of client connected to the SSID. `0` means unlimited",
						},
						"mist_nac": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"enabled": schema.BoolAttribute{
									Computed:            true,
									Description:         "When enabled:\n  * `auth_servers` is ignored\n  * `acct_servers` is ignored\n  * `auth_servers_*` are ignored\n  * `coa_servers` is ignored\n  * `radsec` is ignored\n  * `coa_enabled` is assumed",
									MarkdownDescription: "When enabled:\n  * `auth_servers` is ignored\n  * `acct_servers` is ignored\n  * `auth_servers_*` are ignored\n  * `coa_servers` is ignored\n  * `radsec` is ignored\n  * `coa_enabled` is assumed",
								},
							},
							CustomType: MistNacType{
								ObjectType: types.ObjectType{
									AttrTypes: MistNacValue{}.AttributeTypes(ctx),
								},
							},
							Computed: true,
						},
						"modified_time": schema.Float64Attribute{
							Computed:            true,
							Description:         "When the object has been modified for the last time, in epoch",
							MarkdownDescription: "When the object has been modified for the last time, in epoch",
						},
						"msp_id": schema.StringAttribute{
							Computed: true,
						},
						"mxtunnel_ids": schema.ListAttribute{
							ElementType:         types.StringType,
							Computed:            true,
							Description:         "When `interface`=`mxtunnel`, id of the Mist Tunnel",
							MarkdownDescription: "When `interface`=`mxtunnel`, id of the Mist Tunnel",
						},
						"mxtunnel_name": schema.ListAttribute{
							ElementType:         types.StringType,
							Computed:            true,
							Description:         "When `interface`=`site_medge`, name of the mxtunnel that in mxtunnels under Site Setting",
							MarkdownDescription: "When `interface`=`site_medge`, name of the mxtunnel that in mxtunnels under Site Setting",
						},
						"no_static_dns": schema.BoolAttribute{
							Computed:            true,
							Description:         "Whether to only allow client to use DNS that we’ve learned from DHCP response",
							MarkdownDescription: "Whether to only allow client to use DNS that we’ve learned from DHCP response",
						},
						"no_static_ip": schema.BoolAttribute{
							Computed:            true,
							Description:         "Whether to only allow client that we’ve learned from DHCP exchange to talk",
							MarkdownDescription: "Whether to only allow client that we’ve learned from DHCP exchange to talk",
						},
						"org_id": schema.StringAttribute{
							Computed: true,
						},
						"portal": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"allow_wlan_id_roam": schema.BoolAttribute{
									Computed:            true,
									Description:         "Optional if `amazon_enabled`==`true`. Whether to allow guest to connect to other Guest WLANs (with different `WLAN.ssid`) of same org without reauthentication (disable random_mac for seamless roaming)",
									MarkdownDescription: "Optional if `amazon_enabled`==`true`. Whether to allow guest to connect to other Guest WLANs (with different `WLAN.ssid`) of same org without reauthentication (disable random_mac for seamless roaming)",
								},
								"amazon_client_id": schema.StringAttribute{
									Computed:            true,
									Description:         "Optional if `amazon_enabled`==`true`. Amazon OAuth2 client id. This is optional. If not provided, it will use a default one.",
									MarkdownDescription: "Optional if `amazon_enabled`==`true`. Amazon OAuth2 client id. This is optional. If not provided, it will use a default one.",
								},
								"amazon_client_secret": schema.StringAttribute{
									Computed:            true,
									Description:         "Optional if `amazon_enabled`==`true`. Amazon OAuth2 client secret. If amazon_client_id was provided, provide a correspoinding value. Else leave blank.",
									MarkdownDescription: "Optional if `amazon_enabled`==`true`. Amazon OAuth2 client secret. If amazon_client_id was provided, provide a correspoinding value. Else leave blank.",
								},
								"amazon_email_domains": schema.ListAttribute{
									ElementType:         types.StringType,
									Computed:            true,
									Description:         "Optional if `amazon_enabled`==`true`. Matches authenticated user email against provided domains. If null or [], all authenticated emails will be allowed.",
									MarkdownDescription: "Optional if `amazon_enabled`==`true`. Matches authenticated user email against provided domains. If null or [], all authenticated emails will be allowed.",
								},
								"amazon_enabled": schema.BoolAttribute{
									Computed:            true,
									Description:         "Whether amazon is enabled as a login method",
									MarkdownDescription: "Whether amazon is enabled as a login method",
								},
								"amazon_expire": schema.Int64Attribute{
									Computed:            true,
									Description:         "Optional if `amazon_enabled`==`true`. Interval for which guest remains authorized using amazon auth (in minutes), if not provided, uses expire`",
									MarkdownDescription: "Optional if `amazon_enabled`==`true`. Interval for which guest remains authorized using amazon auth (in minutes), if not provided, uses expire`",
								},
								"auth": schema.StringAttribute{
									Computed:            true,
									Description:         "authentication scheme. enum: `amazon`, `azure`, `email`, `external`, `facebook`, `google`, `microsoft`, `multi`, `none`, `password`, `sponsor`, `sso`",
									MarkdownDescription: "authentication scheme. enum: `amazon`, `azure`, `email`, `external`, `facebook`, `google`, `microsoft`, `multi`, `none`, `password`, `sponsor`, `sso`",
								},
								"azure_client_id": schema.StringAttribute{
									Computed:            true,
									Description:         "Required if `azure_enabled`==`true`. Azure active directory app client id",
									MarkdownDescription: "Required if `azure_enabled`==`true`. Azure active directory app client id",
								},
								"azure_client_secret": schema.StringAttribute{
									Computed:            true,
									Description:         "Required if `azure_enabled`==`true`. Azure active directory app client secret",
									MarkdownDescription: "Required if `azure_enabled`==`true`. Azure active directory app client secret",
								},
								"azure_enabled": schema.BoolAttribute{
									Computed:            true,
									Description:         "Whether Azure Active Directory is enabled as a login method",
									MarkdownDescription: "Whether Azure Active Directory is enabled as a login method",
								},
								"azure_expire": schema.Int64Attribute{
									Computed:            true,
									Description:         "Interval for which guest remains authorized using azure auth (in minutes), if not provided, uses expire`",
									MarkdownDescription: "Interval for which guest remains authorized using azure auth (in minutes), if not provided, uses expire`",
								},
								"azure_tenant_id": schema.StringAttribute{
									Computed:            true,
									Description:         "Required if `azure_enabled`==`true`. Azure active directory tenant id.",
									MarkdownDescription: "Required if `azure_enabled`==`true`. Azure active directory tenant id.",
								},
								"broadnet_password": schema.StringAttribute{
									Computed:            true,
									Sensitive:           true,
									Description:         "Required if `sms_provider`==`broadnet`",
									MarkdownDescription: "Required if `sms_provider`==`broadnet`",
								},
								"broadnet_sid": schema.StringAttribute{
									Computed:            true,
									Description:         "Required if `sms_provider`==`broadnet`",
									MarkdownDescription: "Required if `sms_provider`==`broadnet`",
								},
								"broadnet_user_id": schema.StringAttribute{
									Computed:            true,
									Description:         "Required if `sms_provider`==`broadnet`",
									MarkdownDescription: "Required if `sms_provider`==`broadnet`",
								},
								"bypass_when_cloud_down": schema.BoolAttribute{
									Computed:            true,
									Description:         "Whether to bypass the guest portal when cloud not reachable (and apply the default policies)",
									MarkdownDescription: "Whether to bypass the guest portal when cloud not reachable (and apply the default policies)",
								},
								"clickatell_api_key": schema.StringAttribute{
									Computed:            true,
									Description:         "Required if `sms_provider`==`clickatell`",
									MarkdownDescription: "Required if `sms_provider`==`clickatell`",
								},
								"cross_site": schema.BoolAttribute{
									Computed:            true,
									Description:         "Whether to allow guest to roam between WLANs (with same `WLAN.ssid`, regardless of variables) of different sites of same org without reauthentication (disable random_mac for seamless roaming)",
									MarkdownDescription: "Whether to allow guest to roam between WLANs (with same `WLAN.ssid`, regardless of variables) of different sites of same org without reauthentication (disable random_mac for seamless roaming)",
								},
								"email_enabled": schema.BoolAttribute{
									Computed:            true,
									Description:         "Whether email (access code verification) is enabled as a login method",
									MarkdownDescription: "Whether email (access code verification) is enabled as a login method",
								},
								"enabled": schema.BoolAttribute{
									Computed:            true,
									Description:         "Whether guest portal is enabled",
									MarkdownDescription: "Whether guest portal is enabled",
								},
								"expire": schema.Int64Attribute{
									Computed:            true,
									Description:         "How long to remain authorized, in minutes",
									MarkdownDescription: "How long to remain authorized, in minutes",
								},
								"external_portal_url": schema.StringAttribute{
									Computed:            true,
									Description:         "Required if `wlan_portal_auth`==`external`. External portal URL (e.g. https://host/url) where we can append our query parameters to",
									MarkdownDescription: "Required if `wlan_portal_auth`==`external`. External portal URL (e.g. https://host/url) where we can append our query parameters to",
								},
								"facebook_client_id": schema.StringAttribute{
									Computed:            true,
									Description:         "Required if `facebook_enabled`==`true`. Facebook OAuth2 app id. This is optional. If not provided, it will use a default one.",
									MarkdownDescription: "Required if `facebook_enabled`==`true`. Facebook OAuth2 app id. This is optional. If not provided, it will use a default one.",
								},
								"facebook_client_secret": schema.StringAttribute{
									Computed:            true,
									Description:         "Required if `facebook_enabled`==`true`. Facebook OAuth2 app secret. If facebook_client_id was provided, provide a correspoinding value. Else leave blank.",
									MarkdownDescription: "Required if `facebook_enabled`==`true`. Facebook OAuth2 app secret. If facebook_client_id was provided, provide a correspoinding value. Else leave blank.",
								},
								"facebook_email_domains": schema.ListAttribute{
									ElementType:         types.StringType,
									Computed:            true,
									Description:         "Optional if `facebook_enabled`==`true`. Matches authenticated user email against provided domains. If null or [], all authenticated emails will be allowed.",
									MarkdownDescription: "Optional if `facebook_enabled`==`true`. Matches authenticated user email against provided domains. If null or [], all authenticated emails will be allowed.",
								},
								"facebook_enabled": schema.BoolAttribute{
									Computed:            true,
									Description:         "Whether facebook is enabled as a login method",
									MarkdownDescription: "Whether facebook is enabled as a login method",
								},
								"facebook_expire": schema.Int64Attribute{
									Computed:            true,
									Description:         "Optional if `facebook_enabled`==`true`. Interval for which guest remains authorized using facebook auth (in minutes), if not provided, uses expire`",
									MarkdownDescription: "Optional if `facebook_enabled`==`true`. Interval for which guest remains authorized using facebook auth (in minutes), if not provided, uses expire`",
								},
								"forward": schema.BoolAttribute{
									Computed:            true,
									Description:         "Whether to forward the user to another URL after authorized",
									MarkdownDescription: "Whether to forward the user to another URL after authorized",
								},
								"forward_url": schema.StringAttribute{
									Computed:            true,
									Description:         "URL to forward the user to",
									MarkdownDescription: "URL to forward the user to",
								},
								"google_client_id": schema.StringAttribute{
									Computed:            true,
									Description:         "Google OAuth2 app id. This is optional. If not provided, it will use a default one.",
									MarkdownDescription: "Google OAuth2 app id. This is optional. If not provided, it will use a default one.",
								},
								"google_client_secret": schema.StringAttribute{
									Computed:            true,
									Description:         "Optional if `google_enabled`==`true`. Google OAuth2 app secret. If google_client_id was provided, provide a correspoinding value. Else leave blank.",
									MarkdownDescription: "Optional if `google_enabled`==`true`. Google OAuth2 app secret. If google_client_id was provided, provide a correspoinding value. Else leave blank.",
								},
								"google_email_domains": schema.ListAttribute{
									ElementType:         types.StringType,
									Computed:            true,
									Description:         "Optional if `google_enabled`==`true`. Matches authenticated user email against provided domains. If null or [], all authenticated emails will be allowed.",
									MarkdownDescription: "Optional if `google_enabled`==`true`. Matches authenticated user email against provided domains. If null or [], all authenticated emails will be allowed.",
								},
								"google_enabled": schema.BoolAttribute{
									Computed:            true,
									Description:         "Whether Google is enabled as login method",
									MarkdownDescription: "Whether Google is enabled as login method",
								},
								"google_expire": schema.Int64Attribute{
									Computed:            true,
									Description:         "Optional if `google_enabled`==`true`. Interval for which guest remains authorized using Google Auth (in minutes), if not provided, uses expire`",
									MarkdownDescription: "Optional if `google_enabled`==`true`. Interval for which guest remains authorized using Google Auth (in minutes), if not provided, uses expire`",
								},
								"gupshup_password": schema.StringAttribute{
									Computed:            true,
									Sensitive:           true,
									Description:         "Required if `sms_provider`==`gupshup`",
									MarkdownDescription: "Required if `sms_provider`==`gupshup`",
								},
								"gupshup_userid": schema.StringAttribute{
									Computed:            true,
									Description:         "Required if `sms_provider`==`gupshup`",
									MarkdownDescription: "Required if `sms_provider`==`gupshup`",
								},
								"microsoft_client_id": schema.StringAttribute{
									Computed:            true,
									Description:         "Optional if `microsoft_enabled`==`true`. Microsoft 365 OAuth2 client id. This is optional. If not provided, it will use a default one.",
									MarkdownDescription: "Optional if `microsoft_enabled`==`true`. Microsoft 365 OAuth2 client id. This is optional. If not provided, it will use a default one.",
								},
								"microsoft_client_secret": schema.StringAttribute{
									Computed:            true,
									Description:         "Optional if `microsoft_enabled`==`true`. Microsoft 365 OAuth2 client secret. If microsoft_client_id was provided, provide a correspoinding value. Else leave blank.",
									MarkdownDescription: "Optional if `microsoft_enabled`==`true`. Microsoft 365 OAuth2 client secret. If microsoft_client_id was provided, provide a correspoinding value. Else leave blank.",
								},
								"microsoft_email_domains": schema.ListAttribute{
									ElementType:         types.StringType,
									Computed:            true,
									Description:         "Optional if `microsoft_enabled`==`true`. Matches authenticated user email against provided domains. If null or [], all authenticated emails will be allowed.",
									MarkdownDescription: "Optional if `microsoft_enabled`==`true`. Matches authenticated user email against provided domains. If null or [], all authenticated emails will be allowed.",
								},
								"microsoft_enabled": schema.BoolAttribute{
									Computed:            true,
									Description:         "Whether microsoft 365 is enabled as a login method",
									MarkdownDescription: "Whether microsoft 365 is enabled as a login method",
								},
								"microsoft_expire": schema.Int64Attribute{
									Computed:            true,
									Description:         "Optional if `microsoft_enabled`==`true`. Interval for which guest remains authorized using microsoft auth (in minutes), if not provided, uses expire`",
									MarkdownDescription: "Optional if `microsoft_enabled`==`true`. Interval for which guest remains authorized using microsoft auth (in minutes), if not provided, uses expire`",
								},
								"passphrase_enabled": schema.BoolAttribute{
									Computed:            true,
									Description:         "Whether password is enabled",
									MarkdownDescription: "Whether password is enabled",
								},
								"passphrase_expire": schema.Int64Attribute{
									Computed:            true,
									Description:         "Optional if `passphrase_enabled`==`true`. Interval for which guest remains authorized using passphrase auth (in minutes), if not provided, uses `expire`",
									MarkdownDescription: "Optional if `passphrase_enabled`==`true`. Interval for which guest remains authorized using passphrase auth (in minutes), if not provided, uses `expire`",
								},
								"password": schema.StringAttribute{
									Computed:            true,
									Sensitive:           true,
									Description:         "Required if `passphrase_enabled`==`true`.",
									MarkdownDescription: "Required if `passphrase_enabled`==`true`.",
								},
								"predefined_sponsors_enabled": schema.BoolAttribute{
									Computed:            true,
									Description:         "Whether to show list of sponsor emails mentioned in `sponsors` object as a dropdown. If both `sponsor_notify_all` and `predefined_sponsors_enabled` are false, behaviour is acc to `sponsor_email_domains`",
									MarkdownDescription: "Whether to show list of sponsor emails mentioned in `sponsors` object as a dropdown. If both `sponsor_notify_all` and `predefined_sponsors_enabled` are false, behaviour is acc to `sponsor_email_domains`",
								},
								"predefined_sponsors_hide_email": schema.BoolAttribute{
									Computed:            true,
									Description:         "Whether to hide sponsor’s email from list of sponsors",
									MarkdownDescription: "Whether to hide sponsor’s email from list of sponsors",
								},
								"privacy": schema.BoolAttribute{
									Computed: true,
								},
								"puzzel_password": schema.StringAttribute{
									Computed:            true,
									Sensitive:           true,
									Description:         "Required if `sms_provider`==`puzzel`",
									MarkdownDescription: "Required if `sms_provider`==`puzzel`",
								},
								"puzzel_service_id": schema.StringAttribute{
									Computed:            true,
									Description:         "Required if `sms_provider`==`puzzel`",
									MarkdownDescription: "Required if `sms_provider`==`puzzel`",
								},
								"puzzel_username": schema.StringAttribute{
									Computed:            true,
									Description:         "Required if `sms_provider`==`puzzel`",
									MarkdownDescription: "Required if `sms_provider`==`puzzel`",
								},
								"sms_enabled": schema.BoolAttribute{
									Computed:            true,
									Description:         "Whether sms is enabled as a login method",
									MarkdownDescription: "Whether sms is enabled as a login method",
								},
								"sms_expire": schema.Int64Attribute{
									Computed:            true,
									Description:         "Optional if `sms_enabled`==`true`. Interval for which guest remains authorized using sms auth (in minutes), if not provided, uses expire`",
									MarkdownDescription: "Optional if `sms_enabled`==`true`. Interval for which guest remains authorized using sms auth (in minutes), if not provided, uses expire`",
								},
								"sms_message_format": schema.StringAttribute{
									Computed:            true,
									Description:         "Optional if `sms_enabled`==`true`. SMS Message format",
									MarkdownDescription: "Optional if `sms_enabled`==`true`. SMS Message format",
								},
								"sms_provider": schema.StringAttribute{
									Computed:            true,
									Description:         "Optioanl if `sms_enabled`==`true`. enum: `broadnet`, `clickatell`, `gupshup`, `manual`, `puzzel`, `telstra`, `twilio`",
									MarkdownDescription: "Optioanl if `sms_enabled`==`true`. enum: `broadnet`, `clickatell`, `gupshup`, `manual`, `puzzel`, `telstra`, `twilio`",
								},
								"sponsor_auto_approve": schema.BoolAttribute{
									Computed:            true,
									Description:         "Optional if `sponsor_enabled`==`true`. Whether to automatically approve guest and allow sponsor to revoke guest access, needs predefined_sponsors_enabled enabled and sponsor_notify_all disabled",
									MarkdownDescription: "Optional if `sponsor_enabled`==`true`. Whether to automatically approve guest and allow sponsor to revoke guest access, needs predefined_sponsors_enabled enabled and sponsor_notify_all disabled",
								},
								"sponsor_email_domains": schema.ListAttribute{
									ElementType:         types.StringType,
									Computed:            true,
									Description:         "List of domain allowed for sponsor email. Required if `sponsor_enabled` is `true` and `sponsors` is empty.",
									MarkdownDescription: "List of domain allowed for sponsor email. Required if `sponsor_enabled` is `true` and `sponsors` is empty.",
								},
								"sponsor_enabled": schema.BoolAttribute{
									Computed:            true,
									Description:         "Whether sponsor is enabled",
									MarkdownDescription: "Whether sponsor is enabled",
								},
								"sponsor_expire": schema.Int64Attribute{
									Computed:            true,
									Description:         "Optional if `sponsor_enabled`==`true`. Interval for which guest remains authorized using sponsor auth (in minutes), if not provided, uses expire`",
									MarkdownDescription: "Optional if `sponsor_enabled`==`true`. Interval for which guest remains authorized using sponsor auth (in minutes), if not provided, uses expire`",
								},
								"sponsor_link_validity_duration": schema.StringAttribute{
									Computed:            true,
									Description:         "Optional if `sponsor_enabled`==`true`. How long to remain valid sponsored guest request approve/deny link received in email, in minutes.",
									MarkdownDescription: "Optional if `sponsor_enabled`==`true`. How long to remain valid sponsored guest request approve/deny link received in email, in minutes.",
								},
								"sponsor_notify_all": schema.BoolAttribute{
									Computed:            true,
									Description:         "Optional if `sponsor_enabled`==`true`. whether to notify all sponsors that are mentioned in `sponsors` object. Both `sponsor_notify_all` and `predefined_sponsors_enabled` should be true in order to notify sponsors. If true, email sent to 10 sponsors in no particular order.",
									MarkdownDescription: "Optional if `sponsor_enabled`==`true`. whether to notify all sponsors that are mentioned in `sponsors` object. Both `sponsor_notify_all` and `predefined_sponsors_enabled` should be true in order to notify sponsors. If true, email sent to 10 sponsors in no particular order.",
								},
								"sponsor_status_notify": schema.BoolAttribute{
									Computed:            true,
									Description:         "Optional if `sponsor_enabled`==`true`. If enabled, guest will get email about sponsor's action (approve/deny)",
									MarkdownDescription: "Optional if `sponsor_enabled`==`true`. If enabled, guest will get email about sponsor's action (approve/deny)",
								},
								"sponsors": schema.MapAttribute{
									ElementType:         types.StringType,
									Computed:            true,
									Description:         "object of allowed sponsors email with name. Required if `sponsor_enabled`\n            is `true` and `sponsor_email_domains` is empty.\n\n            Property key is the sponsor email, Property value is the sponsor name",
									MarkdownDescription: "object of allowed sponsors email with name. Required if `sponsor_enabled`\n            is `true` and `sponsor_email_domains` is empty.\n\n            Property key is the sponsor email, Property value is the sponsor name",
								},
								"sso_default_role": schema.StringAttribute{
									Computed:            true,
									Description:         "Optionl if `wlan_portal_auth`==`sso`, default role to assign if there’s no match. By default, an assertion is treated as invalid when there’s no role matched",
									MarkdownDescription: "Optionl if `wlan_portal_auth`==`sso`, default role to assign if there’s no match. By default, an assertion is treated as invalid when there’s no role matched",
								},
								"sso_forced_role": schema.StringAttribute{
									Computed:            true,
									Description:         "Optionl if `wlan_portal_auth`==`sso`",
									MarkdownDescription: "Optionl if `wlan_portal_auth`==`sso`",
								},
								"sso_idp_cert": schema.StringAttribute{
									Computed:            true,
									Description:         "Required if `wlan_portal_auth`==`sso`. IDP Cert (used to verify the signed response)",
									MarkdownDescription: "Required if `wlan_portal_auth`==`sso`. IDP Cert (used to verify the signed response)",
								},
								"sso_idp_sign_algo": schema.StringAttribute{
									Computed:            true,
									Description:         "Optioanl if `wlan_portal_auth`==`sso`, Signing algorithm for SAML Assertion. enum: `sha1`, `sha256`, `sha384`, `sha512`",
									MarkdownDescription: "Optioanl if `wlan_portal_auth`==`sso`, Signing algorithm for SAML Assertion. enum: `sha1`, `sha256`, `sha384`, `sha512`",
								},
								"sso_idp_sso_url": schema.StringAttribute{
									Computed:            true,
									Description:         "Required if `wlan_portal_auth`==`sso`, IDP Single-Sign-On URL",
									MarkdownDescription: "Required if `wlan_portal_auth`==`sso`, IDP Single-Sign-On URL",
								},
								"sso_issuer": schema.StringAttribute{
									Computed:            true,
									Description:         "Required if `wlan_portal_auth`==`sso`, IDP issuer URL",
									MarkdownDescription: "Required if `wlan_portal_auth`==`sso`, IDP issuer URL",
								},
								"sso_nameid_format": schema.StringAttribute{
									Computed:            true,
									Description:         "Optional if `wlan_portal_auth`==`sso`. enum: `email`, `unspecified`",
									MarkdownDescription: "Optional if `wlan_portal_auth`==`sso`. enum: `email`, `unspecified`",
								},
								"telstra_client_id": schema.StringAttribute{
									Computed:            true,
									Description:         "Required if `sms_provider`==`telstra`, Client ID provided by Telstra",
									MarkdownDescription: "Required if `sms_provider`==`telstra`, Client ID provided by Telstra",
								},
								"telstra_client_secret": schema.StringAttribute{
									Computed:            true,
									Description:         "Required if `sms_provider`==`telstra`, Client secret provided by Telstra",
									MarkdownDescription: "Required if `sms_provider`==`telstra`, Client secret provided by Telstra",
								},
								"twilio_auth_token": schema.StringAttribute{
									Computed:            true,
									Description:         "Required if `sms_provider`==`twilio`, Auth token account with twilio account",
									MarkdownDescription: "Required if `sms_provider`==`twilio`, Auth token account with twilio account",
								},
								"twilio_phone_number": schema.StringAttribute{
									Computed:            true,
									Description:         "Required if `sms_provider`==`twilio`, Twilio phone number associated with the account. See example for accepted format.",
									MarkdownDescription: "Required if `sms_provider`==`twilio`, Twilio phone number associated with the account. See example for accepted format.",
								},
								"twilio_sid": schema.StringAttribute{
									Computed:            true,
									Description:         "Required if `sms_provider`==`twilio`, Account SID provided by Twilio",
									MarkdownDescription: "Required if `sms_provider`==`twilio`, Account SID provided by Twilio",
								},
							},
							CustomType: PortalType{
								ObjectType: types.ObjectType{
									AttrTypes: PortalValue{}.AttributeTypes(ctx),
								},
							},
							Computed:            true,
							Description:         "Portal wlan settings",
							MarkdownDescription: "Portal wlan settings",
						},
						"portal_allowed_hostnames": schema.ListAttribute{
							ElementType:         types.StringType,
							Computed:            true,
							Description:         "List of hostnames without http(s):// (matched by substring)",
							MarkdownDescription: "List of hostnames without http(s):// (matched by substring)",
						},
						"portal_allowed_subnets": schema.ListAttribute{
							ElementType:         types.StringType,
							Computed:            true,
							Description:         "List of CIDRs",
							MarkdownDescription: "List of CIDRs",
						},
						"portal_api_secret": schema.StringAttribute{
							Computed:            true,
							Description:         "APi secret (auto-generated) that can be used to sign guest authorization requests",
							MarkdownDescription: "APi secret (auto-generated) that can be used to sign guest authorization requests",
						},
						"portal_denied_hostnames": schema.ListAttribute{
							ElementType:         types.StringType,
							Computed:            true,
							Description:         "List of hostnames without http(s):// (matched by substring), this takes precedence over portal_allowed_hostnames",
							MarkdownDescription: "List of hostnames without http(s):// (matched by substring), this takes precedence over portal_allowed_hostnames",
						},
						"portal_image": schema.StringAttribute{
							Computed:            true,
							Description:         "Url of portal background image",
							MarkdownDescription: "Url of portal background image",
						},
						"portal_sso_url": schema.StringAttribute{
							Computed: true,
						},
						"qos": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"class": schema.StringAttribute{
									Computed:            true,
									Description:         "enum: `background`, `best_effort`, `video`, `voice`",
									MarkdownDescription: "enum: `background`, `best_effort`, `video`, `voice`",
								},
								"overwrite": schema.BoolAttribute{
									Computed:            true,
									Description:         "Whether to overwrite QoS",
									MarkdownDescription: "Whether to overwrite QoS",
								},
							},
							CustomType: QosType{
								ObjectType: types.ObjectType{
									AttrTypes: QosValue{}.AttributeTypes(ctx),
								},
							},
							Computed: true,
						},
						"radsec": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"coa_enabled": schema.BoolAttribute{
									Computed: true,
								},
								"enabled": schema.BoolAttribute{
									Computed: true,
								},
								"idle_timeout": schema.Int64Attribute{
									Computed: true,
								},
								"mxcluster_ids": schema.ListAttribute{
									ElementType:         types.StringType,
									Computed:            true,
									Description:         "To use Org mxedges when this WLAN does not use mxtunnel, specify their mxcluster_ids. Org mxedge(s) identified by mxcluster_ids",
									MarkdownDescription: "To use Org mxedges when this WLAN does not use mxtunnel, specify their mxcluster_ids. Org mxedge(s) identified by mxcluster_ids",
								},
								"proxy_hosts": schema.ListAttribute{
									ElementType:         types.StringType,
									Computed:            true,
									Description:         "Default is site.mxedge.radsec.proxy_hosts which must be a superset of all `wlans[*].radsec.proxy_hosts`. When `radsec.proxy_hosts` are not used, tunnel peers (org or site mxedges) are used irrespective of `use_site_mxedge`",
									MarkdownDescription: "Default is site.mxedge.radsec.proxy_hosts which must be a superset of all `wlans[*].radsec.proxy_hosts`. When `radsec.proxy_hosts` are not used, tunnel peers (org or site mxedges) are used irrespective of `use_site_mxedge`",
								},
								"server_name": schema.StringAttribute{
									Computed:            true,
									Description:         "Name of the server to verify (against the cacerts in Org Setting). Only if not Mist Edge.",
									MarkdownDescription: "Name of the server to verify (against the cacerts in Org Setting). Only if not Mist Edge.",
								},
								"servers": schema.ListNestedAttribute{
									NestedObject: schema.NestedAttributeObject{
										Attributes: map[string]schema.Attribute{
											"host": schema.StringAttribute{
												Computed: true,
											},
											"port": schema.Int64Attribute{
												Computed: true,
											},
										},
										CustomType: ServersType{
											ObjectType: types.ObjectType{
												AttrTypes: ServersValue{}.AttributeTypes(ctx),
											},
										},
									},
									Computed:            true,
									Description:         "List of RadSec Servers. Only if not Mist Edge.",
									MarkdownDescription: "List of RadSec Servers. Only if not Mist Edge.",
								},
								"use_mxedge": schema.BoolAttribute{
									Computed:            true,
									Description:         "use mxedge(s) as RadSec Proxy",
									MarkdownDescription: "use mxedge(s) as RadSec Proxy",
								},
								"use_site_mxedge": schema.BoolAttribute{
									Computed:            true,
									Description:         "To use Site mxedges when this WLAN does not use mxtunnel",
									MarkdownDescription: "To use Site mxedges when this WLAN does not use mxtunnel",
								},
							},
							CustomType: RadsecType{
								ObjectType: types.ObjectType{
									AttrTypes: RadsecValue{}.AttributeTypes(ctx),
								},
							},
							Computed:            true,
							Description:         "RadSec settings",
							MarkdownDescription: "RadSec settings",
						},
						"rateset": schema.MapNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"ht": schema.StringAttribute{
										Computed:            true,
										Description:         "If `template`==`custom`. MCS bitmasks for 4 streams (16-bit for each stream, MCS0 is least significant bit), e.g. 00ff 00f0 001f limits HT rates to MCS 0-7 for 1 stream, MCS 4-7 for 2 stream (i.e. MCS 12-15), MCS 1-5 for 3 stream (i.e. MCS 16-20)",
										MarkdownDescription: "If `template`==`custom`. MCS bitmasks for 4 streams (16-bit for each stream, MCS0 is least significant bit), e.g. 00ff 00f0 001f limits HT rates to MCS 0-7 for 1 stream, MCS 4-7 for 2 stream (i.e. MCS 12-15), MCS 1-5 for 3 stream (i.e. MCS 16-20)",
									},
									"legacy": schema.ListAttribute{
										ElementType:         types.StringType,
										Computed:            true,
										Description:         "If `template`==`custom`. List of supported rates (IE=1) and extended supported rates (IE=50) for custom template, append ‘b’ at the end to indicate a rate being basic/mandatory. If `template`==`custom` is configured and legacy does not define at least one basic rate, it will use `no-legacy` default values",
										MarkdownDescription: "If `template`==`custom`. List of supported rates (IE=1) and extended supported rates (IE=50) for custom template, append ‘b’ at the end to indicate a rate being basic/mandatory. If `template`==`custom` is configured and legacy does not define at least one basic rate, it will use `no-legacy` default values",
									},
									"min_rssi": schema.Int64Attribute{
										Computed:            true,
										Description:         "Minimum RSSI for client to connect, 0 means not enforcing",
										MarkdownDescription: "Minimum RSSI for client to connect, 0 means not enforcing",
									},
									"template": schema.StringAttribute{
										Computed:            true,
										Description:         "Data Rates template to apply. enum: \n  * `no-legacy`: no 11b\n  * `compatible`: all, like before, default setting that Broadcom/Atheros used\n  * `legacy-only`: disable 802.11n and 802.11ac\n  * `high-density`: no 11b, no low rates\n  * `custom`: user defined",
										MarkdownDescription: "Data Rates template to apply. enum: \n  * `no-legacy`: no 11b\n  * `compatible`: all, like before, default setting that Broadcom/Atheros used\n  * `legacy-only`: disable 802.11n and 802.11ac\n  * `high-density`: no 11b, no low rates\n  * `custom`: user defined",
									},
									"vht": schema.StringAttribute{
										Computed:            true,
										Description:         "If `template`==`custom`. MCS bitmasks for 4 streams (16-bit for each stream, MCS0 is least significant bit), e.g. 03ff 01ff 00ff limits VHT rates to MCS 0-9 for 1 stream, MCS 0-8 for 2 streams, and MCS 0-7 for 3 streams.",
										MarkdownDescription: "If `template`==`custom`. MCS bitmasks for 4 streams (16-bit for each stream, MCS0 is least significant bit), e.g. 03ff 01ff 00ff limits VHT rates to MCS 0-9 for 1 stream, MCS 0-8 for 2 streams, and MCS 0-7 for 3 streams.",
									},
								},
								CustomType: RatesetType{
									ObjectType: types.ObjectType{
										AttrTypes: RatesetValue{}.AttributeTypes(ctx),
									},
								},
							},
							Computed:            true,
							Description:         "Property key is the RF band. enum: `24`, `5`, `6`",
							MarkdownDescription: "Property key is the RF band. enum: `24`, `5`, `6`",
							Validators: []validator.Map{
								mapvalidator.SizeAtLeast(1),
							},
						},
						"reconnect_clients_when_roaming_mxcluster": schema.BoolAttribute{
							Computed:            true,
							Description:         "When different mxcluster is on different subnet, we'd want to disconnect clients (so they'll reconnect and get new IPs)",
							MarkdownDescription: "When different mxcluster is on different subnet, we'd want to disconnect clients (so they'll reconnect and get new IPs)",
						},
						"roam_mode": schema.StringAttribute{
							Computed:            true,
							Description:         "enum: `11r`, `OKC`, `NONE`",
							MarkdownDescription: "enum: `11r`, `OKC`, `NONE`",
						},
						"schedule": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"enabled": schema.BoolAttribute{
									Computed: true,
								},
								"hours": schema.SingleNestedAttribute{
									Attributes: map[string]schema.Attribute{
										"fri": schema.StringAttribute{
											Computed:            true,
											Description:         "Hour range of the day (e.g. `09:00-17:00`). If the hour is not defined then it's treated as 00:00-23:59.",
											MarkdownDescription: "Hour range of the day (e.g. `09:00-17:00`). If the hour is not defined then it's treated as 00:00-23:59.",
										},
										"mon": schema.StringAttribute{
											Computed:            true,
											Description:         "Hour range of the day (e.g. `09:00-17:00`). If the hour is not defined then it's treated as 00:00-23:59.",
											MarkdownDescription: "Hour range of the day (e.g. `09:00-17:00`). If the hour is not defined then it's treated as 00:00-23:59.",
										},
										"sat": schema.StringAttribute{
											Computed:            true,
											Description:         "Hour range of the day (e.g. `09:00-17:00`). If the hour is not defined then it's treated as 00:00-23:59.",
											MarkdownDescription: "Hour range of the day (e.g. `09:00-17:00`). If the hour is not defined then it's treated as 00:00-23:59.",
										},
										"sun": schema.StringAttribute{
											Computed:            true,
											Description:         "Hour range of the day (e.g. `09:00-17:00`). If the hour is not defined then it's treated as 00:00-23:59.",
											MarkdownDescription: "Hour range of the day (e.g. `09:00-17:00`). If the hour is not defined then it's treated as 00:00-23:59.",
										},
										"thu": schema.StringAttribute{
											Computed:            true,
											Description:         "Hour range of the day (e.g. `09:00-17:00`). If the hour is not defined then it's treated as 00:00-23:59.",
											MarkdownDescription: "Hour range of the day (e.g. `09:00-17:00`). If the hour is not defined then it's treated as 00:00-23:59.",
										},
										"tue": schema.StringAttribute{
											Computed:            true,
											Description:         "Hour range of the day (e.g. `09:00-17:00`). If the hour is not defined then it's treated as 00:00-23:59.",
											MarkdownDescription: "Hour range of the day (e.g. `09:00-17:00`). If the hour is not defined then it's treated as 00:00-23:59.",
										},
										"wed": schema.StringAttribute{
											Computed:            true,
											Description:         "Hour range of the day (e.g. `09:00-17:00`). If the hour is not defined then it's treated as 00:00-23:59.",
											MarkdownDescription: "Hour range of the day (e.g. `09:00-17:00`). If the hour is not defined then it's treated as 00:00-23:59.",
										},
									},
									CustomType: HoursType{
										ObjectType: types.ObjectType{
											AttrTypes: HoursValue{}.AttributeTypes(ctx),
										},
									},
									Computed:            true,
									Description:         "Days/Hours of operation filter, the available days (mon, tue, wed, thu, fri, sat, sun)",
									MarkdownDescription: "Days/Hours of operation filter, the available days (mon, tue, wed, thu, fri, sat, sun)",
								},
							},
							CustomType: ScheduleType{
								ObjectType: types.ObjectType{
									AttrTypes: ScheduleValue{}.AttributeTypes(ctx),
								},
							},
							Computed:            true,
							Description:         "WLAN operating schedule, default is disabled",
							MarkdownDescription: "WLAN operating schedule, default is disabled",
						},
						"sle_excluded": schema.BoolAttribute{
							Computed:            true,
							Description:         "Whether to exclude this WLAN from SLE metrics",
							MarkdownDescription: "Whether to exclude this WLAN from SLE metrics",
						},
						"ssid": schema.StringAttribute{
							Computed:            true,
							Description:         "Name of the SSID",
							MarkdownDescription: "Name of the SSID",
						},
						"template_id": schema.StringAttribute{
							Computed: true,
						},
						"use_eapol_v1": schema.BoolAttribute{
							Computed:            true,
							Description:         "If `auth.type`==`eap` or `auth.type`==`psk`, should only be set for legacy client, such as pre-2004, 802.11b devices",
							MarkdownDescription: "If `auth.type`==`eap` or `auth.type`==`psk`, should only be set for legacy client, such as pre-2004, 802.11b devices",
						},
						"vlan_enabled": schema.BoolAttribute{
							Computed:            true,
							Description:         "If vlan tagging is enabled",
							MarkdownDescription: "If vlan tagging is enabled",
						},
						"vlan_id": schema.StringAttribute{
							Computed: true,
						},
						"vlan_ids": schema.ListAttribute{
							ElementType:         types.StringType,
							Computed:            true,
							Description:         "if `vlan_enabled`==`true` and `vlan_pooling`==`true`. List of VLAN IDs (comma separeted) to be used in the VLAN Pool",
							MarkdownDescription: "if `vlan_enabled`==`true` and `vlan_pooling`==`true`. List of VLAN IDs (comma separeted) to be used in the VLAN Pool",
						},
						"vlan_pooling": schema.BoolAttribute{
							Computed:            true,
							Description:         "Requires `vlan_enabled`==`true` to be set to `true`. Vlan pooling allows AP to place client on different VLAN using a deterministic algorithm",
							MarkdownDescription: "Requires `vlan_enabled`==`true` to be set to `true`. Vlan pooling allows AP to place client on different VLAN using a deterministic algorithm",
						},
						"wlan_limit_down": schema.Int64Attribute{
							Computed:            true,
							Description:         "In kbps",
							MarkdownDescription: "In kbps",
						},
						"wlan_limit_down_enabled": schema.BoolAttribute{
							Computed:            true,
							Description:         "If downlink limiting for whole wlan is enabled",
							MarkdownDescription: "If downlink limiting for whole wlan is enabled",
						},
						"wlan_limit_up": schema.Int64Attribute{
							Computed:            true,
							Description:         "In kbps",
							MarkdownDescription: "In kbps",
						},
						"wlan_limit_up_enabled": schema.BoolAttribute{
							Computed:            true,
							Description:         "If uplink limiting for whole wlan is enabled",
							MarkdownDescription: "If uplink limiting for whole wlan is enabled",
						},
						"wxtag_ids": schema.ListAttribute{
							ElementType:         types.StringType,
							Computed:            true,
							Description:         "List of wxtag_ids",
							MarkdownDescription: "List of wxtag_ids",
						},
						"wxtunnel_id": schema.StringAttribute{
							Computed:            true,
							Description:         "When `interface`=`wxtunnel`, id of the WXLAN Tunnel",
							MarkdownDescription: "When `interface`=`wxtunnel`, id of the WXLAN Tunnel",
						},
						"wxtunnel_remote_id": schema.StringAttribute{
							Computed:            true,
							Description:         "When `interface`=`wxtunnel`, remote tunnel identifier",
							MarkdownDescription: "When `interface`=`wxtunnel`, remote tunnel identifier",
						},
					},
					CustomType: OrgWlansType{
						ObjectType: types.ObjectType{
							AttrTypes: OrgWlansValue{}.AttributeTypes(ctx),
						},
					},
				},
				Computed: true,
			},
		},
	}
}

type OrgWlansModel struct {
	OrgId    types.String `tfsdk:"org_id"`
	OrgWlans types.Set    `tfsdk:"org_wlans"`
}

var _ basetypes.ObjectTypable = OrgWlansType{}

type OrgWlansType struct {
	basetypes.ObjectType
}

func (t OrgWlansType) Equal(o attr.Type) bool {
	other, ok := o.(OrgWlansType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t OrgWlansType) String() string {
	return "OrgWlansType"
}

func (t OrgWlansType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	acctImmediateUpdateAttribute, ok := attributes["acct_immediate_update"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`acct_immediate_update is missing from object`)

		return nil, diags
	}

	acctImmediateUpdateVal, ok := acctImmediateUpdateAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`acct_immediate_update expected to be basetypes.BoolValue, was: %T`, acctImmediateUpdateAttribute))
	}

	acctInterimIntervalAttribute, ok := attributes["acct_interim_interval"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`acct_interim_interval is missing from object`)

		return nil, diags
	}

	acctInterimIntervalVal, ok := acctInterimIntervalAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`acct_interim_interval expected to be basetypes.Int64Value, was: %T`, acctInterimIntervalAttribute))
	}

	acctServersAttribute, ok := attributes["acct_servers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`acct_servers is missing from object`)

		return nil, diags
	}

	acctServersVal, ok := acctServersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`acct_servers expected to be basetypes.ListValue, was: %T`, acctServersAttribute))
	}

	airwatchAttribute, ok := attributes["airwatch"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`airwatch is missing from object`)

		return nil, diags
	}

	airwatchVal, ok := airwatchAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`airwatch expected to be basetypes.ObjectValue, was: %T`, airwatchAttribute))
	}

	allowIpv6NdpAttribute, ok := attributes["allow_ipv6_ndp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allow_ipv6_ndp is missing from object`)

		return nil, diags
	}

	allowIpv6NdpVal, ok := allowIpv6NdpAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allow_ipv6_ndp expected to be basetypes.BoolValue, was: %T`, allowIpv6NdpAttribute))
	}

	allowMdnsAttribute, ok := attributes["allow_mdns"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allow_mdns is missing from object`)

		return nil, diags
	}

	allowMdnsVal, ok := allowMdnsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allow_mdns expected to be basetypes.BoolValue, was: %T`, allowMdnsAttribute))
	}

	allowSsdpAttribute, ok := attributes["allow_ssdp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allow_ssdp is missing from object`)

		return nil, diags
	}

	allowSsdpVal, ok := allowSsdpAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allow_ssdp expected to be basetypes.BoolValue, was: %T`, allowSsdpAttribute))
	}

	apIdsAttribute, ok := attributes["ap_ids"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ap_ids is missing from object`)

		return nil, diags
	}

	apIdsVal, ok := apIdsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ap_ids expected to be basetypes.ListValue, was: %T`, apIdsAttribute))
	}

	appLimitAttribute, ok := attributes["app_limit"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`app_limit is missing from object`)

		return nil, diags
	}

	appLimitVal, ok := appLimitAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`app_limit expected to be basetypes.ObjectValue, was: %T`, appLimitAttribute))
	}

	appQosAttribute, ok := attributes["app_qos"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`app_qos is missing from object`)

		return nil, diags
	}

	appQosVal, ok := appQosAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`app_qos expected to be basetypes.ObjectValue, was: %T`, appQosAttribute))
	}

	applyToAttribute, ok := attributes["apply_to"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`apply_to is missing from object`)

		return nil, diags
	}

	applyToVal, ok := applyToAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`apply_to expected to be basetypes.StringValue, was: %T`, applyToAttribute))
	}

	arpFilterAttribute, ok := attributes["arp_filter"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`arp_filter is missing from object`)

		return nil, diags
	}

	arpFilterVal, ok := arpFilterAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`arp_filter expected to be basetypes.BoolValue, was: %T`, arpFilterAttribute))
	}

	authAttribute, ok := attributes["auth"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auth is missing from object`)

		return nil, diags
	}

	authVal, ok := authAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auth expected to be basetypes.ObjectValue, was: %T`, authAttribute))
	}

	authServerSelectionAttribute, ok := attributes["auth_server_selection"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auth_server_selection is missing from object`)

		return nil, diags
	}

	authServerSelectionVal, ok := authServerSelectionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auth_server_selection expected to be basetypes.StringValue, was: %T`, authServerSelectionAttribute))
	}

	authServersAttribute, ok := attributes["auth_servers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auth_servers is missing from object`)

		return nil, diags
	}

	authServersVal, ok := authServersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auth_servers expected to be basetypes.ListValue, was: %T`, authServersAttribute))
	}

	authServersNasIdAttribute, ok := attributes["auth_servers_nas_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auth_servers_nas_id is missing from object`)

		return nil, diags
	}

	authServersNasIdVal, ok := authServersNasIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auth_servers_nas_id expected to be basetypes.StringValue, was: %T`, authServersNasIdAttribute))
	}

	authServersNasIpAttribute, ok := attributes["auth_servers_nas_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auth_servers_nas_ip is missing from object`)

		return nil, diags
	}

	authServersNasIpVal, ok := authServersNasIpAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auth_servers_nas_ip expected to be basetypes.StringValue, was: %T`, authServersNasIpAttribute))
	}

	authServersRetriesAttribute, ok := attributes["auth_servers_retries"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auth_servers_retries is missing from object`)

		return nil, diags
	}

	authServersRetriesVal, ok := authServersRetriesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auth_servers_retries expected to be basetypes.Int64Value, was: %T`, authServersRetriesAttribute))
	}

	authServersTimeoutAttribute, ok := attributes["auth_servers_timeout"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auth_servers_timeout is missing from object`)

		return nil, diags
	}

	authServersTimeoutVal, ok := authServersTimeoutAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auth_servers_timeout expected to be basetypes.Int64Value, was: %T`, authServersTimeoutAttribute))
	}

	bandSteerAttribute, ok := attributes["band_steer"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`band_steer is missing from object`)

		return nil, diags
	}

	bandSteerVal, ok := bandSteerAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`band_steer expected to be basetypes.BoolValue, was: %T`, bandSteerAttribute))
	}

	bandSteerForceBand5Attribute, ok := attributes["band_steer_force_band5"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`band_steer_force_band5 is missing from object`)

		return nil, diags
	}

	bandSteerForceBand5Val, ok := bandSteerForceBand5Attribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`band_steer_force_band5 expected to be basetypes.BoolValue, was: %T`, bandSteerForceBand5Attribute))
	}

	bandsAttribute, ok := attributes["bands"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bands is missing from object`)

		return nil, diags
	}

	bandsVal, ok := bandsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bands expected to be basetypes.ListValue, was: %T`, bandsAttribute))
	}

	blockBlacklistClientsAttribute, ok := attributes["block_blacklist_clients"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`block_blacklist_clients is missing from object`)

		return nil, diags
	}

	blockBlacklistClientsVal, ok := blockBlacklistClientsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`block_blacklist_clients expected to be basetypes.BoolValue, was: %T`, blockBlacklistClientsAttribute))
	}

	bonjourAttribute, ok := attributes["bonjour"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bonjour is missing from object`)

		return nil, diags
	}

	bonjourVal, ok := bonjourAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bonjour expected to be basetypes.ObjectValue, was: %T`, bonjourAttribute))
	}

	ciscoCwaAttribute, ok := attributes["cisco_cwa"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cisco_cwa is missing from object`)

		return nil, diags
	}

	ciscoCwaVal, ok := ciscoCwaAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cisco_cwa expected to be basetypes.ObjectValue, was: %T`, ciscoCwaAttribute))
	}

	clientLimitDownAttribute, ok := attributes["client_limit_down"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`client_limit_down is missing from object`)

		return nil, diags
	}

	clientLimitDownVal, ok := clientLimitDownAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`client_limit_down expected to be basetypes.Int64Value, was: %T`, clientLimitDownAttribute))
	}

	clientLimitDownEnabledAttribute, ok := attributes["client_limit_down_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`client_limit_down_enabled is missing from object`)

		return nil, diags
	}

	clientLimitDownEnabledVal, ok := clientLimitDownEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`client_limit_down_enabled expected to be basetypes.BoolValue, was: %T`, clientLimitDownEnabledAttribute))
	}

	clientLimitUpAttribute, ok := attributes["client_limit_up"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`client_limit_up is missing from object`)

		return nil, diags
	}

	clientLimitUpVal, ok := clientLimitUpAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`client_limit_up expected to be basetypes.Int64Value, was: %T`, clientLimitUpAttribute))
	}

	clientLimitUpEnabledAttribute, ok := attributes["client_limit_up_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`client_limit_up_enabled is missing from object`)

		return nil, diags
	}

	clientLimitUpEnabledVal, ok := clientLimitUpEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`client_limit_up_enabled expected to be basetypes.BoolValue, was: %T`, clientLimitUpEnabledAttribute))
	}

	coaServersAttribute, ok := attributes["coa_servers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`coa_servers is missing from object`)

		return nil, diags
	}

	coaServersVal, ok := coaServersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`coa_servers expected to be basetypes.ListValue, was: %T`, coaServersAttribute))
	}

	createdTimeAttribute, ok := attributes["created_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_time is missing from object`)

		return nil, diags
	}

	createdTimeVal, ok := createdTimeAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_time expected to be basetypes.Float64Value, was: %T`, createdTimeAttribute))
	}

	disable11axAttribute, ok := attributes["disable_11ax"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disable_11ax is missing from object`)

		return nil, diags
	}

	disable11axVal, ok := disable11axAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disable_11ax expected to be basetypes.BoolValue, was: %T`, disable11axAttribute))
	}

	disableHtVhtRatesAttribute, ok := attributes["disable_ht_vht_rates"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disable_ht_vht_rates is missing from object`)

		return nil, diags
	}

	disableHtVhtRatesVal, ok := disableHtVhtRatesAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disable_ht_vht_rates expected to be basetypes.BoolValue, was: %T`, disableHtVhtRatesAttribute))
	}

	disableUapsdAttribute, ok := attributes["disable_uapsd"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disable_uapsd is missing from object`)

		return nil, diags
	}

	disableUapsdVal, ok := disableUapsdAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disable_uapsd expected to be basetypes.BoolValue, was: %T`, disableUapsdAttribute))
	}

	disableV1RoamNotifyAttribute, ok := attributes["disable_v1_roam_notify"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disable_v1_roam_notify is missing from object`)

		return nil, diags
	}

	disableV1RoamNotifyVal, ok := disableV1RoamNotifyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disable_v1_roam_notify expected to be basetypes.BoolValue, was: %T`, disableV1RoamNotifyAttribute))
	}

	disableV2RoamNotifyAttribute, ok := attributes["disable_v2_roam_notify"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disable_v2_roam_notify is missing from object`)

		return nil, diags
	}

	disableV2RoamNotifyVal, ok := disableV2RoamNotifyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disable_v2_roam_notify expected to be basetypes.BoolValue, was: %T`, disableV2RoamNotifyAttribute))
	}

	disableWhenGatewayUnreachableAttribute, ok := attributes["disable_when_gateway_unreachable"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disable_when_gateway_unreachable is missing from object`)

		return nil, diags
	}

	disableWhenGatewayUnreachableVal, ok := disableWhenGatewayUnreachableAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disable_when_gateway_unreachable expected to be basetypes.BoolValue, was: %T`, disableWhenGatewayUnreachableAttribute))
	}

	disableWhenMxtunnelDownAttribute, ok := attributes["disable_when_mxtunnel_down"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disable_when_mxtunnel_down is missing from object`)

		return nil, diags
	}

	disableWhenMxtunnelDownVal, ok := disableWhenMxtunnelDownAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disable_when_mxtunnel_down expected to be basetypes.BoolValue, was: %T`, disableWhenMxtunnelDownAttribute))
	}

	disableWmmAttribute, ok := attributes["disable_wmm"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disable_wmm is missing from object`)

		return nil, diags
	}

	disableWmmVal, ok := disableWmmAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disable_wmm expected to be basetypes.BoolValue, was: %T`, disableWmmAttribute))
	}

	dnsServerRewriteAttribute, ok := attributes["dns_server_rewrite"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dns_server_rewrite is missing from object`)

		return nil, diags
	}

	dnsServerRewriteVal, ok := dnsServerRewriteAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dns_server_rewrite expected to be basetypes.ObjectValue, was: %T`, dnsServerRewriteAttribute))
	}

	dtimAttribute, ok := attributes["dtim"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dtim is missing from object`)

		return nil, diags
	}

	dtimVal, ok := dtimAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dtim expected to be basetypes.Int64Value, was: %T`, dtimAttribute))
	}

	dynamicPskAttribute, ok := attributes["dynamic_psk"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dynamic_psk is missing from object`)

		return nil, diags
	}

	dynamicPskVal, ok := dynamicPskAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dynamic_psk expected to be basetypes.ObjectValue, was: %T`, dynamicPskAttribute))
	}

	dynamicVlanAttribute, ok := attributes["dynamic_vlan"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dynamic_vlan is missing from object`)

		return nil, diags
	}

	dynamicVlanVal, ok := dynamicVlanAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dynamic_vlan expected to be basetypes.ObjectValue, was: %T`, dynamicVlanAttribute))
	}

	enableLocalKeycachingAttribute, ok := attributes["enable_local_keycaching"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable_local_keycaching is missing from object`)

		return nil, diags
	}

	enableLocalKeycachingVal, ok := enableLocalKeycachingAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable_local_keycaching expected to be basetypes.BoolValue, was: %T`, enableLocalKeycachingAttribute))
	}

	enableWirelessBridgingAttribute, ok := attributes["enable_wireless_bridging"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable_wireless_bridging is missing from object`)

		return nil, diags
	}

	enableWirelessBridgingVal, ok := enableWirelessBridgingAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable_wireless_bridging expected to be basetypes.BoolValue, was: %T`, enableWirelessBridgingAttribute))
	}

	enableWirelessBridgingDhcpTrackingAttribute, ok := attributes["enable_wireless_bridging_dhcp_tracking"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable_wireless_bridging_dhcp_tracking is missing from object`)

		return nil, diags
	}

	enableWirelessBridgingDhcpTrackingVal, ok := enableWirelessBridgingDhcpTrackingAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable_wireless_bridging_dhcp_tracking expected to be basetypes.BoolValue, was: %T`, enableWirelessBridgingDhcpTrackingAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	fastDot1xTimersAttribute, ok := attributes["fast_dot1x_timers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fast_dot1x_timers is missing from object`)

		return nil, diags
	}

	fastDot1xTimersVal, ok := fastDot1xTimersAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fast_dot1x_timers expected to be basetypes.BoolValue, was: %T`, fastDot1xTimersAttribute))
	}

	hideSsidAttribute, ok := attributes["hide_ssid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`hide_ssid is missing from object`)

		return nil, diags
	}

	hideSsidVal, ok := hideSsidAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`hide_ssid expected to be basetypes.BoolValue, was: %T`, hideSsidAttribute))
	}

	hostnameIeAttribute, ok := attributes["hostname_ie"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`hostname_ie is missing from object`)

		return nil, diags
	}

	hostnameIeVal, ok := hostnameIeAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`hostname_ie expected to be basetypes.BoolValue, was: %T`, hostnameIeAttribute))
	}

	hotspot20Attribute, ok := attributes["hotspot20"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`hotspot20 is missing from object`)

		return nil, diags
	}

	hotspot20Val, ok := hotspot20Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`hotspot20 expected to be basetypes.ObjectValue, was: %T`, hotspot20Attribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	injectDhcpOption82Attribute, ok := attributes["inject_dhcp_option_82"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`inject_dhcp_option_82 is missing from object`)

		return nil, diags
	}

	injectDhcpOption82Val, ok := injectDhcpOption82Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`inject_dhcp_option_82 expected to be basetypes.ObjectValue, was: %T`, injectDhcpOption82Attribute))
	}

	interfaceAttribute, ok := attributes["interface"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface is missing from object`)

		return nil, diags
	}

	interfaceVal, ok := interfaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface expected to be basetypes.StringValue, was: %T`, interfaceAttribute))
	}

	isolationAttribute, ok := attributes["isolation"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`isolation is missing from object`)

		return nil, diags
	}

	isolationVal, ok := isolationAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`isolation expected to be basetypes.BoolValue, was: %T`, isolationAttribute))
	}

	l2IsolationAttribute, ok := attributes["l2_isolation"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`l2_isolation is missing from object`)

		return nil, diags
	}

	l2IsolationVal, ok := l2IsolationAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`l2_isolation expected to be basetypes.BoolValue, was: %T`, l2IsolationAttribute))
	}

	legacyOverdsAttribute, ok := attributes["legacy_overds"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`legacy_overds is missing from object`)

		return nil, diags
	}

	legacyOverdsVal, ok := legacyOverdsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`legacy_overds expected to be basetypes.BoolValue, was: %T`, legacyOverdsAttribute))
	}

	limitBcastAttribute, ok := attributes["limit_bcast"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`limit_bcast is missing from object`)

		return nil, diags
	}

	limitBcastVal, ok := limitBcastAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`limit_bcast expected to be basetypes.BoolValue, was: %T`, limitBcastAttribute))
	}

	limitProbeResponseAttribute, ok := attributes["limit_probe_response"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`limit_probe_response is missing from object`)

		return nil, diags
	}

	limitProbeResponseVal, ok := limitProbeResponseAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`limit_probe_response expected to be basetypes.BoolValue, was: %T`, limitProbeResponseAttribute))
	}

	maxIdletimeAttribute, ok := attributes["max_idletime"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_idletime is missing from object`)

		return nil, diags
	}

	maxIdletimeVal, ok := maxIdletimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_idletime expected to be basetypes.Int64Value, was: %T`, maxIdletimeAttribute))
	}

	maxNumClientsAttribute, ok := attributes["max_num_clients"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_num_clients is missing from object`)

		return nil, diags
	}

	maxNumClientsVal, ok := maxNumClientsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_num_clients expected to be basetypes.Int64Value, was: %T`, maxNumClientsAttribute))
	}

	mistNacAttribute, ok := attributes["mist_nac"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mist_nac is missing from object`)

		return nil, diags
	}

	mistNacVal, ok := mistNacAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mist_nac expected to be basetypes.ObjectValue, was: %T`, mistNacAttribute))
	}

	modifiedTimeAttribute, ok := attributes["modified_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`modified_time is missing from object`)

		return nil, diags
	}

	modifiedTimeVal, ok := modifiedTimeAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`modified_time expected to be basetypes.Float64Value, was: %T`, modifiedTimeAttribute))
	}

	mspIdAttribute, ok := attributes["msp_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`msp_id is missing from object`)

		return nil, diags
	}

	mspIdVal, ok := mspIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`msp_id expected to be basetypes.StringValue, was: %T`, mspIdAttribute))
	}

	mxtunnelIdsAttribute, ok := attributes["mxtunnel_ids"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mxtunnel_ids is missing from object`)

		return nil, diags
	}

	mxtunnelIdsVal, ok := mxtunnelIdsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mxtunnel_ids expected to be basetypes.ListValue, was: %T`, mxtunnelIdsAttribute))
	}

	mxtunnelNameAttribute, ok := attributes["mxtunnel_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mxtunnel_name is missing from object`)

		return nil, diags
	}

	mxtunnelNameVal, ok := mxtunnelNameAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mxtunnel_name expected to be basetypes.ListValue, was: %T`, mxtunnelNameAttribute))
	}

	noStaticDnsAttribute, ok := attributes["no_static_dns"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`no_static_dns is missing from object`)

		return nil, diags
	}

	noStaticDnsVal, ok := noStaticDnsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`no_static_dns expected to be basetypes.BoolValue, was: %T`, noStaticDnsAttribute))
	}

	noStaticIpAttribute, ok := attributes["no_static_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`no_static_ip is missing from object`)

		return nil, diags
	}

	noStaticIpVal, ok := noStaticIpAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`no_static_ip expected to be basetypes.BoolValue, was: %T`, noStaticIpAttribute))
	}

	orgIdAttribute, ok := attributes["org_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`org_id is missing from object`)

		return nil, diags
	}

	orgIdVal, ok := orgIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`org_id expected to be basetypes.StringValue, was: %T`, orgIdAttribute))
	}

	portalAttribute, ok := attributes["portal"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`portal is missing from object`)

		return nil, diags
	}

	portalVal, ok := portalAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`portal expected to be basetypes.ObjectValue, was: %T`, portalAttribute))
	}

	portalAllowedHostnamesAttribute, ok := attributes["portal_allowed_hostnames"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`portal_allowed_hostnames is missing from object`)

		return nil, diags
	}

	portalAllowedHostnamesVal, ok := portalAllowedHostnamesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`portal_allowed_hostnames expected to be basetypes.ListValue, was: %T`, portalAllowedHostnamesAttribute))
	}

	portalAllowedSubnetsAttribute, ok := attributes["portal_allowed_subnets"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`portal_allowed_subnets is missing from object`)

		return nil, diags
	}

	portalAllowedSubnetsVal, ok := portalAllowedSubnetsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`portal_allowed_subnets expected to be basetypes.ListValue, was: %T`, portalAllowedSubnetsAttribute))
	}

	portalApiSecretAttribute, ok := attributes["portal_api_secret"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`portal_api_secret is missing from object`)

		return nil, diags
	}

	portalApiSecretVal, ok := portalApiSecretAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`portal_api_secret expected to be basetypes.StringValue, was: %T`, portalApiSecretAttribute))
	}

	portalDeniedHostnamesAttribute, ok := attributes["portal_denied_hostnames"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`portal_denied_hostnames is missing from object`)

		return nil, diags
	}

	portalDeniedHostnamesVal, ok := portalDeniedHostnamesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`portal_denied_hostnames expected to be basetypes.ListValue, was: %T`, portalDeniedHostnamesAttribute))
	}

	portalImageAttribute, ok := attributes["portal_image"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`portal_image is missing from object`)

		return nil, diags
	}

	portalImageVal, ok := portalImageAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`portal_image expected to be basetypes.StringValue, was: %T`, portalImageAttribute))
	}

	portalSsoUrlAttribute, ok := attributes["portal_sso_url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`portal_sso_url is missing from object`)

		return nil, diags
	}

	portalSsoUrlVal, ok := portalSsoUrlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`portal_sso_url expected to be basetypes.StringValue, was: %T`, portalSsoUrlAttribute))
	}

	qosAttribute, ok := attributes["qos"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`qos is missing from object`)

		return nil, diags
	}

	qosVal, ok := qosAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`qos expected to be basetypes.ObjectValue, was: %T`, qosAttribute))
	}

	radsecAttribute, ok := attributes["radsec"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`radsec is missing from object`)

		return nil, diags
	}

	radsecVal, ok := radsecAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`radsec expected to be basetypes.ObjectValue, was: %T`, radsecAttribute))
	}

	ratesetAttribute, ok := attributes["rateset"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rateset is missing from object`)

		return nil, diags
	}

	ratesetVal, ok := ratesetAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rateset expected to be basetypes.MapValue, was: %T`, ratesetAttribute))
	}

	reconnectClientsWhenRoamingMxclusterAttribute, ok := attributes["reconnect_clients_when_roaming_mxcluster"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`reconnect_clients_when_roaming_mxcluster is missing from object`)

		return nil, diags
	}

	reconnectClientsWhenRoamingMxclusterVal, ok := reconnectClientsWhenRoamingMxclusterAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`reconnect_clients_when_roaming_mxcluster expected to be basetypes.BoolValue, was: %T`, reconnectClientsWhenRoamingMxclusterAttribute))
	}

	roamModeAttribute, ok := attributes["roam_mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`roam_mode is missing from object`)

		return nil, diags
	}

	roamModeVal, ok := roamModeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`roam_mode expected to be basetypes.StringValue, was: %T`, roamModeAttribute))
	}

	scheduleAttribute, ok := attributes["schedule"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`schedule is missing from object`)

		return nil, diags
	}

	scheduleVal, ok := scheduleAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`schedule expected to be basetypes.ObjectValue, was: %T`, scheduleAttribute))
	}

	sleExcludedAttribute, ok := attributes["sle_excluded"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sle_excluded is missing from object`)

		return nil, diags
	}

	sleExcludedVal, ok := sleExcludedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sle_excluded expected to be basetypes.BoolValue, was: %T`, sleExcludedAttribute))
	}

	ssidAttribute, ok := attributes["ssid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ssid is missing from object`)

		return nil, diags
	}

	ssidVal, ok := ssidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ssid expected to be basetypes.StringValue, was: %T`, ssidAttribute))
	}

	templateIdAttribute, ok := attributes["template_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`template_id is missing from object`)

		return nil, diags
	}

	templateIdVal, ok := templateIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`template_id expected to be basetypes.StringValue, was: %T`, templateIdAttribute))
	}

	useEapolV1Attribute, ok := attributes["use_eapol_v1"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`use_eapol_v1 is missing from object`)

		return nil, diags
	}

	useEapolV1Val, ok := useEapolV1Attribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`use_eapol_v1 expected to be basetypes.BoolValue, was: %T`, useEapolV1Attribute))
	}

	vlanEnabledAttribute, ok := attributes["vlan_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan_enabled is missing from object`)

		return nil, diags
	}

	vlanEnabledVal, ok := vlanEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan_enabled expected to be basetypes.BoolValue, was: %T`, vlanEnabledAttribute))
	}

	vlanIdAttribute, ok := attributes["vlan_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan_id is missing from object`)

		return nil, diags
	}

	vlanIdVal, ok := vlanIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan_id expected to be basetypes.StringValue, was: %T`, vlanIdAttribute))
	}

	vlanIdsAttribute, ok := attributes["vlan_ids"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan_ids is missing from object`)

		return nil, diags
	}

	vlanIdsVal, ok := vlanIdsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan_ids expected to be basetypes.ListValue, was: %T`, vlanIdsAttribute))
	}

	vlanPoolingAttribute, ok := attributes["vlan_pooling"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan_pooling is missing from object`)

		return nil, diags
	}

	vlanPoolingVal, ok := vlanPoolingAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan_pooling expected to be basetypes.BoolValue, was: %T`, vlanPoolingAttribute))
	}

	wlanLimitDownAttribute, ok := attributes["wlan_limit_down"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wlan_limit_down is missing from object`)

		return nil, diags
	}

	wlanLimitDownVal, ok := wlanLimitDownAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wlan_limit_down expected to be basetypes.Int64Value, was: %T`, wlanLimitDownAttribute))
	}

	wlanLimitDownEnabledAttribute, ok := attributes["wlan_limit_down_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wlan_limit_down_enabled is missing from object`)

		return nil, diags
	}

	wlanLimitDownEnabledVal, ok := wlanLimitDownEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wlan_limit_down_enabled expected to be basetypes.BoolValue, was: %T`, wlanLimitDownEnabledAttribute))
	}

	wlanLimitUpAttribute, ok := attributes["wlan_limit_up"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wlan_limit_up is missing from object`)

		return nil, diags
	}

	wlanLimitUpVal, ok := wlanLimitUpAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wlan_limit_up expected to be basetypes.Int64Value, was: %T`, wlanLimitUpAttribute))
	}

	wlanLimitUpEnabledAttribute, ok := attributes["wlan_limit_up_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wlan_limit_up_enabled is missing from object`)

		return nil, diags
	}

	wlanLimitUpEnabledVal, ok := wlanLimitUpEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wlan_limit_up_enabled expected to be basetypes.BoolValue, was: %T`, wlanLimitUpEnabledAttribute))
	}

	wxtagIdsAttribute, ok := attributes["wxtag_ids"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wxtag_ids is missing from object`)

		return nil, diags
	}

	wxtagIdsVal, ok := wxtagIdsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wxtag_ids expected to be basetypes.ListValue, was: %T`, wxtagIdsAttribute))
	}

	wxtunnelIdAttribute, ok := attributes["wxtunnel_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wxtunnel_id is missing from object`)

		return nil, diags
	}

	wxtunnelIdVal, ok := wxtunnelIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wxtunnel_id expected to be basetypes.StringValue, was: %T`, wxtunnelIdAttribute))
	}

	wxtunnelRemoteIdAttribute, ok := attributes["wxtunnel_remote_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wxtunnel_remote_id is missing from object`)

		return nil, diags
	}

	wxtunnelRemoteIdVal, ok := wxtunnelRemoteIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wxtunnel_remote_id expected to be basetypes.StringValue, was: %T`, wxtunnelRemoteIdAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return OrgWlansValue{
		AcctImmediateUpdate:                  acctImmediateUpdateVal,
		AcctInterimInterval:                  acctInterimIntervalVal,
		AcctServers:                          acctServersVal,
		Airwatch:                             airwatchVal,
		AllowIpv6Ndp:                         allowIpv6NdpVal,
		AllowMdns:                            allowMdnsVal,
		AllowSsdp:                            allowSsdpVal,
		ApIds:                                apIdsVal,
		AppLimit:                             appLimitVal,
		AppQos:                               appQosVal,
		ApplyTo:                              applyToVal,
		ArpFilter:                            arpFilterVal,
		Auth:                                 authVal,
		AuthServerSelection:                  authServerSelectionVal,
		AuthServers:                          authServersVal,
		AuthServersNasId:                     authServersNasIdVal,
		AuthServersNasIp:                     authServersNasIpVal,
		AuthServersRetries:                   authServersRetriesVal,
		AuthServersTimeout:                   authServersTimeoutVal,
		BandSteer:                            bandSteerVal,
		BandSteerForceBand5:                  bandSteerForceBand5Val,
		Bands:                                bandsVal,
		BlockBlacklistClients:                blockBlacklistClientsVal,
		Bonjour:                              bonjourVal,
		CiscoCwa:                             ciscoCwaVal,
		ClientLimitDown:                      clientLimitDownVal,
		ClientLimitDownEnabled:               clientLimitDownEnabledVal,
		ClientLimitUp:                        clientLimitUpVal,
		ClientLimitUpEnabled:                 clientLimitUpEnabledVal,
		CoaServers:                           coaServersVal,
		CreatedTime:                          createdTimeVal,
		Disable11ax:                          disable11axVal,
		DisableHtVhtRates:                    disableHtVhtRatesVal,
		DisableUapsd:                         disableUapsdVal,
		DisableV1RoamNotify:                  disableV1RoamNotifyVal,
		DisableV2RoamNotify:                  disableV2RoamNotifyVal,
		DisableWhenGatewayUnreachable:        disableWhenGatewayUnreachableVal,
		DisableWhenMxtunnelDown:              disableWhenMxtunnelDownVal,
		DisableWmm:                           disableWmmVal,
		DnsServerRewrite:                     dnsServerRewriteVal,
		Dtim:                                 dtimVal,
		DynamicPsk:                           dynamicPskVal,
		DynamicVlan:                          dynamicVlanVal,
		EnableLocalKeycaching:                enableLocalKeycachingVal,
		EnableWirelessBridging:               enableWirelessBridgingVal,
		EnableWirelessBridgingDhcpTracking:   enableWirelessBridgingDhcpTrackingVal,
		Enabled:                              enabledVal,
		FastDot1xTimers:                      fastDot1xTimersVal,
		HideSsid:                             hideSsidVal,
		HostnameIe:                           hostnameIeVal,
		Hotspot20:                            hotspot20Val,
		Id:                                   idVal,
		InjectDhcpOption82:                   injectDhcpOption82Val,
		Interface:                            interfaceVal,
		Isolation:                            isolationVal,
		L2Isolation:                          l2IsolationVal,
		LegacyOverds:                         legacyOverdsVal,
		LimitBcast:                           limitBcastVal,
		LimitProbeResponse:                   limitProbeResponseVal,
		MaxIdletime:                          maxIdletimeVal,
		MaxNumClients:                        maxNumClientsVal,
		MistNac:                              mistNacVal,
		ModifiedTime:                         modifiedTimeVal,
		MspId:                                mspIdVal,
		MxtunnelIds:                          mxtunnelIdsVal,
		MxtunnelName:                         mxtunnelNameVal,
		NoStaticDns:                          noStaticDnsVal,
		NoStaticIp:                           noStaticIpVal,
		OrgId:                                orgIdVal,
		Portal:                               portalVal,
		PortalAllowedHostnames:               portalAllowedHostnamesVal,
		PortalAllowedSubnets:                 portalAllowedSubnetsVal,
		PortalApiSecret:                      portalApiSecretVal,
		PortalDeniedHostnames:                portalDeniedHostnamesVal,
		PortalImage:                          portalImageVal,
		PortalSsoUrl:                         portalSsoUrlVal,
		Qos:                                  qosVal,
		Radsec:                               radsecVal,
		Rateset:                              ratesetVal,
		ReconnectClientsWhenRoamingMxcluster: reconnectClientsWhenRoamingMxclusterVal,
		RoamMode:                             roamModeVal,
		Schedule:                             scheduleVal,
		SleExcluded:                          sleExcludedVal,
		Ssid:                                 ssidVal,
		TemplateId:                           templateIdVal,
		UseEapolV1:                           useEapolV1Val,
		VlanEnabled:                          vlanEnabledVal,
		VlanId:                               vlanIdVal,
		VlanIds:                              vlanIdsVal,
		VlanPooling:                          vlanPoolingVal,
		WlanLimitDown:                        wlanLimitDownVal,
		WlanLimitDownEnabled:                 wlanLimitDownEnabledVal,
		WlanLimitUp:                          wlanLimitUpVal,
		WlanLimitUpEnabled:                   wlanLimitUpEnabledVal,
		WxtagIds:                             wxtagIdsVal,
		WxtunnelId:                           wxtunnelIdVal,
		WxtunnelRemoteId:                     wxtunnelRemoteIdVal,
		state:                                attr.ValueStateKnown,
	}, diags
}

func NewOrgWlansValueNull() OrgWlansValue {
	return OrgWlansValue{
		state: attr.ValueStateNull,
	}
}

func NewOrgWlansValueUnknown() OrgWlansValue {
	return OrgWlansValue{
		state: attr.ValueStateUnknown,
	}
}

func NewOrgWlansValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (OrgWlansValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing OrgWlansValue Attribute Value",
				"While creating a OrgWlansValue value, a missing attribute value was detected. "+
					"A OrgWlansValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OrgWlansValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid OrgWlansValue Attribute Type",
				"While creating a OrgWlansValue value, an invalid attribute value was detected. "+
					"A OrgWlansValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OrgWlansValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("OrgWlansValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra OrgWlansValue Attribute Value",
				"While creating a OrgWlansValue value, an extra attribute value was detected. "+
					"A OrgWlansValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra OrgWlansValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewOrgWlansValueUnknown(), diags
	}

	acctImmediateUpdateAttribute, ok := attributes["acct_immediate_update"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`acct_immediate_update is missing from object`)

		return NewOrgWlansValueUnknown(), diags
	}

	acctImmediateUpdateVal, ok := acctImmediateUpdateAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`acct_immediate_update expected to be basetypes.BoolValue, was: %T`, acctImmediateUpdateAttribute))
	}

	acctInterimIntervalAttribute, ok := attributes["acct_interim_interval"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`acct_interim_interval is missing from object`)

		return NewOrgWlansValueUnknown(), diags
	}

	acctInterimIntervalVal, ok := acctInterimIntervalAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`acct_interim_interval expected to be basetypes.Int64Value, was: %T`, acctInterimIntervalAttribute))
	}

	acctServersAttribute, ok := attributes["acct_servers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`acct_servers is missing from object`)

		return NewOrgWlansValueUnknown(), diags
	}

	acctServersVal, ok := acctServersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`acct_servers expected to be basetypes.ListValue, was: %T`, acctServersAttribute))
	}

	airwatchAttribute, ok := attributes["airwatch"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`airwatch is missing from object`)

		return NewOrgWlansValueUnknown(), diags
	}

	airwatchVal, ok := airwatchAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`airwatch expected to be basetypes.ObjectValue, was: %T`, airwatchAttribute))
	}

	allowIpv6NdpAttribute, ok := attributes["allow_ipv6_ndp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allow_ipv6_ndp is missing from object`)

		return NewOrgWlansValueUnknown(), diags
	}

	allowIpv6NdpVal, ok := allowIpv6NdpAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allow_ipv6_ndp expected to be basetypes.BoolValue, was: %T`, allowIpv6NdpAttribute))
	}

	allowMdnsAttribute, ok := attributes["allow_mdns"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allow_mdns is missing from object`)

		return NewOrgWlansValueUnknown(), diags
	}

	allowMdnsVal, ok := allowMdnsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allow_mdns expected to be basetypes.BoolValue, was: %T`, allowMdnsAttribute))
	}

	allowSsdpAttribute, ok := attributes["allow_ssdp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allow_ssdp is missing from object`)

		return NewOrgWlansValueUnknown(), diags
	}

	allowSsdpVal, ok := allowSsdpAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allow_ssdp expected to be basetypes.BoolValue, was: %T`, allowSsdpAttribute))
	}

	apIdsAttribute, ok := attributes["ap_ids"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ap_ids is missing from object`)

		return NewOrgWlansValueUnknown(), diags
	}

	apIdsVal, ok := apIdsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ap_ids expected to be basetypes.ListValue, was: %T`, apIdsAttribute))
	}

	appLimitAttribute, ok := attributes["app_limit"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`app_limit is missing from object`)

		return NewOrgWlansValueUnknown(), diags
	}

	appLimitVal, ok := appLimitAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`app_limit expected to be basetypes.ObjectValue, was: %T`, appLimitAttribute))
	}

	appQosAttribute, ok := attributes["app_qos"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`app_qos is missing from object`)

		return NewOrgWlansValueUnknown(), diags
	}

	appQosVal, ok := appQosAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`app_qos expected to be basetypes.ObjectValue, was: %T`, appQosAttribute))
	}

	applyToAttribute, ok := attributes["apply_to"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`apply_to is missing from object`)

		return NewOrgWlansValueUnknown(), diags
	}

	applyToVal, ok := applyToAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`apply_to expected to be basetypes.StringValue, was: %T`, applyToAttribute))
	}

	arpFilterAttribute, ok := attributes["arp_filter"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`arp_filter is missing from object`)

		return NewOrgWlansValueUnknown(), diags
	}

	arpFilterVal, ok := arpFilterAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`arp_filter expected to be basetypes.BoolValue, was: %T`, arpFilterAttribute))
	}

	authAttribute, ok := attributes["auth"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auth is missing from object`)

		return NewOrgWlansValueUnknown(), diags
	}

	authVal, ok := authAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auth expected to be basetypes.ObjectValue, was: %T`, authAttribute))
	}

	authServerSelectionAttribute, ok := attributes["auth_server_selection"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auth_server_selection is missing from object`)

		return NewOrgWlansValueUnknown(), diags
	}

	authServerSelectionVal, ok := authServerSelectionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auth_server_selection expected to be basetypes.StringValue, was: %T`, authServerSelectionAttribute))
	}

	authServersAttribute, ok := attributes["auth_servers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auth_servers is missing from object`)

		return NewOrgWlansValueUnknown(), diags
	}

	authServersVal, ok := authServersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auth_servers expected to be basetypes.ListValue, was: %T`, authServersAttribute))
	}

	authServersNasIdAttribute, ok := attributes["auth_servers_nas_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auth_servers_nas_id is missing from object`)

		return NewOrgWlansValueUnknown(), diags
	}

	authServersNasIdVal, ok := authServersNasIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auth_servers_nas_id expected to be basetypes.StringValue, was: %T`, authServersNasIdAttribute))
	}

	authServersNasIpAttribute, ok := attributes["auth_servers_nas_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auth_servers_nas_ip is missing from object`)

		return NewOrgWlansValueUnknown(), diags
	}

	authServersNasIpVal, ok := authServersNasIpAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auth_servers_nas_ip expected to be basetypes.StringValue, was: %T`, authServersNasIpAttribute))
	}

	authServersRetriesAttribute, ok := attributes["auth_servers_retries"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auth_servers_retries is missing from object`)

		return NewOrgWlansValueUnknown(), diags
	}

	authServersRetriesVal, ok := authServersRetriesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auth_servers_retries expected to be basetypes.Int64Value, was: %T`, authServersRetriesAttribute))
	}

	authServersTimeoutAttribute, ok := attributes["auth_servers_timeout"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auth_servers_timeout is missing from object`)

		return NewOrgWlansValueUnknown(), diags
	}

	authServersTimeoutVal, ok := authServersTimeoutAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auth_servers_timeout expected to be basetypes.Int64Value, was: %T`, authServersTimeoutAttribute))
	}

	bandSteerAttribute, ok := attributes["band_steer"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`band_steer is missing from object`)

		return NewOrgWlansValueUnknown(), diags
	}

	bandSteerVal, ok := bandSteerAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`band_steer expected to be basetypes.BoolValue, was: %T`, bandSteerAttribute))
	}

	bandSteerForceBand5Attribute, ok := attributes["band_steer_force_band5"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`band_steer_force_band5 is missing from object`)

		return NewOrgWlansValueUnknown(), diags
	}

	bandSteerForceBand5Val, ok := bandSteerForceBand5Attribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`band_steer_force_band5 expected to be basetypes.BoolValue, was: %T`, bandSteerForceBand5Attribute))
	}

	bandsAttribute, ok := attributes["bands"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bands is missing from object`)

		return NewOrgWlansValueUnknown(), diags
	}

	bandsVal, ok := bandsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bands expected to be basetypes.ListValue, was: %T`, bandsAttribute))
	}

	blockBlacklistClientsAttribute, ok := attributes["block_blacklist_clients"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`block_blacklist_clients is missing from object`)

		return NewOrgWlansValueUnknown(), diags
	}

	blockBlacklistClientsVal, ok := blockBlacklistClientsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`block_blacklist_clients expected to be basetypes.BoolValue, was: %T`, blockBlacklistClientsAttribute))
	}

	bonjourAttribute, ok := attributes["bonjour"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bonjour is missing from object`)

		return NewOrgWlansValueUnknown(), diags
	}

	bonjourVal, ok := bonjourAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bonjour expected to be basetypes.ObjectValue, was: %T`, bonjourAttribute))
	}

	ciscoCwaAttribute, ok := attributes["cisco_cwa"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cisco_cwa is missing from object`)

		return NewOrgWlansValueUnknown(), diags
	}

	ciscoCwaVal, ok := ciscoCwaAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cisco_cwa expected to be basetypes.ObjectValue, was: %T`, ciscoCwaAttribute))
	}

	clientLimitDownAttribute, ok := attributes["client_limit_down"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`client_limit_down is missing from object`)

		return NewOrgWlansValueUnknown(), diags
	}

	clientLimitDownVal, ok := clientLimitDownAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`client_limit_down expected to be basetypes.Int64Value, was: %T`, clientLimitDownAttribute))
	}

	clientLimitDownEnabledAttribute, ok := attributes["client_limit_down_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`client_limit_down_enabled is missing from object`)

		return NewOrgWlansValueUnknown(), diags
	}

	clientLimitDownEnabledVal, ok := clientLimitDownEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`client_limit_down_enabled expected to be basetypes.BoolValue, was: %T`, clientLimitDownEnabledAttribute))
	}

	clientLimitUpAttribute, ok := attributes["client_limit_up"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`client_limit_up is missing from object`)

		return NewOrgWlansValueUnknown(), diags
	}

	clientLimitUpVal, ok := clientLimitUpAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`client_limit_up expected to be basetypes.Int64Value, was: %T`, clientLimitUpAttribute))
	}

	clientLimitUpEnabledAttribute, ok := attributes["client_limit_up_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`client_limit_up_enabled is missing from object`)

		return NewOrgWlansValueUnknown(), diags
	}

	clientLimitUpEnabledVal, ok := clientLimitUpEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`client_limit_up_enabled expected to be basetypes.BoolValue, was: %T`, clientLimitUpEnabledAttribute))
	}

	coaServersAttribute, ok := attributes["coa_servers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`coa_servers is missing from object`)

		return NewOrgWlansValueUnknown(), diags
	}

	coaServersVal, ok := coaServersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`coa_servers expected to be basetypes.ListValue, was: %T`, coaServersAttribute))
	}

	createdTimeAttribute, ok := attributes["created_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_time is missing from object`)

		return NewOrgWlansValueUnknown(), diags
	}

	createdTimeVal, ok := createdTimeAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_time expected to be basetypes.Float64Value, was: %T`, createdTimeAttribute))
	}

	disable11axAttribute, ok := attributes["disable_11ax"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disable_11ax is missing from object`)

		return NewOrgWlansValueUnknown(), diags
	}

	disable11axVal, ok := disable11axAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disable_11ax expected to be basetypes.BoolValue, was: %T`, disable11axAttribute))
	}

	disableHtVhtRatesAttribute, ok := attributes["disable_ht_vht_rates"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disable_ht_vht_rates is missing from object`)

		return NewOrgWlansValueUnknown(), diags
	}

	disableHtVhtRatesVal, ok := disableHtVhtRatesAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disable_ht_vht_rates expected to be basetypes.BoolValue, was: %T`, disableHtVhtRatesAttribute))
	}

	disableUapsdAttribute, ok := attributes["disable_uapsd"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disable_uapsd is missing from object`)

		return NewOrgWlansValueUnknown(), diags
	}

	disableUapsdVal, ok := disableUapsdAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disable_uapsd expected to be basetypes.BoolValue, was: %T`, disableUapsdAttribute))
	}

	disableV1RoamNotifyAttribute, ok := attributes["disable_v1_roam_notify"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disable_v1_roam_notify is missing from object`)

		return NewOrgWlansValueUnknown(), diags
	}

	disableV1RoamNotifyVal, ok := disableV1RoamNotifyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disable_v1_roam_notify expected to be basetypes.BoolValue, was: %T`, disableV1RoamNotifyAttribute))
	}

	disableV2RoamNotifyAttribute, ok := attributes["disable_v2_roam_notify"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disable_v2_roam_notify is missing from object`)

		return NewOrgWlansValueUnknown(), diags
	}

	disableV2RoamNotifyVal, ok := disableV2RoamNotifyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disable_v2_roam_notify expected to be basetypes.BoolValue, was: %T`, disableV2RoamNotifyAttribute))
	}

	disableWhenGatewayUnreachableAttribute, ok := attributes["disable_when_gateway_unreachable"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disable_when_gateway_unreachable is missing from object`)

		return NewOrgWlansValueUnknown(), diags
	}

	disableWhenGatewayUnreachableVal, ok := disableWhenGatewayUnreachableAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disable_when_gateway_unreachable expected to be basetypes.BoolValue, was: %T`, disableWhenGatewayUnreachableAttribute))
	}

	disableWhenMxtunnelDownAttribute, ok := attributes["disable_when_mxtunnel_down"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disable_when_mxtunnel_down is missing from object`)

		return NewOrgWlansValueUnknown(), diags
	}

	disableWhenMxtunnelDownVal, ok := disableWhenMxtunnelDownAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disable_when_mxtunnel_down expected to be basetypes.BoolValue, was: %T`, disableWhenMxtunnelDownAttribute))
	}

	disableWmmAttribute, ok := attributes["disable_wmm"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disable_wmm is missing from object`)

		return NewOrgWlansValueUnknown(), diags
	}

	disableWmmVal, ok := disableWmmAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disable_wmm expected to be basetypes.BoolValue, was: %T`, disableWmmAttribute))
	}

	dnsServerRewriteAttribute, ok := attributes["dns_server_rewrite"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dns_server_rewrite is missing from object`)

		return NewOrgWlansValueUnknown(), diags
	}

	dnsServerRewriteVal, ok := dnsServerRewriteAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dns_server_rewrite expected to be basetypes.ObjectValue, was: %T`, dnsServerRewriteAttribute))
	}

	dtimAttribute, ok := attributes["dtim"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dtim is missing from object`)

		return NewOrgWlansValueUnknown(), diags
	}

	dtimVal, ok := dtimAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dtim expected to be basetypes.Int64Value, was: %T`, dtimAttribute))
	}

	dynamicPskAttribute, ok := attributes["dynamic_psk"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dynamic_psk is missing from object`)

		return NewOrgWlansValueUnknown(), diags
	}

	dynamicPskVal, ok := dynamicPskAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dynamic_psk expected to be basetypes.ObjectValue, was: %T`, dynamicPskAttribute))
	}

	dynamicVlanAttribute, ok := attributes["dynamic_vlan"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dynamic_vlan is missing from object`)

		return NewOrgWlansValueUnknown(), diags
	}

	dynamicVlanVal, ok := dynamicVlanAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dynamic_vlan expected to be basetypes.ObjectValue, was: %T`, dynamicVlanAttribute))
	}

	enableLocalKeycachingAttribute, ok := attributes["enable_local_keycaching"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable_local_keycaching is missing from object`)

		return NewOrgWlansValueUnknown(), diags
	}

	enableLocalKeycachingVal, ok := enableLocalKeycachingAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable_local_keycaching expected to be basetypes.BoolValue, was: %T`, enableLocalKeycachingAttribute))
	}

	enableWirelessBridgingAttribute, ok := attributes["enable_wireless_bridging"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable_wireless_bridging is missing from object`)

		return NewOrgWlansValueUnknown(), diags
	}

	enableWirelessBridgingVal, ok := enableWirelessBridgingAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable_wireless_bridging expected to be basetypes.BoolValue, was: %T`, enableWirelessBridgingAttribute))
	}

	enableWirelessBridgingDhcpTrackingAttribute, ok := attributes["enable_wireless_bridging_dhcp_tracking"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable_wireless_bridging_dhcp_tracking is missing from object`)

		return NewOrgWlansValueUnknown(), diags
	}

	enableWirelessBridgingDhcpTrackingVal, ok := enableWirelessBridgingDhcpTrackingAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable_wireless_bridging_dhcp_tracking expected to be basetypes.BoolValue, was: %T`, enableWirelessBridgingDhcpTrackingAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewOrgWlansValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	fastDot1xTimersAttribute, ok := attributes["fast_dot1x_timers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fast_dot1x_timers is missing from object`)

		return NewOrgWlansValueUnknown(), diags
	}

	fastDot1xTimersVal, ok := fastDot1xTimersAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fast_dot1x_timers expected to be basetypes.BoolValue, was: %T`, fastDot1xTimersAttribute))
	}

	hideSsidAttribute, ok := attributes["hide_ssid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`hide_ssid is missing from object`)

		return NewOrgWlansValueUnknown(), diags
	}

	hideSsidVal, ok := hideSsidAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`hide_ssid expected to be basetypes.BoolValue, was: %T`, hideSsidAttribute))
	}

	hostnameIeAttribute, ok := attributes["hostname_ie"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`hostname_ie is missing from object`)

		return NewOrgWlansValueUnknown(), diags
	}

	hostnameIeVal, ok := hostnameIeAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`hostname_ie expected to be basetypes.BoolValue, was: %T`, hostnameIeAttribute))
	}

	hotspot20Attribute, ok := attributes["hotspot20"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`hotspot20 is missing from object`)

		return NewOrgWlansValueUnknown(), diags
	}

	hotspot20Val, ok := hotspot20Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`hotspot20 expected to be basetypes.ObjectValue, was: %T`, hotspot20Attribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewOrgWlansValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	injectDhcpOption82Attribute, ok := attributes["inject_dhcp_option_82"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`inject_dhcp_option_82 is missing from object`)

		return NewOrgWlansValueUnknown(), diags
	}

	injectDhcpOption82Val, ok := injectDhcpOption82Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`inject_dhcp_option_82 expected to be basetypes.ObjectValue, was: %T`, injectDhcpOption82Attribute))
	}

	interfaceAttribute, ok := attributes["interface"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface is missing from object`)

		return NewOrgWlansValueUnknown(), diags
	}

	interfaceVal, ok := interfaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface expected to be basetypes.StringValue, was: %T`, interfaceAttribute))
	}

	isolationAttribute, ok := attributes["isolation"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`isolation is missing from object`)

		return NewOrgWlansValueUnknown(), diags
	}

	isolationVal, ok := isolationAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`isolation expected to be basetypes.BoolValue, was: %T`, isolationAttribute))
	}

	l2IsolationAttribute, ok := attributes["l2_isolation"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`l2_isolation is missing from object`)

		return NewOrgWlansValueUnknown(), diags
	}

	l2IsolationVal, ok := l2IsolationAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`l2_isolation expected to be basetypes.BoolValue, was: %T`, l2IsolationAttribute))
	}

	legacyOverdsAttribute, ok := attributes["legacy_overds"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`legacy_overds is missing from object`)

		return NewOrgWlansValueUnknown(), diags
	}

	legacyOverdsVal, ok := legacyOverdsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`legacy_overds expected to be basetypes.BoolValue, was: %T`, legacyOverdsAttribute))
	}

	limitBcastAttribute, ok := attributes["limit_bcast"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`limit_bcast is missing from object`)

		return NewOrgWlansValueUnknown(), diags
	}

	limitBcastVal, ok := limitBcastAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`limit_bcast expected to be basetypes.BoolValue, was: %T`, limitBcastAttribute))
	}

	limitProbeResponseAttribute, ok := attributes["limit_probe_response"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`limit_probe_response is missing from object`)

		return NewOrgWlansValueUnknown(), diags
	}

	limitProbeResponseVal, ok := limitProbeResponseAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`limit_probe_response expected to be basetypes.BoolValue, was: %T`, limitProbeResponseAttribute))
	}

	maxIdletimeAttribute, ok := attributes["max_idletime"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_idletime is missing from object`)

		return NewOrgWlansValueUnknown(), diags
	}

	maxIdletimeVal, ok := maxIdletimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_idletime expected to be basetypes.Int64Value, was: %T`, maxIdletimeAttribute))
	}

	maxNumClientsAttribute, ok := attributes["max_num_clients"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_num_clients is missing from object`)

		return NewOrgWlansValueUnknown(), diags
	}

	maxNumClientsVal, ok := maxNumClientsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_num_clients expected to be basetypes.Int64Value, was: %T`, maxNumClientsAttribute))
	}

	mistNacAttribute, ok := attributes["mist_nac"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mist_nac is missing from object`)

		return NewOrgWlansValueUnknown(), diags
	}

	mistNacVal, ok := mistNacAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mist_nac expected to be basetypes.ObjectValue, was: %T`, mistNacAttribute))
	}

	modifiedTimeAttribute, ok := attributes["modified_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`modified_time is missing from object`)

		return NewOrgWlansValueUnknown(), diags
	}

	modifiedTimeVal, ok := modifiedTimeAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`modified_time expected to be basetypes.Float64Value, was: %T`, modifiedTimeAttribute))
	}

	mspIdAttribute, ok := attributes["msp_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`msp_id is missing from object`)

		return NewOrgWlansValueUnknown(), diags
	}

	mspIdVal, ok := mspIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`msp_id expected to be basetypes.StringValue, was: %T`, mspIdAttribute))
	}

	mxtunnelIdsAttribute, ok := attributes["mxtunnel_ids"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mxtunnel_ids is missing from object`)

		return NewOrgWlansValueUnknown(), diags
	}

	mxtunnelIdsVal, ok := mxtunnelIdsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mxtunnel_ids expected to be basetypes.ListValue, was: %T`, mxtunnelIdsAttribute))
	}

	mxtunnelNameAttribute, ok := attributes["mxtunnel_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mxtunnel_name is missing from object`)

		return NewOrgWlansValueUnknown(), diags
	}

	mxtunnelNameVal, ok := mxtunnelNameAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mxtunnel_name expected to be basetypes.ListValue, was: %T`, mxtunnelNameAttribute))
	}

	noStaticDnsAttribute, ok := attributes["no_static_dns"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`no_static_dns is missing from object`)

		return NewOrgWlansValueUnknown(), diags
	}

	noStaticDnsVal, ok := noStaticDnsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`no_static_dns expected to be basetypes.BoolValue, was: %T`, noStaticDnsAttribute))
	}

	noStaticIpAttribute, ok := attributes["no_static_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`no_static_ip is missing from object`)

		return NewOrgWlansValueUnknown(), diags
	}

	noStaticIpVal, ok := noStaticIpAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`no_static_ip expected to be basetypes.BoolValue, was: %T`, noStaticIpAttribute))
	}

	orgIdAttribute, ok := attributes["org_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`org_id is missing from object`)

		return NewOrgWlansValueUnknown(), diags
	}

	orgIdVal, ok := orgIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`org_id expected to be basetypes.StringValue, was: %T`, orgIdAttribute))
	}

	portalAttribute, ok := attributes["portal"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`portal is missing from object`)

		return NewOrgWlansValueUnknown(), diags
	}

	portalVal, ok := portalAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`portal expected to be basetypes.ObjectValue, was: %T`, portalAttribute))
	}

	portalAllowedHostnamesAttribute, ok := attributes["portal_allowed_hostnames"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`portal_allowed_hostnames is missing from object`)

		return NewOrgWlansValueUnknown(), diags
	}

	portalAllowedHostnamesVal, ok := portalAllowedHostnamesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`portal_allowed_hostnames expected to be basetypes.ListValue, was: %T`, portalAllowedHostnamesAttribute))
	}

	portalAllowedSubnetsAttribute, ok := attributes["portal_allowed_subnets"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`portal_allowed_subnets is missing from object`)

		return NewOrgWlansValueUnknown(), diags
	}

	portalAllowedSubnetsVal, ok := portalAllowedSubnetsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`portal_allowed_subnets expected to be basetypes.ListValue, was: %T`, portalAllowedSubnetsAttribute))
	}

	portalApiSecretAttribute, ok := attributes["portal_api_secret"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`portal_api_secret is missing from object`)

		return NewOrgWlansValueUnknown(), diags
	}

	portalApiSecretVal, ok := portalApiSecretAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`portal_api_secret expected to be basetypes.StringValue, was: %T`, portalApiSecretAttribute))
	}

	portalDeniedHostnamesAttribute, ok := attributes["portal_denied_hostnames"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`portal_denied_hostnames is missing from object`)

		return NewOrgWlansValueUnknown(), diags
	}

	portalDeniedHostnamesVal, ok := portalDeniedHostnamesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`portal_denied_hostnames expected to be basetypes.ListValue, was: %T`, portalDeniedHostnamesAttribute))
	}

	portalImageAttribute, ok := attributes["portal_image"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`portal_image is missing from object`)

		return NewOrgWlansValueUnknown(), diags
	}

	portalImageVal, ok := portalImageAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`portal_image expected to be basetypes.StringValue, was: %T`, portalImageAttribute))
	}

	portalSsoUrlAttribute, ok := attributes["portal_sso_url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`portal_sso_url is missing from object`)

		return NewOrgWlansValueUnknown(), diags
	}

	portalSsoUrlVal, ok := portalSsoUrlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`portal_sso_url expected to be basetypes.StringValue, was: %T`, portalSsoUrlAttribute))
	}

	qosAttribute, ok := attributes["qos"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`qos is missing from object`)

		return NewOrgWlansValueUnknown(), diags
	}

	qosVal, ok := qosAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`qos expected to be basetypes.ObjectValue, was: %T`, qosAttribute))
	}

	radsecAttribute, ok := attributes["radsec"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`radsec is missing from object`)

		return NewOrgWlansValueUnknown(), diags
	}

	radsecVal, ok := radsecAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`radsec expected to be basetypes.ObjectValue, was: %T`, radsecAttribute))
	}

	ratesetAttribute, ok := attributes["rateset"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rateset is missing from object`)

		return NewOrgWlansValueUnknown(), diags
	}

	ratesetVal, ok := ratesetAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rateset expected to be basetypes.MapValue, was: %T`, ratesetAttribute))
	}

	reconnectClientsWhenRoamingMxclusterAttribute, ok := attributes["reconnect_clients_when_roaming_mxcluster"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`reconnect_clients_when_roaming_mxcluster is missing from object`)

		return NewOrgWlansValueUnknown(), diags
	}

	reconnectClientsWhenRoamingMxclusterVal, ok := reconnectClientsWhenRoamingMxclusterAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`reconnect_clients_when_roaming_mxcluster expected to be basetypes.BoolValue, was: %T`, reconnectClientsWhenRoamingMxclusterAttribute))
	}

	roamModeAttribute, ok := attributes["roam_mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`roam_mode is missing from object`)

		return NewOrgWlansValueUnknown(), diags
	}

	roamModeVal, ok := roamModeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`roam_mode expected to be basetypes.StringValue, was: %T`, roamModeAttribute))
	}

	scheduleAttribute, ok := attributes["schedule"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`schedule is missing from object`)

		return NewOrgWlansValueUnknown(), diags
	}

	scheduleVal, ok := scheduleAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`schedule expected to be basetypes.ObjectValue, was: %T`, scheduleAttribute))
	}

	sleExcludedAttribute, ok := attributes["sle_excluded"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sle_excluded is missing from object`)

		return NewOrgWlansValueUnknown(), diags
	}

	sleExcludedVal, ok := sleExcludedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sle_excluded expected to be basetypes.BoolValue, was: %T`, sleExcludedAttribute))
	}

	ssidAttribute, ok := attributes["ssid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ssid is missing from object`)

		return NewOrgWlansValueUnknown(), diags
	}

	ssidVal, ok := ssidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ssid expected to be basetypes.StringValue, was: %T`, ssidAttribute))
	}

	templateIdAttribute, ok := attributes["template_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`template_id is missing from object`)

		return NewOrgWlansValueUnknown(), diags
	}

	templateIdVal, ok := templateIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`template_id expected to be basetypes.StringValue, was: %T`, templateIdAttribute))
	}

	useEapolV1Attribute, ok := attributes["use_eapol_v1"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`use_eapol_v1 is missing from object`)

		return NewOrgWlansValueUnknown(), diags
	}

	useEapolV1Val, ok := useEapolV1Attribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`use_eapol_v1 expected to be basetypes.BoolValue, was: %T`, useEapolV1Attribute))
	}

	vlanEnabledAttribute, ok := attributes["vlan_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan_enabled is missing from object`)

		return NewOrgWlansValueUnknown(), diags
	}

	vlanEnabledVal, ok := vlanEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan_enabled expected to be basetypes.BoolValue, was: %T`, vlanEnabledAttribute))
	}

	vlanIdAttribute, ok := attributes["vlan_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan_id is missing from object`)

		return NewOrgWlansValueUnknown(), diags
	}

	vlanIdVal, ok := vlanIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan_id expected to be basetypes.StringValue, was: %T`, vlanIdAttribute))
	}

	vlanIdsAttribute, ok := attributes["vlan_ids"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan_ids is missing from object`)

		return NewOrgWlansValueUnknown(), diags
	}

	vlanIdsVal, ok := vlanIdsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan_ids expected to be basetypes.ListValue, was: %T`, vlanIdsAttribute))
	}

	vlanPoolingAttribute, ok := attributes["vlan_pooling"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan_pooling is missing from object`)

		return NewOrgWlansValueUnknown(), diags
	}

	vlanPoolingVal, ok := vlanPoolingAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan_pooling expected to be basetypes.BoolValue, was: %T`, vlanPoolingAttribute))
	}

	wlanLimitDownAttribute, ok := attributes["wlan_limit_down"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wlan_limit_down is missing from object`)

		return NewOrgWlansValueUnknown(), diags
	}

	wlanLimitDownVal, ok := wlanLimitDownAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wlan_limit_down expected to be basetypes.Int64Value, was: %T`, wlanLimitDownAttribute))
	}

	wlanLimitDownEnabledAttribute, ok := attributes["wlan_limit_down_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wlan_limit_down_enabled is missing from object`)

		return NewOrgWlansValueUnknown(), diags
	}

	wlanLimitDownEnabledVal, ok := wlanLimitDownEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wlan_limit_down_enabled expected to be basetypes.BoolValue, was: %T`, wlanLimitDownEnabledAttribute))
	}

	wlanLimitUpAttribute, ok := attributes["wlan_limit_up"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wlan_limit_up is missing from object`)

		return NewOrgWlansValueUnknown(), diags
	}

	wlanLimitUpVal, ok := wlanLimitUpAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wlan_limit_up expected to be basetypes.Int64Value, was: %T`, wlanLimitUpAttribute))
	}

	wlanLimitUpEnabledAttribute, ok := attributes["wlan_limit_up_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wlan_limit_up_enabled is missing from object`)

		return NewOrgWlansValueUnknown(), diags
	}

	wlanLimitUpEnabledVal, ok := wlanLimitUpEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wlan_limit_up_enabled expected to be basetypes.BoolValue, was: %T`, wlanLimitUpEnabledAttribute))
	}

	wxtagIdsAttribute, ok := attributes["wxtag_ids"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wxtag_ids is missing from object`)

		return NewOrgWlansValueUnknown(), diags
	}

	wxtagIdsVal, ok := wxtagIdsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wxtag_ids expected to be basetypes.ListValue, was: %T`, wxtagIdsAttribute))
	}

	wxtunnelIdAttribute, ok := attributes["wxtunnel_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wxtunnel_id is missing from object`)

		return NewOrgWlansValueUnknown(), diags
	}

	wxtunnelIdVal, ok := wxtunnelIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wxtunnel_id expected to be basetypes.StringValue, was: %T`, wxtunnelIdAttribute))
	}

	wxtunnelRemoteIdAttribute, ok := attributes["wxtunnel_remote_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wxtunnel_remote_id is missing from object`)

		return NewOrgWlansValueUnknown(), diags
	}

	wxtunnelRemoteIdVal, ok := wxtunnelRemoteIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wxtunnel_remote_id expected to be basetypes.StringValue, was: %T`, wxtunnelRemoteIdAttribute))
	}

	if diags.HasError() {
		return NewOrgWlansValueUnknown(), diags
	}

	return OrgWlansValue{
		AcctImmediateUpdate:                  acctImmediateUpdateVal,
		AcctInterimInterval:                  acctInterimIntervalVal,
		AcctServers:                          acctServersVal,
		Airwatch:                             airwatchVal,
		AllowIpv6Ndp:                         allowIpv6NdpVal,
		AllowMdns:                            allowMdnsVal,
		AllowSsdp:                            allowSsdpVal,
		ApIds:                                apIdsVal,
		AppLimit:                             appLimitVal,
		AppQos:                               appQosVal,
		ApplyTo:                              applyToVal,
		ArpFilter:                            arpFilterVal,
		Auth:                                 authVal,
		AuthServerSelection:                  authServerSelectionVal,
		AuthServers:                          authServersVal,
		AuthServersNasId:                     authServersNasIdVal,
		AuthServersNasIp:                     authServersNasIpVal,
		AuthServersRetries:                   authServersRetriesVal,
		AuthServersTimeout:                   authServersTimeoutVal,
		BandSteer:                            bandSteerVal,
		BandSteerForceBand5:                  bandSteerForceBand5Val,
		Bands:                                bandsVal,
		BlockBlacklistClients:                blockBlacklistClientsVal,
		Bonjour:                              bonjourVal,
		CiscoCwa:                             ciscoCwaVal,
		ClientLimitDown:                      clientLimitDownVal,
		ClientLimitDownEnabled:               clientLimitDownEnabledVal,
		ClientLimitUp:                        clientLimitUpVal,
		ClientLimitUpEnabled:                 clientLimitUpEnabledVal,
		CoaServers:                           coaServersVal,
		CreatedTime:                          createdTimeVal,
		Disable11ax:                          disable11axVal,
		DisableHtVhtRates:                    disableHtVhtRatesVal,
		DisableUapsd:                         disableUapsdVal,
		DisableV1RoamNotify:                  disableV1RoamNotifyVal,
		DisableV2RoamNotify:                  disableV2RoamNotifyVal,
		DisableWhenGatewayUnreachable:        disableWhenGatewayUnreachableVal,
		DisableWhenMxtunnelDown:              disableWhenMxtunnelDownVal,
		DisableWmm:                           disableWmmVal,
		DnsServerRewrite:                     dnsServerRewriteVal,
		Dtim:                                 dtimVal,
		DynamicPsk:                           dynamicPskVal,
		DynamicVlan:                          dynamicVlanVal,
		EnableLocalKeycaching:                enableLocalKeycachingVal,
		EnableWirelessBridging:               enableWirelessBridgingVal,
		EnableWirelessBridgingDhcpTracking:   enableWirelessBridgingDhcpTrackingVal,
		Enabled:                              enabledVal,
		FastDot1xTimers:                      fastDot1xTimersVal,
		HideSsid:                             hideSsidVal,
		HostnameIe:                           hostnameIeVal,
		Hotspot20:                            hotspot20Val,
		Id:                                   idVal,
		InjectDhcpOption82:                   injectDhcpOption82Val,
		Interface:                            interfaceVal,
		Isolation:                            isolationVal,
		L2Isolation:                          l2IsolationVal,
		LegacyOverds:                         legacyOverdsVal,
		LimitBcast:                           limitBcastVal,
		LimitProbeResponse:                   limitProbeResponseVal,
		MaxIdletime:                          maxIdletimeVal,
		MaxNumClients:                        maxNumClientsVal,
		MistNac:                              mistNacVal,
		ModifiedTime:                         modifiedTimeVal,
		MspId:                                mspIdVal,
		MxtunnelIds:                          mxtunnelIdsVal,
		MxtunnelName:                         mxtunnelNameVal,
		NoStaticDns:                          noStaticDnsVal,
		NoStaticIp:                           noStaticIpVal,
		OrgId:                                orgIdVal,
		Portal:                               portalVal,
		PortalAllowedHostnames:               portalAllowedHostnamesVal,
		PortalAllowedSubnets:                 portalAllowedSubnetsVal,
		PortalApiSecret:                      portalApiSecretVal,
		PortalDeniedHostnames:                portalDeniedHostnamesVal,
		PortalImage:                          portalImageVal,
		PortalSsoUrl:                         portalSsoUrlVal,
		Qos:                                  qosVal,
		Radsec:                               radsecVal,
		Rateset:                              ratesetVal,
		ReconnectClientsWhenRoamingMxcluster: reconnectClientsWhenRoamingMxclusterVal,
		RoamMode:                             roamModeVal,
		Schedule:                             scheduleVal,
		SleExcluded:                          sleExcludedVal,
		Ssid:                                 ssidVal,
		TemplateId:                           templateIdVal,
		UseEapolV1:                           useEapolV1Val,
		VlanEnabled:                          vlanEnabledVal,
		VlanId:                               vlanIdVal,
		VlanIds:                              vlanIdsVal,
		VlanPooling:                          vlanPoolingVal,
		WlanLimitDown:                        wlanLimitDownVal,
		WlanLimitDownEnabled:                 wlanLimitDownEnabledVal,
		WlanLimitUp:                          wlanLimitUpVal,
		WlanLimitUpEnabled:                   wlanLimitUpEnabledVal,
		WxtagIds:                             wxtagIdsVal,
		WxtunnelId:                           wxtunnelIdVal,
		WxtunnelRemoteId:                     wxtunnelRemoteIdVal,
		state:                                attr.ValueStateKnown,
	}, diags
}

func NewOrgWlansValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) OrgWlansValue {
	object, diags := NewOrgWlansValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewOrgWlansValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t OrgWlansType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewOrgWlansValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewOrgWlansValueUnknown(), nil
	}

	if in.IsNull() {
		return NewOrgWlansValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewOrgWlansValueMust(OrgWlansValue{}.AttributeTypes(ctx), attributes), nil
}

func (t OrgWlansType) ValueType(ctx context.Context) attr.Value {
	return OrgWlansValue{}
}

var _ basetypes.ObjectValuable = OrgWlansValue{}

type OrgWlansValue struct {
	AcctImmediateUpdate                  basetypes.BoolValue    `tfsdk:"acct_immediate_update"`
	AcctInterimInterval                  basetypes.Int64Value   `tfsdk:"acct_interim_interval"`
	AcctServers                          basetypes.ListValue    `tfsdk:"acct_servers"`
	Airwatch                             basetypes.ObjectValue  `tfsdk:"airwatch"`
	AllowIpv6Ndp                         basetypes.BoolValue    `tfsdk:"allow_ipv6_ndp"`
	AllowMdns                            basetypes.BoolValue    `tfsdk:"allow_mdns"`
	AllowSsdp                            basetypes.BoolValue    `tfsdk:"allow_ssdp"`
	ApIds                                basetypes.ListValue    `tfsdk:"ap_ids"`
	AppLimit                             basetypes.ObjectValue  `tfsdk:"app_limit"`
	AppQos                               basetypes.ObjectValue  `tfsdk:"app_qos"`
	ApplyTo                              basetypes.StringValue  `tfsdk:"apply_to"`
	ArpFilter                            basetypes.BoolValue    `tfsdk:"arp_filter"`
	Auth                                 basetypes.ObjectValue  `tfsdk:"auth"`
	AuthServerSelection                  basetypes.StringValue  `tfsdk:"auth_server_selection"`
	AuthServers                          basetypes.ListValue    `tfsdk:"auth_servers"`
	AuthServersNasId                     basetypes.StringValue  `tfsdk:"auth_servers_nas_id"`
	AuthServersNasIp                     basetypes.StringValue  `tfsdk:"auth_servers_nas_ip"`
	AuthServersRetries                   basetypes.Int64Value   `tfsdk:"auth_servers_retries"`
	AuthServersTimeout                   basetypes.Int64Value   `tfsdk:"auth_servers_timeout"`
	BandSteer                            basetypes.BoolValue    `tfsdk:"band_steer"`
	BandSteerForceBand5                  basetypes.BoolValue    `tfsdk:"band_steer_force_band5"`
	Bands                                basetypes.ListValue    `tfsdk:"bands"`
	BlockBlacklistClients                basetypes.BoolValue    `tfsdk:"block_blacklist_clients"`
	Bonjour                              basetypes.ObjectValue  `tfsdk:"bonjour"`
	CiscoCwa                             basetypes.ObjectValue  `tfsdk:"cisco_cwa"`
	ClientLimitDown                      basetypes.Int64Value   `tfsdk:"client_limit_down"`
	ClientLimitDownEnabled               basetypes.BoolValue    `tfsdk:"client_limit_down_enabled"`
	ClientLimitUp                        basetypes.Int64Value   `tfsdk:"client_limit_up"`
	ClientLimitUpEnabled                 basetypes.BoolValue    `tfsdk:"client_limit_up_enabled"`
	CoaServers                           basetypes.ListValue    `tfsdk:"coa_servers"`
	CreatedTime                          basetypes.Float64Value `tfsdk:"created_time"`
	Disable11ax                          basetypes.BoolValue    `tfsdk:"disable_11ax"`
	DisableHtVhtRates                    basetypes.BoolValue    `tfsdk:"disable_ht_vht_rates"`
	DisableUapsd                         basetypes.BoolValue    `tfsdk:"disable_uapsd"`
	DisableV1RoamNotify                  basetypes.BoolValue    `tfsdk:"disable_v1_roam_notify"`
	DisableV2RoamNotify                  basetypes.BoolValue    `tfsdk:"disable_v2_roam_notify"`
	DisableWhenGatewayUnreachable        basetypes.BoolValue    `tfsdk:"disable_when_gateway_unreachable"`
	DisableWhenMxtunnelDown              basetypes.BoolValue    `tfsdk:"disable_when_mxtunnel_down"`
	DisableWmm                           basetypes.BoolValue    `tfsdk:"disable_wmm"`
	DnsServerRewrite                     basetypes.ObjectValue  `tfsdk:"dns_server_rewrite"`
	Dtim                                 basetypes.Int64Value   `tfsdk:"dtim"`
	DynamicPsk                           basetypes.ObjectValue  `tfsdk:"dynamic_psk"`
	DynamicVlan                          basetypes.ObjectValue  `tfsdk:"dynamic_vlan"`
	EnableLocalKeycaching                basetypes.BoolValue    `tfsdk:"enable_local_keycaching"`
	EnableWirelessBridging               basetypes.BoolValue    `tfsdk:"enable_wireless_bridging"`
	EnableWirelessBridgingDhcpTracking   basetypes.BoolValue    `tfsdk:"enable_wireless_bridging_dhcp_tracking"`
	Enabled                              basetypes.BoolValue    `tfsdk:"enabled"`
	FastDot1xTimers                      basetypes.BoolValue    `tfsdk:"fast_dot1x_timers"`
	HideSsid                             basetypes.BoolValue    `tfsdk:"hide_ssid"`
	HostnameIe                           basetypes.BoolValue    `tfsdk:"hostname_ie"`
	Hotspot20                            basetypes.ObjectValue  `tfsdk:"hotspot20"`
	Id                                   basetypes.StringValue  `tfsdk:"id"`
	InjectDhcpOption82                   basetypes.ObjectValue  `tfsdk:"inject_dhcp_option_82"`
	Interface                            basetypes.StringValue  `tfsdk:"interface"`
	Isolation                            basetypes.BoolValue    `tfsdk:"isolation"`
	L2Isolation                          basetypes.BoolValue    `tfsdk:"l2_isolation"`
	LegacyOverds                         basetypes.BoolValue    `tfsdk:"legacy_overds"`
	LimitBcast                           basetypes.BoolValue    `tfsdk:"limit_bcast"`
	LimitProbeResponse                   basetypes.BoolValue    `tfsdk:"limit_probe_response"`
	MaxIdletime                          basetypes.Int64Value   `tfsdk:"max_idletime"`
	MaxNumClients                        basetypes.Int64Value   `tfsdk:"max_num_clients"`
	MistNac                              basetypes.ObjectValue  `tfsdk:"mist_nac"`
	ModifiedTime                         basetypes.Float64Value `tfsdk:"modified_time"`
	MspId                                basetypes.StringValue  `tfsdk:"msp_id"`
	MxtunnelIds                          basetypes.ListValue    `tfsdk:"mxtunnel_ids"`
	MxtunnelName                         basetypes.ListValue    `tfsdk:"mxtunnel_name"`
	NoStaticDns                          basetypes.BoolValue    `tfsdk:"no_static_dns"`
	NoStaticIp                           basetypes.BoolValue    `tfsdk:"no_static_ip"`
	OrgId                                basetypes.StringValue  `tfsdk:"org_id"`
	Portal                               basetypes.ObjectValue  `tfsdk:"portal"`
	PortalAllowedHostnames               basetypes.ListValue    `tfsdk:"portal_allowed_hostnames"`
	PortalAllowedSubnets                 basetypes.ListValue    `tfsdk:"portal_allowed_subnets"`
	PortalApiSecret                      basetypes.StringValue  `tfsdk:"portal_api_secret"`
	PortalDeniedHostnames                basetypes.ListValue    `tfsdk:"portal_denied_hostnames"`
	PortalImage                          basetypes.StringValue  `tfsdk:"portal_image"`
	PortalSsoUrl                         basetypes.StringValue  `tfsdk:"portal_sso_url"`
	Qos                                  basetypes.ObjectValue  `tfsdk:"qos"`
	Radsec                               basetypes.ObjectValue  `tfsdk:"radsec"`
	Rateset                              basetypes.MapValue     `tfsdk:"rateset"`
	ReconnectClientsWhenRoamingMxcluster basetypes.BoolValue    `tfsdk:"reconnect_clients_when_roaming_mxcluster"`
	RoamMode                             basetypes.StringValue  `tfsdk:"roam_mode"`
	Schedule                             basetypes.ObjectValue  `tfsdk:"schedule"`
	SleExcluded                          basetypes.BoolValue    `tfsdk:"sle_excluded"`
	Ssid                                 basetypes.StringValue  `tfsdk:"ssid"`
	TemplateId                           basetypes.StringValue  `tfsdk:"template_id"`
	UseEapolV1                           basetypes.BoolValue    `tfsdk:"use_eapol_v1"`
	VlanEnabled                          basetypes.BoolValue    `tfsdk:"vlan_enabled"`
	VlanId                               basetypes.StringValue  `tfsdk:"vlan_id"`
	VlanIds                              basetypes.ListValue    `tfsdk:"vlan_ids"`
	VlanPooling                          basetypes.BoolValue    `tfsdk:"vlan_pooling"`
	WlanLimitDown                        basetypes.Int64Value   `tfsdk:"wlan_limit_down"`
	WlanLimitDownEnabled                 basetypes.BoolValue    `tfsdk:"wlan_limit_down_enabled"`
	WlanLimitUp                          basetypes.Int64Value   `tfsdk:"wlan_limit_up"`
	WlanLimitUpEnabled                   basetypes.BoolValue    `tfsdk:"wlan_limit_up_enabled"`
	WxtagIds                             basetypes.ListValue    `tfsdk:"wxtag_ids"`
	WxtunnelId                           basetypes.StringValue  `tfsdk:"wxtunnel_id"`
	WxtunnelRemoteId                     basetypes.StringValue  `tfsdk:"wxtunnel_remote_id"`
	state                                attr.ValueState
}

func (v OrgWlansValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 97)

	var val tftypes.Value
	var err error

	attrTypes["acct_immediate_update"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["acct_interim_interval"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["acct_servers"] = basetypes.ListType{
		ElemType: AcctServersValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["airwatch"] = basetypes.ObjectType{
		AttrTypes: AirwatchValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["allow_ipv6_ndp"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["allow_mdns"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["allow_ssdp"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["ap_ids"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["app_limit"] = basetypes.ObjectType{
		AttrTypes: AppLimitValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["app_qos"] = basetypes.ObjectType{
		AttrTypes: AppQosValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["apply_to"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["arp_filter"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["auth"] = basetypes.ObjectType{
		AttrTypes: AuthValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["auth_server_selection"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["auth_servers"] = basetypes.ListType{
		ElemType: AuthServersValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["auth_servers_nas_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["auth_servers_nas_ip"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["auth_servers_retries"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["auth_servers_timeout"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["band_steer"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["band_steer_force_band5"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["bands"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["block_blacklist_clients"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["bonjour"] = basetypes.ObjectType{
		AttrTypes: BonjourValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["cisco_cwa"] = basetypes.ObjectType{
		AttrTypes: CiscoCwaValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["client_limit_down"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["client_limit_down_enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["client_limit_up"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["client_limit_up_enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["coa_servers"] = basetypes.ListType{
		ElemType: CoaServersValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["created_time"] = basetypes.Float64Type{}.TerraformType(ctx)
	attrTypes["disable_11ax"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["disable_ht_vht_rates"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["disable_uapsd"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["disable_v1_roam_notify"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["disable_v2_roam_notify"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["disable_when_gateway_unreachable"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["disable_when_mxtunnel_down"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["disable_wmm"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["dns_server_rewrite"] = basetypes.ObjectType{
		AttrTypes: DnsServerRewriteValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["dtim"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["dynamic_psk"] = basetypes.ObjectType{
		AttrTypes: DynamicPskValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["dynamic_vlan"] = basetypes.ObjectType{
		AttrTypes: DynamicVlanValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["enable_local_keycaching"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["enable_wireless_bridging"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["enable_wireless_bridging_dhcp_tracking"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["fast_dot1x_timers"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["hide_ssid"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["hostname_ie"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["hotspot20"] = basetypes.ObjectType{
		AttrTypes: Hotspot20Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["inject_dhcp_option_82"] = basetypes.ObjectType{
		AttrTypes: InjectDhcpOption82Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["interface"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["isolation"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["l2_isolation"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["legacy_overds"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["limit_bcast"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["limit_probe_response"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["max_idletime"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["max_num_clients"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["mist_nac"] = basetypes.ObjectType{
		AttrTypes: MistNacValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["modified_time"] = basetypes.Float64Type{}.TerraformType(ctx)
	attrTypes["msp_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["mxtunnel_ids"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["mxtunnel_name"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["no_static_dns"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["no_static_ip"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["org_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["portal"] = basetypes.ObjectType{
		AttrTypes: PortalValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["portal_allowed_hostnames"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["portal_allowed_subnets"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["portal_api_secret"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["portal_denied_hostnames"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["portal_image"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["portal_sso_url"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["qos"] = basetypes.ObjectType{
		AttrTypes: QosValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["radsec"] = basetypes.ObjectType{
		AttrTypes: RadsecValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["rateset"] = basetypes.MapType{
		ElemType: RatesetValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["reconnect_clients_when_roaming_mxcluster"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["roam_mode"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["schedule"] = basetypes.ObjectType{
		AttrTypes: ScheduleValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["sle_excluded"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["ssid"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["template_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["use_eapol_v1"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["vlan_enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["vlan_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["vlan_ids"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["vlan_pooling"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["wlan_limit_down"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["wlan_limit_down_enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["wlan_limit_up"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["wlan_limit_up_enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["wxtag_ids"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["wxtunnel_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["wxtunnel_remote_id"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 97)

		val, err = v.AcctImmediateUpdate.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["acct_immediate_update"] = val

		val, err = v.AcctInterimInterval.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["acct_interim_interval"] = val

		val, err = v.AcctServers.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["acct_servers"] = val

		val, err = v.Airwatch.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["airwatch"] = val

		val, err = v.AllowIpv6Ndp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["allow_ipv6_ndp"] = val

		val, err = v.AllowMdns.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["allow_mdns"] = val

		val, err = v.AllowSsdp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["allow_ssdp"] = val

		val, err = v.ApIds.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ap_ids"] = val

		val, err = v.AppLimit.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["app_limit"] = val

		val, err = v.AppQos.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["app_qos"] = val

		val, err = v.ApplyTo.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["apply_to"] = val

		val, err = v.ArpFilter.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["arp_filter"] = val

		val, err = v.Auth.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["auth"] = val

		val, err = v.AuthServerSelection.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["auth_server_selection"] = val

		val, err = v.AuthServers.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["auth_servers"] = val

		val, err = v.AuthServersNasId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["auth_servers_nas_id"] = val

		val, err = v.AuthServersNasIp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["auth_servers_nas_ip"] = val

		val, err = v.AuthServersRetries.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["auth_servers_retries"] = val

		val, err = v.AuthServersTimeout.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["auth_servers_timeout"] = val

		val, err = v.BandSteer.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["band_steer"] = val

		val, err = v.BandSteerForceBand5.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["band_steer_force_band5"] = val

		val, err = v.Bands.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bands"] = val

		val, err = v.BlockBlacklistClients.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["block_blacklist_clients"] = val

		val, err = v.Bonjour.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bonjour"] = val

		val, err = v.CiscoCwa.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cisco_cwa"] = val

		val, err = v.ClientLimitDown.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["client_limit_down"] = val

		val, err = v.ClientLimitDownEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["client_limit_down_enabled"] = val

		val, err = v.ClientLimitUp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["client_limit_up"] = val

		val, err = v.ClientLimitUpEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["client_limit_up_enabled"] = val

		val, err = v.CoaServers.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["coa_servers"] = val

		val, err = v.CreatedTime.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["created_time"] = val

		val, err = v.Disable11ax.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["disable_11ax"] = val

		val, err = v.DisableHtVhtRates.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["disable_ht_vht_rates"] = val

		val, err = v.DisableUapsd.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["disable_uapsd"] = val

		val, err = v.DisableV1RoamNotify.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["disable_v1_roam_notify"] = val

		val, err = v.DisableV2RoamNotify.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["disable_v2_roam_notify"] = val

		val, err = v.DisableWhenGatewayUnreachable.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["disable_when_gateway_unreachable"] = val

		val, err = v.DisableWhenMxtunnelDown.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["disable_when_mxtunnel_down"] = val

		val, err = v.DisableWmm.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["disable_wmm"] = val

		val, err = v.DnsServerRewrite.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dns_server_rewrite"] = val

		val, err = v.Dtim.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dtim"] = val

		val, err = v.DynamicPsk.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dynamic_psk"] = val

		val, err = v.DynamicVlan.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dynamic_vlan"] = val

		val, err = v.EnableLocalKeycaching.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enable_local_keycaching"] = val

		val, err = v.EnableWirelessBridging.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enable_wireless_bridging"] = val

		val, err = v.EnableWirelessBridgingDhcpTracking.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enable_wireless_bridging_dhcp_tracking"] = val

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.FastDot1xTimers.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["fast_dot1x_timers"] = val

		val, err = v.HideSsid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["hide_ssid"] = val

		val, err = v.HostnameIe.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["hostname_ie"] = val

		val, err = v.Hotspot20.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["hotspot20"] = val

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.InjectDhcpOption82.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["inject_dhcp_option_82"] = val

		val, err = v.Interface.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["interface"] = val

		val, err = v.Isolation.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["isolation"] = val

		val, err = v.L2Isolation.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["l2_isolation"] = val

		val, err = v.LegacyOverds.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["legacy_overds"] = val

		val, err = v.LimitBcast.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["limit_bcast"] = val

		val, err = v.LimitProbeResponse.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["limit_probe_response"] = val

		val, err = v.MaxIdletime.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_idletime"] = val

		val, err = v.MaxNumClients.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_num_clients"] = val

		val, err = v.MistNac.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mist_nac"] = val

		val, err = v.ModifiedTime.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["modified_time"] = val

		val, err = v.MspId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["msp_id"] = val

		val, err = v.MxtunnelIds.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mxtunnel_ids"] = val

		val, err = v.MxtunnelName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mxtunnel_name"] = val

		val, err = v.NoStaticDns.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["no_static_dns"] = val

		val, err = v.NoStaticIp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["no_static_ip"] = val

		val, err = v.OrgId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["org_id"] = val

		val, err = v.Portal.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["portal"] = val

		val, err = v.PortalAllowedHostnames.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["portal_allowed_hostnames"] = val

		val, err = v.PortalAllowedSubnets.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["portal_allowed_subnets"] = val

		val, err = v.PortalApiSecret.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["portal_api_secret"] = val

		val, err = v.PortalDeniedHostnames.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["portal_denied_hostnames"] = val

		val, err = v.PortalImage.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["portal_image"] = val

		val, err = v.PortalSsoUrl.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["portal_sso_url"] = val

		val, err = v.Qos.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["qos"] = val

		val, err = v.Radsec.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["radsec"] = val

		val, err = v.Rateset.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["rateset"] = val

		val, err = v.ReconnectClientsWhenRoamingMxcluster.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["reconnect_clients_when_roaming_mxcluster"] = val

		val, err = v.RoamMode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["roam_mode"] = val

		val, err = v.Schedule.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["schedule"] = val

		val, err = v.SleExcluded.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["sle_excluded"] = val

		val, err = v.Ssid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ssid"] = val

		val, err = v.TemplateId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["template_id"] = val

		val, err = v.UseEapolV1.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["use_eapol_v1"] = val

		val, err = v.VlanEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vlan_enabled"] = val

		val, err = v.VlanId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vlan_id"] = val

		val, err = v.VlanIds.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vlan_ids"] = val

		val, err = v.VlanPooling.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vlan_pooling"] = val

		val, err = v.WlanLimitDown.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["wlan_limit_down"] = val

		val, err = v.WlanLimitDownEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["wlan_limit_down_enabled"] = val

		val, err = v.WlanLimitUp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["wlan_limit_up"] = val

		val, err = v.WlanLimitUpEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["wlan_limit_up_enabled"] = val

		val, err = v.WxtagIds.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["wxtag_ids"] = val

		val, err = v.WxtunnelId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["wxtunnel_id"] = val

		val, err = v.WxtunnelRemoteId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["wxtunnel_remote_id"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v OrgWlansValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v OrgWlansValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v OrgWlansValue) String() string {
	return "OrgWlansValue"
}

func (v OrgWlansValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	acctServers := types.ListValueMust(
		AcctServersType{
			basetypes.ObjectType{
				AttrTypes: AcctServersValue{}.AttributeTypes(ctx),
			},
		},
		v.AcctServers.Elements(),
	)

	if v.AcctServers.IsNull() {
		acctServers = types.ListNull(
			AcctServersType{
				basetypes.ObjectType{
					AttrTypes: AcctServersValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.AcctServers.IsUnknown() {
		acctServers = types.ListUnknown(
			AcctServersType{
				basetypes.ObjectType{
					AttrTypes: AcctServersValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var airwatch basetypes.ObjectValue

	if v.Airwatch.IsNull() {
		airwatch = types.ObjectNull(
			AirwatchValue{}.AttributeTypes(ctx),
		)
	}

	if v.Airwatch.IsUnknown() {
		airwatch = types.ObjectUnknown(
			AirwatchValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Airwatch.IsNull() && !v.Airwatch.IsUnknown() {
		airwatch = types.ObjectValueMust(
			AirwatchValue{}.AttributeTypes(ctx),
			v.Airwatch.Attributes(),
		)
	}

	var appLimit basetypes.ObjectValue

	if v.AppLimit.IsNull() {
		appLimit = types.ObjectNull(
			AppLimitValue{}.AttributeTypes(ctx),
		)
	}

	if v.AppLimit.IsUnknown() {
		appLimit = types.ObjectUnknown(
			AppLimitValue{}.AttributeTypes(ctx),
		)
	}

	if !v.AppLimit.IsNull() && !v.AppLimit.IsUnknown() {
		appLimit = types.ObjectValueMust(
			AppLimitValue{}.AttributeTypes(ctx),
			v.AppLimit.Attributes(),
		)
	}

	var appQos basetypes.ObjectValue

	if v.AppQos.IsNull() {
		appQos = types.ObjectNull(
			AppQosValue{}.AttributeTypes(ctx),
		)
	}

	if v.AppQos.IsUnknown() {
		appQos = types.ObjectUnknown(
			AppQosValue{}.AttributeTypes(ctx),
		)
	}

	if !v.AppQos.IsNull() && !v.AppQos.IsUnknown() {
		appQos = types.ObjectValueMust(
			AppQosValue{}.AttributeTypes(ctx),
			v.AppQos.Attributes(),
		)
	}

	var auth basetypes.ObjectValue

	if v.Auth.IsNull() {
		auth = types.ObjectNull(
			AuthValue{}.AttributeTypes(ctx),
		)
	}

	if v.Auth.IsUnknown() {
		auth = types.ObjectUnknown(
			AuthValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Auth.IsNull() && !v.Auth.IsUnknown() {
		auth = types.ObjectValueMust(
			AuthValue{}.AttributeTypes(ctx),
			v.Auth.Attributes(),
		)
	}

	authServers := types.ListValueMust(
		AuthServersType{
			basetypes.ObjectType{
				AttrTypes: AuthServersValue{}.AttributeTypes(ctx),
			},
		},
		v.AuthServers.Elements(),
	)

	if v.AuthServers.IsNull() {
		authServers = types.ListNull(
			AuthServersType{
				basetypes.ObjectType{
					AttrTypes: AuthServersValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.AuthServers.IsUnknown() {
		authServers = types.ListUnknown(
			AuthServersType{
				basetypes.ObjectType{
					AttrTypes: AuthServersValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var bonjour basetypes.ObjectValue

	if v.Bonjour.IsNull() {
		bonjour = types.ObjectNull(
			BonjourValue{}.AttributeTypes(ctx),
		)
	}

	if v.Bonjour.IsUnknown() {
		bonjour = types.ObjectUnknown(
			BonjourValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Bonjour.IsNull() && !v.Bonjour.IsUnknown() {
		bonjour = types.ObjectValueMust(
			BonjourValue{}.AttributeTypes(ctx),
			v.Bonjour.Attributes(),
		)
	}

	var ciscoCwa basetypes.ObjectValue

	if v.CiscoCwa.IsNull() {
		ciscoCwa = types.ObjectNull(
			CiscoCwaValue{}.AttributeTypes(ctx),
		)
	}

	if v.CiscoCwa.IsUnknown() {
		ciscoCwa = types.ObjectUnknown(
			CiscoCwaValue{}.AttributeTypes(ctx),
		)
	}

	if !v.CiscoCwa.IsNull() && !v.CiscoCwa.IsUnknown() {
		ciscoCwa = types.ObjectValueMust(
			CiscoCwaValue{}.AttributeTypes(ctx),
			v.CiscoCwa.Attributes(),
		)
	}

	coaServers := types.ListValueMust(
		CoaServersType{
			basetypes.ObjectType{
				AttrTypes: CoaServersValue{}.AttributeTypes(ctx),
			},
		},
		v.CoaServers.Elements(),
	)

	if v.CoaServers.IsNull() {
		coaServers = types.ListNull(
			CoaServersType{
				basetypes.ObjectType{
					AttrTypes: CoaServersValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.CoaServers.IsUnknown() {
		coaServers = types.ListUnknown(
			CoaServersType{
				basetypes.ObjectType{
					AttrTypes: CoaServersValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var dnsServerRewrite basetypes.ObjectValue

	if v.DnsServerRewrite.IsNull() {
		dnsServerRewrite = types.ObjectNull(
			DnsServerRewriteValue{}.AttributeTypes(ctx),
		)
	}

	if v.DnsServerRewrite.IsUnknown() {
		dnsServerRewrite = types.ObjectUnknown(
			DnsServerRewriteValue{}.AttributeTypes(ctx),
		)
	}

	if !v.DnsServerRewrite.IsNull() && !v.DnsServerRewrite.IsUnknown() {
		dnsServerRewrite = types.ObjectValueMust(
			DnsServerRewriteValue{}.AttributeTypes(ctx),
			v.DnsServerRewrite.Attributes(),
		)
	}

	var dynamicPsk basetypes.ObjectValue

	if v.DynamicPsk.IsNull() {
		dynamicPsk = types.ObjectNull(
			DynamicPskValue{}.AttributeTypes(ctx),
		)
	}

	if v.DynamicPsk.IsUnknown() {
		dynamicPsk = types.ObjectUnknown(
			DynamicPskValue{}.AttributeTypes(ctx),
		)
	}

	if !v.DynamicPsk.IsNull() && !v.DynamicPsk.IsUnknown() {
		dynamicPsk = types.ObjectValueMust(
			DynamicPskValue{}.AttributeTypes(ctx),
			v.DynamicPsk.Attributes(),
		)
	}

	var dynamicVlan basetypes.ObjectValue

	if v.DynamicVlan.IsNull() {
		dynamicVlan = types.ObjectNull(
			DynamicVlanValue{}.AttributeTypes(ctx),
		)
	}

	if v.DynamicVlan.IsUnknown() {
		dynamicVlan = types.ObjectUnknown(
			DynamicVlanValue{}.AttributeTypes(ctx),
		)
	}

	if !v.DynamicVlan.IsNull() && !v.DynamicVlan.IsUnknown() {
		dynamicVlan = types.ObjectValueMust(
			DynamicVlanValue{}.AttributeTypes(ctx),
			v.DynamicVlan.Attributes(),
		)
	}

	var hotspot20 basetypes.ObjectValue

	if v.Hotspot20.IsNull() {
		hotspot20 = types.ObjectNull(
			Hotspot20Value{}.AttributeTypes(ctx),
		)
	}

	if v.Hotspot20.IsUnknown() {
		hotspot20 = types.ObjectUnknown(
			Hotspot20Value{}.AttributeTypes(ctx),
		)
	}

	if !v.Hotspot20.IsNull() && !v.Hotspot20.IsUnknown() {
		hotspot20 = types.ObjectValueMust(
			Hotspot20Value{}.AttributeTypes(ctx),
			v.Hotspot20.Attributes(),
		)
	}

	var injectDhcpOption82 basetypes.ObjectValue

	if v.InjectDhcpOption82.IsNull() {
		injectDhcpOption82 = types.ObjectNull(
			InjectDhcpOption82Value{}.AttributeTypes(ctx),
		)
	}

	if v.InjectDhcpOption82.IsUnknown() {
		injectDhcpOption82 = types.ObjectUnknown(
			InjectDhcpOption82Value{}.AttributeTypes(ctx),
		)
	}

	if !v.InjectDhcpOption82.IsNull() && !v.InjectDhcpOption82.IsUnknown() {
		injectDhcpOption82 = types.ObjectValueMust(
			InjectDhcpOption82Value{}.AttributeTypes(ctx),
			v.InjectDhcpOption82.Attributes(),
		)
	}

	var mistNac basetypes.ObjectValue

	if v.MistNac.IsNull() {
		mistNac = types.ObjectNull(
			MistNacValue{}.AttributeTypes(ctx),
		)
	}

	if v.MistNac.IsUnknown() {
		mistNac = types.ObjectUnknown(
			MistNacValue{}.AttributeTypes(ctx),
		)
	}

	if !v.MistNac.IsNull() && !v.MistNac.IsUnknown() {
		mistNac = types.ObjectValueMust(
			MistNacValue{}.AttributeTypes(ctx),
			v.MistNac.Attributes(),
		)
	}

	var portal basetypes.ObjectValue

	if v.Portal.IsNull() {
		portal = types.ObjectNull(
			PortalValue{}.AttributeTypes(ctx),
		)
	}

	if v.Portal.IsUnknown() {
		portal = types.ObjectUnknown(
			PortalValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Portal.IsNull() && !v.Portal.IsUnknown() {
		portal = types.ObjectValueMust(
			PortalValue{}.AttributeTypes(ctx),
			v.Portal.Attributes(),
		)
	}

	var qos basetypes.ObjectValue

	if v.Qos.IsNull() {
		qos = types.ObjectNull(
			QosValue{}.AttributeTypes(ctx),
		)
	}

	if v.Qos.IsUnknown() {
		qos = types.ObjectUnknown(
			QosValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Qos.IsNull() && !v.Qos.IsUnknown() {
		qos = types.ObjectValueMust(
			QosValue{}.AttributeTypes(ctx),
			v.Qos.Attributes(),
		)
	}

	var radsec basetypes.ObjectValue

	if v.Radsec.IsNull() {
		radsec = types.ObjectNull(
			RadsecValue{}.AttributeTypes(ctx),
		)
	}

	if v.Radsec.IsUnknown() {
		radsec = types.ObjectUnknown(
			RadsecValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Radsec.IsNull() && !v.Radsec.IsUnknown() {
		radsec = types.ObjectValueMust(
			RadsecValue{}.AttributeTypes(ctx),
			v.Radsec.Attributes(),
		)
	}

	rateset := types.MapValueMust(
		RatesetType{
			basetypes.ObjectType{
				AttrTypes: RatesetValue{}.AttributeTypes(ctx),
			},
		},
		v.Rateset.Elements(),
	)

	if v.Rateset.IsNull() {
		rateset = types.MapNull(
			RatesetType{
				basetypes.ObjectType{
					AttrTypes: RatesetValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Rateset.IsUnknown() {
		rateset = types.MapUnknown(
			RatesetType{
				basetypes.ObjectType{
					AttrTypes: RatesetValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var schedule basetypes.ObjectValue

	if v.Schedule.IsNull() {
		schedule = types.ObjectNull(
			ScheduleValue{}.AttributeTypes(ctx),
		)
	}

	if v.Schedule.IsUnknown() {
		schedule = types.ObjectUnknown(
			ScheduleValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Schedule.IsNull() && !v.Schedule.IsUnknown() {
		schedule = types.ObjectValueMust(
			ScheduleValue{}.AttributeTypes(ctx),
			v.Schedule.Attributes(),
		)
	}

	apIdsVal, d := types.ListValue(types.StringType, v.ApIds.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"acct_immediate_update": basetypes.BoolType{},
			"acct_interim_interval": basetypes.Int64Type{},
			"acct_servers": basetypes.ListType{
				ElemType: AcctServersValue{}.Type(ctx),
			},
			"airwatch": basetypes.ObjectType{
				AttrTypes: AirwatchValue{}.AttributeTypes(ctx),
			},
			"allow_ipv6_ndp": basetypes.BoolType{},
			"allow_mdns":     basetypes.BoolType{},
			"allow_ssdp":     basetypes.BoolType{},
			"ap_ids": basetypes.ListType{
				ElemType: types.StringType,
			},
			"app_limit": basetypes.ObjectType{
				AttrTypes: AppLimitValue{}.AttributeTypes(ctx),
			},
			"app_qos": basetypes.ObjectType{
				AttrTypes: AppQosValue{}.AttributeTypes(ctx),
			},
			"apply_to":   basetypes.StringType{},
			"arp_filter": basetypes.BoolType{},
			"auth": basetypes.ObjectType{
				AttrTypes: AuthValue{}.AttributeTypes(ctx),
			},
			"auth_server_selection": basetypes.StringType{},
			"auth_servers": basetypes.ListType{
				ElemType: AuthServersValue{}.Type(ctx),
			},
			"auth_servers_nas_id":    basetypes.StringType{},
			"auth_servers_nas_ip":    basetypes.StringType{},
			"auth_servers_retries":   basetypes.Int64Type{},
			"auth_servers_timeout":   basetypes.Int64Type{},
			"band_steer":             basetypes.BoolType{},
			"band_steer_force_band5": basetypes.BoolType{},
			"bands": basetypes.ListType{
				ElemType: types.StringType,
			},
			"block_blacklist_clients": basetypes.BoolType{},
			"bonjour": basetypes.ObjectType{
				AttrTypes: BonjourValue{}.AttributeTypes(ctx),
			},
			"cisco_cwa": basetypes.ObjectType{
				AttrTypes: CiscoCwaValue{}.AttributeTypes(ctx),
			},
			"client_limit_down":         basetypes.Int64Type{},
			"client_limit_down_enabled": basetypes.BoolType{},
			"client_limit_up":           basetypes.Int64Type{},
			"client_limit_up_enabled":   basetypes.BoolType{},
			"coa_servers": basetypes.ListType{
				ElemType: CoaServersValue{}.Type(ctx),
			},
			"created_time":                     basetypes.Float64Type{},
			"disable_11ax":                     basetypes.BoolType{},
			"disable_ht_vht_rates":             basetypes.BoolType{},
			"disable_uapsd":                    basetypes.BoolType{},
			"disable_v1_roam_notify":           basetypes.BoolType{},
			"disable_v2_roam_notify":           basetypes.BoolType{},
			"disable_when_gateway_unreachable": basetypes.BoolType{},
			"disable_when_mxtunnel_down":       basetypes.BoolType{},
			"disable_wmm":                      basetypes.BoolType{},
			"dns_server_rewrite": basetypes.ObjectType{
				AttrTypes: DnsServerRewriteValue{}.AttributeTypes(ctx),
			},
			"dtim": basetypes.Int64Type{},
			"dynamic_psk": basetypes.ObjectType{
				AttrTypes: DynamicPskValue{}.AttributeTypes(ctx),
			},
			"dynamic_vlan": basetypes.ObjectType{
				AttrTypes: DynamicVlanValue{}.AttributeTypes(ctx),
			},
			"enable_local_keycaching":                basetypes.BoolType{},
			"enable_wireless_bridging":               basetypes.BoolType{},
			"enable_wireless_bridging_dhcp_tracking": basetypes.BoolType{},
			"enabled":                                basetypes.BoolType{},
			"fast_dot1x_timers":                      basetypes.BoolType{},
			"hide_ssid":                              basetypes.BoolType{},
			"hostname_ie":                            basetypes.BoolType{},
			"hotspot20": basetypes.ObjectType{
				AttrTypes: Hotspot20Value{}.AttributeTypes(ctx),
			},
			"id": basetypes.StringType{},
			"inject_dhcp_option_82": basetypes.ObjectType{
				AttrTypes: InjectDhcpOption82Value{}.AttributeTypes(ctx),
			},
			"interface":            basetypes.StringType{},
			"isolation":            basetypes.BoolType{},
			"l2_isolation":         basetypes.BoolType{},
			"legacy_overds":        basetypes.BoolType{},
			"limit_bcast":          basetypes.BoolType{},
			"limit_probe_response": basetypes.BoolType{},
			"max_idletime":         basetypes.Int64Type{},
			"max_num_clients":      basetypes.Int64Type{},
			"mist_nac": basetypes.ObjectType{
				AttrTypes: MistNacValue{}.AttributeTypes(ctx),
			},
			"modified_time": basetypes.Float64Type{},
			"msp_id":        basetypes.StringType{},
			"mxtunnel_ids": basetypes.ListType{
				ElemType: types.StringType,
			},
			"mxtunnel_name": basetypes.ListType{
				ElemType: types.StringType,
			},
			"no_static_dns": basetypes.BoolType{},
			"no_static_ip":  basetypes.BoolType{},
			"org_id":        basetypes.StringType{},
			"portal": basetypes.ObjectType{
				AttrTypes: PortalValue{}.AttributeTypes(ctx),
			},
			"portal_allowed_hostnames": basetypes.ListType{
				ElemType: types.StringType,
			},
			"portal_allowed_subnets": basetypes.ListType{
				ElemType: types.StringType,
			},
			"portal_api_secret": basetypes.StringType{},
			"portal_denied_hostnames": basetypes.ListType{
				ElemType: types.StringType,
			},
			"portal_image":   basetypes.StringType{},
			"portal_sso_url": basetypes.StringType{},
			"qos": basetypes.ObjectType{
				AttrTypes: QosValue{}.AttributeTypes(ctx),
			},
			"radsec": basetypes.ObjectType{
				AttrTypes: RadsecValue{}.AttributeTypes(ctx),
			},
			"rateset": basetypes.MapType{
				ElemType: RatesetValue{}.Type(ctx),
			},
			"reconnect_clients_when_roaming_mxcluster": basetypes.BoolType{},
			"roam_mode": basetypes.StringType{},
			"schedule": basetypes.ObjectType{
				AttrTypes: ScheduleValue{}.AttributeTypes(ctx),
			},
			"sle_excluded": basetypes.BoolType{},
			"ssid":         basetypes.StringType{},
			"template_id":  basetypes.StringType{},
			"use_eapol_v1": basetypes.BoolType{},
			"vlan_enabled": basetypes.BoolType{},
			"vlan_id":      basetypes.StringType{},
			"vlan_ids": basetypes.ListType{
				ElemType: types.StringType,
			},
			"vlan_pooling":            basetypes.BoolType{},
			"wlan_limit_down":         basetypes.Int64Type{},
			"wlan_limit_down_enabled": basetypes.BoolType{},
			"wlan_limit_up":           basetypes.Int64Type{},
			"wlan_limit_up_enabled":   basetypes.BoolType{},
			"wxtag_ids": basetypes.ListType{
				ElemType: types.StringType,
			},
			"wxtunnel_id":        basetypes.StringType{},
			"wxtunnel_remote_id": basetypes.StringType{},
		}), diags
	}

	bandsVal, d := types.ListValue(types.StringType, v.Bands.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"acct_immediate_update": basetypes.BoolType{},
			"acct_interim_interval": basetypes.Int64Type{},
			"acct_servers": basetypes.ListType{
				ElemType: AcctServersValue{}.Type(ctx),
			},
			"airwatch": basetypes.ObjectType{
				AttrTypes: AirwatchValue{}.AttributeTypes(ctx),
			},
			"allow_ipv6_ndp": basetypes.BoolType{},
			"allow_mdns":     basetypes.BoolType{},
			"allow_ssdp":     basetypes.BoolType{},
			"ap_ids": basetypes.ListType{
				ElemType: types.StringType,
			},
			"app_limit": basetypes.ObjectType{
				AttrTypes: AppLimitValue{}.AttributeTypes(ctx),
			},
			"app_qos": basetypes.ObjectType{
				AttrTypes: AppQosValue{}.AttributeTypes(ctx),
			},
			"apply_to":   basetypes.StringType{},
			"arp_filter": basetypes.BoolType{},
			"auth": basetypes.ObjectType{
				AttrTypes: AuthValue{}.AttributeTypes(ctx),
			},
			"auth_server_selection": basetypes.StringType{},
			"auth_servers": basetypes.ListType{
				ElemType: AuthServersValue{}.Type(ctx),
			},
			"auth_servers_nas_id":    basetypes.StringType{},
			"auth_servers_nas_ip":    basetypes.StringType{},
			"auth_servers_retries":   basetypes.Int64Type{},
			"auth_servers_timeout":   basetypes.Int64Type{},
			"band_steer":             basetypes.BoolType{},
			"band_steer_force_band5": basetypes.BoolType{},
			"bands": basetypes.ListType{
				ElemType: types.StringType,
			},
			"block_blacklist_clients": basetypes.BoolType{},
			"bonjour": basetypes.ObjectType{
				AttrTypes: BonjourValue{}.AttributeTypes(ctx),
			},
			"cisco_cwa": basetypes.ObjectType{
				AttrTypes: CiscoCwaValue{}.AttributeTypes(ctx),
			},
			"client_limit_down":         basetypes.Int64Type{},
			"client_limit_down_enabled": basetypes.BoolType{},
			"client_limit_up":           basetypes.Int64Type{},
			"client_limit_up_enabled":   basetypes.BoolType{},
			"coa_servers": basetypes.ListType{
				ElemType: CoaServersValue{}.Type(ctx),
			},
			"created_time":                     basetypes.Float64Type{},
			"disable_11ax":                     basetypes.BoolType{},
			"disable_ht_vht_rates":             basetypes.BoolType{},
			"disable_uapsd":                    basetypes.BoolType{},
			"disable_v1_roam_notify":           basetypes.BoolType{},
			"disable_v2_roam_notify":           basetypes.BoolType{},
			"disable_when_gateway_unreachable": basetypes.BoolType{},
			"disable_when_mxtunnel_down":       basetypes.BoolType{},
			"disable_wmm":                      basetypes.BoolType{},
			"dns_server_rewrite": basetypes.ObjectType{
				AttrTypes: DnsServerRewriteValue{}.AttributeTypes(ctx),
			},
			"dtim": basetypes.Int64Type{},
			"dynamic_psk": basetypes.ObjectType{
				AttrTypes: DynamicPskValue{}.AttributeTypes(ctx),
			},
			"dynamic_vlan": basetypes.ObjectType{
				AttrTypes: DynamicVlanValue{}.AttributeTypes(ctx),
			},
			"enable_local_keycaching":                basetypes.BoolType{},
			"enable_wireless_bridging":               basetypes.BoolType{},
			"enable_wireless_bridging_dhcp_tracking": basetypes.BoolType{},
			"enabled":                                basetypes.BoolType{},
			"fast_dot1x_timers":                      basetypes.BoolType{},
			"hide_ssid":                              basetypes.BoolType{},
			"hostname_ie":                            basetypes.BoolType{},
			"hotspot20": basetypes.ObjectType{
				AttrTypes: Hotspot20Value{}.AttributeTypes(ctx),
			},
			"id": basetypes.StringType{},
			"inject_dhcp_option_82": basetypes.ObjectType{
				AttrTypes: InjectDhcpOption82Value{}.AttributeTypes(ctx),
			},
			"interface":            basetypes.StringType{},
			"isolation":            basetypes.BoolType{},
			"l2_isolation":         basetypes.BoolType{},
			"legacy_overds":        basetypes.BoolType{},
			"limit_bcast":          basetypes.BoolType{},
			"limit_probe_response": basetypes.BoolType{},
			"max_idletime":         basetypes.Int64Type{},
			"max_num_clients":      basetypes.Int64Type{},
			"mist_nac": basetypes.ObjectType{
				AttrTypes: MistNacValue{}.AttributeTypes(ctx),
			},
			"modified_time": basetypes.Float64Type{},
			"msp_id":        basetypes.StringType{},
			"mxtunnel_ids": basetypes.ListType{
				ElemType: types.StringType,
			},
			"mxtunnel_name": basetypes.ListType{
				ElemType: types.StringType,
			},
			"no_static_dns": basetypes.BoolType{},
			"no_static_ip":  basetypes.BoolType{},
			"org_id":        basetypes.StringType{},
			"portal": basetypes.ObjectType{
				AttrTypes: PortalValue{}.AttributeTypes(ctx),
			},
			"portal_allowed_hostnames": basetypes.ListType{
				ElemType: types.StringType,
			},
			"portal_allowed_subnets": basetypes.ListType{
				ElemType: types.StringType,
			},
			"portal_api_secret": basetypes.StringType{},
			"portal_denied_hostnames": basetypes.ListType{
				ElemType: types.StringType,
			},
			"portal_image":   basetypes.StringType{},
			"portal_sso_url": basetypes.StringType{},
			"qos": basetypes.ObjectType{
				AttrTypes: QosValue{}.AttributeTypes(ctx),
			},
			"radsec": basetypes.ObjectType{
				AttrTypes: RadsecValue{}.AttributeTypes(ctx),
			},
			"rateset": basetypes.MapType{
				ElemType: RatesetValue{}.Type(ctx),
			},
			"reconnect_clients_when_roaming_mxcluster": basetypes.BoolType{},
			"roam_mode": basetypes.StringType{},
			"schedule": basetypes.ObjectType{
				AttrTypes: ScheduleValue{}.AttributeTypes(ctx),
			},
			"sle_excluded": basetypes.BoolType{},
			"ssid":         basetypes.StringType{},
			"template_id":  basetypes.StringType{},
			"use_eapol_v1": basetypes.BoolType{},
			"vlan_enabled": basetypes.BoolType{},
			"vlan_id":      basetypes.StringType{},
			"vlan_ids": basetypes.ListType{
				ElemType: types.StringType,
			},
			"vlan_pooling":            basetypes.BoolType{},
			"wlan_limit_down":         basetypes.Int64Type{},
			"wlan_limit_down_enabled": basetypes.BoolType{},
			"wlan_limit_up":           basetypes.Int64Type{},
			"wlan_limit_up_enabled":   basetypes.BoolType{},
			"wxtag_ids": basetypes.ListType{
				ElemType: types.StringType,
			},
			"wxtunnel_id":        basetypes.StringType{},
			"wxtunnel_remote_id": basetypes.StringType{},
		}), diags
	}

	mxtunnelIdsVal, d := types.ListValue(types.StringType, v.MxtunnelIds.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"acct_immediate_update": basetypes.BoolType{},
			"acct_interim_interval": basetypes.Int64Type{},
			"acct_servers": basetypes.ListType{
				ElemType: AcctServersValue{}.Type(ctx),
			},
			"airwatch": basetypes.ObjectType{
				AttrTypes: AirwatchValue{}.AttributeTypes(ctx),
			},
			"allow_ipv6_ndp": basetypes.BoolType{},
			"allow_mdns":     basetypes.BoolType{},
			"allow_ssdp":     basetypes.BoolType{},
			"ap_ids": basetypes.ListType{
				ElemType: types.StringType,
			},
			"app_limit": basetypes.ObjectType{
				AttrTypes: AppLimitValue{}.AttributeTypes(ctx),
			},
			"app_qos": basetypes.ObjectType{
				AttrTypes: AppQosValue{}.AttributeTypes(ctx),
			},
			"apply_to":   basetypes.StringType{},
			"arp_filter": basetypes.BoolType{},
			"auth": basetypes.ObjectType{
				AttrTypes: AuthValue{}.AttributeTypes(ctx),
			},
			"auth_server_selection": basetypes.StringType{},
			"auth_servers": basetypes.ListType{
				ElemType: AuthServersValue{}.Type(ctx),
			},
			"auth_servers_nas_id":    basetypes.StringType{},
			"auth_servers_nas_ip":    basetypes.StringType{},
			"auth_servers_retries":   basetypes.Int64Type{},
			"auth_servers_timeout":   basetypes.Int64Type{},
			"band_steer":             basetypes.BoolType{},
			"band_steer_force_band5": basetypes.BoolType{},
			"bands": basetypes.ListType{
				ElemType: types.StringType,
			},
			"block_blacklist_clients": basetypes.BoolType{},
			"bonjour": basetypes.ObjectType{
				AttrTypes: BonjourValue{}.AttributeTypes(ctx),
			},
			"cisco_cwa": basetypes.ObjectType{
				AttrTypes: CiscoCwaValue{}.AttributeTypes(ctx),
			},
			"client_limit_down":         basetypes.Int64Type{},
			"client_limit_down_enabled": basetypes.BoolType{},
			"client_limit_up":           basetypes.Int64Type{},
			"client_limit_up_enabled":   basetypes.BoolType{},
			"coa_servers": basetypes.ListType{
				ElemType: CoaServersValue{}.Type(ctx),
			},
			"created_time":                     basetypes.Float64Type{},
			"disable_11ax":                     basetypes.BoolType{},
			"disable_ht_vht_rates":             basetypes.BoolType{},
			"disable_uapsd":                    basetypes.BoolType{},
			"disable_v1_roam_notify":           basetypes.BoolType{},
			"disable_v2_roam_notify":           basetypes.BoolType{},
			"disable_when_gateway_unreachable": basetypes.BoolType{},
			"disable_when_mxtunnel_down":       basetypes.BoolType{},
			"disable_wmm":                      basetypes.BoolType{},
			"dns_server_rewrite": basetypes.ObjectType{
				AttrTypes: DnsServerRewriteValue{}.AttributeTypes(ctx),
			},
			"dtim": basetypes.Int64Type{},
			"dynamic_psk": basetypes.ObjectType{
				AttrTypes: DynamicPskValue{}.AttributeTypes(ctx),
			},
			"dynamic_vlan": basetypes.ObjectType{
				AttrTypes: DynamicVlanValue{}.AttributeTypes(ctx),
			},
			"enable_local_keycaching":                basetypes.BoolType{},
			"enable_wireless_bridging":               basetypes.BoolType{},
			"enable_wireless_bridging_dhcp_tracking": basetypes.BoolType{},
			"enabled":                                basetypes.BoolType{},
			"fast_dot1x_timers":                      basetypes.BoolType{},
			"hide_ssid":                              basetypes.BoolType{},
			"hostname_ie":                            basetypes.BoolType{},
			"hotspot20": basetypes.ObjectType{
				AttrTypes: Hotspot20Value{}.AttributeTypes(ctx),
			},
			"id": basetypes.StringType{},
			"inject_dhcp_option_82": basetypes.ObjectType{
				AttrTypes: InjectDhcpOption82Value{}.AttributeTypes(ctx),
			},
			"interface":            basetypes.StringType{},
			"isolation":            basetypes.BoolType{},
			"l2_isolation":         basetypes.BoolType{},
			"legacy_overds":        basetypes.BoolType{},
			"limit_bcast":          basetypes.BoolType{},
			"limit_probe_response": basetypes.BoolType{},
			"max_idletime":         basetypes.Int64Type{},
			"max_num_clients":      basetypes.Int64Type{},
			"mist_nac": basetypes.ObjectType{
				AttrTypes: MistNacValue{}.AttributeTypes(ctx),
			},
			"modified_time": basetypes.Float64Type{},
			"msp_id":        basetypes.StringType{},
			"mxtunnel_ids": basetypes.ListType{
				ElemType: types.StringType,
			},
			"mxtunnel_name": basetypes.ListType{
				ElemType: types.StringType,
			},
			"no_static_dns": basetypes.BoolType{},
			"no_static_ip":  basetypes.BoolType{},
			"org_id":        basetypes.StringType{},
			"portal": basetypes.ObjectType{
				AttrTypes: PortalValue{}.AttributeTypes(ctx),
			},
			"portal_allowed_hostnames": basetypes.ListType{
				ElemType: types.StringType,
			},
			"portal_allowed_subnets": basetypes.ListType{
				ElemType: types.StringType,
			},
			"portal_api_secret": basetypes.StringType{},
			"portal_denied_hostnames": basetypes.ListType{
				ElemType: types.StringType,
			},
			"portal_image":   basetypes.StringType{},
			"portal_sso_url": basetypes.StringType{},
			"qos": basetypes.ObjectType{
				AttrTypes: QosValue{}.AttributeTypes(ctx),
			},
			"radsec": basetypes.ObjectType{
				AttrTypes: RadsecValue{}.AttributeTypes(ctx),
			},
			"rateset": basetypes.MapType{
				ElemType: RatesetValue{}.Type(ctx),
			},
			"reconnect_clients_when_roaming_mxcluster": basetypes.BoolType{},
			"roam_mode": basetypes.StringType{},
			"schedule": basetypes.ObjectType{
				AttrTypes: ScheduleValue{}.AttributeTypes(ctx),
			},
			"sle_excluded": basetypes.BoolType{},
			"ssid":         basetypes.StringType{},
			"template_id":  basetypes.StringType{},
			"use_eapol_v1": basetypes.BoolType{},
			"vlan_enabled": basetypes.BoolType{},
			"vlan_id":      basetypes.StringType{},
			"vlan_ids": basetypes.ListType{
				ElemType: types.StringType,
			},
			"vlan_pooling":            basetypes.BoolType{},
			"wlan_limit_down":         basetypes.Int64Type{},
			"wlan_limit_down_enabled": basetypes.BoolType{},
			"wlan_limit_up":           basetypes.Int64Type{},
			"wlan_limit_up_enabled":   basetypes.BoolType{},
			"wxtag_ids": basetypes.ListType{
				ElemType: types.StringType,
			},
			"wxtunnel_id":        basetypes.StringType{},
			"wxtunnel_remote_id": basetypes.StringType{},
		}), diags
	}

	mxtunnelNameVal, d := types.ListValue(types.StringType, v.MxtunnelName.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"acct_immediate_update": basetypes.BoolType{},
			"acct_interim_interval": basetypes.Int64Type{},
			"acct_servers": basetypes.ListType{
				ElemType: AcctServersValue{}.Type(ctx),
			},
			"airwatch": basetypes.ObjectType{
				AttrTypes: AirwatchValue{}.AttributeTypes(ctx),
			},
			"allow_ipv6_ndp": basetypes.BoolType{},
			"allow_mdns":     basetypes.BoolType{},
			"allow_ssdp":     basetypes.BoolType{},
			"ap_ids": basetypes.ListType{
				ElemType: types.StringType,
			},
			"app_limit": basetypes.ObjectType{
				AttrTypes: AppLimitValue{}.AttributeTypes(ctx),
			},
			"app_qos": basetypes.ObjectType{
				AttrTypes: AppQosValue{}.AttributeTypes(ctx),
			},
			"apply_to":   basetypes.StringType{},
			"arp_filter": basetypes.BoolType{},
			"auth": basetypes.ObjectType{
				AttrTypes: AuthValue{}.AttributeTypes(ctx),
			},
			"auth_server_selection": basetypes.StringType{},
			"auth_servers": basetypes.ListType{
				ElemType: AuthServersValue{}.Type(ctx),
			},
			"auth_servers_nas_id":    basetypes.StringType{},
			"auth_servers_nas_ip":    basetypes.StringType{},
			"auth_servers_retries":   basetypes.Int64Type{},
			"auth_servers_timeout":   basetypes.Int64Type{},
			"band_steer":             basetypes.BoolType{},
			"band_steer_force_band5": basetypes.BoolType{},
			"bands": basetypes.ListType{
				ElemType: types.StringType,
			},
			"block_blacklist_clients": basetypes.BoolType{},
			"bonjour": basetypes.ObjectType{
				AttrTypes: BonjourValue{}.AttributeTypes(ctx),
			},
			"cisco_cwa": basetypes.ObjectType{
				AttrTypes: CiscoCwaValue{}.AttributeTypes(ctx),
			},
			"client_limit_down":         basetypes.Int64Type{},
			"client_limit_down_enabled": basetypes.BoolType{},
			"client_limit_up":           basetypes.Int64Type{},
			"client_limit_up_enabled":   basetypes.BoolType{},
			"coa_servers": basetypes.ListType{
				ElemType: CoaServersValue{}.Type(ctx),
			},
			"created_time":                     basetypes.Float64Type{},
			"disable_11ax":                     basetypes.BoolType{},
			"disable_ht_vht_rates":             basetypes.BoolType{},
			"disable_uapsd":                    basetypes.BoolType{},
			"disable_v1_roam_notify":           basetypes.BoolType{},
			"disable_v2_roam_notify":           basetypes.BoolType{},
			"disable_when_gateway_unreachable": basetypes.BoolType{},
			"disable_when_mxtunnel_down":       basetypes.BoolType{},
			"disable_wmm":                      basetypes.BoolType{},
			"dns_server_rewrite": basetypes.ObjectType{
				AttrTypes: DnsServerRewriteValue{}.AttributeTypes(ctx),
			},
			"dtim": basetypes.Int64Type{},
			"dynamic_psk": basetypes.ObjectType{
				AttrTypes: DynamicPskValue{}.AttributeTypes(ctx),
			},
			"dynamic_vlan": basetypes.ObjectType{
				AttrTypes: DynamicVlanValue{}.AttributeTypes(ctx),
			},
			"enable_local_keycaching":                basetypes.BoolType{},
			"enable_wireless_bridging":               basetypes.BoolType{},
			"enable_wireless_bridging_dhcp_tracking": basetypes.BoolType{},
			"enabled":                                basetypes.BoolType{},
			"fast_dot1x_timers":                      basetypes.BoolType{},
			"hide_ssid":                              basetypes.BoolType{},
			"hostname_ie":                            basetypes.BoolType{},
			"hotspot20": basetypes.ObjectType{
				AttrTypes: Hotspot20Value{}.AttributeTypes(ctx),
			},
			"id": basetypes.StringType{},
			"inject_dhcp_option_82": basetypes.ObjectType{
				AttrTypes: InjectDhcpOption82Value{}.AttributeTypes(ctx),
			},
			"interface":            basetypes.StringType{},
			"isolation":            basetypes.BoolType{},
			"l2_isolation":         basetypes.BoolType{},
			"legacy_overds":        basetypes.BoolType{},
			"limit_bcast":          basetypes.BoolType{},
			"limit_probe_response": basetypes.BoolType{},
			"max_idletime":         basetypes.Int64Type{},
			"max_num_clients":      basetypes.Int64Type{},
			"mist_nac": basetypes.ObjectType{
				AttrTypes: MistNacValue{}.AttributeTypes(ctx),
			},
			"modified_time": basetypes.Float64Type{},
			"msp_id":        basetypes.StringType{},
			"mxtunnel_ids": basetypes.ListType{
				ElemType: types.StringType,
			},
			"mxtunnel_name": basetypes.ListType{
				ElemType: types.StringType,
			},
			"no_static_dns": basetypes.BoolType{},
			"no_static_ip":  basetypes.BoolType{},
			"org_id":        basetypes.StringType{},
			"portal": basetypes.ObjectType{
				AttrTypes: PortalValue{}.AttributeTypes(ctx),
			},
			"portal_allowed_hostnames": basetypes.ListType{
				ElemType: types.StringType,
			},
			"portal_allowed_subnets": basetypes.ListType{
				ElemType: types.StringType,
			},
			"portal_api_secret": basetypes.StringType{},
			"portal_denied_hostnames": basetypes.ListType{
				ElemType: types.StringType,
			},
			"portal_image":   basetypes.StringType{},
			"portal_sso_url": basetypes.StringType{},
			"qos": basetypes.ObjectType{
				AttrTypes: QosValue{}.AttributeTypes(ctx),
			},
			"radsec": basetypes.ObjectType{
				AttrTypes: RadsecValue{}.AttributeTypes(ctx),
			},
			"rateset": basetypes.MapType{
				ElemType: RatesetValue{}.Type(ctx),
			},
			"reconnect_clients_when_roaming_mxcluster": basetypes.BoolType{},
			"roam_mode": basetypes.StringType{},
			"schedule": basetypes.ObjectType{
				AttrTypes: ScheduleValue{}.AttributeTypes(ctx),
			},
			"sle_excluded": basetypes.BoolType{},
			"ssid":         basetypes.StringType{},
			"template_id":  basetypes.StringType{},
			"use_eapol_v1": basetypes.BoolType{},
			"vlan_enabled": basetypes.BoolType{},
			"vlan_id":      basetypes.StringType{},
			"vlan_ids": basetypes.ListType{
				ElemType: types.StringType,
			},
			"vlan_pooling":            basetypes.BoolType{},
			"wlan_limit_down":         basetypes.Int64Type{},
			"wlan_limit_down_enabled": basetypes.BoolType{},
			"wlan_limit_up":           basetypes.Int64Type{},
			"wlan_limit_up_enabled":   basetypes.BoolType{},
			"wxtag_ids": basetypes.ListType{
				ElemType: types.StringType,
			},
			"wxtunnel_id":        basetypes.StringType{},
			"wxtunnel_remote_id": basetypes.StringType{},
		}), diags
	}

	portalAllowedHostnamesVal, d := types.ListValue(types.StringType, v.PortalAllowedHostnames.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"acct_immediate_update": basetypes.BoolType{},
			"acct_interim_interval": basetypes.Int64Type{},
			"acct_servers": basetypes.ListType{
				ElemType: AcctServersValue{}.Type(ctx),
			},
			"airwatch": basetypes.ObjectType{
				AttrTypes: AirwatchValue{}.AttributeTypes(ctx),
			},
			"allow_ipv6_ndp": basetypes.BoolType{},
			"allow_mdns":     basetypes.BoolType{},
			"allow_ssdp":     basetypes.BoolType{},
			"ap_ids": basetypes.ListType{
				ElemType: types.StringType,
			},
			"app_limit": basetypes.ObjectType{
				AttrTypes: AppLimitValue{}.AttributeTypes(ctx),
			},
			"app_qos": basetypes.ObjectType{
				AttrTypes: AppQosValue{}.AttributeTypes(ctx),
			},
			"apply_to":   basetypes.StringType{},
			"arp_filter": basetypes.BoolType{},
			"auth": basetypes.ObjectType{
				AttrTypes: AuthValue{}.AttributeTypes(ctx),
			},
			"auth_server_selection": basetypes.StringType{},
			"auth_servers": basetypes.ListType{
				ElemType: AuthServersValue{}.Type(ctx),
			},
			"auth_servers_nas_id":    basetypes.StringType{},
			"auth_servers_nas_ip":    basetypes.StringType{},
			"auth_servers_retries":   basetypes.Int64Type{},
			"auth_servers_timeout":   basetypes.Int64Type{},
			"band_steer":             basetypes.BoolType{},
			"band_steer_force_band5": basetypes.BoolType{},
			"bands": basetypes.ListType{
				ElemType: types.StringType,
			},
			"block_blacklist_clients": basetypes.BoolType{},
			"bonjour": basetypes.ObjectType{
				AttrTypes: BonjourValue{}.AttributeTypes(ctx),
			},
			"cisco_cwa": basetypes.ObjectType{
				AttrTypes: CiscoCwaValue{}.AttributeTypes(ctx),
			},
			"client_limit_down":         basetypes.Int64Type{},
			"client_limit_down_enabled": basetypes.BoolType{},
			"client_limit_up":           basetypes.Int64Type{},
			"client_limit_up_enabled":   basetypes.BoolType{},
			"coa_servers": basetypes.ListType{
				ElemType: CoaServersValue{}.Type(ctx),
			},
			"created_time":                     basetypes.Float64Type{},
			"disable_11ax":                     basetypes.BoolType{},
			"disable_ht_vht_rates":             basetypes.BoolType{},
			"disable_uapsd":                    basetypes.BoolType{},
			"disable_v1_roam_notify":           basetypes.BoolType{},
			"disable_v2_roam_notify":           basetypes.BoolType{},
			"disable_when_gateway_unreachable": basetypes.BoolType{},
			"disable_when_mxtunnel_down":       basetypes.BoolType{},
			"disable_wmm":                      basetypes.BoolType{},
			"dns_server_rewrite": basetypes.ObjectType{
				AttrTypes: DnsServerRewriteValue{}.AttributeTypes(ctx),
			},
			"dtim": basetypes.Int64Type{},
			"dynamic_psk": basetypes.ObjectType{
				AttrTypes: DynamicPskValue{}.AttributeTypes(ctx),
			},
			"dynamic_vlan": basetypes.ObjectType{
				AttrTypes: DynamicVlanValue{}.AttributeTypes(ctx),
			},
			"enable_local_keycaching":                basetypes.BoolType{},
			"enable_wireless_bridging":               basetypes.BoolType{},
			"enable_wireless_bridging_dhcp_tracking": basetypes.BoolType{},
			"enabled":                                basetypes.BoolType{},
			"fast_dot1x_timers":                      basetypes.BoolType{},
			"hide_ssid":                              basetypes.BoolType{},
			"hostname_ie":                            basetypes.BoolType{},
			"hotspot20": basetypes.ObjectType{
				AttrTypes: Hotspot20Value{}.AttributeTypes(ctx),
			},
			"id": basetypes.StringType{},
			"inject_dhcp_option_82": basetypes.ObjectType{
				AttrTypes: InjectDhcpOption82Value{}.AttributeTypes(ctx),
			},
			"interface":            basetypes.StringType{},
			"isolation":            basetypes.BoolType{},
			"l2_isolation":         basetypes.BoolType{},
			"legacy_overds":        basetypes.BoolType{},
			"limit_bcast":          basetypes.BoolType{},
			"limit_probe_response": basetypes.BoolType{},
			"max_idletime":         basetypes.Int64Type{},
			"max_num_clients":      basetypes.Int64Type{},
			"mist_nac": basetypes.ObjectType{
				AttrTypes: MistNacValue{}.AttributeTypes(ctx),
			},
			"modified_time": basetypes.Float64Type{},
			"msp_id":        basetypes.StringType{},
			"mxtunnel_ids": basetypes.ListType{
				ElemType: types.StringType,
			},
			"mxtunnel_name": basetypes.ListType{
				ElemType: types.StringType,
			},
			"no_static_dns": basetypes.BoolType{},
			"no_static_ip":  basetypes.BoolType{},
			"org_id":        basetypes.StringType{},
			"portal": basetypes.ObjectType{
				AttrTypes: PortalValue{}.AttributeTypes(ctx),
			},
			"portal_allowed_hostnames": basetypes.ListType{
				ElemType: types.StringType,
			},
			"portal_allowed_subnets": basetypes.ListType{
				ElemType: types.StringType,
			},
			"portal_api_secret": basetypes.StringType{},
			"portal_denied_hostnames": basetypes.ListType{
				ElemType: types.StringType,
			},
			"portal_image":   basetypes.StringType{},
			"portal_sso_url": basetypes.StringType{},
			"qos": basetypes.ObjectType{
				AttrTypes: QosValue{}.AttributeTypes(ctx),
			},
			"radsec": basetypes.ObjectType{
				AttrTypes: RadsecValue{}.AttributeTypes(ctx),
			},
			"rateset": basetypes.MapType{
				ElemType: RatesetValue{}.Type(ctx),
			},
			"reconnect_clients_when_roaming_mxcluster": basetypes.BoolType{},
			"roam_mode": basetypes.StringType{},
			"schedule": basetypes.ObjectType{
				AttrTypes: ScheduleValue{}.AttributeTypes(ctx),
			},
			"sle_excluded": basetypes.BoolType{},
			"ssid":         basetypes.StringType{},
			"template_id":  basetypes.StringType{},
			"use_eapol_v1": basetypes.BoolType{},
			"vlan_enabled": basetypes.BoolType{},
			"vlan_id":      basetypes.StringType{},
			"vlan_ids": basetypes.ListType{
				ElemType: types.StringType,
			},
			"vlan_pooling":            basetypes.BoolType{},
			"wlan_limit_down":         basetypes.Int64Type{},
			"wlan_limit_down_enabled": basetypes.BoolType{},
			"wlan_limit_up":           basetypes.Int64Type{},
			"wlan_limit_up_enabled":   basetypes.BoolType{},
			"wxtag_ids": basetypes.ListType{
				ElemType: types.StringType,
			},
			"wxtunnel_id":        basetypes.StringType{},
			"wxtunnel_remote_id": basetypes.StringType{},
		}), diags
	}

	portalAllowedSubnetsVal, d := types.ListValue(types.StringType, v.PortalAllowedSubnets.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"acct_immediate_update": basetypes.BoolType{},
			"acct_interim_interval": basetypes.Int64Type{},
			"acct_servers": basetypes.ListType{
				ElemType: AcctServersValue{}.Type(ctx),
			},
			"airwatch": basetypes.ObjectType{
				AttrTypes: AirwatchValue{}.AttributeTypes(ctx),
			},
			"allow_ipv6_ndp": basetypes.BoolType{},
			"allow_mdns":     basetypes.BoolType{},
			"allow_ssdp":     basetypes.BoolType{},
			"ap_ids": basetypes.ListType{
				ElemType: types.StringType,
			},
			"app_limit": basetypes.ObjectType{
				AttrTypes: AppLimitValue{}.AttributeTypes(ctx),
			},
			"app_qos": basetypes.ObjectType{
				AttrTypes: AppQosValue{}.AttributeTypes(ctx),
			},
			"apply_to":   basetypes.StringType{},
			"arp_filter": basetypes.BoolType{},
			"auth": basetypes.ObjectType{
				AttrTypes: AuthValue{}.AttributeTypes(ctx),
			},
			"auth_server_selection": basetypes.StringType{},
			"auth_servers": basetypes.ListType{
				ElemType: AuthServersValue{}.Type(ctx),
			},
			"auth_servers_nas_id":    basetypes.StringType{},
			"auth_servers_nas_ip":    basetypes.StringType{},
			"auth_servers_retries":   basetypes.Int64Type{},
			"auth_servers_timeout":   basetypes.Int64Type{},
			"band_steer":             basetypes.BoolType{},
			"band_steer_force_band5": basetypes.BoolType{},
			"bands": basetypes.ListType{
				ElemType: types.StringType,
			},
			"block_blacklist_clients": basetypes.BoolType{},
			"bonjour": basetypes.ObjectType{
				AttrTypes: BonjourValue{}.AttributeTypes(ctx),
			},
			"cisco_cwa": basetypes.ObjectType{
				AttrTypes: CiscoCwaValue{}.AttributeTypes(ctx),
			},
			"client_limit_down":         basetypes.Int64Type{},
			"client_limit_down_enabled": basetypes.BoolType{},
			"client_limit_up":           basetypes.Int64Type{},
			"client_limit_up_enabled":   basetypes.BoolType{},
			"coa_servers": basetypes.ListType{
				ElemType: CoaServersValue{}.Type(ctx),
			},
			"created_time":                     basetypes.Float64Type{},
			"disable_11ax":                     basetypes.BoolType{},
			"disable_ht_vht_rates":             basetypes.BoolType{},
			"disable_uapsd":                    basetypes.BoolType{},
			"disable_v1_roam_notify":           basetypes.BoolType{},
			"disable_v2_roam_notify":           basetypes.BoolType{},
			"disable_when_gateway_unreachable": basetypes.BoolType{},
			"disable_when_mxtunnel_down":       basetypes.BoolType{},
			"disable_wmm":                      basetypes.BoolType{},
			"dns_server_rewrite": basetypes.ObjectType{
				AttrTypes: DnsServerRewriteValue{}.AttributeTypes(ctx),
			},
			"dtim": basetypes.Int64Type{},
			"dynamic_psk": basetypes.ObjectType{
				AttrTypes: DynamicPskValue{}.AttributeTypes(ctx),
			},
			"dynamic_vlan": basetypes.ObjectType{
				AttrTypes: DynamicVlanValue{}.AttributeTypes(ctx),
			},
			"enable_local_keycaching":                basetypes.BoolType{},
			"enable_wireless_bridging":               basetypes.BoolType{},
			"enable_wireless_bridging_dhcp_tracking": basetypes.BoolType{},
			"enabled":                                basetypes.BoolType{},
			"fast_dot1x_timers":                      basetypes.BoolType{},
			"hide_ssid":                              basetypes.BoolType{},
			"hostname_ie":                            basetypes.BoolType{},
			"hotspot20": basetypes.ObjectType{
				AttrTypes: Hotspot20Value{}.AttributeTypes(ctx),
			},
			"id": basetypes.StringType{},
			"inject_dhcp_option_82": basetypes.ObjectType{
				AttrTypes: InjectDhcpOption82Value{}.AttributeTypes(ctx),
			},
			"interface":            basetypes.StringType{},
			"isolation":            basetypes.BoolType{},
			"l2_isolation":         basetypes.BoolType{},
			"legacy_overds":        basetypes.BoolType{},
			"limit_bcast":          basetypes.BoolType{},
			"limit_probe_response": basetypes.BoolType{},
			"max_idletime":         basetypes.Int64Type{},
			"max_num_clients":      basetypes.Int64Type{},
			"mist_nac": basetypes.ObjectType{
				AttrTypes: MistNacValue{}.AttributeTypes(ctx),
			},
			"modified_time": basetypes.Float64Type{},
			"msp_id":        basetypes.StringType{},
			"mxtunnel_ids": basetypes.ListType{
				ElemType: types.StringType,
			},
			"mxtunnel_name": basetypes.ListType{
				ElemType: types.StringType,
			},
			"no_static_dns": basetypes.BoolType{},
			"no_static_ip":  basetypes.BoolType{},
			"org_id":        basetypes.StringType{},
			"portal": basetypes.ObjectType{
				AttrTypes: PortalValue{}.AttributeTypes(ctx),
			},
			"portal_allowed_hostnames": basetypes.ListType{
				ElemType: types.StringType,
			},
			"portal_allowed_subnets": basetypes.ListType{
				ElemType: types.StringType,
			},
			"portal_api_secret": basetypes.StringType{},
			"portal_denied_hostnames": basetypes.ListType{
				ElemType: types.StringType,
			},
			"portal_image":   basetypes.StringType{},
			"portal_sso_url": basetypes.StringType{},
			"qos": basetypes.ObjectType{
				AttrTypes: QosValue{}.AttributeTypes(ctx),
			},
			"radsec": basetypes.ObjectType{
				AttrTypes: RadsecValue{}.AttributeTypes(ctx),
			},
			"rateset": basetypes.MapType{
				ElemType: RatesetValue{}.Type(ctx),
			},
			"reconnect_clients_when_roaming_mxcluster": basetypes.BoolType{},
			"roam_mode": basetypes.StringType{},
			"schedule": basetypes.ObjectType{
				AttrTypes: ScheduleValue{}.AttributeTypes(ctx),
			},
			"sle_excluded": basetypes.BoolType{},
			"ssid":         basetypes.StringType{},
			"template_id":  basetypes.StringType{},
			"use_eapol_v1": basetypes.BoolType{},
			"vlan_enabled": basetypes.BoolType{},
			"vlan_id":      basetypes.StringType{},
			"vlan_ids": basetypes.ListType{
				ElemType: types.StringType,
			},
			"vlan_pooling":            basetypes.BoolType{},
			"wlan_limit_down":         basetypes.Int64Type{},
			"wlan_limit_down_enabled": basetypes.BoolType{},
			"wlan_limit_up":           basetypes.Int64Type{},
			"wlan_limit_up_enabled":   basetypes.BoolType{},
			"wxtag_ids": basetypes.ListType{
				ElemType: types.StringType,
			},
			"wxtunnel_id":        basetypes.StringType{},
			"wxtunnel_remote_id": basetypes.StringType{},
		}), diags
	}

	portalDeniedHostnamesVal, d := types.ListValue(types.StringType, v.PortalDeniedHostnames.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"acct_immediate_update": basetypes.BoolType{},
			"acct_interim_interval": basetypes.Int64Type{},
			"acct_servers": basetypes.ListType{
				ElemType: AcctServersValue{}.Type(ctx),
			},
			"airwatch": basetypes.ObjectType{
				AttrTypes: AirwatchValue{}.AttributeTypes(ctx),
			},
			"allow_ipv6_ndp": basetypes.BoolType{},
			"allow_mdns":     basetypes.BoolType{},
			"allow_ssdp":     basetypes.BoolType{},
			"ap_ids": basetypes.ListType{
				ElemType: types.StringType,
			},
			"app_limit": basetypes.ObjectType{
				AttrTypes: AppLimitValue{}.AttributeTypes(ctx),
			},
			"app_qos": basetypes.ObjectType{
				AttrTypes: AppQosValue{}.AttributeTypes(ctx),
			},
			"apply_to":   basetypes.StringType{},
			"arp_filter": basetypes.BoolType{},
			"auth": basetypes.ObjectType{
				AttrTypes: AuthValue{}.AttributeTypes(ctx),
			},
			"auth_server_selection": basetypes.StringType{},
			"auth_servers": basetypes.ListType{
				ElemType: AuthServersValue{}.Type(ctx),
			},
			"auth_servers_nas_id":    basetypes.StringType{},
			"auth_servers_nas_ip":    basetypes.StringType{},
			"auth_servers_retries":   basetypes.Int64Type{},
			"auth_servers_timeout":   basetypes.Int64Type{},
			"band_steer":             basetypes.BoolType{},
			"band_steer_force_band5": basetypes.BoolType{},
			"bands": basetypes.ListType{
				ElemType: types.StringType,
			},
			"block_blacklist_clients": basetypes.BoolType{},
			"bonjour": basetypes.ObjectType{
				AttrTypes: BonjourValue{}.AttributeTypes(ctx),
			},
			"cisco_cwa": basetypes.ObjectType{
				AttrTypes: CiscoCwaValue{}.AttributeTypes(ctx),
			},
			"client_limit_down":         basetypes.Int64Type{},
			"client_limit_down_enabled": basetypes.BoolType{},
			"client_limit_up":           basetypes.Int64Type{},
			"client_limit_up_enabled":   basetypes.BoolType{},
			"coa_servers": basetypes.ListType{
				ElemType: CoaServersValue{}.Type(ctx),
			},
			"created_time":                     basetypes.Float64Type{},
			"disable_11ax":                     basetypes.BoolType{},
			"disable_ht_vht_rates":             basetypes.BoolType{},
			"disable_uapsd":                    basetypes.BoolType{},
			"disable_v1_roam_notify":           basetypes.BoolType{},
			"disable_v2_roam_notify":           basetypes.BoolType{},
			"disable_when_gateway_unreachable": basetypes.BoolType{},
			"disable_when_mxtunnel_down":       basetypes.BoolType{},
			"disable_wmm":                      basetypes.BoolType{},
			"dns_server_rewrite": basetypes.ObjectType{
				AttrTypes: DnsServerRewriteValue{}.AttributeTypes(ctx),
			},
			"dtim": basetypes.Int64Type{},
			"dynamic_psk": basetypes.ObjectType{
				AttrTypes: DynamicPskValue{}.AttributeTypes(ctx),
			},
			"dynamic_vlan": basetypes.ObjectType{
				AttrTypes: DynamicVlanValue{}.AttributeTypes(ctx),
			},
			"enable_local_keycaching":                basetypes.BoolType{},
			"enable_wireless_bridging":               basetypes.BoolType{},
			"enable_wireless_bridging_dhcp_tracking": basetypes.BoolType{},
			"enabled":                                basetypes.BoolType{},
			"fast_dot1x_timers":                      basetypes.BoolType{},
			"hide_ssid":                              basetypes.BoolType{},
			"hostname_ie":                            basetypes.BoolType{},
			"hotspot20": basetypes.ObjectType{
				AttrTypes: Hotspot20Value{}.AttributeTypes(ctx),
			},
			"id": basetypes.StringType{},
			"inject_dhcp_option_82": basetypes.ObjectType{
				AttrTypes: InjectDhcpOption82Value{}.AttributeTypes(ctx),
			},
			"interface":            basetypes.StringType{},
			"isolation":            basetypes.BoolType{},
			"l2_isolation":         basetypes.BoolType{},
			"legacy_overds":        basetypes.BoolType{},
			"limit_bcast":          basetypes.BoolType{},
			"limit_probe_response": basetypes.BoolType{},
			"max_idletime":         basetypes.Int64Type{},
			"max_num_clients":      basetypes.Int64Type{},
			"mist_nac": basetypes.ObjectType{
				AttrTypes: MistNacValue{}.AttributeTypes(ctx),
			},
			"modified_time": basetypes.Float64Type{},
			"msp_id":        basetypes.StringType{},
			"mxtunnel_ids": basetypes.ListType{
				ElemType: types.StringType,
			},
			"mxtunnel_name": basetypes.ListType{
				ElemType: types.StringType,
			},
			"no_static_dns": basetypes.BoolType{},
			"no_static_ip":  basetypes.BoolType{},
			"org_id":        basetypes.StringType{},
			"portal": basetypes.ObjectType{
				AttrTypes: PortalValue{}.AttributeTypes(ctx),
			},
			"portal_allowed_hostnames": basetypes.ListType{
				ElemType: types.StringType,
			},
			"portal_allowed_subnets": basetypes.ListType{
				ElemType: types.StringType,
			},
			"portal_api_secret": basetypes.StringType{},
			"portal_denied_hostnames": basetypes.ListType{
				ElemType: types.StringType,
			},
			"portal_image":   basetypes.StringType{},
			"portal_sso_url": basetypes.StringType{},
			"qos": basetypes.ObjectType{
				AttrTypes: QosValue{}.AttributeTypes(ctx),
			},
			"radsec": basetypes.ObjectType{
				AttrTypes: RadsecValue{}.AttributeTypes(ctx),
			},
			"rateset": basetypes.MapType{
				ElemType: RatesetValue{}.Type(ctx),
			},
			"reconnect_clients_when_roaming_mxcluster": basetypes.BoolType{},
			"roam_mode": basetypes.StringType{},
			"schedule": basetypes.ObjectType{
				AttrTypes: ScheduleValue{}.AttributeTypes(ctx),
			},
			"sle_excluded": basetypes.BoolType{},
			"ssid":         basetypes.StringType{},
			"template_id":  basetypes.StringType{},
			"use_eapol_v1": basetypes.BoolType{},
			"vlan_enabled": basetypes.BoolType{},
			"vlan_id":      basetypes.StringType{},
			"vlan_ids": basetypes.ListType{
				ElemType: types.StringType,
			},
			"vlan_pooling":            basetypes.BoolType{},
			"wlan_limit_down":         basetypes.Int64Type{},
			"wlan_limit_down_enabled": basetypes.BoolType{},
			"wlan_limit_up":           basetypes.Int64Type{},
			"wlan_limit_up_enabled":   basetypes.BoolType{},
			"wxtag_ids": basetypes.ListType{
				ElemType: types.StringType,
			},
			"wxtunnel_id":        basetypes.StringType{},
			"wxtunnel_remote_id": basetypes.StringType{},
		}), diags
	}

	vlanIdsVal, d := types.ListValue(types.StringType, v.VlanIds.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"acct_immediate_update": basetypes.BoolType{},
			"acct_interim_interval": basetypes.Int64Type{},
			"acct_servers": basetypes.ListType{
				ElemType: AcctServersValue{}.Type(ctx),
			},
			"airwatch": basetypes.ObjectType{
				AttrTypes: AirwatchValue{}.AttributeTypes(ctx),
			},
			"allow_ipv6_ndp": basetypes.BoolType{},
			"allow_mdns":     basetypes.BoolType{},
			"allow_ssdp":     basetypes.BoolType{},
			"ap_ids": basetypes.ListType{
				ElemType: types.StringType,
			},
			"app_limit": basetypes.ObjectType{
				AttrTypes: AppLimitValue{}.AttributeTypes(ctx),
			},
			"app_qos": basetypes.ObjectType{
				AttrTypes: AppQosValue{}.AttributeTypes(ctx),
			},
			"apply_to":   basetypes.StringType{},
			"arp_filter": basetypes.BoolType{},
			"auth": basetypes.ObjectType{
				AttrTypes: AuthValue{}.AttributeTypes(ctx),
			},
			"auth_server_selection": basetypes.StringType{},
			"auth_servers": basetypes.ListType{
				ElemType: AuthServersValue{}.Type(ctx),
			},
			"auth_servers_nas_id":    basetypes.StringType{},
			"auth_servers_nas_ip":    basetypes.StringType{},
			"auth_servers_retries":   basetypes.Int64Type{},
			"auth_servers_timeout":   basetypes.Int64Type{},
			"band_steer":             basetypes.BoolType{},
			"band_steer_force_band5": basetypes.BoolType{},
			"bands": basetypes.ListType{
				ElemType: types.StringType,
			},
			"block_blacklist_clients": basetypes.BoolType{},
			"bonjour": basetypes.ObjectType{
				AttrTypes: BonjourValue{}.AttributeTypes(ctx),
			},
			"cisco_cwa": basetypes.ObjectType{
				AttrTypes: CiscoCwaValue{}.AttributeTypes(ctx),
			},
			"client_limit_down":         basetypes.Int64Type{},
			"client_limit_down_enabled": basetypes.BoolType{},
			"client_limit_up":           basetypes.Int64Type{},
			"client_limit_up_enabled":   basetypes.BoolType{},
			"coa_servers": basetypes.ListType{
				ElemType: CoaServersValue{}.Type(ctx),
			},
			"created_time":                     basetypes.Float64Type{},
			"disable_11ax":                     basetypes.BoolType{},
			"disable_ht_vht_rates":             basetypes.BoolType{},
			"disable_uapsd":                    basetypes.BoolType{},
			"disable_v1_roam_notify":           basetypes.BoolType{},
			"disable_v2_roam_notify":           basetypes.BoolType{},
			"disable_when_gateway_unreachable": basetypes.BoolType{},
			"disable_when_mxtunnel_down":       basetypes.BoolType{},
			"disable_wmm":                      basetypes.BoolType{},
			"dns_server_rewrite": basetypes.ObjectType{
				AttrTypes: DnsServerRewriteValue{}.AttributeTypes(ctx),
			},
			"dtim": basetypes.Int64Type{},
			"dynamic_psk": basetypes.ObjectType{
				AttrTypes: DynamicPskValue{}.AttributeTypes(ctx),
			},
			"dynamic_vlan": basetypes.ObjectType{
				AttrTypes: DynamicVlanValue{}.AttributeTypes(ctx),
			},
			"enable_local_keycaching":                basetypes.BoolType{},
			"enable_wireless_bridging":               basetypes.BoolType{},
			"enable_wireless_bridging_dhcp_tracking": basetypes.BoolType{},
			"enabled":                                basetypes.BoolType{},
			"fast_dot1x_timers":                      basetypes.BoolType{},
			"hide_ssid":                              basetypes.BoolType{},
			"hostname_ie":                            basetypes.BoolType{},
			"hotspot20": basetypes.ObjectType{
				AttrTypes: Hotspot20Value{}.AttributeTypes(ctx),
			},
			"id": basetypes.StringType{},
			"inject_dhcp_option_82": basetypes.ObjectType{
				AttrTypes: InjectDhcpOption82Value{}.AttributeTypes(ctx),
			},
			"interface":            basetypes.StringType{},
			"isolation":            basetypes.BoolType{},
			"l2_isolation":         basetypes.BoolType{},
			"legacy_overds":        basetypes.BoolType{},
			"limit_bcast":          basetypes.BoolType{},
			"limit_probe_response": basetypes.BoolType{},
			"max_idletime":         basetypes.Int64Type{},
			"max_num_clients":      basetypes.Int64Type{},
			"mist_nac": basetypes.ObjectType{
				AttrTypes: MistNacValue{}.AttributeTypes(ctx),
			},
			"modified_time": basetypes.Float64Type{},
			"msp_id":        basetypes.StringType{},
			"mxtunnel_ids": basetypes.ListType{
				ElemType: types.StringType,
			},
			"mxtunnel_name": basetypes.ListType{
				ElemType: types.StringType,
			},
			"no_static_dns": basetypes.BoolType{},
			"no_static_ip":  basetypes.BoolType{},
			"org_id":        basetypes.StringType{},
			"portal": basetypes.ObjectType{
				AttrTypes: PortalValue{}.AttributeTypes(ctx),
			},
			"portal_allowed_hostnames": basetypes.ListType{
				ElemType: types.StringType,
			},
			"portal_allowed_subnets": basetypes.ListType{
				ElemType: types.StringType,
			},
			"portal_api_secret": basetypes.StringType{},
			"portal_denied_hostnames": basetypes.ListType{
				ElemType: types.StringType,
			},
			"portal_image":   basetypes.StringType{},
			"portal_sso_url": basetypes.StringType{},
			"qos": basetypes.ObjectType{
				AttrTypes: QosValue{}.AttributeTypes(ctx),
			},
			"radsec": basetypes.ObjectType{
				AttrTypes: RadsecValue{}.AttributeTypes(ctx),
			},
			"rateset": basetypes.MapType{
				ElemType: RatesetValue{}.Type(ctx),
			},
			"reconnect_clients_when_roaming_mxcluster": basetypes.BoolType{},
			"roam_mode": basetypes.StringType{},
			"schedule": basetypes.ObjectType{
				AttrTypes: ScheduleValue{}.AttributeTypes(ctx),
			},
			"sle_excluded": basetypes.BoolType{},
			"ssid":         basetypes.StringType{},
			"template_id":  basetypes.StringType{},
			"use_eapol_v1": basetypes.BoolType{},
			"vlan_enabled": basetypes.BoolType{},
			"vlan_id":      basetypes.StringType{},
			"vlan_ids": basetypes.ListType{
				ElemType: types.StringType,
			},
			"vlan_pooling":            basetypes.BoolType{},
			"wlan_limit_down":         basetypes.Int64Type{},
			"wlan_limit_down_enabled": basetypes.BoolType{},
			"wlan_limit_up":           basetypes.Int64Type{},
			"wlan_limit_up_enabled":   basetypes.BoolType{},
			"wxtag_ids": basetypes.ListType{
				ElemType: types.StringType,
			},
			"wxtunnel_id":        basetypes.StringType{},
			"wxtunnel_remote_id": basetypes.StringType{},
		}), diags
	}

	wxtagIdsVal, d := types.ListValue(types.StringType, v.WxtagIds.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"acct_immediate_update": basetypes.BoolType{},
			"acct_interim_interval": basetypes.Int64Type{},
			"acct_servers": basetypes.ListType{
				ElemType: AcctServersValue{}.Type(ctx),
			},
			"airwatch": basetypes.ObjectType{
				AttrTypes: AirwatchValue{}.AttributeTypes(ctx),
			},
			"allow_ipv6_ndp": basetypes.BoolType{},
			"allow_mdns":     basetypes.BoolType{},
			"allow_ssdp":     basetypes.BoolType{},
			"ap_ids": basetypes.ListType{
				ElemType: types.StringType,
			},
			"app_limit": basetypes.ObjectType{
				AttrTypes: AppLimitValue{}.AttributeTypes(ctx),
			},
			"app_qos": basetypes.ObjectType{
				AttrTypes: AppQosValue{}.AttributeTypes(ctx),
			},
			"apply_to":   basetypes.StringType{},
			"arp_filter": basetypes.BoolType{},
			"auth": basetypes.ObjectType{
				AttrTypes: AuthValue{}.AttributeTypes(ctx),
			},
			"auth_server_selection": basetypes.StringType{},
			"auth_servers": basetypes.ListType{
				ElemType: AuthServersValue{}.Type(ctx),
			},
			"auth_servers_nas_id":    basetypes.StringType{},
			"auth_servers_nas_ip":    basetypes.StringType{},
			"auth_servers_retries":   basetypes.Int64Type{},
			"auth_servers_timeout":   basetypes.Int64Type{},
			"band_steer":             basetypes.BoolType{},
			"band_steer_force_band5": basetypes.BoolType{},
			"bands": basetypes.ListType{
				ElemType: types.StringType,
			},
			"block_blacklist_clients": basetypes.BoolType{},
			"bonjour": basetypes.ObjectType{
				AttrTypes: BonjourValue{}.AttributeTypes(ctx),
			},
			"cisco_cwa": basetypes.ObjectType{
				AttrTypes: CiscoCwaValue{}.AttributeTypes(ctx),
			},
			"client_limit_down":         basetypes.Int64Type{},
			"client_limit_down_enabled": basetypes.BoolType{},
			"client_limit_up":           basetypes.Int64Type{},
			"client_limit_up_enabled":   basetypes.BoolType{},
			"coa_servers": basetypes.ListType{
				ElemType: CoaServersValue{}.Type(ctx),
			},
			"created_time":                     basetypes.Float64Type{},
			"disable_11ax":                     basetypes.BoolType{},
			"disable_ht_vht_rates":             basetypes.BoolType{},
			"disable_uapsd":                    basetypes.BoolType{},
			"disable_v1_roam_notify":           basetypes.BoolType{},
			"disable_v2_roam_notify":           basetypes.BoolType{},
			"disable_when_gateway_unreachable": basetypes.BoolType{},
			"disable_when_mxtunnel_down":       basetypes.BoolType{},
			"disable_wmm":                      basetypes.BoolType{},
			"dns_server_rewrite": basetypes.ObjectType{
				AttrTypes: DnsServerRewriteValue{}.AttributeTypes(ctx),
			},
			"dtim": basetypes.Int64Type{},
			"dynamic_psk": basetypes.ObjectType{
				AttrTypes: DynamicPskValue{}.AttributeTypes(ctx),
			},
			"dynamic_vlan": basetypes.ObjectType{
				AttrTypes: DynamicVlanValue{}.AttributeTypes(ctx),
			},
			"enable_local_keycaching":                basetypes.BoolType{},
			"enable_wireless_bridging":               basetypes.BoolType{},
			"enable_wireless_bridging_dhcp_tracking": basetypes.BoolType{},
			"enabled":                                basetypes.BoolType{},
			"fast_dot1x_timers":                      basetypes.BoolType{},
			"hide_ssid":                              basetypes.BoolType{},
			"hostname_ie":                            basetypes.BoolType{},
			"hotspot20": basetypes.ObjectType{
				AttrTypes: Hotspot20Value{}.AttributeTypes(ctx),
			},
			"id": basetypes.StringType{},
			"inject_dhcp_option_82": basetypes.ObjectType{
				AttrTypes: InjectDhcpOption82Value{}.AttributeTypes(ctx),
			},
			"interface":            basetypes.StringType{},
			"isolation":            basetypes.BoolType{},
			"l2_isolation":         basetypes.BoolType{},
			"legacy_overds":        basetypes.BoolType{},
			"limit_bcast":          basetypes.BoolType{},
			"limit_probe_response": basetypes.BoolType{},
			"max_idletime":         basetypes.Int64Type{},
			"max_num_clients":      basetypes.Int64Type{},
			"mist_nac": basetypes.ObjectType{
				AttrTypes: MistNacValue{}.AttributeTypes(ctx),
			},
			"modified_time": basetypes.Float64Type{},
			"msp_id":        basetypes.StringType{},
			"mxtunnel_ids": basetypes.ListType{
				ElemType: types.StringType,
			},
			"mxtunnel_name": basetypes.ListType{
				ElemType: types.StringType,
			},
			"no_static_dns": basetypes.BoolType{},
			"no_static_ip":  basetypes.BoolType{},
			"org_id":        basetypes.StringType{},
			"portal": basetypes.ObjectType{
				AttrTypes: PortalValue{}.AttributeTypes(ctx),
			},
			"portal_allowed_hostnames": basetypes.ListType{
				ElemType: types.StringType,
			},
			"portal_allowed_subnets": basetypes.ListType{
				ElemType: types.StringType,
			},
			"portal_api_secret": basetypes.StringType{},
			"portal_denied_hostnames": basetypes.ListType{
				ElemType: types.StringType,
			},
			"portal_image":   basetypes.StringType{},
			"portal_sso_url": basetypes.StringType{},
			"qos": basetypes.ObjectType{
				AttrTypes: QosValue{}.AttributeTypes(ctx),
			},
			"radsec": basetypes.ObjectType{
				AttrTypes: RadsecValue{}.AttributeTypes(ctx),
			},
			"rateset": basetypes.MapType{
				ElemType: RatesetValue{}.Type(ctx),
			},
			"reconnect_clients_when_roaming_mxcluster": basetypes.BoolType{},
			"roam_mode": basetypes.StringType{},
			"schedule": basetypes.ObjectType{
				AttrTypes: ScheduleValue{}.AttributeTypes(ctx),
			},
			"sle_excluded": basetypes.BoolType{},
			"ssid":         basetypes.StringType{},
			"template_id":  basetypes.StringType{},
			"use_eapol_v1": basetypes.BoolType{},
			"vlan_enabled": basetypes.BoolType{},
			"vlan_id":      basetypes.StringType{},
			"vlan_ids": basetypes.ListType{
				ElemType: types.StringType,
			},
			"vlan_pooling":            basetypes.BoolType{},
			"wlan_limit_down":         basetypes.Int64Type{},
			"wlan_limit_down_enabled": basetypes.BoolType{},
			"wlan_limit_up":           basetypes.Int64Type{},
			"wlan_limit_up_enabled":   basetypes.BoolType{},
			"wxtag_ids": basetypes.ListType{
				ElemType: types.StringType,
			},
			"wxtunnel_id":        basetypes.StringType{},
			"wxtunnel_remote_id": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"acct_immediate_update": basetypes.BoolType{},
		"acct_interim_interval": basetypes.Int64Type{},
		"acct_servers": basetypes.ListType{
			ElemType: AcctServersValue{}.Type(ctx),
		},
		"airwatch": basetypes.ObjectType{
			AttrTypes: AirwatchValue{}.AttributeTypes(ctx),
		},
		"allow_ipv6_ndp": basetypes.BoolType{},
		"allow_mdns":     basetypes.BoolType{},
		"allow_ssdp":     basetypes.BoolType{},
		"ap_ids": basetypes.ListType{
			ElemType: types.StringType,
		},
		"app_limit": basetypes.ObjectType{
			AttrTypes: AppLimitValue{}.AttributeTypes(ctx),
		},
		"app_qos": basetypes.ObjectType{
			AttrTypes: AppQosValue{}.AttributeTypes(ctx),
		},
		"apply_to":   basetypes.StringType{},
		"arp_filter": basetypes.BoolType{},
		"auth": basetypes.ObjectType{
			AttrTypes: AuthValue{}.AttributeTypes(ctx),
		},
		"auth_server_selection": basetypes.StringType{},
		"auth_servers": basetypes.ListType{
			ElemType: AuthServersValue{}.Type(ctx),
		},
		"auth_servers_nas_id":    basetypes.StringType{},
		"auth_servers_nas_ip":    basetypes.StringType{},
		"auth_servers_retries":   basetypes.Int64Type{},
		"auth_servers_timeout":   basetypes.Int64Type{},
		"band_steer":             basetypes.BoolType{},
		"band_steer_force_band5": basetypes.BoolType{},
		"bands": basetypes.ListType{
			ElemType: types.StringType,
		},
		"block_blacklist_clients": basetypes.BoolType{},
		"bonjour": basetypes.ObjectType{
			AttrTypes: BonjourValue{}.AttributeTypes(ctx),
		},
		"cisco_cwa": basetypes.ObjectType{
			AttrTypes: CiscoCwaValue{}.AttributeTypes(ctx),
		},
		"client_limit_down":         basetypes.Int64Type{},
		"client_limit_down_enabled": basetypes.BoolType{},
		"client_limit_up":           basetypes.Int64Type{},
		"client_limit_up_enabled":   basetypes.BoolType{},
		"coa_servers": basetypes.ListType{
			ElemType: CoaServersValue{}.Type(ctx),
		},
		"created_time":                     basetypes.Float64Type{},
		"disable_11ax":                     basetypes.BoolType{},
		"disable_ht_vht_rates":             basetypes.BoolType{},
		"disable_uapsd":                    basetypes.BoolType{},
		"disable_v1_roam_notify":           basetypes.BoolType{},
		"disable_v2_roam_notify":           basetypes.BoolType{},
		"disable_when_gateway_unreachable": basetypes.BoolType{},
		"disable_when_mxtunnel_down":       basetypes.BoolType{},
		"disable_wmm":                      basetypes.BoolType{},
		"dns_server_rewrite": basetypes.ObjectType{
			AttrTypes: DnsServerRewriteValue{}.AttributeTypes(ctx),
		},
		"dtim": basetypes.Int64Type{},
		"dynamic_psk": basetypes.ObjectType{
			AttrTypes: DynamicPskValue{}.AttributeTypes(ctx),
		},
		"dynamic_vlan": basetypes.ObjectType{
			AttrTypes: DynamicVlanValue{}.AttributeTypes(ctx),
		},
		"enable_local_keycaching":                basetypes.BoolType{},
		"enable_wireless_bridging":               basetypes.BoolType{},
		"enable_wireless_bridging_dhcp_tracking": basetypes.BoolType{},
		"enabled":                                basetypes.BoolType{},
		"fast_dot1x_timers":                      basetypes.BoolType{},
		"hide_ssid":                              basetypes.BoolType{},
		"hostname_ie":                            basetypes.BoolType{},
		"hotspot20": basetypes.ObjectType{
			AttrTypes: Hotspot20Value{}.AttributeTypes(ctx),
		},
		"id": basetypes.StringType{},
		"inject_dhcp_option_82": basetypes.ObjectType{
			AttrTypes: InjectDhcpOption82Value{}.AttributeTypes(ctx),
		},
		"interface":            basetypes.StringType{},
		"isolation":            basetypes.BoolType{},
		"l2_isolation":         basetypes.BoolType{},
		"legacy_overds":        basetypes.BoolType{},
		"limit_bcast":          basetypes.BoolType{},
		"limit_probe_response": basetypes.BoolType{},
		"max_idletime":         basetypes.Int64Type{},
		"max_num_clients":      basetypes.Int64Type{},
		"mist_nac": basetypes.ObjectType{
			AttrTypes: MistNacValue{}.AttributeTypes(ctx),
		},
		"modified_time": basetypes.Float64Type{},
		"msp_id":        basetypes.StringType{},
		"mxtunnel_ids": basetypes.ListType{
			ElemType: types.StringType,
		},
		"mxtunnel_name": basetypes.ListType{
			ElemType: types.StringType,
		},
		"no_static_dns": basetypes.BoolType{},
		"no_static_ip":  basetypes.BoolType{},
		"org_id":        basetypes.StringType{},
		"portal": basetypes.ObjectType{
			AttrTypes: PortalValue{}.AttributeTypes(ctx),
		},
		"portal_allowed_hostnames": basetypes.ListType{
			ElemType: types.StringType,
		},
		"portal_allowed_subnets": basetypes.ListType{
			ElemType: types.StringType,
		},
		"portal_api_secret": basetypes.StringType{},
		"portal_denied_hostnames": basetypes.ListType{
			ElemType: types.StringType,
		},
		"portal_image":   basetypes.StringType{},
		"portal_sso_url": basetypes.StringType{},
		"qos": basetypes.ObjectType{
			AttrTypes: QosValue{}.AttributeTypes(ctx),
		},
		"radsec": basetypes.ObjectType{
			AttrTypes: RadsecValue{}.AttributeTypes(ctx),
		},
		"rateset": basetypes.MapType{
			ElemType: RatesetValue{}.Type(ctx),
		},
		"reconnect_clients_when_roaming_mxcluster": basetypes.BoolType{},
		"roam_mode": basetypes.StringType{},
		"schedule": basetypes.ObjectType{
			AttrTypes: ScheduleValue{}.AttributeTypes(ctx),
		},
		"sle_excluded": basetypes.BoolType{},
		"ssid":         basetypes.StringType{},
		"template_id":  basetypes.StringType{},
		"use_eapol_v1": basetypes.BoolType{},
		"vlan_enabled": basetypes.BoolType{},
		"vlan_id":      basetypes.StringType{},
		"vlan_ids": basetypes.ListType{
			ElemType: types.StringType,
		},
		"vlan_pooling":            basetypes.BoolType{},
		"wlan_limit_down":         basetypes.Int64Type{},
		"wlan_limit_down_enabled": basetypes.BoolType{},
		"wlan_limit_up":           basetypes.Int64Type{},
		"wlan_limit_up_enabled":   basetypes.BoolType{},
		"wxtag_ids": basetypes.ListType{
			ElemType: types.StringType,
		},
		"wxtunnel_id":        basetypes.StringType{},
		"wxtunnel_remote_id": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"acct_immediate_update":                  v.AcctImmediateUpdate,
			"acct_interim_interval":                  v.AcctInterimInterval,
			"acct_servers":                           acctServers,
			"airwatch":                               airwatch,
			"allow_ipv6_ndp":                         v.AllowIpv6Ndp,
			"allow_mdns":                             v.AllowMdns,
			"allow_ssdp":                             v.AllowSsdp,
			"ap_ids":                                 apIdsVal,
			"app_limit":                              appLimit,
			"app_qos":                                appQos,
			"apply_to":                               v.ApplyTo,
			"arp_filter":                             v.ArpFilter,
			"auth":                                   auth,
			"auth_server_selection":                  v.AuthServerSelection,
			"auth_servers":                           authServers,
			"auth_servers_nas_id":                    v.AuthServersNasId,
			"auth_servers_nas_ip":                    v.AuthServersNasIp,
			"auth_servers_retries":                   v.AuthServersRetries,
			"auth_servers_timeout":                   v.AuthServersTimeout,
			"band_steer":                             v.BandSteer,
			"band_steer_force_band5":                 v.BandSteerForceBand5,
			"bands":                                  bandsVal,
			"block_blacklist_clients":                v.BlockBlacklistClients,
			"bonjour":                                bonjour,
			"cisco_cwa":                              ciscoCwa,
			"client_limit_down":                      v.ClientLimitDown,
			"client_limit_down_enabled":              v.ClientLimitDownEnabled,
			"client_limit_up":                        v.ClientLimitUp,
			"client_limit_up_enabled":                v.ClientLimitUpEnabled,
			"coa_servers":                            coaServers,
			"created_time":                           v.CreatedTime,
			"disable_11ax":                           v.Disable11ax,
			"disable_ht_vht_rates":                   v.DisableHtVhtRates,
			"disable_uapsd":                          v.DisableUapsd,
			"disable_v1_roam_notify":                 v.DisableV1RoamNotify,
			"disable_v2_roam_notify":                 v.DisableV2RoamNotify,
			"disable_when_gateway_unreachable":       v.DisableWhenGatewayUnreachable,
			"disable_when_mxtunnel_down":             v.DisableWhenMxtunnelDown,
			"disable_wmm":                            v.DisableWmm,
			"dns_server_rewrite":                     dnsServerRewrite,
			"dtim":                                   v.Dtim,
			"dynamic_psk":                            dynamicPsk,
			"dynamic_vlan":                           dynamicVlan,
			"enable_local_keycaching":                v.EnableLocalKeycaching,
			"enable_wireless_bridging":               v.EnableWirelessBridging,
			"enable_wireless_bridging_dhcp_tracking": v.EnableWirelessBridgingDhcpTracking,
			"enabled":                                v.Enabled,
			"fast_dot1x_timers":                      v.FastDot1xTimers,
			"hide_ssid":                              v.HideSsid,
			"hostname_ie":                            v.HostnameIe,
			"hotspot20":                              hotspot20,
			"id":                                     v.Id,
			"inject_dhcp_option_82":                  injectDhcpOption82,
			"interface":                              v.Interface,
			"isolation":                              v.Isolation,
			"l2_isolation":                           v.L2Isolation,
			"legacy_overds":                          v.LegacyOverds,
			"limit_bcast":                            v.LimitBcast,
			"limit_probe_response":                   v.LimitProbeResponse,
			"max_idletime":                           v.MaxIdletime,
			"max_num_clients":                        v.MaxNumClients,
			"mist_nac":                               mistNac,
			"modified_time":                          v.ModifiedTime,
			"msp_id":                                 v.MspId,
			"mxtunnel_ids":                           mxtunnelIdsVal,
			"mxtunnel_name":                          mxtunnelNameVal,
			"no_static_dns":                          v.NoStaticDns,
			"no_static_ip":                           v.NoStaticIp,
			"org_id":                                 v.OrgId,
			"portal":                                 portal,
			"portal_allowed_hostnames":               portalAllowedHostnamesVal,
			"portal_allowed_subnets":                 portalAllowedSubnetsVal,
			"portal_api_secret":                      v.PortalApiSecret,
			"portal_denied_hostnames":                portalDeniedHostnamesVal,
			"portal_image":                           v.PortalImage,
			"portal_sso_url":                         v.PortalSsoUrl,
			"qos":                                    qos,
			"radsec":                                 radsec,
			"rateset":                                rateset,
			"reconnect_clients_when_roaming_mxcluster": v.ReconnectClientsWhenRoamingMxcluster,
			"roam_mode":               v.RoamMode,
			"schedule":                schedule,
			"sle_excluded":            v.SleExcluded,
			"ssid":                    v.Ssid,
			"template_id":             v.TemplateId,
			"use_eapol_v1":            v.UseEapolV1,
			"vlan_enabled":            v.VlanEnabled,
			"vlan_id":                 v.VlanId,
			"vlan_ids":                vlanIdsVal,
			"vlan_pooling":            v.VlanPooling,
			"wlan_limit_down":         v.WlanLimitDown,
			"wlan_limit_down_enabled": v.WlanLimitDownEnabled,
			"wlan_limit_up":           v.WlanLimitUp,
			"wlan_limit_up_enabled":   v.WlanLimitUpEnabled,
			"wxtag_ids":               wxtagIdsVal,
			"wxtunnel_id":             v.WxtunnelId,
			"wxtunnel_remote_id":      v.WxtunnelRemoteId,
		})

	return objVal, diags
}

func (v OrgWlansValue) Equal(o attr.Value) bool {
	other, ok := o.(OrgWlansValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AcctImmediateUpdate.Equal(other.AcctImmediateUpdate) {
		return false
	}

	if !v.AcctInterimInterval.Equal(other.AcctInterimInterval) {
		return false
	}

	if !v.AcctServers.Equal(other.AcctServers) {
		return false
	}

	if !v.Airwatch.Equal(other.Airwatch) {
		return false
	}

	if !v.AllowIpv6Ndp.Equal(other.AllowIpv6Ndp) {
		return false
	}

	if !v.AllowMdns.Equal(other.AllowMdns) {
		return false
	}

	if !v.AllowSsdp.Equal(other.AllowSsdp) {
		return false
	}

	if !v.ApIds.Equal(other.ApIds) {
		return false
	}

	if !v.AppLimit.Equal(other.AppLimit) {
		return false
	}

	if !v.AppQos.Equal(other.AppQos) {
		return false
	}

	if !v.ApplyTo.Equal(other.ApplyTo) {
		return false
	}

	if !v.ArpFilter.Equal(other.ArpFilter) {
		return false
	}

	if !v.Auth.Equal(other.Auth) {
		return false
	}

	if !v.AuthServerSelection.Equal(other.AuthServerSelection) {
		return false
	}

	if !v.AuthServers.Equal(other.AuthServers) {
		return false
	}

	if !v.AuthServersNasId.Equal(other.AuthServersNasId) {
		return false
	}

	if !v.AuthServersNasIp.Equal(other.AuthServersNasIp) {
		return false
	}

	if !v.AuthServersRetries.Equal(other.AuthServersRetries) {
		return false
	}

	if !v.AuthServersTimeout.Equal(other.AuthServersTimeout) {
		return false
	}

	if !v.BandSteer.Equal(other.BandSteer) {
		return false
	}

	if !v.BandSteerForceBand5.Equal(other.BandSteerForceBand5) {
		return false
	}

	if !v.Bands.Equal(other.Bands) {
		return false
	}

	if !v.BlockBlacklistClients.Equal(other.BlockBlacklistClients) {
		return false
	}

	if !v.Bonjour.Equal(other.Bonjour) {
		return false
	}

	if !v.CiscoCwa.Equal(other.CiscoCwa) {
		return false
	}

	if !v.ClientLimitDown.Equal(other.ClientLimitDown) {
		return false
	}

	if !v.ClientLimitDownEnabled.Equal(other.ClientLimitDownEnabled) {
		return false
	}

	if !v.ClientLimitUp.Equal(other.ClientLimitUp) {
		return false
	}

	if !v.ClientLimitUpEnabled.Equal(other.ClientLimitUpEnabled) {
		return false
	}

	if !v.CoaServers.Equal(other.CoaServers) {
		return false
	}

	if !v.CreatedTime.Equal(other.CreatedTime) {
		return false
	}

	if !v.Disable11ax.Equal(other.Disable11ax) {
		return false
	}

	if !v.DisableHtVhtRates.Equal(other.DisableHtVhtRates) {
		return false
	}

	if !v.DisableUapsd.Equal(other.DisableUapsd) {
		return false
	}

	if !v.DisableV1RoamNotify.Equal(other.DisableV1RoamNotify) {
		return false
	}

	if !v.DisableV2RoamNotify.Equal(other.DisableV2RoamNotify) {
		return false
	}

	if !v.DisableWhenGatewayUnreachable.Equal(other.DisableWhenGatewayUnreachable) {
		return false
	}

	if !v.DisableWhenMxtunnelDown.Equal(other.DisableWhenMxtunnelDown) {
		return false
	}

	if !v.DisableWmm.Equal(other.DisableWmm) {
		return false
	}

	if !v.DnsServerRewrite.Equal(other.DnsServerRewrite) {
		return false
	}

	if !v.Dtim.Equal(other.Dtim) {
		return false
	}

	if !v.DynamicPsk.Equal(other.DynamicPsk) {
		return false
	}

	if !v.DynamicVlan.Equal(other.DynamicVlan) {
		return false
	}

	if !v.EnableLocalKeycaching.Equal(other.EnableLocalKeycaching) {
		return false
	}

	if !v.EnableWirelessBridging.Equal(other.EnableWirelessBridging) {
		return false
	}

	if !v.EnableWirelessBridgingDhcpTracking.Equal(other.EnableWirelessBridgingDhcpTracking) {
		return false
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.FastDot1xTimers.Equal(other.FastDot1xTimers) {
		return false
	}

	if !v.HideSsid.Equal(other.HideSsid) {
		return false
	}

	if !v.HostnameIe.Equal(other.HostnameIe) {
		return false
	}

	if !v.Hotspot20.Equal(other.Hotspot20) {
		return false
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.InjectDhcpOption82.Equal(other.InjectDhcpOption82) {
		return false
	}

	if !v.Interface.Equal(other.Interface) {
		return false
	}

	if !v.Isolation.Equal(other.Isolation) {
		return false
	}

	if !v.L2Isolation.Equal(other.L2Isolation) {
		return false
	}

	if !v.LegacyOverds.Equal(other.LegacyOverds) {
		return false
	}

	if !v.LimitBcast.Equal(other.LimitBcast) {
		return false
	}

	if !v.LimitProbeResponse.Equal(other.LimitProbeResponse) {
		return false
	}

	if !v.MaxIdletime.Equal(other.MaxIdletime) {
		return false
	}

	if !v.MaxNumClients.Equal(other.MaxNumClients) {
		return false
	}

	if !v.MistNac.Equal(other.MistNac) {
		return false
	}

	if !v.ModifiedTime.Equal(other.ModifiedTime) {
		return false
	}

	if !v.MspId.Equal(other.MspId) {
		return false
	}

	if !v.MxtunnelIds.Equal(other.MxtunnelIds) {
		return false
	}

	if !v.MxtunnelName.Equal(other.MxtunnelName) {
		return false
	}

	if !v.NoStaticDns.Equal(other.NoStaticDns) {
		return false
	}

	if !v.NoStaticIp.Equal(other.NoStaticIp) {
		return false
	}

	if !v.OrgId.Equal(other.OrgId) {
		return false
	}

	if !v.Portal.Equal(other.Portal) {
		return false
	}

	if !v.PortalAllowedHostnames.Equal(other.PortalAllowedHostnames) {
		return false
	}

	if !v.PortalAllowedSubnets.Equal(other.PortalAllowedSubnets) {
		return false
	}

	if !v.PortalApiSecret.Equal(other.PortalApiSecret) {
		return false
	}

	if !v.PortalDeniedHostnames.Equal(other.PortalDeniedHostnames) {
		return false
	}

	if !v.PortalImage.Equal(other.PortalImage) {
		return false
	}

	if !v.PortalSsoUrl.Equal(other.PortalSsoUrl) {
		return false
	}

	if !v.Qos.Equal(other.Qos) {
		return false
	}

	if !v.Radsec.Equal(other.Radsec) {
		return false
	}

	if !v.Rateset.Equal(other.Rateset) {
		return false
	}

	if !v.ReconnectClientsWhenRoamingMxcluster.Equal(other.ReconnectClientsWhenRoamingMxcluster) {
		return false
	}

	if !v.RoamMode.Equal(other.RoamMode) {
		return false
	}

	if !v.Schedule.Equal(other.Schedule) {
		return false
	}

	if !v.SleExcluded.Equal(other.SleExcluded) {
		return false
	}

	if !v.Ssid.Equal(other.Ssid) {
		return false
	}

	if !v.TemplateId.Equal(other.TemplateId) {
		return false
	}

	if !v.UseEapolV1.Equal(other.UseEapolV1) {
		return false
	}

	if !v.VlanEnabled.Equal(other.VlanEnabled) {
		return false
	}

	if !v.VlanId.Equal(other.VlanId) {
		return false
	}

	if !v.VlanIds.Equal(other.VlanIds) {
		return false
	}

	if !v.VlanPooling.Equal(other.VlanPooling) {
		return false
	}

	if !v.WlanLimitDown.Equal(other.WlanLimitDown) {
		return false
	}

	if !v.WlanLimitDownEnabled.Equal(other.WlanLimitDownEnabled) {
		return false
	}

	if !v.WlanLimitUp.Equal(other.WlanLimitUp) {
		return false
	}

	if !v.WlanLimitUpEnabled.Equal(other.WlanLimitUpEnabled) {
		return false
	}

	if !v.WxtagIds.Equal(other.WxtagIds) {
		return false
	}

	if !v.WxtunnelId.Equal(other.WxtunnelId) {
		return false
	}

	if !v.WxtunnelRemoteId.Equal(other.WxtunnelRemoteId) {
		return false
	}

	return true
}

func (v OrgWlansValue) Type(ctx context.Context) attr.Type {
	return OrgWlansType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v OrgWlansValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"acct_immediate_update": basetypes.BoolType{},
		"acct_interim_interval": basetypes.Int64Type{},
		"acct_servers": basetypes.ListType{
			ElemType: AcctServersValue{}.Type(ctx),
		},
		"airwatch": basetypes.ObjectType{
			AttrTypes: AirwatchValue{}.AttributeTypes(ctx),
		},
		"allow_ipv6_ndp": basetypes.BoolType{},
		"allow_mdns":     basetypes.BoolType{},
		"allow_ssdp":     basetypes.BoolType{},
		"ap_ids": basetypes.ListType{
			ElemType: types.StringType,
		},
		"app_limit": basetypes.ObjectType{
			AttrTypes: AppLimitValue{}.AttributeTypes(ctx),
		},
		"app_qos": basetypes.ObjectType{
			AttrTypes: AppQosValue{}.AttributeTypes(ctx),
		},
		"apply_to":   basetypes.StringType{},
		"arp_filter": basetypes.BoolType{},
		"auth": basetypes.ObjectType{
			AttrTypes: AuthValue{}.AttributeTypes(ctx),
		},
		"auth_server_selection": basetypes.StringType{},
		"auth_servers": basetypes.ListType{
			ElemType: AuthServersValue{}.Type(ctx),
		},
		"auth_servers_nas_id":    basetypes.StringType{},
		"auth_servers_nas_ip":    basetypes.StringType{},
		"auth_servers_retries":   basetypes.Int64Type{},
		"auth_servers_timeout":   basetypes.Int64Type{},
		"band_steer":             basetypes.BoolType{},
		"band_steer_force_band5": basetypes.BoolType{},
		"bands": basetypes.ListType{
			ElemType: types.StringType,
		},
		"block_blacklist_clients": basetypes.BoolType{},
		"bonjour": basetypes.ObjectType{
			AttrTypes: BonjourValue{}.AttributeTypes(ctx),
		},
		"cisco_cwa": basetypes.ObjectType{
			AttrTypes: CiscoCwaValue{}.AttributeTypes(ctx),
		},
		"client_limit_down":         basetypes.Int64Type{},
		"client_limit_down_enabled": basetypes.BoolType{},
		"client_limit_up":           basetypes.Int64Type{},
		"client_limit_up_enabled":   basetypes.BoolType{},
		"coa_servers": basetypes.ListType{
			ElemType: CoaServersValue{}.Type(ctx),
		},
		"created_time":                     basetypes.Float64Type{},
		"disable_11ax":                     basetypes.BoolType{},
		"disable_ht_vht_rates":             basetypes.BoolType{},
		"disable_uapsd":                    basetypes.BoolType{},
		"disable_v1_roam_notify":           basetypes.BoolType{},
		"disable_v2_roam_notify":           basetypes.BoolType{},
		"disable_when_gateway_unreachable": basetypes.BoolType{},
		"disable_when_mxtunnel_down":       basetypes.BoolType{},
		"disable_wmm":                      basetypes.BoolType{},
		"dns_server_rewrite": basetypes.ObjectType{
			AttrTypes: DnsServerRewriteValue{}.AttributeTypes(ctx),
		},
		"dtim": basetypes.Int64Type{},
		"dynamic_psk": basetypes.ObjectType{
			AttrTypes: DynamicPskValue{}.AttributeTypes(ctx),
		},
		"dynamic_vlan": basetypes.ObjectType{
			AttrTypes: DynamicVlanValue{}.AttributeTypes(ctx),
		},
		"enable_local_keycaching":                basetypes.BoolType{},
		"enable_wireless_bridging":               basetypes.BoolType{},
		"enable_wireless_bridging_dhcp_tracking": basetypes.BoolType{},
		"enabled":                                basetypes.BoolType{},
		"fast_dot1x_timers":                      basetypes.BoolType{},
		"hide_ssid":                              basetypes.BoolType{},
		"hostname_ie":                            basetypes.BoolType{},
		"hotspot20": basetypes.ObjectType{
			AttrTypes: Hotspot20Value{}.AttributeTypes(ctx),
		},
		"id": basetypes.StringType{},
		"inject_dhcp_option_82": basetypes.ObjectType{
			AttrTypes: InjectDhcpOption82Value{}.AttributeTypes(ctx),
		},
		"interface":            basetypes.StringType{},
		"isolation":            basetypes.BoolType{},
		"l2_isolation":         basetypes.BoolType{},
		"legacy_overds":        basetypes.BoolType{},
		"limit_bcast":          basetypes.BoolType{},
		"limit_probe_response": basetypes.BoolType{},
		"max_idletime":         basetypes.Int64Type{},
		"max_num_clients":      basetypes.Int64Type{},
		"mist_nac": basetypes.ObjectType{
			AttrTypes: MistNacValue{}.AttributeTypes(ctx),
		},
		"modified_time": basetypes.Float64Type{},
		"msp_id":        basetypes.StringType{},
		"mxtunnel_ids": basetypes.ListType{
			ElemType: types.StringType,
		},
		"mxtunnel_name": basetypes.ListType{
			ElemType: types.StringType,
		},
		"no_static_dns": basetypes.BoolType{},
		"no_static_ip":  basetypes.BoolType{},
		"org_id":        basetypes.StringType{},
		"portal": basetypes.ObjectType{
			AttrTypes: PortalValue{}.AttributeTypes(ctx),
		},
		"portal_allowed_hostnames": basetypes.ListType{
			ElemType: types.StringType,
		},
		"portal_allowed_subnets": basetypes.ListType{
			ElemType: types.StringType,
		},
		"portal_api_secret": basetypes.StringType{},
		"portal_denied_hostnames": basetypes.ListType{
			ElemType: types.StringType,
		},
		"portal_image":   basetypes.StringType{},
		"portal_sso_url": basetypes.StringType{},
		"qos": basetypes.ObjectType{
			AttrTypes: QosValue{}.AttributeTypes(ctx),
		},
		"radsec": basetypes.ObjectType{
			AttrTypes: RadsecValue{}.AttributeTypes(ctx),
		},
		"rateset": basetypes.MapType{
			ElemType: RatesetValue{}.Type(ctx),
		},
		"reconnect_clients_when_roaming_mxcluster": basetypes.BoolType{},
		"roam_mode": basetypes.StringType{},
		"schedule": basetypes.ObjectType{
			AttrTypes: ScheduleValue{}.AttributeTypes(ctx),
		},
		"sle_excluded": basetypes.BoolType{},
		"ssid":         basetypes.StringType{},
		"template_id":  basetypes.StringType{},
		"use_eapol_v1": basetypes.BoolType{},
		"vlan_enabled": basetypes.BoolType{},
		"vlan_id":      basetypes.StringType{},
		"vlan_ids": basetypes.ListType{
			ElemType: types.StringType,
		},
		"vlan_pooling":            basetypes.BoolType{},
		"wlan_limit_down":         basetypes.Int64Type{},
		"wlan_limit_down_enabled": basetypes.BoolType{},
		"wlan_limit_up":           basetypes.Int64Type{},
		"wlan_limit_up_enabled":   basetypes.BoolType{},
		"wxtag_ids": basetypes.ListType{
			ElemType: types.StringType,
		},
		"wxtunnel_id":        basetypes.StringType{},
		"wxtunnel_remote_id": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = AcctServersType{}

type AcctServersType struct {
	basetypes.ObjectType
}

func (t AcctServersType) Equal(o attr.Type) bool {
	other, ok := o.(AcctServersType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AcctServersType) String() string {
	return "AcctServersType"
}

func (t AcctServersType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	hostAttribute, ok := attributes["host"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`host is missing from object`)

		return nil, diags
	}

	hostVal, ok := hostAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`host expected to be basetypes.StringValue, was: %T`, hostAttribute))
	}

	keywrapEnabledAttribute, ok := attributes["keywrap_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywrap_enabled is missing from object`)

		return nil, diags
	}

	keywrapEnabledVal, ok := keywrapEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywrap_enabled expected to be basetypes.BoolValue, was: %T`, keywrapEnabledAttribute))
	}

	keywrapFormatAttribute, ok := attributes["keywrap_format"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywrap_format is missing from object`)

		return nil, diags
	}

	keywrapFormatVal, ok := keywrapFormatAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywrap_format expected to be basetypes.StringValue, was: %T`, keywrapFormatAttribute))
	}

	keywrapKekAttribute, ok := attributes["keywrap_kek"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywrap_kek is missing from object`)

		return nil, diags
	}

	keywrapKekVal, ok := keywrapKekAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywrap_kek expected to be basetypes.StringValue, was: %T`, keywrapKekAttribute))
	}

	keywrapMackAttribute, ok := attributes["keywrap_mack"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywrap_mack is missing from object`)

		return nil, diags
	}

	keywrapMackVal, ok := keywrapMackAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywrap_mack expected to be basetypes.StringValue, was: %T`, keywrapMackAttribute))
	}

	portAttribute, ok := attributes["port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port is missing from object`)

		return nil, diags
	}

	portVal, ok := portAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port expected to be basetypes.Int64Value, was: %T`, portAttribute))
	}

	secretAttribute, ok := attributes["secret"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`secret is missing from object`)

		return nil, diags
	}

	secretVal, ok := secretAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`secret expected to be basetypes.StringValue, was: %T`, secretAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AcctServersValue{
		Host:           hostVal,
		KeywrapEnabled: keywrapEnabledVal,
		KeywrapFormat:  keywrapFormatVal,
		KeywrapKek:     keywrapKekVal,
		KeywrapMack:    keywrapMackVal,
		Port:           portVal,
		Secret:         secretVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewAcctServersValueNull() AcctServersValue {
	return AcctServersValue{
		state: attr.ValueStateNull,
	}
}

func NewAcctServersValueUnknown() AcctServersValue {
	return AcctServersValue{
		state: attr.ValueStateUnknown,
	}
}

func NewAcctServersValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AcctServersValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AcctServersValue Attribute Value",
				"While creating a AcctServersValue value, a missing attribute value was detected. "+
					"A AcctServersValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AcctServersValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AcctServersValue Attribute Type",
				"While creating a AcctServersValue value, an invalid attribute value was detected. "+
					"A AcctServersValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AcctServersValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AcctServersValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AcctServersValue Attribute Value",
				"While creating a AcctServersValue value, an extra attribute value was detected. "+
					"A AcctServersValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AcctServersValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAcctServersValueUnknown(), diags
	}

	hostAttribute, ok := attributes["host"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`host is missing from object`)

		return NewAcctServersValueUnknown(), diags
	}

	hostVal, ok := hostAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`host expected to be basetypes.StringValue, was: %T`, hostAttribute))
	}

	keywrapEnabledAttribute, ok := attributes["keywrap_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywrap_enabled is missing from object`)

		return NewAcctServersValueUnknown(), diags
	}

	keywrapEnabledVal, ok := keywrapEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywrap_enabled expected to be basetypes.BoolValue, was: %T`, keywrapEnabledAttribute))
	}

	keywrapFormatAttribute, ok := attributes["keywrap_format"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywrap_format is missing from object`)

		return NewAcctServersValueUnknown(), diags
	}

	keywrapFormatVal, ok := keywrapFormatAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywrap_format expected to be basetypes.StringValue, was: %T`, keywrapFormatAttribute))
	}

	keywrapKekAttribute, ok := attributes["keywrap_kek"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywrap_kek is missing from object`)

		return NewAcctServersValueUnknown(), diags
	}

	keywrapKekVal, ok := keywrapKekAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywrap_kek expected to be basetypes.StringValue, was: %T`, keywrapKekAttribute))
	}

	keywrapMackAttribute, ok := attributes["keywrap_mack"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywrap_mack is missing from object`)

		return NewAcctServersValueUnknown(), diags
	}

	keywrapMackVal, ok := keywrapMackAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywrap_mack expected to be basetypes.StringValue, was: %T`, keywrapMackAttribute))
	}

	portAttribute, ok := attributes["port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port is missing from object`)

		return NewAcctServersValueUnknown(), diags
	}

	portVal, ok := portAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port expected to be basetypes.Int64Value, was: %T`, portAttribute))
	}

	secretAttribute, ok := attributes["secret"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`secret is missing from object`)

		return NewAcctServersValueUnknown(), diags
	}

	secretVal, ok := secretAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`secret expected to be basetypes.StringValue, was: %T`, secretAttribute))
	}

	if diags.HasError() {
		return NewAcctServersValueUnknown(), diags
	}

	return AcctServersValue{
		Host:           hostVal,
		KeywrapEnabled: keywrapEnabledVal,
		KeywrapFormat:  keywrapFormatVal,
		KeywrapKek:     keywrapKekVal,
		KeywrapMack:    keywrapMackVal,
		Port:           portVal,
		Secret:         secretVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewAcctServersValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AcctServersValue {
	object, diags := NewAcctServersValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAcctServersValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AcctServersType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAcctServersValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAcctServersValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAcctServersValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAcctServersValueMust(AcctServersValue{}.AttributeTypes(ctx), attributes), nil
}

func (t AcctServersType) ValueType(ctx context.Context) attr.Value {
	return AcctServersValue{}
}

var _ basetypes.ObjectValuable = AcctServersValue{}

type AcctServersValue struct {
	Host           basetypes.StringValue `tfsdk:"host"`
	KeywrapEnabled basetypes.BoolValue   `tfsdk:"keywrap_enabled"`
	KeywrapFormat  basetypes.StringValue `tfsdk:"keywrap_format"`
	KeywrapKek     basetypes.StringValue `tfsdk:"keywrap_kek"`
	KeywrapMack    basetypes.StringValue `tfsdk:"keywrap_mack"`
	Port           basetypes.Int64Value  `tfsdk:"port"`
	Secret         basetypes.StringValue `tfsdk:"secret"`
	state          attr.ValueState
}

func (v AcctServersValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 7)

	var val tftypes.Value
	var err error

	attrTypes["host"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["keywrap_enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["keywrap_format"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["keywrap_kek"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["keywrap_mack"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["port"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["secret"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 7)

		val, err = v.Host.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["host"] = val

		val, err = v.KeywrapEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["keywrap_enabled"] = val

		val, err = v.KeywrapFormat.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["keywrap_format"] = val

		val, err = v.KeywrapKek.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["keywrap_kek"] = val

		val, err = v.KeywrapMack.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["keywrap_mack"] = val

		val, err = v.Port.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port"] = val

		val, err = v.Secret.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["secret"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AcctServersValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AcctServersValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AcctServersValue) String() string {
	return "AcctServersValue"
}

func (v AcctServersValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"host":            basetypes.StringType{},
		"keywrap_enabled": basetypes.BoolType{},
		"keywrap_format":  basetypes.StringType{},
		"keywrap_kek":     basetypes.StringType{},
		"keywrap_mack":    basetypes.StringType{},
		"port":            basetypes.Int64Type{},
		"secret":          basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"host":            v.Host,
			"keywrap_enabled": v.KeywrapEnabled,
			"keywrap_format":  v.KeywrapFormat,
			"keywrap_kek":     v.KeywrapKek,
			"keywrap_mack":    v.KeywrapMack,
			"port":            v.Port,
			"secret":          v.Secret,
		})

	return objVal, diags
}

func (v AcctServersValue) Equal(o attr.Value) bool {
	other, ok := o.(AcctServersValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Host.Equal(other.Host) {
		return false
	}

	if !v.KeywrapEnabled.Equal(other.KeywrapEnabled) {
		return false
	}

	if !v.KeywrapFormat.Equal(other.KeywrapFormat) {
		return false
	}

	if !v.KeywrapKek.Equal(other.KeywrapKek) {
		return false
	}

	if !v.KeywrapMack.Equal(other.KeywrapMack) {
		return false
	}

	if !v.Port.Equal(other.Port) {
		return false
	}

	if !v.Secret.Equal(other.Secret) {
		return false
	}

	return true
}

func (v AcctServersValue) Type(ctx context.Context) attr.Type {
	return AcctServersType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AcctServersValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"host":            basetypes.StringType{},
		"keywrap_enabled": basetypes.BoolType{},
		"keywrap_format":  basetypes.StringType{},
		"keywrap_kek":     basetypes.StringType{},
		"keywrap_mack":    basetypes.StringType{},
		"port":            basetypes.Int64Type{},
		"secret":          basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = AirwatchType{}

type AirwatchType struct {
	basetypes.ObjectType
}

func (t AirwatchType) Equal(o attr.Type) bool {
	other, ok := o.(AirwatchType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AirwatchType) String() string {
	return "AirwatchType"
}

func (t AirwatchType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	apiKeyAttribute, ok := attributes["api_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`api_key is missing from object`)

		return nil, diags
	}

	apiKeyVal, ok := apiKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`api_key expected to be basetypes.StringValue, was: %T`, apiKeyAttribute))
	}

	consoleUrlAttribute, ok := attributes["console_url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`console_url is missing from object`)

		return nil, diags
	}

	consoleUrlVal, ok := consoleUrlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`console_url expected to be basetypes.StringValue, was: %T`, consoleUrlAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	passwordAttribute, ok := attributes["password"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`password is missing from object`)

		return nil, diags
	}

	passwordVal, ok := passwordAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`password expected to be basetypes.StringValue, was: %T`, passwordAttribute))
	}

	usernameAttribute, ok := attributes["username"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`username is missing from object`)

		return nil, diags
	}

	usernameVal, ok := usernameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`username expected to be basetypes.StringValue, was: %T`, usernameAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AirwatchValue{
		ApiKey:     apiKeyVal,
		ConsoleUrl: consoleUrlVal,
		Enabled:    enabledVal,
		Password:   passwordVal,
		Username:   usernameVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewAirwatchValueNull() AirwatchValue {
	return AirwatchValue{
		state: attr.ValueStateNull,
	}
}

func NewAirwatchValueUnknown() AirwatchValue {
	return AirwatchValue{
		state: attr.ValueStateUnknown,
	}
}

func NewAirwatchValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AirwatchValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AirwatchValue Attribute Value",
				"While creating a AirwatchValue value, a missing attribute value was detected. "+
					"A AirwatchValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AirwatchValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AirwatchValue Attribute Type",
				"While creating a AirwatchValue value, an invalid attribute value was detected. "+
					"A AirwatchValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AirwatchValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AirwatchValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AirwatchValue Attribute Value",
				"While creating a AirwatchValue value, an extra attribute value was detected. "+
					"A AirwatchValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AirwatchValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAirwatchValueUnknown(), diags
	}

	apiKeyAttribute, ok := attributes["api_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`api_key is missing from object`)

		return NewAirwatchValueUnknown(), diags
	}

	apiKeyVal, ok := apiKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`api_key expected to be basetypes.StringValue, was: %T`, apiKeyAttribute))
	}

	consoleUrlAttribute, ok := attributes["console_url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`console_url is missing from object`)

		return NewAirwatchValueUnknown(), diags
	}

	consoleUrlVal, ok := consoleUrlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`console_url expected to be basetypes.StringValue, was: %T`, consoleUrlAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewAirwatchValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	passwordAttribute, ok := attributes["password"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`password is missing from object`)

		return NewAirwatchValueUnknown(), diags
	}

	passwordVal, ok := passwordAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`password expected to be basetypes.StringValue, was: %T`, passwordAttribute))
	}

	usernameAttribute, ok := attributes["username"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`username is missing from object`)

		return NewAirwatchValueUnknown(), diags
	}

	usernameVal, ok := usernameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`username expected to be basetypes.StringValue, was: %T`, usernameAttribute))
	}

	if diags.HasError() {
		return NewAirwatchValueUnknown(), diags
	}

	return AirwatchValue{
		ApiKey:     apiKeyVal,
		ConsoleUrl: consoleUrlVal,
		Enabled:    enabledVal,
		Password:   passwordVal,
		Username:   usernameVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewAirwatchValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AirwatchValue {
	object, diags := NewAirwatchValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAirwatchValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AirwatchType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAirwatchValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAirwatchValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAirwatchValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAirwatchValueMust(AirwatchValue{}.AttributeTypes(ctx), attributes), nil
}

func (t AirwatchType) ValueType(ctx context.Context) attr.Value {
	return AirwatchValue{}
}

var _ basetypes.ObjectValuable = AirwatchValue{}

type AirwatchValue struct {
	ApiKey     basetypes.StringValue `tfsdk:"api_key"`
	ConsoleUrl basetypes.StringValue `tfsdk:"console_url"`
	Enabled    basetypes.BoolValue   `tfsdk:"enabled"`
	Password   basetypes.StringValue `tfsdk:"password"`
	Username   basetypes.StringValue `tfsdk:"username"`
	state      attr.ValueState
}

func (v AirwatchValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["api_key"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["console_url"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["password"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["username"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.ApiKey.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["api_key"] = val

		val, err = v.ConsoleUrl.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["console_url"] = val

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.Password.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["password"] = val

		val, err = v.Username.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["username"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AirwatchValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AirwatchValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AirwatchValue) String() string {
	return "AirwatchValue"
}

func (v AirwatchValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"api_key":     basetypes.StringType{},
		"console_url": basetypes.StringType{},
		"enabled":     basetypes.BoolType{},
		"password":    basetypes.StringType{},
		"username":    basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"api_key":     v.ApiKey,
			"console_url": v.ConsoleUrl,
			"enabled":     v.Enabled,
			"password":    v.Password,
			"username":    v.Username,
		})

	return objVal, diags
}

func (v AirwatchValue) Equal(o attr.Value) bool {
	other, ok := o.(AirwatchValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.ApiKey.Equal(other.ApiKey) {
		return false
	}

	if !v.ConsoleUrl.Equal(other.ConsoleUrl) {
		return false
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.Password.Equal(other.Password) {
		return false
	}

	if !v.Username.Equal(other.Username) {
		return false
	}

	return true
}

func (v AirwatchValue) Type(ctx context.Context) attr.Type {
	return AirwatchType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AirwatchValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"api_key":     basetypes.StringType{},
		"console_url": basetypes.StringType{},
		"enabled":     basetypes.BoolType{},
		"password":    basetypes.StringType{},
		"username":    basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = AppLimitType{}

type AppLimitType struct {
	basetypes.ObjectType
}

func (t AppLimitType) Equal(o attr.Type) bool {
	other, ok := o.(AppLimitType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AppLimitType) String() string {
	return "AppLimitType"
}

func (t AppLimitType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	appsAttribute, ok := attributes["apps"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`apps is missing from object`)

		return nil, diags
	}

	appsVal, ok := appsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`apps expected to be basetypes.MapValue, was: %T`, appsAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	wxtagIdsAttribute, ok := attributes["wxtag_ids"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wxtag_ids is missing from object`)

		return nil, diags
	}

	wxtagIdsVal, ok := wxtagIdsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wxtag_ids expected to be basetypes.MapValue, was: %T`, wxtagIdsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AppLimitValue{
		Apps:     appsVal,
		Enabled:  enabledVal,
		WxtagIds: wxtagIdsVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewAppLimitValueNull() AppLimitValue {
	return AppLimitValue{
		state: attr.ValueStateNull,
	}
}

func NewAppLimitValueUnknown() AppLimitValue {
	return AppLimitValue{
		state: attr.ValueStateUnknown,
	}
}

func NewAppLimitValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AppLimitValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AppLimitValue Attribute Value",
				"While creating a AppLimitValue value, a missing attribute value was detected. "+
					"A AppLimitValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AppLimitValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AppLimitValue Attribute Type",
				"While creating a AppLimitValue value, an invalid attribute value was detected. "+
					"A AppLimitValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AppLimitValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AppLimitValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AppLimitValue Attribute Value",
				"While creating a AppLimitValue value, an extra attribute value was detected. "+
					"A AppLimitValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AppLimitValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAppLimitValueUnknown(), diags
	}

	appsAttribute, ok := attributes["apps"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`apps is missing from object`)

		return NewAppLimitValueUnknown(), diags
	}

	appsVal, ok := appsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`apps expected to be basetypes.MapValue, was: %T`, appsAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewAppLimitValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	wxtagIdsAttribute, ok := attributes["wxtag_ids"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wxtag_ids is missing from object`)

		return NewAppLimitValueUnknown(), diags
	}

	wxtagIdsVal, ok := wxtagIdsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wxtag_ids expected to be basetypes.MapValue, was: %T`, wxtagIdsAttribute))
	}

	if diags.HasError() {
		return NewAppLimitValueUnknown(), diags
	}

	return AppLimitValue{
		Apps:     appsVal,
		Enabled:  enabledVal,
		WxtagIds: wxtagIdsVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewAppLimitValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AppLimitValue {
	object, diags := NewAppLimitValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAppLimitValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AppLimitType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAppLimitValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAppLimitValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAppLimitValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAppLimitValueMust(AppLimitValue{}.AttributeTypes(ctx), attributes), nil
}

func (t AppLimitType) ValueType(ctx context.Context) attr.Value {
	return AppLimitValue{}
}

var _ basetypes.ObjectValuable = AppLimitValue{}

type AppLimitValue struct {
	Apps     basetypes.MapValue  `tfsdk:"apps"`
	Enabled  basetypes.BoolValue `tfsdk:"enabled"`
	WxtagIds basetypes.MapValue  `tfsdk:"wxtag_ids"`
	state    attr.ValueState
}

func (v AppLimitValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["apps"] = basetypes.MapType{
		ElemType: types.Int64Type,
	}.TerraformType(ctx)
	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["wxtag_ids"] = basetypes.MapType{
		ElemType: types.Int64Type,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Apps.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["apps"] = val

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.WxtagIds.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["wxtag_ids"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AppLimitValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AppLimitValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AppLimitValue) String() string {
	return "AppLimitValue"
}

func (v AppLimitValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	appsVal, d := types.MapValue(types.Int64Type, v.Apps.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"apps": basetypes.MapType{
				ElemType: types.Int64Type,
			},
			"enabled": basetypes.BoolType{},
			"wxtag_ids": basetypes.MapType{
				ElemType: types.Int64Type,
			},
		}), diags
	}

	wxtagIdsVal, d := types.MapValue(types.Int64Type, v.WxtagIds.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"apps": basetypes.MapType{
				ElemType: types.Int64Type,
			},
			"enabled": basetypes.BoolType{},
			"wxtag_ids": basetypes.MapType{
				ElemType: types.Int64Type,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"apps": basetypes.MapType{
			ElemType: types.Int64Type,
		},
		"enabled": basetypes.BoolType{},
		"wxtag_ids": basetypes.MapType{
			ElemType: types.Int64Type,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"apps":      appsVal,
			"enabled":   v.Enabled,
			"wxtag_ids": wxtagIdsVal,
		})

	return objVal, diags
}

func (v AppLimitValue) Equal(o attr.Value) bool {
	other, ok := o.(AppLimitValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Apps.Equal(other.Apps) {
		return false
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.WxtagIds.Equal(other.WxtagIds) {
		return false
	}

	return true
}

func (v AppLimitValue) Type(ctx context.Context) attr.Type {
	return AppLimitType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AppLimitValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"apps": basetypes.MapType{
			ElemType: types.Int64Type,
		},
		"enabled": basetypes.BoolType{},
		"wxtag_ids": basetypes.MapType{
			ElemType: types.Int64Type,
		},
	}
}

var _ basetypes.ObjectTypable = AppQosType{}

type AppQosType struct {
	basetypes.ObjectType
}

func (t AppQosType) Equal(o attr.Type) bool {
	other, ok := o.(AppQosType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AppQosType) String() string {
	return "AppQosType"
}

func (t AppQosType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	appsAttribute, ok := attributes["apps"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`apps is missing from object`)

		return nil, diags
	}

	appsVal, ok := appsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`apps expected to be basetypes.MapValue, was: %T`, appsAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	othersAttribute, ok := attributes["others"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`others is missing from object`)

		return nil, diags
	}

	othersVal, ok := othersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`others expected to be basetypes.ListValue, was: %T`, othersAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AppQosValue{
		Apps:    appsVal,
		Enabled: enabledVal,
		Others:  othersVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewAppQosValueNull() AppQosValue {
	return AppQosValue{
		state: attr.ValueStateNull,
	}
}

func NewAppQosValueUnknown() AppQosValue {
	return AppQosValue{
		state: attr.ValueStateUnknown,
	}
}

func NewAppQosValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AppQosValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AppQosValue Attribute Value",
				"While creating a AppQosValue value, a missing attribute value was detected. "+
					"A AppQosValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AppQosValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AppQosValue Attribute Type",
				"While creating a AppQosValue value, an invalid attribute value was detected. "+
					"A AppQosValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AppQosValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AppQosValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AppQosValue Attribute Value",
				"While creating a AppQosValue value, an extra attribute value was detected. "+
					"A AppQosValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AppQosValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAppQosValueUnknown(), diags
	}

	appsAttribute, ok := attributes["apps"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`apps is missing from object`)

		return NewAppQosValueUnknown(), diags
	}

	appsVal, ok := appsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`apps expected to be basetypes.MapValue, was: %T`, appsAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewAppQosValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	othersAttribute, ok := attributes["others"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`others is missing from object`)

		return NewAppQosValueUnknown(), diags
	}

	othersVal, ok := othersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`others expected to be basetypes.ListValue, was: %T`, othersAttribute))
	}

	if diags.HasError() {
		return NewAppQosValueUnknown(), diags
	}

	return AppQosValue{
		Apps:    appsVal,
		Enabled: enabledVal,
		Others:  othersVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewAppQosValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AppQosValue {
	object, diags := NewAppQosValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAppQosValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AppQosType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAppQosValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAppQosValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAppQosValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAppQosValueMust(AppQosValue{}.AttributeTypes(ctx), attributes), nil
}

func (t AppQosType) ValueType(ctx context.Context) attr.Value {
	return AppQosValue{}
}

var _ basetypes.ObjectValuable = AppQosValue{}

type AppQosValue struct {
	Apps    basetypes.MapValue  `tfsdk:"apps"`
	Enabled basetypes.BoolValue `tfsdk:"enabled"`
	Others  basetypes.ListValue `tfsdk:"others"`
	state   attr.ValueState
}

func (v AppQosValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["apps"] = basetypes.MapType{
		ElemType: AppsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["others"] = basetypes.ListType{
		ElemType: OthersValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Apps.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["apps"] = val

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.Others.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["others"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AppQosValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AppQosValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AppQosValue) String() string {
	return "AppQosValue"
}

func (v AppQosValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	apps := types.MapValueMust(
		AppsType{
			basetypes.ObjectType{
				AttrTypes: AppsValue{}.AttributeTypes(ctx),
			},
		},
		v.Apps.Elements(),
	)

	if v.Apps.IsNull() {
		apps = types.MapNull(
			AppsType{
				basetypes.ObjectType{
					AttrTypes: AppsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Apps.IsUnknown() {
		apps = types.MapUnknown(
			AppsType{
				basetypes.ObjectType{
					AttrTypes: AppsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	others := types.ListValueMust(
		OthersType{
			basetypes.ObjectType{
				AttrTypes: OthersValue{}.AttributeTypes(ctx),
			},
		},
		v.Others.Elements(),
	)

	if v.Others.IsNull() {
		others = types.ListNull(
			OthersType{
				basetypes.ObjectType{
					AttrTypes: OthersValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Others.IsUnknown() {
		others = types.ListUnknown(
			OthersType{
				basetypes.ObjectType{
					AttrTypes: OthersValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"apps": basetypes.MapType{
			ElemType: AppsValue{}.Type(ctx),
		},
		"enabled": basetypes.BoolType{},
		"others": basetypes.ListType{
			ElemType: OthersValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"apps":    apps,
			"enabled": v.Enabled,
			"others":  others,
		})

	return objVal, diags
}

func (v AppQosValue) Equal(o attr.Value) bool {
	other, ok := o.(AppQosValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Apps.Equal(other.Apps) {
		return false
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.Others.Equal(other.Others) {
		return false
	}

	return true
}

func (v AppQosValue) Type(ctx context.Context) attr.Type {
	return AppQosType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AppQosValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"apps": basetypes.MapType{
			ElemType: AppsValue{}.Type(ctx),
		},
		"enabled": basetypes.BoolType{},
		"others": basetypes.ListType{
			ElemType: OthersValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = AppsType{}

type AppsType struct {
	basetypes.ObjectType
}

func (t AppsType) Equal(o attr.Type) bool {
	other, ok := o.(AppsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AppsType) String() string {
	return "AppsType"
}

func (t AppsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	dscpAttribute, ok := attributes["dscp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dscp is missing from object`)

		return nil, diags
	}

	dscpVal, ok := dscpAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dscp expected to be basetypes.Int64Value, was: %T`, dscpAttribute))
	}

	dstSubnetAttribute, ok := attributes["dst_subnet"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dst_subnet is missing from object`)

		return nil, diags
	}

	dstSubnetVal, ok := dstSubnetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dst_subnet expected to be basetypes.StringValue, was: %T`, dstSubnetAttribute))
	}

	srcSubnetAttribute, ok := attributes["src_subnet"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`src_subnet is missing from object`)

		return nil, diags
	}

	srcSubnetVal, ok := srcSubnetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`src_subnet expected to be basetypes.StringValue, was: %T`, srcSubnetAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AppsValue{
		Dscp:      dscpVal,
		DstSubnet: dstSubnetVal,
		SrcSubnet: srcSubnetVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewAppsValueNull() AppsValue {
	return AppsValue{
		state: attr.ValueStateNull,
	}
}

func NewAppsValueUnknown() AppsValue {
	return AppsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewAppsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AppsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AppsValue Attribute Value",
				"While creating a AppsValue value, a missing attribute value was detected. "+
					"A AppsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AppsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AppsValue Attribute Type",
				"While creating a AppsValue value, an invalid attribute value was detected. "+
					"A AppsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AppsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AppsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AppsValue Attribute Value",
				"While creating a AppsValue value, an extra attribute value was detected. "+
					"A AppsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AppsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAppsValueUnknown(), diags
	}

	dscpAttribute, ok := attributes["dscp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dscp is missing from object`)

		return NewAppsValueUnknown(), diags
	}

	dscpVal, ok := dscpAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dscp expected to be basetypes.Int64Value, was: %T`, dscpAttribute))
	}

	dstSubnetAttribute, ok := attributes["dst_subnet"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dst_subnet is missing from object`)

		return NewAppsValueUnknown(), diags
	}

	dstSubnetVal, ok := dstSubnetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dst_subnet expected to be basetypes.StringValue, was: %T`, dstSubnetAttribute))
	}

	srcSubnetAttribute, ok := attributes["src_subnet"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`src_subnet is missing from object`)

		return NewAppsValueUnknown(), diags
	}

	srcSubnetVal, ok := srcSubnetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`src_subnet expected to be basetypes.StringValue, was: %T`, srcSubnetAttribute))
	}

	if diags.HasError() {
		return NewAppsValueUnknown(), diags
	}

	return AppsValue{
		Dscp:      dscpVal,
		DstSubnet: dstSubnetVal,
		SrcSubnet: srcSubnetVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewAppsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AppsValue {
	object, diags := NewAppsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAppsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AppsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAppsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAppsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAppsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAppsValueMust(AppsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t AppsType) ValueType(ctx context.Context) attr.Value {
	return AppsValue{}
}

var _ basetypes.ObjectValuable = AppsValue{}

type AppsValue struct {
	Dscp      basetypes.Int64Value  `tfsdk:"dscp"`
	DstSubnet basetypes.StringValue `tfsdk:"dst_subnet"`
	SrcSubnet basetypes.StringValue `tfsdk:"src_subnet"`
	state     attr.ValueState
}

func (v AppsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["dscp"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["dst_subnet"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["src_subnet"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Dscp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dscp"] = val

		val, err = v.DstSubnet.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dst_subnet"] = val

		val, err = v.SrcSubnet.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["src_subnet"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AppsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AppsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AppsValue) String() string {
	return "AppsValue"
}

func (v AppsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"dscp":       basetypes.Int64Type{},
		"dst_subnet": basetypes.StringType{},
		"src_subnet": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"dscp":       v.Dscp,
			"dst_subnet": v.DstSubnet,
			"src_subnet": v.SrcSubnet,
		})

	return objVal, diags
}

func (v AppsValue) Equal(o attr.Value) bool {
	other, ok := o.(AppsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Dscp.Equal(other.Dscp) {
		return false
	}

	if !v.DstSubnet.Equal(other.DstSubnet) {
		return false
	}

	if !v.SrcSubnet.Equal(other.SrcSubnet) {
		return false
	}

	return true
}

func (v AppsValue) Type(ctx context.Context) attr.Type {
	return AppsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AppsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"dscp":       basetypes.Int64Type{},
		"dst_subnet": basetypes.StringType{},
		"src_subnet": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = OthersType{}

type OthersType struct {
	basetypes.ObjectType
}

func (t OthersType) Equal(o attr.Type) bool {
	other, ok := o.(OthersType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t OthersType) String() string {
	return "OthersType"
}

func (t OthersType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	dscpAttribute, ok := attributes["dscp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dscp is missing from object`)

		return nil, diags
	}

	dscpVal, ok := dscpAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dscp expected to be basetypes.Int64Value, was: %T`, dscpAttribute))
	}

	dstSubnetAttribute, ok := attributes["dst_subnet"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dst_subnet is missing from object`)

		return nil, diags
	}

	dstSubnetVal, ok := dstSubnetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dst_subnet expected to be basetypes.StringValue, was: %T`, dstSubnetAttribute))
	}

	portRangesAttribute, ok := attributes["port_ranges"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_ranges is missing from object`)

		return nil, diags
	}

	portRangesVal, ok := portRangesAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_ranges expected to be basetypes.StringValue, was: %T`, portRangesAttribute))
	}

	protocolAttribute, ok := attributes["protocol"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`protocol is missing from object`)

		return nil, diags
	}

	protocolVal, ok := protocolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`protocol expected to be basetypes.StringValue, was: %T`, protocolAttribute))
	}

	srcSubnetAttribute, ok := attributes["src_subnet"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`src_subnet is missing from object`)

		return nil, diags
	}

	srcSubnetVal, ok := srcSubnetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`src_subnet expected to be basetypes.StringValue, was: %T`, srcSubnetAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return OthersValue{
		Dscp:       dscpVal,
		DstSubnet:  dstSubnetVal,
		PortRanges: portRangesVal,
		Protocol:   protocolVal,
		SrcSubnet:  srcSubnetVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewOthersValueNull() OthersValue {
	return OthersValue{
		state: attr.ValueStateNull,
	}
}

func NewOthersValueUnknown() OthersValue {
	return OthersValue{
		state: attr.ValueStateUnknown,
	}
}

func NewOthersValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (OthersValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing OthersValue Attribute Value",
				"While creating a OthersValue value, a missing attribute value was detected. "+
					"A OthersValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OthersValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid OthersValue Attribute Type",
				"While creating a OthersValue value, an invalid attribute value was detected. "+
					"A OthersValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OthersValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("OthersValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra OthersValue Attribute Value",
				"While creating a OthersValue value, an extra attribute value was detected. "+
					"A OthersValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra OthersValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewOthersValueUnknown(), diags
	}

	dscpAttribute, ok := attributes["dscp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dscp is missing from object`)

		return NewOthersValueUnknown(), diags
	}

	dscpVal, ok := dscpAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dscp expected to be basetypes.Int64Value, was: %T`, dscpAttribute))
	}

	dstSubnetAttribute, ok := attributes["dst_subnet"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dst_subnet is missing from object`)

		return NewOthersValueUnknown(), diags
	}

	dstSubnetVal, ok := dstSubnetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dst_subnet expected to be basetypes.StringValue, was: %T`, dstSubnetAttribute))
	}

	portRangesAttribute, ok := attributes["port_ranges"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_ranges is missing from object`)

		return NewOthersValueUnknown(), diags
	}

	portRangesVal, ok := portRangesAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_ranges expected to be basetypes.StringValue, was: %T`, portRangesAttribute))
	}

	protocolAttribute, ok := attributes["protocol"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`protocol is missing from object`)

		return NewOthersValueUnknown(), diags
	}

	protocolVal, ok := protocolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`protocol expected to be basetypes.StringValue, was: %T`, protocolAttribute))
	}

	srcSubnetAttribute, ok := attributes["src_subnet"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`src_subnet is missing from object`)

		return NewOthersValueUnknown(), diags
	}

	srcSubnetVal, ok := srcSubnetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`src_subnet expected to be basetypes.StringValue, was: %T`, srcSubnetAttribute))
	}

	if diags.HasError() {
		return NewOthersValueUnknown(), diags
	}

	return OthersValue{
		Dscp:       dscpVal,
		DstSubnet:  dstSubnetVal,
		PortRanges: portRangesVal,
		Protocol:   protocolVal,
		SrcSubnet:  srcSubnetVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewOthersValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) OthersValue {
	object, diags := NewOthersValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewOthersValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t OthersType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewOthersValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewOthersValueUnknown(), nil
	}

	if in.IsNull() {
		return NewOthersValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewOthersValueMust(OthersValue{}.AttributeTypes(ctx), attributes), nil
}

func (t OthersType) ValueType(ctx context.Context) attr.Value {
	return OthersValue{}
}

var _ basetypes.ObjectValuable = OthersValue{}

type OthersValue struct {
	Dscp       basetypes.Int64Value  `tfsdk:"dscp"`
	DstSubnet  basetypes.StringValue `tfsdk:"dst_subnet"`
	PortRanges basetypes.StringValue `tfsdk:"port_ranges"`
	Protocol   basetypes.StringValue `tfsdk:"protocol"`
	SrcSubnet  basetypes.StringValue `tfsdk:"src_subnet"`
	state      attr.ValueState
}

func (v OthersValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["dscp"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["dst_subnet"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["port_ranges"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["protocol"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["src_subnet"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.Dscp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dscp"] = val

		val, err = v.DstSubnet.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dst_subnet"] = val

		val, err = v.PortRanges.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port_ranges"] = val

		val, err = v.Protocol.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["protocol"] = val

		val, err = v.SrcSubnet.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["src_subnet"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v OthersValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v OthersValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v OthersValue) String() string {
	return "OthersValue"
}

func (v OthersValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"dscp":        basetypes.Int64Type{},
		"dst_subnet":  basetypes.StringType{},
		"port_ranges": basetypes.StringType{},
		"protocol":    basetypes.StringType{},
		"src_subnet":  basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"dscp":        v.Dscp,
			"dst_subnet":  v.DstSubnet,
			"port_ranges": v.PortRanges,
			"protocol":    v.Protocol,
			"src_subnet":  v.SrcSubnet,
		})

	return objVal, diags
}

func (v OthersValue) Equal(o attr.Value) bool {
	other, ok := o.(OthersValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Dscp.Equal(other.Dscp) {
		return false
	}

	if !v.DstSubnet.Equal(other.DstSubnet) {
		return false
	}

	if !v.PortRanges.Equal(other.PortRanges) {
		return false
	}

	if !v.Protocol.Equal(other.Protocol) {
		return false
	}

	if !v.SrcSubnet.Equal(other.SrcSubnet) {
		return false
	}

	return true
}

func (v OthersValue) Type(ctx context.Context) attr.Type {
	return OthersType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v OthersValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"dscp":        basetypes.Int64Type{},
		"dst_subnet":  basetypes.StringType{},
		"port_ranges": basetypes.StringType{},
		"protocol":    basetypes.StringType{},
		"src_subnet":  basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = AuthType{}

type AuthType struct {
	basetypes.ObjectType
}

func (t AuthType) Equal(o attr.Type) bool {
	other, ok := o.(AuthType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AuthType) String() string {
	return "AuthType"
}

func (t AuthType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	anticlogThresholdAttribute, ok := attributes["anticlog_threshold"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`anticlog_threshold is missing from object`)

		return nil, diags
	}

	anticlogThresholdVal, ok := anticlogThresholdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`anticlog_threshold expected to be basetypes.Int64Value, was: %T`, anticlogThresholdAttribute))
	}

	eapReauthAttribute, ok := attributes["eap_reauth"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`eap_reauth is missing from object`)

		return nil, diags
	}

	eapReauthVal, ok := eapReauthAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`eap_reauth expected to be basetypes.BoolValue, was: %T`, eapReauthAttribute))
	}

	enableMacAuthAttribute, ok := attributes["enable_mac_auth"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable_mac_auth is missing from object`)

		return nil, diags
	}

	enableMacAuthVal, ok := enableMacAuthAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable_mac_auth expected to be basetypes.BoolValue, was: %T`, enableMacAuthAttribute))
	}

	keyIdxAttribute, ok := attributes["key_idx"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`key_idx is missing from object`)

		return nil, diags
	}

	keyIdxVal, ok := keyIdxAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`key_idx expected to be basetypes.Int64Value, was: %T`, keyIdxAttribute))
	}

	keysAttribute, ok := attributes["keys"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keys is missing from object`)

		return nil, diags
	}

	keysVal, ok := keysAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keys expected to be basetypes.ListValue, was: %T`, keysAttribute))
	}

	multiPskOnlyAttribute, ok := attributes["multi_psk_only"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`multi_psk_only is missing from object`)

		return nil, diags
	}

	multiPskOnlyVal, ok := multiPskOnlyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`multi_psk_only expected to be basetypes.BoolValue, was: %T`, multiPskOnlyAttribute))
	}

	oweAttribute, ok := attributes["owe"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`owe is missing from object`)

		return nil, diags
	}

	oweVal, ok := oweAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`owe expected to be basetypes.StringValue, was: %T`, oweAttribute))
	}

	pairwiseAttribute, ok := attributes["pairwise"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pairwise is missing from object`)

		return nil, diags
	}

	pairwiseVal, ok := pairwiseAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pairwise expected to be basetypes.ListValue, was: %T`, pairwiseAttribute))
	}

	privateWlanAttribute, ok := attributes["private_wlan"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`private_wlan is missing from object`)

		return nil, diags
	}

	privateWlanVal, ok := privateWlanAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`private_wlan expected to be basetypes.BoolValue, was: %T`, privateWlanAttribute))
	}

	pskAttribute, ok := attributes["psk"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`psk is missing from object`)

		return nil, diags
	}

	pskVal, ok := pskAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`psk expected to be basetypes.StringValue, was: %T`, pskAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	wepAsSecondaryAuthAttribute, ok := attributes["wep_as_secondary_auth"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wep_as_secondary_auth is missing from object`)

		return nil, diags
	}

	wepAsSecondaryAuthVal, ok := wepAsSecondaryAuthAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wep_as_secondary_auth expected to be basetypes.BoolValue, was: %T`, wepAsSecondaryAuthAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AuthValue{
		AnticlogThreshold:  anticlogThresholdVal,
		EapReauth:          eapReauthVal,
		EnableMacAuth:      enableMacAuthVal,
		KeyIdx:             keyIdxVal,
		Keys:               keysVal,
		MultiPskOnly:       multiPskOnlyVal,
		Owe:                oweVal,
		Pairwise:           pairwiseVal,
		PrivateWlan:        privateWlanVal,
		Psk:                pskVal,
		AuthType:           typeVal,
		WepAsSecondaryAuth: wepAsSecondaryAuthVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewAuthValueNull() AuthValue {
	return AuthValue{
		state: attr.ValueStateNull,
	}
}

func NewAuthValueUnknown() AuthValue {
	return AuthValue{
		state: attr.ValueStateUnknown,
	}
}

func NewAuthValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AuthValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AuthValue Attribute Value",
				"While creating a AuthValue value, a missing attribute value was detected. "+
					"A AuthValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AuthValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AuthValue Attribute Type",
				"While creating a AuthValue value, an invalid attribute value was detected. "+
					"A AuthValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AuthValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AuthValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AuthValue Attribute Value",
				"While creating a AuthValue value, an extra attribute value was detected. "+
					"A AuthValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AuthValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAuthValueUnknown(), diags
	}

	anticlogThresholdAttribute, ok := attributes["anticlog_threshold"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`anticlog_threshold is missing from object`)

		return NewAuthValueUnknown(), diags
	}

	anticlogThresholdVal, ok := anticlogThresholdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`anticlog_threshold expected to be basetypes.Int64Value, was: %T`, anticlogThresholdAttribute))
	}

	eapReauthAttribute, ok := attributes["eap_reauth"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`eap_reauth is missing from object`)

		return NewAuthValueUnknown(), diags
	}

	eapReauthVal, ok := eapReauthAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`eap_reauth expected to be basetypes.BoolValue, was: %T`, eapReauthAttribute))
	}

	enableMacAuthAttribute, ok := attributes["enable_mac_auth"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable_mac_auth is missing from object`)

		return NewAuthValueUnknown(), diags
	}

	enableMacAuthVal, ok := enableMacAuthAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable_mac_auth expected to be basetypes.BoolValue, was: %T`, enableMacAuthAttribute))
	}

	keyIdxAttribute, ok := attributes["key_idx"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`key_idx is missing from object`)

		return NewAuthValueUnknown(), diags
	}

	keyIdxVal, ok := keyIdxAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`key_idx expected to be basetypes.Int64Value, was: %T`, keyIdxAttribute))
	}

	keysAttribute, ok := attributes["keys"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keys is missing from object`)

		return NewAuthValueUnknown(), diags
	}

	keysVal, ok := keysAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keys expected to be basetypes.ListValue, was: %T`, keysAttribute))
	}

	multiPskOnlyAttribute, ok := attributes["multi_psk_only"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`multi_psk_only is missing from object`)

		return NewAuthValueUnknown(), diags
	}

	multiPskOnlyVal, ok := multiPskOnlyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`multi_psk_only expected to be basetypes.BoolValue, was: %T`, multiPskOnlyAttribute))
	}

	oweAttribute, ok := attributes["owe"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`owe is missing from object`)

		return NewAuthValueUnknown(), diags
	}

	oweVal, ok := oweAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`owe expected to be basetypes.StringValue, was: %T`, oweAttribute))
	}

	pairwiseAttribute, ok := attributes["pairwise"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pairwise is missing from object`)

		return NewAuthValueUnknown(), diags
	}

	pairwiseVal, ok := pairwiseAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pairwise expected to be basetypes.ListValue, was: %T`, pairwiseAttribute))
	}

	privateWlanAttribute, ok := attributes["private_wlan"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`private_wlan is missing from object`)

		return NewAuthValueUnknown(), diags
	}

	privateWlanVal, ok := privateWlanAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`private_wlan expected to be basetypes.BoolValue, was: %T`, privateWlanAttribute))
	}

	pskAttribute, ok := attributes["psk"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`psk is missing from object`)

		return NewAuthValueUnknown(), diags
	}

	pskVal, ok := pskAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`psk expected to be basetypes.StringValue, was: %T`, pskAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewAuthValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	wepAsSecondaryAuthAttribute, ok := attributes["wep_as_secondary_auth"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wep_as_secondary_auth is missing from object`)

		return NewAuthValueUnknown(), diags
	}

	wepAsSecondaryAuthVal, ok := wepAsSecondaryAuthAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wep_as_secondary_auth expected to be basetypes.BoolValue, was: %T`, wepAsSecondaryAuthAttribute))
	}

	if diags.HasError() {
		return NewAuthValueUnknown(), diags
	}

	return AuthValue{
		AnticlogThreshold:  anticlogThresholdVal,
		EapReauth:          eapReauthVal,
		EnableMacAuth:      enableMacAuthVal,
		KeyIdx:             keyIdxVal,
		Keys:               keysVal,
		MultiPskOnly:       multiPskOnlyVal,
		Owe:                oweVal,
		Pairwise:           pairwiseVal,
		PrivateWlan:        privateWlanVal,
		Psk:                pskVal,
		AuthType:           typeVal,
		WepAsSecondaryAuth: wepAsSecondaryAuthVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewAuthValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AuthValue {
	object, diags := NewAuthValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAuthValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AuthType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAuthValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAuthValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAuthValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAuthValueMust(AuthValue{}.AttributeTypes(ctx), attributes), nil
}

func (t AuthType) ValueType(ctx context.Context) attr.Value {
	return AuthValue{}
}

var _ basetypes.ObjectValuable = AuthValue{}

type AuthValue struct {
	AnticlogThreshold  basetypes.Int64Value  `tfsdk:"anticlog_threshold"`
	EapReauth          basetypes.BoolValue   `tfsdk:"eap_reauth"`
	EnableMacAuth      basetypes.BoolValue   `tfsdk:"enable_mac_auth"`
	KeyIdx             basetypes.Int64Value  `tfsdk:"key_idx"`
	Keys               basetypes.ListValue   `tfsdk:"keys"`
	MultiPskOnly       basetypes.BoolValue   `tfsdk:"multi_psk_only"`
	Owe                basetypes.StringValue `tfsdk:"owe"`
	Pairwise           basetypes.ListValue   `tfsdk:"pairwise"`
	PrivateWlan        basetypes.BoolValue   `tfsdk:"private_wlan"`
	Psk                basetypes.StringValue `tfsdk:"psk"`
	AuthType           basetypes.StringValue `tfsdk:"type"`
	WepAsSecondaryAuth basetypes.BoolValue   `tfsdk:"wep_as_secondary_auth"`
	state              attr.ValueState
}

func (v AuthValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 12)

	var val tftypes.Value
	var err error

	attrTypes["anticlog_threshold"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["eap_reauth"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["enable_mac_auth"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["key_idx"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["keys"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["multi_psk_only"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["owe"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["pairwise"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["private_wlan"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["psk"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["wep_as_secondary_auth"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 12)

		val, err = v.AnticlogThreshold.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["anticlog_threshold"] = val

		val, err = v.EapReauth.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["eap_reauth"] = val

		val, err = v.EnableMacAuth.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enable_mac_auth"] = val

		val, err = v.KeyIdx.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["key_idx"] = val

		val, err = v.Keys.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["keys"] = val

		val, err = v.MultiPskOnly.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["multi_psk_only"] = val

		val, err = v.Owe.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["owe"] = val

		val, err = v.Pairwise.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["pairwise"] = val

		val, err = v.PrivateWlan.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["private_wlan"] = val

		val, err = v.Psk.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["psk"] = val

		val, err = v.AuthType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		val, err = v.WepAsSecondaryAuth.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["wep_as_secondary_auth"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AuthValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AuthValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AuthValue) String() string {
	return "AuthValue"
}

func (v AuthValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	keysVal, d := types.ListValue(types.StringType, v.Keys.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"anticlog_threshold": basetypes.Int64Type{},
			"eap_reauth":         basetypes.BoolType{},
			"enable_mac_auth":    basetypes.BoolType{},
			"key_idx":            basetypes.Int64Type{},
			"keys": basetypes.ListType{
				ElemType: types.StringType,
			},
			"multi_psk_only": basetypes.BoolType{},
			"owe":            basetypes.StringType{},
			"pairwise": basetypes.ListType{
				ElemType: types.StringType,
			},
			"private_wlan":          basetypes.BoolType{},
			"psk":                   basetypes.StringType{},
			"type":                  basetypes.StringType{},
			"wep_as_secondary_auth": basetypes.BoolType{},
		}), diags
	}

	pairwiseVal, d := types.ListValue(types.StringType, v.Pairwise.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"anticlog_threshold": basetypes.Int64Type{},
			"eap_reauth":         basetypes.BoolType{},
			"enable_mac_auth":    basetypes.BoolType{},
			"key_idx":            basetypes.Int64Type{},
			"keys": basetypes.ListType{
				ElemType: types.StringType,
			},
			"multi_psk_only": basetypes.BoolType{},
			"owe":            basetypes.StringType{},
			"pairwise": basetypes.ListType{
				ElemType: types.StringType,
			},
			"private_wlan":          basetypes.BoolType{},
			"psk":                   basetypes.StringType{},
			"type":                  basetypes.StringType{},
			"wep_as_secondary_auth": basetypes.BoolType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"anticlog_threshold": basetypes.Int64Type{},
		"eap_reauth":         basetypes.BoolType{},
		"enable_mac_auth":    basetypes.BoolType{},
		"key_idx":            basetypes.Int64Type{},
		"keys": basetypes.ListType{
			ElemType: types.StringType,
		},
		"multi_psk_only": basetypes.BoolType{},
		"owe":            basetypes.StringType{},
		"pairwise": basetypes.ListType{
			ElemType: types.StringType,
		},
		"private_wlan":          basetypes.BoolType{},
		"psk":                   basetypes.StringType{},
		"type":                  basetypes.StringType{},
		"wep_as_secondary_auth": basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"anticlog_threshold":    v.AnticlogThreshold,
			"eap_reauth":            v.EapReauth,
			"enable_mac_auth":       v.EnableMacAuth,
			"key_idx":               v.KeyIdx,
			"keys":                  keysVal,
			"multi_psk_only":        v.MultiPskOnly,
			"owe":                   v.Owe,
			"pairwise":              pairwiseVal,
			"private_wlan":          v.PrivateWlan,
			"psk":                   v.Psk,
			"type":                  v.AuthType,
			"wep_as_secondary_auth": v.WepAsSecondaryAuth,
		})

	return objVal, diags
}

func (v AuthValue) Equal(o attr.Value) bool {
	other, ok := o.(AuthValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AnticlogThreshold.Equal(other.AnticlogThreshold) {
		return false
	}

	if !v.EapReauth.Equal(other.EapReauth) {
		return false
	}

	if !v.EnableMacAuth.Equal(other.EnableMacAuth) {
		return false
	}

	if !v.KeyIdx.Equal(other.KeyIdx) {
		return false
	}

	if !v.Keys.Equal(other.Keys) {
		return false
	}

	if !v.MultiPskOnly.Equal(other.MultiPskOnly) {
		return false
	}

	if !v.Owe.Equal(other.Owe) {
		return false
	}

	if !v.Pairwise.Equal(other.Pairwise) {
		return false
	}

	if !v.PrivateWlan.Equal(other.PrivateWlan) {
		return false
	}

	if !v.Psk.Equal(other.Psk) {
		return false
	}

	if !v.AuthType.Equal(other.AuthType) {
		return false
	}

	if !v.WepAsSecondaryAuth.Equal(other.WepAsSecondaryAuth) {
		return false
	}

	return true
}

func (v AuthValue) Type(ctx context.Context) attr.Type {
	return AuthType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AuthValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"anticlog_threshold": basetypes.Int64Type{},
		"eap_reauth":         basetypes.BoolType{},
		"enable_mac_auth":    basetypes.BoolType{},
		"key_idx":            basetypes.Int64Type{},
		"keys": basetypes.ListType{
			ElemType: types.StringType,
		},
		"multi_psk_only": basetypes.BoolType{},
		"owe":            basetypes.StringType{},
		"pairwise": basetypes.ListType{
			ElemType: types.StringType,
		},
		"private_wlan":          basetypes.BoolType{},
		"psk":                   basetypes.StringType{},
		"type":                  basetypes.StringType{},
		"wep_as_secondary_auth": basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = AuthServersType{}

type AuthServersType struct {
	basetypes.ObjectType
}

func (t AuthServersType) Equal(o attr.Type) bool {
	other, ok := o.(AuthServersType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AuthServersType) String() string {
	return "AuthServersType"
}

func (t AuthServersType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	hostAttribute, ok := attributes["host"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`host is missing from object`)

		return nil, diags
	}

	hostVal, ok := hostAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`host expected to be basetypes.StringValue, was: %T`, hostAttribute))
	}

	keywrapEnabledAttribute, ok := attributes["keywrap_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywrap_enabled is missing from object`)

		return nil, diags
	}

	keywrapEnabledVal, ok := keywrapEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywrap_enabled expected to be basetypes.BoolValue, was: %T`, keywrapEnabledAttribute))
	}

	keywrapFormatAttribute, ok := attributes["keywrap_format"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywrap_format is missing from object`)

		return nil, diags
	}

	keywrapFormatVal, ok := keywrapFormatAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywrap_format expected to be basetypes.StringValue, was: %T`, keywrapFormatAttribute))
	}

	keywrapKekAttribute, ok := attributes["keywrap_kek"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywrap_kek is missing from object`)

		return nil, diags
	}

	keywrapKekVal, ok := keywrapKekAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywrap_kek expected to be basetypes.StringValue, was: %T`, keywrapKekAttribute))
	}

	keywrapMackAttribute, ok := attributes["keywrap_mack"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywrap_mack is missing from object`)

		return nil, diags
	}

	keywrapMackVal, ok := keywrapMackAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywrap_mack expected to be basetypes.StringValue, was: %T`, keywrapMackAttribute))
	}

	portAttribute, ok := attributes["port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port is missing from object`)

		return nil, diags
	}

	portVal, ok := portAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port expected to be basetypes.Int64Value, was: %T`, portAttribute))
	}

	requireMessageAuthenticatorAttribute, ok := attributes["require_message_authenticator"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`require_message_authenticator is missing from object`)

		return nil, diags
	}

	requireMessageAuthenticatorVal, ok := requireMessageAuthenticatorAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`require_message_authenticator expected to be basetypes.BoolValue, was: %T`, requireMessageAuthenticatorAttribute))
	}

	secretAttribute, ok := attributes["secret"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`secret is missing from object`)

		return nil, diags
	}

	secretVal, ok := secretAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`secret expected to be basetypes.StringValue, was: %T`, secretAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AuthServersValue{
		Host:                        hostVal,
		KeywrapEnabled:              keywrapEnabledVal,
		KeywrapFormat:               keywrapFormatVal,
		KeywrapKek:                  keywrapKekVal,
		KeywrapMack:                 keywrapMackVal,
		Port:                        portVal,
		RequireMessageAuthenticator: requireMessageAuthenticatorVal,
		Secret:                      secretVal,
		state:                       attr.ValueStateKnown,
	}, diags
}

func NewAuthServersValueNull() AuthServersValue {
	return AuthServersValue{
		state: attr.ValueStateNull,
	}
}

func NewAuthServersValueUnknown() AuthServersValue {
	return AuthServersValue{
		state: attr.ValueStateUnknown,
	}
}

func NewAuthServersValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AuthServersValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AuthServersValue Attribute Value",
				"While creating a AuthServersValue value, a missing attribute value was detected. "+
					"A AuthServersValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AuthServersValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AuthServersValue Attribute Type",
				"While creating a AuthServersValue value, an invalid attribute value was detected. "+
					"A AuthServersValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AuthServersValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AuthServersValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AuthServersValue Attribute Value",
				"While creating a AuthServersValue value, an extra attribute value was detected. "+
					"A AuthServersValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AuthServersValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAuthServersValueUnknown(), diags
	}

	hostAttribute, ok := attributes["host"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`host is missing from object`)

		return NewAuthServersValueUnknown(), diags
	}

	hostVal, ok := hostAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`host expected to be basetypes.StringValue, was: %T`, hostAttribute))
	}

	keywrapEnabledAttribute, ok := attributes["keywrap_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywrap_enabled is missing from object`)

		return NewAuthServersValueUnknown(), diags
	}

	keywrapEnabledVal, ok := keywrapEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywrap_enabled expected to be basetypes.BoolValue, was: %T`, keywrapEnabledAttribute))
	}

	keywrapFormatAttribute, ok := attributes["keywrap_format"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywrap_format is missing from object`)

		return NewAuthServersValueUnknown(), diags
	}

	keywrapFormatVal, ok := keywrapFormatAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywrap_format expected to be basetypes.StringValue, was: %T`, keywrapFormatAttribute))
	}

	keywrapKekAttribute, ok := attributes["keywrap_kek"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywrap_kek is missing from object`)

		return NewAuthServersValueUnknown(), diags
	}

	keywrapKekVal, ok := keywrapKekAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywrap_kek expected to be basetypes.StringValue, was: %T`, keywrapKekAttribute))
	}

	keywrapMackAttribute, ok := attributes["keywrap_mack"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywrap_mack is missing from object`)

		return NewAuthServersValueUnknown(), diags
	}

	keywrapMackVal, ok := keywrapMackAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywrap_mack expected to be basetypes.StringValue, was: %T`, keywrapMackAttribute))
	}

	portAttribute, ok := attributes["port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port is missing from object`)

		return NewAuthServersValueUnknown(), diags
	}

	portVal, ok := portAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port expected to be basetypes.Int64Value, was: %T`, portAttribute))
	}

	requireMessageAuthenticatorAttribute, ok := attributes["require_message_authenticator"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`require_message_authenticator is missing from object`)

		return NewAuthServersValueUnknown(), diags
	}

	requireMessageAuthenticatorVal, ok := requireMessageAuthenticatorAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`require_message_authenticator expected to be basetypes.BoolValue, was: %T`, requireMessageAuthenticatorAttribute))
	}

	secretAttribute, ok := attributes["secret"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`secret is missing from object`)

		return NewAuthServersValueUnknown(), diags
	}

	secretVal, ok := secretAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`secret expected to be basetypes.StringValue, was: %T`, secretAttribute))
	}

	if diags.HasError() {
		return NewAuthServersValueUnknown(), diags
	}

	return AuthServersValue{
		Host:                        hostVal,
		KeywrapEnabled:              keywrapEnabledVal,
		KeywrapFormat:               keywrapFormatVal,
		KeywrapKek:                  keywrapKekVal,
		KeywrapMack:                 keywrapMackVal,
		Port:                        portVal,
		RequireMessageAuthenticator: requireMessageAuthenticatorVal,
		Secret:                      secretVal,
		state:                       attr.ValueStateKnown,
	}, diags
}

func NewAuthServersValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AuthServersValue {
	object, diags := NewAuthServersValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAuthServersValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AuthServersType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAuthServersValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAuthServersValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAuthServersValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAuthServersValueMust(AuthServersValue{}.AttributeTypes(ctx), attributes), nil
}

func (t AuthServersType) ValueType(ctx context.Context) attr.Value {
	return AuthServersValue{}
}

var _ basetypes.ObjectValuable = AuthServersValue{}

type AuthServersValue struct {
	Host                        basetypes.StringValue `tfsdk:"host"`
	KeywrapEnabled              basetypes.BoolValue   `tfsdk:"keywrap_enabled"`
	KeywrapFormat               basetypes.StringValue `tfsdk:"keywrap_format"`
	KeywrapKek                  basetypes.StringValue `tfsdk:"keywrap_kek"`
	KeywrapMack                 basetypes.StringValue `tfsdk:"keywrap_mack"`
	Port                        basetypes.Int64Value  `tfsdk:"port"`
	RequireMessageAuthenticator basetypes.BoolValue   `tfsdk:"require_message_authenticator"`
	Secret                      basetypes.StringValue `tfsdk:"secret"`
	state                       attr.ValueState
}

func (v AuthServersValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 8)

	var val tftypes.Value
	var err error

	attrTypes["host"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["keywrap_enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["keywrap_format"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["keywrap_kek"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["keywrap_mack"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["port"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["require_message_authenticator"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["secret"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 8)

		val, err = v.Host.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["host"] = val

		val, err = v.KeywrapEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["keywrap_enabled"] = val

		val, err = v.KeywrapFormat.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["keywrap_format"] = val

		val, err = v.KeywrapKek.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["keywrap_kek"] = val

		val, err = v.KeywrapMack.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["keywrap_mack"] = val

		val, err = v.Port.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port"] = val

		val, err = v.RequireMessageAuthenticator.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["require_message_authenticator"] = val

		val, err = v.Secret.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["secret"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AuthServersValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AuthServersValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AuthServersValue) String() string {
	return "AuthServersValue"
}

func (v AuthServersValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"host":                          basetypes.StringType{},
		"keywrap_enabled":               basetypes.BoolType{},
		"keywrap_format":                basetypes.StringType{},
		"keywrap_kek":                   basetypes.StringType{},
		"keywrap_mack":                  basetypes.StringType{},
		"port":                          basetypes.Int64Type{},
		"require_message_authenticator": basetypes.BoolType{},
		"secret":                        basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"host":                          v.Host,
			"keywrap_enabled":               v.KeywrapEnabled,
			"keywrap_format":                v.KeywrapFormat,
			"keywrap_kek":                   v.KeywrapKek,
			"keywrap_mack":                  v.KeywrapMack,
			"port":                          v.Port,
			"require_message_authenticator": v.RequireMessageAuthenticator,
			"secret":                        v.Secret,
		})

	return objVal, diags
}

func (v AuthServersValue) Equal(o attr.Value) bool {
	other, ok := o.(AuthServersValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Host.Equal(other.Host) {
		return false
	}

	if !v.KeywrapEnabled.Equal(other.KeywrapEnabled) {
		return false
	}

	if !v.KeywrapFormat.Equal(other.KeywrapFormat) {
		return false
	}

	if !v.KeywrapKek.Equal(other.KeywrapKek) {
		return false
	}

	if !v.KeywrapMack.Equal(other.KeywrapMack) {
		return false
	}

	if !v.Port.Equal(other.Port) {
		return false
	}

	if !v.RequireMessageAuthenticator.Equal(other.RequireMessageAuthenticator) {
		return false
	}

	if !v.Secret.Equal(other.Secret) {
		return false
	}

	return true
}

func (v AuthServersValue) Type(ctx context.Context) attr.Type {
	return AuthServersType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AuthServersValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"host":                          basetypes.StringType{},
		"keywrap_enabled":               basetypes.BoolType{},
		"keywrap_format":                basetypes.StringType{},
		"keywrap_kek":                   basetypes.StringType{},
		"keywrap_mack":                  basetypes.StringType{},
		"port":                          basetypes.Int64Type{},
		"require_message_authenticator": basetypes.BoolType{},
		"secret":                        basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = BonjourType{}

type BonjourType struct {
	basetypes.ObjectType
}

func (t BonjourType) Equal(o attr.Type) bool {
	other, ok := o.(BonjourType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t BonjourType) String() string {
	return "BonjourType"
}

func (t BonjourType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	additionalVlanIdsAttribute, ok := attributes["additional_vlan_ids"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`additional_vlan_ids is missing from object`)

		return nil, diags
	}

	additionalVlanIdsVal, ok := additionalVlanIdsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`additional_vlan_ids expected to be basetypes.ListValue, was: %T`, additionalVlanIdsAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	servicesAttribute, ok := attributes["services"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`services is missing from object`)

		return nil, diags
	}

	servicesVal, ok := servicesAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`services expected to be basetypes.MapValue, was: %T`, servicesAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return BonjourValue{
		AdditionalVlanIds: additionalVlanIdsVal,
		Enabled:           enabledVal,
		Services:          servicesVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewBonjourValueNull() BonjourValue {
	return BonjourValue{
		state: attr.ValueStateNull,
	}
}

func NewBonjourValueUnknown() BonjourValue {
	return BonjourValue{
		state: attr.ValueStateUnknown,
	}
}

func NewBonjourValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (BonjourValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing BonjourValue Attribute Value",
				"While creating a BonjourValue value, a missing attribute value was detected. "+
					"A BonjourValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("BonjourValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid BonjourValue Attribute Type",
				"While creating a BonjourValue value, an invalid attribute value was detected. "+
					"A BonjourValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("BonjourValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("BonjourValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra BonjourValue Attribute Value",
				"While creating a BonjourValue value, an extra attribute value was detected. "+
					"A BonjourValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra BonjourValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewBonjourValueUnknown(), diags
	}

	additionalVlanIdsAttribute, ok := attributes["additional_vlan_ids"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`additional_vlan_ids is missing from object`)

		return NewBonjourValueUnknown(), diags
	}

	additionalVlanIdsVal, ok := additionalVlanIdsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`additional_vlan_ids expected to be basetypes.ListValue, was: %T`, additionalVlanIdsAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewBonjourValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	servicesAttribute, ok := attributes["services"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`services is missing from object`)

		return NewBonjourValueUnknown(), diags
	}

	servicesVal, ok := servicesAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`services expected to be basetypes.MapValue, was: %T`, servicesAttribute))
	}

	if diags.HasError() {
		return NewBonjourValueUnknown(), diags
	}

	return BonjourValue{
		AdditionalVlanIds: additionalVlanIdsVal,
		Enabled:           enabledVal,
		Services:          servicesVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewBonjourValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) BonjourValue {
	object, diags := NewBonjourValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewBonjourValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t BonjourType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewBonjourValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewBonjourValueUnknown(), nil
	}

	if in.IsNull() {
		return NewBonjourValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewBonjourValueMust(BonjourValue{}.AttributeTypes(ctx), attributes), nil
}

func (t BonjourType) ValueType(ctx context.Context) attr.Value {
	return BonjourValue{}
}

var _ basetypes.ObjectValuable = BonjourValue{}

type BonjourValue struct {
	AdditionalVlanIds basetypes.ListValue `tfsdk:"additional_vlan_ids"`
	Enabled           basetypes.BoolValue `tfsdk:"enabled"`
	Services          basetypes.MapValue  `tfsdk:"services"`
	state             attr.ValueState
}

func (v BonjourValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["additional_vlan_ids"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["services"] = basetypes.MapType{
		ElemType: ServicesValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.AdditionalVlanIds.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["additional_vlan_ids"] = val

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.Services.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["services"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v BonjourValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v BonjourValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v BonjourValue) String() string {
	return "BonjourValue"
}

func (v BonjourValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	services := types.MapValueMust(
		ServicesType{
			basetypes.ObjectType{
				AttrTypes: ServicesValue{}.AttributeTypes(ctx),
			},
		},
		v.Services.Elements(),
	)

	if v.Services.IsNull() {
		services = types.MapNull(
			ServicesType{
				basetypes.ObjectType{
					AttrTypes: ServicesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Services.IsUnknown() {
		services = types.MapUnknown(
			ServicesType{
				basetypes.ObjectType{
					AttrTypes: ServicesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	additionalVlanIdsVal, d := types.ListValue(types.StringType, v.AdditionalVlanIds.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"additional_vlan_ids": basetypes.ListType{
				ElemType: types.StringType,
			},
			"enabled": basetypes.BoolType{},
			"services": basetypes.MapType{
				ElemType: ServicesValue{}.Type(ctx),
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"additional_vlan_ids": basetypes.ListType{
			ElemType: types.StringType,
		},
		"enabled": basetypes.BoolType{},
		"services": basetypes.MapType{
			ElemType: ServicesValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"additional_vlan_ids": additionalVlanIdsVal,
			"enabled":             v.Enabled,
			"services":            services,
		})

	return objVal, diags
}

func (v BonjourValue) Equal(o attr.Value) bool {
	other, ok := o.(BonjourValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AdditionalVlanIds.Equal(other.AdditionalVlanIds) {
		return false
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.Services.Equal(other.Services) {
		return false
	}

	return true
}

func (v BonjourValue) Type(ctx context.Context) attr.Type {
	return BonjourType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v BonjourValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"additional_vlan_ids": basetypes.ListType{
			ElemType: types.StringType,
		},
		"enabled": basetypes.BoolType{},
		"services": basetypes.MapType{
			ElemType: ServicesValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = ServicesType{}

type ServicesType struct {
	basetypes.ObjectType
}

func (t ServicesType) Equal(o attr.Type) bool {
	other, ok := o.(ServicesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ServicesType) String() string {
	return "ServicesType"
}

func (t ServicesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	disableLocalAttribute, ok := attributes["disable_local"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disable_local is missing from object`)

		return nil, diags
	}

	disableLocalVal, ok := disableLocalAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disable_local expected to be basetypes.BoolValue, was: %T`, disableLocalAttribute))
	}

	radiusGroupsAttribute, ok := attributes["radius_groups"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`radius_groups is missing from object`)

		return nil, diags
	}

	radiusGroupsVal, ok := radiusGroupsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`radius_groups expected to be basetypes.ListValue, was: %T`, radiusGroupsAttribute))
	}

	scopeAttribute, ok := attributes["scope"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`scope is missing from object`)

		return nil, diags
	}

	scopeVal, ok := scopeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`scope expected to be basetypes.StringValue, was: %T`, scopeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ServicesValue{
		DisableLocal: disableLocalVal,
		RadiusGroups: radiusGroupsVal,
		Scope:        scopeVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewServicesValueNull() ServicesValue {
	return ServicesValue{
		state: attr.ValueStateNull,
	}
}

func NewServicesValueUnknown() ServicesValue {
	return ServicesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewServicesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ServicesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ServicesValue Attribute Value",
				"While creating a ServicesValue value, a missing attribute value was detected. "+
					"A ServicesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ServicesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ServicesValue Attribute Type",
				"While creating a ServicesValue value, an invalid attribute value was detected. "+
					"A ServicesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ServicesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ServicesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ServicesValue Attribute Value",
				"While creating a ServicesValue value, an extra attribute value was detected. "+
					"A ServicesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ServicesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewServicesValueUnknown(), diags
	}

	disableLocalAttribute, ok := attributes["disable_local"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disable_local is missing from object`)

		return NewServicesValueUnknown(), diags
	}

	disableLocalVal, ok := disableLocalAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disable_local expected to be basetypes.BoolValue, was: %T`, disableLocalAttribute))
	}

	radiusGroupsAttribute, ok := attributes["radius_groups"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`radius_groups is missing from object`)

		return NewServicesValueUnknown(), diags
	}

	radiusGroupsVal, ok := radiusGroupsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`radius_groups expected to be basetypes.ListValue, was: %T`, radiusGroupsAttribute))
	}

	scopeAttribute, ok := attributes["scope"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`scope is missing from object`)

		return NewServicesValueUnknown(), diags
	}

	scopeVal, ok := scopeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`scope expected to be basetypes.StringValue, was: %T`, scopeAttribute))
	}

	if diags.HasError() {
		return NewServicesValueUnknown(), diags
	}

	return ServicesValue{
		DisableLocal: disableLocalVal,
		RadiusGroups: radiusGroupsVal,
		Scope:        scopeVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewServicesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ServicesValue {
	object, diags := NewServicesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewServicesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ServicesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewServicesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewServicesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewServicesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewServicesValueMust(ServicesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ServicesType) ValueType(ctx context.Context) attr.Value {
	return ServicesValue{}
}

var _ basetypes.ObjectValuable = ServicesValue{}

type ServicesValue struct {
	DisableLocal basetypes.BoolValue   `tfsdk:"disable_local"`
	RadiusGroups basetypes.ListValue   `tfsdk:"radius_groups"`
	Scope        basetypes.StringValue `tfsdk:"scope"`
	state        attr.ValueState
}

func (v ServicesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["disable_local"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["radius_groups"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["scope"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.DisableLocal.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["disable_local"] = val

		val, err = v.RadiusGroups.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["radius_groups"] = val

		val, err = v.Scope.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["scope"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ServicesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ServicesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ServicesValue) String() string {
	return "ServicesValue"
}

func (v ServicesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	radiusGroupsVal, d := types.ListValue(types.StringType, v.RadiusGroups.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"disable_local": basetypes.BoolType{},
			"radius_groups": basetypes.ListType{
				ElemType: types.StringType,
			},
			"scope": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"disable_local": basetypes.BoolType{},
		"radius_groups": basetypes.ListType{
			ElemType: types.StringType,
		},
		"scope": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"disable_local": v.DisableLocal,
			"radius_groups": radiusGroupsVal,
			"scope":         v.Scope,
		})

	return objVal, diags
}

func (v ServicesValue) Equal(o attr.Value) bool {
	other, ok := o.(ServicesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.DisableLocal.Equal(other.DisableLocal) {
		return false
	}

	if !v.RadiusGroups.Equal(other.RadiusGroups) {
		return false
	}

	if !v.Scope.Equal(other.Scope) {
		return false
	}

	return true
}

func (v ServicesValue) Type(ctx context.Context) attr.Type {
	return ServicesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ServicesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"disable_local": basetypes.BoolType{},
		"radius_groups": basetypes.ListType{
			ElemType: types.StringType,
		},
		"scope": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = CiscoCwaType{}

type CiscoCwaType struct {
	basetypes.ObjectType
}

func (t CiscoCwaType) Equal(o attr.Type) bool {
	other, ok := o.(CiscoCwaType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t CiscoCwaType) String() string {
	return "CiscoCwaType"
}

func (t CiscoCwaType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	allowedHostnamesAttribute, ok := attributes["allowed_hostnames"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allowed_hostnames is missing from object`)

		return nil, diags
	}

	allowedHostnamesVal, ok := allowedHostnamesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allowed_hostnames expected to be basetypes.ListValue, was: %T`, allowedHostnamesAttribute))
	}

	allowedSubnetsAttribute, ok := attributes["allowed_subnets"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allowed_subnets is missing from object`)

		return nil, diags
	}

	allowedSubnetsVal, ok := allowedSubnetsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allowed_subnets expected to be basetypes.ListValue, was: %T`, allowedSubnetsAttribute))
	}

	blockedSubnetsAttribute, ok := attributes["blocked_subnets"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`blocked_subnets is missing from object`)

		return nil, diags
	}

	blockedSubnetsVal, ok := blockedSubnetsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`blocked_subnets expected to be basetypes.ListValue, was: %T`, blockedSubnetsAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return CiscoCwaValue{
		AllowedHostnames: allowedHostnamesVal,
		AllowedSubnets:   allowedSubnetsVal,
		BlockedSubnets:   blockedSubnetsVal,
		Enabled:          enabledVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewCiscoCwaValueNull() CiscoCwaValue {
	return CiscoCwaValue{
		state: attr.ValueStateNull,
	}
}

func NewCiscoCwaValueUnknown() CiscoCwaValue {
	return CiscoCwaValue{
		state: attr.ValueStateUnknown,
	}
}

func NewCiscoCwaValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (CiscoCwaValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing CiscoCwaValue Attribute Value",
				"While creating a CiscoCwaValue value, a missing attribute value was detected. "+
					"A CiscoCwaValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CiscoCwaValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid CiscoCwaValue Attribute Type",
				"While creating a CiscoCwaValue value, an invalid attribute value was detected. "+
					"A CiscoCwaValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CiscoCwaValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("CiscoCwaValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra CiscoCwaValue Attribute Value",
				"While creating a CiscoCwaValue value, an extra attribute value was detected. "+
					"A CiscoCwaValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra CiscoCwaValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewCiscoCwaValueUnknown(), diags
	}

	allowedHostnamesAttribute, ok := attributes["allowed_hostnames"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allowed_hostnames is missing from object`)

		return NewCiscoCwaValueUnknown(), diags
	}

	allowedHostnamesVal, ok := allowedHostnamesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allowed_hostnames expected to be basetypes.ListValue, was: %T`, allowedHostnamesAttribute))
	}

	allowedSubnetsAttribute, ok := attributes["allowed_subnets"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allowed_subnets is missing from object`)

		return NewCiscoCwaValueUnknown(), diags
	}

	allowedSubnetsVal, ok := allowedSubnetsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allowed_subnets expected to be basetypes.ListValue, was: %T`, allowedSubnetsAttribute))
	}

	blockedSubnetsAttribute, ok := attributes["blocked_subnets"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`blocked_subnets is missing from object`)

		return NewCiscoCwaValueUnknown(), diags
	}

	blockedSubnetsVal, ok := blockedSubnetsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`blocked_subnets expected to be basetypes.ListValue, was: %T`, blockedSubnetsAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewCiscoCwaValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	if diags.HasError() {
		return NewCiscoCwaValueUnknown(), diags
	}

	return CiscoCwaValue{
		AllowedHostnames: allowedHostnamesVal,
		AllowedSubnets:   allowedSubnetsVal,
		BlockedSubnets:   blockedSubnetsVal,
		Enabled:          enabledVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewCiscoCwaValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) CiscoCwaValue {
	object, diags := NewCiscoCwaValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewCiscoCwaValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t CiscoCwaType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewCiscoCwaValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewCiscoCwaValueUnknown(), nil
	}

	if in.IsNull() {
		return NewCiscoCwaValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewCiscoCwaValueMust(CiscoCwaValue{}.AttributeTypes(ctx), attributes), nil
}

func (t CiscoCwaType) ValueType(ctx context.Context) attr.Value {
	return CiscoCwaValue{}
}

var _ basetypes.ObjectValuable = CiscoCwaValue{}

type CiscoCwaValue struct {
	AllowedHostnames basetypes.ListValue `tfsdk:"allowed_hostnames"`
	AllowedSubnets   basetypes.ListValue `tfsdk:"allowed_subnets"`
	BlockedSubnets   basetypes.ListValue `tfsdk:"blocked_subnets"`
	Enabled          basetypes.BoolValue `tfsdk:"enabled"`
	state            attr.ValueState
}

func (v CiscoCwaValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["allowed_hostnames"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["allowed_subnets"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["blocked_subnets"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.AllowedHostnames.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["allowed_hostnames"] = val

		val, err = v.AllowedSubnets.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["allowed_subnets"] = val

		val, err = v.BlockedSubnets.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["blocked_subnets"] = val

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v CiscoCwaValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v CiscoCwaValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v CiscoCwaValue) String() string {
	return "CiscoCwaValue"
}

func (v CiscoCwaValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	allowedHostnamesVal, d := types.ListValue(types.StringType, v.AllowedHostnames.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"allowed_hostnames": basetypes.ListType{
				ElemType: types.StringType,
			},
			"allowed_subnets": basetypes.ListType{
				ElemType: types.StringType,
			},
			"blocked_subnets": basetypes.ListType{
				ElemType: types.StringType,
			},
			"enabled": basetypes.BoolType{},
		}), diags
	}

	allowedSubnetsVal, d := types.ListValue(types.StringType, v.AllowedSubnets.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"allowed_hostnames": basetypes.ListType{
				ElemType: types.StringType,
			},
			"allowed_subnets": basetypes.ListType{
				ElemType: types.StringType,
			},
			"blocked_subnets": basetypes.ListType{
				ElemType: types.StringType,
			},
			"enabled": basetypes.BoolType{},
		}), diags
	}

	blockedSubnetsVal, d := types.ListValue(types.StringType, v.BlockedSubnets.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"allowed_hostnames": basetypes.ListType{
				ElemType: types.StringType,
			},
			"allowed_subnets": basetypes.ListType{
				ElemType: types.StringType,
			},
			"blocked_subnets": basetypes.ListType{
				ElemType: types.StringType,
			},
			"enabled": basetypes.BoolType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"allowed_hostnames": basetypes.ListType{
			ElemType: types.StringType,
		},
		"allowed_subnets": basetypes.ListType{
			ElemType: types.StringType,
		},
		"blocked_subnets": basetypes.ListType{
			ElemType: types.StringType,
		},
		"enabled": basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"allowed_hostnames": allowedHostnamesVal,
			"allowed_subnets":   allowedSubnetsVal,
			"blocked_subnets":   blockedSubnetsVal,
			"enabled":           v.Enabled,
		})

	return objVal, diags
}

func (v CiscoCwaValue) Equal(o attr.Value) bool {
	other, ok := o.(CiscoCwaValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AllowedHostnames.Equal(other.AllowedHostnames) {
		return false
	}

	if !v.AllowedSubnets.Equal(other.AllowedSubnets) {
		return false
	}

	if !v.BlockedSubnets.Equal(other.BlockedSubnets) {
		return false
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	return true
}

func (v CiscoCwaValue) Type(ctx context.Context) attr.Type {
	return CiscoCwaType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v CiscoCwaValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"allowed_hostnames": basetypes.ListType{
			ElemType: types.StringType,
		},
		"allowed_subnets": basetypes.ListType{
			ElemType: types.StringType,
		},
		"blocked_subnets": basetypes.ListType{
			ElemType: types.StringType,
		},
		"enabled": basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = CoaServersType{}

type CoaServersType struct {
	basetypes.ObjectType
}

func (t CoaServersType) Equal(o attr.Type) bool {
	other, ok := o.(CoaServersType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t CoaServersType) String() string {
	return "CoaServersType"
}

func (t CoaServersType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	disableEventTimestampCheckAttribute, ok := attributes["disable_event_timestamp_check"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disable_event_timestamp_check is missing from object`)

		return nil, diags
	}

	disableEventTimestampCheckVal, ok := disableEventTimestampCheckAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disable_event_timestamp_check expected to be basetypes.BoolValue, was: %T`, disableEventTimestampCheckAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	ipAttribute, ok := attributes["ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip is missing from object`)

		return nil, diags
	}

	ipVal, ok := ipAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip expected to be basetypes.StringValue, was: %T`, ipAttribute))
	}

	portAttribute, ok := attributes["port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port is missing from object`)

		return nil, diags
	}

	portVal, ok := portAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port expected to be basetypes.Int64Value, was: %T`, portAttribute))
	}

	secretAttribute, ok := attributes["secret"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`secret is missing from object`)

		return nil, diags
	}

	secretVal, ok := secretAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`secret expected to be basetypes.StringValue, was: %T`, secretAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return CoaServersValue{
		DisableEventTimestampCheck: disableEventTimestampCheckVal,
		Enabled:                    enabledVal,
		Ip:                         ipVal,
		Port:                       portVal,
		Secret:                     secretVal,
		state:                      attr.ValueStateKnown,
	}, diags
}

func NewCoaServersValueNull() CoaServersValue {
	return CoaServersValue{
		state: attr.ValueStateNull,
	}
}

func NewCoaServersValueUnknown() CoaServersValue {
	return CoaServersValue{
		state: attr.ValueStateUnknown,
	}
}

func NewCoaServersValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (CoaServersValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing CoaServersValue Attribute Value",
				"While creating a CoaServersValue value, a missing attribute value was detected. "+
					"A CoaServersValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CoaServersValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid CoaServersValue Attribute Type",
				"While creating a CoaServersValue value, an invalid attribute value was detected. "+
					"A CoaServersValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CoaServersValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("CoaServersValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra CoaServersValue Attribute Value",
				"While creating a CoaServersValue value, an extra attribute value was detected. "+
					"A CoaServersValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra CoaServersValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewCoaServersValueUnknown(), diags
	}

	disableEventTimestampCheckAttribute, ok := attributes["disable_event_timestamp_check"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disable_event_timestamp_check is missing from object`)

		return NewCoaServersValueUnknown(), diags
	}

	disableEventTimestampCheckVal, ok := disableEventTimestampCheckAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disable_event_timestamp_check expected to be basetypes.BoolValue, was: %T`, disableEventTimestampCheckAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewCoaServersValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	ipAttribute, ok := attributes["ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip is missing from object`)

		return NewCoaServersValueUnknown(), diags
	}

	ipVal, ok := ipAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip expected to be basetypes.StringValue, was: %T`, ipAttribute))
	}

	portAttribute, ok := attributes["port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port is missing from object`)

		return NewCoaServersValueUnknown(), diags
	}

	portVal, ok := portAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port expected to be basetypes.Int64Value, was: %T`, portAttribute))
	}

	secretAttribute, ok := attributes["secret"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`secret is missing from object`)

		return NewCoaServersValueUnknown(), diags
	}

	secretVal, ok := secretAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`secret expected to be basetypes.StringValue, was: %T`, secretAttribute))
	}

	if diags.HasError() {
		return NewCoaServersValueUnknown(), diags
	}

	return CoaServersValue{
		DisableEventTimestampCheck: disableEventTimestampCheckVal,
		Enabled:                    enabledVal,
		Ip:                         ipVal,
		Port:                       portVal,
		Secret:                     secretVal,
		state:                      attr.ValueStateKnown,
	}, diags
}

func NewCoaServersValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) CoaServersValue {
	object, diags := NewCoaServersValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewCoaServersValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t CoaServersType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewCoaServersValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewCoaServersValueUnknown(), nil
	}

	if in.IsNull() {
		return NewCoaServersValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewCoaServersValueMust(CoaServersValue{}.AttributeTypes(ctx), attributes), nil
}

func (t CoaServersType) ValueType(ctx context.Context) attr.Value {
	return CoaServersValue{}
}

var _ basetypes.ObjectValuable = CoaServersValue{}

type CoaServersValue struct {
	DisableEventTimestampCheck basetypes.BoolValue   `tfsdk:"disable_event_timestamp_check"`
	Enabled                    basetypes.BoolValue   `tfsdk:"enabled"`
	Ip                         basetypes.StringValue `tfsdk:"ip"`
	Port                       basetypes.Int64Value  `tfsdk:"port"`
	Secret                     basetypes.StringValue `tfsdk:"secret"`
	state                      attr.ValueState
}

func (v CoaServersValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["disable_event_timestamp_check"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["ip"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["port"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["secret"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.DisableEventTimestampCheck.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["disable_event_timestamp_check"] = val

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.Ip.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip"] = val

		val, err = v.Port.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port"] = val

		val, err = v.Secret.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["secret"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v CoaServersValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v CoaServersValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v CoaServersValue) String() string {
	return "CoaServersValue"
}

func (v CoaServersValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"disable_event_timestamp_check": basetypes.BoolType{},
		"enabled":                       basetypes.BoolType{},
		"ip":                            basetypes.StringType{},
		"port":                          basetypes.Int64Type{},
		"secret":                        basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"disable_event_timestamp_check": v.DisableEventTimestampCheck,
			"enabled":                       v.Enabled,
			"ip":                            v.Ip,
			"port":                          v.Port,
			"secret":                        v.Secret,
		})

	return objVal, diags
}

func (v CoaServersValue) Equal(o attr.Value) bool {
	other, ok := o.(CoaServersValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.DisableEventTimestampCheck.Equal(other.DisableEventTimestampCheck) {
		return false
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.Ip.Equal(other.Ip) {
		return false
	}

	if !v.Port.Equal(other.Port) {
		return false
	}

	if !v.Secret.Equal(other.Secret) {
		return false
	}

	return true
}

func (v CoaServersValue) Type(ctx context.Context) attr.Type {
	return CoaServersType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v CoaServersValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"disable_event_timestamp_check": basetypes.BoolType{},
		"enabled":                       basetypes.BoolType{},
		"ip":                            basetypes.StringType{},
		"port":                          basetypes.Int64Type{},
		"secret":                        basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = DnsServerRewriteType{}

type DnsServerRewriteType struct {
	basetypes.ObjectType
}

func (t DnsServerRewriteType) Equal(o attr.Type) bool {
	other, ok := o.(DnsServerRewriteType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t DnsServerRewriteType) String() string {
	return "DnsServerRewriteType"
}

func (t DnsServerRewriteType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	radiusGroupsAttribute, ok := attributes["radius_groups"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`radius_groups is missing from object`)

		return nil, diags
	}

	radiusGroupsVal, ok := radiusGroupsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`radius_groups expected to be basetypes.MapValue, was: %T`, radiusGroupsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return DnsServerRewriteValue{
		Enabled:      enabledVal,
		RadiusGroups: radiusGroupsVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewDnsServerRewriteValueNull() DnsServerRewriteValue {
	return DnsServerRewriteValue{
		state: attr.ValueStateNull,
	}
}

func NewDnsServerRewriteValueUnknown() DnsServerRewriteValue {
	return DnsServerRewriteValue{
		state: attr.ValueStateUnknown,
	}
}

func NewDnsServerRewriteValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (DnsServerRewriteValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing DnsServerRewriteValue Attribute Value",
				"While creating a DnsServerRewriteValue value, a missing attribute value was detected. "+
					"A DnsServerRewriteValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DnsServerRewriteValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid DnsServerRewriteValue Attribute Type",
				"While creating a DnsServerRewriteValue value, an invalid attribute value was detected. "+
					"A DnsServerRewriteValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DnsServerRewriteValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("DnsServerRewriteValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra DnsServerRewriteValue Attribute Value",
				"While creating a DnsServerRewriteValue value, an extra attribute value was detected. "+
					"A DnsServerRewriteValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra DnsServerRewriteValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewDnsServerRewriteValueUnknown(), diags
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewDnsServerRewriteValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	radiusGroupsAttribute, ok := attributes["radius_groups"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`radius_groups is missing from object`)

		return NewDnsServerRewriteValueUnknown(), diags
	}

	radiusGroupsVal, ok := radiusGroupsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`radius_groups expected to be basetypes.MapValue, was: %T`, radiusGroupsAttribute))
	}

	if diags.HasError() {
		return NewDnsServerRewriteValueUnknown(), diags
	}

	return DnsServerRewriteValue{
		Enabled:      enabledVal,
		RadiusGroups: radiusGroupsVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewDnsServerRewriteValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) DnsServerRewriteValue {
	object, diags := NewDnsServerRewriteValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewDnsServerRewriteValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t DnsServerRewriteType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewDnsServerRewriteValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewDnsServerRewriteValueUnknown(), nil
	}

	if in.IsNull() {
		return NewDnsServerRewriteValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewDnsServerRewriteValueMust(DnsServerRewriteValue{}.AttributeTypes(ctx), attributes), nil
}

func (t DnsServerRewriteType) ValueType(ctx context.Context) attr.Value {
	return DnsServerRewriteValue{}
}

var _ basetypes.ObjectValuable = DnsServerRewriteValue{}

type DnsServerRewriteValue struct {
	Enabled      basetypes.BoolValue `tfsdk:"enabled"`
	RadiusGroups basetypes.MapValue  `tfsdk:"radius_groups"`
	state        attr.ValueState
}

func (v DnsServerRewriteValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["radius_groups"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.RadiusGroups.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["radius_groups"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v DnsServerRewriteValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v DnsServerRewriteValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v DnsServerRewriteValue) String() string {
	return "DnsServerRewriteValue"
}

func (v DnsServerRewriteValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	radiusGroupsVal, d := types.MapValue(types.StringType, v.RadiusGroups.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"enabled": basetypes.BoolType{},
			"radius_groups": basetypes.MapType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"enabled": basetypes.BoolType{},
		"radius_groups": basetypes.MapType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"enabled":       v.Enabled,
			"radius_groups": radiusGroupsVal,
		})

	return objVal, diags
}

func (v DnsServerRewriteValue) Equal(o attr.Value) bool {
	other, ok := o.(DnsServerRewriteValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.RadiusGroups.Equal(other.RadiusGroups) {
		return false
	}

	return true
}

func (v DnsServerRewriteValue) Type(ctx context.Context) attr.Type {
	return DnsServerRewriteType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v DnsServerRewriteValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"enabled": basetypes.BoolType{},
		"radius_groups": basetypes.MapType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = DynamicPskType{}

type DynamicPskType struct {
	basetypes.ObjectType
}

func (t DynamicPskType) Equal(o attr.Type) bool {
	other, ok := o.(DynamicPskType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t DynamicPskType) String() string {
	return "DynamicPskType"
}

func (t DynamicPskType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	defaultPskAttribute, ok := attributes["default_psk"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`default_psk is missing from object`)

		return nil, diags
	}

	defaultPskVal, ok := defaultPskAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`default_psk expected to be basetypes.StringValue, was: %T`, defaultPskAttribute))
	}

	defaultVlanIdAttribute, ok := attributes["default_vlan_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`default_vlan_id is missing from object`)

		return nil, diags
	}

	defaultVlanIdVal, ok := defaultVlanIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`default_vlan_id expected to be basetypes.StringValue, was: %T`, defaultVlanIdAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	forceLookupAttribute, ok := attributes["force_lookup"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`force_lookup is missing from object`)

		return nil, diags
	}

	forceLookupVal, ok := forceLookupAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`force_lookup expected to be basetypes.BoolValue, was: %T`, forceLookupAttribute))
	}

	sourceAttribute, ok := attributes["source"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`source is missing from object`)

		return nil, diags
	}

	sourceVal, ok := sourceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`source expected to be basetypes.StringValue, was: %T`, sourceAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return DynamicPskValue{
		DefaultPsk:    defaultPskVal,
		DefaultVlanId: defaultVlanIdVal,
		Enabled:       enabledVal,
		ForceLookup:   forceLookupVal,
		Source:        sourceVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewDynamicPskValueNull() DynamicPskValue {
	return DynamicPskValue{
		state: attr.ValueStateNull,
	}
}

func NewDynamicPskValueUnknown() DynamicPskValue {
	return DynamicPskValue{
		state: attr.ValueStateUnknown,
	}
}

func NewDynamicPskValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (DynamicPskValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing DynamicPskValue Attribute Value",
				"While creating a DynamicPskValue value, a missing attribute value was detected. "+
					"A DynamicPskValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DynamicPskValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid DynamicPskValue Attribute Type",
				"While creating a DynamicPskValue value, an invalid attribute value was detected. "+
					"A DynamicPskValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DynamicPskValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("DynamicPskValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra DynamicPskValue Attribute Value",
				"While creating a DynamicPskValue value, an extra attribute value was detected. "+
					"A DynamicPskValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra DynamicPskValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewDynamicPskValueUnknown(), diags
	}

	defaultPskAttribute, ok := attributes["default_psk"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`default_psk is missing from object`)

		return NewDynamicPskValueUnknown(), diags
	}

	defaultPskVal, ok := defaultPskAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`default_psk expected to be basetypes.StringValue, was: %T`, defaultPskAttribute))
	}

	defaultVlanIdAttribute, ok := attributes["default_vlan_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`default_vlan_id is missing from object`)

		return NewDynamicPskValueUnknown(), diags
	}

	defaultVlanIdVal, ok := defaultVlanIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`default_vlan_id expected to be basetypes.StringValue, was: %T`, defaultVlanIdAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewDynamicPskValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	forceLookupAttribute, ok := attributes["force_lookup"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`force_lookup is missing from object`)

		return NewDynamicPskValueUnknown(), diags
	}

	forceLookupVal, ok := forceLookupAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`force_lookup expected to be basetypes.BoolValue, was: %T`, forceLookupAttribute))
	}

	sourceAttribute, ok := attributes["source"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`source is missing from object`)

		return NewDynamicPskValueUnknown(), diags
	}

	sourceVal, ok := sourceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`source expected to be basetypes.StringValue, was: %T`, sourceAttribute))
	}

	if diags.HasError() {
		return NewDynamicPskValueUnknown(), diags
	}

	return DynamicPskValue{
		DefaultPsk:    defaultPskVal,
		DefaultVlanId: defaultVlanIdVal,
		Enabled:       enabledVal,
		ForceLookup:   forceLookupVal,
		Source:        sourceVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewDynamicPskValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) DynamicPskValue {
	object, diags := NewDynamicPskValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewDynamicPskValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t DynamicPskType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewDynamicPskValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewDynamicPskValueUnknown(), nil
	}

	if in.IsNull() {
		return NewDynamicPskValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewDynamicPskValueMust(DynamicPskValue{}.AttributeTypes(ctx), attributes), nil
}

func (t DynamicPskType) ValueType(ctx context.Context) attr.Value {
	return DynamicPskValue{}
}

var _ basetypes.ObjectValuable = DynamicPskValue{}

type DynamicPskValue struct {
	DefaultPsk    basetypes.StringValue `tfsdk:"default_psk"`
	DefaultVlanId basetypes.StringValue `tfsdk:"default_vlan_id"`
	Enabled       basetypes.BoolValue   `tfsdk:"enabled"`
	ForceLookup   basetypes.BoolValue   `tfsdk:"force_lookup"`
	Source        basetypes.StringValue `tfsdk:"source"`
	state         attr.ValueState
}

func (v DynamicPskValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["default_psk"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["default_vlan_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["force_lookup"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["source"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.DefaultPsk.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["default_psk"] = val

		val, err = v.DefaultVlanId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["default_vlan_id"] = val

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.ForceLookup.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["force_lookup"] = val

		val, err = v.Source.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["source"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v DynamicPskValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v DynamicPskValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v DynamicPskValue) String() string {
	return "DynamicPskValue"
}

func (v DynamicPskValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"default_psk":     basetypes.StringType{},
		"default_vlan_id": basetypes.StringType{},
		"enabled":         basetypes.BoolType{},
		"force_lookup":    basetypes.BoolType{},
		"source":          basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"default_psk":     v.DefaultPsk,
			"default_vlan_id": v.DefaultVlanId,
			"enabled":         v.Enabled,
			"force_lookup":    v.ForceLookup,
			"source":          v.Source,
		})

	return objVal, diags
}

func (v DynamicPskValue) Equal(o attr.Value) bool {
	other, ok := o.(DynamicPskValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.DefaultPsk.Equal(other.DefaultPsk) {
		return false
	}

	if !v.DefaultVlanId.Equal(other.DefaultVlanId) {
		return false
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.ForceLookup.Equal(other.ForceLookup) {
		return false
	}

	if !v.Source.Equal(other.Source) {
		return false
	}

	return true
}

func (v DynamicPskValue) Type(ctx context.Context) attr.Type {
	return DynamicPskType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v DynamicPskValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"default_psk":     basetypes.StringType{},
		"default_vlan_id": basetypes.StringType{},
		"enabled":         basetypes.BoolType{},
		"force_lookup":    basetypes.BoolType{},
		"source":          basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = DynamicVlanType{}

type DynamicVlanType struct {
	basetypes.ObjectType
}

func (t DynamicVlanType) Equal(o attr.Type) bool {
	other, ok := o.(DynamicVlanType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t DynamicVlanType) String() string {
	return "DynamicVlanType"
}

func (t DynamicVlanType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	defaultVlanIdsAttribute, ok := attributes["default_vlan_ids"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`default_vlan_ids is missing from object`)

		return nil, diags
	}

	defaultVlanIdsVal, ok := defaultVlanIdsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`default_vlan_ids expected to be basetypes.ListValue, was: %T`, defaultVlanIdsAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	localVlanIdsAttribute, ok := attributes["local_vlan_ids"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`local_vlan_ids is missing from object`)

		return nil, diags
	}

	localVlanIdsVal, ok := localVlanIdsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`local_vlan_ids expected to be basetypes.ListValue, was: %T`, localVlanIdsAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	vlansAttribute, ok := attributes["vlans"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlans is missing from object`)

		return nil, diags
	}

	vlansVal, ok := vlansAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlans expected to be basetypes.MapValue, was: %T`, vlansAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return DynamicVlanValue{
		DefaultVlanIds:  defaultVlanIdsVal,
		Enabled:         enabledVal,
		LocalVlanIds:    localVlanIdsVal,
		DynamicVlanType: typeVal,
		Vlans:           vlansVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewDynamicVlanValueNull() DynamicVlanValue {
	return DynamicVlanValue{
		state: attr.ValueStateNull,
	}
}

func NewDynamicVlanValueUnknown() DynamicVlanValue {
	return DynamicVlanValue{
		state: attr.ValueStateUnknown,
	}
}

func NewDynamicVlanValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (DynamicVlanValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing DynamicVlanValue Attribute Value",
				"While creating a DynamicVlanValue value, a missing attribute value was detected. "+
					"A DynamicVlanValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DynamicVlanValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid DynamicVlanValue Attribute Type",
				"While creating a DynamicVlanValue value, an invalid attribute value was detected. "+
					"A DynamicVlanValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DynamicVlanValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("DynamicVlanValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra DynamicVlanValue Attribute Value",
				"While creating a DynamicVlanValue value, an extra attribute value was detected. "+
					"A DynamicVlanValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra DynamicVlanValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewDynamicVlanValueUnknown(), diags
	}

	defaultVlanIdsAttribute, ok := attributes["default_vlan_ids"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`default_vlan_ids is missing from object`)

		return NewDynamicVlanValueUnknown(), diags
	}

	defaultVlanIdsVal, ok := defaultVlanIdsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`default_vlan_ids expected to be basetypes.ListValue, was: %T`, defaultVlanIdsAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewDynamicVlanValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	localVlanIdsAttribute, ok := attributes["local_vlan_ids"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`local_vlan_ids is missing from object`)

		return NewDynamicVlanValueUnknown(), diags
	}

	localVlanIdsVal, ok := localVlanIdsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`local_vlan_ids expected to be basetypes.ListValue, was: %T`, localVlanIdsAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewDynamicVlanValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	vlansAttribute, ok := attributes["vlans"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlans is missing from object`)

		return NewDynamicVlanValueUnknown(), diags
	}

	vlansVal, ok := vlansAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlans expected to be basetypes.MapValue, was: %T`, vlansAttribute))
	}

	if diags.HasError() {
		return NewDynamicVlanValueUnknown(), diags
	}

	return DynamicVlanValue{
		DefaultVlanIds:  defaultVlanIdsVal,
		Enabled:         enabledVal,
		LocalVlanIds:    localVlanIdsVal,
		DynamicVlanType: typeVal,
		Vlans:           vlansVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewDynamicVlanValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) DynamicVlanValue {
	object, diags := NewDynamicVlanValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewDynamicVlanValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t DynamicVlanType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewDynamicVlanValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewDynamicVlanValueUnknown(), nil
	}

	if in.IsNull() {
		return NewDynamicVlanValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewDynamicVlanValueMust(DynamicVlanValue{}.AttributeTypes(ctx), attributes), nil
}

func (t DynamicVlanType) ValueType(ctx context.Context) attr.Value {
	return DynamicVlanValue{}
}

var _ basetypes.ObjectValuable = DynamicVlanValue{}

type DynamicVlanValue struct {
	DefaultVlanIds  basetypes.ListValue   `tfsdk:"default_vlan_ids"`
	Enabled         basetypes.BoolValue   `tfsdk:"enabled"`
	LocalVlanIds    basetypes.ListValue   `tfsdk:"local_vlan_ids"`
	DynamicVlanType basetypes.StringValue `tfsdk:"type"`
	Vlans           basetypes.MapValue    `tfsdk:"vlans"`
	state           attr.ValueState
}

func (v DynamicVlanValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["default_vlan_ids"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["local_vlan_ids"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["vlans"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.DefaultVlanIds.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["default_vlan_ids"] = val

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.LocalVlanIds.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["local_vlan_ids"] = val

		val, err = v.DynamicVlanType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		val, err = v.Vlans.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vlans"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v DynamicVlanValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v DynamicVlanValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v DynamicVlanValue) String() string {
	return "DynamicVlanValue"
}

func (v DynamicVlanValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	defaultVlanIdsVal, d := types.ListValue(types.StringType, v.DefaultVlanIds.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"default_vlan_ids": basetypes.ListType{
				ElemType: types.StringType,
			},
			"enabled": basetypes.BoolType{},
			"local_vlan_ids": basetypes.ListType{
				ElemType: types.StringType,
			},
			"type": basetypes.StringType{},
			"vlans": basetypes.MapType{
				ElemType: types.StringType,
			},
		}), diags
	}

	localVlanIdsVal, d := types.ListValue(types.StringType, v.LocalVlanIds.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"default_vlan_ids": basetypes.ListType{
				ElemType: types.StringType,
			},
			"enabled": basetypes.BoolType{},
			"local_vlan_ids": basetypes.ListType{
				ElemType: types.StringType,
			},
			"type": basetypes.StringType{},
			"vlans": basetypes.MapType{
				ElemType: types.StringType,
			},
		}), diags
	}

	vlansVal, d := types.MapValue(types.StringType, v.Vlans.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"default_vlan_ids": basetypes.ListType{
				ElemType: types.StringType,
			},
			"enabled": basetypes.BoolType{},
			"local_vlan_ids": basetypes.ListType{
				ElemType: types.StringType,
			},
			"type": basetypes.StringType{},
			"vlans": basetypes.MapType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"default_vlan_ids": basetypes.ListType{
			ElemType: types.StringType,
		},
		"enabled": basetypes.BoolType{},
		"local_vlan_ids": basetypes.ListType{
			ElemType: types.StringType,
		},
		"type": basetypes.StringType{},
		"vlans": basetypes.MapType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"default_vlan_ids": defaultVlanIdsVal,
			"enabled":          v.Enabled,
			"local_vlan_ids":   localVlanIdsVal,
			"type":             v.DynamicVlanType,
			"vlans":            vlansVal,
		})

	return objVal, diags
}

func (v DynamicVlanValue) Equal(o attr.Value) bool {
	other, ok := o.(DynamicVlanValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.DefaultVlanIds.Equal(other.DefaultVlanIds) {
		return false
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.LocalVlanIds.Equal(other.LocalVlanIds) {
		return false
	}

	if !v.DynamicVlanType.Equal(other.DynamicVlanType) {
		return false
	}

	if !v.Vlans.Equal(other.Vlans) {
		return false
	}

	return true
}

func (v DynamicVlanValue) Type(ctx context.Context) attr.Type {
	return DynamicVlanType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v DynamicVlanValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"default_vlan_ids": basetypes.ListType{
			ElemType: types.StringType,
		},
		"enabled": basetypes.BoolType{},
		"local_vlan_ids": basetypes.ListType{
			ElemType: types.StringType,
		},
		"type": basetypes.StringType{},
		"vlans": basetypes.MapType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = Hotspot20Type{}

type Hotspot20Type struct {
	basetypes.ObjectType
}

func (t Hotspot20Type) Equal(o attr.Type) bool {
	other, ok := o.(Hotspot20Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Hotspot20Type) String() string {
	return "Hotspot20Type"
}

func (t Hotspot20Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	domainNameAttribute, ok := attributes["domain_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`domain_name is missing from object`)

		return nil, diags
	}

	domainNameVal, ok := domainNameAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`domain_name expected to be basetypes.ListValue, was: %T`, domainNameAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	naiRealmsAttribute, ok := attributes["nai_realms"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`nai_realms is missing from object`)

		return nil, diags
	}

	naiRealmsVal, ok := naiRealmsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`nai_realms expected to be basetypes.ListValue, was: %T`, naiRealmsAttribute))
	}

	operatorsAttribute, ok := attributes["operators"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`operators is missing from object`)

		return nil, diags
	}

	operatorsVal, ok := operatorsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`operators expected to be basetypes.ListValue, was: %T`, operatorsAttribute))
	}

	rcoiAttribute, ok := attributes["rcoi"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rcoi is missing from object`)

		return nil, diags
	}

	rcoiVal, ok := rcoiAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rcoi expected to be basetypes.ListValue, was: %T`, rcoiAttribute))
	}

	venueNameAttribute, ok := attributes["venue_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`venue_name is missing from object`)

		return nil, diags
	}

	venueNameVal, ok := venueNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`venue_name expected to be basetypes.StringValue, was: %T`, venueNameAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Hotspot20Value{
		DomainName: domainNameVal,
		Enabled:    enabledVal,
		NaiRealms:  naiRealmsVal,
		Operators:  operatorsVal,
		Rcoi:       rcoiVal,
		VenueName:  venueNameVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewHotspot20ValueNull() Hotspot20Value {
	return Hotspot20Value{
		state: attr.ValueStateNull,
	}
}

func NewHotspot20ValueUnknown() Hotspot20Value {
	return Hotspot20Value{
		state: attr.ValueStateUnknown,
	}
}

func NewHotspot20Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Hotspot20Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Hotspot20Value Attribute Value",
				"While creating a Hotspot20Value value, a missing attribute value was detected. "+
					"A Hotspot20Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Hotspot20Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Hotspot20Value Attribute Type",
				"While creating a Hotspot20Value value, an invalid attribute value was detected. "+
					"A Hotspot20Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Hotspot20Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Hotspot20Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Hotspot20Value Attribute Value",
				"While creating a Hotspot20Value value, an extra attribute value was detected. "+
					"A Hotspot20Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Hotspot20Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewHotspot20ValueUnknown(), diags
	}

	domainNameAttribute, ok := attributes["domain_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`domain_name is missing from object`)

		return NewHotspot20ValueUnknown(), diags
	}

	domainNameVal, ok := domainNameAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`domain_name expected to be basetypes.ListValue, was: %T`, domainNameAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewHotspot20ValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	naiRealmsAttribute, ok := attributes["nai_realms"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`nai_realms is missing from object`)

		return NewHotspot20ValueUnknown(), diags
	}

	naiRealmsVal, ok := naiRealmsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`nai_realms expected to be basetypes.ListValue, was: %T`, naiRealmsAttribute))
	}

	operatorsAttribute, ok := attributes["operators"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`operators is missing from object`)

		return NewHotspot20ValueUnknown(), diags
	}

	operatorsVal, ok := operatorsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`operators expected to be basetypes.ListValue, was: %T`, operatorsAttribute))
	}

	rcoiAttribute, ok := attributes["rcoi"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rcoi is missing from object`)

		return NewHotspot20ValueUnknown(), diags
	}

	rcoiVal, ok := rcoiAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rcoi expected to be basetypes.ListValue, was: %T`, rcoiAttribute))
	}

	venueNameAttribute, ok := attributes["venue_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`venue_name is missing from object`)

		return NewHotspot20ValueUnknown(), diags
	}

	venueNameVal, ok := venueNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`venue_name expected to be basetypes.StringValue, was: %T`, venueNameAttribute))
	}

	if diags.HasError() {
		return NewHotspot20ValueUnknown(), diags
	}

	return Hotspot20Value{
		DomainName: domainNameVal,
		Enabled:    enabledVal,
		NaiRealms:  naiRealmsVal,
		Operators:  operatorsVal,
		Rcoi:       rcoiVal,
		VenueName:  venueNameVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewHotspot20ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Hotspot20Value {
	object, diags := NewHotspot20Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewHotspot20ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Hotspot20Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewHotspot20ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewHotspot20ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewHotspot20ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewHotspot20ValueMust(Hotspot20Value{}.AttributeTypes(ctx), attributes), nil
}

func (t Hotspot20Type) ValueType(ctx context.Context) attr.Value {
	return Hotspot20Value{}
}

var _ basetypes.ObjectValuable = Hotspot20Value{}

type Hotspot20Value struct {
	DomainName basetypes.ListValue   `tfsdk:"domain_name"`
	Enabled    basetypes.BoolValue   `tfsdk:"enabled"`
	NaiRealms  basetypes.ListValue   `tfsdk:"nai_realms"`
	Operators  basetypes.ListValue   `tfsdk:"operators"`
	Rcoi       basetypes.ListValue   `tfsdk:"rcoi"`
	VenueName  basetypes.StringValue `tfsdk:"venue_name"`
	state      attr.ValueState
}

func (v Hotspot20Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 6)

	var val tftypes.Value
	var err error

	attrTypes["domain_name"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["nai_realms"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["operators"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["rcoi"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["venue_name"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 6)

		val, err = v.DomainName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["domain_name"] = val

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.NaiRealms.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["nai_realms"] = val

		val, err = v.Operators.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["operators"] = val

		val, err = v.Rcoi.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["rcoi"] = val

		val, err = v.VenueName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["venue_name"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Hotspot20Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Hotspot20Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Hotspot20Value) String() string {
	return "Hotspot20Value"
}

func (v Hotspot20Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	domainNameVal, d := types.ListValue(types.StringType, v.DomainName.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"domain_name": basetypes.ListType{
				ElemType: types.StringType,
			},
			"enabled": basetypes.BoolType{},
			"nai_realms": basetypes.ListType{
				ElemType: types.StringType,
			},
			"operators": basetypes.ListType{
				ElemType: types.StringType,
			},
			"rcoi": basetypes.ListType{
				ElemType: types.StringType,
			},
			"venue_name": basetypes.StringType{},
		}), diags
	}

	naiRealmsVal, d := types.ListValue(types.StringType, v.NaiRealms.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"domain_name": basetypes.ListType{
				ElemType: types.StringType,
			},
			"enabled": basetypes.BoolType{},
			"nai_realms": basetypes.ListType{
				ElemType: types.StringType,
			},
			"operators": basetypes.ListType{
				ElemType: types.StringType,
			},
			"rcoi": basetypes.ListType{
				ElemType: types.StringType,
			},
			"venue_name": basetypes.StringType{},
		}), diags
	}

	operatorsVal, d := types.ListValue(types.StringType, v.Operators.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"domain_name": basetypes.ListType{
				ElemType: types.StringType,
			},
			"enabled": basetypes.BoolType{},
			"nai_realms": basetypes.ListType{
				ElemType: types.StringType,
			},
			"operators": basetypes.ListType{
				ElemType: types.StringType,
			},
			"rcoi": basetypes.ListType{
				ElemType: types.StringType,
			},
			"venue_name": basetypes.StringType{},
		}), diags
	}

	rcoiVal, d := types.ListValue(types.StringType, v.Rcoi.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"domain_name": basetypes.ListType{
				ElemType: types.StringType,
			},
			"enabled": basetypes.BoolType{},
			"nai_realms": basetypes.ListType{
				ElemType: types.StringType,
			},
			"operators": basetypes.ListType{
				ElemType: types.StringType,
			},
			"rcoi": basetypes.ListType{
				ElemType: types.StringType,
			},
			"venue_name": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"domain_name": basetypes.ListType{
			ElemType: types.StringType,
		},
		"enabled": basetypes.BoolType{},
		"nai_realms": basetypes.ListType{
			ElemType: types.StringType,
		},
		"operators": basetypes.ListType{
			ElemType: types.StringType,
		},
		"rcoi": basetypes.ListType{
			ElemType: types.StringType,
		},
		"venue_name": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"domain_name": domainNameVal,
			"enabled":     v.Enabled,
			"nai_realms":  naiRealmsVal,
			"operators":   operatorsVal,
			"rcoi":        rcoiVal,
			"venue_name":  v.VenueName,
		})

	return objVal, diags
}

func (v Hotspot20Value) Equal(o attr.Value) bool {
	other, ok := o.(Hotspot20Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.DomainName.Equal(other.DomainName) {
		return false
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.NaiRealms.Equal(other.NaiRealms) {
		return false
	}

	if !v.Operators.Equal(other.Operators) {
		return false
	}

	if !v.Rcoi.Equal(other.Rcoi) {
		return false
	}

	if !v.VenueName.Equal(other.VenueName) {
		return false
	}

	return true
}

func (v Hotspot20Value) Type(ctx context.Context) attr.Type {
	return Hotspot20Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Hotspot20Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"domain_name": basetypes.ListType{
			ElemType: types.StringType,
		},
		"enabled": basetypes.BoolType{},
		"nai_realms": basetypes.ListType{
			ElemType: types.StringType,
		},
		"operators": basetypes.ListType{
			ElemType: types.StringType,
		},
		"rcoi": basetypes.ListType{
			ElemType: types.StringType,
		},
		"venue_name": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = InjectDhcpOption82Type{}

type InjectDhcpOption82Type struct {
	basetypes.ObjectType
}

func (t InjectDhcpOption82Type) Equal(o attr.Type) bool {
	other, ok := o.(InjectDhcpOption82Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t InjectDhcpOption82Type) String() string {
	return "InjectDhcpOption82Type"
}

func (t InjectDhcpOption82Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	circuitIdAttribute, ok := attributes["circuit_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`circuit_id is missing from object`)

		return nil, diags
	}

	circuitIdVal, ok := circuitIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`circuit_id expected to be basetypes.StringValue, was: %T`, circuitIdAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return InjectDhcpOption82Value{
		CircuitId: circuitIdVal,
		Enabled:   enabledVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewInjectDhcpOption82ValueNull() InjectDhcpOption82Value {
	return InjectDhcpOption82Value{
		state: attr.ValueStateNull,
	}
}

func NewInjectDhcpOption82ValueUnknown() InjectDhcpOption82Value {
	return InjectDhcpOption82Value{
		state: attr.ValueStateUnknown,
	}
}

func NewInjectDhcpOption82Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (InjectDhcpOption82Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing InjectDhcpOption82Value Attribute Value",
				"While creating a InjectDhcpOption82Value value, a missing attribute value was detected. "+
					"A InjectDhcpOption82Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("InjectDhcpOption82Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid InjectDhcpOption82Value Attribute Type",
				"While creating a InjectDhcpOption82Value value, an invalid attribute value was detected. "+
					"A InjectDhcpOption82Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("InjectDhcpOption82Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("InjectDhcpOption82Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra InjectDhcpOption82Value Attribute Value",
				"While creating a InjectDhcpOption82Value value, an extra attribute value was detected. "+
					"A InjectDhcpOption82Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra InjectDhcpOption82Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewInjectDhcpOption82ValueUnknown(), diags
	}

	circuitIdAttribute, ok := attributes["circuit_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`circuit_id is missing from object`)

		return NewInjectDhcpOption82ValueUnknown(), diags
	}

	circuitIdVal, ok := circuitIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`circuit_id expected to be basetypes.StringValue, was: %T`, circuitIdAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewInjectDhcpOption82ValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	if diags.HasError() {
		return NewInjectDhcpOption82ValueUnknown(), diags
	}

	return InjectDhcpOption82Value{
		CircuitId: circuitIdVal,
		Enabled:   enabledVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewInjectDhcpOption82ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) InjectDhcpOption82Value {
	object, diags := NewInjectDhcpOption82Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewInjectDhcpOption82ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t InjectDhcpOption82Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewInjectDhcpOption82ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewInjectDhcpOption82ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewInjectDhcpOption82ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewInjectDhcpOption82ValueMust(InjectDhcpOption82Value{}.AttributeTypes(ctx), attributes), nil
}

func (t InjectDhcpOption82Type) ValueType(ctx context.Context) attr.Value {
	return InjectDhcpOption82Value{}
}

var _ basetypes.ObjectValuable = InjectDhcpOption82Value{}

type InjectDhcpOption82Value struct {
	CircuitId basetypes.StringValue `tfsdk:"circuit_id"`
	Enabled   basetypes.BoolValue   `tfsdk:"enabled"`
	state     attr.ValueState
}

func (v InjectDhcpOption82Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["circuit_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.CircuitId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["circuit_id"] = val

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v InjectDhcpOption82Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v InjectDhcpOption82Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v InjectDhcpOption82Value) String() string {
	return "InjectDhcpOption82Value"
}

func (v InjectDhcpOption82Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"circuit_id": basetypes.StringType{},
		"enabled":    basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"circuit_id": v.CircuitId,
			"enabled":    v.Enabled,
		})

	return objVal, diags
}

func (v InjectDhcpOption82Value) Equal(o attr.Value) bool {
	other, ok := o.(InjectDhcpOption82Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.CircuitId.Equal(other.CircuitId) {
		return false
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	return true
}

func (v InjectDhcpOption82Value) Type(ctx context.Context) attr.Type {
	return InjectDhcpOption82Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v InjectDhcpOption82Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"circuit_id": basetypes.StringType{},
		"enabled":    basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = MistNacType{}

type MistNacType struct {
	basetypes.ObjectType
}

func (t MistNacType) Equal(o attr.Type) bool {
	other, ok := o.(MistNacType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t MistNacType) String() string {
	return "MistNacType"
}

func (t MistNacType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return MistNacValue{
		Enabled: enabledVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewMistNacValueNull() MistNacValue {
	return MistNacValue{
		state: attr.ValueStateNull,
	}
}

func NewMistNacValueUnknown() MistNacValue {
	return MistNacValue{
		state: attr.ValueStateUnknown,
	}
}

func NewMistNacValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (MistNacValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing MistNacValue Attribute Value",
				"While creating a MistNacValue value, a missing attribute value was detected. "+
					"A MistNacValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MistNacValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid MistNacValue Attribute Type",
				"While creating a MistNacValue value, an invalid attribute value was detected. "+
					"A MistNacValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MistNacValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("MistNacValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra MistNacValue Attribute Value",
				"While creating a MistNacValue value, an extra attribute value was detected. "+
					"A MistNacValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra MistNacValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewMistNacValueUnknown(), diags
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewMistNacValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	if diags.HasError() {
		return NewMistNacValueUnknown(), diags
	}

	return MistNacValue{
		Enabled: enabledVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewMistNacValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) MistNacValue {
	object, diags := NewMistNacValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewMistNacValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t MistNacType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewMistNacValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewMistNacValueUnknown(), nil
	}

	if in.IsNull() {
		return NewMistNacValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewMistNacValueMust(MistNacValue{}.AttributeTypes(ctx), attributes), nil
}

func (t MistNacType) ValueType(ctx context.Context) attr.Value {
	return MistNacValue{}
}

var _ basetypes.ObjectValuable = MistNacValue{}

type MistNacValue struct {
	Enabled basetypes.BoolValue `tfsdk:"enabled"`
	state   attr.ValueState
}

func (v MistNacValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v MistNacValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v MistNacValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v MistNacValue) String() string {
	return "MistNacValue"
}

func (v MistNacValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"enabled": basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"enabled": v.Enabled,
		})

	return objVal, diags
}

func (v MistNacValue) Equal(o attr.Value) bool {
	other, ok := o.(MistNacValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	return true
}

func (v MistNacValue) Type(ctx context.Context) attr.Type {
	return MistNacType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v MistNacValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"enabled": basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = PortalType{}

type PortalType struct {
	basetypes.ObjectType
}

func (t PortalType) Equal(o attr.Type) bool {
	other, ok := o.(PortalType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PortalType) String() string {
	return "PortalType"
}

func (t PortalType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	allowWlanIdRoamAttribute, ok := attributes["allow_wlan_id_roam"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allow_wlan_id_roam is missing from object`)

		return nil, diags
	}

	allowWlanIdRoamVal, ok := allowWlanIdRoamAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allow_wlan_id_roam expected to be basetypes.BoolValue, was: %T`, allowWlanIdRoamAttribute))
	}

	amazonClientIdAttribute, ok := attributes["amazon_client_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`amazon_client_id is missing from object`)

		return nil, diags
	}

	amazonClientIdVal, ok := amazonClientIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`amazon_client_id expected to be basetypes.StringValue, was: %T`, amazonClientIdAttribute))
	}

	amazonClientSecretAttribute, ok := attributes["amazon_client_secret"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`amazon_client_secret is missing from object`)

		return nil, diags
	}

	amazonClientSecretVal, ok := amazonClientSecretAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`amazon_client_secret expected to be basetypes.StringValue, was: %T`, amazonClientSecretAttribute))
	}

	amazonEmailDomainsAttribute, ok := attributes["amazon_email_domains"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`amazon_email_domains is missing from object`)

		return nil, diags
	}

	amazonEmailDomainsVal, ok := amazonEmailDomainsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`amazon_email_domains expected to be basetypes.ListValue, was: %T`, amazonEmailDomainsAttribute))
	}

	amazonEnabledAttribute, ok := attributes["amazon_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`amazon_enabled is missing from object`)

		return nil, diags
	}

	amazonEnabledVal, ok := amazonEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`amazon_enabled expected to be basetypes.BoolValue, was: %T`, amazonEnabledAttribute))
	}

	amazonExpireAttribute, ok := attributes["amazon_expire"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`amazon_expire is missing from object`)

		return nil, diags
	}

	amazonExpireVal, ok := amazonExpireAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`amazon_expire expected to be basetypes.Int64Value, was: %T`, amazonExpireAttribute))
	}

	authAttribute, ok := attributes["auth"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auth is missing from object`)

		return nil, diags
	}

	authVal, ok := authAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auth expected to be basetypes.StringValue, was: %T`, authAttribute))
	}

	azureClientIdAttribute, ok := attributes["azure_client_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`azure_client_id is missing from object`)

		return nil, diags
	}

	azureClientIdVal, ok := azureClientIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`azure_client_id expected to be basetypes.StringValue, was: %T`, azureClientIdAttribute))
	}

	azureClientSecretAttribute, ok := attributes["azure_client_secret"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`azure_client_secret is missing from object`)

		return nil, diags
	}

	azureClientSecretVal, ok := azureClientSecretAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`azure_client_secret expected to be basetypes.StringValue, was: %T`, azureClientSecretAttribute))
	}

	azureEnabledAttribute, ok := attributes["azure_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`azure_enabled is missing from object`)

		return nil, diags
	}

	azureEnabledVal, ok := azureEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`azure_enabled expected to be basetypes.BoolValue, was: %T`, azureEnabledAttribute))
	}

	azureExpireAttribute, ok := attributes["azure_expire"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`azure_expire is missing from object`)

		return nil, diags
	}

	azureExpireVal, ok := azureExpireAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`azure_expire expected to be basetypes.Int64Value, was: %T`, azureExpireAttribute))
	}

	azureTenantIdAttribute, ok := attributes["azure_tenant_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`azure_tenant_id is missing from object`)

		return nil, diags
	}

	azureTenantIdVal, ok := azureTenantIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`azure_tenant_id expected to be basetypes.StringValue, was: %T`, azureTenantIdAttribute))
	}

	broadnetPasswordAttribute, ok := attributes["broadnet_password"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`broadnet_password is missing from object`)

		return nil, diags
	}

	broadnetPasswordVal, ok := broadnetPasswordAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`broadnet_password expected to be basetypes.StringValue, was: %T`, broadnetPasswordAttribute))
	}

	broadnetSidAttribute, ok := attributes["broadnet_sid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`broadnet_sid is missing from object`)

		return nil, diags
	}

	broadnetSidVal, ok := broadnetSidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`broadnet_sid expected to be basetypes.StringValue, was: %T`, broadnetSidAttribute))
	}

	broadnetUserIdAttribute, ok := attributes["broadnet_user_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`broadnet_user_id is missing from object`)

		return nil, diags
	}

	broadnetUserIdVal, ok := broadnetUserIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`broadnet_user_id expected to be basetypes.StringValue, was: %T`, broadnetUserIdAttribute))
	}

	bypassWhenCloudDownAttribute, ok := attributes["bypass_when_cloud_down"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bypass_when_cloud_down is missing from object`)

		return nil, diags
	}

	bypassWhenCloudDownVal, ok := bypassWhenCloudDownAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bypass_when_cloud_down expected to be basetypes.BoolValue, was: %T`, bypassWhenCloudDownAttribute))
	}

	clickatellApiKeyAttribute, ok := attributes["clickatell_api_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`clickatell_api_key is missing from object`)

		return nil, diags
	}

	clickatellApiKeyVal, ok := clickatellApiKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`clickatell_api_key expected to be basetypes.StringValue, was: %T`, clickatellApiKeyAttribute))
	}

	crossSiteAttribute, ok := attributes["cross_site"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cross_site is missing from object`)

		return nil, diags
	}

	crossSiteVal, ok := crossSiteAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cross_site expected to be basetypes.BoolValue, was: %T`, crossSiteAttribute))
	}

	emailEnabledAttribute, ok := attributes["email_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`email_enabled is missing from object`)

		return nil, diags
	}

	emailEnabledVal, ok := emailEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`email_enabled expected to be basetypes.BoolValue, was: %T`, emailEnabledAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	expireAttribute, ok := attributes["expire"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`expire is missing from object`)

		return nil, diags
	}

	expireVal, ok := expireAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`expire expected to be basetypes.Int64Value, was: %T`, expireAttribute))
	}

	externalPortalUrlAttribute, ok := attributes["external_portal_url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`external_portal_url is missing from object`)

		return nil, diags
	}

	externalPortalUrlVal, ok := externalPortalUrlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`external_portal_url expected to be basetypes.StringValue, was: %T`, externalPortalUrlAttribute))
	}

	facebookClientIdAttribute, ok := attributes["facebook_client_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`facebook_client_id is missing from object`)

		return nil, diags
	}

	facebookClientIdVal, ok := facebookClientIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`facebook_client_id expected to be basetypes.StringValue, was: %T`, facebookClientIdAttribute))
	}

	facebookClientSecretAttribute, ok := attributes["facebook_client_secret"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`facebook_client_secret is missing from object`)

		return nil, diags
	}

	facebookClientSecretVal, ok := facebookClientSecretAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`facebook_client_secret expected to be basetypes.StringValue, was: %T`, facebookClientSecretAttribute))
	}

	facebookEmailDomainsAttribute, ok := attributes["facebook_email_domains"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`facebook_email_domains is missing from object`)

		return nil, diags
	}

	facebookEmailDomainsVal, ok := facebookEmailDomainsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`facebook_email_domains expected to be basetypes.ListValue, was: %T`, facebookEmailDomainsAttribute))
	}

	facebookEnabledAttribute, ok := attributes["facebook_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`facebook_enabled is missing from object`)

		return nil, diags
	}

	facebookEnabledVal, ok := facebookEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`facebook_enabled expected to be basetypes.BoolValue, was: %T`, facebookEnabledAttribute))
	}

	facebookExpireAttribute, ok := attributes["facebook_expire"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`facebook_expire is missing from object`)

		return nil, diags
	}

	facebookExpireVal, ok := facebookExpireAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`facebook_expire expected to be basetypes.Int64Value, was: %T`, facebookExpireAttribute))
	}

	forwardAttribute, ok := attributes["forward"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`forward is missing from object`)

		return nil, diags
	}

	forwardVal, ok := forwardAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`forward expected to be basetypes.BoolValue, was: %T`, forwardAttribute))
	}

	forwardUrlAttribute, ok := attributes["forward_url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`forward_url is missing from object`)

		return nil, diags
	}

	forwardUrlVal, ok := forwardUrlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`forward_url expected to be basetypes.StringValue, was: %T`, forwardUrlAttribute))
	}

	googleClientIdAttribute, ok := attributes["google_client_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`google_client_id is missing from object`)

		return nil, diags
	}

	googleClientIdVal, ok := googleClientIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`google_client_id expected to be basetypes.StringValue, was: %T`, googleClientIdAttribute))
	}

	googleClientSecretAttribute, ok := attributes["google_client_secret"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`google_client_secret is missing from object`)

		return nil, diags
	}

	googleClientSecretVal, ok := googleClientSecretAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`google_client_secret expected to be basetypes.StringValue, was: %T`, googleClientSecretAttribute))
	}

	googleEmailDomainsAttribute, ok := attributes["google_email_domains"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`google_email_domains is missing from object`)

		return nil, diags
	}

	googleEmailDomainsVal, ok := googleEmailDomainsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`google_email_domains expected to be basetypes.ListValue, was: %T`, googleEmailDomainsAttribute))
	}

	googleEnabledAttribute, ok := attributes["google_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`google_enabled is missing from object`)

		return nil, diags
	}

	googleEnabledVal, ok := googleEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`google_enabled expected to be basetypes.BoolValue, was: %T`, googleEnabledAttribute))
	}

	googleExpireAttribute, ok := attributes["google_expire"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`google_expire is missing from object`)

		return nil, diags
	}

	googleExpireVal, ok := googleExpireAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`google_expire expected to be basetypes.Int64Value, was: %T`, googleExpireAttribute))
	}

	gupshupPasswordAttribute, ok := attributes["gupshup_password"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gupshup_password is missing from object`)

		return nil, diags
	}

	gupshupPasswordVal, ok := gupshupPasswordAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gupshup_password expected to be basetypes.StringValue, was: %T`, gupshupPasswordAttribute))
	}

	gupshupUseridAttribute, ok := attributes["gupshup_userid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gupshup_userid is missing from object`)

		return nil, diags
	}

	gupshupUseridVal, ok := gupshupUseridAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gupshup_userid expected to be basetypes.StringValue, was: %T`, gupshupUseridAttribute))
	}

	microsoftClientIdAttribute, ok := attributes["microsoft_client_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`microsoft_client_id is missing from object`)

		return nil, diags
	}

	microsoftClientIdVal, ok := microsoftClientIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`microsoft_client_id expected to be basetypes.StringValue, was: %T`, microsoftClientIdAttribute))
	}

	microsoftClientSecretAttribute, ok := attributes["microsoft_client_secret"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`microsoft_client_secret is missing from object`)

		return nil, diags
	}

	microsoftClientSecretVal, ok := microsoftClientSecretAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`microsoft_client_secret expected to be basetypes.StringValue, was: %T`, microsoftClientSecretAttribute))
	}

	microsoftEmailDomainsAttribute, ok := attributes["microsoft_email_domains"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`microsoft_email_domains is missing from object`)

		return nil, diags
	}

	microsoftEmailDomainsVal, ok := microsoftEmailDomainsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`microsoft_email_domains expected to be basetypes.ListValue, was: %T`, microsoftEmailDomainsAttribute))
	}

	microsoftEnabledAttribute, ok := attributes["microsoft_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`microsoft_enabled is missing from object`)

		return nil, diags
	}

	microsoftEnabledVal, ok := microsoftEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`microsoft_enabled expected to be basetypes.BoolValue, was: %T`, microsoftEnabledAttribute))
	}

	microsoftExpireAttribute, ok := attributes["microsoft_expire"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`microsoft_expire is missing from object`)

		return nil, diags
	}

	microsoftExpireVal, ok := microsoftExpireAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`microsoft_expire expected to be basetypes.Int64Value, was: %T`, microsoftExpireAttribute))
	}

	passphraseEnabledAttribute, ok := attributes["passphrase_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`passphrase_enabled is missing from object`)

		return nil, diags
	}

	passphraseEnabledVal, ok := passphraseEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`passphrase_enabled expected to be basetypes.BoolValue, was: %T`, passphraseEnabledAttribute))
	}

	passphraseExpireAttribute, ok := attributes["passphrase_expire"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`passphrase_expire is missing from object`)

		return nil, diags
	}

	passphraseExpireVal, ok := passphraseExpireAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`passphrase_expire expected to be basetypes.Int64Value, was: %T`, passphraseExpireAttribute))
	}

	passwordAttribute, ok := attributes["password"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`password is missing from object`)

		return nil, diags
	}

	passwordVal, ok := passwordAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`password expected to be basetypes.StringValue, was: %T`, passwordAttribute))
	}

	predefinedSponsorsEnabledAttribute, ok := attributes["predefined_sponsors_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`predefined_sponsors_enabled is missing from object`)

		return nil, diags
	}

	predefinedSponsorsEnabledVal, ok := predefinedSponsorsEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`predefined_sponsors_enabled expected to be basetypes.BoolValue, was: %T`, predefinedSponsorsEnabledAttribute))
	}

	predefinedSponsorsHideEmailAttribute, ok := attributes["predefined_sponsors_hide_email"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`predefined_sponsors_hide_email is missing from object`)

		return nil, diags
	}

	predefinedSponsorsHideEmailVal, ok := predefinedSponsorsHideEmailAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`predefined_sponsors_hide_email expected to be basetypes.BoolValue, was: %T`, predefinedSponsorsHideEmailAttribute))
	}

	privacyAttribute, ok := attributes["privacy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`privacy is missing from object`)

		return nil, diags
	}

	privacyVal, ok := privacyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`privacy expected to be basetypes.BoolValue, was: %T`, privacyAttribute))
	}

	puzzelPasswordAttribute, ok := attributes["puzzel_password"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`puzzel_password is missing from object`)

		return nil, diags
	}

	puzzelPasswordVal, ok := puzzelPasswordAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`puzzel_password expected to be basetypes.StringValue, was: %T`, puzzelPasswordAttribute))
	}

	puzzelServiceIdAttribute, ok := attributes["puzzel_service_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`puzzel_service_id is missing from object`)

		return nil, diags
	}

	puzzelServiceIdVal, ok := puzzelServiceIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`puzzel_service_id expected to be basetypes.StringValue, was: %T`, puzzelServiceIdAttribute))
	}

	puzzelUsernameAttribute, ok := attributes["puzzel_username"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`puzzel_username is missing from object`)

		return nil, diags
	}

	puzzelUsernameVal, ok := puzzelUsernameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`puzzel_username expected to be basetypes.StringValue, was: %T`, puzzelUsernameAttribute))
	}

	smsEnabledAttribute, ok := attributes["sms_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sms_enabled is missing from object`)

		return nil, diags
	}

	smsEnabledVal, ok := smsEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sms_enabled expected to be basetypes.BoolValue, was: %T`, smsEnabledAttribute))
	}

	smsExpireAttribute, ok := attributes["sms_expire"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sms_expire is missing from object`)

		return nil, diags
	}

	smsExpireVal, ok := smsExpireAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sms_expire expected to be basetypes.Int64Value, was: %T`, smsExpireAttribute))
	}

	smsMessageFormatAttribute, ok := attributes["sms_message_format"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sms_message_format is missing from object`)

		return nil, diags
	}

	smsMessageFormatVal, ok := smsMessageFormatAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sms_message_format expected to be basetypes.StringValue, was: %T`, smsMessageFormatAttribute))
	}

	smsProviderAttribute, ok := attributes["sms_provider"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sms_provider is missing from object`)

		return nil, diags
	}

	smsProviderVal, ok := smsProviderAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sms_provider expected to be basetypes.StringValue, was: %T`, smsProviderAttribute))
	}

	sponsorAutoApproveAttribute, ok := attributes["sponsor_auto_approve"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sponsor_auto_approve is missing from object`)

		return nil, diags
	}

	sponsorAutoApproveVal, ok := sponsorAutoApproveAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sponsor_auto_approve expected to be basetypes.BoolValue, was: %T`, sponsorAutoApproveAttribute))
	}

	sponsorEmailDomainsAttribute, ok := attributes["sponsor_email_domains"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sponsor_email_domains is missing from object`)

		return nil, diags
	}

	sponsorEmailDomainsVal, ok := sponsorEmailDomainsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sponsor_email_domains expected to be basetypes.ListValue, was: %T`, sponsorEmailDomainsAttribute))
	}

	sponsorEnabledAttribute, ok := attributes["sponsor_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sponsor_enabled is missing from object`)

		return nil, diags
	}

	sponsorEnabledVal, ok := sponsorEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sponsor_enabled expected to be basetypes.BoolValue, was: %T`, sponsorEnabledAttribute))
	}

	sponsorExpireAttribute, ok := attributes["sponsor_expire"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sponsor_expire is missing from object`)

		return nil, diags
	}

	sponsorExpireVal, ok := sponsorExpireAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sponsor_expire expected to be basetypes.Int64Value, was: %T`, sponsorExpireAttribute))
	}

	sponsorLinkValidityDurationAttribute, ok := attributes["sponsor_link_validity_duration"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sponsor_link_validity_duration is missing from object`)

		return nil, diags
	}

	sponsorLinkValidityDurationVal, ok := sponsorLinkValidityDurationAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sponsor_link_validity_duration expected to be basetypes.StringValue, was: %T`, sponsorLinkValidityDurationAttribute))
	}

	sponsorNotifyAllAttribute, ok := attributes["sponsor_notify_all"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sponsor_notify_all is missing from object`)

		return nil, diags
	}

	sponsorNotifyAllVal, ok := sponsorNotifyAllAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sponsor_notify_all expected to be basetypes.BoolValue, was: %T`, sponsorNotifyAllAttribute))
	}

	sponsorStatusNotifyAttribute, ok := attributes["sponsor_status_notify"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sponsor_status_notify is missing from object`)

		return nil, diags
	}

	sponsorStatusNotifyVal, ok := sponsorStatusNotifyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sponsor_status_notify expected to be basetypes.BoolValue, was: %T`, sponsorStatusNotifyAttribute))
	}

	sponsorsAttribute, ok := attributes["sponsors"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sponsors is missing from object`)

		return nil, diags
	}

	sponsorsVal, ok := sponsorsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sponsors expected to be basetypes.MapValue, was: %T`, sponsorsAttribute))
	}

	ssoDefaultRoleAttribute, ok := attributes["sso_default_role"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sso_default_role is missing from object`)

		return nil, diags
	}

	ssoDefaultRoleVal, ok := ssoDefaultRoleAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sso_default_role expected to be basetypes.StringValue, was: %T`, ssoDefaultRoleAttribute))
	}

	ssoForcedRoleAttribute, ok := attributes["sso_forced_role"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sso_forced_role is missing from object`)

		return nil, diags
	}

	ssoForcedRoleVal, ok := ssoForcedRoleAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sso_forced_role expected to be basetypes.StringValue, was: %T`, ssoForcedRoleAttribute))
	}

	ssoIdpCertAttribute, ok := attributes["sso_idp_cert"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sso_idp_cert is missing from object`)

		return nil, diags
	}

	ssoIdpCertVal, ok := ssoIdpCertAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sso_idp_cert expected to be basetypes.StringValue, was: %T`, ssoIdpCertAttribute))
	}

	ssoIdpSignAlgoAttribute, ok := attributes["sso_idp_sign_algo"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sso_idp_sign_algo is missing from object`)

		return nil, diags
	}

	ssoIdpSignAlgoVal, ok := ssoIdpSignAlgoAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sso_idp_sign_algo expected to be basetypes.StringValue, was: %T`, ssoIdpSignAlgoAttribute))
	}

	ssoIdpSsoUrlAttribute, ok := attributes["sso_idp_sso_url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sso_idp_sso_url is missing from object`)

		return nil, diags
	}

	ssoIdpSsoUrlVal, ok := ssoIdpSsoUrlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sso_idp_sso_url expected to be basetypes.StringValue, was: %T`, ssoIdpSsoUrlAttribute))
	}

	ssoIssuerAttribute, ok := attributes["sso_issuer"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sso_issuer is missing from object`)

		return nil, diags
	}

	ssoIssuerVal, ok := ssoIssuerAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sso_issuer expected to be basetypes.StringValue, was: %T`, ssoIssuerAttribute))
	}

	ssoNameidFormatAttribute, ok := attributes["sso_nameid_format"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sso_nameid_format is missing from object`)

		return nil, diags
	}

	ssoNameidFormatVal, ok := ssoNameidFormatAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sso_nameid_format expected to be basetypes.StringValue, was: %T`, ssoNameidFormatAttribute))
	}

	telstraClientIdAttribute, ok := attributes["telstra_client_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`telstra_client_id is missing from object`)

		return nil, diags
	}

	telstraClientIdVal, ok := telstraClientIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`telstra_client_id expected to be basetypes.StringValue, was: %T`, telstraClientIdAttribute))
	}

	telstraClientSecretAttribute, ok := attributes["telstra_client_secret"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`telstra_client_secret is missing from object`)

		return nil, diags
	}

	telstraClientSecretVal, ok := telstraClientSecretAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`telstra_client_secret expected to be basetypes.StringValue, was: %T`, telstraClientSecretAttribute))
	}

	twilioAuthTokenAttribute, ok := attributes["twilio_auth_token"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`twilio_auth_token is missing from object`)

		return nil, diags
	}

	twilioAuthTokenVal, ok := twilioAuthTokenAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`twilio_auth_token expected to be basetypes.StringValue, was: %T`, twilioAuthTokenAttribute))
	}

	twilioPhoneNumberAttribute, ok := attributes["twilio_phone_number"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`twilio_phone_number is missing from object`)

		return nil, diags
	}

	twilioPhoneNumberVal, ok := twilioPhoneNumberAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`twilio_phone_number expected to be basetypes.StringValue, was: %T`, twilioPhoneNumberAttribute))
	}

	twilioSidAttribute, ok := attributes["twilio_sid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`twilio_sid is missing from object`)

		return nil, diags
	}

	twilioSidVal, ok := twilioSidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`twilio_sid expected to be basetypes.StringValue, was: %T`, twilioSidAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PortalValue{
		AllowWlanIdRoam:             allowWlanIdRoamVal,
		AmazonClientId:              amazonClientIdVal,
		AmazonClientSecret:          amazonClientSecretVal,
		AmazonEmailDomains:          amazonEmailDomainsVal,
		AmazonEnabled:               amazonEnabledVal,
		AmazonExpire:                amazonExpireVal,
		Auth:                        authVal,
		AzureClientId:               azureClientIdVal,
		AzureClientSecret:           azureClientSecretVal,
		AzureEnabled:                azureEnabledVal,
		AzureExpire:                 azureExpireVal,
		AzureTenantId:               azureTenantIdVal,
		BroadnetPassword:            broadnetPasswordVal,
		BroadnetSid:                 broadnetSidVal,
		BroadnetUserId:              broadnetUserIdVal,
		BypassWhenCloudDown:         bypassWhenCloudDownVal,
		ClickatellApiKey:            clickatellApiKeyVal,
		CrossSite:                   crossSiteVal,
		EmailEnabled:                emailEnabledVal,
		Enabled:                     enabledVal,
		Expire:                      expireVal,
		ExternalPortalUrl:           externalPortalUrlVal,
		FacebookClientId:            facebookClientIdVal,
		FacebookClientSecret:        facebookClientSecretVal,
		FacebookEmailDomains:        facebookEmailDomainsVal,
		FacebookEnabled:             facebookEnabledVal,
		FacebookExpire:              facebookExpireVal,
		Forward:                     forwardVal,
		ForwardUrl:                  forwardUrlVal,
		GoogleClientId:              googleClientIdVal,
		GoogleClientSecret:          googleClientSecretVal,
		GoogleEmailDomains:          googleEmailDomainsVal,
		GoogleEnabled:               googleEnabledVal,
		GoogleExpire:                googleExpireVal,
		GupshupPassword:             gupshupPasswordVal,
		GupshupUserid:               gupshupUseridVal,
		MicrosoftClientId:           microsoftClientIdVal,
		MicrosoftClientSecret:       microsoftClientSecretVal,
		MicrosoftEmailDomains:       microsoftEmailDomainsVal,
		MicrosoftEnabled:            microsoftEnabledVal,
		MicrosoftExpire:             microsoftExpireVal,
		PassphraseEnabled:           passphraseEnabledVal,
		PassphraseExpire:            passphraseExpireVal,
		Password:                    passwordVal,
		PredefinedSponsorsEnabled:   predefinedSponsorsEnabledVal,
		PredefinedSponsorsHideEmail: predefinedSponsorsHideEmailVal,
		Privacy:                     privacyVal,
		PuzzelPassword:              puzzelPasswordVal,
		PuzzelServiceId:             puzzelServiceIdVal,
		PuzzelUsername:              puzzelUsernameVal,
		SmsEnabled:                  smsEnabledVal,
		SmsExpire:                   smsExpireVal,
		SmsMessageFormat:            smsMessageFormatVal,
		SmsProvider:                 smsProviderVal,
		SponsorAutoApprove:          sponsorAutoApproveVal,
		SponsorEmailDomains:         sponsorEmailDomainsVal,
		SponsorEnabled:              sponsorEnabledVal,
		SponsorExpire:               sponsorExpireVal,
		SponsorLinkValidityDuration: sponsorLinkValidityDurationVal,
		SponsorNotifyAll:            sponsorNotifyAllVal,
		SponsorStatusNotify:         sponsorStatusNotifyVal,
		Sponsors:                    sponsorsVal,
		SsoDefaultRole:              ssoDefaultRoleVal,
		SsoForcedRole:               ssoForcedRoleVal,
		SsoIdpCert:                  ssoIdpCertVal,
		SsoIdpSignAlgo:              ssoIdpSignAlgoVal,
		SsoIdpSsoUrl:                ssoIdpSsoUrlVal,
		SsoIssuer:                   ssoIssuerVal,
		SsoNameidFormat:             ssoNameidFormatVal,
		TelstraClientId:             telstraClientIdVal,
		TelstraClientSecret:         telstraClientSecretVal,
		TwilioAuthToken:             twilioAuthTokenVal,
		TwilioPhoneNumber:           twilioPhoneNumberVal,
		TwilioSid:                   twilioSidVal,
		state:                       attr.ValueStateKnown,
	}, diags
}

func NewPortalValueNull() PortalValue {
	return PortalValue{
		state: attr.ValueStateNull,
	}
}

func NewPortalValueUnknown() PortalValue {
	return PortalValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPortalValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PortalValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PortalValue Attribute Value",
				"While creating a PortalValue value, a missing attribute value was detected. "+
					"A PortalValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PortalValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PortalValue Attribute Type",
				"While creating a PortalValue value, an invalid attribute value was detected. "+
					"A PortalValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PortalValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PortalValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PortalValue Attribute Value",
				"While creating a PortalValue value, an extra attribute value was detected. "+
					"A PortalValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PortalValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPortalValueUnknown(), diags
	}

	allowWlanIdRoamAttribute, ok := attributes["allow_wlan_id_roam"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allow_wlan_id_roam is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	allowWlanIdRoamVal, ok := allowWlanIdRoamAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allow_wlan_id_roam expected to be basetypes.BoolValue, was: %T`, allowWlanIdRoamAttribute))
	}

	amazonClientIdAttribute, ok := attributes["amazon_client_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`amazon_client_id is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	amazonClientIdVal, ok := amazonClientIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`amazon_client_id expected to be basetypes.StringValue, was: %T`, amazonClientIdAttribute))
	}

	amazonClientSecretAttribute, ok := attributes["amazon_client_secret"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`amazon_client_secret is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	amazonClientSecretVal, ok := amazonClientSecretAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`amazon_client_secret expected to be basetypes.StringValue, was: %T`, amazonClientSecretAttribute))
	}

	amazonEmailDomainsAttribute, ok := attributes["amazon_email_domains"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`amazon_email_domains is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	amazonEmailDomainsVal, ok := amazonEmailDomainsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`amazon_email_domains expected to be basetypes.ListValue, was: %T`, amazonEmailDomainsAttribute))
	}

	amazonEnabledAttribute, ok := attributes["amazon_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`amazon_enabled is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	amazonEnabledVal, ok := amazonEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`amazon_enabled expected to be basetypes.BoolValue, was: %T`, amazonEnabledAttribute))
	}

	amazonExpireAttribute, ok := attributes["amazon_expire"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`amazon_expire is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	amazonExpireVal, ok := amazonExpireAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`amazon_expire expected to be basetypes.Int64Value, was: %T`, amazonExpireAttribute))
	}

	authAttribute, ok := attributes["auth"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auth is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	authVal, ok := authAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auth expected to be basetypes.StringValue, was: %T`, authAttribute))
	}

	azureClientIdAttribute, ok := attributes["azure_client_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`azure_client_id is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	azureClientIdVal, ok := azureClientIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`azure_client_id expected to be basetypes.StringValue, was: %T`, azureClientIdAttribute))
	}

	azureClientSecretAttribute, ok := attributes["azure_client_secret"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`azure_client_secret is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	azureClientSecretVal, ok := azureClientSecretAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`azure_client_secret expected to be basetypes.StringValue, was: %T`, azureClientSecretAttribute))
	}

	azureEnabledAttribute, ok := attributes["azure_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`azure_enabled is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	azureEnabledVal, ok := azureEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`azure_enabled expected to be basetypes.BoolValue, was: %T`, azureEnabledAttribute))
	}

	azureExpireAttribute, ok := attributes["azure_expire"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`azure_expire is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	azureExpireVal, ok := azureExpireAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`azure_expire expected to be basetypes.Int64Value, was: %T`, azureExpireAttribute))
	}

	azureTenantIdAttribute, ok := attributes["azure_tenant_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`azure_tenant_id is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	azureTenantIdVal, ok := azureTenantIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`azure_tenant_id expected to be basetypes.StringValue, was: %T`, azureTenantIdAttribute))
	}

	broadnetPasswordAttribute, ok := attributes["broadnet_password"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`broadnet_password is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	broadnetPasswordVal, ok := broadnetPasswordAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`broadnet_password expected to be basetypes.StringValue, was: %T`, broadnetPasswordAttribute))
	}

	broadnetSidAttribute, ok := attributes["broadnet_sid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`broadnet_sid is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	broadnetSidVal, ok := broadnetSidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`broadnet_sid expected to be basetypes.StringValue, was: %T`, broadnetSidAttribute))
	}

	broadnetUserIdAttribute, ok := attributes["broadnet_user_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`broadnet_user_id is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	broadnetUserIdVal, ok := broadnetUserIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`broadnet_user_id expected to be basetypes.StringValue, was: %T`, broadnetUserIdAttribute))
	}

	bypassWhenCloudDownAttribute, ok := attributes["bypass_when_cloud_down"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bypass_when_cloud_down is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	bypassWhenCloudDownVal, ok := bypassWhenCloudDownAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bypass_when_cloud_down expected to be basetypes.BoolValue, was: %T`, bypassWhenCloudDownAttribute))
	}

	clickatellApiKeyAttribute, ok := attributes["clickatell_api_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`clickatell_api_key is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	clickatellApiKeyVal, ok := clickatellApiKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`clickatell_api_key expected to be basetypes.StringValue, was: %T`, clickatellApiKeyAttribute))
	}

	crossSiteAttribute, ok := attributes["cross_site"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cross_site is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	crossSiteVal, ok := crossSiteAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cross_site expected to be basetypes.BoolValue, was: %T`, crossSiteAttribute))
	}

	emailEnabledAttribute, ok := attributes["email_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`email_enabled is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	emailEnabledVal, ok := emailEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`email_enabled expected to be basetypes.BoolValue, was: %T`, emailEnabledAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	expireAttribute, ok := attributes["expire"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`expire is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	expireVal, ok := expireAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`expire expected to be basetypes.Int64Value, was: %T`, expireAttribute))
	}

	externalPortalUrlAttribute, ok := attributes["external_portal_url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`external_portal_url is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	externalPortalUrlVal, ok := externalPortalUrlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`external_portal_url expected to be basetypes.StringValue, was: %T`, externalPortalUrlAttribute))
	}

	facebookClientIdAttribute, ok := attributes["facebook_client_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`facebook_client_id is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	facebookClientIdVal, ok := facebookClientIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`facebook_client_id expected to be basetypes.StringValue, was: %T`, facebookClientIdAttribute))
	}

	facebookClientSecretAttribute, ok := attributes["facebook_client_secret"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`facebook_client_secret is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	facebookClientSecretVal, ok := facebookClientSecretAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`facebook_client_secret expected to be basetypes.StringValue, was: %T`, facebookClientSecretAttribute))
	}

	facebookEmailDomainsAttribute, ok := attributes["facebook_email_domains"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`facebook_email_domains is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	facebookEmailDomainsVal, ok := facebookEmailDomainsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`facebook_email_domains expected to be basetypes.ListValue, was: %T`, facebookEmailDomainsAttribute))
	}

	facebookEnabledAttribute, ok := attributes["facebook_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`facebook_enabled is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	facebookEnabledVal, ok := facebookEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`facebook_enabled expected to be basetypes.BoolValue, was: %T`, facebookEnabledAttribute))
	}

	facebookExpireAttribute, ok := attributes["facebook_expire"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`facebook_expire is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	facebookExpireVal, ok := facebookExpireAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`facebook_expire expected to be basetypes.Int64Value, was: %T`, facebookExpireAttribute))
	}

	forwardAttribute, ok := attributes["forward"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`forward is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	forwardVal, ok := forwardAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`forward expected to be basetypes.BoolValue, was: %T`, forwardAttribute))
	}

	forwardUrlAttribute, ok := attributes["forward_url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`forward_url is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	forwardUrlVal, ok := forwardUrlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`forward_url expected to be basetypes.StringValue, was: %T`, forwardUrlAttribute))
	}

	googleClientIdAttribute, ok := attributes["google_client_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`google_client_id is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	googleClientIdVal, ok := googleClientIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`google_client_id expected to be basetypes.StringValue, was: %T`, googleClientIdAttribute))
	}

	googleClientSecretAttribute, ok := attributes["google_client_secret"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`google_client_secret is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	googleClientSecretVal, ok := googleClientSecretAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`google_client_secret expected to be basetypes.StringValue, was: %T`, googleClientSecretAttribute))
	}

	googleEmailDomainsAttribute, ok := attributes["google_email_domains"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`google_email_domains is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	googleEmailDomainsVal, ok := googleEmailDomainsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`google_email_domains expected to be basetypes.ListValue, was: %T`, googleEmailDomainsAttribute))
	}

	googleEnabledAttribute, ok := attributes["google_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`google_enabled is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	googleEnabledVal, ok := googleEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`google_enabled expected to be basetypes.BoolValue, was: %T`, googleEnabledAttribute))
	}

	googleExpireAttribute, ok := attributes["google_expire"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`google_expire is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	googleExpireVal, ok := googleExpireAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`google_expire expected to be basetypes.Int64Value, was: %T`, googleExpireAttribute))
	}

	gupshupPasswordAttribute, ok := attributes["gupshup_password"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gupshup_password is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	gupshupPasswordVal, ok := gupshupPasswordAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gupshup_password expected to be basetypes.StringValue, was: %T`, gupshupPasswordAttribute))
	}

	gupshupUseridAttribute, ok := attributes["gupshup_userid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gupshup_userid is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	gupshupUseridVal, ok := gupshupUseridAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gupshup_userid expected to be basetypes.StringValue, was: %T`, gupshupUseridAttribute))
	}

	microsoftClientIdAttribute, ok := attributes["microsoft_client_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`microsoft_client_id is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	microsoftClientIdVal, ok := microsoftClientIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`microsoft_client_id expected to be basetypes.StringValue, was: %T`, microsoftClientIdAttribute))
	}

	microsoftClientSecretAttribute, ok := attributes["microsoft_client_secret"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`microsoft_client_secret is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	microsoftClientSecretVal, ok := microsoftClientSecretAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`microsoft_client_secret expected to be basetypes.StringValue, was: %T`, microsoftClientSecretAttribute))
	}

	microsoftEmailDomainsAttribute, ok := attributes["microsoft_email_domains"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`microsoft_email_domains is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	microsoftEmailDomainsVal, ok := microsoftEmailDomainsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`microsoft_email_domains expected to be basetypes.ListValue, was: %T`, microsoftEmailDomainsAttribute))
	}

	microsoftEnabledAttribute, ok := attributes["microsoft_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`microsoft_enabled is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	microsoftEnabledVal, ok := microsoftEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`microsoft_enabled expected to be basetypes.BoolValue, was: %T`, microsoftEnabledAttribute))
	}

	microsoftExpireAttribute, ok := attributes["microsoft_expire"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`microsoft_expire is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	microsoftExpireVal, ok := microsoftExpireAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`microsoft_expire expected to be basetypes.Int64Value, was: %T`, microsoftExpireAttribute))
	}

	passphraseEnabledAttribute, ok := attributes["passphrase_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`passphrase_enabled is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	passphraseEnabledVal, ok := passphraseEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`passphrase_enabled expected to be basetypes.BoolValue, was: %T`, passphraseEnabledAttribute))
	}

	passphraseExpireAttribute, ok := attributes["passphrase_expire"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`passphrase_expire is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	passphraseExpireVal, ok := passphraseExpireAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`passphrase_expire expected to be basetypes.Int64Value, was: %T`, passphraseExpireAttribute))
	}

	passwordAttribute, ok := attributes["password"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`password is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	passwordVal, ok := passwordAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`password expected to be basetypes.StringValue, was: %T`, passwordAttribute))
	}

	predefinedSponsorsEnabledAttribute, ok := attributes["predefined_sponsors_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`predefined_sponsors_enabled is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	predefinedSponsorsEnabledVal, ok := predefinedSponsorsEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`predefined_sponsors_enabled expected to be basetypes.BoolValue, was: %T`, predefinedSponsorsEnabledAttribute))
	}

	predefinedSponsorsHideEmailAttribute, ok := attributes["predefined_sponsors_hide_email"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`predefined_sponsors_hide_email is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	predefinedSponsorsHideEmailVal, ok := predefinedSponsorsHideEmailAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`predefined_sponsors_hide_email expected to be basetypes.BoolValue, was: %T`, predefinedSponsorsHideEmailAttribute))
	}

	privacyAttribute, ok := attributes["privacy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`privacy is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	privacyVal, ok := privacyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`privacy expected to be basetypes.BoolValue, was: %T`, privacyAttribute))
	}

	puzzelPasswordAttribute, ok := attributes["puzzel_password"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`puzzel_password is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	puzzelPasswordVal, ok := puzzelPasswordAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`puzzel_password expected to be basetypes.StringValue, was: %T`, puzzelPasswordAttribute))
	}

	puzzelServiceIdAttribute, ok := attributes["puzzel_service_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`puzzel_service_id is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	puzzelServiceIdVal, ok := puzzelServiceIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`puzzel_service_id expected to be basetypes.StringValue, was: %T`, puzzelServiceIdAttribute))
	}

	puzzelUsernameAttribute, ok := attributes["puzzel_username"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`puzzel_username is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	puzzelUsernameVal, ok := puzzelUsernameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`puzzel_username expected to be basetypes.StringValue, was: %T`, puzzelUsernameAttribute))
	}

	smsEnabledAttribute, ok := attributes["sms_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sms_enabled is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	smsEnabledVal, ok := smsEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sms_enabled expected to be basetypes.BoolValue, was: %T`, smsEnabledAttribute))
	}

	smsExpireAttribute, ok := attributes["sms_expire"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sms_expire is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	smsExpireVal, ok := smsExpireAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sms_expire expected to be basetypes.Int64Value, was: %T`, smsExpireAttribute))
	}

	smsMessageFormatAttribute, ok := attributes["sms_message_format"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sms_message_format is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	smsMessageFormatVal, ok := smsMessageFormatAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sms_message_format expected to be basetypes.StringValue, was: %T`, smsMessageFormatAttribute))
	}

	smsProviderAttribute, ok := attributes["sms_provider"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sms_provider is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	smsProviderVal, ok := smsProviderAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sms_provider expected to be basetypes.StringValue, was: %T`, smsProviderAttribute))
	}

	sponsorAutoApproveAttribute, ok := attributes["sponsor_auto_approve"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sponsor_auto_approve is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	sponsorAutoApproveVal, ok := sponsorAutoApproveAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sponsor_auto_approve expected to be basetypes.BoolValue, was: %T`, sponsorAutoApproveAttribute))
	}

	sponsorEmailDomainsAttribute, ok := attributes["sponsor_email_domains"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sponsor_email_domains is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	sponsorEmailDomainsVal, ok := sponsorEmailDomainsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sponsor_email_domains expected to be basetypes.ListValue, was: %T`, sponsorEmailDomainsAttribute))
	}

	sponsorEnabledAttribute, ok := attributes["sponsor_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sponsor_enabled is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	sponsorEnabledVal, ok := sponsorEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sponsor_enabled expected to be basetypes.BoolValue, was: %T`, sponsorEnabledAttribute))
	}

	sponsorExpireAttribute, ok := attributes["sponsor_expire"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sponsor_expire is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	sponsorExpireVal, ok := sponsorExpireAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sponsor_expire expected to be basetypes.Int64Value, was: %T`, sponsorExpireAttribute))
	}

	sponsorLinkValidityDurationAttribute, ok := attributes["sponsor_link_validity_duration"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sponsor_link_validity_duration is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	sponsorLinkValidityDurationVal, ok := sponsorLinkValidityDurationAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sponsor_link_validity_duration expected to be basetypes.StringValue, was: %T`, sponsorLinkValidityDurationAttribute))
	}

	sponsorNotifyAllAttribute, ok := attributes["sponsor_notify_all"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sponsor_notify_all is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	sponsorNotifyAllVal, ok := sponsorNotifyAllAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sponsor_notify_all expected to be basetypes.BoolValue, was: %T`, sponsorNotifyAllAttribute))
	}

	sponsorStatusNotifyAttribute, ok := attributes["sponsor_status_notify"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sponsor_status_notify is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	sponsorStatusNotifyVal, ok := sponsorStatusNotifyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sponsor_status_notify expected to be basetypes.BoolValue, was: %T`, sponsorStatusNotifyAttribute))
	}

	sponsorsAttribute, ok := attributes["sponsors"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sponsors is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	sponsorsVal, ok := sponsorsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sponsors expected to be basetypes.MapValue, was: %T`, sponsorsAttribute))
	}

	ssoDefaultRoleAttribute, ok := attributes["sso_default_role"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sso_default_role is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	ssoDefaultRoleVal, ok := ssoDefaultRoleAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sso_default_role expected to be basetypes.StringValue, was: %T`, ssoDefaultRoleAttribute))
	}

	ssoForcedRoleAttribute, ok := attributes["sso_forced_role"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sso_forced_role is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	ssoForcedRoleVal, ok := ssoForcedRoleAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sso_forced_role expected to be basetypes.StringValue, was: %T`, ssoForcedRoleAttribute))
	}

	ssoIdpCertAttribute, ok := attributes["sso_idp_cert"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sso_idp_cert is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	ssoIdpCertVal, ok := ssoIdpCertAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sso_idp_cert expected to be basetypes.StringValue, was: %T`, ssoIdpCertAttribute))
	}

	ssoIdpSignAlgoAttribute, ok := attributes["sso_idp_sign_algo"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sso_idp_sign_algo is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	ssoIdpSignAlgoVal, ok := ssoIdpSignAlgoAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sso_idp_sign_algo expected to be basetypes.StringValue, was: %T`, ssoIdpSignAlgoAttribute))
	}

	ssoIdpSsoUrlAttribute, ok := attributes["sso_idp_sso_url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sso_idp_sso_url is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	ssoIdpSsoUrlVal, ok := ssoIdpSsoUrlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sso_idp_sso_url expected to be basetypes.StringValue, was: %T`, ssoIdpSsoUrlAttribute))
	}

	ssoIssuerAttribute, ok := attributes["sso_issuer"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sso_issuer is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	ssoIssuerVal, ok := ssoIssuerAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sso_issuer expected to be basetypes.StringValue, was: %T`, ssoIssuerAttribute))
	}

	ssoNameidFormatAttribute, ok := attributes["sso_nameid_format"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sso_nameid_format is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	ssoNameidFormatVal, ok := ssoNameidFormatAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sso_nameid_format expected to be basetypes.StringValue, was: %T`, ssoNameidFormatAttribute))
	}

	telstraClientIdAttribute, ok := attributes["telstra_client_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`telstra_client_id is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	telstraClientIdVal, ok := telstraClientIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`telstra_client_id expected to be basetypes.StringValue, was: %T`, telstraClientIdAttribute))
	}

	telstraClientSecretAttribute, ok := attributes["telstra_client_secret"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`telstra_client_secret is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	telstraClientSecretVal, ok := telstraClientSecretAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`telstra_client_secret expected to be basetypes.StringValue, was: %T`, telstraClientSecretAttribute))
	}

	twilioAuthTokenAttribute, ok := attributes["twilio_auth_token"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`twilio_auth_token is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	twilioAuthTokenVal, ok := twilioAuthTokenAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`twilio_auth_token expected to be basetypes.StringValue, was: %T`, twilioAuthTokenAttribute))
	}

	twilioPhoneNumberAttribute, ok := attributes["twilio_phone_number"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`twilio_phone_number is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	twilioPhoneNumberVal, ok := twilioPhoneNumberAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`twilio_phone_number expected to be basetypes.StringValue, was: %T`, twilioPhoneNumberAttribute))
	}

	twilioSidAttribute, ok := attributes["twilio_sid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`twilio_sid is missing from object`)

		return NewPortalValueUnknown(), diags
	}

	twilioSidVal, ok := twilioSidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`twilio_sid expected to be basetypes.StringValue, was: %T`, twilioSidAttribute))
	}

	if diags.HasError() {
		return NewPortalValueUnknown(), diags
	}

	return PortalValue{
		AllowWlanIdRoam:             allowWlanIdRoamVal,
		AmazonClientId:              amazonClientIdVal,
		AmazonClientSecret:          amazonClientSecretVal,
		AmazonEmailDomains:          amazonEmailDomainsVal,
		AmazonEnabled:               amazonEnabledVal,
		AmazonExpire:                amazonExpireVal,
		Auth:                        authVal,
		AzureClientId:               azureClientIdVal,
		AzureClientSecret:           azureClientSecretVal,
		AzureEnabled:                azureEnabledVal,
		AzureExpire:                 azureExpireVal,
		AzureTenantId:               azureTenantIdVal,
		BroadnetPassword:            broadnetPasswordVal,
		BroadnetSid:                 broadnetSidVal,
		BroadnetUserId:              broadnetUserIdVal,
		BypassWhenCloudDown:         bypassWhenCloudDownVal,
		ClickatellApiKey:            clickatellApiKeyVal,
		CrossSite:                   crossSiteVal,
		EmailEnabled:                emailEnabledVal,
		Enabled:                     enabledVal,
		Expire:                      expireVal,
		ExternalPortalUrl:           externalPortalUrlVal,
		FacebookClientId:            facebookClientIdVal,
		FacebookClientSecret:        facebookClientSecretVal,
		FacebookEmailDomains:        facebookEmailDomainsVal,
		FacebookEnabled:             facebookEnabledVal,
		FacebookExpire:              facebookExpireVal,
		Forward:                     forwardVal,
		ForwardUrl:                  forwardUrlVal,
		GoogleClientId:              googleClientIdVal,
		GoogleClientSecret:          googleClientSecretVal,
		GoogleEmailDomains:          googleEmailDomainsVal,
		GoogleEnabled:               googleEnabledVal,
		GoogleExpire:                googleExpireVal,
		GupshupPassword:             gupshupPasswordVal,
		GupshupUserid:               gupshupUseridVal,
		MicrosoftClientId:           microsoftClientIdVal,
		MicrosoftClientSecret:       microsoftClientSecretVal,
		MicrosoftEmailDomains:       microsoftEmailDomainsVal,
		MicrosoftEnabled:            microsoftEnabledVal,
		MicrosoftExpire:             microsoftExpireVal,
		PassphraseEnabled:           passphraseEnabledVal,
		PassphraseExpire:            passphraseExpireVal,
		Password:                    passwordVal,
		PredefinedSponsorsEnabled:   predefinedSponsorsEnabledVal,
		PredefinedSponsorsHideEmail: predefinedSponsorsHideEmailVal,
		Privacy:                     privacyVal,
		PuzzelPassword:              puzzelPasswordVal,
		PuzzelServiceId:             puzzelServiceIdVal,
		PuzzelUsername:              puzzelUsernameVal,
		SmsEnabled:                  smsEnabledVal,
		SmsExpire:                   smsExpireVal,
		SmsMessageFormat:            smsMessageFormatVal,
		SmsProvider:                 smsProviderVal,
		SponsorAutoApprove:          sponsorAutoApproveVal,
		SponsorEmailDomains:         sponsorEmailDomainsVal,
		SponsorEnabled:              sponsorEnabledVal,
		SponsorExpire:               sponsorExpireVal,
		SponsorLinkValidityDuration: sponsorLinkValidityDurationVal,
		SponsorNotifyAll:            sponsorNotifyAllVal,
		SponsorStatusNotify:         sponsorStatusNotifyVal,
		Sponsors:                    sponsorsVal,
		SsoDefaultRole:              ssoDefaultRoleVal,
		SsoForcedRole:               ssoForcedRoleVal,
		SsoIdpCert:                  ssoIdpCertVal,
		SsoIdpSignAlgo:              ssoIdpSignAlgoVal,
		SsoIdpSsoUrl:                ssoIdpSsoUrlVal,
		SsoIssuer:                   ssoIssuerVal,
		SsoNameidFormat:             ssoNameidFormatVal,
		TelstraClientId:             telstraClientIdVal,
		TelstraClientSecret:         telstraClientSecretVal,
		TwilioAuthToken:             twilioAuthTokenVal,
		TwilioPhoneNumber:           twilioPhoneNumberVal,
		TwilioSid:                   twilioSidVal,
		state:                       attr.ValueStateKnown,
	}, diags
}

func NewPortalValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PortalValue {
	object, diags := NewPortalValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPortalValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PortalType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPortalValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPortalValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPortalValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPortalValueMust(PortalValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PortalType) ValueType(ctx context.Context) attr.Value {
	return PortalValue{}
}

var _ basetypes.ObjectValuable = PortalValue{}

type PortalValue struct {
	AllowWlanIdRoam             basetypes.BoolValue   `tfsdk:"allow_wlan_id_roam"`
	AmazonClientId              basetypes.StringValue `tfsdk:"amazon_client_id"`
	AmazonClientSecret          basetypes.StringValue `tfsdk:"amazon_client_secret"`
	AmazonEmailDomains          basetypes.ListValue   `tfsdk:"amazon_email_domains"`
	AmazonEnabled               basetypes.BoolValue   `tfsdk:"amazon_enabled"`
	AmazonExpire                basetypes.Int64Value  `tfsdk:"amazon_expire"`
	Auth                        basetypes.StringValue `tfsdk:"auth"`
	AzureClientId               basetypes.StringValue `tfsdk:"azure_client_id"`
	AzureClientSecret           basetypes.StringValue `tfsdk:"azure_client_secret"`
	AzureEnabled                basetypes.BoolValue   `tfsdk:"azure_enabled"`
	AzureExpire                 basetypes.Int64Value  `tfsdk:"azure_expire"`
	AzureTenantId               basetypes.StringValue `tfsdk:"azure_tenant_id"`
	BroadnetPassword            basetypes.StringValue `tfsdk:"broadnet_password"`
	BroadnetSid                 basetypes.StringValue `tfsdk:"broadnet_sid"`
	BroadnetUserId              basetypes.StringValue `tfsdk:"broadnet_user_id"`
	BypassWhenCloudDown         basetypes.BoolValue   `tfsdk:"bypass_when_cloud_down"`
	ClickatellApiKey            basetypes.StringValue `tfsdk:"clickatell_api_key"`
	CrossSite                   basetypes.BoolValue   `tfsdk:"cross_site"`
	EmailEnabled                basetypes.BoolValue   `tfsdk:"email_enabled"`
	Enabled                     basetypes.BoolValue   `tfsdk:"enabled"`
	Expire                      basetypes.Int64Value  `tfsdk:"expire"`
	ExternalPortalUrl           basetypes.StringValue `tfsdk:"external_portal_url"`
	FacebookClientId            basetypes.StringValue `tfsdk:"facebook_client_id"`
	FacebookClientSecret        basetypes.StringValue `tfsdk:"facebook_client_secret"`
	FacebookEmailDomains        basetypes.ListValue   `tfsdk:"facebook_email_domains"`
	FacebookEnabled             basetypes.BoolValue   `tfsdk:"facebook_enabled"`
	FacebookExpire              basetypes.Int64Value  `tfsdk:"facebook_expire"`
	Forward                     basetypes.BoolValue   `tfsdk:"forward"`
	ForwardUrl                  basetypes.StringValue `tfsdk:"forward_url"`
	GoogleClientId              basetypes.StringValue `tfsdk:"google_client_id"`
	GoogleClientSecret          basetypes.StringValue `tfsdk:"google_client_secret"`
	GoogleEmailDomains          basetypes.ListValue   `tfsdk:"google_email_domains"`
	GoogleEnabled               basetypes.BoolValue   `tfsdk:"google_enabled"`
	GoogleExpire                basetypes.Int64Value  `tfsdk:"google_expire"`
	GupshupPassword             basetypes.StringValue `tfsdk:"gupshup_password"`
	GupshupUserid               basetypes.StringValue `tfsdk:"gupshup_userid"`
	MicrosoftClientId           basetypes.StringValue `tfsdk:"microsoft_client_id"`
	MicrosoftClientSecret       basetypes.StringValue `tfsdk:"microsoft_client_secret"`
	MicrosoftEmailDomains       basetypes.ListValue   `tfsdk:"microsoft_email_domains"`
	MicrosoftEnabled            basetypes.BoolValue   `tfsdk:"microsoft_enabled"`
	MicrosoftExpire             basetypes.Int64Value  `tfsdk:"microsoft_expire"`
	PassphraseEnabled           basetypes.BoolValue   `tfsdk:"passphrase_enabled"`
	PassphraseExpire            basetypes.Int64Value  `tfsdk:"passphrase_expire"`
	Password                    basetypes.StringValue `tfsdk:"password"`
	PredefinedSponsorsEnabled   basetypes.BoolValue   `tfsdk:"predefined_sponsors_enabled"`
	PredefinedSponsorsHideEmail basetypes.BoolValue   `tfsdk:"predefined_sponsors_hide_email"`
	Privacy                     basetypes.BoolValue   `tfsdk:"privacy"`
	PuzzelPassword              basetypes.StringValue `tfsdk:"puzzel_password"`
	PuzzelServiceId             basetypes.StringValue `tfsdk:"puzzel_service_id"`
	PuzzelUsername              basetypes.StringValue `tfsdk:"puzzel_username"`
	SmsEnabled                  basetypes.BoolValue   `tfsdk:"sms_enabled"`
	SmsExpire                   basetypes.Int64Value  `tfsdk:"sms_expire"`
	SmsMessageFormat            basetypes.StringValue `tfsdk:"sms_message_format"`
	SmsProvider                 basetypes.StringValue `tfsdk:"sms_provider"`
	SponsorAutoApprove          basetypes.BoolValue   `tfsdk:"sponsor_auto_approve"`
	SponsorEmailDomains         basetypes.ListValue   `tfsdk:"sponsor_email_domains"`
	SponsorEnabled              basetypes.BoolValue   `tfsdk:"sponsor_enabled"`
	SponsorExpire               basetypes.Int64Value  `tfsdk:"sponsor_expire"`
	SponsorLinkValidityDuration basetypes.StringValue `tfsdk:"sponsor_link_validity_duration"`
	SponsorNotifyAll            basetypes.BoolValue   `tfsdk:"sponsor_notify_all"`
	SponsorStatusNotify         basetypes.BoolValue   `tfsdk:"sponsor_status_notify"`
	Sponsors                    basetypes.MapValue    `tfsdk:"sponsors"`
	SsoDefaultRole              basetypes.StringValue `tfsdk:"sso_default_role"`
	SsoForcedRole               basetypes.StringValue `tfsdk:"sso_forced_role"`
	SsoIdpCert                  basetypes.StringValue `tfsdk:"sso_idp_cert"`
	SsoIdpSignAlgo              basetypes.StringValue `tfsdk:"sso_idp_sign_algo"`
	SsoIdpSsoUrl                basetypes.StringValue `tfsdk:"sso_idp_sso_url"`
	SsoIssuer                   basetypes.StringValue `tfsdk:"sso_issuer"`
	SsoNameidFormat             basetypes.StringValue `tfsdk:"sso_nameid_format"`
	TelstraClientId             basetypes.StringValue `tfsdk:"telstra_client_id"`
	TelstraClientSecret         basetypes.StringValue `tfsdk:"telstra_client_secret"`
	TwilioAuthToken             basetypes.StringValue `tfsdk:"twilio_auth_token"`
	TwilioPhoneNumber           basetypes.StringValue `tfsdk:"twilio_phone_number"`
	TwilioSid                   basetypes.StringValue `tfsdk:"twilio_sid"`
	state                       attr.ValueState
}

func (v PortalValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 74)

	var val tftypes.Value
	var err error

	attrTypes["allow_wlan_id_roam"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["amazon_client_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["amazon_client_secret"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["amazon_email_domains"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["amazon_enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["amazon_expire"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["auth"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["azure_client_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["azure_client_secret"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["azure_enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["azure_expire"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["azure_tenant_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["broadnet_password"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["broadnet_sid"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["broadnet_user_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["bypass_when_cloud_down"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["clickatell_api_key"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["cross_site"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["email_enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["expire"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["external_portal_url"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["facebook_client_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["facebook_client_secret"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["facebook_email_domains"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["facebook_enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["facebook_expire"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["forward"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["forward_url"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["google_client_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["google_client_secret"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["google_email_domains"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["google_enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["google_expire"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["gupshup_password"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["gupshup_userid"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["microsoft_client_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["microsoft_client_secret"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["microsoft_email_domains"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["microsoft_enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["microsoft_expire"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["passphrase_enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["passphrase_expire"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["password"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["predefined_sponsors_enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["predefined_sponsors_hide_email"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["privacy"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["puzzel_password"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["puzzel_service_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["puzzel_username"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["sms_enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["sms_expire"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["sms_message_format"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["sms_provider"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["sponsor_auto_approve"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["sponsor_email_domains"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["sponsor_enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["sponsor_expire"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["sponsor_link_validity_duration"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["sponsor_notify_all"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["sponsor_status_notify"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["sponsors"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["sso_default_role"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["sso_forced_role"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["sso_idp_cert"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["sso_idp_sign_algo"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["sso_idp_sso_url"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["sso_issuer"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["sso_nameid_format"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["telstra_client_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["telstra_client_secret"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["twilio_auth_token"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["twilio_phone_number"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["twilio_sid"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 74)

		val, err = v.AllowWlanIdRoam.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["allow_wlan_id_roam"] = val

		val, err = v.AmazonClientId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["amazon_client_id"] = val

		val, err = v.AmazonClientSecret.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["amazon_client_secret"] = val

		val, err = v.AmazonEmailDomains.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["amazon_email_domains"] = val

		val, err = v.AmazonEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["amazon_enabled"] = val

		val, err = v.AmazonExpire.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["amazon_expire"] = val

		val, err = v.Auth.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["auth"] = val

		val, err = v.AzureClientId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["azure_client_id"] = val

		val, err = v.AzureClientSecret.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["azure_client_secret"] = val

		val, err = v.AzureEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["azure_enabled"] = val

		val, err = v.AzureExpire.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["azure_expire"] = val

		val, err = v.AzureTenantId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["azure_tenant_id"] = val

		val, err = v.BroadnetPassword.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["broadnet_password"] = val

		val, err = v.BroadnetSid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["broadnet_sid"] = val

		val, err = v.BroadnetUserId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["broadnet_user_id"] = val

		val, err = v.BypassWhenCloudDown.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bypass_when_cloud_down"] = val

		val, err = v.ClickatellApiKey.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["clickatell_api_key"] = val

		val, err = v.CrossSite.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cross_site"] = val

		val, err = v.EmailEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["email_enabled"] = val

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.Expire.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["expire"] = val

		val, err = v.ExternalPortalUrl.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["external_portal_url"] = val

		val, err = v.FacebookClientId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["facebook_client_id"] = val

		val, err = v.FacebookClientSecret.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["facebook_client_secret"] = val

		val, err = v.FacebookEmailDomains.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["facebook_email_domains"] = val

		val, err = v.FacebookEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["facebook_enabled"] = val

		val, err = v.FacebookExpire.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["facebook_expire"] = val

		val, err = v.Forward.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["forward"] = val

		val, err = v.ForwardUrl.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["forward_url"] = val

		val, err = v.GoogleClientId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["google_client_id"] = val

		val, err = v.GoogleClientSecret.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["google_client_secret"] = val

		val, err = v.GoogleEmailDomains.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["google_email_domains"] = val

		val, err = v.GoogleEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["google_enabled"] = val

		val, err = v.GoogleExpire.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["google_expire"] = val

		val, err = v.GupshupPassword.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["gupshup_password"] = val

		val, err = v.GupshupUserid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["gupshup_userid"] = val

		val, err = v.MicrosoftClientId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["microsoft_client_id"] = val

		val, err = v.MicrosoftClientSecret.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["microsoft_client_secret"] = val

		val, err = v.MicrosoftEmailDomains.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["microsoft_email_domains"] = val

		val, err = v.MicrosoftEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["microsoft_enabled"] = val

		val, err = v.MicrosoftExpire.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["microsoft_expire"] = val

		val, err = v.PassphraseEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["passphrase_enabled"] = val

		val, err = v.PassphraseExpire.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["passphrase_expire"] = val

		val, err = v.Password.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["password"] = val

		val, err = v.PredefinedSponsorsEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["predefined_sponsors_enabled"] = val

		val, err = v.PredefinedSponsorsHideEmail.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["predefined_sponsors_hide_email"] = val

		val, err = v.Privacy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["privacy"] = val

		val, err = v.PuzzelPassword.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["puzzel_password"] = val

		val, err = v.PuzzelServiceId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["puzzel_service_id"] = val

		val, err = v.PuzzelUsername.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["puzzel_username"] = val

		val, err = v.SmsEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["sms_enabled"] = val

		val, err = v.SmsExpire.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["sms_expire"] = val

		val, err = v.SmsMessageFormat.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["sms_message_format"] = val

		val, err = v.SmsProvider.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["sms_provider"] = val

		val, err = v.SponsorAutoApprove.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["sponsor_auto_approve"] = val

		val, err = v.SponsorEmailDomains.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["sponsor_email_domains"] = val

		val, err = v.SponsorEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["sponsor_enabled"] = val

		val, err = v.SponsorExpire.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["sponsor_expire"] = val

		val, err = v.SponsorLinkValidityDuration.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["sponsor_link_validity_duration"] = val

		val, err = v.SponsorNotifyAll.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["sponsor_notify_all"] = val

		val, err = v.SponsorStatusNotify.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["sponsor_status_notify"] = val

		val, err = v.Sponsors.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["sponsors"] = val

		val, err = v.SsoDefaultRole.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["sso_default_role"] = val

		val, err = v.SsoForcedRole.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["sso_forced_role"] = val

		val, err = v.SsoIdpCert.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["sso_idp_cert"] = val

		val, err = v.SsoIdpSignAlgo.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["sso_idp_sign_algo"] = val

		val, err = v.SsoIdpSsoUrl.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["sso_idp_sso_url"] = val

		val, err = v.SsoIssuer.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["sso_issuer"] = val

		val, err = v.SsoNameidFormat.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["sso_nameid_format"] = val

		val, err = v.TelstraClientId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["telstra_client_id"] = val

		val, err = v.TelstraClientSecret.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["telstra_client_secret"] = val

		val, err = v.TwilioAuthToken.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["twilio_auth_token"] = val

		val, err = v.TwilioPhoneNumber.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["twilio_phone_number"] = val

		val, err = v.TwilioSid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["twilio_sid"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PortalValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PortalValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PortalValue) String() string {
	return "PortalValue"
}

func (v PortalValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	amazonEmailDomainsVal, d := types.ListValue(types.StringType, v.AmazonEmailDomains.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"allow_wlan_id_roam":   basetypes.BoolType{},
			"amazon_client_id":     basetypes.StringType{},
			"amazon_client_secret": basetypes.StringType{},
			"amazon_email_domains": basetypes.ListType{
				ElemType: types.StringType,
			},
			"amazon_enabled":         basetypes.BoolType{},
			"amazon_expire":          basetypes.Int64Type{},
			"auth":                   basetypes.StringType{},
			"azure_client_id":        basetypes.StringType{},
			"azure_client_secret":    basetypes.StringType{},
			"azure_enabled":          basetypes.BoolType{},
			"azure_expire":           basetypes.Int64Type{},
			"azure_tenant_id":        basetypes.StringType{},
			"broadnet_password":      basetypes.StringType{},
			"broadnet_sid":           basetypes.StringType{},
			"broadnet_user_id":       basetypes.StringType{},
			"bypass_when_cloud_down": basetypes.BoolType{},
			"clickatell_api_key":     basetypes.StringType{},
			"cross_site":             basetypes.BoolType{},
			"email_enabled":          basetypes.BoolType{},
			"enabled":                basetypes.BoolType{},
			"expire":                 basetypes.Int64Type{},
			"external_portal_url":    basetypes.StringType{},
			"facebook_client_id":     basetypes.StringType{},
			"facebook_client_secret": basetypes.StringType{},
			"facebook_email_domains": basetypes.ListType{
				ElemType: types.StringType,
			},
			"facebook_enabled":     basetypes.BoolType{},
			"facebook_expire":      basetypes.Int64Type{},
			"forward":              basetypes.BoolType{},
			"forward_url":          basetypes.StringType{},
			"google_client_id":     basetypes.StringType{},
			"google_client_secret": basetypes.StringType{},
			"google_email_domains": basetypes.ListType{
				ElemType: types.StringType,
			},
			"google_enabled":          basetypes.BoolType{},
			"google_expire":           basetypes.Int64Type{},
			"gupshup_password":        basetypes.StringType{},
			"gupshup_userid":          basetypes.StringType{},
			"microsoft_client_id":     basetypes.StringType{},
			"microsoft_client_secret": basetypes.StringType{},
			"microsoft_email_domains": basetypes.ListType{
				ElemType: types.StringType,
			},
			"microsoft_enabled":              basetypes.BoolType{},
			"microsoft_expire":               basetypes.Int64Type{},
			"passphrase_enabled":             basetypes.BoolType{},
			"passphrase_expire":              basetypes.Int64Type{},
			"password":                       basetypes.StringType{},
			"predefined_sponsors_enabled":    basetypes.BoolType{},
			"predefined_sponsors_hide_email": basetypes.BoolType{},
			"privacy":                        basetypes.BoolType{},
			"puzzel_password":                basetypes.StringType{},
			"puzzel_service_id":              basetypes.StringType{},
			"puzzel_username":                basetypes.StringType{},
			"sms_enabled":                    basetypes.BoolType{},
			"sms_expire":                     basetypes.Int64Type{},
			"sms_message_format":             basetypes.StringType{},
			"sms_provider":                   basetypes.StringType{},
			"sponsor_auto_approve":           basetypes.BoolType{},
			"sponsor_email_domains": basetypes.ListType{
				ElemType: types.StringType,
			},
			"sponsor_enabled":                basetypes.BoolType{},
			"sponsor_expire":                 basetypes.Int64Type{},
			"sponsor_link_validity_duration": basetypes.StringType{},
			"sponsor_notify_all":             basetypes.BoolType{},
			"sponsor_status_notify":          basetypes.BoolType{},
			"sponsors": basetypes.MapType{
				ElemType: types.StringType,
			},
			"sso_default_role":      basetypes.StringType{},
			"sso_forced_role":       basetypes.StringType{},
			"sso_idp_cert":          basetypes.StringType{},
			"sso_idp_sign_algo":     basetypes.StringType{},
			"sso_idp_sso_url":       basetypes.StringType{},
			"sso_issuer":            basetypes.StringType{},
			"sso_nameid_format":     basetypes.StringType{},
			"telstra_client_id":     basetypes.StringType{},
			"telstra_client_secret": basetypes.StringType{},
			"twilio_auth_token":     basetypes.StringType{},
			"twilio_phone_number":   basetypes.StringType{},
			"twilio_sid":            basetypes.StringType{},
		}), diags
	}

	facebookEmailDomainsVal, d := types.ListValue(types.StringType, v.FacebookEmailDomains.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"allow_wlan_id_roam":   basetypes.BoolType{},
			"amazon_client_id":     basetypes.StringType{},
			"amazon_client_secret": basetypes.StringType{},
			"amazon_email_domains": basetypes.ListType{
				ElemType: types.StringType,
			},
			"amazon_enabled":         basetypes.BoolType{},
			"amazon_expire":          basetypes.Int64Type{},
			"auth":                   basetypes.StringType{},
			"azure_client_id":        basetypes.StringType{},
			"azure_client_secret":    basetypes.StringType{},
			"azure_enabled":          basetypes.BoolType{},
			"azure_expire":           basetypes.Int64Type{},
			"azure_tenant_id":        basetypes.StringType{},
			"broadnet_password":      basetypes.StringType{},
			"broadnet_sid":           basetypes.StringType{},
			"broadnet_user_id":       basetypes.StringType{},
			"bypass_when_cloud_down": basetypes.BoolType{},
			"clickatell_api_key":     basetypes.StringType{},
			"cross_site":             basetypes.BoolType{},
			"email_enabled":          basetypes.BoolType{},
			"enabled":                basetypes.BoolType{},
			"expire":                 basetypes.Int64Type{},
			"external_portal_url":    basetypes.StringType{},
			"facebook_client_id":     basetypes.StringType{},
			"facebook_client_secret": basetypes.StringType{},
			"facebook_email_domains": basetypes.ListType{
				ElemType: types.StringType,
			},
			"facebook_enabled":     basetypes.BoolType{},
			"facebook_expire":      basetypes.Int64Type{},
			"forward":              basetypes.BoolType{},
			"forward_url":          basetypes.StringType{},
			"google_client_id":     basetypes.StringType{},
			"google_client_secret": basetypes.StringType{},
			"google_email_domains": basetypes.ListType{
				ElemType: types.StringType,
			},
			"google_enabled":          basetypes.BoolType{},
			"google_expire":           basetypes.Int64Type{},
			"gupshup_password":        basetypes.StringType{},
			"gupshup_userid":          basetypes.StringType{},
			"microsoft_client_id":     basetypes.StringType{},
			"microsoft_client_secret": basetypes.StringType{},
			"microsoft_email_domains": basetypes.ListType{
				ElemType: types.StringType,
			},
			"microsoft_enabled":              basetypes.BoolType{},
			"microsoft_expire":               basetypes.Int64Type{},
			"passphrase_enabled":             basetypes.BoolType{},
			"passphrase_expire":              basetypes.Int64Type{},
			"password":                       basetypes.StringType{},
			"predefined_sponsors_enabled":    basetypes.BoolType{},
			"predefined_sponsors_hide_email": basetypes.BoolType{},
			"privacy":                        basetypes.BoolType{},
			"puzzel_password":                basetypes.StringType{},
			"puzzel_service_id":              basetypes.StringType{},
			"puzzel_username":                basetypes.StringType{},
			"sms_enabled":                    basetypes.BoolType{},
			"sms_expire":                     basetypes.Int64Type{},
			"sms_message_format":             basetypes.StringType{},
			"sms_provider":                   basetypes.StringType{},
			"sponsor_auto_approve":           basetypes.BoolType{},
			"sponsor_email_domains": basetypes.ListType{
				ElemType: types.StringType,
			},
			"sponsor_enabled":                basetypes.BoolType{},
			"sponsor_expire":                 basetypes.Int64Type{},
			"sponsor_link_validity_duration": basetypes.StringType{},
			"sponsor_notify_all":             basetypes.BoolType{},
			"sponsor_status_notify":          basetypes.BoolType{},
			"sponsors": basetypes.MapType{
				ElemType: types.StringType,
			},
			"sso_default_role":      basetypes.StringType{},
			"sso_forced_role":       basetypes.StringType{},
			"sso_idp_cert":          basetypes.StringType{},
			"sso_idp_sign_algo":     basetypes.StringType{},
			"sso_idp_sso_url":       basetypes.StringType{},
			"sso_issuer":            basetypes.StringType{},
			"sso_nameid_format":     basetypes.StringType{},
			"telstra_client_id":     basetypes.StringType{},
			"telstra_client_secret": basetypes.StringType{},
			"twilio_auth_token":     basetypes.StringType{},
			"twilio_phone_number":   basetypes.StringType{},
			"twilio_sid":            basetypes.StringType{},
		}), diags
	}

	googleEmailDomainsVal, d := types.ListValue(types.StringType, v.GoogleEmailDomains.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"allow_wlan_id_roam":   basetypes.BoolType{},
			"amazon_client_id":     basetypes.StringType{},
			"amazon_client_secret": basetypes.StringType{},
			"amazon_email_domains": basetypes.ListType{
				ElemType: types.StringType,
			},
			"amazon_enabled":         basetypes.BoolType{},
			"amazon_expire":          basetypes.Int64Type{},
			"auth":                   basetypes.StringType{},
			"azure_client_id":        basetypes.StringType{},
			"azure_client_secret":    basetypes.StringType{},
			"azure_enabled":          basetypes.BoolType{},
			"azure_expire":           basetypes.Int64Type{},
			"azure_tenant_id":        basetypes.StringType{},
			"broadnet_password":      basetypes.StringType{},
			"broadnet_sid":           basetypes.StringType{},
			"broadnet_user_id":       basetypes.StringType{},
			"bypass_when_cloud_down": basetypes.BoolType{},
			"clickatell_api_key":     basetypes.StringType{},
			"cross_site":             basetypes.BoolType{},
			"email_enabled":          basetypes.BoolType{},
			"enabled":                basetypes.BoolType{},
			"expire":                 basetypes.Int64Type{},
			"external_portal_url":    basetypes.StringType{},
			"facebook_client_id":     basetypes.StringType{},
			"facebook_client_secret": basetypes.StringType{},
			"facebook_email_domains": basetypes.ListType{
				ElemType: types.StringType,
			},
			"facebook_enabled":     basetypes.BoolType{},
			"facebook_expire":      basetypes.Int64Type{},
			"forward":              basetypes.BoolType{},
			"forward_url":          basetypes.StringType{},
			"google_client_id":     basetypes.StringType{},
			"google_client_secret": basetypes.StringType{},
			"google_email_domains": basetypes.ListType{
				ElemType: types.StringType,
			},
			"google_enabled":          basetypes.BoolType{},
			"google_expire":           basetypes.Int64Type{},
			"gupshup_password":        basetypes.StringType{},
			"gupshup_userid":          basetypes.StringType{},
			"microsoft_client_id":     basetypes.StringType{},
			"microsoft_client_secret": basetypes.StringType{},
			"microsoft_email_domains": basetypes.ListType{
				ElemType: types.StringType,
			},
			"microsoft_enabled":              basetypes.BoolType{},
			"microsoft_expire":               basetypes.Int64Type{},
			"passphrase_enabled":             basetypes.BoolType{},
			"passphrase_expire":              basetypes.Int64Type{},
			"password":                       basetypes.StringType{},
			"predefined_sponsors_enabled":    basetypes.BoolType{},
			"predefined_sponsors_hide_email": basetypes.BoolType{},
			"privacy":                        basetypes.BoolType{},
			"puzzel_password":                basetypes.StringType{},
			"puzzel_service_id":              basetypes.StringType{},
			"puzzel_username":                basetypes.StringType{},
			"sms_enabled":                    basetypes.BoolType{},
			"sms_expire":                     basetypes.Int64Type{},
			"sms_message_format":             basetypes.StringType{},
			"sms_provider":                   basetypes.StringType{},
			"sponsor_auto_approve":           basetypes.BoolType{},
			"sponsor_email_domains": basetypes.ListType{
				ElemType: types.StringType,
			},
			"sponsor_enabled":                basetypes.BoolType{},
			"sponsor_expire":                 basetypes.Int64Type{},
			"sponsor_link_validity_duration": basetypes.StringType{},
			"sponsor_notify_all":             basetypes.BoolType{},
			"sponsor_status_notify":          basetypes.BoolType{},
			"sponsors": basetypes.MapType{
				ElemType: types.StringType,
			},
			"sso_default_role":      basetypes.StringType{},
			"sso_forced_role":       basetypes.StringType{},
			"sso_idp_cert":          basetypes.StringType{},
			"sso_idp_sign_algo":     basetypes.StringType{},
			"sso_idp_sso_url":       basetypes.StringType{},
			"sso_issuer":            basetypes.StringType{},
			"sso_nameid_format":     basetypes.StringType{},
			"telstra_client_id":     basetypes.StringType{},
			"telstra_client_secret": basetypes.StringType{},
			"twilio_auth_token":     basetypes.StringType{},
			"twilio_phone_number":   basetypes.StringType{},
			"twilio_sid":            basetypes.StringType{},
		}), diags
	}

	microsoftEmailDomainsVal, d := types.ListValue(types.StringType, v.MicrosoftEmailDomains.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"allow_wlan_id_roam":   basetypes.BoolType{},
			"amazon_client_id":     basetypes.StringType{},
			"amazon_client_secret": basetypes.StringType{},
			"amazon_email_domains": basetypes.ListType{
				ElemType: types.StringType,
			},
			"amazon_enabled":         basetypes.BoolType{},
			"amazon_expire":          basetypes.Int64Type{},
			"auth":                   basetypes.StringType{},
			"azure_client_id":        basetypes.StringType{},
			"azure_client_secret":    basetypes.StringType{},
			"azure_enabled":          basetypes.BoolType{},
			"azure_expire":           basetypes.Int64Type{},
			"azure_tenant_id":        basetypes.StringType{},
			"broadnet_password":      basetypes.StringType{},
			"broadnet_sid":           basetypes.StringType{},
			"broadnet_user_id":       basetypes.StringType{},
			"bypass_when_cloud_down": basetypes.BoolType{},
			"clickatell_api_key":     basetypes.StringType{},
			"cross_site":             basetypes.BoolType{},
			"email_enabled":          basetypes.BoolType{},
			"enabled":                basetypes.BoolType{},
			"expire":                 basetypes.Int64Type{},
			"external_portal_url":    basetypes.StringType{},
			"facebook_client_id":     basetypes.StringType{},
			"facebook_client_secret": basetypes.StringType{},
			"facebook_email_domains": basetypes.ListType{
				ElemType: types.StringType,
			},
			"facebook_enabled":     basetypes.BoolType{},
			"facebook_expire":      basetypes.Int64Type{},
			"forward":              basetypes.BoolType{},
			"forward_url":          basetypes.StringType{},
			"google_client_id":     basetypes.StringType{},
			"google_client_secret": basetypes.StringType{},
			"google_email_domains": basetypes.ListType{
				ElemType: types.StringType,
			},
			"google_enabled":          basetypes.BoolType{},
			"google_expire":           basetypes.Int64Type{},
			"gupshup_password":        basetypes.StringType{},
			"gupshup_userid":          basetypes.StringType{},
			"microsoft_client_id":     basetypes.StringType{},
			"microsoft_client_secret": basetypes.StringType{},
			"microsoft_email_domains": basetypes.ListType{
				ElemType: types.StringType,
			},
			"microsoft_enabled":              basetypes.BoolType{},
			"microsoft_expire":               basetypes.Int64Type{},
			"passphrase_enabled":             basetypes.BoolType{},
			"passphrase_expire":              basetypes.Int64Type{},
			"password":                       basetypes.StringType{},
			"predefined_sponsors_enabled":    basetypes.BoolType{},
			"predefined_sponsors_hide_email": basetypes.BoolType{},
			"privacy":                        basetypes.BoolType{},
			"puzzel_password":                basetypes.StringType{},
			"puzzel_service_id":              basetypes.StringType{},
			"puzzel_username":                basetypes.StringType{},
			"sms_enabled":                    basetypes.BoolType{},
			"sms_expire":                     basetypes.Int64Type{},
			"sms_message_format":             basetypes.StringType{},
			"sms_provider":                   basetypes.StringType{},
			"sponsor_auto_approve":           basetypes.BoolType{},
			"sponsor_email_domains": basetypes.ListType{
				ElemType: types.StringType,
			},
			"sponsor_enabled":                basetypes.BoolType{},
			"sponsor_expire":                 basetypes.Int64Type{},
			"sponsor_link_validity_duration": basetypes.StringType{},
			"sponsor_notify_all":             basetypes.BoolType{},
			"sponsor_status_notify":          basetypes.BoolType{},
			"sponsors": basetypes.MapType{
				ElemType: types.StringType,
			},
			"sso_default_role":      basetypes.StringType{},
			"sso_forced_role":       basetypes.StringType{},
			"sso_idp_cert":          basetypes.StringType{},
			"sso_idp_sign_algo":     basetypes.StringType{},
			"sso_idp_sso_url":       basetypes.StringType{},
			"sso_issuer":            basetypes.StringType{},
			"sso_nameid_format":     basetypes.StringType{},
			"telstra_client_id":     basetypes.StringType{},
			"telstra_client_secret": basetypes.StringType{},
			"twilio_auth_token":     basetypes.StringType{},
			"twilio_phone_number":   basetypes.StringType{},
			"twilio_sid":            basetypes.StringType{},
		}), diags
	}

	sponsorEmailDomainsVal, d := types.ListValue(types.StringType, v.SponsorEmailDomains.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"allow_wlan_id_roam":   basetypes.BoolType{},
			"amazon_client_id":     basetypes.StringType{},
			"amazon_client_secret": basetypes.StringType{},
			"amazon_email_domains": basetypes.ListType{
				ElemType: types.StringType,
			},
			"amazon_enabled":         basetypes.BoolType{},
			"amazon_expire":          basetypes.Int64Type{},
			"auth":                   basetypes.StringType{},
			"azure_client_id":        basetypes.StringType{},
			"azure_client_secret":    basetypes.StringType{},
			"azure_enabled":          basetypes.BoolType{},
			"azure_expire":           basetypes.Int64Type{},
			"azure_tenant_id":        basetypes.StringType{},
			"broadnet_password":      basetypes.StringType{},
			"broadnet_sid":           basetypes.StringType{},
			"broadnet_user_id":       basetypes.StringType{},
			"bypass_when_cloud_down": basetypes.BoolType{},
			"clickatell_api_key":     basetypes.StringType{},
			"cross_site":             basetypes.BoolType{},
			"email_enabled":          basetypes.BoolType{},
			"enabled":                basetypes.BoolType{},
			"expire":                 basetypes.Int64Type{},
			"external_portal_url":    basetypes.StringType{},
			"facebook_client_id":     basetypes.StringType{},
			"facebook_client_secret": basetypes.StringType{},
			"facebook_email_domains": basetypes.ListType{
				ElemType: types.StringType,
			},
			"facebook_enabled":     basetypes.BoolType{},
			"facebook_expire":      basetypes.Int64Type{},
			"forward":              basetypes.BoolType{},
			"forward_url":          basetypes.StringType{},
			"google_client_id":     basetypes.StringType{},
			"google_client_secret": basetypes.StringType{},
			"google_email_domains": basetypes.ListType{
				ElemType: types.StringType,
			},
			"google_enabled":          basetypes.BoolType{},
			"google_expire":           basetypes.Int64Type{},
			"gupshup_password":        basetypes.StringType{},
			"gupshup_userid":          basetypes.StringType{},
			"microsoft_client_id":     basetypes.StringType{},
			"microsoft_client_secret": basetypes.StringType{},
			"microsoft_email_domains": basetypes.ListType{
				ElemType: types.StringType,
			},
			"microsoft_enabled":              basetypes.BoolType{},
			"microsoft_expire":               basetypes.Int64Type{},
			"passphrase_enabled":             basetypes.BoolType{},
			"passphrase_expire":              basetypes.Int64Type{},
			"password":                       basetypes.StringType{},
			"predefined_sponsors_enabled":    basetypes.BoolType{},
			"predefined_sponsors_hide_email": basetypes.BoolType{},
			"privacy":                        basetypes.BoolType{},
			"puzzel_password":                basetypes.StringType{},
			"puzzel_service_id":              basetypes.StringType{},
			"puzzel_username":                basetypes.StringType{},
			"sms_enabled":                    basetypes.BoolType{},
			"sms_expire":                     basetypes.Int64Type{},
			"sms_message_format":             basetypes.StringType{},
			"sms_provider":                   basetypes.StringType{},
			"sponsor_auto_approve":           basetypes.BoolType{},
			"sponsor_email_domains": basetypes.ListType{
				ElemType: types.StringType,
			},
			"sponsor_enabled":                basetypes.BoolType{},
			"sponsor_expire":                 basetypes.Int64Type{},
			"sponsor_link_validity_duration": basetypes.StringType{},
			"sponsor_notify_all":             basetypes.BoolType{},
			"sponsor_status_notify":          basetypes.BoolType{},
			"sponsors": basetypes.MapType{
				ElemType: types.StringType,
			},
			"sso_default_role":      basetypes.StringType{},
			"sso_forced_role":       basetypes.StringType{},
			"sso_idp_cert":          basetypes.StringType{},
			"sso_idp_sign_algo":     basetypes.StringType{},
			"sso_idp_sso_url":       basetypes.StringType{},
			"sso_issuer":            basetypes.StringType{},
			"sso_nameid_format":     basetypes.StringType{},
			"telstra_client_id":     basetypes.StringType{},
			"telstra_client_secret": basetypes.StringType{},
			"twilio_auth_token":     basetypes.StringType{},
			"twilio_phone_number":   basetypes.StringType{},
			"twilio_sid":            basetypes.StringType{},
		}), diags
	}

	sponsorsVal, d := types.MapValue(types.StringType, v.Sponsors.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"allow_wlan_id_roam":   basetypes.BoolType{},
			"amazon_client_id":     basetypes.StringType{},
			"amazon_client_secret": basetypes.StringType{},
			"amazon_email_domains": basetypes.ListType{
				ElemType: types.StringType,
			},
			"amazon_enabled":         basetypes.BoolType{},
			"amazon_expire":          basetypes.Int64Type{},
			"auth":                   basetypes.StringType{},
			"azure_client_id":        basetypes.StringType{},
			"azure_client_secret":    basetypes.StringType{},
			"azure_enabled":          basetypes.BoolType{},
			"azure_expire":           basetypes.Int64Type{},
			"azure_tenant_id":        basetypes.StringType{},
			"broadnet_password":      basetypes.StringType{},
			"broadnet_sid":           basetypes.StringType{},
			"broadnet_user_id":       basetypes.StringType{},
			"bypass_when_cloud_down": basetypes.BoolType{},
			"clickatell_api_key":     basetypes.StringType{},
			"cross_site":             basetypes.BoolType{},
			"email_enabled":          basetypes.BoolType{},
			"enabled":                basetypes.BoolType{},
			"expire":                 basetypes.Int64Type{},
			"external_portal_url":    basetypes.StringType{},
			"facebook_client_id":     basetypes.StringType{},
			"facebook_client_secret": basetypes.StringType{},
			"facebook_email_domains": basetypes.ListType{
				ElemType: types.StringType,
			},
			"facebook_enabled":     basetypes.BoolType{},
			"facebook_expire":      basetypes.Int64Type{},
			"forward":              basetypes.BoolType{},
			"forward_url":          basetypes.StringType{},
			"google_client_id":     basetypes.StringType{},
			"google_client_secret": basetypes.StringType{},
			"google_email_domains": basetypes.ListType{
				ElemType: types.StringType,
			},
			"google_enabled":          basetypes.BoolType{},
			"google_expire":           basetypes.Int64Type{},
			"gupshup_password":        basetypes.StringType{},
			"gupshup_userid":          basetypes.StringType{},
			"microsoft_client_id":     basetypes.StringType{},
			"microsoft_client_secret": basetypes.StringType{},
			"microsoft_email_domains": basetypes.ListType{
				ElemType: types.StringType,
			},
			"microsoft_enabled":              basetypes.BoolType{},
			"microsoft_expire":               basetypes.Int64Type{},
			"passphrase_enabled":             basetypes.BoolType{},
			"passphrase_expire":              basetypes.Int64Type{},
			"password":                       basetypes.StringType{},
			"predefined_sponsors_enabled":    basetypes.BoolType{},
			"predefined_sponsors_hide_email": basetypes.BoolType{},
			"privacy":                        basetypes.BoolType{},
			"puzzel_password":                basetypes.StringType{},
			"puzzel_service_id":              basetypes.StringType{},
			"puzzel_username":                basetypes.StringType{},
			"sms_enabled":                    basetypes.BoolType{},
			"sms_expire":                     basetypes.Int64Type{},
			"sms_message_format":             basetypes.StringType{},
			"sms_provider":                   basetypes.StringType{},
			"sponsor_auto_approve":           basetypes.BoolType{},
			"sponsor_email_domains": basetypes.ListType{
				ElemType: types.StringType,
			},
			"sponsor_enabled":                basetypes.BoolType{},
			"sponsor_expire":                 basetypes.Int64Type{},
			"sponsor_link_validity_duration": basetypes.StringType{},
			"sponsor_notify_all":             basetypes.BoolType{},
			"sponsor_status_notify":          basetypes.BoolType{},
			"sponsors": basetypes.MapType{
				ElemType: types.StringType,
			},
			"sso_default_role":      basetypes.StringType{},
			"sso_forced_role":       basetypes.StringType{},
			"sso_idp_cert":          basetypes.StringType{},
			"sso_idp_sign_algo":     basetypes.StringType{},
			"sso_idp_sso_url":       basetypes.StringType{},
			"sso_issuer":            basetypes.StringType{},
			"sso_nameid_format":     basetypes.StringType{},
			"telstra_client_id":     basetypes.StringType{},
			"telstra_client_secret": basetypes.StringType{},
			"twilio_auth_token":     basetypes.StringType{},
			"twilio_phone_number":   basetypes.StringType{},
			"twilio_sid":            basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"allow_wlan_id_roam":   basetypes.BoolType{},
		"amazon_client_id":     basetypes.StringType{},
		"amazon_client_secret": basetypes.StringType{},
		"amazon_email_domains": basetypes.ListType{
			ElemType: types.StringType,
		},
		"amazon_enabled":         basetypes.BoolType{},
		"amazon_expire":          basetypes.Int64Type{},
		"auth":                   basetypes.StringType{},
		"azure_client_id":        basetypes.StringType{},
		"azure_client_secret":    basetypes.StringType{},
		"azure_enabled":          basetypes.BoolType{},
		"azure_expire":           basetypes.Int64Type{},
		"azure_tenant_id":        basetypes.StringType{},
		"broadnet_password":      basetypes.StringType{},
		"broadnet_sid":           basetypes.StringType{},
		"broadnet_user_id":       basetypes.StringType{},
		"bypass_when_cloud_down": basetypes.BoolType{},
		"clickatell_api_key":     basetypes.StringType{},
		"cross_site":             basetypes.BoolType{},
		"email_enabled":          basetypes.BoolType{},
		"enabled":                basetypes.BoolType{},
		"expire":                 basetypes.Int64Type{},
		"external_portal_url":    basetypes.StringType{},
		"facebook_client_id":     basetypes.StringType{},
		"facebook_client_secret": basetypes.StringType{},
		"facebook_email_domains": basetypes.ListType{
			ElemType: types.StringType,
		},
		"facebook_enabled":     basetypes.BoolType{},
		"facebook_expire":      basetypes.Int64Type{},
		"forward":              basetypes.BoolType{},
		"forward_url":          basetypes.StringType{},
		"google_client_id":     basetypes.StringType{},
		"google_client_secret": basetypes.StringType{},
		"google_email_domains": basetypes.ListType{
			ElemType: types.StringType,
		},
		"google_enabled":          basetypes.BoolType{},
		"google_expire":           basetypes.Int64Type{},
		"gupshup_password":        basetypes.StringType{},
		"gupshup_userid":          basetypes.StringType{},
		"microsoft_client_id":     basetypes.StringType{},
		"microsoft_client_secret": basetypes.StringType{},
		"microsoft_email_domains": basetypes.ListType{
			ElemType: types.StringType,
		},
		"microsoft_enabled":              basetypes.BoolType{},
		"microsoft_expire":               basetypes.Int64Type{},
		"passphrase_enabled":             basetypes.BoolType{},
		"passphrase_expire":              basetypes.Int64Type{},
		"password":                       basetypes.StringType{},
		"predefined_sponsors_enabled":    basetypes.BoolType{},
		"predefined_sponsors_hide_email": basetypes.BoolType{},
		"privacy":                        basetypes.BoolType{},
		"puzzel_password":                basetypes.StringType{},
		"puzzel_service_id":              basetypes.StringType{},
		"puzzel_username":                basetypes.StringType{},
		"sms_enabled":                    basetypes.BoolType{},
		"sms_expire":                     basetypes.Int64Type{},
		"sms_message_format":             basetypes.StringType{},
		"sms_provider":                   basetypes.StringType{},
		"sponsor_auto_approve":           basetypes.BoolType{},
		"sponsor_email_domains": basetypes.ListType{
			ElemType: types.StringType,
		},
		"sponsor_enabled":                basetypes.BoolType{},
		"sponsor_expire":                 basetypes.Int64Type{},
		"sponsor_link_validity_duration": basetypes.StringType{},
		"sponsor_notify_all":             basetypes.BoolType{},
		"sponsor_status_notify":          basetypes.BoolType{},
		"sponsors": basetypes.MapType{
			ElemType: types.StringType,
		},
		"sso_default_role":      basetypes.StringType{},
		"sso_forced_role":       basetypes.StringType{},
		"sso_idp_cert":          basetypes.StringType{},
		"sso_idp_sign_algo":     basetypes.StringType{},
		"sso_idp_sso_url":       basetypes.StringType{},
		"sso_issuer":            basetypes.StringType{},
		"sso_nameid_format":     basetypes.StringType{},
		"telstra_client_id":     basetypes.StringType{},
		"telstra_client_secret": basetypes.StringType{},
		"twilio_auth_token":     basetypes.StringType{},
		"twilio_phone_number":   basetypes.StringType{},
		"twilio_sid":            basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"allow_wlan_id_roam":             v.AllowWlanIdRoam,
			"amazon_client_id":               v.AmazonClientId,
			"amazon_client_secret":           v.AmazonClientSecret,
			"amazon_email_domains":           amazonEmailDomainsVal,
			"amazon_enabled":                 v.AmazonEnabled,
			"amazon_expire":                  v.AmazonExpire,
			"auth":                           v.Auth,
			"azure_client_id":                v.AzureClientId,
			"azure_client_secret":            v.AzureClientSecret,
			"azure_enabled":                  v.AzureEnabled,
			"azure_expire":                   v.AzureExpire,
			"azure_tenant_id":                v.AzureTenantId,
			"broadnet_password":              v.BroadnetPassword,
			"broadnet_sid":                   v.BroadnetSid,
			"broadnet_user_id":               v.BroadnetUserId,
			"bypass_when_cloud_down":         v.BypassWhenCloudDown,
			"clickatell_api_key":             v.ClickatellApiKey,
			"cross_site":                     v.CrossSite,
			"email_enabled":                  v.EmailEnabled,
			"enabled":                        v.Enabled,
			"expire":                         v.Expire,
			"external_portal_url":            v.ExternalPortalUrl,
			"facebook_client_id":             v.FacebookClientId,
			"facebook_client_secret":         v.FacebookClientSecret,
			"facebook_email_domains":         facebookEmailDomainsVal,
			"facebook_enabled":               v.FacebookEnabled,
			"facebook_expire":                v.FacebookExpire,
			"forward":                        v.Forward,
			"forward_url":                    v.ForwardUrl,
			"google_client_id":               v.GoogleClientId,
			"google_client_secret":           v.GoogleClientSecret,
			"google_email_domains":           googleEmailDomainsVal,
			"google_enabled":                 v.GoogleEnabled,
			"google_expire":                  v.GoogleExpire,
			"gupshup_password":               v.GupshupPassword,
			"gupshup_userid":                 v.GupshupUserid,
			"microsoft_client_id":            v.MicrosoftClientId,
			"microsoft_client_secret":        v.MicrosoftClientSecret,
			"microsoft_email_domains":        microsoftEmailDomainsVal,
			"microsoft_enabled":              v.MicrosoftEnabled,
			"microsoft_expire":               v.MicrosoftExpire,
			"passphrase_enabled":             v.PassphraseEnabled,
			"passphrase_expire":              v.PassphraseExpire,
			"password":                       v.Password,
			"predefined_sponsors_enabled":    v.PredefinedSponsorsEnabled,
			"predefined_sponsors_hide_email": v.PredefinedSponsorsHideEmail,
			"privacy":                        v.Privacy,
			"puzzel_password":                v.PuzzelPassword,
			"puzzel_service_id":              v.PuzzelServiceId,
			"puzzel_username":                v.PuzzelUsername,
			"sms_enabled":                    v.SmsEnabled,
			"sms_expire":                     v.SmsExpire,
			"sms_message_format":             v.SmsMessageFormat,
			"sms_provider":                   v.SmsProvider,
			"sponsor_auto_approve":           v.SponsorAutoApprove,
			"sponsor_email_domains":          sponsorEmailDomainsVal,
			"sponsor_enabled":                v.SponsorEnabled,
			"sponsor_expire":                 v.SponsorExpire,
			"sponsor_link_validity_duration": v.SponsorLinkValidityDuration,
			"sponsor_notify_all":             v.SponsorNotifyAll,
			"sponsor_status_notify":          v.SponsorStatusNotify,
			"sponsors":                       sponsorsVal,
			"sso_default_role":               v.SsoDefaultRole,
			"sso_forced_role":                v.SsoForcedRole,
			"sso_idp_cert":                   v.SsoIdpCert,
			"sso_idp_sign_algo":              v.SsoIdpSignAlgo,
			"sso_idp_sso_url":                v.SsoIdpSsoUrl,
			"sso_issuer":                     v.SsoIssuer,
			"sso_nameid_format":              v.SsoNameidFormat,
			"telstra_client_id":              v.TelstraClientId,
			"telstra_client_secret":          v.TelstraClientSecret,
			"twilio_auth_token":              v.TwilioAuthToken,
			"twilio_phone_number":            v.TwilioPhoneNumber,
			"twilio_sid":                     v.TwilioSid,
		})

	return objVal, diags
}

func (v PortalValue) Equal(o attr.Value) bool {
	other, ok := o.(PortalValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AllowWlanIdRoam.Equal(other.AllowWlanIdRoam) {
		return false
	}

	if !v.AmazonClientId.Equal(other.AmazonClientId) {
		return false
	}

	if !v.AmazonClientSecret.Equal(other.AmazonClientSecret) {
		return false
	}

	if !v.AmazonEmailDomains.Equal(other.AmazonEmailDomains) {
		return false
	}

	if !v.AmazonEnabled.Equal(other.AmazonEnabled) {
		return false
	}

	if !v.AmazonExpire.Equal(other.AmazonExpire) {
		return false
	}

	if !v.Auth.Equal(other.Auth) {
		return false
	}

	if !v.AzureClientId.Equal(other.AzureClientId) {
		return false
	}

	if !v.AzureClientSecret.Equal(other.AzureClientSecret) {
		return false
	}

	if !v.AzureEnabled.Equal(other.AzureEnabled) {
		return false
	}

	if !v.AzureExpire.Equal(other.AzureExpire) {
		return false
	}

	if !v.AzureTenantId.Equal(other.AzureTenantId) {
		return false
	}

	if !v.BroadnetPassword.Equal(other.BroadnetPassword) {
		return false
	}

	if !v.BroadnetSid.Equal(other.BroadnetSid) {
		return false
	}

	if !v.BroadnetUserId.Equal(other.BroadnetUserId) {
		return false
	}

	if !v.BypassWhenCloudDown.Equal(other.BypassWhenCloudDown) {
		return false
	}

	if !v.ClickatellApiKey.Equal(other.ClickatellApiKey) {
		return false
	}

	if !v.CrossSite.Equal(other.CrossSite) {
		return false
	}

	if !v.EmailEnabled.Equal(other.EmailEnabled) {
		return false
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.Expire.Equal(other.Expire) {
		return false
	}

	if !v.ExternalPortalUrl.Equal(other.ExternalPortalUrl) {
		return false
	}

	if !v.FacebookClientId.Equal(other.FacebookClientId) {
		return false
	}

	if !v.FacebookClientSecret.Equal(other.FacebookClientSecret) {
		return false
	}

	if !v.FacebookEmailDomains.Equal(other.FacebookEmailDomains) {
		return false
	}

	if !v.FacebookEnabled.Equal(other.FacebookEnabled) {
		return false
	}

	if !v.FacebookExpire.Equal(other.FacebookExpire) {
		return false
	}

	if !v.Forward.Equal(other.Forward) {
		return false
	}

	if !v.ForwardUrl.Equal(other.ForwardUrl) {
		return false
	}

	if !v.GoogleClientId.Equal(other.GoogleClientId) {
		return false
	}

	if !v.GoogleClientSecret.Equal(other.GoogleClientSecret) {
		return false
	}

	if !v.GoogleEmailDomains.Equal(other.GoogleEmailDomains) {
		return false
	}

	if !v.GoogleEnabled.Equal(other.GoogleEnabled) {
		return false
	}

	if !v.GoogleExpire.Equal(other.GoogleExpire) {
		return false
	}

	if !v.GupshupPassword.Equal(other.GupshupPassword) {
		return false
	}

	if !v.GupshupUserid.Equal(other.GupshupUserid) {
		return false
	}

	if !v.MicrosoftClientId.Equal(other.MicrosoftClientId) {
		return false
	}

	if !v.MicrosoftClientSecret.Equal(other.MicrosoftClientSecret) {
		return false
	}

	if !v.MicrosoftEmailDomains.Equal(other.MicrosoftEmailDomains) {
		return false
	}

	if !v.MicrosoftEnabled.Equal(other.MicrosoftEnabled) {
		return false
	}

	if !v.MicrosoftExpire.Equal(other.MicrosoftExpire) {
		return false
	}

	if !v.PassphraseEnabled.Equal(other.PassphraseEnabled) {
		return false
	}

	if !v.PassphraseExpire.Equal(other.PassphraseExpire) {
		return false
	}

	if !v.Password.Equal(other.Password) {
		return false
	}

	if !v.PredefinedSponsorsEnabled.Equal(other.PredefinedSponsorsEnabled) {
		return false
	}

	if !v.PredefinedSponsorsHideEmail.Equal(other.PredefinedSponsorsHideEmail) {
		return false
	}

	if !v.Privacy.Equal(other.Privacy) {
		return false
	}

	if !v.PuzzelPassword.Equal(other.PuzzelPassword) {
		return false
	}

	if !v.PuzzelServiceId.Equal(other.PuzzelServiceId) {
		return false
	}

	if !v.PuzzelUsername.Equal(other.PuzzelUsername) {
		return false
	}

	if !v.SmsEnabled.Equal(other.SmsEnabled) {
		return false
	}

	if !v.SmsExpire.Equal(other.SmsExpire) {
		return false
	}

	if !v.SmsMessageFormat.Equal(other.SmsMessageFormat) {
		return false
	}

	if !v.SmsProvider.Equal(other.SmsProvider) {
		return false
	}

	if !v.SponsorAutoApprove.Equal(other.SponsorAutoApprove) {
		return false
	}

	if !v.SponsorEmailDomains.Equal(other.SponsorEmailDomains) {
		return false
	}

	if !v.SponsorEnabled.Equal(other.SponsorEnabled) {
		return false
	}

	if !v.SponsorExpire.Equal(other.SponsorExpire) {
		return false
	}

	if !v.SponsorLinkValidityDuration.Equal(other.SponsorLinkValidityDuration) {
		return false
	}

	if !v.SponsorNotifyAll.Equal(other.SponsorNotifyAll) {
		return false
	}

	if !v.SponsorStatusNotify.Equal(other.SponsorStatusNotify) {
		return false
	}

	if !v.Sponsors.Equal(other.Sponsors) {
		return false
	}

	if !v.SsoDefaultRole.Equal(other.SsoDefaultRole) {
		return false
	}

	if !v.SsoForcedRole.Equal(other.SsoForcedRole) {
		return false
	}

	if !v.SsoIdpCert.Equal(other.SsoIdpCert) {
		return false
	}

	if !v.SsoIdpSignAlgo.Equal(other.SsoIdpSignAlgo) {
		return false
	}

	if !v.SsoIdpSsoUrl.Equal(other.SsoIdpSsoUrl) {
		return false
	}

	if !v.SsoIssuer.Equal(other.SsoIssuer) {
		return false
	}

	if !v.SsoNameidFormat.Equal(other.SsoNameidFormat) {
		return false
	}

	if !v.TelstraClientId.Equal(other.TelstraClientId) {
		return false
	}

	if !v.TelstraClientSecret.Equal(other.TelstraClientSecret) {
		return false
	}

	if !v.TwilioAuthToken.Equal(other.TwilioAuthToken) {
		return false
	}

	if !v.TwilioPhoneNumber.Equal(other.TwilioPhoneNumber) {
		return false
	}

	if !v.TwilioSid.Equal(other.TwilioSid) {
		return false
	}

	return true
}

func (v PortalValue) Type(ctx context.Context) attr.Type {
	return PortalType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PortalValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"allow_wlan_id_roam":   basetypes.BoolType{},
		"amazon_client_id":     basetypes.StringType{},
		"amazon_client_secret": basetypes.StringType{},
		"amazon_email_domains": basetypes.ListType{
			ElemType: types.StringType,
		},
		"amazon_enabled":         basetypes.BoolType{},
		"amazon_expire":          basetypes.Int64Type{},
		"auth":                   basetypes.StringType{},
		"azure_client_id":        basetypes.StringType{},
		"azure_client_secret":    basetypes.StringType{},
		"azure_enabled":          basetypes.BoolType{},
		"azure_expire":           basetypes.Int64Type{},
		"azure_tenant_id":        basetypes.StringType{},
		"broadnet_password":      basetypes.StringType{},
		"broadnet_sid":           basetypes.StringType{},
		"broadnet_user_id":       basetypes.StringType{},
		"bypass_when_cloud_down": basetypes.BoolType{},
		"clickatell_api_key":     basetypes.StringType{},
		"cross_site":             basetypes.BoolType{},
		"email_enabled":          basetypes.BoolType{},
		"enabled":                basetypes.BoolType{},
		"expire":                 basetypes.Int64Type{},
		"external_portal_url":    basetypes.StringType{},
		"facebook_client_id":     basetypes.StringType{},
		"facebook_client_secret": basetypes.StringType{},
		"facebook_email_domains": basetypes.ListType{
			ElemType: types.StringType,
		},
		"facebook_enabled":     basetypes.BoolType{},
		"facebook_expire":      basetypes.Int64Type{},
		"forward":              basetypes.BoolType{},
		"forward_url":          basetypes.StringType{},
		"google_client_id":     basetypes.StringType{},
		"google_client_secret": basetypes.StringType{},
		"google_email_domains": basetypes.ListType{
			ElemType: types.StringType,
		},
		"google_enabled":          basetypes.BoolType{},
		"google_expire":           basetypes.Int64Type{},
		"gupshup_password":        basetypes.StringType{},
		"gupshup_userid":          basetypes.StringType{},
		"microsoft_client_id":     basetypes.StringType{},
		"microsoft_client_secret": basetypes.StringType{},
		"microsoft_email_domains": basetypes.ListType{
			ElemType: types.StringType,
		},
		"microsoft_enabled":              basetypes.BoolType{},
		"microsoft_expire":               basetypes.Int64Type{},
		"passphrase_enabled":             basetypes.BoolType{},
		"passphrase_expire":              basetypes.Int64Type{},
		"password":                       basetypes.StringType{},
		"predefined_sponsors_enabled":    basetypes.BoolType{},
		"predefined_sponsors_hide_email": basetypes.BoolType{},
		"privacy":                        basetypes.BoolType{},
		"puzzel_password":                basetypes.StringType{},
		"puzzel_service_id":              basetypes.StringType{},
		"puzzel_username":                basetypes.StringType{},
		"sms_enabled":                    basetypes.BoolType{},
		"sms_expire":                     basetypes.Int64Type{},
		"sms_message_format":             basetypes.StringType{},
		"sms_provider":                   basetypes.StringType{},
		"sponsor_auto_approve":           basetypes.BoolType{},
		"sponsor_email_domains": basetypes.ListType{
			ElemType: types.StringType,
		},
		"sponsor_enabled":                basetypes.BoolType{},
		"sponsor_expire":                 basetypes.Int64Type{},
		"sponsor_link_validity_duration": basetypes.StringType{},
		"sponsor_notify_all":             basetypes.BoolType{},
		"sponsor_status_notify":          basetypes.BoolType{},
		"sponsors": basetypes.MapType{
			ElemType: types.StringType,
		},
		"sso_default_role":      basetypes.StringType{},
		"sso_forced_role":       basetypes.StringType{},
		"sso_idp_cert":          basetypes.StringType{},
		"sso_idp_sign_algo":     basetypes.StringType{},
		"sso_idp_sso_url":       basetypes.StringType{},
		"sso_issuer":            basetypes.StringType{},
		"sso_nameid_format":     basetypes.StringType{},
		"telstra_client_id":     basetypes.StringType{},
		"telstra_client_secret": basetypes.StringType{},
		"twilio_auth_token":     basetypes.StringType{},
		"twilio_phone_number":   basetypes.StringType{},
		"twilio_sid":            basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = QosType{}

type QosType struct {
	basetypes.ObjectType
}

func (t QosType) Equal(o attr.Type) bool {
	other, ok := o.(QosType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t QosType) String() string {
	return "QosType"
}

func (t QosType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	classAttribute, ok := attributes["class"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`class is missing from object`)

		return nil, diags
	}

	classVal, ok := classAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`class expected to be basetypes.StringValue, was: %T`, classAttribute))
	}

	overwriteAttribute, ok := attributes["overwrite"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`overwrite is missing from object`)

		return nil, diags
	}

	overwriteVal, ok := overwriteAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`overwrite expected to be basetypes.BoolValue, was: %T`, overwriteAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return QosValue{
		Class:     classVal,
		Overwrite: overwriteVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewQosValueNull() QosValue {
	return QosValue{
		state: attr.ValueStateNull,
	}
}

func NewQosValueUnknown() QosValue {
	return QosValue{
		state: attr.ValueStateUnknown,
	}
}

func NewQosValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (QosValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing QosValue Attribute Value",
				"While creating a QosValue value, a missing attribute value was detected. "+
					"A QosValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("QosValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid QosValue Attribute Type",
				"While creating a QosValue value, an invalid attribute value was detected. "+
					"A QosValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("QosValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("QosValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra QosValue Attribute Value",
				"While creating a QosValue value, an extra attribute value was detected. "+
					"A QosValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra QosValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewQosValueUnknown(), diags
	}

	classAttribute, ok := attributes["class"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`class is missing from object`)

		return NewQosValueUnknown(), diags
	}

	classVal, ok := classAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`class expected to be basetypes.StringValue, was: %T`, classAttribute))
	}

	overwriteAttribute, ok := attributes["overwrite"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`overwrite is missing from object`)

		return NewQosValueUnknown(), diags
	}

	overwriteVal, ok := overwriteAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`overwrite expected to be basetypes.BoolValue, was: %T`, overwriteAttribute))
	}

	if diags.HasError() {
		return NewQosValueUnknown(), diags
	}

	return QosValue{
		Class:     classVal,
		Overwrite: overwriteVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewQosValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) QosValue {
	object, diags := NewQosValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewQosValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t QosType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewQosValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewQosValueUnknown(), nil
	}

	if in.IsNull() {
		return NewQosValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewQosValueMust(QosValue{}.AttributeTypes(ctx), attributes), nil
}

func (t QosType) ValueType(ctx context.Context) attr.Value {
	return QosValue{}
}

var _ basetypes.ObjectValuable = QosValue{}

type QosValue struct {
	Class     basetypes.StringValue `tfsdk:"class"`
	Overwrite basetypes.BoolValue   `tfsdk:"overwrite"`
	state     attr.ValueState
}

func (v QosValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["class"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["overwrite"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Class.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["class"] = val

		val, err = v.Overwrite.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["overwrite"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v QosValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v QosValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v QosValue) String() string {
	return "QosValue"
}

func (v QosValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"class":     basetypes.StringType{},
		"overwrite": basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"class":     v.Class,
			"overwrite": v.Overwrite,
		})

	return objVal, diags
}

func (v QosValue) Equal(o attr.Value) bool {
	other, ok := o.(QosValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Class.Equal(other.Class) {
		return false
	}

	if !v.Overwrite.Equal(other.Overwrite) {
		return false
	}

	return true
}

func (v QosValue) Type(ctx context.Context) attr.Type {
	return QosType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v QosValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"class":     basetypes.StringType{},
		"overwrite": basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = RadsecType{}

type RadsecType struct {
	basetypes.ObjectType
}

func (t RadsecType) Equal(o attr.Type) bool {
	other, ok := o.(RadsecType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t RadsecType) String() string {
	return "RadsecType"
}

func (t RadsecType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	coaEnabledAttribute, ok := attributes["coa_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`coa_enabled is missing from object`)

		return nil, diags
	}

	coaEnabledVal, ok := coaEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`coa_enabled expected to be basetypes.BoolValue, was: %T`, coaEnabledAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	idleTimeoutAttribute, ok := attributes["idle_timeout"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`idle_timeout is missing from object`)

		return nil, diags
	}

	idleTimeoutVal, ok := idleTimeoutAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`idle_timeout expected to be basetypes.Int64Value, was: %T`, idleTimeoutAttribute))
	}

	mxclusterIdsAttribute, ok := attributes["mxcluster_ids"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mxcluster_ids is missing from object`)

		return nil, diags
	}

	mxclusterIdsVal, ok := mxclusterIdsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mxcluster_ids expected to be basetypes.ListValue, was: %T`, mxclusterIdsAttribute))
	}

	proxyHostsAttribute, ok := attributes["proxy_hosts"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`proxy_hosts is missing from object`)

		return nil, diags
	}

	proxyHostsVal, ok := proxyHostsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`proxy_hosts expected to be basetypes.ListValue, was: %T`, proxyHostsAttribute))
	}

	serverNameAttribute, ok := attributes["server_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`server_name is missing from object`)

		return nil, diags
	}

	serverNameVal, ok := serverNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`server_name expected to be basetypes.StringValue, was: %T`, serverNameAttribute))
	}

	serversAttribute, ok := attributes["servers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`servers is missing from object`)

		return nil, diags
	}

	serversVal, ok := serversAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`servers expected to be basetypes.ListValue, was: %T`, serversAttribute))
	}

	useMxedgeAttribute, ok := attributes["use_mxedge"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`use_mxedge is missing from object`)

		return nil, diags
	}

	useMxedgeVal, ok := useMxedgeAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`use_mxedge expected to be basetypes.BoolValue, was: %T`, useMxedgeAttribute))
	}

	useSiteMxedgeAttribute, ok := attributes["use_site_mxedge"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`use_site_mxedge is missing from object`)

		return nil, diags
	}

	useSiteMxedgeVal, ok := useSiteMxedgeAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`use_site_mxedge expected to be basetypes.BoolValue, was: %T`, useSiteMxedgeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return RadsecValue{
		CoaEnabled:    coaEnabledVal,
		Enabled:       enabledVal,
		IdleTimeout:   idleTimeoutVal,
		MxclusterIds:  mxclusterIdsVal,
		ProxyHosts:    proxyHostsVal,
		ServerName:    serverNameVal,
		Servers:       serversVal,
		UseMxedge:     useMxedgeVal,
		UseSiteMxedge: useSiteMxedgeVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewRadsecValueNull() RadsecValue {
	return RadsecValue{
		state: attr.ValueStateNull,
	}
}

func NewRadsecValueUnknown() RadsecValue {
	return RadsecValue{
		state: attr.ValueStateUnknown,
	}
}

func NewRadsecValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (RadsecValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing RadsecValue Attribute Value",
				"While creating a RadsecValue value, a missing attribute value was detected. "+
					"A RadsecValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RadsecValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid RadsecValue Attribute Type",
				"While creating a RadsecValue value, an invalid attribute value was detected. "+
					"A RadsecValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RadsecValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("RadsecValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra RadsecValue Attribute Value",
				"While creating a RadsecValue value, an extra attribute value was detected. "+
					"A RadsecValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra RadsecValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewRadsecValueUnknown(), diags
	}

	coaEnabledAttribute, ok := attributes["coa_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`coa_enabled is missing from object`)

		return NewRadsecValueUnknown(), diags
	}

	coaEnabledVal, ok := coaEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`coa_enabled expected to be basetypes.BoolValue, was: %T`, coaEnabledAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewRadsecValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	idleTimeoutAttribute, ok := attributes["idle_timeout"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`idle_timeout is missing from object`)

		return NewRadsecValueUnknown(), diags
	}

	idleTimeoutVal, ok := idleTimeoutAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`idle_timeout expected to be basetypes.Int64Value, was: %T`, idleTimeoutAttribute))
	}

	mxclusterIdsAttribute, ok := attributes["mxcluster_ids"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mxcluster_ids is missing from object`)

		return NewRadsecValueUnknown(), diags
	}

	mxclusterIdsVal, ok := mxclusterIdsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mxcluster_ids expected to be basetypes.ListValue, was: %T`, mxclusterIdsAttribute))
	}

	proxyHostsAttribute, ok := attributes["proxy_hosts"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`proxy_hosts is missing from object`)

		return NewRadsecValueUnknown(), diags
	}

	proxyHostsVal, ok := proxyHostsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`proxy_hosts expected to be basetypes.ListValue, was: %T`, proxyHostsAttribute))
	}

	serverNameAttribute, ok := attributes["server_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`server_name is missing from object`)

		return NewRadsecValueUnknown(), diags
	}

	serverNameVal, ok := serverNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`server_name expected to be basetypes.StringValue, was: %T`, serverNameAttribute))
	}

	serversAttribute, ok := attributes["servers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`servers is missing from object`)

		return NewRadsecValueUnknown(), diags
	}

	serversVal, ok := serversAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`servers expected to be basetypes.ListValue, was: %T`, serversAttribute))
	}

	useMxedgeAttribute, ok := attributes["use_mxedge"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`use_mxedge is missing from object`)

		return NewRadsecValueUnknown(), diags
	}

	useMxedgeVal, ok := useMxedgeAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`use_mxedge expected to be basetypes.BoolValue, was: %T`, useMxedgeAttribute))
	}

	useSiteMxedgeAttribute, ok := attributes["use_site_mxedge"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`use_site_mxedge is missing from object`)

		return NewRadsecValueUnknown(), diags
	}

	useSiteMxedgeVal, ok := useSiteMxedgeAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`use_site_mxedge expected to be basetypes.BoolValue, was: %T`, useSiteMxedgeAttribute))
	}

	if diags.HasError() {
		return NewRadsecValueUnknown(), diags
	}

	return RadsecValue{
		CoaEnabled:    coaEnabledVal,
		Enabled:       enabledVal,
		IdleTimeout:   idleTimeoutVal,
		MxclusterIds:  mxclusterIdsVal,
		ProxyHosts:    proxyHostsVal,
		ServerName:    serverNameVal,
		Servers:       serversVal,
		UseMxedge:     useMxedgeVal,
		UseSiteMxedge: useSiteMxedgeVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewRadsecValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) RadsecValue {
	object, diags := NewRadsecValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewRadsecValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t RadsecType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewRadsecValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewRadsecValueUnknown(), nil
	}

	if in.IsNull() {
		return NewRadsecValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewRadsecValueMust(RadsecValue{}.AttributeTypes(ctx), attributes), nil
}

func (t RadsecType) ValueType(ctx context.Context) attr.Value {
	return RadsecValue{}
}

var _ basetypes.ObjectValuable = RadsecValue{}

type RadsecValue struct {
	CoaEnabled    basetypes.BoolValue   `tfsdk:"coa_enabled"`
	Enabled       basetypes.BoolValue   `tfsdk:"enabled"`
	IdleTimeout   basetypes.Int64Value  `tfsdk:"idle_timeout"`
	MxclusterIds  basetypes.ListValue   `tfsdk:"mxcluster_ids"`
	ProxyHosts    basetypes.ListValue   `tfsdk:"proxy_hosts"`
	ServerName    basetypes.StringValue `tfsdk:"server_name"`
	Servers       basetypes.ListValue   `tfsdk:"servers"`
	UseMxedge     basetypes.BoolValue   `tfsdk:"use_mxedge"`
	UseSiteMxedge basetypes.BoolValue   `tfsdk:"use_site_mxedge"`
	state         attr.ValueState
}

func (v RadsecValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 9)

	var val tftypes.Value
	var err error

	attrTypes["coa_enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["idle_timeout"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["mxcluster_ids"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["proxy_hosts"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["server_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["servers"] = basetypes.ListType{
		ElemType: ServersValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["use_mxedge"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["use_site_mxedge"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 9)

		val, err = v.CoaEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["coa_enabled"] = val

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.IdleTimeout.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["idle_timeout"] = val

		val, err = v.MxclusterIds.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mxcluster_ids"] = val

		val, err = v.ProxyHosts.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["proxy_hosts"] = val

		val, err = v.ServerName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["server_name"] = val

		val, err = v.Servers.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["servers"] = val

		val, err = v.UseMxedge.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["use_mxedge"] = val

		val, err = v.UseSiteMxedge.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["use_site_mxedge"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v RadsecValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v RadsecValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v RadsecValue) String() string {
	return "RadsecValue"
}

func (v RadsecValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	servers := types.ListValueMust(
		ServersType{
			basetypes.ObjectType{
				AttrTypes: ServersValue{}.AttributeTypes(ctx),
			},
		},
		v.Servers.Elements(),
	)

	if v.Servers.IsNull() {
		servers = types.ListNull(
			ServersType{
				basetypes.ObjectType{
					AttrTypes: ServersValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Servers.IsUnknown() {
		servers = types.ListUnknown(
			ServersType{
				basetypes.ObjectType{
					AttrTypes: ServersValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	mxclusterIdsVal, d := types.ListValue(types.StringType, v.MxclusterIds.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"coa_enabled":  basetypes.BoolType{},
			"enabled":      basetypes.BoolType{},
			"idle_timeout": basetypes.Int64Type{},
			"mxcluster_ids": basetypes.ListType{
				ElemType: types.StringType,
			},
			"proxy_hosts": basetypes.ListType{
				ElemType: types.StringType,
			},
			"server_name": basetypes.StringType{},
			"servers": basetypes.ListType{
				ElemType: ServersValue{}.Type(ctx),
			},
			"use_mxedge":      basetypes.BoolType{},
			"use_site_mxedge": basetypes.BoolType{},
		}), diags
	}

	proxyHostsVal, d := types.ListValue(types.StringType, v.ProxyHosts.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"coa_enabled":  basetypes.BoolType{},
			"enabled":      basetypes.BoolType{},
			"idle_timeout": basetypes.Int64Type{},
			"mxcluster_ids": basetypes.ListType{
				ElemType: types.StringType,
			},
			"proxy_hosts": basetypes.ListType{
				ElemType: types.StringType,
			},
			"server_name": basetypes.StringType{},
			"servers": basetypes.ListType{
				ElemType: ServersValue{}.Type(ctx),
			},
			"use_mxedge":      basetypes.BoolType{},
			"use_site_mxedge": basetypes.BoolType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"coa_enabled":  basetypes.BoolType{},
		"enabled":      basetypes.BoolType{},
		"idle_timeout": basetypes.Int64Type{},
		"mxcluster_ids": basetypes.ListType{
			ElemType: types.StringType,
		},
		"proxy_hosts": basetypes.ListType{
			ElemType: types.StringType,
		},
		"server_name": basetypes.StringType{},
		"servers": basetypes.ListType{
			ElemType: ServersValue{}.Type(ctx),
		},
		"use_mxedge":      basetypes.BoolType{},
		"use_site_mxedge": basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"coa_enabled":     v.CoaEnabled,
			"enabled":         v.Enabled,
			"idle_timeout":    v.IdleTimeout,
			"mxcluster_ids":   mxclusterIdsVal,
			"proxy_hosts":     proxyHostsVal,
			"server_name":     v.ServerName,
			"servers":         servers,
			"use_mxedge":      v.UseMxedge,
			"use_site_mxedge": v.UseSiteMxedge,
		})

	return objVal, diags
}

func (v RadsecValue) Equal(o attr.Value) bool {
	other, ok := o.(RadsecValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.CoaEnabled.Equal(other.CoaEnabled) {
		return false
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.IdleTimeout.Equal(other.IdleTimeout) {
		return false
	}

	if !v.MxclusterIds.Equal(other.MxclusterIds) {
		return false
	}

	if !v.ProxyHosts.Equal(other.ProxyHosts) {
		return false
	}

	if !v.ServerName.Equal(other.ServerName) {
		return false
	}

	if !v.Servers.Equal(other.Servers) {
		return false
	}

	if !v.UseMxedge.Equal(other.UseMxedge) {
		return false
	}

	if !v.UseSiteMxedge.Equal(other.UseSiteMxedge) {
		return false
	}

	return true
}

func (v RadsecValue) Type(ctx context.Context) attr.Type {
	return RadsecType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v RadsecValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"coa_enabled":  basetypes.BoolType{},
		"enabled":      basetypes.BoolType{},
		"idle_timeout": basetypes.Int64Type{},
		"mxcluster_ids": basetypes.ListType{
			ElemType: types.StringType,
		},
		"proxy_hosts": basetypes.ListType{
			ElemType: types.StringType,
		},
		"server_name": basetypes.StringType{},
		"servers": basetypes.ListType{
			ElemType: ServersValue{}.Type(ctx),
		},
		"use_mxedge":      basetypes.BoolType{},
		"use_site_mxedge": basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = ServersType{}

type ServersType struct {
	basetypes.ObjectType
}

func (t ServersType) Equal(o attr.Type) bool {
	other, ok := o.(ServersType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ServersType) String() string {
	return "ServersType"
}

func (t ServersType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	hostAttribute, ok := attributes["host"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`host is missing from object`)

		return nil, diags
	}

	hostVal, ok := hostAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`host expected to be basetypes.StringValue, was: %T`, hostAttribute))
	}

	portAttribute, ok := attributes["port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port is missing from object`)

		return nil, diags
	}

	portVal, ok := portAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port expected to be basetypes.Int64Value, was: %T`, portAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ServersValue{
		Host:  hostVal,
		Port:  portVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewServersValueNull() ServersValue {
	return ServersValue{
		state: attr.ValueStateNull,
	}
}

func NewServersValueUnknown() ServersValue {
	return ServersValue{
		state: attr.ValueStateUnknown,
	}
}

func NewServersValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ServersValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ServersValue Attribute Value",
				"While creating a ServersValue value, a missing attribute value was detected. "+
					"A ServersValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ServersValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ServersValue Attribute Type",
				"While creating a ServersValue value, an invalid attribute value was detected. "+
					"A ServersValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ServersValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ServersValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ServersValue Attribute Value",
				"While creating a ServersValue value, an extra attribute value was detected. "+
					"A ServersValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ServersValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewServersValueUnknown(), diags
	}

	hostAttribute, ok := attributes["host"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`host is missing from object`)

		return NewServersValueUnknown(), diags
	}

	hostVal, ok := hostAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`host expected to be basetypes.StringValue, was: %T`, hostAttribute))
	}

	portAttribute, ok := attributes["port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port is missing from object`)

		return NewServersValueUnknown(), diags
	}

	portVal, ok := portAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port expected to be basetypes.Int64Value, was: %T`, portAttribute))
	}

	if diags.HasError() {
		return NewServersValueUnknown(), diags
	}

	return ServersValue{
		Host:  hostVal,
		Port:  portVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewServersValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ServersValue {
	object, diags := NewServersValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewServersValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ServersType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewServersValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewServersValueUnknown(), nil
	}

	if in.IsNull() {
		return NewServersValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewServersValueMust(ServersValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ServersType) ValueType(ctx context.Context) attr.Value {
	return ServersValue{}
}

var _ basetypes.ObjectValuable = ServersValue{}

type ServersValue struct {
	Host  basetypes.StringValue `tfsdk:"host"`
	Port  basetypes.Int64Value  `tfsdk:"port"`
	state attr.ValueState
}

func (v ServersValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["host"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["port"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Host.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["host"] = val

		val, err = v.Port.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ServersValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ServersValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ServersValue) String() string {
	return "ServersValue"
}

func (v ServersValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"host": basetypes.StringType{},
		"port": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"host": v.Host,
			"port": v.Port,
		})

	return objVal, diags
}

func (v ServersValue) Equal(o attr.Value) bool {
	other, ok := o.(ServersValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Host.Equal(other.Host) {
		return false
	}

	if !v.Port.Equal(other.Port) {
		return false
	}

	return true
}

func (v ServersValue) Type(ctx context.Context) attr.Type {
	return ServersType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ServersValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"host": basetypes.StringType{},
		"port": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = RatesetType{}

type RatesetType struct {
	basetypes.ObjectType
}

func (t RatesetType) Equal(o attr.Type) bool {
	other, ok := o.(RatesetType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t RatesetType) String() string {
	return "RatesetType"
}

func (t RatesetType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	htAttribute, ok := attributes["ht"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ht is missing from object`)

		return nil, diags
	}

	htVal, ok := htAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ht expected to be basetypes.StringValue, was: %T`, htAttribute))
	}

	legacyAttribute, ok := attributes["legacy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`legacy is missing from object`)

		return nil, diags
	}

	legacyVal, ok := legacyAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`legacy expected to be basetypes.ListValue, was: %T`, legacyAttribute))
	}

	minRssiAttribute, ok := attributes["min_rssi"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`min_rssi is missing from object`)

		return nil, diags
	}

	minRssiVal, ok := minRssiAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`min_rssi expected to be basetypes.Int64Value, was: %T`, minRssiAttribute))
	}

	templateAttribute, ok := attributes["template"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`template is missing from object`)

		return nil, diags
	}

	templateVal, ok := templateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`template expected to be basetypes.StringValue, was: %T`, templateAttribute))
	}

	vhtAttribute, ok := attributes["vht"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vht is missing from object`)

		return nil, diags
	}

	vhtVal, ok := vhtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vht expected to be basetypes.StringValue, was: %T`, vhtAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return RatesetValue{
		Ht:       htVal,
		Legacy:   legacyVal,
		MinRssi:  minRssiVal,
		Template: templateVal,
		Vht:      vhtVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewRatesetValueNull() RatesetValue {
	return RatesetValue{
		state: attr.ValueStateNull,
	}
}

func NewRatesetValueUnknown() RatesetValue {
	return RatesetValue{
		state: attr.ValueStateUnknown,
	}
}

func NewRatesetValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (RatesetValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing RatesetValue Attribute Value",
				"While creating a RatesetValue value, a missing attribute value was detected. "+
					"A RatesetValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RatesetValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid RatesetValue Attribute Type",
				"While creating a RatesetValue value, an invalid attribute value was detected. "+
					"A RatesetValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RatesetValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("RatesetValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra RatesetValue Attribute Value",
				"While creating a RatesetValue value, an extra attribute value was detected. "+
					"A RatesetValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra RatesetValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewRatesetValueUnknown(), diags
	}

	htAttribute, ok := attributes["ht"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ht is missing from object`)

		return NewRatesetValueUnknown(), diags
	}

	htVal, ok := htAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ht expected to be basetypes.StringValue, was: %T`, htAttribute))
	}

	legacyAttribute, ok := attributes["legacy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`legacy is missing from object`)

		return NewRatesetValueUnknown(), diags
	}

	legacyVal, ok := legacyAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`legacy expected to be basetypes.ListValue, was: %T`, legacyAttribute))
	}

	minRssiAttribute, ok := attributes["min_rssi"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`min_rssi is missing from object`)

		return NewRatesetValueUnknown(), diags
	}

	minRssiVal, ok := minRssiAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`min_rssi expected to be basetypes.Int64Value, was: %T`, minRssiAttribute))
	}

	templateAttribute, ok := attributes["template"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`template is missing from object`)

		return NewRatesetValueUnknown(), diags
	}

	templateVal, ok := templateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`template expected to be basetypes.StringValue, was: %T`, templateAttribute))
	}

	vhtAttribute, ok := attributes["vht"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vht is missing from object`)

		return NewRatesetValueUnknown(), diags
	}

	vhtVal, ok := vhtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vht expected to be basetypes.StringValue, was: %T`, vhtAttribute))
	}

	if diags.HasError() {
		return NewRatesetValueUnknown(), diags
	}

	return RatesetValue{
		Ht:       htVal,
		Legacy:   legacyVal,
		MinRssi:  minRssiVal,
		Template: templateVal,
		Vht:      vhtVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewRatesetValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) RatesetValue {
	object, diags := NewRatesetValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewRatesetValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t RatesetType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewRatesetValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewRatesetValueUnknown(), nil
	}

	if in.IsNull() {
		return NewRatesetValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewRatesetValueMust(RatesetValue{}.AttributeTypes(ctx), attributes), nil
}

func (t RatesetType) ValueType(ctx context.Context) attr.Value {
	return RatesetValue{}
}

var _ basetypes.ObjectValuable = RatesetValue{}

type RatesetValue struct {
	Ht       basetypes.StringValue `tfsdk:"ht"`
	Legacy   basetypes.ListValue   `tfsdk:"legacy"`
	MinRssi  basetypes.Int64Value  `tfsdk:"min_rssi"`
	Template basetypes.StringValue `tfsdk:"template"`
	Vht      basetypes.StringValue `tfsdk:"vht"`
	state    attr.ValueState
}

func (v RatesetValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["ht"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["legacy"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["min_rssi"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["template"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["vht"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.Ht.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ht"] = val

		val, err = v.Legacy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["legacy"] = val

		val, err = v.MinRssi.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["min_rssi"] = val

		val, err = v.Template.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["template"] = val

		val, err = v.Vht.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vht"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v RatesetValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v RatesetValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v RatesetValue) String() string {
	return "RatesetValue"
}

func (v RatesetValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	legacyVal, d := types.ListValue(types.StringType, v.Legacy.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"ht": basetypes.StringType{},
			"legacy": basetypes.ListType{
				ElemType: types.StringType,
			},
			"min_rssi": basetypes.Int64Type{},
			"template": basetypes.StringType{},
			"vht":      basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"ht": basetypes.StringType{},
		"legacy": basetypes.ListType{
			ElemType: types.StringType,
		},
		"min_rssi": basetypes.Int64Type{},
		"template": basetypes.StringType{},
		"vht":      basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"ht":       v.Ht,
			"legacy":   legacyVal,
			"min_rssi": v.MinRssi,
			"template": v.Template,
			"vht":      v.Vht,
		})

	return objVal, diags
}

func (v RatesetValue) Equal(o attr.Value) bool {
	other, ok := o.(RatesetValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Ht.Equal(other.Ht) {
		return false
	}

	if !v.Legacy.Equal(other.Legacy) {
		return false
	}

	if !v.MinRssi.Equal(other.MinRssi) {
		return false
	}

	if !v.Template.Equal(other.Template) {
		return false
	}

	if !v.Vht.Equal(other.Vht) {
		return false
	}

	return true
}

func (v RatesetValue) Type(ctx context.Context) attr.Type {
	return RatesetType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v RatesetValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"ht": basetypes.StringType{},
		"legacy": basetypes.ListType{
			ElemType: types.StringType,
		},
		"min_rssi": basetypes.Int64Type{},
		"template": basetypes.StringType{},
		"vht":      basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = ScheduleType{}

type ScheduleType struct {
	basetypes.ObjectType
}

func (t ScheduleType) Equal(o attr.Type) bool {
	other, ok := o.(ScheduleType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ScheduleType) String() string {
	return "ScheduleType"
}

func (t ScheduleType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	hoursAttribute, ok := attributes["hours"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`hours is missing from object`)

		return nil, diags
	}

	hoursVal, ok := hoursAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`hours expected to be basetypes.ObjectValue, was: %T`, hoursAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ScheduleValue{
		Enabled: enabledVal,
		Hours:   hoursVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewScheduleValueNull() ScheduleValue {
	return ScheduleValue{
		state: attr.ValueStateNull,
	}
}

func NewScheduleValueUnknown() ScheduleValue {
	return ScheduleValue{
		state: attr.ValueStateUnknown,
	}
}

func NewScheduleValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ScheduleValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ScheduleValue Attribute Value",
				"While creating a ScheduleValue value, a missing attribute value was detected. "+
					"A ScheduleValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ScheduleValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ScheduleValue Attribute Type",
				"While creating a ScheduleValue value, an invalid attribute value was detected. "+
					"A ScheduleValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ScheduleValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ScheduleValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ScheduleValue Attribute Value",
				"While creating a ScheduleValue value, an extra attribute value was detected. "+
					"A ScheduleValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ScheduleValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewScheduleValueUnknown(), diags
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewScheduleValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	hoursAttribute, ok := attributes["hours"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`hours is missing from object`)

		return NewScheduleValueUnknown(), diags
	}

	hoursVal, ok := hoursAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`hours expected to be basetypes.ObjectValue, was: %T`, hoursAttribute))
	}

	if diags.HasError() {
		return NewScheduleValueUnknown(), diags
	}

	return ScheduleValue{
		Enabled: enabledVal,
		Hours:   hoursVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewScheduleValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ScheduleValue {
	object, diags := NewScheduleValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewScheduleValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ScheduleType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewScheduleValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewScheduleValueUnknown(), nil
	}

	if in.IsNull() {
		return NewScheduleValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewScheduleValueMust(ScheduleValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ScheduleType) ValueType(ctx context.Context) attr.Value {
	return ScheduleValue{}
}

var _ basetypes.ObjectValuable = ScheduleValue{}

type ScheduleValue struct {
	Enabled basetypes.BoolValue   `tfsdk:"enabled"`
	Hours   basetypes.ObjectValue `tfsdk:"hours"`
	state   attr.ValueState
}

func (v ScheduleValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["hours"] = basetypes.ObjectType{
		AttrTypes: HoursValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.Hours.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["hours"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ScheduleValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ScheduleValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ScheduleValue) String() string {
	return "ScheduleValue"
}

func (v ScheduleValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var hours basetypes.ObjectValue

	if v.Hours.IsNull() {
		hours = types.ObjectNull(
			HoursValue{}.AttributeTypes(ctx),
		)
	}

	if v.Hours.IsUnknown() {
		hours = types.ObjectUnknown(
			HoursValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Hours.IsNull() && !v.Hours.IsUnknown() {
		hours = types.ObjectValueMust(
			HoursValue{}.AttributeTypes(ctx),
			v.Hours.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"enabled": basetypes.BoolType{},
		"hours": basetypes.ObjectType{
			AttrTypes: HoursValue{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"enabled": v.Enabled,
			"hours":   hours,
		})

	return objVal, diags
}

func (v ScheduleValue) Equal(o attr.Value) bool {
	other, ok := o.(ScheduleValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.Hours.Equal(other.Hours) {
		return false
	}

	return true
}

func (v ScheduleValue) Type(ctx context.Context) attr.Type {
	return ScheduleType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ScheduleValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"enabled": basetypes.BoolType{},
		"hours": basetypes.ObjectType{
			AttrTypes: HoursValue{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = HoursType{}

type HoursType struct {
	basetypes.ObjectType
}

func (t HoursType) Equal(o attr.Type) bool {
	other, ok := o.(HoursType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t HoursType) String() string {
	return "HoursType"
}

func (t HoursType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	friAttribute, ok := attributes["fri"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fri is missing from object`)

		return nil, diags
	}

	friVal, ok := friAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fri expected to be basetypes.StringValue, was: %T`, friAttribute))
	}

	monAttribute, ok := attributes["mon"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mon is missing from object`)

		return nil, diags
	}

	monVal, ok := monAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mon expected to be basetypes.StringValue, was: %T`, monAttribute))
	}

	satAttribute, ok := attributes["sat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sat is missing from object`)

		return nil, diags
	}

	satVal, ok := satAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sat expected to be basetypes.StringValue, was: %T`, satAttribute))
	}

	sunAttribute, ok := attributes["sun"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sun is missing from object`)

		return nil, diags
	}

	sunVal, ok := sunAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sun expected to be basetypes.StringValue, was: %T`, sunAttribute))
	}

	thuAttribute, ok := attributes["thu"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`thu is missing from object`)

		return nil, diags
	}

	thuVal, ok := thuAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`thu expected to be basetypes.StringValue, was: %T`, thuAttribute))
	}

	tueAttribute, ok := attributes["tue"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tue is missing from object`)

		return nil, diags
	}

	tueVal, ok := tueAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tue expected to be basetypes.StringValue, was: %T`, tueAttribute))
	}

	wedAttribute, ok := attributes["wed"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wed is missing from object`)

		return nil, diags
	}

	wedVal, ok := wedAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wed expected to be basetypes.StringValue, was: %T`, wedAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return HoursValue{
		Fri:   friVal,
		Mon:   monVal,
		Sat:   satVal,
		Sun:   sunVal,
		Thu:   thuVal,
		Tue:   tueVal,
		Wed:   wedVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewHoursValueNull() HoursValue {
	return HoursValue{
		state: attr.ValueStateNull,
	}
}

func NewHoursValueUnknown() HoursValue {
	return HoursValue{
		state: attr.ValueStateUnknown,
	}
}

func NewHoursValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (HoursValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing HoursValue Attribute Value",
				"While creating a HoursValue value, a missing attribute value was detected. "+
					"A HoursValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("HoursValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid HoursValue Attribute Type",
				"While creating a HoursValue value, an invalid attribute value was detected. "+
					"A HoursValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("HoursValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("HoursValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra HoursValue Attribute Value",
				"While creating a HoursValue value, an extra attribute value was detected. "+
					"A HoursValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra HoursValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewHoursValueUnknown(), diags
	}

	friAttribute, ok := attributes["fri"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fri is missing from object`)

		return NewHoursValueUnknown(), diags
	}

	friVal, ok := friAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fri expected to be basetypes.StringValue, was: %T`, friAttribute))
	}

	monAttribute, ok := attributes["mon"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mon is missing from object`)

		return NewHoursValueUnknown(), diags
	}

	monVal, ok := monAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mon expected to be basetypes.StringValue, was: %T`, monAttribute))
	}

	satAttribute, ok := attributes["sat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sat is missing from object`)

		return NewHoursValueUnknown(), diags
	}

	satVal, ok := satAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sat expected to be basetypes.StringValue, was: %T`, satAttribute))
	}

	sunAttribute, ok := attributes["sun"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sun is missing from object`)

		return NewHoursValueUnknown(), diags
	}

	sunVal, ok := sunAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sun expected to be basetypes.StringValue, was: %T`, sunAttribute))
	}

	thuAttribute, ok := attributes["thu"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`thu is missing from object`)

		return NewHoursValueUnknown(), diags
	}

	thuVal, ok := thuAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`thu expected to be basetypes.StringValue, was: %T`, thuAttribute))
	}

	tueAttribute, ok := attributes["tue"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tue is missing from object`)

		return NewHoursValueUnknown(), diags
	}

	tueVal, ok := tueAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tue expected to be basetypes.StringValue, was: %T`, tueAttribute))
	}

	wedAttribute, ok := attributes["wed"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wed is missing from object`)

		return NewHoursValueUnknown(), diags
	}

	wedVal, ok := wedAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wed expected to be basetypes.StringValue, was: %T`, wedAttribute))
	}

	if diags.HasError() {
		return NewHoursValueUnknown(), diags
	}

	return HoursValue{
		Fri:   friVal,
		Mon:   monVal,
		Sat:   satVal,
		Sun:   sunVal,
		Thu:   thuVal,
		Tue:   tueVal,
		Wed:   wedVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewHoursValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) HoursValue {
	object, diags := NewHoursValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewHoursValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t HoursType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewHoursValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewHoursValueUnknown(), nil
	}

	if in.IsNull() {
		return NewHoursValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewHoursValueMust(HoursValue{}.AttributeTypes(ctx), attributes), nil
}

func (t HoursType) ValueType(ctx context.Context) attr.Value {
	return HoursValue{}
}

var _ basetypes.ObjectValuable = HoursValue{}

type HoursValue struct {
	Fri   basetypes.StringValue `tfsdk:"fri"`
	Mon   basetypes.StringValue `tfsdk:"mon"`
	Sat   basetypes.StringValue `tfsdk:"sat"`
	Sun   basetypes.StringValue `tfsdk:"sun"`
	Thu   basetypes.StringValue `tfsdk:"thu"`
	Tue   basetypes.StringValue `tfsdk:"tue"`
	Wed   basetypes.StringValue `tfsdk:"wed"`
	state attr.ValueState
}

func (v HoursValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 7)

	var val tftypes.Value
	var err error

	attrTypes["fri"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["mon"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["sat"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["sun"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["thu"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["tue"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["wed"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 7)

		val, err = v.Fri.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["fri"] = val

		val, err = v.Mon.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mon"] = val

		val, err = v.Sat.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["sat"] = val

		val, err = v.Sun.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["sun"] = val

		val, err = v.Thu.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["thu"] = val

		val, err = v.Tue.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tue"] = val

		val, err = v.Wed.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["wed"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v HoursValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v HoursValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v HoursValue) String() string {
	return "HoursValue"
}

func (v HoursValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"fri": basetypes.StringType{},
		"mon": basetypes.StringType{},
		"sat": basetypes.StringType{},
		"sun": basetypes.StringType{},
		"thu": basetypes.StringType{},
		"tue": basetypes.StringType{},
		"wed": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"fri": v.Fri,
			"mon": v.Mon,
			"sat": v.Sat,
			"sun": v.Sun,
			"thu": v.Thu,
			"tue": v.Tue,
			"wed": v.Wed,
		})

	return objVal, diags
}

func (v HoursValue) Equal(o attr.Value) bool {
	other, ok := o.(HoursValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Fri.Equal(other.Fri) {
		return false
	}

	if !v.Mon.Equal(other.Mon) {
		return false
	}

	if !v.Sat.Equal(other.Sat) {
		return false
	}

	if !v.Sun.Equal(other.Sun) {
		return false
	}

	if !v.Thu.Equal(other.Thu) {
		return false
	}

	if !v.Tue.Equal(other.Tue) {
		return false
	}

	if !v.Wed.Equal(other.Wed) {
		return false
	}

	return true
}

func (v HoursValue) Type(ctx context.Context) attr.Type {
	return HoursType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v HoursValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"fri": basetypes.StringType{},
		"mon": basetypes.StringType{},
		"sat": basetypes.StringType{},
		"sun": basetypes.StringType{},
		"thu": basetypes.StringType{},
		"tue": basetypes.StringType{},
		"wed": basetypes.StringType{},
	}
}
