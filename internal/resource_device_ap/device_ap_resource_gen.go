// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package resource_device_ap

import (
	"context"
	"fmt"
	"github.com/Juniper/terraform-provider-mist/internal/validators"
	"github.com/hashicorp/terraform-plugin-framework-validators/int64validator"
	"github.com/hashicorp/terraform-plugin-framework-validators/listvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/mapvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/booldefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/int64default"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
)

func DeviceApResourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"aeroscout": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"enabled": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "Whether to enable aeroscout config",
						MarkdownDescription: "Whether to enable aeroscout config",
						Default:             booldefault.StaticBool(false),
					},
					"host": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "Required if enabled, aeroscout server host",
						MarkdownDescription: "Required if enabled, aeroscout server host",
						Validators: []validator.String{
							mistvalidator.RequiredWhenValueIs(path.MatchRelative().AtParent().AtName("enabled"), types.BoolValue(true)),
						},
						Default: stringdefault.StaticString(""),
					},
					"locate_connected": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "Whether to enable the feature to allow wireless clients data received and sent to AES server for location calculation",
						MarkdownDescription: "Whether to enable the feature to allow wireless clients data received and sent to AES server for location calculation",
						Default:             booldefault.StaticBool(false),
					},
					"port": schema.Int64Attribute{
						Optional: true,
						Computed: true,
						Default:  int64default.StaticInt64(1144),
					},
				},
				CustomType: AeroscoutType{
					ObjectType: types.ObjectType{
						AttrTypes: AeroscoutValue{}.AttributeTypes(ctx),
					},
				},
				Optional:            true,
				Description:         "Aeroscout AP settings",
				MarkdownDescription: "Aeroscout AP settings",
			},
			"ble_config": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"beacon_enabled": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "Whether Mist beacons is enabled",
						MarkdownDescription: "Whether Mist beacons is enabled",
						Default:             booldefault.StaticBool(true),
					},
					"beacon_rate": schema.Int64Attribute{
						Optional:            true,
						Description:         "Required if `beacon_rate_mode`==`custom`, 1-10, in number-beacons-per-second",
						MarkdownDescription: "Required if `beacon_rate_mode`==`custom`, 1-10, in number-beacons-per-second",
						Validators: []validator.Int64{
							mistvalidator.AllowedWhenValueIs(path.MatchRelative().AtParent().AtName("beacon_rate_mode"), types.StringValue("custom")),
						},
					},
					"beacon_rate_mode": schema.StringAttribute{
						Optional:            true,
						Description:         "enum: `custom`, `default`",
						MarkdownDescription: "enum: `custom`, `default`",
						Validators: []validator.String{
							stringvalidator.OneOf(
								"",
								"custom",
								"default",
							),
						},
					},
					"beam_disabled": schema.ListAttribute{
						ElementType:         types.Int64Type,
						Optional:            true,
						Description:         "List of AP BLE location beam numbers (1-8) which should be disabled at the AP and not transmit location information (where beam 1 is oriented at the top the AP, growing counter-clock-wise, with 9 being the omni BLE beam)",
						MarkdownDescription: "List of AP BLE location beam numbers (1-8) which should be disabled at the AP and not transmit location information (where beam 1 is oriented at the top the AP, growing counter-clock-wise, with 9 being the omni BLE beam)",
						Validators: []validator.List{
							listvalidator.SizeAtLeast(1),
							listvalidator.ValueInt64sAre(int64validator.Between(1, 8)),
						},
					},
					"custom_ble_packet_enabled": schema.BoolAttribute{
						Optional:            true,
						Description:         "Can be enabled if `beacon_enabled`==`true`, whether to send custom packet",
						MarkdownDescription: "Can be enabled if `beacon_enabled`==`true`, whether to send custom packet",
						Validators: []validator.Bool{
							mistvalidator.AllowedWhenValueIs(path.MatchRelative().AtParent().AtName("beacon_enabled"), types.BoolValue(true)),
						},
					},
					"custom_ble_packet_frame": schema.StringAttribute{
						Optional:            true,
						Description:         "The custom frame to be sent out in this beacon. The frame must be a hexstring",
						MarkdownDescription: "The custom frame to be sent out in this beacon. The frame must be a hexstring",
						Validators: []validator.String{
							mistvalidator.AllowedWhenValueIs(path.MatchRelative().AtParent().AtName("custom_ble_packet_enabled"), types.BoolValue(true)),
						},
					},
					"custom_ble_packet_freq_msec": schema.Int64Attribute{
						Optional:            true,
						Description:         "Frequency (msec) of data emitted by custom ble beacon",
						MarkdownDescription: "Frequency (msec) of data emitted by custom ble beacon",
						Validators: []validator.Int64{
							mistvalidator.AllowedWhenValueIs(path.MatchRelative().AtParent().AtName("custom_ble_packet_enabled"), types.BoolValue(true)),
						},
					},
					"eddystone_uid_adv_power": schema.Int64Attribute{
						Optional:            true,
						Description:         "Advertised TX Power, -100 to 20 (dBm), omit this attribute to use default",
						MarkdownDescription: "Advertised TX Power, -100 to 20 (dBm), omit this attribute to use default",
						Validators: []validator.Int64{
							int64validator.Between(-100, 20),
						},
					},
					"eddystone_uid_beams": schema.StringAttribute{
						Optional: true,
					},
					"eddystone_uid_enabled": schema.BoolAttribute{
						Optional:            true,
						Description:         "Only if `beacon_enabled`==`false`, Whether Eddystone-UID beacon is enabled",
						MarkdownDescription: "Only if `beacon_enabled`==`false`, Whether Eddystone-UID beacon is enabled",
						Validators: []validator.Bool{
							mistvalidator.AllowedWhenValueIs(path.MatchRelative().AtParent().AtName("beacon_enabled"), types.BoolValue(false)),
						},
					},
					"eddystone_uid_freq_msec": schema.Int64Attribute{
						Optional:            true,
						Description:         "Frequency (msec) of data emmit by Eddystone-UID beacon",
						MarkdownDescription: "Frequency (msec) of data emmit by Eddystone-UID beacon",
						Validators: []validator.Int64{
							mistvalidator.AllowedWhenValueIs(path.MatchRelative().AtParent().AtName("eddystone_uid_enabled"), types.BoolValue(true)),
						},
					},
					"eddystone_uid_instance": schema.StringAttribute{
						Optional:            true,
						Description:         "Eddystone-UID instance for the device",
						MarkdownDescription: "Eddystone-UID instance for the device",
						Validators: []validator.String{
							mistvalidator.AllowedWhenValueIs(path.MatchRelative().AtParent().AtName("eddystone_uid_enabled"), types.BoolValue(true)),
						},
					},
					"eddystone_uid_namespace": schema.StringAttribute{
						Optional:            true,
						Description:         "Eddystone-UID namespace",
						MarkdownDescription: "Eddystone-UID namespace",
						Validators: []validator.String{
							mistvalidator.AllowedWhenValueIs(path.MatchRelative().AtParent().AtName("eddystone_uid_enabled"), types.BoolValue(true)),
						},
					},
					"eddystone_url_adv_power": schema.Int64Attribute{
						Optional:            true,
						Description:         "Advertised TX Power, -100 to 20 (dBm), omit this attribute to use default",
						MarkdownDescription: "Advertised TX Power, -100 to 20 (dBm), omit this attribute to use default",
						Validators: []validator.Int64{
							int64validator.Between(-100, 20),
						},
					},
					"eddystone_url_beams": schema.StringAttribute{
						Optional: true,
						Validators: []validator.String{
							mistvalidator.AllowedWhenValueIs(path.MatchRelative().AtParent().AtName("eddystone_url_enabled"), types.BoolValue(true)),
						},
					},
					"eddystone_url_enabled": schema.BoolAttribute{
						Optional:            true,
						Description:         "Only if `beacon_enabled`==`false`, Whether Eddystone-URL beacon is enabled",
						MarkdownDescription: "Only if `beacon_enabled`==`false`, Whether Eddystone-URL beacon is enabled",
						Validators: []validator.Bool{
							mistvalidator.AllowedWhenValueIs(path.MatchRelative().AtParent().AtName("beacon_enabled"), types.BoolValue(false)),
						},
					},
					"eddystone_url_freq_msec": schema.Int64Attribute{
						Optional:            true,
						Description:         "Frequency (msec) of data emit by Eddystone-UID beacon",
						MarkdownDescription: "Frequency (msec) of data emit by Eddystone-UID beacon",
						Validators: []validator.Int64{
							mistvalidator.AllowedWhenValueIs(path.MatchRelative().AtParent().AtName("eddystone_url_enabled"), types.BoolValue(true)),
						},
					},
					"eddystone_url_url": schema.StringAttribute{
						Optional:            true,
						Description:         "URL pointed by Eddystone-URL beacon",
						MarkdownDescription: "URL pointed by Eddystone-URL beacon",
						Validators: []validator.String{
							mistvalidator.AllowedWhenValueIs(path.MatchRelative().AtParent().AtName("eddystone_url_enabled"), types.BoolValue(true)),
						},
					},
					"ibeacon_adv_power": schema.Int64Attribute{
						Optional:            true,
						Description:         "Advertised TX Power, -100 to 20 (dBm), omit this attribute to use default",
						MarkdownDescription: "Advertised TX Power, -100 to 20 (dBm), omit this attribute to use default",
						Validators: []validator.Int64{
							int64validator.Between(-100, 20),
						},
					},
					"ibeacon_beams": schema.StringAttribute{
						Optional: true,
						Validators: []validator.String{
							mistvalidator.AllowedWhenValueIs(path.MatchRelative().AtParent().AtName("ibeacon_enabled"), types.BoolValue(true)),
						},
					},
					"ibeacon_enabled": schema.BoolAttribute{
						Optional:            true,
						Description:         "Can be enabled if `beacon_enabled`==`true`, whether to send iBeacon",
						MarkdownDescription: "Can be enabled if `beacon_enabled`==`true`, whether to send iBeacon",
						Validators: []validator.Bool{
							mistvalidator.AllowedWhenValueIs(path.MatchRelative().AtParent().AtName("beacon_enabled"), types.BoolValue(true)),
						},
					},
					"ibeacon_freq_msec": schema.Int64Attribute{
						Optional:            true,
						Description:         "Frequency (msec) of data emmit for iBeacon",
						MarkdownDescription: "Frequency (msec) of data emmit for iBeacon",
						Validators: []validator.Int64{
							mistvalidator.AllowedWhenValueIs(path.MatchRelative().AtParent().AtName("ibeacon_enabled"), types.BoolValue(true)),
						},
					},
					"ibeacon_major": schema.Int64Attribute{
						Optional:            true,
						Description:         "Major number for iBeacon",
						MarkdownDescription: "Major number for iBeacon",
						Validators: []validator.Int64{
							mistvalidator.AllowedWhenValueIs(path.MatchRelative().AtParent().AtName("ibeacon_enabled"), types.BoolValue(true)),
						},
					},
					"ibeacon_minor": schema.Int64Attribute{
						Optional:            true,
						Description:         "Minor number for iBeacon",
						MarkdownDescription: "Minor number for iBeacon",
						Validators: []validator.Int64{
							mistvalidator.AllowedWhenValueIs(path.MatchRelative().AtParent().AtName("ibeacon_enabled"), types.BoolValue(true)),
						},
					},
					"ibeacon_uuid": schema.StringAttribute{
						Optional:            true,
						Description:         "Optional, if not specified, the same UUID as the beacon will be used",
						MarkdownDescription: "Optional, if not specified, the same UUID as the beacon will be used",
						Validators: []validator.String{
							mistvalidator.AllowedWhenValueIs(path.MatchRelative().AtParent().AtName("ibeacon_enabled"), types.BoolValue(true)),
						},
					},
					"power": schema.Int64Attribute{
						Optional:            true,
						Description:         "Required if `power_mode`==`custom`; else use `power_mode` as default",
						MarkdownDescription: "Required if `power_mode`==`custom`; else use `power_mode` as default",
						Validators: []validator.Int64{
							int64validator.Between(2, 7),
						},
					},
					"power_mode": schema.StringAttribute{
						Optional:            true,
						Description:         "enum: `custom`, `default`",
						MarkdownDescription: "enum: `custom`, `default`",
						Validators: []validator.String{
							stringvalidator.OneOf(
								"",
								"custom",
								"default",
							),
						},
					},
				},
				CustomType: BleConfigType{
					ObjectType: types.ObjectType{
						AttrTypes: BleConfigValue{}.AttributeTypes(ctx),
					},
				},
				Optional:            true,
				Description:         "BLE AP settings",
				MarkdownDescription: "BLE AP settings",
			},
			"centrak": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"enabled": schema.BoolAttribute{
						Optional: true,
						Computed: true,
						Default:  booldefault.StaticBool(false),
					},
				},
				CustomType: CentrakType{
					ObjectType: types.ObjectType{
						AttrTypes: CentrakValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
			},
			"client_bridge": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"auth": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"psk": schema.StringAttribute{
								Optional:  true,
								Sensitive: true,
								Validators: []validator.String{
									stringvalidator.LengthBetween(8, 63),
								},
							},
							"type": schema.StringAttribute{
								Optional:            true,
								Computed:            true,
								Description:         "wpa2-AES/CCMPp is assumed when `type`==`psk`. enum: `open`, `psk`",
								MarkdownDescription: "wpa2-AES/CCMPp is assumed when `type`==`psk`. enum: `open`, `psk`",
								Validators: []validator.String{
									stringvalidator.OneOf(
										"",
										"open",
										"psk",
									),
									stringvalidator.LengthAtLeast(1),
								},
								Default: stringdefault.StaticString("psk"),
							},
						},
						CustomType: AuthType{
							ObjectType: types.ObjectType{
								AttrTypes: AuthValue{}.AttributeTypes(ctx),
							},
						},
						Optional: true,
					},
					"enabled": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "When acted as client bridge:\n  * only 5G radio can be used\n  * will not serve as AP on any radios",
						MarkdownDescription: "When acted as client bridge:\n  * only 5G radio can be used\n  * will not serve as AP on any radios",
						Default:             booldefault.StaticBool(false),
					},
					"ssid": schema.StringAttribute{
						Optional: true,
						Validators: []validator.String{
							stringvalidator.LengthAtLeast(1),
						},
					},
				},
				CustomType: ClientBridgeType{
					ObjectType: types.ObjectType{
						AttrTypes: ClientBridgeValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
			},
			"device_id": schema.StringAttribute{
				Required: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"disable_eth1": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Whether to disable eth1 port",
				MarkdownDescription: "Whether to disable eth1 port",
				Default:             booldefault.StaticBool(false),
			},
			"disable_eth2": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Whether to disable eth2 port",
				MarkdownDescription: "Whether to disable eth2 port",
				Default:             booldefault.StaticBool(false),
			},
			"disable_eth3": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Whether to disable eth3 port",
				MarkdownDescription: "Whether to disable eth3 port",
				Default:             booldefault.StaticBool(false),
			},
			"disable_module": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Whether to disable module port",
				MarkdownDescription: "Whether to disable module port",
				Default:             booldefault.StaticBool(false),
			},
			"esl_config": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"cacert": schema.StringAttribute{
						Optional:            true,
						Description:         "Only if `type`==`imagotag` or `type`==`native`",
						MarkdownDescription: "Only if `type`==`imagotag` or `type`==`native`",
						Validators: []validator.String{
							mistvalidator.AllowedWhenValueIsIn(
								path.MatchRelative().AtParent().AtName("type"),
								[]attr.Value{
									types.StringValue("imagotag"),
									types.StringValue("native"),
								},
							),
						},
					},
					"channel": schema.Int64Attribute{
						Optional:            true,
						Description:         "Only if `type`==`imagotag` or `type`==`native`",
						MarkdownDescription: "Only if `type`==`imagotag` or `type`==`native`",
						Validators: []validator.Int64{
							mistvalidator.AllowedWhenValueIsIn(
								path.MatchRelative().AtParent().AtName("type"),
								[]attr.Value{
									types.StringValue("imagotag"),
									types.StringValue("native"),
								},
							),
						},
					},
					"enabled": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "usb_config is ignored if esl_config enabled",
						MarkdownDescription: "usb_config is ignored if esl_config enabled",
						Default:             booldefault.StaticBool(false),
					},
					"host": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "Only if `type`==`imagotag` or `type`==`native`",
						MarkdownDescription: "Only if `type`==`imagotag` or `type`==`native`",
						Validators: []validator.String{
							mistvalidator.AllowedWhenValueIsIn(
								path.MatchRelative().AtParent().AtName("type"),
								[]attr.Value{
									types.StringValue("imagotag"),
									types.StringValue("native"),
								},
							),
						},
						Default: stringdefault.StaticString(""),
					},
					"port": schema.Int64Attribute{
						Optional:            true,
						Description:         "Only if `type`==`imagotag` or `type`==`native`",
						MarkdownDescription: "Only if `type`==`imagotag` or `type`==`native`",
						Validators: []validator.Int64{
							mistvalidator.AllowedWhenValueIsIn(
								path.MatchRelative().AtParent().AtName("type"),
								[]attr.Value{
									types.StringValue("imagotag"),
									types.StringValue("native"),
								},
							),
							int64validator.Between(1, 65535),
						},
					},
					"type": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "note: ble_config will be ignored if esl_config is enabled and with native mode. enum: `hanshow`, `imagotag`, `native`, `solum`",
						MarkdownDescription: "note: ble_config will be ignored if esl_config is enabled and with native mode. enum: `hanshow`, `imagotag`, `native`, `solum`",
						Validators: []validator.String{
							stringvalidator.OneOf(
								"",
								"hanshow",
								"imagotag",
								"native",
								"solum",
							),
						},
						Default: stringdefault.StaticString("imagotag"),
					},
					"verify_cert": schema.BoolAttribute{
						Optional:            true,
						Description:         "Only if `type`==`imagotag` or `type`==`native`",
						MarkdownDescription: "Only if `type`==`imagotag` or `type`==`native`",
						Validators: []validator.Bool{
							mistvalidator.AllowedWhenValueIsIn(
								path.MatchRelative().AtParent().AtName("type"),
								[]attr.Value{
									types.StringValue("imagotag"),
									types.StringValue("native"),
								},
							),
						},
					},
					"vlan_id": schema.Int64Attribute{
						Optional:            true,
						Computed:            true,
						Description:         "Only if `type`==`solum` or `type`==`hanshow`",
						MarkdownDescription: "Only if `type`==`solum` or `type`==`hanshow`",
						Validators: []validator.Int64{
							mistvalidator.AllowedWhenValueIsInWithDefault(
								path.MatchRelative().AtParent().AtName("type"),
								[]attr.Value{
									types.StringValue("solum"),
									types.StringValue("hanshow"),
								},
								types.Int64Value(1),
							),
							int64validator.Between(1, 4094),
						},
						Default: int64default.StaticInt64(1),
					},
				},
				CustomType: EslConfigType{
					ObjectType: types.ObjectType{
						AttrTypes: EslConfigValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
			},
			"flow_control": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "For some AP models, flow_control can be enabled to address some switch compatibility issue",
				MarkdownDescription: "For some AP models, flow_control can be enabled to address some switch compatibility issue",
				Default:             booldefault.StaticBool(false),
			},
			"height": schema.Float64Attribute{
				Optional:            true,
				Description:         "Height, in meters, optional",
				MarkdownDescription: "Height, in meters, optional",
			},
			"image1_url": schema.StringAttribute{
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"image2_url": schema.StringAttribute{
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"image3_url": schema.StringAttribute{
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"ip_config": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"dns": schema.ListAttribute{
						ElementType:         types.StringType,
						Optional:            true,
						Computed:            true,
						Description:         "If `type`==`static`",
						MarkdownDescription: "If `type`==`static`",
						Validators: []validator.List{
							listvalidator.SizeAtLeast(1),
						},
					},
					"dns_suffix": schema.ListAttribute{
						ElementType:         types.StringType,
						Optional:            true,
						Computed:            true,
						Description:         "Required if `type`==`static`",
						MarkdownDescription: "Required if `type`==`static`",
						Validators: []validator.List{
							listvalidator.SizeAtLeast(1),
						},
					},
					"gateway": schema.StringAttribute{
						Optional:            true,
						Description:         "Required if `type`==`static`",
						MarkdownDescription: "Required if `type`==`static`",
						Validators: []validator.String{
							stringvalidator.Any(
								mistvalidator.ParseIp(true, false),
								mistvalidator.ParseVar(),
							),
							mistvalidator.RequiredWhenValueIs(path.MatchRelative().AtParent().AtName("type"), types.StringValue("static")),
							mistvalidator.ForbiddenWhenValueIs(path.MatchRelative().AtParent().AtName("type"), types.StringValue("dhcp")),
						},
					},
					"gateway6": schema.StringAttribute{
						Optional: true,
						Validators: []validator.String{
							stringvalidator.Any(mistvalidator.ParseIp(false, true), mistvalidator.ParseVar()),
							mistvalidator.RequiredWhenValueIs(path.MatchRelative().AtParent().AtName("type6"), types.StringValue("static")),
							mistvalidator.ForbiddenWhenValueIs(path.MatchRelative().AtParent().AtName("type6"), types.StringValue("dhcp")),
							mistvalidator.ForbiddenWhenValueIs(path.MatchRelative().AtParent().AtName("type6"), types.StringValue("autoconf")),
						},
					},
					"ip": schema.StringAttribute{
						Optional:            true,
						Description:         "Required if `type`==`static`",
						MarkdownDescription: "Required if `type`==`static`",
						Validators: []validator.String{
							stringvalidator.Any(mistvalidator.ParseIp(true, false), mistvalidator.ParseVar()),
							mistvalidator.RequiredWhenValueIs(path.MatchRelative().AtParent().AtName("type"), types.StringValue("static")),
							mistvalidator.ForbiddenWhenValueIs(path.MatchRelative().AtParent().AtName("type"), types.StringValue("dhcp")),
						},
					},
					"ip6": schema.StringAttribute{
						Optional: true,
						Validators: []validator.String{
							stringvalidator.Any(mistvalidator.ParseIp(false, true), mistvalidator.ParseVar()),
							mistvalidator.RequiredWhenValueIs(path.MatchRelative().AtParent().AtName("type6"), types.StringValue("static")),
							mistvalidator.ForbiddenWhenValueIs(path.MatchRelative().AtParent().AtName("type6"), types.StringValue("dhcp")),
							mistvalidator.ForbiddenWhenValueIs(path.MatchRelative().AtParent().AtName("type6"), types.StringValue("autoconf")),
						},
					},
					"mtu": schema.Int64Attribute{
						Optional: true,
						Computed: true,
						Default:  int64default.StaticInt64(0),
					},
					"netmask": schema.StringAttribute{
						Optional:            true,
						Description:         "Required if `type`==`static`",
						MarkdownDescription: "Required if `type`==`static`",
						Validators: []validator.String{
							stringvalidator.Any(mistvalidator.ParseNetmask(false, false), mistvalidator.ParseVar()),
							mistvalidator.RequiredWhenValueIs(path.MatchRelative().AtParent().AtName("type"), types.StringValue("static")),
							mistvalidator.ForbiddenWhenValueIs(path.MatchRelative().AtParent().AtName("type"), types.StringValue("dhcp")),
						},
					},
					"netmask6": schema.StringAttribute{
						Optional: true,
						Validators: []validator.String{
							stringvalidator.Any(mistvalidator.ParseNetmask(false, false), mistvalidator.ParseVar()),
							mistvalidator.RequiredWhenValueIs(path.MatchRelative().AtParent().AtName("type6"), types.StringValue("static")),
							mistvalidator.ForbiddenWhenValueIs(path.MatchRelative().AtParent().AtName("type6"), types.StringValue("dhcp")),
							mistvalidator.ForbiddenWhenValueIs(path.MatchRelative().AtParent().AtName("type6"), types.StringValue("autoconf")),
						},
					},
					"type": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "enum: `dhcp`, `static`",
						MarkdownDescription: "enum: `dhcp`, `static`",
						Validators: []validator.String{
							stringvalidator.OneOf(
								"",
								"dhcp",
								"static",
							),
						},
						Default: stringdefault.StaticString("dhcp"),
					},
					"type6": schema.StringAttribute{
						Optional:            true,
						Description:         "enum: `autoconf`, `dhcp`, `disabled`, `static`",
						MarkdownDescription: "enum: `autoconf`, `dhcp`, `disabled`, `static`",
						Validators: []validator.String{
							stringvalidator.OneOf(
								"",
								"autoconf",
								"dhcp",
								"disabled",
								"static",
							),
						},
					},
					"vlan_id": schema.Int64Attribute{
						Optional:            true,
						Description:         "Management VLAN id, default is 1 (untagged)",
						MarkdownDescription: "Management VLAN id, default is 1 (untagged)",
						Validators: []validator.Int64{
							int64validator.Between(1, 4094),
						},
					},
				},
				CustomType: IpConfigType{
					ObjectType: types.ObjectType{
						AttrTypes: IpConfigValue{}.AttributeTypes(ctx),
					},
				},
				Optional:            true,
				Description:         "IP AP settings",
				MarkdownDescription: "IP AP settings",
			},
			"lacp_config": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"enabled": schema.BoolAttribute{
						Optional: true,
						Computed: true,
						Default:  booldefault.StaticBool(false),
					},
				},
				CustomType: LacpConfigType{
					ObjectType: types.ObjectType{
						AttrTypes: LacpConfigValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
			},
			"led": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"brightness": schema.Int64Attribute{
						Optional: true,
						Computed: true,
						Validators: []validator.Int64{
							int64validator.Between(0, 255),
						},
						Default: int64default.StaticInt64(255),
					},
					"enabled": schema.BoolAttribute{
						Optional: true,
						Computed: true,
						Default:  booldefault.StaticBool(true),
					},
				},
				CustomType: LedType{
					ObjectType: types.ObjectType{
						AttrTypes: LedValue{}.AttributeTypes(ctx),
					},
				},
				Optional:            true,
				Description:         "LED AP settings",
				MarkdownDescription: "LED AP settings",
			},
			"locked": schema.BoolAttribute{
				Optional:            true,
				Description:         "Whether this map is considered locked down",
				MarkdownDescription: "Whether this map is considered locked down",
			},
			"mac": schema.StringAttribute{
				Computed:            true,
				Description:         "Device MAC address",
				MarkdownDescription: "Device MAC address",
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"map_id": schema.StringAttribute{
				Optional:            true,
				Description:         "Map where the device belongs to",
				MarkdownDescription: "Map where the device belongs to",
			},
			"mesh": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"bands": schema.ListAttribute{
						ElementType:         types.StringType,
						Optional:            true,
						Description:         "List of bands that the mesh should apply to. For relay, the first viable one will be picked. For relay, the first viable one will be picked. enum: `24`, `5`, `6`",
						MarkdownDescription: "List of bands that the mesh should apply to. For relay, the first viable one will be picked. For relay, the first viable one will be picked. enum: `24`, `5`, `6`",
						Validators: []validator.List{
							listvalidator.SizeAtLeast(1),
						},
					},
					"enabled": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "Whether mesh is enabled on this AP",
						MarkdownDescription: "Whether mesh is enabled on this AP",
						Default:             booldefault.StaticBool(false),
					},
					"group": schema.Int64Attribute{
						Optional:            true,
						Description:         "Mesh group, base AP(s) will only allow remote AP(s) in the same mesh group to join, 1-9, optional",
						MarkdownDescription: "Mesh group, base AP(s) will only allow remote AP(s) in the same mesh group to join, 1-9, optional",
						Validators: []validator.Int64{
							int64validator.Between(1, 9),
						},
					},
					"role": schema.StringAttribute{
						Optional:            true,
						Description:         "enum: `base`, `remote`",
						MarkdownDescription: "enum: `base`, `remote`",
						Validators: []validator.String{
							stringvalidator.OneOf(
								"",
								"base",
								"remote",
							),
						},
					},
				},
				CustomType: MeshType{
					ObjectType: types.ObjectType{
						AttrTypes: MeshValue{}.AttributeTypes(ctx),
					},
				},
				Optional:            true,
				Description:         "Mesh AP settings",
				MarkdownDescription: "Mesh AP settings",
			},
			"model": schema.StringAttribute{
				Computed:            true,
				Description:         "Device Model",
				MarkdownDescription: "Device Model",
			},
			"name": schema.StringAttribute{
				Required: true,
			},
			"notes": schema.StringAttribute{
				Optional:            true,
				Description:         "Any notes about this AP",
				MarkdownDescription: "Any notes about this AP",
			},
			"ntp_servers": schema.ListAttribute{
				ElementType: types.StringType,
				Optional:    true,
				Validators: []validator.List{
					listvalidator.UniqueValues(),
				},
			},
			"org_id": schema.StringAttribute{
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"orientation": schema.Int64Attribute{
				Optional:            true,
				Description:         "Orientation, 0-359, in degrees, up is 0, right is 90.",
				MarkdownDescription: "Orientation, 0-359, in degrees, up is 0, right is 90.",
				Validators: []validator.Int64{
					int64validator.Between(0, 359),
				},
			},
			"poe_passthrough": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Whether to enable power out through module port (for APH) or eth1 (for APL/BT11)",
				MarkdownDescription: "Whether to enable power out through module port (for APH) or eth1 (for APL/BT11)",
				Default:             booldefault.StaticBool(false),
			},
			"port_config": schema.MapNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"disabled": schema.BoolAttribute{
							Optional: true,
							Computed: true,
							Default:  booldefault.StaticBool(false),
						},
						"dynamic_vlan": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"default_vlan_id": schema.Int64Attribute{
									Optional: true,
									Validators: []validator.Int64{
										int64validator.Between(1, 4094),
									},
								},
								"enabled": schema.BoolAttribute{
									Optional: true,
								},
								"type": schema.StringAttribute{
									Optional: true,
								},
								"vlans": schema.MapAttribute{
									ElementType: types.StringType,
									Optional:    true,
								},
							},
							CustomType: DynamicVlanType{
								ObjectType: types.ObjectType{
									AttrTypes: DynamicVlanValue{}.AttributeTypes(ctx),
								},
							},
							Optional:            true,
							Description:         "Optional dynamic vlan",
							MarkdownDescription: "Optional dynamic vlan",
						},
						"enable_mac_auth": schema.BoolAttribute{
							Optional: true,
							Computed: true,
							Default:  booldefault.StaticBool(false),
						},
						"forwarding": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "enum: \n  * `all`: local breakout, All VLANs\n  * `limited`: local breakout, only the VLANs configured in `port_vlan_id` and `vlan_ids`\n  * `mxtunnel`: central breakout to an Org Mist Edge (requires `mxtunnel_id`)\n  * `site_mxedge`: central breakout to a Site Mist Edge (requires `mxtunnel_name`)\n  * `wxtunnel`': central breakout to an Org WxTunnel (requires `wxtunnel_id`)",
							MarkdownDescription: "enum: \n  * `all`: local breakout, All VLANs\n  * `limited`: local breakout, only the VLANs configured in `port_vlan_id` and `vlan_ids`\n  * `mxtunnel`: central breakout to an Org Mist Edge (requires `mxtunnel_id`)\n  * `site_mxedge`: central breakout to a Site Mist Edge (requires `mxtunnel_name`)\n  * `wxtunnel`': central breakout to an Org WxTunnel (requires `wxtunnel_id`)",
							Validators: []validator.String{
								stringvalidator.OneOf(
									"",
									"all",
									"limited",
									"mxtunnel",
									"site_mxedge",
									"wxtunnel",
								),
							},
							Default: stringdefault.StaticString("all"),
						},
						"mac_auth_preferred": schema.BoolAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "When `true`, we'll do dot1x then mac_auth. enable this to prefer mac_auth",
							MarkdownDescription: "When `true`, we'll do dot1x then mac_auth. enable this to prefer mac_auth",
							Default:             booldefault.StaticBool(false),
						},
						"mac_auth_protocol": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "if `enable_mac_auth`==`true`, allows user to select an authentication protocol. enum: `eap-md5`, `eap-peap`, `pap`",
							MarkdownDescription: "if `enable_mac_auth`==`true`, allows user to select an authentication protocol. enum: `eap-md5`, `eap-peap`, `pap`",
							Validators: []validator.String{
								stringvalidator.OneOf(
									"",
									"eap-md5",
									"eap-peap",
									"pap",
								),
							},
							Default: stringdefault.StaticString("pap"),
						},
						"mist_nac": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"enabled": schema.BoolAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "When enabled:\n  * `auth_servers` is ignored\n  * `acct_servers` is ignored\n  * `auth_servers_*` are ignored\n  * `coa_servers` is ignored\n  * `radsec` is ignored\n  * `coa_enabled` is assumed",
									MarkdownDescription: "When enabled:\n  * `auth_servers` is ignored\n  * `acct_servers` is ignored\n  * `auth_servers_*` are ignored\n  * `coa_servers` is ignored\n  * `radsec` is ignored\n  * `coa_enabled` is assumed",
									Default:             booldefault.StaticBool(false),
								},
							},
							CustomType: MistNacType{
								ObjectType: types.ObjectType{
									AttrTypes: MistNacValue{}.AttributeTypes(ctx),
								},
							},
							Optional: true,
						},
						"mx_tunnel_id": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "If `forwarding`==`mxtunnel`, vlan_ids comes from mxtunnel",
							MarkdownDescription: "If `forwarding`==`mxtunnel`, vlan_ids comes from mxtunnel",
							Default:             stringdefault.StaticString(""),
						},
						"mxtunnel_name": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "If `forwarding`==`site_mxedge`, vlan_ids comes from site_mxedge (`mxtunnels` under site setting)",
							MarkdownDescription: "If `forwarding`==`site_mxedge`, vlan_ids comes from site_mxedge (`mxtunnels` under site setting)",
							Default:             stringdefault.StaticString(""),
						},
						"port_auth": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "When doing port auth. enum: `dot1x`, `none`",
							MarkdownDescription: "When doing port auth. enum: `dot1x`, `none`",
							Validators: []validator.String{
								stringvalidator.OneOf(
									"",
									"dot1x",
									"none",
								),
							},
							Default: stringdefault.StaticString("none"),
						},
						"port_vlan_id": schema.Int64Attribute{
							Optional:            true,
							Description:         "If `forwarding`==`limited`",
							MarkdownDescription: "If `forwarding`==`limited`",
							Validators: []validator.Int64{
								int64validator.Between(1, 4094),
							},
						},
						"radius_config": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"acct_interim_interval": schema.Int64Attribute{
									Optional:            true,
									Computed:            true,
									Description:         "How frequently should interim accounting be reported, 60-65535. default is 0 (use one specified in Access-Accept request from RADIUS Server). Very frequent messages can affect the performance of the radius server, 600 and up is recommended when enabled",
									MarkdownDescription: "How frequently should interim accounting be reported, 60-65535. default is 0 (use one specified in Access-Accept request from RADIUS Server). Very frequent messages can affect the performance of the radius server, 600 and up is recommended when enabled",
									Validators: []validator.Int64{
										int64validator.Between(0, 65535),
									},
									Default: int64default.StaticInt64(0),
								},
								"acct_servers": schema.ListNestedAttribute{
									NestedObject: schema.NestedAttributeObject{
										Attributes: map[string]schema.Attribute{
											"host": schema.StringAttribute{
												Required:            true,
												Description:         "IP/ hostname of RADIUS server",
												MarkdownDescription: "IP/ hostname of RADIUS server",
											},
											"keywrap_enabled": schema.BoolAttribute{
												Optional: true,
											},
											"keywrap_format": schema.StringAttribute{
												Optional:            true,
												Description:         "enum: `ascii`, `hex`",
												MarkdownDescription: "enum: `ascii`, `hex`",
												Validators: []validator.String{
													stringvalidator.OneOf(
														"",
														"ascii",
														"hex",
													),
												},
											},
											"keywrap_kek": schema.StringAttribute{
												Optional: true,
											},
											"keywrap_mack": schema.StringAttribute{
												Optional: true,
											},
											"port": schema.StringAttribute{
												Optional: true,
											},
											"secret": schema.StringAttribute{
												Required:            true,
												Sensitive:           true,
												Description:         "Secret of RADIUS server",
												MarkdownDescription: "Secret of RADIUS server",
											},
										},
										CustomType: AcctServersType{
											ObjectType: types.ObjectType{
												AttrTypes: AcctServersValue{}.AttributeTypes(ctx),
											},
										},
									},
									Optional: true,
									Validators: []validator.List{
										listvalidator.UniqueValues(),
									},
								},
								"auth_servers": schema.ListNestedAttribute{
									NestedObject: schema.NestedAttributeObject{
										Attributes: map[string]schema.Attribute{
											"host": schema.StringAttribute{
												Required:            true,
												Description:         "IP/ hostname of RADIUS server",
												MarkdownDescription: "IP/ hostname of RADIUS server",
											},
											"keywrap_enabled": schema.BoolAttribute{
												Optional: true,
											},
											"keywrap_format": schema.StringAttribute{
												Optional:            true,
												Description:         "enum: `ascii`, `hex`",
												MarkdownDescription: "enum: `ascii`, `hex`",
												Validators: []validator.String{
													stringvalidator.OneOf(
														"",
														"ascii",
														"hex",
													),
												},
											},
											"keywrap_kek": schema.StringAttribute{
												Optional: true,
											},
											"keywrap_mack": schema.StringAttribute{
												Optional: true,
											},
											"port": schema.StringAttribute{
												Optional: true,
											},
											"require_message_authenticator": schema.BoolAttribute{
												Optional:            true,
												Computed:            true,
												Description:         "Whether to require Message-Authenticator in requests",
												MarkdownDescription: "Whether to require Message-Authenticator in requests",
												Default:             booldefault.StaticBool(false),
											},
											"secret": schema.StringAttribute{
												Required:            true,
												Sensitive:           true,
												Description:         "Secret of RADIUS server",
												MarkdownDescription: "Secret of RADIUS server",
											},
										},
										CustomType: AuthServersType{
											ObjectType: types.ObjectType{
												AttrTypes: AuthServersValue{}.AttributeTypes(ctx),
											},
										},
									},
									Optional: true,
									Validators: []validator.List{
										listvalidator.SizeAtLeast(1),
										listvalidator.UniqueValues(),
									},
								},
								"auth_servers_retries": schema.Int64Attribute{
									Optional:            true,
									Computed:            true,
									Description:         "radius auth session retries",
									MarkdownDescription: "radius auth session retries",
									Default:             int64default.StaticInt64(3),
								},
								"auth_servers_timeout": schema.Int64Attribute{
									Optional:            true,
									Computed:            true,
									Description:         "radius auth session timeout",
									MarkdownDescription: "radius auth session timeout",
									Default:             int64default.StaticInt64(5),
								},
								"coa_enabled": schema.BoolAttribute{
									Optional: true,
									Computed: true,
									Default:  booldefault.StaticBool(false),
								},
								"coa_port": schema.Int64Attribute{
									Optional: true,
									Computed: true,
									Validators: []validator.Int64{
										int64validator.Between(1, 65535),
									},
									Default: int64default.StaticInt64(3799),
								},
								"network": schema.StringAttribute{
									Optional:            true,
									Description:         "use `network`or `source_ip`, which network the RADIUS server resides, if there's static IP for this network, we'd use it as source-ip",
									MarkdownDescription: "use `network`or `source_ip`, which network the RADIUS server resides, if there's static IP for this network, we'd use it as source-ip",
								},
								"source_ip": schema.StringAttribute{
									Optional:            true,
									Description:         "use `network`or `source_ip`",
									MarkdownDescription: "use `network`or `source_ip`",
								},
							},
							CustomType: RadiusConfigType{
								ObjectType: types.ObjectType{
									AttrTypes: RadiusConfigValue{}.AttributeTypes(ctx),
								},
							},
							Optional:            true,
							Description:         "Junos Radius config",
							MarkdownDescription: "Junos Radius config",
						},
						"radsec": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"coa_enabled": schema.BoolAttribute{
									Optional: true,
									Computed: true,
									Default:  booldefault.StaticBool(false),
								},
								"enabled": schema.BoolAttribute{
									Optional: true,
								},
								"idle_timeout": schema.StringAttribute{
									Optional: true,
								},
								"mxcluster_ids": schema.ListAttribute{
									ElementType:         types.StringType,
									Optional:            true,
									Description:         "To use Org mxedges when this WLAN does not use mxtunnel, specify their mxcluster_ids. Org mxedge(s) identified by mxcluster_ids",
									MarkdownDescription: "To use Org mxedges when this WLAN does not use mxtunnel, specify their mxcluster_ids. Org mxedge(s) identified by mxcluster_ids",
								},
								"proxy_hosts": schema.ListAttribute{
									ElementType:         types.StringType,
									Optional:            true,
									Description:         "Default is site.mxedge.radsec.proxy_hosts which must be a superset of all `wlans[*].radsec.proxy_hosts`. When `radsec.proxy_hosts` are not used, tunnel peers (org or site mxedges) are used irrespective of `use_site_mxedge`",
									MarkdownDescription: "Default is site.mxedge.radsec.proxy_hosts which must be a superset of all `wlans[*].radsec.proxy_hosts`. When `radsec.proxy_hosts` are not used, tunnel peers (org or site mxedges) are used irrespective of `use_site_mxedge`",
								},
								"server_name": schema.StringAttribute{
									Optional:            true,
									Description:         "Name of the server to verify (against the cacerts in Org Setting). Only if not Mist Edge.",
									MarkdownDescription: "Name of the server to verify (against the cacerts in Org Setting). Only if not Mist Edge.",
								},
								"servers": schema.ListNestedAttribute{
									NestedObject: schema.NestedAttributeObject{
										Attributes: map[string]schema.Attribute{
											"host": schema.StringAttribute{
												Optional: true,
											},
											"port": schema.Int64Attribute{
												Optional: true,
												Validators: []validator.Int64{
													int64validator.Between(1, 65535),
												},
											},
										},
										CustomType: ServersType{
											ObjectType: types.ObjectType{
												AttrTypes: ServersValue{}.AttributeTypes(ctx),
											},
										},
									},
									Optional:            true,
									Description:         "List of RadSec Servers. Only if not Mist Edge.",
									MarkdownDescription: "List of RadSec Servers. Only if not Mist Edge.",
									Validators: []validator.List{
										listvalidator.UniqueValues(),
									},
								},
								"use_mxedge": schema.BoolAttribute{
									Optional:            true,
									Description:         "use mxedge(s) as RadSec Proxy",
									MarkdownDescription: "use mxedge(s) as RadSec Proxy",
								},
								"use_site_mxedge": schema.BoolAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "To use Site mxedges when this WLAN does not use mxtunnel",
									MarkdownDescription: "To use Site mxedges when this WLAN does not use mxtunnel",
									Default:             booldefault.StaticBool(false),
								},
							},
							CustomType: RadsecType{
								ObjectType: types.ObjectType{
									AttrTypes: RadsecValue{}.AttributeTypes(ctx),
								},
							},
							Optional:            true,
							Description:         "RadSec settings",
							MarkdownDescription: "RadSec settings",
						},
						"vlan_id": schema.Int64Attribute{
							Optional:            true,
							Description:         "Optional to specify the vlan id for a tunnel if forwarding is for `wxtunnel`, `mxtunnel` or `site_mxedge`.\n  * if vlan_id is not specified then it will use first one in vlan_ids[] of the mxtunnel.\n  * if forwarding == site_mxedge, vlan_ids comes from site_mxedge (`mxtunnels` under site setting)",
							MarkdownDescription: "Optional to specify the vlan id for a tunnel if forwarding is for `wxtunnel`, `mxtunnel` or `site_mxedge`.\n  * if vlan_id is not specified then it will use first one in vlan_ids[] of the mxtunnel.\n  * if forwarding == site_mxedge, vlan_ids comes from site_mxedge (`mxtunnels` under site setting)",
							Validators: []validator.Int64{
								int64validator.Between(1, 4094),
							},
						},
						"vlan_ids": schema.ListAttribute{
							ElementType:         types.Int64Type,
							Optional:            true,
							Description:         "If `forwarding`==`limited`",
							MarkdownDescription: "If `forwarding`==`limited`",
						},
						"wxtunnel_id": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "If `forwarding`==`wxtunnel`, the port is bridged to the vlan of the session",
							MarkdownDescription: "If `forwarding`==`wxtunnel`, the port is bridged to the vlan of the session",
							Default:             stringdefault.StaticString(""),
						},
						"wxtunnel_remote_id": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "If `forwarding`==`wxtunnel`, the port is bridged to the vlan of the session",
							MarkdownDescription: "If `forwarding`==`wxtunnel`, the port is bridged to the vlan of the session",
							Default:             stringdefault.StaticString(""),
						},
					},
					CustomType: PortConfigType{
						ObjectType: types.ObjectType{
							AttrTypes: PortConfigValue{}.AttributeTypes(ctx),
						},
					},
				},
				Optional:            true,
				Description:         "eth0 is not allowed here. Property key is the interface(s) name (e.g. `eth1` or `eth1,eth2`). If spcified, this takes predecence over switch_config (deprecated)",
				MarkdownDescription: "eth0 is not allowed here. Property key is the interface(s) name (e.g. `eth1` or `eth1,eth2`). If spcified, this takes predecence over switch_config (deprecated)",
				Validators: []validator.Map{
					mapvalidator.SizeAtLeast(1),
				},
			},
			"pwr_config": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"base": schema.Int64Attribute{
						Optional:            true,
						Computed:            true,
						Description:         "Additional power to request during negotiating with PSE over PoE, in mW",
						MarkdownDescription: "Additional power to request during negotiating with PSE over PoE, in mW",
						Default:             int64default.StaticInt64(0),
					},
					"prefer_usb_over_wifi": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "Whether to enable power out to peripheral, meanwhile will reduce power to Wi-Fi (only for AP45 at power mode)",
						MarkdownDescription: "Whether to enable power out to peripheral, meanwhile will reduce power to Wi-Fi (only for AP45 at power mode)",
						Default:             booldefault.StaticBool(false),
					},
				},
				CustomType: PwrConfigType{
					ObjectType: types.ObjectType{
						AttrTypes: PwrConfigValue{}.AttributeTypes(ctx),
					},
				},
				Optional:            true,
				Description:         "Power related configs",
				MarkdownDescription: "Power related configs",
			},
			"radio_config": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"allow_rrm_disable": schema.BoolAttribute{
						Optional: true,
					},
					"ant_gain_24": schema.Int64Attribute{
						Optional:            true,
						Description:         "Antenna gain for 2.4G - for models with external antenna only",
						MarkdownDescription: "Antenna gain for 2.4G - for models with external antenna only",
						Validators: []validator.Int64{
							int64validator.AtLeast(0),
						},
					},
					"ant_gain_5": schema.Int64Attribute{
						Optional:            true,
						Description:         "Antenna gain for 5G - for models with external antenna only",
						MarkdownDescription: "Antenna gain for 5G - for models with external antenna only",
						Validators: []validator.Int64{
							int64validator.AtLeast(0),
						},
					},
					"ant_gain_6": schema.Int64Attribute{
						Optional:            true,
						Description:         "Antenna gain for 6G - for models with external antenna only",
						MarkdownDescription: "Antenna gain for 6G - for models with external antenna only",
						Validators: []validator.Int64{
							int64validator.AtLeast(0),
						},
					},
					"antenna_mode": schema.StringAttribute{
						Optional:            true,
						Description:         "enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`",
						MarkdownDescription: "enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`",
						Validators: []validator.String{
							stringvalidator.OneOf(
								"",
								"1x1",
								"2x2",
								"3x3",
								"4x4",
								"default",
							),
						},
					},
					"band_24": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"allow_rrm_disable": schema.BoolAttribute{
								Optional: true,
								Computed: true,
								Default:  booldefault.StaticBool(false),
							},
							"ant_gain": schema.Int64Attribute{
								Optional: true,
								Computed: true,
								Validators: []validator.Int64{
									int64validator.Between(0, 10),
								},
								Default: int64default.StaticInt64(0),
							},
							"antenna_mode": schema.StringAttribute{
								Optional:            true,
								Computed:            true,
								Description:         "enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`",
								MarkdownDescription: "enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`",
								Validators: []validator.String{
									stringvalidator.OneOf(
										"",
										"1x1",
										"2x2",
										"3x3",
										"4x4",
										"default",
									),
								},
								Default: stringdefault.StaticString("default"),
							},
							"bandwidth": schema.Int64Attribute{
								Optional:            true,
								Computed:            true,
								Description:         "channel width for the 2.4GHz band. enum: `20`, `40`",
								MarkdownDescription: "channel width for the 2.4GHz band. enum: `20`, `40`",
								Validators: []validator.Int64{
									int64validator.OneOf(
										20,
										40,
									),
								},
								Default: int64default.StaticInt64(20),
							},
							"channel": schema.Int64Attribute{
								Optional:            true,
								Computed:            true,
								Description:         "For Device. (primary) channel for the band, 0 means using the Site Setting",
								MarkdownDescription: "For Device. (primary) channel for the band, 0 means using the Site Setting",
								Validators: []validator.Int64{
									int64validator.Between(1, 13),
								},
								Default: int64default.StaticInt64(0),
							},
							"channels": schema.ListAttribute{
								ElementType:         types.Int64Type,
								Optional:            true,
								Description:         "For RFTemplates. List of channels, null or empty array means auto",
								MarkdownDescription: "For RFTemplates. List of channels, null or empty array means auto",
							},
							"disabled": schema.BoolAttribute{
								Optional:            true,
								Computed:            true,
								Description:         "Whether to disable the radio",
								MarkdownDescription: "Whether to disable the radio",
								Default:             booldefault.StaticBool(false),
							},
							"power": schema.Int64Attribute{
								Optional:            true,
								Computed:            true,
								Description:         "TX power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / : treated as 0 / -1 / -2 / ",
								MarkdownDescription: "TX power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / : treated as 0 / -1 / -2 / ",
								Validators: []validator.Int64{
									int64validator.Between(3, 25),
								},
								Default: int64default.StaticInt64(0),
							},
							"power_max": schema.Int64Attribute{
								Optional:            true,
								Computed:            true,
								Description:         "When power=0, max tx power to use, HW-specific values will be used if not set",
								MarkdownDescription: "When power=0, max tx power to use, HW-specific values will be used if not set",
								Validators: []validator.Int64{
									int64validator.Between(3, 18),
								},
								Default: int64default.StaticInt64(17),
							},
							"power_min": schema.Int64Attribute{
								Optional:            true,
								Computed:            true,
								Description:         "When power=0, min tx power to use, HW-specific values will be used if not set",
								MarkdownDescription: "When power=0, min tx power to use, HW-specific values will be used if not set",
								Validators: []validator.Int64{
									int64validator.Between(3, 18),
								},
								Default: int64default.StaticInt64(8),
							},
							"preamble": schema.StringAttribute{
								Optional:            true,
								Computed:            true,
								Description:         "enum: `auto`, `long`, `short`",
								MarkdownDescription: "enum: `auto`, `long`, `short`",
								Validators: []validator.String{
									stringvalidator.OneOf(
										"",
										"auto",
										"long",
										"short",
									),
								},
								Default: stringdefault.StaticString("short"),
							},
						},
						CustomType: Band24Type{
							ObjectType: types.ObjectType{
								AttrTypes: Band24Value{}.AttributeTypes(ctx),
							},
						},
						Optional:            true,
						Description:         "Radio Band AP settings",
						MarkdownDescription: "Radio Band AP settings",
					},
					"band_24_usage": schema.StringAttribute{
						Optional:            true,
						Description:         "enum: `24`, `5`, `6`, `auto`",
						MarkdownDescription: "enum: `24`, `5`, `6`, `auto`",
						Validators: []validator.String{
							stringvalidator.OneOf(
								"",
								"24",
								"5",
								"6",
								"auto",
							),
						},
					},
					"band_5": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"allow_rrm_disable": schema.BoolAttribute{
								Optional: true,
								Computed: true,
								Default:  booldefault.StaticBool(false),
							},
							"ant_gain": schema.Int64Attribute{
								Optional: true,
								Computed: true,
								Validators: []validator.Int64{
									int64validator.Between(0, 10),
								},
								Default: int64default.StaticInt64(0),
							},
							"antenna_mode": schema.StringAttribute{
								Optional:            true,
								Computed:            true,
								Description:         "enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`",
								MarkdownDescription: "enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`",
								Validators: []validator.String{
									stringvalidator.OneOf(
										"",
										"1x1",
										"2x2",
										"3x3",
										"4x4",
										"default",
									),
								},
								Default: stringdefault.StaticString("default"),
							},
							"bandwidth": schema.Int64Attribute{
								Optional:            true,
								Computed:            true,
								Description:         "channel width for the 5GHz band. enum: `20`, `40`, `80`",
								MarkdownDescription: "channel width for the 5GHz band. enum: `20`, `40`, `80`",
								Validators: []validator.Int64{
									int64validator.OneOf(
										20,
										40,
										80,
									),
								},
								Default: int64default.StaticInt64(40),
							},
							"channel": schema.Int64Attribute{
								Optional:            true,
								Computed:            true,
								Description:         "For Device. (primary) channel for the band, 0 means using the Site Setting",
								MarkdownDescription: "For Device. (primary) channel for the band, 0 means using the Site Setting",
								Default:             int64default.StaticInt64(0),
							},
							"channels": schema.ListAttribute{
								ElementType:         types.Int64Type,
								Optional:            true,
								Description:         "For RFTemplates. List of channels, null or empty array means auto",
								MarkdownDescription: "For RFTemplates. List of channels, null or empty array means auto",
							},
							"disabled": schema.BoolAttribute{
								Optional:            true,
								Computed:            true,
								Description:         "Whether to disable the radio",
								MarkdownDescription: "Whether to disable the radio",
								Default:             booldefault.StaticBool(false),
							},
							"power": schema.Int64Attribute{
								Optional:            true,
								Computed:            true,
								Description:         "TX power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / : treated as 0 / -1 / -2 / ",
								MarkdownDescription: "TX power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / : treated as 0 / -1 / -2 / ",
								Validators: []validator.Int64{
									int64validator.Between(5, 25),
								},
								Default: int64default.StaticInt64(0),
							},
							"power_max": schema.Int64Attribute{
								Optional:            true,
								Computed:            true,
								Description:         "When power=0, max tx power to use, HW-specific values will be used if not set",
								MarkdownDescription: "When power=0, max tx power to use, HW-specific values will be used if not set",
								Validators: []validator.Int64{
									int64validator.Between(5, 17),
								},
								Default: int64default.StaticInt64(17),
							},
							"power_min": schema.Int64Attribute{
								Optional:            true,
								Computed:            true,
								Description:         "When power=0, min tx power to use, HW-specific values will be used if not set",
								MarkdownDescription: "When power=0, min tx power to use, HW-specific values will be used if not set",
								Validators: []validator.Int64{
									int64validator.Between(5, 17),
								},
								Default: int64default.StaticInt64(8),
							},
							"preamble": schema.StringAttribute{
								Optional:            true,
								Computed:            true,
								Description:         "enum: `auto`, `long`, `short`",
								MarkdownDescription: "enum: `auto`, `long`, `short`",
								Validators: []validator.String{
									stringvalidator.OneOf(
										"",
										"auto",
										"long",
										"short",
									),
								},
								Default: stringdefault.StaticString("short"),
							},
						},
						CustomType: Band5Type{
							ObjectType: types.ObjectType{
								AttrTypes: Band5Value{}.AttributeTypes(ctx),
							},
						},
						Optional:            true,
						Description:         "Radio Band AP settings",
						MarkdownDescription: "Radio Band AP settings",
					},
					"band_5_on_24_radio": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"allow_rrm_disable": schema.BoolAttribute{
								Optional: true,
								Computed: true,
								Default:  booldefault.StaticBool(false),
							},
							"ant_gain": schema.Int64Attribute{
								Optional: true,
								Computed: true,
								Validators: []validator.Int64{
									int64validator.Between(0, 10),
								},
								Default: int64default.StaticInt64(0),
							},
							"antenna_mode": schema.StringAttribute{
								Optional:            true,
								Computed:            true,
								Description:         "enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`",
								MarkdownDescription: "enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`",
								Validators: []validator.String{
									stringvalidator.OneOf(
										"",
										"1x1",
										"2x2",
										"3x3",
										"4x4",
										"default",
									),
								},
								Default: stringdefault.StaticString("default"),
							},
							"bandwidth": schema.Int64Attribute{
								Optional:            true,
								Computed:            true,
								Description:         "channel width for the 5GHz band. enum: `20`, `40`, `80`",
								MarkdownDescription: "channel width for the 5GHz band. enum: `20`, `40`, `80`",
								Validators: []validator.Int64{
									int64validator.OneOf(
										20,
										40,
										80,
									),
								},
								Default: int64default.StaticInt64(40),
							},
							"channel": schema.Int64Attribute{
								Optional:            true,
								Computed:            true,
								Description:         "For Device. (primary) channel for the band, 0 means using the Site Setting",
								MarkdownDescription: "For Device. (primary) channel for the band, 0 means using the Site Setting",
								Default:             int64default.StaticInt64(0),
							},
							"channels": schema.ListAttribute{
								ElementType:         types.Int64Type,
								Optional:            true,
								Description:         "For RFTemplates. List of channels, null or empty array means auto",
								MarkdownDescription: "For RFTemplates. List of channels, null or empty array means auto",
							},
							"disabled": schema.BoolAttribute{
								Optional:            true,
								Computed:            true,
								Description:         "Whether to disable the radio",
								MarkdownDescription: "Whether to disable the radio",
								Default:             booldefault.StaticBool(false),
							},
							"power": schema.Int64Attribute{
								Optional:            true,
								Computed:            true,
								Description:         "TX power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / : treated as 0 / -1 / -2 / ",
								MarkdownDescription: "TX power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / : treated as 0 / -1 / -2 / ",
								Validators: []validator.Int64{
									int64validator.Between(5, 25),
								},
								Default: int64default.StaticInt64(0),
							},
							"power_max": schema.Int64Attribute{
								Optional:            true,
								Computed:            true,
								Description:         "When power=0, max tx power to use, HW-specific values will be used if not set",
								MarkdownDescription: "When power=0, max tx power to use, HW-specific values will be used if not set",
								Validators: []validator.Int64{
									int64validator.Between(5, 17),
								},
								Default: int64default.StaticInt64(17),
							},
							"power_min": schema.Int64Attribute{
								Optional:            true,
								Computed:            true,
								Description:         "When power=0, min tx power to use, HW-specific values will be used if not set",
								MarkdownDescription: "When power=0, min tx power to use, HW-specific values will be used if not set",
								Validators: []validator.Int64{
									int64validator.Between(5, 17),
								},
								Default: int64default.StaticInt64(8),
							},
							"preamble": schema.StringAttribute{
								Optional:            true,
								Computed:            true,
								Description:         "enum: `auto`, `long`, `short`",
								MarkdownDescription: "enum: `auto`, `long`, `short`",
								Validators: []validator.String{
									stringvalidator.OneOf(
										"",
										"auto",
										"long",
										"short",
									),
								},
								Default: stringdefault.StaticString("short"),
							},
						},
						CustomType: Band5On24RadioType{
							ObjectType: types.ObjectType{
								AttrTypes: Band5On24RadioValue{}.AttributeTypes(ctx),
							},
						},
						Optional:            true,
						Description:         "Radio Band AP settings",
						MarkdownDescription: "Radio Band AP settings",
					},
					"band_6": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"allow_rrm_disable": schema.BoolAttribute{
								Optional: true,
								Computed: true,
								Default:  booldefault.StaticBool(false),
							},
							"ant_gain": schema.Int64Attribute{
								Optional: true,
								Computed: true,
								Validators: []validator.Int64{
									int64validator.Between(0, 10),
								},
								Default: int64default.StaticInt64(0),
							},
							"antenna_mode": schema.StringAttribute{
								Optional:            true,
								Computed:            true,
								Description:         "enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`",
								MarkdownDescription: "enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`",
								Validators: []validator.String{
									stringvalidator.OneOf(
										"",
										"1x1",
										"2x2",
										"3x3",
										"4x4",
										"default",
									),
								},
								Default: stringdefault.StaticString("default"),
							},
							"bandwidth": schema.Int64Attribute{
								Optional:            true,
								Computed:            true,
								Description:         "channel width for the 6GHz band. enum: `20`, `40`, `80`, `160`",
								MarkdownDescription: "channel width for the 6GHz band. enum: `20`, `40`, `80`, `160`",
								Validators: []validator.Int64{
									int64validator.OneOf(
										20,
										40,
										80,
										160,
									),
								},
								Default: int64default.StaticInt64(80),
							},
							"channel": schema.Int64Attribute{
								Optional:            true,
								Computed:            true,
								Description:         "For Device. (primary) channel for the band, 0 means using the Site Setting",
								MarkdownDescription: "For Device. (primary) channel for the band, 0 means using the Site Setting",
								Default:             int64default.StaticInt64(0),
							},
							"channels": schema.ListAttribute{
								ElementType:         types.Int64Type,
								Optional:            true,
								Description:         "For RFTemplates. List of channels, null or empty array means auto",
								MarkdownDescription: "For RFTemplates. List of channels, null or empty array means auto",
							},
							"disabled": schema.BoolAttribute{
								Optional:            true,
								Computed:            true,
								Description:         "Whether to disable the radio",
								MarkdownDescription: "Whether to disable the radio",
								Default:             booldefault.StaticBool(false),
							},
							"power": schema.Int64Attribute{
								Optional:            true,
								Computed:            true,
								Description:         "TX power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / : treated as 0 / -1 / -2 / ",
								MarkdownDescription: "TX power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / : treated as 0 / -1 / -2 / ",
								Validators: []validator.Int64{
									int64validator.Between(5, 25),
								},
								Default: int64default.StaticInt64(0),
							},
							"power_max": schema.Int64Attribute{
								Optional:            true,
								Computed:            true,
								Description:         "When power=0, max tx power to use, HW-specific values will be used if not set",
								MarkdownDescription: "When power=0, max tx power to use, HW-specific values will be used if not set",
								Validators: []validator.Int64{
									int64validator.Between(5, 18),
								},
								Default: int64default.StaticInt64(18),
							},
							"power_min": schema.Int64Attribute{
								Optional:            true,
								Computed:            true,
								Description:         "When power=0, min tx power to use, HW-specific values will be used if not set",
								MarkdownDescription: "When power=0, min tx power to use, HW-specific values will be used if not set",
								Validators: []validator.Int64{
									int64validator.Between(5, 18),
								},
								Default: int64default.StaticInt64(8),
							},
							"preamble": schema.StringAttribute{
								Optional:            true,
								Computed:            true,
								Description:         "enum: `auto`, `long`, `short`",
								MarkdownDescription: "enum: `auto`, `long`, `short`",
								Validators: []validator.String{
									stringvalidator.OneOf(
										"",
										"auto",
										"long",
										"short",
									),
								},
								Default: stringdefault.StaticString("short"),
							},
							"standard_power": schema.BoolAttribute{
								Optional:            true,
								Computed:            true,
								Description:         "For 6GHz Only, standard-power operation, AFC (Automatic Frequency Coordination) will be performed, and we'll fall back to Low Power Indoor if AFC failed",
								MarkdownDescription: "For 6GHz Only, standard-power operation, AFC (Automatic Frequency Coordination) will be performed, and we'll fall back to Low Power Indoor if AFC failed",
								Default:             booldefault.StaticBool(false),
							},
						},
						CustomType: Band6Type{
							ObjectType: types.ObjectType{
								AttrTypes: Band6Value{}.AttributeTypes(ctx),
							},
						},
						Optional:            true,
						Description:         "Radio Band AP settings",
						MarkdownDescription: "Radio Band AP settings",
					},
					"full_automatic_rrm": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "Let RRM control everything, only the `channels` and `ant_gain` will be honored (i.e. disabled/bandwidth/power/band_24_usage are all controlled by RRM)",
						MarkdownDescription: "Let RRM control everything, only the `channels` and `ant_gain` will be honored (i.e. disabled/bandwidth/power/band_24_usage are all controlled by RRM)",
						Default:             booldefault.StaticBool(false),
					},
					"indoor_use": schema.BoolAttribute{
						Optional:            true,
						Description:         "To make an outdoor operate indoor. For an outdoor-ap, some channels are disallowed by default, this allows the user to use it as an indoor-ap",
						MarkdownDescription: "To make an outdoor operate indoor. For an outdoor-ap, some channels are disallowed by default, this allows the user to use it as an indoor-ap",
					},
					"scanning_enabled": schema.BoolAttribute{
						Optional:            true,
						Description:         "Whether scanning radio is enabled",
						MarkdownDescription: "Whether scanning radio is enabled",
					},
				},
				CustomType: RadioConfigType{
					ObjectType: types.ObjectType{
						AttrTypes: RadioConfigValue{}.AttributeTypes(ctx),
					},
				},
				Optional:            true,
				Description:         "Radio AP settings",
				MarkdownDescription: "Radio AP settings",
			},
			"serial": schema.StringAttribute{
				Computed:            true,
				Description:         "Device Serial",
				MarkdownDescription: "Device Serial",
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"site_id": schema.StringAttribute{
				Required: true,
			},
			"type": schema.StringAttribute{
				Computed:            true,
				Description:         "Device Type. enum: `ap`",
				MarkdownDescription: "Device Type. enum: `ap`",
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
				Validators: []validator.String{
					stringvalidator.OneOf(
						"",
						"ap",
					),
				},
			},
			"uplink_port_config": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"dot1x": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "Whether to do 802.1x against uplink switch. When enabled, AP cert will be used to do EAP-TLS and the Org's CA Cert has to be provisioned at the switch",
						MarkdownDescription: "Whether to do 802.1x against uplink switch. When enabled, AP cert will be used to do EAP-TLS and the Org's CA Cert has to be provisioned at the switch",
						Default:             booldefault.StaticBool(false),
					},
					"keep_wlans_up_if_down": schema.BoolAttribute{
						Optional:            true,
						Description:         "By default, WLANs are disabled when uplink is down. In some scenario, like SiteSurvey, one would want the AP to keep sending beacons.",
						MarkdownDescription: "By default, WLANs are disabled when uplink is down. In some scenario, like SiteSurvey, one would want the AP to keep sending beacons.",
					},
				},
				CustomType: UplinkPortConfigType{
					ObjectType: types.ObjectType{
						AttrTypes: UplinkPortConfigValue{}.AttributeTypes(ctx),
					},
				},
				Optional:            true,
				Description:         "AP Uplink port configuration",
				MarkdownDescription: "AP Uplink port configuration",
			},
			"usb_config": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"cacert": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "Only if `type`==`imagotag`",
						MarkdownDescription: "Only if `type`==`imagotag`",
						Validators: []validator.String{
							mistvalidator.AllowedWhenValueIs(
								path.MatchRelative().AtParent().AtName("type"),
								types.StringValue("imagotag"),
							),
						},
						Default: stringdefault.StaticString(""),
					},
					"channel": schema.Int64Attribute{
						Optional:            true,
						Description:         "Only if `type`==`imagotag`, channel selection, not needed by default, required for manual channel override only",
						MarkdownDescription: "Only if `type`==`imagotag`, channel selection, not needed by default, required for manual channel override only",
						Validators: []validator.Int64{
							mistvalidator.AllowedWhenValueIs(
								path.MatchRelative().AtParent().AtName("type"),
								types.StringValue("imagotag"),
							),
						},
					},
					"enabled": schema.BoolAttribute{
						Optional:            true,
						Description:         "Whether to enable any usb config",
						MarkdownDescription: "Whether to enable any usb config",
					},
					"host": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "Only if `type`==`imagotag`",
						MarkdownDescription: "Only if `type`==`imagotag`",
						Validators: []validator.String{
							mistvalidator.AllowedWhenValueIs(
								path.MatchRelative().AtParent().AtName("type"),
								types.StringValue("imagotag"),
							),
						},
						Default: stringdefault.StaticString(""),
					},
					"port": schema.Int64Attribute{
						Optional:            true,
						Description:         "Only if `type`==`imagotag`",
						MarkdownDescription: "Only if `type`==`imagotag`",
						Validators: []validator.Int64{
							mistvalidator.AllowedWhenValueIs(
								path.MatchRelative().AtParent().AtName("type"),
								types.StringValue("imagotag"),
							),
							int64validator.Between(1, 65535),
						},
					},
					"type": schema.StringAttribute{
						Optional:            true,
						Description:         "usb config type. enum: `hanshow`, `imagotag`, `solum`",
						MarkdownDescription: "usb config type. enum: `hanshow`, `imagotag`, `solum`",
						Validators: []validator.String{
							stringvalidator.OneOf(
								"",
								"hanshow",
								"imagotag",
								"solum",
							),
						},
					},
					"verify_cert": schema.BoolAttribute{
						Optional:            true,
						Description:         "Only if `type`==`imagotag`, whether to turn on SSL verification",
						MarkdownDescription: "Only if `type`==`imagotag`, whether to turn on SSL verification",
						Validators: []validator.Bool{
							mistvalidator.AllowedWhenValueIs(
								path.MatchRelative().AtParent().AtName("type"),
								types.StringValue("imagotag"),
							),
						},
					},
					"vlan_id": schema.Int64Attribute{
						Optional:            true,
						Description:         "Only if `type`==`solum` or `type`==`hanshow`",
						MarkdownDescription: "Only if `type`==`solum` or `type`==`hanshow`",
						Validators: []validator.Int64{
							mistvalidator.AllowedWhenValueIsIn(
								path.MatchRelative().AtParent().AtName("type"),
								[]attr.Value{
									types.StringValue("solum"),
									types.StringValue("hanshow"),
								},
							),
							int64validator.Between(1, 4094),
						},
					},
				},
				CustomType: UsbConfigType{
					ObjectType: types.ObjectType{
						AttrTypes: UsbConfigValue{}.AttributeTypes(ctx),
					},
				},
				Optional:            true,
				Description:         "USB AP settings\n  - Note: if native imagotag is enabled, BLE will be disabled automatically\n  - Note: legacy, new config moved to ESL Config.",
				MarkdownDescription: "USB AP settings\n  - Note: if native imagotag is enabled, BLE will be disabled automatically\n  - Note: legacy, new config moved to ESL Config.",
			},
			"vars": schema.MapAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Description:         "Dictionary of name->value, the vars can then be used in Wlans. This can overwrite those from Site Vars",
				MarkdownDescription: "Dictionary of name->value, the vars can then be used in Wlans. This can overwrite those from Site Vars",
			},
			"x": schema.Float64Attribute{
				Optional:            true,
				Description:         "X in pixel",
				MarkdownDescription: "X in pixel",
			},
			"y": schema.Float64Attribute{
				Optional:            true,
				Description:         "Y in pixel",
				MarkdownDescription: "Y in pixel",
			},
		},
	}
}

type DeviceApModel struct {
	Aeroscout        AeroscoutValue        `tfsdk:"aeroscout"`
	BleConfig        BleConfigValue        `tfsdk:"ble_config"`
	Centrak          CentrakValue          `tfsdk:"centrak"`
	ClientBridge     ClientBridgeValue     `tfsdk:"client_bridge"`
	DeviceId         types.String          `tfsdk:"device_id"`
	DisableEth1      types.Bool            `tfsdk:"disable_eth1"`
	DisableEth2      types.Bool            `tfsdk:"disable_eth2"`
	DisableEth3      types.Bool            `tfsdk:"disable_eth3"`
	DisableModule    types.Bool            `tfsdk:"disable_module"`
	EslConfig        EslConfigValue        `tfsdk:"esl_config"`
	FlowControl      types.Bool            `tfsdk:"flow_control"`
	Height           types.Float64         `tfsdk:"height"`
	Image1Url        types.String          `tfsdk:"image1_url"`
	Image2Url        types.String          `tfsdk:"image2_url"`
	Image3Url        types.String          `tfsdk:"image3_url"`
	IpConfig         IpConfigValue         `tfsdk:"ip_config"`
	LacpConfig       LacpConfigValue       `tfsdk:"lacp_config"`
	Led              LedValue              `tfsdk:"led"`
	Locked           types.Bool            `tfsdk:"locked"`
	Mac              types.String          `tfsdk:"mac"`
	MapId            types.String          `tfsdk:"map_id"`
	Mesh             MeshValue             `tfsdk:"mesh"`
	Model            types.String          `tfsdk:"model"`
	Name             types.String          `tfsdk:"name"`
	Notes            types.String          `tfsdk:"notes"`
	NtpServers       types.List            `tfsdk:"ntp_servers"`
	OrgId            types.String          `tfsdk:"org_id"`
	Orientation      types.Int64           `tfsdk:"orientation"`
	PoePassthrough   types.Bool            `tfsdk:"poe_passthrough"`
	PortConfig       types.Map             `tfsdk:"port_config"`
	PwrConfig        PwrConfigValue        `tfsdk:"pwr_config"`
	RadioConfig      RadioConfigValue      `tfsdk:"radio_config"`
	Serial           types.String          `tfsdk:"serial"`
	SiteId           types.String          `tfsdk:"site_id"`
	Type             types.String          `tfsdk:"type"`
	UplinkPortConfig UplinkPortConfigValue `tfsdk:"uplink_port_config"`
	UsbConfig        UsbConfigValue        `tfsdk:"usb_config"`
	Vars             types.Map             `tfsdk:"vars"`
	X                types.Float64         `tfsdk:"x"`
	Y                types.Float64         `tfsdk:"y"`
}

var _ basetypes.ObjectTypable = AeroscoutType{}

type AeroscoutType struct {
	basetypes.ObjectType
}

func (t AeroscoutType) Equal(o attr.Type) bool {
	other, ok := o.(AeroscoutType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AeroscoutType) String() string {
	return "AeroscoutType"
}

func (t AeroscoutType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	hostAttribute, ok := attributes["host"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`host is missing from object`)

		return nil, diags
	}

	hostVal, ok := hostAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`host expected to be basetypes.StringValue, was: %T`, hostAttribute))
	}

	locateConnectedAttribute, ok := attributes["locate_connected"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`locate_connected is missing from object`)

		return nil, diags
	}

	locateConnectedVal, ok := locateConnectedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`locate_connected expected to be basetypes.BoolValue, was: %T`, locateConnectedAttribute))
	}

	portAttribute, ok := attributes["port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port is missing from object`)

		return nil, diags
	}

	portVal, ok := portAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port expected to be basetypes.Int64Value, was: %T`, portAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AeroscoutValue{
		Enabled:         enabledVal,
		Host:            hostVal,
		LocateConnected: locateConnectedVal,
		Port:            portVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewAeroscoutValueNull() AeroscoutValue {
	return AeroscoutValue{
		state: attr.ValueStateNull,
	}
}

func NewAeroscoutValueUnknown() AeroscoutValue {
	return AeroscoutValue{
		state: attr.ValueStateUnknown,
	}
}

func NewAeroscoutValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AeroscoutValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AeroscoutValue Attribute Value",
				"While creating a AeroscoutValue value, a missing attribute value was detected. "+
					"A AeroscoutValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AeroscoutValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AeroscoutValue Attribute Type",
				"While creating a AeroscoutValue value, an invalid attribute value was detected. "+
					"A AeroscoutValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AeroscoutValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AeroscoutValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AeroscoutValue Attribute Value",
				"While creating a AeroscoutValue value, an extra attribute value was detected. "+
					"A AeroscoutValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AeroscoutValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAeroscoutValueUnknown(), diags
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewAeroscoutValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	hostAttribute, ok := attributes["host"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`host is missing from object`)

		return NewAeroscoutValueUnknown(), diags
	}

	hostVal, ok := hostAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`host expected to be basetypes.StringValue, was: %T`, hostAttribute))
	}

	locateConnectedAttribute, ok := attributes["locate_connected"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`locate_connected is missing from object`)

		return NewAeroscoutValueUnknown(), diags
	}

	locateConnectedVal, ok := locateConnectedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`locate_connected expected to be basetypes.BoolValue, was: %T`, locateConnectedAttribute))
	}

	portAttribute, ok := attributes["port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port is missing from object`)

		return NewAeroscoutValueUnknown(), diags
	}

	portVal, ok := portAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port expected to be basetypes.Int64Value, was: %T`, portAttribute))
	}

	if diags.HasError() {
		return NewAeroscoutValueUnknown(), diags
	}

	return AeroscoutValue{
		Enabled:         enabledVal,
		Host:            hostVal,
		LocateConnected: locateConnectedVal,
		Port:            portVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewAeroscoutValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AeroscoutValue {
	object, diags := NewAeroscoutValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAeroscoutValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AeroscoutType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAeroscoutValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAeroscoutValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAeroscoutValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAeroscoutValueMust(AeroscoutValue{}.AttributeTypes(ctx), attributes), nil
}

func (t AeroscoutType) ValueType(ctx context.Context) attr.Value {
	return AeroscoutValue{}
}

var _ basetypes.ObjectValuable = AeroscoutValue{}

type AeroscoutValue struct {
	Enabled         basetypes.BoolValue   `tfsdk:"enabled"`
	Host            basetypes.StringValue `tfsdk:"host"`
	LocateConnected basetypes.BoolValue   `tfsdk:"locate_connected"`
	Port            basetypes.Int64Value  `tfsdk:"port"`
	state           attr.ValueState
}

func (v AeroscoutValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["host"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["locate_connected"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["port"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.Host.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["host"] = val

		val, err = v.LocateConnected.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["locate_connected"] = val

		val, err = v.Port.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AeroscoutValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AeroscoutValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AeroscoutValue) String() string {
	return "AeroscoutValue"
}

func (v AeroscoutValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"enabled":          basetypes.BoolType{},
		"host":             basetypes.StringType{},
		"locate_connected": basetypes.BoolType{},
		"port":             basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"enabled":          v.Enabled,
			"host":             v.Host,
			"locate_connected": v.LocateConnected,
			"port":             v.Port,
		})

	return objVal, diags
}

func (v AeroscoutValue) Equal(o attr.Value) bool {
	other, ok := o.(AeroscoutValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.Host.Equal(other.Host) {
		return false
	}

	if !v.LocateConnected.Equal(other.LocateConnected) {
		return false
	}

	if !v.Port.Equal(other.Port) {
		return false
	}

	return true
}

func (v AeroscoutValue) Type(ctx context.Context) attr.Type {
	return AeroscoutType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AeroscoutValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"enabled":          basetypes.BoolType{},
		"host":             basetypes.StringType{},
		"locate_connected": basetypes.BoolType{},
		"port":             basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = BleConfigType{}

type BleConfigType struct {
	basetypes.ObjectType
}

func (t BleConfigType) Equal(o attr.Type) bool {
	other, ok := o.(BleConfigType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t BleConfigType) String() string {
	return "BleConfigType"
}

func (t BleConfigType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	beaconEnabledAttribute, ok := attributes["beacon_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`beacon_enabled is missing from object`)

		return nil, diags
	}

	beaconEnabledVal, ok := beaconEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`beacon_enabled expected to be basetypes.BoolValue, was: %T`, beaconEnabledAttribute))
	}

	beaconRateAttribute, ok := attributes["beacon_rate"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`beacon_rate is missing from object`)

		return nil, diags
	}

	beaconRateVal, ok := beaconRateAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`beacon_rate expected to be basetypes.Int64Value, was: %T`, beaconRateAttribute))
	}

	beaconRateModeAttribute, ok := attributes["beacon_rate_mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`beacon_rate_mode is missing from object`)

		return nil, diags
	}

	beaconRateModeVal, ok := beaconRateModeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`beacon_rate_mode expected to be basetypes.StringValue, was: %T`, beaconRateModeAttribute))
	}

	beamDisabledAttribute, ok := attributes["beam_disabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`beam_disabled is missing from object`)

		return nil, diags
	}

	beamDisabledVal, ok := beamDisabledAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`beam_disabled expected to be basetypes.ListValue, was: %T`, beamDisabledAttribute))
	}

	customBlePacketEnabledAttribute, ok := attributes["custom_ble_packet_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`custom_ble_packet_enabled is missing from object`)

		return nil, diags
	}

	customBlePacketEnabledVal, ok := customBlePacketEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`custom_ble_packet_enabled expected to be basetypes.BoolValue, was: %T`, customBlePacketEnabledAttribute))
	}

	customBlePacketFrameAttribute, ok := attributes["custom_ble_packet_frame"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`custom_ble_packet_frame is missing from object`)

		return nil, diags
	}

	customBlePacketFrameVal, ok := customBlePacketFrameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`custom_ble_packet_frame expected to be basetypes.StringValue, was: %T`, customBlePacketFrameAttribute))
	}

	customBlePacketFreqMsecAttribute, ok := attributes["custom_ble_packet_freq_msec"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`custom_ble_packet_freq_msec is missing from object`)

		return nil, diags
	}

	customBlePacketFreqMsecVal, ok := customBlePacketFreqMsecAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`custom_ble_packet_freq_msec expected to be basetypes.Int64Value, was: %T`, customBlePacketFreqMsecAttribute))
	}

	eddystoneUidAdvPowerAttribute, ok := attributes["eddystone_uid_adv_power"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`eddystone_uid_adv_power is missing from object`)

		return nil, diags
	}

	eddystoneUidAdvPowerVal, ok := eddystoneUidAdvPowerAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`eddystone_uid_adv_power expected to be basetypes.Int64Value, was: %T`, eddystoneUidAdvPowerAttribute))
	}

	eddystoneUidBeamsAttribute, ok := attributes["eddystone_uid_beams"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`eddystone_uid_beams is missing from object`)

		return nil, diags
	}

	eddystoneUidBeamsVal, ok := eddystoneUidBeamsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`eddystone_uid_beams expected to be basetypes.StringValue, was: %T`, eddystoneUidBeamsAttribute))
	}

	eddystoneUidEnabledAttribute, ok := attributes["eddystone_uid_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`eddystone_uid_enabled is missing from object`)

		return nil, diags
	}

	eddystoneUidEnabledVal, ok := eddystoneUidEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`eddystone_uid_enabled expected to be basetypes.BoolValue, was: %T`, eddystoneUidEnabledAttribute))
	}

	eddystoneUidFreqMsecAttribute, ok := attributes["eddystone_uid_freq_msec"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`eddystone_uid_freq_msec is missing from object`)

		return nil, diags
	}

	eddystoneUidFreqMsecVal, ok := eddystoneUidFreqMsecAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`eddystone_uid_freq_msec expected to be basetypes.Int64Value, was: %T`, eddystoneUidFreqMsecAttribute))
	}

	eddystoneUidInstanceAttribute, ok := attributes["eddystone_uid_instance"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`eddystone_uid_instance is missing from object`)

		return nil, diags
	}

	eddystoneUidInstanceVal, ok := eddystoneUidInstanceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`eddystone_uid_instance expected to be basetypes.StringValue, was: %T`, eddystoneUidInstanceAttribute))
	}

	eddystoneUidNamespaceAttribute, ok := attributes["eddystone_uid_namespace"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`eddystone_uid_namespace is missing from object`)

		return nil, diags
	}

	eddystoneUidNamespaceVal, ok := eddystoneUidNamespaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`eddystone_uid_namespace expected to be basetypes.StringValue, was: %T`, eddystoneUidNamespaceAttribute))
	}

	eddystoneUrlAdvPowerAttribute, ok := attributes["eddystone_url_adv_power"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`eddystone_url_adv_power is missing from object`)

		return nil, diags
	}

	eddystoneUrlAdvPowerVal, ok := eddystoneUrlAdvPowerAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`eddystone_url_adv_power expected to be basetypes.Int64Value, was: %T`, eddystoneUrlAdvPowerAttribute))
	}

	eddystoneUrlBeamsAttribute, ok := attributes["eddystone_url_beams"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`eddystone_url_beams is missing from object`)

		return nil, diags
	}

	eddystoneUrlBeamsVal, ok := eddystoneUrlBeamsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`eddystone_url_beams expected to be basetypes.StringValue, was: %T`, eddystoneUrlBeamsAttribute))
	}

	eddystoneUrlEnabledAttribute, ok := attributes["eddystone_url_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`eddystone_url_enabled is missing from object`)

		return nil, diags
	}

	eddystoneUrlEnabledVal, ok := eddystoneUrlEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`eddystone_url_enabled expected to be basetypes.BoolValue, was: %T`, eddystoneUrlEnabledAttribute))
	}

	eddystoneUrlFreqMsecAttribute, ok := attributes["eddystone_url_freq_msec"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`eddystone_url_freq_msec is missing from object`)

		return nil, diags
	}

	eddystoneUrlFreqMsecVal, ok := eddystoneUrlFreqMsecAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`eddystone_url_freq_msec expected to be basetypes.Int64Value, was: %T`, eddystoneUrlFreqMsecAttribute))
	}

	eddystoneUrlUrlAttribute, ok := attributes["eddystone_url_url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`eddystone_url_url is missing from object`)

		return nil, diags
	}

	eddystoneUrlUrlVal, ok := eddystoneUrlUrlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`eddystone_url_url expected to be basetypes.StringValue, was: %T`, eddystoneUrlUrlAttribute))
	}

	ibeaconAdvPowerAttribute, ok := attributes["ibeacon_adv_power"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ibeacon_adv_power is missing from object`)

		return nil, diags
	}

	ibeaconAdvPowerVal, ok := ibeaconAdvPowerAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ibeacon_adv_power expected to be basetypes.Int64Value, was: %T`, ibeaconAdvPowerAttribute))
	}

	ibeaconBeamsAttribute, ok := attributes["ibeacon_beams"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ibeacon_beams is missing from object`)

		return nil, diags
	}

	ibeaconBeamsVal, ok := ibeaconBeamsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ibeacon_beams expected to be basetypes.StringValue, was: %T`, ibeaconBeamsAttribute))
	}

	ibeaconEnabledAttribute, ok := attributes["ibeacon_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ibeacon_enabled is missing from object`)

		return nil, diags
	}

	ibeaconEnabledVal, ok := ibeaconEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ibeacon_enabled expected to be basetypes.BoolValue, was: %T`, ibeaconEnabledAttribute))
	}

	ibeaconFreqMsecAttribute, ok := attributes["ibeacon_freq_msec"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ibeacon_freq_msec is missing from object`)

		return nil, diags
	}

	ibeaconFreqMsecVal, ok := ibeaconFreqMsecAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ibeacon_freq_msec expected to be basetypes.Int64Value, was: %T`, ibeaconFreqMsecAttribute))
	}

	ibeaconMajorAttribute, ok := attributes["ibeacon_major"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ibeacon_major is missing from object`)

		return nil, diags
	}

	ibeaconMajorVal, ok := ibeaconMajorAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ibeacon_major expected to be basetypes.Int64Value, was: %T`, ibeaconMajorAttribute))
	}

	ibeaconMinorAttribute, ok := attributes["ibeacon_minor"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ibeacon_minor is missing from object`)

		return nil, diags
	}

	ibeaconMinorVal, ok := ibeaconMinorAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ibeacon_minor expected to be basetypes.Int64Value, was: %T`, ibeaconMinorAttribute))
	}

	ibeaconUuidAttribute, ok := attributes["ibeacon_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ibeacon_uuid is missing from object`)

		return nil, diags
	}

	ibeaconUuidVal, ok := ibeaconUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ibeacon_uuid expected to be basetypes.StringValue, was: %T`, ibeaconUuidAttribute))
	}

	powerAttribute, ok := attributes["power"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`power is missing from object`)

		return nil, diags
	}

	powerVal, ok := powerAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`power expected to be basetypes.Int64Value, was: %T`, powerAttribute))
	}

	powerModeAttribute, ok := attributes["power_mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`power_mode is missing from object`)

		return nil, diags
	}

	powerModeVal, ok := powerModeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`power_mode expected to be basetypes.StringValue, was: %T`, powerModeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return BleConfigValue{
		BeaconEnabled:           beaconEnabledVal,
		BeaconRate:              beaconRateVal,
		BeaconRateMode:          beaconRateModeVal,
		BeamDisabled:            beamDisabledVal,
		CustomBlePacketEnabled:  customBlePacketEnabledVal,
		CustomBlePacketFrame:    customBlePacketFrameVal,
		CustomBlePacketFreqMsec: customBlePacketFreqMsecVal,
		EddystoneUidAdvPower:    eddystoneUidAdvPowerVal,
		EddystoneUidBeams:       eddystoneUidBeamsVal,
		EddystoneUidEnabled:     eddystoneUidEnabledVal,
		EddystoneUidFreqMsec:    eddystoneUidFreqMsecVal,
		EddystoneUidInstance:    eddystoneUidInstanceVal,
		EddystoneUidNamespace:   eddystoneUidNamespaceVal,
		EddystoneUrlAdvPower:    eddystoneUrlAdvPowerVal,
		EddystoneUrlBeams:       eddystoneUrlBeamsVal,
		EddystoneUrlEnabled:     eddystoneUrlEnabledVal,
		EddystoneUrlFreqMsec:    eddystoneUrlFreqMsecVal,
		EddystoneUrlUrl:         eddystoneUrlUrlVal,
		IbeaconAdvPower:         ibeaconAdvPowerVal,
		IbeaconBeams:            ibeaconBeamsVal,
		IbeaconEnabled:          ibeaconEnabledVal,
		IbeaconFreqMsec:         ibeaconFreqMsecVal,
		IbeaconMajor:            ibeaconMajorVal,
		IbeaconMinor:            ibeaconMinorVal,
		IbeaconUuid:             ibeaconUuidVal,
		Power:                   powerVal,
		PowerMode:               powerModeVal,
		state:                   attr.ValueStateKnown,
	}, diags
}

func NewBleConfigValueNull() BleConfigValue {
	return BleConfigValue{
		state: attr.ValueStateNull,
	}
}

func NewBleConfigValueUnknown() BleConfigValue {
	return BleConfigValue{
		state: attr.ValueStateUnknown,
	}
}

func NewBleConfigValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (BleConfigValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing BleConfigValue Attribute Value",
				"While creating a BleConfigValue value, a missing attribute value was detected. "+
					"A BleConfigValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("BleConfigValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid BleConfigValue Attribute Type",
				"While creating a BleConfigValue value, an invalid attribute value was detected. "+
					"A BleConfigValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("BleConfigValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("BleConfigValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra BleConfigValue Attribute Value",
				"While creating a BleConfigValue value, an extra attribute value was detected. "+
					"A BleConfigValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra BleConfigValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewBleConfigValueUnknown(), diags
	}

	beaconEnabledAttribute, ok := attributes["beacon_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`beacon_enabled is missing from object`)

		return NewBleConfigValueUnknown(), diags
	}

	beaconEnabledVal, ok := beaconEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`beacon_enabled expected to be basetypes.BoolValue, was: %T`, beaconEnabledAttribute))
	}

	beaconRateAttribute, ok := attributes["beacon_rate"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`beacon_rate is missing from object`)

		return NewBleConfigValueUnknown(), diags
	}

	beaconRateVal, ok := beaconRateAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`beacon_rate expected to be basetypes.Int64Value, was: %T`, beaconRateAttribute))
	}

	beaconRateModeAttribute, ok := attributes["beacon_rate_mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`beacon_rate_mode is missing from object`)

		return NewBleConfigValueUnknown(), diags
	}

	beaconRateModeVal, ok := beaconRateModeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`beacon_rate_mode expected to be basetypes.StringValue, was: %T`, beaconRateModeAttribute))
	}

	beamDisabledAttribute, ok := attributes["beam_disabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`beam_disabled is missing from object`)

		return NewBleConfigValueUnknown(), diags
	}

	beamDisabledVal, ok := beamDisabledAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`beam_disabled expected to be basetypes.ListValue, was: %T`, beamDisabledAttribute))
	}

	customBlePacketEnabledAttribute, ok := attributes["custom_ble_packet_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`custom_ble_packet_enabled is missing from object`)

		return NewBleConfigValueUnknown(), diags
	}

	customBlePacketEnabledVal, ok := customBlePacketEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`custom_ble_packet_enabled expected to be basetypes.BoolValue, was: %T`, customBlePacketEnabledAttribute))
	}

	customBlePacketFrameAttribute, ok := attributes["custom_ble_packet_frame"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`custom_ble_packet_frame is missing from object`)

		return NewBleConfigValueUnknown(), diags
	}

	customBlePacketFrameVal, ok := customBlePacketFrameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`custom_ble_packet_frame expected to be basetypes.StringValue, was: %T`, customBlePacketFrameAttribute))
	}

	customBlePacketFreqMsecAttribute, ok := attributes["custom_ble_packet_freq_msec"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`custom_ble_packet_freq_msec is missing from object`)

		return NewBleConfigValueUnknown(), diags
	}

	customBlePacketFreqMsecVal, ok := customBlePacketFreqMsecAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`custom_ble_packet_freq_msec expected to be basetypes.Int64Value, was: %T`, customBlePacketFreqMsecAttribute))
	}

	eddystoneUidAdvPowerAttribute, ok := attributes["eddystone_uid_adv_power"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`eddystone_uid_adv_power is missing from object`)

		return NewBleConfigValueUnknown(), diags
	}

	eddystoneUidAdvPowerVal, ok := eddystoneUidAdvPowerAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`eddystone_uid_adv_power expected to be basetypes.Int64Value, was: %T`, eddystoneUidAdvPowerAttribute))
	}

	eddystoneUidBeamsAttribute, ok := attributes["eddystone_uid_beams"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`eddystone_uid_beams is missing from object`)

		return NewBleConfigValueUnknown(), diags
	}

	eddystoneUidBeamsVal, ok := eddystoneUidBeamsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`eddystone_uid_beams expected to be basetypes.StringValue, was: %T`, eddystoneUidBeamsAttribute))
	}

	eddystoneUidEnabledAttribute, ok := attributes["eddystone_uid_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`eddystone_uid_enabled is missing from object`)

		return NewBleConfigValueUnknown(), diags
	}

	eddystoneUidEnabledVal, ok := eddystoneUidEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`eddystone_uid_enabled expected to be basetypes.BoolValue, was: %T`, eddystoneUidEnabledAttribute))
	}

	eddystoneUidFreqMsecAttribute, ok := attributes["eddystone_uid_freq_msec"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`eddystone_uid_freq_msec is missing from object`)

		return NewBleConfigValueUnknown(), diags
	}

	eddystoneUidFreqMsecVal, ok := eddystoneUidFreqMsecAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`eddystone_uid_freq_msec expected to be basetypes.Int64Value, was: %T`, eddystoneUidFreqMsecAttribute))
	}

	eddystoneUidInstanceAttribute, ok := attributes["eddystone_uid_instance"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`eddystone_uid_instance is missing from object`)

		return NewBleConfigValueUnknown(), diags
	}

	eddystoneUidInstanceVal, ok := eddystoneUidInstanceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`eddystone_uid_instance expected to be basetypes.StringValue, was: %T`, eddystoneUidInstanceAttribute))
	}

	eddystoneUidNamespaceAttribute, ok := attributes["eddystone_uid_namespace"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`eddystone_uid_namespace is missing from object`)

		return NewBleConfigValueUnknown(), diags
	}

	eddystoneUidNamespaceVal, ok := eddystoneUidNamespaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`eddystone_uid_namespace expected to be basetypes.StringValue, was: %T`, eddystoneUidNamespaceAttribute))
	}

	eddystoneUrlAdvPowerAttribute, ok := attributes["eddystone_url_adv_power"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`eddystone_url_adv_power is missing from object`)

		return NewBleConfigValueUnknown(), diags
	}

	eddystoneUrlAdvPowerVal, ok := eddystoneUrlAdvPowerAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`eddystone_url_adv_power expected to be basetypes.Int64Value, was: %T`, eddystoneUrlAdvPowerAttribute))
	}

	eddystoneUrlBeamsAttribute, ok := attributes["eddystone_url_beams"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`eddystone_url_beams is missing from object`)

		return NewBleConfigValueUnknown(), diags
	}

	eddystoneUrlBeamsVal, ok := eddystoneUrlBeamsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`eddystone_url_beams expected to be basetypes.StringValue, was: %T`, eddystoneUrlBeamsAttribute))
	}

	eddystoneUrlEnabledAttribute, ok := attributes["eddystone_url_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`eddystone_url_enabled is missing from object`)

		return NewBleConfigValueUnknown(), diags
	}

	eddystoneUrlEnabledVal, ok := eddystoneUrlEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`eddystone_url_enabled expected to be basetypes.BoolValue, was: %T`, eddystoneUrlEnabledAttribute))
	}

	eddystoneUrlFreqMsecAttribute, ok := attributes["eddystone_url_freq_msec"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`eddystone_url_freq_msec is missing from object`)

		return NewBleConfigValueUnknown(), diags
	}

	eddystoneUrlFreqMsecVal, ok := eddystoneUrlFreqMsecAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`eddystone_url_freq_msec expected to be basetypes.Int64Value, was: %T`, eddystoneUrlFreqMsecAttribute))
	}

	eddystoneUrlUrlAttribute, ok := attributes["eddystone_url_url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`eddystone_url_url is missing from object`)

		return NewBleConfigValueUnknown(), diags
	}

	eddystoneUrlUrlVal, ok := eddystoneUrlUrlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`eddystone_url_url expected to be basetypes.StringValue, was: %T`, eddystoneUrlUrlAttribute))
	}

	ibeaconAdvPowerAttribute, ok := attributes["ibeacon_adv_power"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ibeacon_adv_power is missing from object`)

		return NewBleConfigValueUnknown(), diags
	}

	ibeaconAdvPowerVal, ok := ibeaconAdvPowerAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ibeacon_adv_power expected to be basetypes.Int64Value, was: %T`, ibeaconAdvPowerAttribute))
	}

	ibeaconBeamsAttribute, ok := attributes["ibeacon_beams"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ibeacon_beams is missing from object`)

		return NewBleConfigValueUnknown(), diags
	}

	ibeaconBeamsVal, ok := ibeaconBeamsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ibeacon_beams expected to be basetypes.StringValue, was: %T`, ibeaconBeamsAttribute))
	}

	ibeaconEnabledAttribute, ok := attributes["ibeacon_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ibeacon_enabled is missing from object`)

		return NewBleConfigValueUnknown(), diags
	}

	ibeaconEnabledVal, ok := ibeaconEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ibeacon_enabled expected to be basetypes.BoolValue, was: %T`, ibeaconEnabledAttribute))
	}

	ibeaconFreqMsecAttribute, ok := attributes["ibeacon_freq_msec"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ibeacon_freq_msec is missing from object`)

		return NewBleConfigValueUnknown(), diags
	}

	ibeaconFreqMsecVal, ok := ibeaconFreqMsecAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ibeacon_freq_msec expected to be basetypes.Int64Value, was: %T`, ibeaconFreqMsecAttribute))
	}

	ibeaconMajorAttribute, ok := attributes["ibeacon_major"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ibeacon_major is missing from object`)

		return NewBleConfigValueUnknown(), diags
	}

	ibeaconMajorVal, ok := ibeaconMajorAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ibeacon_major expected to be basetypes.Int64Value, was: %T`, ibeaconMajorAttribute))
	}

	ibeaconMinorAttribute, ok := attributes["ibeacon_minor"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ibeacon_minor is missing from object`)

		return NewBleConfigValueUnknown(), diags
	}

	ibeaconMinorVal, ok := ibeaconMinorAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ibeacon_minor expected to be basetypes.Int64Value, was: %T`, ibeaconMinorAttribute))
	}

	ibeaconUuidAttribute, ok := attributes["ibeacon_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ibeacon_uuid is missing from object`)

		return NewBleConfigValueUnknown(), diags
	}

	ibeaconUuidVal, ok := ibeaconUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ibeacon_uuid expected to be basetypes.StringValue, was: %T`, ibeaconUuidAttribute))
	}

	powerAttribute, ok := attributes["power"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`power is missing from object`)

		return NewBleConfigValueUnknown(), diags
	}

	powerVal, ok := powerAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`power expected to be basetypes.Int64Value, was: %T`, powerAttribute))
	}

	powerModeAttribute, ok := attributes["power_mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`power_mode is missing from object`)

		return NewBleConfigValueUnknown(), diags
	}

	powerModeVal, ok := powerModeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`power_mode expected to be basetypes.StringValue, was: %T`, powerModeAttribute))
	}

	if diags.HasError() {
		return NewBleConfigValueUnknown(), diags
	}

	return BleConfigValue{
		BeaconEnabled:           beaconEnabledVal,
		BeaconRate:              beaconRateVal,
		BeaconRateMode:          beaconRateModeVal,
		BeamDisabled:            beamDisabledVal,
		CustomBlePacketEnabled:  customBlePacketEnabledVal,
		CustomBlePacketFrame:    customBlePacketFrameVal,
		CustomBlePacketFreqMsec: customBlePacketFreqMsecVal,
		EddystoneUidAdvPower:    eddystoneUidAdvPowerVal,
		EddystoneUidBeams:       eddystoneUidBeamsVal,
		EddystoneUidEnabled:     eddystoneUidEnabledVal,
		EddystoneUidFreqMsec:    eddystoneUidFreqMsecVal,
		EddystoneUidInstance:    eddystoneUidInstanceVal,
		EddystoneUidNamespace:   eddystoneUidNamespaceVal,
		EddystoneUrlAdvPower:    eddystoneUrlAdvPowerVal,
		EddystoneUrlBeams:       eddystoneUrlBeamsVal,
		EddystoneUrlEnabled:     eddystoneUrlEnabledVal,
		EddystoneUrlFreqMsec:    eddystoneUrlFreqMsecVal,
		EddystoneUrlUrl:         eddystoneUrlUrlVal,
		IbeaconAdvPower:         ibeaconAdvPowerVal,
		IbeaconBeams:            ibeaconBeamsVal,
		IbeaconEnabled:          ibeaconEnabledVal,
		IbeaconFreqMsec:         ibeaconFreqMsecVal,
		IbeaconMajor:            ibeaconMajorVal,
		IbeaconMinor:            ibeaconMinorVal,
		IbeaconUuid:             ibeaconUuidVal,
		Power:                   powerVal,
		PowerMode:               powerModeVal,
		state:                   attr.ValueStateKnown,
	}, diags
}

func NewBleConfigValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) BleConfigValue {
	object, diags := NewBleConfigValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewBleConfigValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t BleConfigType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewBleConfigValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewBleConfigValueUnknown(), nil
	}

	if in.IsNull() {
		return NewBleConfigValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewBleConfigValueMust(BleConfigValue{}.AttributeTypes(ctx), attributes), nil
}

func (t BleConfigType) ValueType(ctx context.Context) attr.Value {
	return BleConfigValue{}
}

var _ basetypes.ObjectValuable = BleConfigValue{}

type BleConfigValue struct {
	BeaconEnabled           basetypes.BoolValue   `tfsdk:"beacon_enabled"`
	BeaconRate              basetypes.Int64Value  `tfsdk:"beacon_rate"`
	BeaconRateMode          basetypes.StringValue `tfsdk:"beacon_rate_mode"`
	BeamDisabled            basetypes.ListValue   `tfsdk:"beam_disabled"`
	CustomBlePacketEnabled  basetypes.BoolValue   `tfsdk:"custom_ble_packet_enabled"`
	CustomBlePacketFrame    basetypes.StringValue `tfsdk:"custom_ble_packet_frame"`
	CustomBlePacketFreqMsec basetypes.Int64Value  `tfsdk:"custom_ble_packet_freq_msec"`
	EddystoneUidAdvPower    basetypes.Int64Value  `tfsdk:"eddystone_uid_adv_power"`
	EddystoneUidBeams       basetypes.StringValue `tfsdk:"eddystone_uid_beams"`
	EddystoneUidEnabled     basetypes.BoolValue   `tfsdk:"eddystone_uid_enabled"`
	EddystoneUidFreqMsec    basetypes.Int64Value  `tfsdk:"eddystone_uid_freq_msec"`
	EddystoneUidInstance    basetypes.StringValue `tfsdk:"eddystone_uid_instance"`
	EddystoneUidNamespace   basetypes.StringValue `tfsdk:"eddystone_uid_namespace"`
	EddystoneUrlAdvPower    basetypes.Int64Value  `tfsdk:"eddystone_url_adv_power"`
	EddystoneUrlBeams       basetypes.StringValue `tfsdk:"eddystone_url_beams"`
	EddystoneUrlEnabled     basetypes.BoolValue   `tfsdk:"eddystone_url_enabled"`
	EddystoneUrlFreqMsec    basetypes.Int64Value  `tfsdk:"eddystone_url_freq_msec"`
	EddystoneUrlUrl         basetypes.StringValue `tfsdk:"eddystone_url_url"`
	IbeaconAdvPower         basetypes.Int64Value  `tfsdk:"ibeacon_adv_power"`
	IbeaconBeams            basetypes.StringValue `tfsdk:"ibeacon_beams"`
	IbeaconEnabled          basetypes.BoolValue   `tfsdk:"ibeacon_enabled"`
	IbeaconFreqMsec         basetypes.Int64Value  `tfsdk:"ibeacon_freq_msec"`
	IbeaconMajor            basetypes.Int64Value  `tfsdk:"ibeacon_major"`
	IbeaconMinor            basetypes.Int64Value  `tfsdk:"ibeacon_minor"`
	IbeaconUuid             basetypes.StringValue `tfsdk:"ibeacon_uuid"`
	Power                   basetypes.Int64Value  `tfsdk:"power"`
	PowerMode               basetypes.StringValue `tfsdk:"power_mode"`
	state                   attr.ValueState
}

func (v BleConfigValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 27)

	var val tftypes.Value
	var err error

	attrTypes["beacon_enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["beacon_rate"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["beacon_rate_mode"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["beam_disabled"] = basetypes.ListType{
		ElemType: types.Int64Type,
	}.TerraformType(ctx)
	attrTypes["custom_ble_packet_enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["custom_ble_packet_frame"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["custom_ble_packet_freq_msec"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["eddystone_uid_adv_power"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["eddystone_uid_beams"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["eddystone_uid_enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["eddystone_uid_freq_msec"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["eddystone_uid_instance"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["eddystone_uid_namespace"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["eddystone_url_adv_power"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["eddystone_url_beams"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["eddystone_url_enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["eddystone_url_freq_msec"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["eddystone_url_url"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ibeacon_adv_power"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["ibeacon_beams"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ibeacon_enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["ibeacon_freq_msec"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["ibeacon_major"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["ibeacon_minor"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["ibeacon_uuid"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["power"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["power_mode"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 27)

		val, err = v.BeaconEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["beacon_enabled"] = val

		val, err = v.BeaconRate.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["beacon_rate"] = val

		val, err = v.BeaconRateMode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["beacon_rate_mode"] = val

		val, err = v.BeamDisabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["beam_disabled"] = val

		val, err = v.CustomBlePacketEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["custom_ble_packet_enabled"] = val

		val, err = v.CustomBlePacketFrame.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["custom_ble_packet_frame"] = val

		val, err = v.CustomBlePacketFreqMsec.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["custom_ble_packet_freq_msec"] = val

		val, err = v.EddystoneUidAdvPower.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["eddystone_uid_adv_power"] = val

		val, err = v.EddystoneUidBeams.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["eddystone_uid_beams"] = val

		val, err = v.EddystoneUidEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["eddystone_uid_enabled"] = val

		val, err = v.EddystoneUidFreqMsec.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["eddystone_uid_freq_msec"] = val

		val, err = v.EddystoneUidInstance.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["eddystone_uid_instance"] = val

		val, err = v.EddystoneUidNamespace.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["eddystone_uid_namespace"] = val

		val, err = v.EddystoneUrlAdvPower.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["eddystone_url_adv_power"] = val

		val, err = v.EddystoneUrlBeams.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["eddystone_url_beams"] = val

		val, err = v.EddystoneUrlEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["eddystone_url_enabled"] = val

		val, err = v.EddystoneUrlFreqMsec.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["eddystone_url_freq_msec"] = val

		val, err = v.EddystoneUrlUrl.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["eddystone_url_url"] = val

		val, err = v.IbeaconAdvPower.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ibeacon_adv_power"] = val

		val, err = v.IbeaconBeams.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ibeacon_beams"] = val

		val, err = v.IbeaconEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ibeacon_enabled"] = val

		val, err = v.IbeaconFreqMsec.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ibeacon_freq_msec"] = val

		val, err = v.IbeaconMajor.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ibeacon_major"] = val

		val, err = v.IbeaconMinor.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ibeacon_minor"] = val

		val, err = v.IbeaconUuid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ibeacon_uuid"] = val

		val, err = v.Power.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["power"] = val

		val, err = v.PowerMode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["power_mode"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v BleConfigValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v BleConfigValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v BleConfigValue) String() string {
	return "BleConfigValue"
}

func (v BleConfigValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var beamDisabledVal basetypes.ListValue
	switch {
	case v.BeamDisabled.IsUnknown():
		beamDisabledVal = types.ListUnknown(types.Int64Type)
	case v.BeamDisabled.IsNull():
		beamDisabledVal = types.ListNull(types.Int64Type)
	default:
		var d diag.Diagnostics
		beamDisabledVal, d = types.ListValue(types.Int64Type, v.BeamDisabled.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"beacon_enabled":   basetypes.BoolType{},
			"beacon_rate":      basetypes.Int64Type{},
			"beacon_rate_mode": basetypes.StringType{},
			"beam_disabled": basetypes.ListType{
				ElemType: types.Int64Type,
			},
			"custom_ble_packet_enabled":   basetypes.BoolType{},
			"custom_ble_packet_frame":     basetypes.StringType{},
			"custom_ble_packet_freq_msec": basetypes.Int64Type{},
			"eddystone_uid_adv_power":     basetypes.Int64Type{},
			"eddystone_uid_beams":         basetypes.StringType{},
			"eddystone_uid_enabled":       basetypes.BoolType{},
			"eddystone_uid_freq_msec":     basetypes.Int64Type{},
			"eddystone_uid_instance":      basetypes.StringType{},
			"eddystone_uid_namespace":     basetypes.StringType{},
			"eddystone_url_adv_power":     basetypes.Int64Type{},
			"eddystone_url_beams":         basetypes.StringType{},
			"eddystone_url_enabled":       basetypes.BoolType{},
			"eddystone_url_freq_msec":     basetypes.Int64Type{},
			"eddystone_url_url":           basetypes.StringType{},
			"ibeacon_adv_power":           basetypes.Int64Type{},
			"ibeacon_beams":               basetypes.StringType{},
			"ibeacon_enabled":             basetypes.BoolType{},
			"ibeacon_freq_msec":           basetypes.Int64Type{},
			"ibeacon_major":               basetypes.Int64Type{},
			"ibeacon_minor":               basetypes.Int64Type{},
			"ibeacon_uuid":                basetypes.StringType{},
			"power":                       basetypes.Int64Type{},
			"power_mode":                  basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"beacon_enabled":   basetypes.BoolType{},
		"beacon_rate":      basetypes.Int64Type{},
		"beacon_rate_mode": basetypes.StringType{},
		"beam_disabled": basetypes.ListType{
			ElemType: types.Int64Type,
		},
		"custom_ble_packet_enabled":   basetypes.BoolType{},
		"custom_ble_packet_frame":     basetypes.StringType{},
		"custom_ble_packet_freq_msec": basetypes.Int64Type{},
		"eddystone_uid_adv_power":     basetypes.Int64Type{},
		"eddystone_uid_beams":         basetypes.StringType{},
		"eddystone_uid_enabled":       basetypes.BoolType{},
		"eddystone_uid_freq_msec":     basetypes.Int64Type{},
		"eddystone_uid_instance":      basetypes.StringType{},
		"eddystone_uid_namespace":     basetypes.StringType{},
		"eddystone_url_adv_power":     basetypes.Int64Type{},
		"eddystone_url_beams":         basetypes.StringType{},
		"eddystone_url_enabled":       basetypes.BoolType{},
		"eddystone_url_freq_msec":     basetypes.Int64Type{},
		"eddystone_url_url":           basetypes.StringType{},
		"ibeacon_adv_power":           basetypes.Int64Type{},
		"ibeacon_beams":               basetypes.StringType{},
		"ibeacon_enabled":             basetypes.BoolType{},
		"ibeacon_freq_msec":           basetypes.Int64Type{},
		"ibeacon_major":               basetypes.Int64Type{},
		"ibeacon_minor":               basetypes.Int64Type{},
		"ibeacon_uuid":                basetypes.StringType{},
		"power":                       basetypes.Int64Type{},
		"power_mode":                  basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"beacon_enabled":              v.BeaconEnabled,
			"beacon_rate":                 v.BeaconRate,
			"beacon_rate_mode":            v.BeaconRateMode,
			"beam_disabled":               beamDisabledVal,
			"custom_ble_packet_enabled":   v.CustomBlePacketEnabled,
			"custom_ble_packet_frame":     v.CustomBlePacketFrame,
			"custom_ble_packet_freq_msec": v.CustomBlePacketFreqMsec,
			"eddystone_uid_adv_power":     v.EddystoneUidAdvPower,
			"eddystone_uid_beams":         v.EddystoneUidBeams,
			"eddystone_uid_enabled":       v.EddystoneUidEnabled,
			"eddystone_uid_freq_msec":     v.EddystoneUidFreqMsec,
			"eddystone_uid_instance":      v.EddystoneUidInstance,
			"eddystone_uid_namespace":     v.EddystoneUidNamespace,
			"eddystone_url_adv_power":     v.EddystoneUrlAdvPower,
			"eddystone_url_beams":         v.EddystoneUrlBeams,
			"eddystone_url_enabled":       v.EddystoneUrlEnabled,
			"eddystone_url_freq_msec":     v.EddystoneUrlFreqMsec,
			"eddystone_url_url":           v.EddystoneUrlUrl,
			"ibeacon_adv_power":           v.IbeaconAdvPower,
			"ibeacon_beams":               v.IbeaconBeams,
			"ibeacon_enabled":             v.IbeaconEnabled,
			"ibeacon_freq_msec":           v.IbeaconFreqMsec,
			"ibeacon_major":               v.IbeaconMajor,
			"ibeacon_minor":               v.IbeaconMinor,
			"ibeacon_uuid":                v.IbeaconUuid,
			"power":                       v.Power,
			"power_mode":                  v.PowerMode,
		})

	return objVal, diags
}

func (v BleConfigValue) Equal(o attr.Value) bool {
	other, ok := o.(BleConfigValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.BeaconEnabled.Equal(other.BeaconEnabled) {
		return false
	}

	if !v.BeaconRate.Equal(other.BeaconRate) {
		return false
	}

	if !v.BeaconRateMode.Equal(other.BeaconRateMode) {
		return false
	}

	if !v.BeamDisabled.Equal(other.BeamDisabled) {
		return false
	}

	if !v.CustomBlePacketEnabled.Equal(other.CustomBlePacketEnabled) {
		return false
	}

	if !v.CustomBlePacketFrame.Equal(other.CustomBlePacketFrame) {
		return false
	}

	if !v.CustomBlePacketFreqMsec.Equal(other.CustomBlePacketFreqMsec) {
		return false
	}

	if !v.EddystoneUidAdvPower.Equal(other.EddystoneUidAdvPower) {
		return false
	}

	if !v.EddystoneUidBeams.Equal(other.EddystoneUidBeams) {
		return false
	}

	if !v.EddystoneUidEnabled.Equal(other.EddystoneUidEnabled) {
		return false
	}

	if !v.EddystoneUidFreqMsec.Equal(other.EddystoneUidFreqMsec) {
		return false
	}

	if !v.EddystoneUidInstance.Equal(other.EddystoneUidInstance) {
		return false
	}

	if !v.EddystoneUidNamespace.Equal(other.EddystoneUidNamespace) {
		return false
	}

	if !v.EddystoneUrlAdvPower.Equal(other.EddystoneUrlAdvPower) {
		return false
	}

	if !v.EddystoneUrlBeams.Equal(other.EddystoneUrlBeams) {
		return false
	}

	if !v.EddystoneUrlEnabled.Equal(other.EddystoneUrlEnabled) {
		return false
	}

	if !v.EddystoneUrlFreqMsec.Equal(other.EddystoneUrlFreqMsec) {
		return false
	}

	if !v.EddystoneUrlUrl.Equal(other.EddystoneUrlUrl) {
		return false
	}

	if !v.IbeaconAdvPower.Equal(other.IbeaconAdvPower) {
		return false
	}

	if !v.IbeaconBeams.Equal(other.IbeaconBeams) {
		return false
	}

	if !v.IbeaconEnabled.Equal(other.IbeaconEnabled) {
		return false
	}

	if !v.IbeaconFreqMsec.Equal(other.IbeaconFreqMsec) {
		return false
	}

	if !v.IbeaconMajor.Equal(other.IbeaconMajor) {
		return false
	}

	if !v.IbeaconMinor.Equal(other.IbeaconMinor) {
		return false
	}

	if !v.IbeaconUuid.Equal(other.IbeaconUuid) {
		return false
	}

	if !v.Power.Equal(other.Power) {
		return false
	}

	if !v.PowerMode.Equal(other.PowerMode) {
		return false
	}

	return true
}

func (v BleConfigValue) Type(ctx context.Context) attr.Type {
	return BleConfigType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v BleConfigValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"beacon_enabled":   basetypes.BoolType{},
		"beacon_rate":      basetypes.Int64Type{},
		"beacon_rate_mode": basetypes.StringType{},
		"beam_disabled": basetypes.ListType{
			ElemType: types.Int64Type,
		},
		"custom_ble_packet_enabled":   basetypes.BoolType{},
		"custom_ble_packet_frame":     basetypes.StringType{},
		"custom_ble_packet_freq_msec": basetypes.Int64Type{},
		"eddystone_uid_adv_power":     basetypes.Int64Type{},
		"eddystone_uid_beams":         basetypes.StringType{},
		"eddystone_uid_enabled":       basetypes.BoolType{},
		"eddystone_uid_freq_msec":     basetypes.Int64Type{},
		"eddystone_uid_instance":      basetypes.StringType{},
		"eddystone_uid_namespace":     basetypes.StringType{},
		"eddystone_url_adv_power":     basetypes.Int64Type{},
		"eddystone_url_beams":         basetypes.StringType{},
		"eddystone_url_enabled":       basetypes.BoolType{},
		"eddystone_url_freq_msec":     basetypes.Int64Type{},
		"eddystone_url_url":           basetypes.StringType{},
		"ibeacon_adv_power":           basetypes.Int64Type{},
		"ibeacon_beams":               basetypes.StringType{},
		"ibeacon_enabled":             basetypes.BoolType{},
		"ibeacon_freq_msec":           basetypes.Int64Type{},
		"ibeacon_major":               basetypes.Int64Type{},
		"ibeacon_minor":               basetypes.Int64Type{},
		"ibeacon_uuid":                basetypes.StringType{},
		"power":                       basetypes.Int64Type{},
		"power_mode":                  basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = CentrakType{}

type CentrakType struct {
	basetypes.ObjectType
}

func (t CentrakType) Equal(o attr.Type) bool {
	other, ok := o.(CentrakType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t CentrakType) String() string {
	return "CentrakType"
}

func (t CentrakType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return CentrakValue{
		Enabled: enabledVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewCentrakValueNull() CentrakValue {
	return CentrakValue{
		state: attr.ValueStateNull,
	}
}

func NewCentrakValueUnknown() CentrakValue {
	return CentrakValue{
		state: attr.ValueStateUnknown,
	}
}

func NewCentrakValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (CentrakValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing CentrakValue Attribute Value",
				"While creating a CentrakValue value, a missing attribute value was detected. "+
					"A CentrakValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CentrakValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid CentrakValue Attribute Type",
				"While creating a CentrakValue value, an invalid attribute value was detected. "+
					"A CentrakValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CentrakValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("CentrakValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra CentrakValue Attribute Value",
				"While creating a CentrakValue value, an extra attribute value was detected. "+
					"A CentrakValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra CentrakValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewCentrakValueUnknown(), diags
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewCentrakValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	if diags.HasError() {
		return NewCentrakValueUnknown(), diags
	}

	return CentrakValue{
		Enabled: enabledVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewCentrakValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) CentrakValue {
	object, diags := NewCentrakValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewCentrakValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t CentrakType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewCentrakValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewCentrakValueUnknown(), nil
	}

	if in.IsNull() {
		return NewCentrakValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewCentrakValueMust(CentrakValue{}.AttributeTypes(ctx), attributes), nil
}

func (t CentrakType) ValueType(ctx context.Context) attr.Value {
	return CentrakValue{}
}

var _ basetypes.ObjectValuable = CentrakValue{}

type CentrakValue struct {
	Enabled basetypes.BoolValue `tfsdk:"enabled"`
	state   attr.ValueState
}

func (v CentrakValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v CentrakValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v CentrakValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v CentrakValue) String() string {
	return "CentrakValue"
}

func (v CentrakValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"enabled": basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"enabled": v.Enabled,
		})

	return objVal, diags
}

func (v CentrakValue) Equal(o attr.Value) bool {
	other, ok := o.(CentrakValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	return true
}

func (v CentrakValue) Type(ctx context.Context) attr.Type {
	return CentrakType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v CentrakValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"enabled": basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = ClientBridgeType{}

type ClientBridgeType struct {
	basetypes.ObjectType
}

func (t ClientBridgeType) Equal(o attr.Type) bool {
	other, ok := o.(ClientBridgeType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ClientBridgeType) String() string {
	return "ClientBridgeType"
}

func (t ClientBridgeType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	authAttribute, ok := attributes["auth"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auth is missing from object`)

		return nil, diags
	}

	authVal, ok := authAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auth expected to be basetypes.ObjectValue, was: %T`, authAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	ssidAttribute, ok := attributes["ssid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ssid is missing from object`)

		return nil, diags
	}

	ssidVal, ok := ssidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ssid expected to be basetypes.StringValue, was: %T`, ssidAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ClientBridgeValue{
		Auth:    authVal,
		Enabled: enabledVal,
		Ssid:    ssidVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewClientBridgeValueNull() ClientBridgeValue {
	return ClientBridgeValue{
		state: attr.ValueStateNull,
	}
}

func NewClientBridgeValueUnknown() ClientBridgeValue {
	return ClientBridgeValue{
		state: attr.ValueStateUnknown,
	}
}

func NewClientBridgeValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ClientBridgeValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ClientBridgeValue Attribute Value",
				"While creating a ClientBridgeValue value, a missing attribute value was detected. "+
					"A ClientBridgeValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ClientBridgeValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ClientBridgeValue Attribute Type",
				"While creating a ClientBridgeValue value, an invalid attribute value was detected. "+
					"A ClientBridgeValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ClientBridgeValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ClientBridgeValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ClientBridgeValue Attribute Value",
				"While creating a ClientBridgeValue value, an extra attribute value was detected. "+
					"A ClientBridgeValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ClientBridgeValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewClientBridgeValueUnknown(), diags
	}

	authAttribute, ok := attributes["auth"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auth is missing from object`)

		return NewClientBridgeValueUnknown(), diags
	}

	authVal, ok := authAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auth expected to be basetypes.ObjectValue, was: %T`, authAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewClientBridgeValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	ssidAttribute, ok := attributes["ssid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ssid is missing from object`)

		return NewClientBridgeValueUnknown(), diags
	}

	ssidVal, ok := ssidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ssid expected to be basetypes.StringValue, was: %T`, ssidAttribute))
	}

	if diags.HasError() {
		return NewClientBridgeValueUnknown(), diags
	}

	return ClientBridgeValue{
		Auth:    authVal,
		Enabled: enabledVal,
		Ssid:    ssidVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewClientBridgeValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ClientBridgeValue {
	object, diags := NewClientBridgeValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewClientBridgeValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ClientBridgeType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewClientBridgeValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewClientBridgeValueUnknown(), nil
	}

	if in.IsNull() {
		return NewClientBridgeValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewClientBridgeValueMust(ClientBridgeValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ClientBridgeType) ValueType(ctx context.Context) attr.Value {
	return ClientBridgeValue{}
}

var _ basetypes.ObjectValuable = ClientBridgeValue{}

type ClientBridgeValue struct {
	Auth    basetypes.ObjectValue `tfsdk:"auth"`
	Enabled basetypes.BoolValue   `tfsdk:"enabled"`
	Ssid    basetypes.StringValue `tfsdk:"ssid"`
	state   attr.ValueState
}

func (v ClientBridgeValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["auth"] = basetypes.ObjectType{
		AttrTypes: AuthValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["ssid"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Auth.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["auth"] = val

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.Ssid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ssid"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ClientBridgeValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ClientBridgeValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ClientBridgeValue) String() string {
	return "ClientBridgeValue"
}

func (v ClientBridgeValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var auth basetypes.ObjectValue

	if v.Auth.IsNull() {
		auth = types.ObjectNull(
			AuthValue{}.AttributeTypes(ctx),
		)
	}

	if v.Auth.IsUnknown() {
		auth = types.ObjectUnknown(
			AuthValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Auth.IsNull() && !v.Auth.IsUnknown() {
		auth = types.ObjectValueMust(
			AuthValue{}.AttributeTypes(ctx),
			v.Auth.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"auth": basetypes.ObjectType{
			AttrTypes: AuthValue{}.AttributeTypes(ctx),
		},
		"enabled": basetypes.BoolType{},
		"ssid":    basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"auth":    auth,
			"enabled": v.Enabled,
			"ssid":    v.Ssid,
		})

	return objVal, diags
}

func (v ClientBridgeValue) Equal(o attr.Value) bool {
	other, ok := o.(ClientBridgeValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Auth.Equal(other.Auth) {
		return false
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.Ssid.Equal(other.Ssid) {
		return false
	}

	return true
}

func (v ClientBridgeValue) Type(ctx context.Context) attr.Type {
	return ClientBridgeType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ClientBridgeValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"auth": basetypes.ObjectType{
			AttrTypes: AuthValue{}.AttributeTypes(ctx),
		},
		"enabled": basetypes.BoolType{},
		"ssid":    basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = AuthType{}

type AuthType struct {
	basetypes.ObjectType
}

func (t AuthType) Equal(o attr.Type) bool {
	other, ok := o.(AuthType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AuthType) String() string {
	return "AuthType"
}

func (t AuthType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	pskAttribute, ok := attributes["psk"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`psk is missing from object`)

		return nil, diags
	}

	pskVal, ok := pskAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`psk expected to be basetypes.StringValue, was: %T`, pskAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AuthValue{
		Psk:      pskVal,
		AuthType: typeVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewAuthValueNull() AuthValue {
	return AuthValue{
		state: attr.ValueStateNull,
	}
}

func NewAuthValueUnknown() AuthValue {
	return AuthValue{
		state: attr.ValueStateUnknown,
	}
}

func NewAuthValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AuthValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AuthValue Attribute Value",
				"While creating a AuthValue value, a missing attribute value was detected. "+
					"A AuthValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AuthValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AuthValue Attribute Type",
				"While creating a AuthValue value, an invalid attribute value was detected. "+
					"A AuthValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AuthValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AuthValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AuthValue Attribute Value",
				"While creating a AuthValue value, an extra attribute value was detected. "+
					"A AuthValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AuthValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAuthValueUnknown(), diags
	}

	pskAttribute, ok := attributes["psk"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`psk is missing from object`)

		return NewAuthValueUnknown(), diags
	}

	pskVal, ok := pskAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`psk expected to be basetypes.StringValue, was: %T`, pskAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewAuthValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return NewAuthValueUnknown(), diags
	}

	return AuthValue{
		Psk:      pskVal,
		AuthType: typeVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewAuthValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AuthValue {
	object, diags := NewAuthValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAuthValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AuthType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAuthValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAuthValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAuthValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAuthValueMust(AuthValue{}.AttributeTypes(ctx), attributes), nil
}

func (t AuthType) ValueType(ctx context.Context) attr.Value {
	return AuthValue{}
}

var _ basetypes.ObjectValuable = AuthValue{}

type AuthValue struct {
	Psk      basetypes.StringValue `tfsdk:"psk"`
	AuthType basetypes.StringValue `tfsdk:"type"`
	state    attr.ValueState
}

func (v AuthValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["psk"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Psk.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["psk"] = val

		val, err = v.AuthType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AuthValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AuthValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AuthValue) String() string {
	return "AuthValue"
}

func (v AuthValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"psk":  basetypes.StringType{},
		"type": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"psk":  v.Psk,
			"type": v.AuthType,
		})

	return objVal, diags
}

func (v AuthValue) Equal(o attr.Value) bool {
	other, ok := o.(AuthValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Psk.Equal(other.Psk) {
		return false
	}

	if !v.AuthType.Equal(other.AuthType) {
		return false
	}

	return true
}

func (v AuthValue) Type(ctx context.Context) attr.Type {
	return AuthType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AuthValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"psk":  basetypes.StringType{},
		"type": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = EslConfigType{}

type EslConfigType struct {
	basetypes.ObjectType
}

func (t EslConfigType) Equal(o attr.Type) bool {
	other, ok := o.(EslConfigType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t EslConfigType) String() string {
	return "EslConfigType"
}

func (t EslConfigType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	cacertAttribute, ok := attributes["cacert"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cacert is missing from object`)

		return nil, diags
	}

	cacertVal, ok := cacertAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cacert expected to be basetypes.StringValue, was: %T`, cacertAttribute))
	}

	channelAttribute, ok := attributes["channel"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`channel is missing from object`)

		return nil, diags
	}

	channelVal, ok := channelAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`channel expected to be basetypes.Int64Value, was: %T`, channelAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	hostAttribute, ok := attributes["host"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`host is missing from object`)

		return nil, diags
	}

	hostVal, ok := hostAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`host expected to be basetypes.StringValue, was: %T`, hostAttribute))
	}

	portAttribute, ok := attributes["port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port is missing from object`)

		return nil, diags
	}

	portVal, ok := portAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port expected to be basetypes.Int64Value, was: %T`, portAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	verifyCertAttribute, ok := attributes["verify_cert"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`verify_cert is missing from object`)

		return nil, diags
	}

	verifyCertVal, ok := verifyCertAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`verify_cert expected to be basetypes.BoolValue, was: %T`, verifyCertAttribute))
	}

	vlanIdAttribute, ok := attributes["vlan_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan_id is missing from object`)

		return nil, diags
	}

	vlanIdVal, ok := vlanIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan_id expected to be basetypes.Int64Value, was: %T`, vlanIdAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return EslConfigValue{
		Cacert:        cacertVal,
		Channel:       channelVal,
		Enabled:       enabledVal,
		Host:          hostVal,
		Port:          portVal,
		EslConfigType: typeVal,
		VerifyCert:    verifyCertVal,
		VlanId:        vlanIdVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewEslConfigValueNull() EslConfigValue {
	return EslConfigValue{
		state: attr.ValueStateNull,
	}
}

func NewEslConfigValueUnknown() EslConfigValue {
	return EslConfigValue{
		state: attr.ValueStateUnknown,
	}
}

func NewEslConfigValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (EslConfigValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing EslConfigValue Attribute Value",
				"While creating a EslConfigValue value, a missing attribute value was detected. "+
					"A EslConfigValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("EslConfigValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid EslConfigValue Attribute Type",
				"While creating a EslConfigValue value, an invalid attribute value was detected. "+
					"A EslConfigValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("EslConfigValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("EslConfigValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra EslConfigValue Attribute Value",
				"While creating a EslConfigValue value, an extra attribute value was detected. "+
					"A EslConfigValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra EslConfigValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewEslConfigValueUnknown(), diags
	}

	cacertAttribute, ok := attributes["cacert"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cacert is missing from object`)

		return NewEslConfigValueUnknown(), diags
	}

	cacertVal, ok := cacertAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cacert expected to be basetypes.StringValue, was: %T`, cacertAttribute))
	}

	channelAttribute, ok := attributes["channel"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`channel is missing from object`)

		return NewEslConfigValueUnknown(), diags
	}

	channelVal, ok := channelAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`channel expected to be basetypes.Int64Value, was: %T`, channelAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewEslConfigValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	hostAttribute, ok := attributes["host"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`host is missing from object`)

		return NewEslConfigValueUnknown(), diags
	}

	hostVal, ok := hostAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`host expected to be basetypes.StringValue, was: %T`, hostAttribute))
	}

	portAttribute, ok := attributes["port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port is missing from object`)

		return NewEslConfigValueUnknown(), diags
	}

	portVal, ok := portAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port expected to be basetypes.Int64Value, was: %T`, portAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewEslConfigValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	verifyCertAttribute, ok := attributes["verify_cert"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`verify_cert is missing from object`)

		return NewEslConfigValueUnknown(), diags
	}

	verifyCertVal, ok := verifyCertAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`verify_cert expected to be basetypes.BoolValue, was: %T`, verifyCertAttribute))
	}

	vlanIdAttribute, ok := attributes["vlan_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan_id is missing from object`)

		return NewEslConfigValueUnknown(), diags
	}

	vlanIdVal, ok := vlanIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan_id expected to be basetypes.Int64Value, was: %T`, vlanIdAttribute))
	}

	if diags.HasError() {
		return NewEslConfigValueUnknown(), diags
	}

	return EslConfigValue{
		Cacert:        cacertVal,
		Channel:       channelVal,
		Enabled:       enabledVal,
		Host:          hostVal,
		Port:          portVal,
		EslConfigType: typeVal,
		VerifyCert:    verifyCertVal,
		VlanId:        vlanIdVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewEslConfigValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) EslConfigValue {
	object, diags := NewEslConfigValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewEslConfigValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t EslConfigType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewEslConfigValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewEslConfigValueUnknown(), nil
	}

	if in.IsNull() {
		return NewEslConfigValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewEslConfigValueMust(EslConfigValue{}.AttributeTypes(ctx), attributes), nil
}

func (t EslConfigType) ValueType(ctx context.Context) attr.Value {
	return EslConfigValue{}
}

var _ basetypes.ObjectValuable = EslConfigValue{}

type EslConfigValue struct {
	Cacert        basetypes.StringValue `tfsdk:"cacert"`
	Channel       basetypes.Int64Value  `tfsdk:"channel"`
	Enabled       basetypes.BoolValue   `tfsdk:"enabled"`
	Host          basetypes.StringValue `tfsdk:"host"`
	Port          basetypes.Int64Value  `tfsdk:"port"`
	EslConfigType basetypes.StringValue `tfsdk:"type"`
	VerifyCert    basetypes.BoolValue   `tfsdk:"verify_cert"`
	VlanId        basetypes.Int64Value  `tfsdk:"vlan_id"`
	state         attr.ValueState
}

func (v EslConfigValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 8)

	var val tftypes.Value
	var err error

	attrTypes["cacert"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["channel"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["host"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["port"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["verify_cert"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["vlan_id"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 8)

		val, err = v.Cacert.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cacert"] = val

		val, err = v.Channel.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["channel"] = val

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.Host.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["host"] = val

		val, err = v.Port.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port"] = val

		val, err = v.EslConfigType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		val, err = v.VerifyCert.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["verify_cert"] = val

		val, err = v.VlanId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vlan_id"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v EslConfigValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v EslConfigValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v EslConfigValue) String() string {
	return "EslConfigValue"
}

func (v EslConfigValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"cacert":      basetypes.StringType{},
		"channel":     basetypes.Int64Type{},
		"enabled":     basetypes.BoolType{},
		"host":        basetypes.StringType{},
		"port":        basetypes.Int64Type{},
		"type":        basetypes.StringType{},
		"verify_cert": basetypes.BoolType{},
		"vlan_id":     basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"cacert":      v.Cacert,
			"channel":     v.Channel,
			"enabled":     v.Enabled,
			"host":        v.Host,
			"port":        v.Port,
			"type":        v.EslConfigType,
			"verify_cert": v.VerifyCert,
			"vlan_id":     v.VlanId,
		})

	return objVal, diags
}

func (v EslConfigValue) Equal(o attr.Value) bool {
	other, ok := o.(EslConfigValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Cacert.Equal(other.Cacert) {
		return false
	}

	if !v.Channel.Equal(other.Channel) {
		return false
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.Host.Equal(other.Host) {
		return false
	}

	if !v.Port.Equal(other.Port) {
		return false
	}

	if !v.EslConfigType.Equal(other.EslConfigType) {
		return false
	}

	if !v.VerifyCert.Equal(other.VerifyCert) {
		return false
	}

	if !v.VlanId.Equal(other.VlanId) {
		return false
	}

	return true
}

func (v EslConfigValue) Type(ctx context.Context) attr.Type {
	return EslConfigType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v EslConfigValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"cacert":      basetypes.StringType{},
		"channel":     basetypes.Int64Type{},
		"enabled":     basetypes.BoolType{},
		"host":        basetypes.StringType{},
		"port":        basetypes.Int64Type{},
		"type":        basetypes.StringType{},
		"verify_cert": basetypes.BoolType{},
		"vlan_id":     basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = IpConfigType{}

type IpConfigType struct {
	basetypes.ObjectType
}

func (t IpConfigType) Equal(o attr.Type) bool {
	other, ok := o.(IpConfigType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t IpConfigType) String() string {
	return "IpConfigType"
}

func (t IpConfigType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	dnsAttribute, ok := attributes["dns"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dns is missing from object`)

		return nil, diags
	}

	dnsVal, ok := dnsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dns expected to be basetypes.ListValue, was: %T`, dnsAttribute))
	}

	dnsSuffixAttribute, ok := attributes["dns_suffix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dns_suffix is missing from object`)

		return nil, diags
	}

	dnsSuffixVal, ok := dnsSuffixAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dns_suffix expected to be basetypes.ListValue, was: %T`, dnsSuffixAttribute))
	}

	gatewayAttribute, ok := attributes["gateway"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gateway is missing from object`)

		return nil, diags
	}

	gatewayVal, ok := gatewayAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gateway expected to be basetypes.StringValue, was: %T`, gatewayAttribute))
	}

	gateway6Attribute, ok := attributes["gateway6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gateway6 is missing from object`)

		return nil, diags
	}

	gateway6Val, ok := gateway6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gateway6 expected to be basetypes.StringValue, was: %T`, gateway6Attribute))
	}

	ipAttribute, ok := attributes["ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip is missing from object`)

		return nil, diags
	}

	ipVal, ok := ipAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip expected to be basetypes.StringValue, was: %T`, ipAttribute))
	}

	ip6Attribute, ok := attributes["ip6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip6 is missing from object`)

		return nil, diags
	}

	ip6Val, ok := ip6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip6 expected to be basetypes.StringValue, was: %T`, ip6Attribute))
	}

	mtuAttribute, ok := attributes["mtu"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mtu is missing from object`)

		return nil, diags
	}

	mtuVal, ok := mtuAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mtu expected to be basetypes.Int64Value, was: %T`, mtuAttribute))
	}

	netmaskAttribute, ok := attributes["netmask"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`netmask is missing from object`)

		return nil, diags
	}

	netmaskVal, ok := netmaskAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`netmask expected to be basetypes.StringValue, was: %T`, netmaskAttribute))
	}

	netmask6Attribute, ok := attributes["netmask6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`netmask6 is missing from object`)

		return nil, diags
	}

	netmask6Val, ok := netmask6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`netmask6 expected to be basetypes.StringValue, was: %T`, netmask6Attribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	type6Attribute, ok := attributes["type6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type6 is missing from object`)

		return nil, diags
	}

	type6Val, ok := type6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type6 expected to be basetypes.StringValue, was: %T`, type6Attribute))
	}

	vlanIdAttribute, ok := attributes["vlan_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan_id is missing from object`)

		return nil, diags
	}

	vlanIdVal, ok := vlanIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan_id expected to be basetypes.Int64Value, was: %T`, vlanIdAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return IpConfigValue{
		Dns:          dnsVal,
		DnsSuffix:    dnsSuffixVal,
		Gateway:      gatewayVal,
		Gateway6:     gateway6Val,
		Ip:           ipVal,
		Ip6:          ip6Val,
		Mtu:          mtuVal,
		Netmask:      netmaskVal,
		Netmask6:     netmask6Val,
		IpConfigType: typeVal,
		Type6:        type6Val,
		VlanId:       vlanIdVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewIpConfigValueNull() IpConfigValue {
	return IpConfigValue{
		state: attr.ValueStateNull,
	}
}

func NewIpConfigValueUnknown() IpConfigValue {
	return IpConfigValue{
		state: attr.ValueStateUnknown,
	}
}

func NewIpConfigValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (IpConfigValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing IpConfigValue Attribute Value",
				"While creating a IpConfigValue value, a missing attribute value was detected. "+
					"A IpConfigValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("IpConfigValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid IpConfigValue Attribute Type",
				"While creating a IpConfigValue value, an invalid attribute value was detected. "+
					"A IpConfigValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("IpConfigValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("IpConfigValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra IpConfigValue Attribute Value",
				"While creating a IpConfigValue value, an extra attribute value was detected. "+
					"A IpConfigValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra IpConfigValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewIpConfigValueUnknown(), diags
	}

	dnsAttribute, ok := attributes["dns"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dns is missing from object`)

		return NewIpConfigValueUnknown(), diags
	}

	dnsVal, ok := dnsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dns expected to be basetypes.ListValue, was: %T`, dnsAttribute))
	}

	dnsSuffixAttribute, ok := attributes["dns_suffix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dns_suffix is missing from object`)

		return NewIpConfigValueUnknown(), diags
	}

	dnsSuffixVal, ok := dnsSuffixAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dns_suffix expected to be basetypes.ListValue, was: %T`, dnsSuffixAttribute))
	}

	gatewayAttribute, ok := attributes["gateway"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gateway is missing from object`)

		return NewIpConfigValueUnknown(), diags
	}

	gatewayVal, ok := gatewayAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gateway expected to be basetypes.StringValue, was: %T`, gatewayAttribute))
	}

	gateway6Attribute, ok := attributes["gateway6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gateway6 is missing from object`)

		return NewIpConfigValueUnknown(), diags
	}

	gateway6Val, ok := gateway6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gateway6 expected to be basetypes.StringValue, was: %T`, gateway6Attribute))
	}

	ipAttribute, ok := attributes["ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip is missing from object`)

		return NewIpConfigValueUnknown(), diags
	}

	ipVal, ok := ipAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip expected to be basetypes.StringValue, was: %T`, ipAttribute))
	}

	ip6Attribute, ok := attributes["ip6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip6 is missing from object`)

		return NewIpConfigValueUnknown(), diags
	}

	ip6Val, ok := ip6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip6 expected to be basetypes.StringValue, was: %T`, ip6Attribute))
	}

	mtuAttribute, ok := attributes["mtu"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mtu is missing from object`)

		return NewIpConfigValueUnknown(), diags
	}

	mtuVal, ok := mtuAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mtu expected to be basetypes.Int64Value, was: %T`, mtuAttribute))
	}

	netmaskAttribute, ok := attributes["netmask"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`netmask is missing from object`)

		return NewIpConfigValueUnknown(), diags
	}

	netmaskVal, ok := netmaskAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`netmask expected to be basetypes.StringValue, was: %T`, netmaskAttribute))
	}

	netmask6Attribute, ok := attributes["netmask6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`netmask6 is missing from object`)

		return NewIpConfigValueUnknown(), diags
	}

	netmask6Val, ok := netmask6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`netmask6 expected to be basetypes.StringValue, was: %T`, netmask6Attribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewIpConfigValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	type6Attribute, ok := attributes["type6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type6 is missing from object`)

		return NewIpConfigValueUnknown(), diags
	}

	type6Val, ok := type6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type6 expected to be basetypes.StringValue, was: %T`, type6Attribute))
	}

	vlanIdAttribute, ok := attributes["vlan_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan_id is missing from object`)

		return NewIpConfigValueUnknown(), diags
	}

	vlanIdVal, ok := vlanIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan_id expected to be basetypes.Int64Value, was: %T`, vlanIdAttribute))
	}

	if diags.HasError() {
		return NewIpConfigValueUnknown(), diags
	}

	return IpConfigValue{
		Dns:          dnsVal,
		DnsSuffix:    dnsSuffixVal,
		Gateway:      gatewayVal,
		Gateway6:     gateway6Val,
		Ip:           ipVal,
		Ip6:          ip6Val,
		Mtu:          mtuVal,
		Netmask:      netmaskVal,
		Netmask6:     netmask6Val,
		IpConfigType: typeVal,
		Type6:        type6Val,
		VlanId:       vlanIdVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewIpConfigValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) IpConfigValue {
	object, diags := NewIpConfigValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewIpConfigValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t IpConfigType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewIpConfigValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewIpConfigValueUnknown(), nil
	}

	if in.IsNull() {
		return NewIpConfigValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewIpConfigValueMust(IpConfigValue{}.AttributeTypes(ctx), attributes), nil
}

func (t IpConfigType) ValueType(ctx context.Context) attr.Value {
	return IpConfigValue{}
}

var _ basetypes.ObjectValuable = IpConfigValue{}

type IpConfigValue struct {
	Dns          basetypes.ListValue   `tfsdk:"dns"`
	DnsSuffix    basetypes.ListValue   `tfsdk:"dns_suffix"`
	Gateway      basetypes.StringValue `tfsdk:"gateway"`
	Gateway6     basetypes.StringValue `tfsdk:"gateway6"`
	Ip           basetypes.StringValue `tfsdk:"ip"`
	Ip6          basetypes.StringValue `tfsdk:"ip6"`
	Mtu          basetypes.Int64Value  `tfsdk:"mtu"`
	Netmask      basetypes.StringValue `tfsdk:"netmask"`
	Netmask6     basetypes.StringValue `tfsdk:"netmask6"`
	IpConfigType basetypes.StringValue `tfsdk:"type"`
	Type6        basetypes.StringValue `tfsdk:"type6"`
	VlanId       basetypes.Int64Value  `tfsdk:"vlan_id"`
	state        attr.ValueState
}

func (v IpConfigValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 12)

	var val tftypes.Value
	var err error

	attrTypes["dns"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["dns_suffix"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["gateway"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["gateway6"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ip"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ip6"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["mtu"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["netmask"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["netmask6"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["type6"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["vlan_id"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 12)

		val, err = v.Dns.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dns"] = val

		val, err = v.DnsSuffix.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dns_suffix"] = val

		val, err = v.Gateway.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["gateway"] = val

		val, err = v.Gateway6.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["gateway6"] = val

		val, err = v.Ip.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip"] = val

		val, err = v.Ip6.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip6"] = val

		val, err = v.Mtu.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mtu"] = val

		val, err = v.Netmask.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["netmask"] = val

		val, err = v.Netmask6.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["netmask6"] = val

		val, err = v.IpConfigType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		val, err = v.Type6.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type6"] = val

		val, err = v.VlanId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vlan_id"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v IpConfigValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v IpConfigValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v IpConfigValue) String() string {
	return "IpConfigValue"
}

func (v IpConfigValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var dnsVal basetypes.ListValue
	switch {
	case v.Dns.IsUnknown():
		dnsVal = types.ListUnknown(types.StringType)
	case v.Dns.IsNull():
		dnsVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		dnsVal, d = types.ListValue(types.StringType, v.Dns.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"dns": basetypes.ListType{
				ElemType: types.StringType,
			},
			"dns_suffix": basetypes.ListType{
				ElemType: types.StringType,
			},
			"gateway":  basetypes.StringType{},
			"gateway6": basetypes.StringType{},
			"ip":       basetypes.StringType{},
			"ip6":      basetypes.StringType{},
			"mtu":      basetypes.Int64Type{},
			"netmask":  basetypes.StringType{},
			"netmask6": basetypes.StringType{},
			"type":     basetypes.StringType{},
			"type6":    basetypes.StringType{},
			"vlan_id":  basetypes.Int64Type{},
		}), diags
	}

	var dnsSuffixVal basetypes.ListValue
	switch {
	case v.DnsSuffix.IsUnknown():
		dnsSuffixVal = types.ListUnknown(types.StringType)
	case v.DnsSuffix.IsNull():
		dnsSuffixVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		dnsSuffixVal, d = types.ListValue(types.StringType, v.DnsSuffix.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"dns": basetypes.ListType{
				ElemType: types.StringType,
			},
			"dns_suffix": basetypes.ListType{
				ElemType: types.StringType,
			},
			"gateway":  basetypes.StringType{},
			"gateway6": basetypes.StringType{},
			"ip":       basetypes.StringType{},
			"ip6":      basetypes.StringType{},
			"mtu":      basetypes.Int64Type{},
			"netmask":  basetypes.StringType{},
			"netmask6": basetypes.StringType{},
			"type":     basetypes.StringType{},
			"type6":    basetypes.StringType{},
			"vlan_id":  basetypes.Int64Type{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"dns": basetypes.ListType{
			ElemType: types.StringType,
		},
		"dns_suffix": basetypes.ListType{
			ElemType: types.StringType,
		},
		"gateway":  basetypes.StringType{},
		"gateway6": basetypes.StringType{},
		"ip":       basetypes.StringType{},
		"ip6":      basetypes.StringType{},
		"mtu":      basetypes.Int64Type{},
		"netmask":  basetypes.StringType{},
		"netmask6": basetypes.StringType{},
		"type":     basetypes.StringType{},
		"type6":    basetypes.StringType{},
		"vlan_id":  basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"dns":        dnsVal,
			"dns_suffix": dnsSuffixVal,
			"gateway":    v.Gateway,
			"gateway6":   v.Gateway6,
			"ip":         v.Ip,
			"ip6":        v.Ip6,
			"mtu":        v.Mtu,
			"netmask":    v.Netmask,
			"netmask6":   v.Netmask6,
			"type":       v.IpConfigType,
			"type6":      v.Type6,
			"vlan_id":    v.VlanId,
		})

	return objVal, diags
}

func (v IpConfigValue) Equal(o attr.Value) bool {
	other, ok := o.(IpConfigValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Dns.Equal(other.Dns) {
		return false
	}

	if !v.DnsSuffix.Equal(other.DnsSuffix) {
		return false
	}

	if !v.Gateway.Equal(other.Gateway) {
		return false
	}

	if !v.Gateway6.Equal(other.Gateway6) {
		return false
	}

	if !v.Ip.Equal(other.Ip) {
		return false
	}

	if !v.Ip6.Equal(other.Ip6) {
		return false
	}

	if !v.Mtu.Equal(other.Mtu) {
		return false
	}

	if !v.Netmask.Equal(other.Netmask) {
		return false
	}

	if !v.Netmask6.Equal(other.Netmask6) {
		return false
	}

	if !v.IpConfigType.Equal(other.IpConfigType) {
		return false
	}

	if !v.Type6.Equal(other.Type6) {
		return false
	}

	if !v.VlanId.Equal(other.VlanId) {
		return false
	}

	return true
}

func (v IpConfigValue) Type(ctx context.Context) attr.Type {
	return IpConfigType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v IpConfigValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"dns": basetypes.ListType{
			ElemType: types.StringType,
		},
		"dns_suffix": basetypes.ListType{
			ElemType: types.StringType,
		},
		"gateway":  basetypes.StringType{},
		"gateway6": basetypes.StringType{},
		"ip":       basetypes.StringType{},
		"ip6":      basetypes.StringType{},
		"mtu":      basetypes.Int64Type{},
		"netmask":  basetypes.StringType{},
		"netmask6": basetypes.StringType{},
		"type":     basetypes.StringType{},
		"type6":    basetypes.StringType{},
		"vlan_id":  basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = LacpConfigType{}

type LacpConfigType struct {
	basetypes.ObjectType
}

func (t LacpConfigType) Equal(o attr.Type) bool {
	other, ok := o.(LacpConfigType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t LacpConfigType) String() string {
	return "LacpConfigType"
}

func (t LacpConfigType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return LacpConfigValue{
		Enabled: enabledVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewLacpConfigValueNull() LacpConfigValue {
	return LacpConfigValue{
		state: attr.ValueStateNull,
	}
}

func NewLacpConfigValueUnknown() LacpConfigValue {
	return LacpConfigValue{
		state: attr.ValueStateUnknown,
	}
}

func NewLacpConfigValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (LacpConfigValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing LacpConfigValue Attribute Value",
				"While creating a LacpConfigValue value, a missing attribute value was detected. "+
					"A LacpConfigValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("LacpConfigValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid LacpConfigValue Attribute Type",
				"While creating a LacpConfigValue value, an invalid attribute value was detected. "+
					"A LacpConfigValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("LacpConfigValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("LacpConfigValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra LacpConfigValue Attribute Value",
				"While creating a LacpConfigValue value, an extra attribute value was detected. "+
					"A LacpConfigValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra LacpConfigValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewLacpConfigValueUnknown(), diags
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewLacpConfigValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	if diags.HasError() {
		return NewLacpConfigValueUnknown(), diags
	}

	return LacpConfigValue{
		Enabled: enabledVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewLacpConfigValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) LacpConfigValue {
	object, diags := NewLacpConfigValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewLacpConfigValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t LacpConfigType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewLacpConfigValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewLacpConfigValueUnknown(), nil
	}

	if in.IsNull() {
		return NewLacpConfigValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewLacpConfigValueMust(LacpConfigValue{}.AttributeTypes(ctx), attributes), nil
}

func (t LacpConfigType) ValueType(ctx context.Context) attr.Value {
	return LacpConfigValue{}
}

var _ basetypes.ObjectValuable = LacpConfigValue{}

type LacpConfigValue struct {
	Enabled basetypes.BoolValue `tfsdk:"enabled"`
	state   attr.ValueState
}

func (v LacpConfigValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v LacpConfigValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v LacpConfigValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v LacpConfigValue) String() string {
	return "LacpConfigValue"
}

func (v LacpConfigValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"enabled": basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"enabled": v.Enabled,
		})

	return objVal, diags
}

func (v LacpConfigValue) Equal(o attr.Value) bool {
	other, ok := o.(LacpConfigValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	return true
}

func (v LacpConfigValue) Type(ctx context.Context) attr.Type {
	return LacpConfigType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v LacpConfigValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"enabled": basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = LedType{}

type LedType struct {
	basetypes.ObjectType
}

func (t LedType) Equal(o attr.Type) bool {
	other, ok := o.(LedType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t LedType) String() string {
	return "LedType"
}

func (t LedType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	brightnessAttribute, ok := attributes["brightness"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`brightness is missing from object`)

		return nil, diags
	}

	brightnessVal, ok := brightnessAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`brightness expected to be basetypes.Int64Value, was: %T`, brightnessAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return LedValue{
		Brightness: brightnessVal,
		Enabled:    enabledVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewLedValueNull() LedValue {
	return LedValue{
		state: attr.ValueStateNull,
	}
}

func NewLedValueUnknown() LedValue {
	return LedValue{
		state: attr.ValueStateUnknown,
	}
}

func NewLedValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (LedValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing LedValue Attribute Value",
				"While creating a LedValue value, a missing attribute value was detected. "+
					"A LedValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("LedValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid LedValue Attribute Type",
				"While creating a LedValue value, an invalid attribute value was detected. "+
					"A LedValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("LedValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("LedValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra LedValue Attribute Value",
				"While creating a LedValue value, an extra attribute value was detected. "+
					"A LedValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra LedValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewLedValueUnknown(), diags
	}

	brightnessAttribute, ok := attributes["brightness"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`brightness is missing from object`)

		return NewLedValueUnknown(), diags
	}

	brightnessVal, ok := brightnessAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`brightness expected to be basetypes.Int64Value, was: %T`, brightnessAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewLedValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	if diags.HasError() {
		return NewLedValueUnknown(), diags
	}

	return LedValue{
		Brightness: brightnessVal,
		Enabled:    enabledVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewLedValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) LedValue {
	object, diags := NewLedValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewLedValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t LedType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewLedValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewLedValueUnknown(), nil
	}

	if in.IsNull() {
		return NewLedValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewLedValueMust(LedValue{}.AttributeTypes(ctx), attributes), nil
}

func (t LedType) ValueType(ctx context.Context) attr.Value {
	return LedValue{}
}

var _ basetypes.ObjectValuable = LedValue{}

type LedValue struct {
	Brightness basetypes.Int64Value `tfsdk:"brightness"`
	Enabled    basetypes.BoolValue  `tfsdk:"enabled"`
	state      attr.ValueState
}

func (v LedValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["brightness"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Brightness.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["brightness"] = val

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v LedValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v LedValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v LedValue) String() string {
	return "LedValue"
}

func (v LedValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"brightness": basetypes.Int64Type{},
		"enabled":    basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"brightness": v.Brightness,
			"enabled":    v.Enabled,
		})

	return objVal, diags
}

func (v LedValue) Equal(o attr.Value) bool {
	other, ok := o.(LedValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Brightness.Equal(other.Brightness) {
		return false
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	return true
}

func (v LedValue) Type(ctx context.Context) attr.Type {
	return LedType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v LedValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"brightness": basetypes.Int64Type{},
		"enabled":    basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = MeshType{}

type MeshType struct {
	basetypes.ObjectType
}

func (t MeshType) Equal(o attr.Type) bool {
	other, ok := o.(MeshType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t MeshType) String() string {
	return "MeshType"
}

func (t MeshType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	bandsAttribute, ok := attributes["bands"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bands is missing from object`)

		return nil, diags
	}

	bandsVal, ok := bandsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bands expected to be basetypes.ListValue, was: %T`, bandsAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	groupAttribute, ok := attributes["group"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`group is missing from object`)

		return nil, diags
	}

	groupVal, ok := groupAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`group expected to be basetypes.Int64Value, was: %T`, groupAttribute))
	}

	roleAttribute, ok := attributes["role"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`role is missing from object`)

		return nil, diags
	}

	roleVal, ok := roleAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`role expected to be basetypes.StringValue, was: %T`, roleAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return MeshValue{
		Bands:   bandsVal,
		Enabled: enabledVal,
		Group:   groupVal,
		Role:    roleVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewMeshValueNull() MeshValue {
	return MeshValue{
		state: attr.ValueStateNull,
	}
}

func NewMeshValueUnknown() MeshValue {
	return MeshValue{
		state: attr.ValueStateUnknown,
	}
}

func NewMeshValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (MeshValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing MeshValue Attribute Value",
				"While creating a MeshValue value, a missing attribute value was detected. "+
					"A MeshValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MeshValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid MeshValue Attribute Type",
				"While creating a MeshValue value, an invalid attribute value was detected. "+
					"A MeshValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MeshValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("MeshValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra MeshValue Attribute Value",
				"While creating a MeshValue value, an extra attribute value was detected. "+
					"A MeshValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra MeshValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewMeshValueUnknown(), diags
	}

	bandsAttribute, ok := attributes["bands"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bands is missing from object`)

		return NewMeshValueUnknown(), diags
	}

	bandsVal, ok := bandsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bands expected to be basetypes.ListValue, was: %T`, bandsAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewMeshValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	groupAttribute, ok := attributes["group"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`group is missing from object`)

		return NewMeshValueUnknown(), diags
	}

	groupVal, ok := groupAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`group expected to be basetypes.Int64Value, was: %T`, groupAttribute))
	}

	roleAttribute, ok := attributes["role"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`role is missing from object`)

		return NewMeshValueUnknown(), diags
	}

	roleVal, ok := roleAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`role expected to be basetypes.StringValue, was: %T`, roleAttribute))
	}

	if diags.HasError() {
		return NewMeshValueUnknown(), diags
	}

	return MeshValue{
		Bands:   bandsVal,
		Enabled: enabledVal,
		Group:   groupVal,
		Role:    roleVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewMeshValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) MeshValue {
	object, diags := NewMeshValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewMeshValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t MeshType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewMeshValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewMeshValueUnknown(), nil
	}

	if in.IsNull() {
		return NewMeshValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewMeshValueMust(MeshValue{}.AttributeTypes(ctx), attributes), nil
}

func (t MeshType) ValueType(ctx context.Context) attr.Value {
	return MeshValue{}
}

var _ basetypes.ObjectValuable = MeshValue{}

type MeshValue struct {
	Bands   basetypes.ListValue   `tfsdk:"bands"`
	Enabled basetypes.BoolValue   `tfsdk:"enabled"`
	Group   basetypes.Int64Value  `tfsdk:"group"`
	Role    basetypes.StringValue `tfsdk:"role"`
	state   attr.ValueState
}

func (v MeshValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["bands"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["group"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["role"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Bands.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bands"] = val

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.Group.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["group"] = val

		val, err = v.Role.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["role"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v MeshValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v MeshValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v MeshValue) String() string {
	return "MeshValue"
}

func (v MeshValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var bandsVal basetypes.ListValue
	switch {
	case v.Bands.IsUnknown():
		bandsVal = types.ListUnknown(types.StringType)
	case v.Bands.IsNull():
		bandsVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		bandsVal, d = types.ListValue(types.StringType, v.Bands.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"bands": basetypes.ListType{
				ElemType: types.StringType,
			},
			"enabled": basetypes.BoolType{},
			"group":   basetypes.Int64Type{},
			"role":    basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"bands": basetypes.ListType{
			ElemType: types.StringType,
		},
		"enabled": basetypes.BoolType{},
		"group":   basetypes.Int64Type{},
		"role":    basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"bands":   bandsVal,
			"enabled": v.Enabled,
			"group":   v.Group,
			"role":    v.Role,
		})

	return objVal, diags
}

func (v MeshValue) Equal(o attr.Value) bool {
	other, ok := o.(MeshValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Bands.Equal(other.Bands) {
		return false
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.Group.Equal(other.Group) {
		return false
	}

	if !v.Role.Equal(other.Role) {
		return false
	}

	return true
}

func (v MeshValue) Type(ctx context.Context) attr.Type {
	return MeshType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v MeshValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"bands": basetypes.ListType{
			ElemType: types.StringType,
		},
		"enabled": basetypes.BoolType{},
		"group":   basetypes.Int64Type{},
		"role":    basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = PortConfigType{}

type PortConfigType struct {
	basetypes.ObjectType
}

func (t PortConfigType) Equal(o attr.Type) bool {
	other, ok := o.(PortConfigType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PortConfigType) String() string {
	return "PortConfigType"
}

func (t PortConfigType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	disabledAttribute, ok := attributes["disabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disabled is missing from object`)

		return nil, diags
	}

	disabledVal, ok := disabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disabled expected to be basetypes.BoolValue, was: %T`, disabledAttribute))
	}

	dynamicVlanAttribute, ok := attributes["dynamic_vlan"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dynamic_vlan is missing from object`)

		return nil, diags
	}

	dynamicVlanVal, ok := dynamicVlanAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dynamic_vlan expected to be basetypes.ObjectValue, was: %T`, dynamicVlanAttribute))
	}

	enableMacAuthAttribute, ok := attributes["enable_mac_auth"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable_mac_auth is missing from object`)

		return nil, diags
	}

	enableMacAuthVal, ok := enableMacAuthAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable_mac_auth expected to be basetypes.BoolValue, was: %T`, enableMacAuthAttribute))
	}

	forwardingAttribute, ok := attributes["forwarding"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`forwarding is missing from object`)

		return nil, diags
	}

	forwardingVal, ok := forwardingAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`forwarding expected to be basetypes.StringValue, was: %T`, forwardingAttribute))
	}

	macAuthPreferredAttribute, ok := attributes["mac_auth_preferred"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mac_auth_preferred is missing from object`)

		return nil, diags
	}

	macAuthPreferredVal, ok := macAuthPreferredAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mac_auth_preferred expected to be basetypes.BoolValue, was: %T`, macAuthPreferredAttribute))
	}

	macAuthProtocolAttribute, ok := attributes["mac_auth_protocol"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mac_auth_protocol is missing from object`)

		return nil, diags
	}

	macAuthProtocolVal, ok := macAuthProtocolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mac_auth_protocol expected to be basetypes.StringValue, was: %T`, macAuthProtocolAttribute))
	}

	mistNacAttribute, ok := attributes["mist_nac"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mist_nac is missing from object`)

		return nil, diags
	}

	mistNacVal, ok := mistNacAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mist_nac expected to be basetypes.ObjectValue, was: %T`, mistNacAttribute))
	}

	mxTunnelIdAttribute, ok := attributes["mx_tunnel_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mx_tunnel_id is missing from object`)

		return nil, diags
	}

	mxTunnelIdVal, ok := mxTunnelIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mx_tunnel_id expected to be basetypes.StringValue, was: %T`, mxTunnelIdAttribute))
	}

	mxtunnelNameAttribute, ok := attributes["mxtunnel_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mxtunnel_name is missing from object`)

		return nil, diags
	}

	mxtunnelNameVal, ok := mxtunnelNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mxtunnel_name expected to be basetypes.StringValue, was: %T`, mxtunnelNameAttribute))
	}

	portAuthAttribute, ok := attributes["port_auth"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_auth is missing from object`)

		return nil, diags
	}

	portAuthVal, ok := portAuthAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_auth expected to be basetypes.StringValue, was: %T`, portAuthAttribute))
	}

	portVlanIdAttribute, ok := attributes["port_vlan_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_vlan_id is missing from object`)

		return nil, diags
	}

	portVlanIdVal, ok := portVlanIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_vlan_id expected to be basetypes.Int64Value, was: %T`, portVlanIdAttribute))
	}

	radiusConfigAttribute, ok := attributes["radius_config"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`radius_config is missing from object`)

		return nil, diags
	}

	radiusConfigVal, ok := radiusConfigAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`radius_config expected to be basetypes.ObjectValue, was: %T`, radiusConfigAttribute))
	}

	radsecAttribute, ok := attributes["radsec"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`radsec is missing from object`)

		return nil, diags
	}

	radsecVal, ok := radsecAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`radsec expected to be basetypes.ObjectValue, was: %T`, radsecAttribute))
	}

	vlanIdAttribute, ok := attributes["vlan_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan_id is missing from object`)

		return nil, diags
	}

	vlanIdVal, ok := vlanIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan_id expected to be basetypes.Int64Value, was: %T`, vlanIdAttribute))
	}

	vlanIdsAttribute, ok := attributes["vlan_ids"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan_ids is missing from object`)

		return nil, diags
	}

	vlanIdsVal, ok := vlanIdsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan_ids expected to be basetypes.ListValue, was: %T`, vlanIdsAttribute))
	}

	wxtunnelIdAttribute, ok := attributes["wxtunnel_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wxtunnel_id is missing from object`)

		return nil, diags
	}

	wxtunnelIdVal, ok := wxtunnelIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wxtunnel_id expected to be basetypes.StringValue, was: %T`, wxtunnelIdAttribute))
	}

	wxtunnelRemoteIdAttribute, ok := attributes["wxtunnel_remote_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wxtunnel_remote_id is missing from object`)

		return nil, diags
	}

	wxtunnelRemoteIdVal, ok := wxtunnelRemoteIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wxtunnel_remote_id expected to be basetypes.StringValue, was: %T`, wxtunnelRemoteIdAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PortConfigValue{
		Disabled:         disabledVal,
		DynamicVlan:      dynamicVlanVal,
		EnableMacAuth:    enableMacAuthVal,
		Forwarding:       forwardingVal,
		MacAuthPreferred: macAuthPreferredVal,
		MacAuthProtocol:  macAuthProtocolVal,
		MistNac:          mistNacVal,
		MxTunnelId:       mxTunnelIdVal,
		MxtunnelName:     mxtunnelNameVal,
		PortAuth:         portAuthVal,
		PortVlanId:       portVlanIdVal,
		RadiusConfig:     radiusConfigVal,
		Radsec:           radsecVal,
		VlanId:           vlanIdVal,
		VlanIds:          vlanIdsVal,
		WxtunnelId:       wxtunnelIdVal,
		WxtunnelRemoteId: wxtunnelRemoteIdVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewPortConfigValueNull() PortConfigValue {
	return PortConfigValue{
		state: attr.ValueStateNull,
	}
}

func NewPortConfigValueUnknown() PortConfigValue {
	return PortConfigValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPortConfigValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PortConfigValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PortConfigValue Attribute Value",
				"While creating a PortConfigValue value, a missing attribute value was detected. "+
					"A PortConfigValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PortConfigValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PortConfigValue Attribute Type",
				"While creating a PortConfigValue value, an invalid attribute value was detected. "+
					"A PortConfigValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PortConfigValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PortConfigValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PortConfigValue Attribute Value",
				"While creating a PortConfigValue value, an extra attribute value was detected. "+
					"A PortConfigValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PortConfigValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPortConfigValueUnknown(), diags
	}

	disabledAttribute, ok := attributes["disabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disabled is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	disabledVal, ok := disabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disabled expected to be basetypes.BoolValue, was: %T`, disabledAttribute))
	}

	dynamicVlanAttribute, ok := attributes["dynamic_vlan"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dynamic_vlan is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	dynamicVlanVal, ok := dynamicVlanAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dynamic_vlan expected to be basetypes.ObjectValue, was: %T`, dynamicVlanAttribute))
	}

	enableMacAuthAttribute, ok := attributes["enable_mac_auth"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable_mac_auth is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	enableMacAuthVal, ok := enableMacAuthAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable_mac_auth expected to be basetypes.BoolValue, was: %T`, enableMacAuthAttribute))
	}

	forwardingAttribute, ok := attributes["forwarding"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`forwarding is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	forwardingVal, ok := forwardingAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`forwarding expected to be basetypes.StringValue, was: %T`, forwardingAttribute))
	}

	macAuthPreferredAttribute, ok := attributes["mac_auth_preferred"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mac_auth_preferred is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	macAuthPreferredVal, ok := macAuthPreferredAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mac_auth_preferred expected to be basetypes.BoolValue, was: %T`, macAuthPreferredAttribute))
	}

	macAuthProtocolAttribute, ok := attributes["mac_auth_protocol"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mac_auth_protocol is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	macAuthProtocolVal, ok := macAuthProtocolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mac_auth_protocol expected to be basetypes.StringValue, was: %T`, macAuthProtocolAttribute))
	}

	mistNacAttribute, ok := attributes["mist_nac"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mist_nac is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	mistNacVal, ok := mistNacAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mist_nac expected to be basetypes.ObjectValue, was: %T`, mistNacAttribute))
	}

	mxTunnelIdAttribute, ok := attributes["mx_tunnel_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mx_tunnel_id is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	mxTunnelIdVal, ok := mxTunnelIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mx_tunnel_id expected to be basetypes.StringValue, was: %T`, mxTunnelIdAttribute))
	}

	mxtunnelNameAttribute, ok := attributes["mxtunnel_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mxtunnel_name is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	mxtunnelNameVal, ok := mxtunnelNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mxtunnel_name expected to be basetypes.StringValue, was: %T`, mxtunnelNameAttribute))
	}

	portAuthAttribute, ok := attributes["port_auth"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_auth is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	portAuthVal, ok := portAuthAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_auth expected to be basetypes.StringValue, was: %T`, portAuthAttribute))
	}

	portVlanIdAttribute, ok := attributes["port_vlan_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_vlan_id is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	portVlanIdVal, ok := portVlanIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_vlan_id expected to be basetypes.Int64Value, was: %T`, portVlanIdAttribute))
	}

	radiusConfigAttribute, ok := attributes["radius_config"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`radius_config is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	radiusConfigVal, ok := radiusConfigAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`radius_config expected to be basetypes.ObjectValue, was: %T`, radiusConfigAttribute))
	}

	radsecAttribute, ok := attributes["radsec"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`radsec is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	radsecVal, ok := radsecAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`radsec expected to be basetypes.ObjectValue, was: %T`, radsecAttribute))
	}

	vlanIdAttribute, ok := attributes["vlan_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan_id is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	vlanIdVal, ok := vlanIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan_id expected to be basetypes.Int64Value, was: %T`, vlanIdAttribute))
	}

	vlanIdsAttribute, ok := attributes["vlan_ids"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan_ids is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	vlanIdsVal, ok := vlanIdsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan_ids expected to be basetypes.ListValue, was: %T`, vlanIdsAttribute))
	}

	wxtunnelIdAttribute, ok := attributes["wxtunnel_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wxtunnel_id is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	wxtunnelIdVal, ok := wxtunnelIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wxtunnel_id expected to be basetypes.StringValue, was: %T`, wxtunnelIdAttribute))
	}

	wxtunnelRemoteIdAttribute, ok := attributes["wxtunnel_remote_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wxtunnel_remote_id is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	wxtunnelRemoteIdVal, ok := wxtunnelRemoteIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wxtunnel_remote_id expected to be basetypes.StringValue, was: %T`, wxtunnelRemoteIdAttribute))
	}

	if diags.HasError() {
		return NewPortConfigValueUnknown(), diags
	}

	return PortConfigValue{
		Disabled:         disabledVal,
		DynamicVlan:      dynamicVlanVal,
		EnableMacAuth:    enableMacAuthVal,
		Forwarding:       forwardingVal,
		MacAuthPreferred: macAuthPreferredVal,
		MacAuthProtocol:  macAuthProtocolVal,
		MistNac:          mistNacVal,
		MxTunnelId:       mxTunnelIdVal,
		MxtunnelName:     mxtunnelNameVal,
		PortAuth:         portAuthVal,
		PortVlanId:       portVlanIdVal,
		RadiusConfig:     radiusConfigVal,
		Radsec:           radsecVal,
		VlanId:           vlanIdVal,
		VlanIds:          vlanIdsVal,
		WxtunnelId:       wxtunnelIdVal,
		WxtunnelRemoteId: wxtunnelRemoteIdVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewPortConfigValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PortConfigValue {
	object, diags := NewPortConfigValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPortConfigValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PortConfigType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPortConfigValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPortConfigValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPortConfigValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPortConfigValueMust(PortConfigValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PortConfigType) ValueType(ctx context.Context) attr.Value {
	return PortConfigValue{}
}

var _ basetypes.ObjectValuable = PortConfigValue{}

type PortConfigValue struct {
	Disabled         basetypes.BoolValue   `tfsdk:"disabled"`
	DynamicVlan      basetypes.ObjectValue `tfsdk:"dynamic_vlan"`
	EnableMacAuth    basetypes.BoolValue   `tfsdk:"enable_mac_auth"`
	Forwarding       basetypes.StringValue `tfsdk:"forwarding"`
	MacAuthPreferred basetypes.BoolValue   `tfsdk:"mac_auth_preferred"`
	MacAuthProtocol  basetypes.StringValue `tfsdk:"mac_auth_protocol"`
	MistNac          basetypes.ObjectValue `tfsdk:"mist_nac"`
	MxTunnelId       basetypes.StringValue `tfsdk:"mx_tunnel_id"`
	MxtunnelName     basetypes.StringValue `tfsdk:"mxtunnel_name"`
	PortAuth         basetypes.StringValue `tfsdk:"port_auth"`
	PortVlanId       basetypes.Int64Value  `tfsdk:"port_vlan_id"`
	RadiusConfig     basetypes.ObjectValue `tfsdk:"radius_config"`
	Radsec           basetypes.ObjectValue `tfsdk:"radsec"`
	VlanId           basetypes.Int64Value  `tfsdk:"vlan_id"`
	VlanIds          basetypes.ListValue   `tfsdk:"vlan_ids"`
	WxtunnelId       basetypes.StringValue `tfsdk:"wxtunnel_id"`
	WxtunnelRemoteId basetypes.StringValue `tfsdk:"wxtunnel_remote_id"`
	state            attr.ValueState
}

func (v PortConfigValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 17)

	var val tftypes.Value
	var err error

	attrTypes["disabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["dynamic_vlan"] = basetypes.ObjectType{
		AttrTypes: DynamicVlanValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["enable_mac_auth"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["forwarding"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["mac_auth_preferred"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["mac_auth_protocol"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["mist_nac"] = basetypes.ObjectType{
		AttrTypes: MistNacValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["mx_tunnel_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["mxtunnel_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["port_auth"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["port_vlan_id"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["radius_config"] = basetypes.ObjectType{
		AttrTypes: RadiusConfigValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["radsec"] = basetypes.ObjectType{
		AttrTypes: RadsecValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["vlan_id"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["vlan_ids"] = basetypes.ListType{
		ElemType: types.Int64Type,
	}.TerraformType(ctx)
	attrTypes["wxtunnel_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["wxtunnel_remote_id"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 17)

		val, err = v.Disabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["disabled"] = val

		val, err = v.DynamicVlan.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dynamic_vlan"] = val

		val, err = v.EnableMacAuth.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enable_mac_auth"] = val

		val, err = v.Forwarding.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["forwarding"] = val

		val, err = v.MacAuthPreferred.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mac_auth_preferred"] = val

		val, err = v.MacAuthProtocol.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mac_auth_protocol"] = val

		val, err = v.MistNac.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mist_nac"] = val

		val, err = v.MxTunnelId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mx_tunnel_id"] = val

		val, err = v.MxtunnelName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mxtunnel_name"] = val

		val, err = v.PortAuth.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port_auth"] = val

		val, err = v.PortVlanId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port_vlan_id"] = val

		val, err = v.RadiusConfig.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["radius_config"] = val

		val, err = v.Radsec.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["radsec"] = val

		val, err = v.VlanId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vlan_id"] = val

		val, err = v.VlanIds.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vlan_ids"] = val

		val, err = v.WxtunnelId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["wxtunnel_id"] = val

		val, err = v.WxtunnelRemoteId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["wxtunnel_remote_id"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PortConfigValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PortConfigValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PortConfigValue) String() string {
	return "PortConfigValue"
}

func (v PortConfigValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var dynamicVlan basetypes.ObjectValue

	if v.DynamicVlan.IsNull() {
		dynamicVlan = types.ObjectNull(
			DynamicVlanValue{}.AttributeTypes(ctx),
		)
	}

	if v.DynamicVlan.IsUnknown() {
		dynamicVlan = types.ObjectUnknown(
			DynamicVlanValue{}.AttributeTypes(ctx),
		)
	}

	if !v.DynamicVlan.IsNull() && !v.DynamicVlan.IsUnknown() {
		dynamicVlan = types.ObjectValueMust(
			DynamicVlanValue{}.AttributeTypes(ctx),
			v.DynamicVlan.Attributes(),
		)
	}

	var mistNac basetypes.ObjectValue

	if v.MistNac.IsNull() {
		mistNac = types.ObjectNull(
			MistNacValue{}.AttributeTypes(ctx),
		)
	}

	if v.MistNac.IsUnknown() {
		mistNac = types.ObjectUnknown(
			MistNacValue{}.AttributeTypes(ctx),
		)
	}

	if !v.MistNac.IsNull() && !v.MistNac.IsUnknown() {
		mistNac = types.ObjectValueMust(
			MistNacValue{}.AttributeTypes(ctx),
			v.MistNac.Attributes(),
		)
	}

	var radiusConfig basetypes.ObjectValue

	if v.RadiusConfig.IsNull() {
		radiusConfig = types.ObjectNull(
			RadiusConfigValue{}.AttributeTypes(ctx),
		)
	}

	if v.RadiusConfig.IsUnknown() {
		radiusConfig = types.ObjectUnknown(
			RadiusConfigValue{}.AttributeTypes(ctx),
		)
	}

	if !v.RadiusConfig.IsNull() && !v.RadiusConfig.IsUnknown() {
		radiusConfig = types.ObjectValueMust(
			RadiusConfigValue{}.AttributeTypes(ctx),
			v.RadiusConfig.Attributes(),
		)
	}

	var radsec basetypes.ObjectValue

	if v.Radsec.IsNull() {
		radsec = types.ObjectNull(
			RadsecValue{}.AttributeTypes(ctx),
		)
	}

	if v.Radsec.IsUnknown() {
		radsec = types.ObjectUnknown(
			RadsecValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Radsec.IsNull() && !v.Radsec.IsUnknown() {
		radsec = types.ObjectValueMust(
			RadsecValue{}.AttributeTypes(ctx),
			v.Radsec.Attributes(),
		)
	}

	var vlanIdsVal basetypes.ListValue
	switch {
	case v.VlanIds.IsUnknown():
		vlanIdsVal = types.ListUnknown(types.Int64Type)
	case v.VlanIds.IsNull():
		vlanIdsVal = types.ListNull(types.Int64Type)
	default:
		var d diag.Diagnostics
		vlanIdsVal, d = types.ListValue(types.Int64Type, v.VlanIds.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"disabled": basetypes.BoolType{},
			"dynamic_vlan": basetypes.ObjectType{
				AttrTypes: DynamicVlanValue{}.AttributeTypes(ctx),
			},
			"enable_mac_auth":    basetypes.BoolType{},
			"forwarding":         basetypes.StringType{},
			"mac_auth_preferred": basetypes.BoolType{},
			"mac_auth_protocol":  basetypes.StringType{},
			"mist_nac": basetypes.ObjectType{
				AttrTypes: MistNacValue{}.AttributeTypes(ctx),
			},
			"mx_tunnel_id":  basetypes.StringType{},
			"mxtunnel_name": basetypes.StringType{},
			"port_auth":     basetypes.StringType{},
			"port_vlan_id":  basetypes.Int64Type{},
			"radius_config": basetypes.ObjectType{
				AttrTypes: RadiusConfigValue{}.AttributeTypes(ctx),
			},
			"radsec": basetypes.ObjectType{
				AttrTypes: RadsecValue{}.AttributeTypes(ctx),
			},
			"vlan_id": basetypes.Int64Type{},
			"vlan_ids": basetypes.ListType{
				ElemType: types.Int64Type,
			},
			"wxtunnel_id":        basetypes.StringType{},
			"wxtunnel_remote_id": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"disabled": basetypes.BoolType{},
		"dynamic_vlan": basetypes.ObjectType{
			AttrTypes: DynamicVlanValue{}.AttributeTypes(ctx),
		},
		"enable_mac_auth":    basetypes.BoolType{},
		"forwarding":         basetypes.StringType{},
		"mac_auth_preferred": basetypes.BoolType{},
		"mac_auth_protocol":  basetypes.StringType{},
		"mist_nac": basetypes.ObjectType{
			AttrTypes: MistNacValue{}.AttributeTypes(ctx),
		},
		"mx_tunnel_id":  basetypes.StringType{},
		"mxtunnel_name": basetypes.StringType{},
		"port_auth":     basetypes.StringType{},
		"port_vlan_id":  basetypes.Int64Type{},
		"radius_config": basetypes.ObjectType{
			AttrTypes: RadiusConfigValue{}.AttributeTypes(ctx),
		},
		"radsec": basetypes.ObjectType{
			AttrTypes: RadsecValue{}.AttributeTypes(ctx),
		},
		"vlan_id": basetypes.Int64Type{},
		"vlan_ids": basetypes.ListType{
			ElemType: types.Int64Type,
		},
		"wxtunnel_id":        basetypes.StringType{},
		"wxtunnel_remote_id": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"disabled":           v.Disabled,
			"dynamic_vlan":       dynamicVlan,
			"enable_mac_auth":    v.EnableMacAuth,
			"forwarding":         v.Forwarding,
			"mac_auth_preferred": v.MacAuthPreferred,
			"mac_auth_protocol":  v.MacAuthProtocol,
			"mist_nac":           mistNac,
			"mx_tunnel_id":       v.MxTunnelId,
			"mxtunnel_name":      v.MxtunnelName,
			"port_auth":          v.PortAuth,
			"port_vlan_id":       v.PortVlanId,
			"radius_config":      radiusConfig,
			"radsec":             radsec,
			"vlan_id":            v.VlanId,
			"vlan_ids":           vlanIdsVal,
			"wxtunnel_id":        v.WxtunnelId,
			"wxtunnel_remote_id": v.WxtunnelRemoteId,
		})

	return objVal, diags
}

func (v PortConfigValue) Equal(o attr.Value) bool {
	other, ok := o.(PortConfigValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Disabled.Equal(other.Disabled) {
		return false
	}

	if !v.DynamicVlan.Equal(other.DynamicVlan) {
		return false
	}

	if !v.EnableMacAuth.Equal(other.EnableMacAuth) {
		return false
	}

	if !v.Forwarding.Equal(other.Forwarding) {
		return false
	}

	if !v.MacAuthPreferred.Equal(other.MacAuthPreferred) {
		return false
	}

	if !v.MacAuthProtocol.Equal(other.MacAuthProtocol) {
		return false
	}

	if !v.MistNac.Equal(other.MistNac) {
		return false
	}

	if !v.MxTunnelId.Equal(other.MxTunnelId) {
		return false
	}

	if !v.MxtunnelName.Equal(other.MxtunnelName) {
		return false
	}

	if !v.PortAuth.Equal(other.PortAuth) {
		return false
	}

	if !v.PortVlanId.Equal(other.PortVlanId) {
		return false
	}

	if !v.RadiusConfig.Equal(other.RadiusConfig) {
		return false
	}

	if !v.Radsec.Equal(other.Radsec) {
		return false
	}

	if !v.VlanId.Equal(other.VlanId) {
		return false
	}

	if !v.VlanIds.Equal(other.VlanIds) {
		return false
	}

	if !v.WxtunnelId.Equal(other.WxtunnelId) {
		return false
	}

	if !v.WxtunnelRemoteId.Equal(other.WxtunnelRemoteId) {
		return false
	}

	return true
}

func (v PortConfigValue) Type(ctx context.Context) attr.Type {
	return PortConfigType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PortConfigValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"disabled": basetypes.BoolType{},
		"dynamic_vlan": basetypes.ObjectType{
			AttrTypes: DynamicVlanValue{}.AttributeTypes(ctx),
		},
		"enable_mac_auth":    basetypes.BoolType{},
		"forwarding":         basetypes.StringType{},
		"mac_auth_preferred": basetypes.BoolType{},
		"mac_auth_protocol":  basetypes.StringType{},
		"mist_nac": basetypes.ObjectType{
			AttrTypes: MistNacValue{}.AttributeTypes(ctx),
		},
		"mx_tunnel_id":  basetypes.StringType{},
		"mxtunnel_name": basetypes.StringType{},
		"port_auth":     basetypes.StringType{},
		"port_vlan_id":  basetypes.Int64Type{},
		"radius_config": basetypes.ObjectType{
			AttrTypes: RadiusConfigValue{}.AttributeTypes(ctx),
		},
		"radsec": basetypes.ObjectType{
			AttrTypes: RadsecValue{}.AttributeTypes(ctx),
		},
		"vlan_id": basetypes.Int64Type{},
		"vlan_ids": basetypes.ListType{
			ElemType: types.Int64Type,
		},
		"wxtunnel_id":        basetypes.StringType{},
		"wxtunnel_remote_id": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = DynamicVlanType{}

type DynamicVlanType struct {
	basetypes.ObjectType
}

func (t DynamicVlanType) Equal(o attr.Type) bool {
	other, ok := o.(DynamicVlanType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t DynamicVlanType) String() string {
	return "DynamicVlanType"
}

func (t DynamicVlanType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	defaultVlanIdAttribute, ok := attributes["default_vlan_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`default_vlan_id is missing from object`)

		return nil, diags
	}

	defaultVlanIdVal, ok := defaultVlanIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`default_vlan_id expected to be basetypes.Int64Value, was: %T`, defaultVlanIdAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	vlansAttribute, ok := attributes["vlans"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlans is missing from object`)

		return nil, diags
	}

	vlansVal, ok := vlansAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlans expected to be basetypes.MapValue, was: %T`, vlansAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return DynamicVlanValue{
		DefaultVlanId:   defaultVlanIdVal,
		Enabled:         enabledVal,
		DynamicVlanType: typeVal,
		Vlans:           vlansVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewDynamicVlanValueNull() DynamicVlanValue {
	return DynamicVlanValue{
		state: attr.ValueStateNull,
	}
}

func NewDynamicVlanValueUnknown() DynamicVlanValue {
	return DynamicVlanValue{
		state: attr.ValueStateUnknown,
	}
}

func NewDynamicVlanValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (DynamicVlanValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing DynamicVlanValue Attribute Value",
				"While creating a DynamicVlanValue value, a missing attribute value was detected. "+
					"A DynamicVlanValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DynamicVlanValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid DynamicVlanValue Attribute Type",
				"While creating a DynamicVlanValue value, an invalid attribute value was detected. "+
					"A DynamicVlanValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DynamicVlanValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("DynamicVlanValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra DynamicVlanValue Attribute Value",
				"While creating a DynamicVlanValue value, an extra attribute value was detected. "+
					"A DynamicVlanValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra DynamicVlanValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewDynamicVlanValueUnknown(), diags
	}

	defaultVlanIdAttribute, ok := attributes["default_vlan_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`default_vlan_id is missing from object`)

		return NewDynamicVlanValueUnknown(), diags
	}

	defaultVlanIdVal, ok := defaultVlanIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`default_vlan_id expected to be basetypes.Int64Value, was: %T`, defaultVlanIdAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewDynamicVlanValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewDynamicVlanValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	vlansAttribute, ok := attributes["vlans"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlans is missing from object`)

		return NewDynamicVlanValueUnknown(), diags
	}

	vlansVal, ok := vlansAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlans expected to be basetypes.MapValue, was: %T`, vlansAttribute))
	}

	if diags.HasError() {
		return NewDynamicVlanValueUnknown(), diags
	}

	return DynamicVlanValue{
		DefaultVlanId:   defaultVlanIdVal,
		Enabled:         enabledVal,
		DynamicVlanType: typeVal,
		Vlans:           vlansVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewDynamicVlanValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) DynamicVlanValue {
	object, diags := NewDynamicVlanValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewDynamicVlanValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t DynamicVlanType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewDynamicVlanValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewDynamicVlanValueUnknown(), nil
	}

	if in.IsNull() {
		return NewDynamicVlanValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewDynamicVlanValueMust(DynamicVlanValue{}.AttributeTypes(ctx), attributes), nil
}

func (t DynamicVlanType) ValueType(ctx context.Context) attr.Value {
	return DynamicVlanValue{}
}

var _ basetypes.ObjectValuable = DynamicVlanValue{}

type DynamicVlanValue struct {
	DefaultVlanId   basetypes.Int64Value  `tfsdk:"default_vlan_id"`
	Enabled         basetypes.BoolValue   `tfsdk:"enabled"`
	DynamicVlanType basetypes.StringValue `tfsdk:"type"`
	Vlans           basetypes.MapValue    `tfsdk:"vlans"`
	state           attr.ValueState
}

func (v DynamicVlanValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["default_vlan_id"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["vlans"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.DefaultVlanId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["default_vlan_id"] = val

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.DynamicVlanType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		val, err = v.Vlans.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vlans"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v DynamicVlanValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v DynamicVlanValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v DynamicVlanValue) String() string {
	return "DynamicVlanValue"
}

func (v DynamicVlanValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var vlansVal basetypes.MapValue
	switch {
	case v.Vlans.IsUnknown():
		vlansVal = types.MapUnknown(types.StringType)
	case v.Vlans.IsNull():
		vlansVal = types.MapNull(types.StringType)
	default:
		var d diag.Diagnostics
		vlansVal, d = types.MapValue(types.StringType, v.Vlans.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"default_vlan_id": basetypes.Int64Type{},
			"enabled":         basetypes.BoolType{},
			"type":            basetypes.StringType{},
			"vlans": basetypes.MapType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"default_vlan_id": basetypes.Int64Type{},
		"enabled":         basetypes.BoolType{},
		"type":            basetypes.StringType{},
		"vlans": basetypes.MapType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"default_vlan_id": v.DefaultVlanId,
			"enabled":         v.Enabled,
			"type":            v.DynamicVlanType,
			"vlans":           vlansVal,
		})

	return objVal, diags
}

func (v DynamicVlanValue) Equal(o attr.Value) bool {
	other, ok := o.(DynamicVlanValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.DefaultVlanId.Equal(other.DefaultVlanId) {
		return false
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.DynamicVlanType.Equal(other.DynamicVlanType) {
		return false
	}

	if !v.Vlans.Equal(other.Vlans) {
		return false
	}

	return true
}

func (v DynamicVlanValue) Type(ctx context.Context) attr.Type {
	return DynamicVlanType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v DynamicVlanValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"default_vlan_id": basetypes.Int64Type{},
		"enabled":         basetypes.BoolType{},
		"type":            basetypes.StringType{},
		"vlans": basetypes.MapType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = MistNacType{}

type MistNacType struct {
	basetypes.ObjectType
}

func (t MistNacType) Equal(o attr.Type) bool {
	other, ok := o.(MistNacType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t MistNacType) String() string {
	return "MistNacType"
}

func (t MistNacType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return MistNacValue{
		Enabled: enabledVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewMistNacValueNull() MistNacValue {
	return MistNacValue{
		state: attr.ValueStateNull,
	}
}

func NewMistNacValueUnknown() MistNacValue {
	return MistNacValue{
		state: attr.ValueStateUnknown,
	}
}

func NewMistNacValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (MistNacValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing MistNacValue Attribute Value",
				"While creating a MistNacValue value, a missing attribute value was detected. "+
					"A MistNacValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MistNacValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid MistNacValue Attribute Type",
				"While creating a MistNacValue value, an invalid attribute value was detected. "+
					"A MistNacValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MistNacValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("MistNacValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra MistNacValue Attribute Value",
				"While creating a MistNacValue value, an extra attribute value was detected. "+
					"A MistNacValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra MistNacValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewMistNacValueUnknown(), diags
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewMistNacValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	if diags.HasError() {
		return NewMistNacValueUnknown(), diags
	}

	return MistNacValue{
		Enabled: enabledVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewMistNacValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) MistNacValue {
	object, diags := NewMistNacValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewMistNacValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t MistNacType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewMistNacValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewMistNacValueUnknown(), nil
	}

	if in.IsNull() {
		return NewMistNacValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewMistNacValueMust(MistNacValue{}.AttributeTypes(ctx), attributes), nil
}

func (t MistNacType) ValueType(ctx context.Context) attr.Value {
	return MistNacValue{}
}

var _ basetypes.ObjectValuable = MistNacValue{}

type MistNacValue struct {
	Enabled basetypes.BoolValue `tfsdk:"enabled"`
	state   attr.ValueState
}

func (v MistNacValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v MistNacValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v MistNacValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v MistNacValue) String() string {
	return "MistNacValue"
}

func (v MistNacValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"enabled": basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"enabled": v.Enabled,
		})

	return objVal, diags
}

func (v MistNacValue) Equal(o attr.Value) bool {
	other, ok := o.(MistNacValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	return true
}

func (v MistNacValue) Type(ctx context.Context) attr.Type {
	return MistNacType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v MistNacValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"enabled": basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = RadiusConfigType{}

type RadiusConfigType struct {
	basetypes.ObjectType
}

func (t RadiusConfigType) Equal(o attr.Type) bool {
	other, ok := o.(RadiusConfigType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t RadiusConfigType) String() string {
	return "RadiusConfigType"
}

func (t RadiusConfigType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	acctInterimIntervalAttribute, ok := attributes["acct_interim_interval"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`acct_interim_interval is missing from object`)

		return nil, diags
	}

	acctInterimIntervalVal, ok := acctInterimIntervalAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`acct_interim_interval expected to be basetypes.Int64Value, was: %T`, acctInterimIntervalAttribute))
	}

	acctServersAttribute, ok := attributes["acct_servers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`acct_servers is missing from object`)

		return nil, diags
	}

	acctServersVal, ok := acctServersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`acct_servers expected to be basetypes.ListValue, was: %T`, acctServersAttribute))
	}

	authServersAttribute, ok := attributes["auth_servers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auth_servers is missing from object`)

		return nil, diags
	}

	authServersVal, ok := authServersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auth_servers expected to be basetypes.ListValue, was: %T`, authServersAttribute))
	}

	authServersRetriesAttribute, ok := attributes["auth_servers_retries"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auth_servers_retries is missing from object`)

		return nil, diags
	}

	authServersRetriesVal, ok := authServersRetriesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auth_servers_retries expected to be basetypes.Int64Value, was: %T`, authServersRetriesAttribute))
	}

	authServersTimeoutAttribute, ok := attributes["auth_servers_timeout"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auth_servers_timeout is missing from object`)

		return nil, diags
	}

	authServersTimeoutVal, ok := authServersTimeoutAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auth_servers_timeout expected to be basetypes.Int64Value, was: %T`, authServersTimeoutAttribute))
	}

	coaEnabledAttribute, ok := attributes["coa_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`coa_enabled is missing from object`)

		return nil, diags
	}

	coaEnabledVal, ok := coaEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`coa_enabled expected to be basetypes.BoolValue, was: %T`, coaEnabledAttribute))
	}

	coaPortAttribute, ok := attributes["coa_port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`coa_port is missing from object`)

		return nil, diags
	}

	coaPortVal, ok := coaPortAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`coa_port expected to be basetypes.Int64Value, was: %T`, coaPortAttribute))
	}

	networkAttribute, ok := attributes["network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`network is missing from object`)

		return nil, diags
	}

	networkVal, ok := networkAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`network expected to be basetypes.StringValue, was: %T`, networkAttribute))
	}

	sourceIpAttribute, ok := attributes["source_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`source_ip is missing from object`)

		return nil, diags
	}

	sourceIpVal, ok := sourceIpAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`source_ip expected to be basetypes.StringValue, was: %T`, sourceIpAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return RadiusConfigValue{
		AcctInterimInterval: acctInterimIntervalVal,
		AcctServers:         acctServersVal,
		AuthServers:         authServersVal,
		AuthServersRetries:  authServersRetriesVal,
		AuthServersTimeout:  authServersTimeoutVal,
		CoaEnabled:          coaEnabledVal,
		CoaPort:             coaPortVal,
		Network:             networkVal,
		SourceIp:            sourceIpVal,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewRadiusConfigValueNull() RadiusConfigValue {
	return RadiusConfigValue{
		state: attr.ValueStateNull,
	}
}

func NewRadiusConfigValueUnknown() RadiusConfigValue {
	return RadiusConfigValue{
		state: attr.ValueStateUnknown,
	}
}

func NewRadiusConfigValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (RadiusConfigValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing RadiusConfigValue Attribute Value",
				"While creating a RadiusConfigValue value, a missing attribute value was detected. "+
					"A RadiusConfigValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RadiusConfigValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid RadiusConfigValue Attribute Type",
				"While creating a RadiusConfigValue value, an invalid attribute value was detected. "+
					"A RadiusConfigValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RadiusConfigValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("RadiusConfigValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra RadiusConfigValue Attribute Value",
				"While creating a RadiusConfigValue value, an extra attribute value was detected. "+
					"A RadiusConfigValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra RadiusConfigValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewRadiusConfigValueUnknown(), diags
	}

	acctInterimIntervalAttribute, ok := attributes["acct_interim_interval"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`acct_interim_interval is missing from object`)

		return NewRadiusConfigValueUnknown(), diags
	}

	acctInterimIntervalVal, ok := acctInterimIntervalAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`acct_interim_interval expected to be basetypes.Int64Value, was: %T`, acctInterimIntervalAttribute))
	}

	acctServersAttribute, ok := attributes["acct_servers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`acct_servers is missing from object`)

		return NewRadiusConfigValueUnknown(), diags
	}

	acctServersVal, ok := acctServersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`acct_servers expected to be basetypes.ListValue, was: %T`, acctServersAttribute))
	}

	authServersAttribute, ok := attributes["auth_servers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auth_servers is missing from object`)

		return NewRadiusConfigValueUnknown(), diags
	}

	authServersVal, ok := authServersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auth_servers expected to be basetypes.ListValue, was: %T`, authServersAttribute))
	}

	authServersRetriesAttribute, ok := attributes["auth_servers_retries"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auth_servers_retries is missing from object`)

		return NewRadiusConfigValueUnknown(), diags
	}

	authServersRetriesVal, ok := authServersRetriesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auth_servers_retries expected to be basetypes.Int64Value, was: %T`, authServersRetriesAttribute))
	}

	authServersTimeoutAttribute, ok := attributes["auth_servers_timeout"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auth_servers_timeout is missing from object`)

		return NewRadiusConfigValueUnknown(), diags
	}

	authServersTimeoutVal, ok := authServersTimeoutAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auth_servers_timeout expected to be basetypes.Int64Value, was: %T`, authServersTimeoutAttribute))
	}

	coaEnabledAttribute, ok := attributes["coa_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`coa_enabled is missing from object`)

		return NewRadiusConfigValueUnknown(), diags
	}

	coaEnabledVal, ok := coaEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`coa_enabled expected to be basetypes.BoolValue, was: %T`, coaEnabledAttribute))
	}

	coaPortAttribute, ok := attributes["coa_port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`coa_port is missing from object`)

		return NewRadiusConfigValueUnknown(), diags
	}

	coaPortVal, ok := coaPortAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`coa_port expected to be basetypes.Int64Value, was: %T`, coaPortAttribute))
	}

	networkAttribute, ok := attributes["network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`network is missing from object`)

		return NewRadiusConfigValueUnknown(), diags
	}

	networkVal, ok := networkAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`network expected to be basetypes.StringValue, was: %T`, networkAttribute))
	}

	sourceIpAttribute, ok := attributes["source_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`source_ip is missing from object`)

		return NewRadiusConfigValueUnknown(), diags
	}

	sourceIpVal, ok := sourceIpAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`source_ip expected to be basetypes.StringValue, was: %T`, sourceIpAttribute))
	}

	if diags.HasError() {
		return NewRadiusConfigValueUnknown(), diags
	}

	return RadiusConfigValue{
		AcctInterimInterval: acctInterimIntervalVal,
		AcctServers:         acctServersVal,
		AuthServers:         authServersVal,
		AuthServersRetries:  authServersRetriesVal,
		AuthServersTimeout:  authServersTimeoutVal,
		CoaEnabled:          coaEnabledVal,
		CoaPort:             coaPortVal,
		Network:             networkVal,
		SourceIp:            sourceIpVal,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewRadiusConfigValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) RadiusConfigValue {
	object, diags := NewRadiusConfigValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewRadiusConfigValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t RadiusConfigType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewRadiusConfigValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewRadiusConfigValueUnknown(), nil
	}

	if in.IsNull() {
		return NewRadiusConfigValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewRadiusConfigValueMust(RadiusConfigValue{}.AttributeTypes(ctx), attributes), nil
}

func (t RadiusConfigType) ValueType(ctx context.Context) attr.Value {
	return RadiusConfigValue{}
}

var _ basetypes.ObjectValuable = RadiusConfigValue{}

type RadiusConfigValue struct {
	AcctInterimInterval basetypes.Int64Value  `tfsdk:"acct_interim_interval"`
	AcctServers         basetypes.ListValue   `tfsdk:"acct_servers"`
	AuthServers         basetypes.ListValue   `tfsdk:"auth_servers"`
	AuthServersRetries  basetypes.Int64Value  `tfsdk:"auth_servers_retries"`
	AuthServersTimeout  basetypes.Int64Value  `tfsdk:"auth_servers_timeout"`
	CoaEnabled          basetypes.BoolValue   `tfsdk:"coa_enabled"`
	CoaPort             basetypes.Int64Value  `tfsdk:"coa_port"`
	Network             basetypes.StringValue `tfsdk:"network"`
	SourceIp            basetypes.StringValue `tfsdk:"source_ip"`
	state               attr.ValueState
}

func (v RadiusConfigValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 9)

	var val tftypes.Value
	var err error

	attrTypes["acct_interim_interval"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["acct_servers"] = basetypes.ListType{
		ElemType: AcctServersValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["auth_servers"] = basetypes.ListType{
		ElemType: AuthServersValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["auth_servers_retries"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["auth_servers_timeout"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["coa_enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["coa_port"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["network"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["source_ip"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 9)

		val, err = v.AcctInterimInterval.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["acct_interim_interval"] = val

		val, err = v.AcctServers.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["acct_servers"] = val

		val, err = v.AuthServers.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["auth_servers"] = val

		val, err = v.AuthServersRetries.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["auth_servers_retries"] = val

		val, err = v.AuthServersTimeout.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["auth_servers_timeout"] = val

		val, err = v.CoaEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["coa_enabled"] = val

		val, err = v.CoaPort.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["coa_port"] = val

		val, err = v.Network.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["network"] = val

		val, err = v.SourceIp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["source_ip"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v RadiusConfigValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v RadiusConfigValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v RadiusConfigValue) String() string {
	return "RadiusConfigValue"
}

func (v RadiusConfigValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	acctServers := types.ListValueMust(
		AcctServersType{
			basetypes.ObjectType{
				AttrTypes: AcctServersValue{}.AttributeTypes(ctx),
			},
		},
		v.AcctServers.Elements(),
	)

	if v.AcctServers.IsNull() {
		acctServers = types.ListNull(
			AcctServersType{
				basetypes.ObjectType{
					AttrTypes: AcctServersValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.AcctServers.IsUnknown() {
		acctServers = types.ListUnknown(
			AcctServersType{
				basetypes.ObjectType{
					AttrTypes: AcctServersValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	authServers := types.ListValueMust(
		AuthServersType{
			basetypes.ObjectType{
				AttrTypes: AuthServersValue{}.AttributeTypes(ctx),
			},
		},
		v.AuthServers.Elements(),
	)

	if v.AuthServers.IsNull() {
		authServers = types.ListNull(
			AuthServersType{
				basetypes.ObjectType{
					AttrTypes: AuthServersValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.AuthServers.IsUnknown() {
		authServers = types.ListUnknown(
			AuthServersType{
				basetypes.ObjectType{
					AttrTypes: AuthServersValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"acct_interim_interval": basetypes.Int64Type{},
		"acct_servers": basetypes.ListType{
			ElemType: AcctServersValue{}.Type(ctx),
		},
		"auth_servers": basetypes.ListType{
			ElemType: AuthServersValue{}.Type(ctx),
		},
		"auth_servers_retries": basetypes.Int64Type{},
		"auth_servers_timeout": basetypes.Int64Type{},
		"coa_enabled":          basetypes.BoolType{},
		"coa_port":             basetypes.Int64Type{},
		"network":              basetypes.StringType{},
		"source_ip":            basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"acct_interim_interval": v.AcctInterimInterval,
			"acct_servers":          acctServers,
			"auth_servers":          authServers,
			"auth_servers_retries":  v.AuthServersRetries,
			"auth_servers_timeout":  v.AuthServersTimeout,
			"coa_enabled":           v.CoaEnabled,
			"coa_port":              v.CoaPort,
			"network":               v.Network,
			"source_ip":             v.SourceIp,
		})

	return objVal, diags
}

func (v RadiusConfigValue) Equal(o attr.Value) bool {
	other, ok := o.(RadiusConfigValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AcctInterimInterval.Equal(other.AcctInterimInterval) {
		return false
	}

	if !v.AcctServers.Equal(other.AcctServers) {
		return false
	}

	if !v.AuthServers.Equal(other.AuthServers) {
		return false
	}

	if !v.AuthServersRetries.Equal(other.AuthServersRetries) {
		return false
	}

	if !v.AuthServersTimeout.Equal(other.AuthServersTimeout) {
		return false
	}

	if !v.CoaEnabled.Equal(other.CoaEnabled) {
		return false
	}

	if !v.CoaPort.Equal(other.CoaPort) {
		return false
	}

	if !v.Network.Equal(other.Network) {
		return false
	}

	if !v.SourceIp.Equal(other.SourceIp) {
		return false
	}

	return true
}

func (v RadiusConfigValue) Type(ctx context.Context) attr.Type {
	return RadiusConfigType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v RadiusConfigValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"acct_interim_interval": basetypes.Int64Type{},
		"acct_servers": basetypes.ListType{
			ElemType: AcctServersValue{}.Type(ctx),
		},
		"auth_servers": basetypes.ListType{
			ElemType: AuthServersValue{}.Type(ctx),
		},
		"auth_servers_retries": basetypes.Int64Type{},
		"auth_servers_timeout": basetypes.Int64Type{},
		"coa_enabled":          basetypes.BoolType{},
		"coa_port":             basetypes.Int64Type{},
		"network":              basetypes.StringType{},
		"source_ip":            basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = AcctServersType{}

type AcctServersType struct {
	basetypes.ObjectType
}

func (t AcctServersType) Equal(o attr.Type) bool {
	other, ok := o.(AcctServersType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AcctServersType) String() string {
	return "AcctServersType"
}

func (t AcctServersType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	hostAttribute, ok := attributes["host"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`host is missing from object`)

		return nil, diags
	}

	hostVal, ok := hostAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`host expected to be basetypes.StringValue, was: %T`, hostAttribute))
	}

	keywrapEnabledAttribute, ok := attributes["keywrap_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywrap_enabled is missing from object`)

		return nil, diags
	}

	keywrapEnabledVal, ok := keywrapEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywrap_enabled expected to be basetypes.BoolValue, was: %T`, keywrapEnabledAttribute))
	}

	keywrapFormatAttribute, ok := attributes["keywrap_format"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywrap_format is missing from object`)

		return nil, diags
	}

	keywrapFormatVal, ok := keywrapFormatAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywrap_format expected to be basetypes.StringValue, was: %T`, keywrapFormatAttribute))
	}

	keywrapKekAttribute, ok := attributes["keywrap_kek"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywrap_kek is missing from object`)

		return nil, diags
	}

	keywrapKekVal, ok := keywrapKekAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywrap_kek expected to be basetypes.StringValue, was: %T`, keywrapKekAttribute))
	}

	keywrapMackAttribute, ok := attributes["keywrap_mack"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywrap_mack is missing from object`)

		return nil, diags
	}

	keywrapMackVal, ok := keywrapMackAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywrap_mack expected to be basetypes.StringValue, was: %T`, keywrapMackAttribute))
	}

	portAttribute, ok := attributes["port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port is missing from object`)

		return nil, diags
	}

	portVal, ok := portAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port expected to be basetypes.StringValue, was: %T`, portAttribute))
	}

	secretAttribute, ok := attributes["secret"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`secret is missing from object`)

		return nil, diags
	}

	secretVal, ok := secretAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`secret expected to be basetypes.StringValue, was: %T`, secretAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AcctServersValue{
		Host:           hostVal,
		KeywrapEnabled: keywrapEnabledVal,
		KeywrapFormat:  keywrapFormatVal,
		KeywrapKek:     keywrapKekVal,
		KeywrapMack:    keywrapMackVal,
		Port:           portVal,
		Secret:         secretVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewAcctServersValueNull() AcctServersValue {
	return AcctServersValue{
		state: attr.ValueStateNull,
	}
}

func NewAcctServersValueUnknown() AcctServersValue {
	return AcctServersValue{
		state: attr.ValueStateUnknown,
	}
}

func NewAcctServersValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AcctServersValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AcctServersValue Attribute Value",
				"While creating a AcctServersValue value, a missing attribute value was detected. "+
					"A AcctServersValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AcctServersValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AcctServersValue Attribute Type",
				"While creating a AcctServersValue value, an invalid attribute value was detected. "+
					"A AcctServersValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AcctServersValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AcctServersValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AcctServersValue Attribute Value",
				"While creating a AcctServersValue value, an extra attribute value was detected. "+
					"A AcctServersValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AcctServersValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAcctServersValueUnknown(), diags
	}

	hostAttribute, ok := attributes["host"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`host is missing from object`)

		return NewAcctServersValueUnknown(), diags
	}

	hostVal, ok := hostAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`host expected to be basetypes.StringValue, was: %T`, hostAttribute))
	}

	keywrapEnabledAttribute, ok := attributes["keywrap_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywrap_enabled is missing from object`)

		return NewAcctServersValueUnknown(), diags
	}

	keywrapEnabledVal, ok := keywrapEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywrap_enabled expected to be basetypes.BoolValue, was: %T`, keywrapEnabledAttribute))
	}

	keywrapFormatAttribute, ok := attributes["keywrap_format"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywrap_format is missing from object`)

		return NewAcctServersValueUnknown(), diags
	}

	keywrapFormatVal, ok := keywrapFormatAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywrap_format expected to be basetypes.StringValue, was: %T`, keywrapFormatAttribute))
	}

	keywrapKekAttribute, ok := attributes["keywrap_kek"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywrap_kek is missing from object`)

		return NewAcctServersValueUnknown(), diags
	}

	keywrapKekVal, ok := keywrapKekAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywrap_kek expected to be basetypes.StringValue, was: %T`, keywrapKekAttribute))
	}

	keywrapMackAttribute, ok := attributes["keywrap_mack"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywrap_mack is missing from object`)

		return NewAcctServersValueUnknown(), diags
	}

	keywrapMackVal, ok := keywrapMackAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywrap_mack expected to be basetypes.StringValue, was: %T`, keywrapMackAttribute))
	}

	portAttribute, ok := attributes["port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port is missing from object`)

		return NewAcctServersValueUnknown(), diags
	}

	portVal, ok := portAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port expected to be basetypes.StringValue, was: %T`, portAttribute))
	}

	secretAttribute, ok := attributes["secret"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`secret is missing from object`)

		return NewAcctServersValueUnknown(), diags
	}

	secretVal, ok := secretAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`secret expected to be basetypes.StringValue, was: %T`, secretAttribute))
	}

	if diags.HasError() {
		return NewAcctServersValueUnknown(), diags
	}

	return AcctServersValue{
		Host:           hostVal,
		KeywrapEnabled: keywrapEnabledVal,
		KeywrapFormat:  keywrapFormatVal,
		KeywrapKek:     keywrapKekVal,
		KeywrapMack:    keywrapMackVal,
		Port:           portVal,
		Secret:         secretVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewAcctServersValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AcctServersValue {
	object, diags := NewAcctServersValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAcctServersValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AcctServersType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAcctServersValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAcctServersValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAcctServersValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAcctServersValueMust(AcctServersValue{}.AttributeTypes(ctx), attributes), nil
}

func (t AcctServersType) ValueType(ctx context.Context) attr.Value {
	return AcctServersValue{}
}

var _ basetypes.ObjectValuable = AcctServersValue{}

type AcctServersValue struct {
	Host           basetypes.StringValue `tfsdk:"host"`
	KeywrapEnabled basetypes.BoolValue   `tfsdk:"keywrap_enabled"`
	KeywrapFormat  basetypes.StringValue `tfsdk:"keywrap_format"`
	KeywrapKek     basetypes.StringValue `tfsdk:"keywrap_kek"`
	KeywrapMack    basetypes.StringValue `tfsdk:"keywrap_mack"`
	Port           basetypes.StringValue `tfsdk:"port"`
	Secret         basetypes.StringValue `tfsdk:"secret"`
	state          attr.ValueState
}

func (v AcctServersValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 7)

	var val tftypes.Value
	var err error

	attrTypes["host"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["keywrap_enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["keywrap_format"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["keywrap_kek"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["keywrap_mack"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["port"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["secret"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 7)

		val, err = v.Host.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["host"] = val

		val, err = v.KeywrapEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["keywrap_enabled"] = val

		val, err = v.KeywrapFormat.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["keywrap_format"] = val

		val, err = v.KeywrapKek.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["keywrap_kek"] = val

		val, err = v.KeywrapMack.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["keywrap_mack"] = val

		val, err = v.Port.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port"] = val

		val, err = v.Secret.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["secret"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AcctServersValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AcctServersValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AcctServersValue) String() string {
	return "AcctServersValue"
}

func (v AcctServersValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"host":            basetypes.StringType{},
		"keywrap_enabled": basetypes.BoolType{},
		"keywrap_format":  basetypes.StringType{},
		"keywrap_kek":     basetypes.StringType{},
		"keywrap_mack":    basetypes.StringType{},
		"port":            basetypes.StringType{},
		"secret":          basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"host":            v.Host,
			"keywrap_enabled": v.KeywrapEnabled,
			"keywrap_format":  v.KeywrapFormat,
			"keywrap_kek":     v.KeywrapKek,
			"keywrap_mack":    v.KeywrapMack,
			"port":            v.Port,
			"secret":          v.Secret,
		})

	return objVal, diags
}

func (v AcctServersValue) Equal(o attr.Value) bool {
	other, ok := o.(AcctServersValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Host.Equal(other.Host) {
		return false
	}

	if !v.KeywrapEnabled.Equal(other.KeywrapEnabled) {
		return false
	}

	if !v.KeywrapFormat.Equal(other.KeywrapFormat) {
		return false
	}

	if !v.KeywrapKek.Equal(other.KeywrapKek) {
		return false
	}

	if !v.KeywrapMack.Equal(other.KeywrapMack) {
		return false
	}

	if !v.Port.Equal(other.Port) {
		return false
	}

	if !v.Secret.Equal(other.Secret) {
		return false
	}

	return true
}

func (v AcctServersValue) Type(ctx context.Context) attr.Type {
	return AcctServersType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AcctServersValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"host":            basetypes.StringType{},
		"keywrap_enabled": basetypes.BoolType{},
		"keywrap_format":  basetypes.StringType{},
		"keywrap_kek":     basetypes.StringType{},
		"keywrap_mack":    basetypes.StringType{},
		"port":            basetypes.StringType{},
		"secret":          basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = AuthServersType{}

type AuthServersType struct {
	basetypes.ObjectType
}

func (t AuthServersType) Equal(o attr.Type) bool {
	other, ok := o.(AuthServersType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AuthServersType) String() string {
	return "AuthServersType"
}

func (t AuthServersType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	hostAttribute, ok := attributes["host"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`host is missing from object`)

		return nil, diags
	}

	hostVal, ok := hostAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`host expected to be basetypes.StringValue, was: %T`, hostAttribute))
	}

	keywrapEnabledAttribute, ok := attributes["keywrap_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywrap_enabled is missing from object`)

		return nil, diags
	}

	keywrapEnabledVal, ok := keywrapEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywrap_enabled expected to be basetypes.BoolValue, was: %T`, keywrapEnabledAttribute))
	}

	keywrapFormatAttribute, ok := attributes["keywrap_format"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywrap_format is missing from object`)

		return nil, diags
	}

	keywrapFormatVal, ok := keywrapFormatAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywrap_format expected to be basetypes.StringValue, was: %T`, keywrapFormatAttribute))
	}

	keywrapKekAttribute, ok := attributes["keywrap_kek"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywrap_kek is missing from object`)

		return nil, diags
	}

	keywrapKekVal, ok := keywrapKekAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywrap_kek expected to be basetypes.StringValue, was: %T`, keywrapKekAttribute))
	}

	keywrapMackAttribute, ok := attributes["keywrap_mack"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywrap_mack is missing from object`)

		return nil, diags
	}

	keywrapMackVal, ok := keywrapMackAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywrap_mack expected to be basetypes.StringValue, was: %T`, keywrapMackAttribute))
	}

	portAttribute, ok := attributes["port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port is missing from object`)

		return nil, diags
	}

	portVal, ok := portAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port expected to be basetypes.StringValue, was: %T`, portAttribute))
	}

	requireMessageAuthenticatorAttribute, ok := attributes["require_message_authenticator"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`require_message_authenticator is missing from object`)

		return nil, diags
	}

	requireMessageAuthenticatorVal, ok := requireMessageAuthenticatorAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`require_message_authenticator expected to be basetypes.BoolValue, was: %T`, requireMessageAuthenticatorAttribute))
	}

	secretAttribute, ok := attributes["secret"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`secret is missing from object`)

		return nil, diags
	}

	secretVal, ok := secretAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`secret expected to be basetypes.StringValue, was: %T`, secretAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AuthServersValue{
		Host:                        hostVal,
		KeywrapEnabled:              keywrapEnabledVal,
		KeywrapFormat:               keywrapFormatVal,
		KeywrapKek:                  keywrapKekVal,
		KeywrapMack:                 keywrapMackVal,
		Port:                        portVal,
		RequireMessageAuthenticator: requireMessageAuthenticatorVal,
		Secret:                      secretVal,
		state:                       attr.ValueStateKnown,
	}, diags
}

func NewAuthServersValueNull() AuthServersValue {
	return AuthServersValue{
		state: attr.ValueStateNull,
	}
}

func NewAuthServersValueUnknown() AuthServersValue {
	return AuthServersValue{
		state: attr.ValueStateUnknown,
	}
}

func NewAuthServersValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AuthServersValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AuthServersValue Attribute Value",
				"While creating a AuthServersValue value, a missing attribute value was detected. "+
					"A AuthServersValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AuthServersValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AuthServersValue Attribute Type",
				"While creating a AuthServersValue value, an invalid attribute value was detected. "+
					"A AuthServersValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AuthServersValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AuthServersValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AuthServersValue Attribute Value",
				"While creating a AuthServersValue value, an extra attribute value was detected. "+
					"A AuthServersValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AuthServersValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAuthServersValueUnknown(), diags
	}

	hostAttribute, ok := attributes["host"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`host is missing from object`)

		return NewAuthServersValueUnknown(), diags
	}

	hostVal, ok := hostAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`host expected to be basetypes.StringValue, was: %T`, hostAttribute))
	}

	keywrapEnabledAttribute, ok := attributes["keywrap_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywrap_enabled is missing from object`)

		return NewAuthServersValueUnknown(), diags
	}

	keywrapEnabledVal, ok := keywrapEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywrap_enabled expected to be basetypes.BoolValue, was: %T`, keywrapEnabledAttribute))
	}

	keywrapFormatAttribute, ok := attributes["keywrap_format"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywrap_format is missing from object`)

		return NewAuthServersValueUnknown(), diags
	}

	keywrapFormatVal, ok := keywrapFormatAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywrap_format expected to be basetypes.StringValue, was: %T`, keywrapFormatAttribute))
	}

	keywrapKekAttribute, ok := attributes["keywrap_kek"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywrap_kek is missing from object`)

		return NewAuthServersValueUnknown(), diags
	}

	keywrapKekVal, ok := keywrapKekAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywrap_kek expected to be basetypes.StringValue, was: %T`, keywrapKekAttribute))
	}

	keywrapMackAttribute, ok := attributes["keywrap_mack"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywrap_mack is missing from object`)

		return NewAuthServersValueUnknown(), diags
	}

	keywrapMackVal, ok := keywrapMackAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywrap_mack expected to be basetypes.StringValue, was: %T`, keywrapMackAttribute))
	}

	portAttribute, ok := attributes["port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port is missing from object`)

		return NewAuthServersValueUnknown(), diags
	}

	portVal, ok := portAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port expected to be basetypes.StringValue, was: %T`, portAttribute))
	}

	requireMessageAuthenticatorAttribute, ok := attributes["require_message_authenticator"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`require_message_authenticator is missing from object`)

		return NewAuthServersValueUnknown(), diags
	}

	requireMessageAuthenticatorVal, ok := requireMessageAuthenticatorAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`require_message_authenticator expected to be basetypes.BoolValue, was: %T`, requireMessageAuthenticatorAttribute))
	}

	secretAttribute, ok := attributes["secret"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`secret is missing from object`)

		return NewAuthServersValueUnknown(), diags
	}

	secretVal, ok := secretAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`secret expected to be basetypes.StringValue, was: %T`, secretAttribute))
	}

	if diags.HasError() {
		return NewAuthServersValueUnknown(), diags
	}

	return AuthServersValue{
		Host:                        hostVal,
		KeywrapEnabled:              keywrapEnabledVal,
		KeywrapFormat:               keywrapFormatVal,
		KeywrapKek:                  keywrapKekVal,
		KeywrapMack:                 keywrapMackVal,
		Port:                        portVal,
		RequireMessageAuthenticator: requireMessageAuthenticatorVal,
		Secret:                      secretVal,
		state:                       attr.ValueStateKnown,
	}, diags
}

func NewAuthServersValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AuthServersValue {
	object, diags := NewAuthServersValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAuthServersValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AuthServersType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAuthServersValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAuthServersValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAuthServersValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAuthServersValueMust(AuthServersValue{}.AttributeTypes(ctx), attributes), nil
}

func (t AuthServersType) ValueType(ctx context.Context) attr.Value {
	return AuthServersValue{}
}

var _ basetypes.ObjectValuable = AuthServersValue{}

type AuthServersValue struct {
	Host                        basetypes.StringValue `tfsdk:"host"`
	KeywrapEnabled              basetypes.BoolValue   `tfsdk:"keywrap_enabled"`
	KeywrapFormat               basetypes.StringValue `tfsdk:"keywrap_format"`
	KeywrapKek                  basetypes.StringValue `tfsdk:"keywrap_kek"`
	KeywrapMack                 basetypes.StringValue `tfsdk:"keywrap_mack"`
	Port                        basetypes.StringValue `tfsdk:"port"`
	RequireMessageAuthenticator basetypes.BoolValue   `tfsdk:"require_message_authenticator"`
	Secret                      basetypes.StringValue `tfsdk:"secret"`
	state                       attr.ValueState
}

func (v AuthServersValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 8)

	var val tftypes.Value
	var err error

	attrTypes["host"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["keywrap_enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["keywrap_format"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["keywrap_kek"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["keywrap_mack"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["port"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["require_message_authenticator"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["secret"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 8)

		val, err = v.Host.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["host"] = val

		val, err = v.KeywrapEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["keywrap_enabled"] = val

		val, err = v.KeywrapFormat.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["keywrap_format"] = val

		val, err = v.KeywrapKek.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["keywrap_kek"] = val

		val, err = v.KeywrapMack.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["keywrap_mack"] = val

		val, err = v.Port.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port"] = val

		val, err = v.RequireMessageAuthenticator.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["require_message_authenticator"] = val

		val, err = v.Secret.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["secret"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AuthServersValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AuthServersValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AuthServersValue) String() string {
	return "AuthServersValue"
}

func (v AuthServersValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"host":                          basetypes.StringType{},
		"keywrap_enabled":               basetypes.BoolType{},
		"keywrap_format":                basetypes.StringType{},
		"keywrap_kek":                   basetypes.StringType{},
		"keywrap_mack":                  basetypes.StringType{},
		"port":                          basetypes.StringType{},
		"require_message_authenticator": basetypes.BoolType{},
		"secret":                        basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"host":                          v.Host,
			"keywrap_enabled":               v.KeywrapEnabled,
			"keywrap_format":                v.KeywrapFormat,
			"keywrap_kek":                   v.KeywrapKek,
			"keywrap_mack":                  v.KeywrapMack,
			"port":                          v.Port,
			"require_message_authenticator": v.RequireMessageAuthenticator,
			"secret":                        v.Secret,
		})

	return objVal, diags
}

func (v AuthServersValue) Equal(o attr.Value) bool {
	other, ok := o.(AuthServersValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Host.Equal(other.Host) {
		return false
	}

	if !v.KeywrapEnabled.Equal(other.KeywrapEnabled) {
		return false
	}

	if !v.KeywrapFormat.Equal(other.KeywrapFormat) {
		return false
	}

	if !v.KeywrapKek.Equal(other.KeywrapKek) {
		return false
	}

	if !v.KeywrapMack.Equal(other.KeywrapMack) {
		return false
	}

	if !v.Port.Equal(other.Port) {
		return false
	}

	if !v.RequireMessageAuthenticator.Equal(other.RequireMessageAuthenticator) {
		return false
	}

	if !v.Secret.Equal(other.Secret) {
		return false
	}

	return true
}

func (v AuthServersValue) Type(ctx context.Context) attr.Type {
	return AuthServersType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AuthServersValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"host":                          basetypes.StringType{},
		"keywrap_enabled":               basetypes.BoolType{},
		"keywrap_format":                basetypes.StringType{},
		"keywrap_kek":                   basetypes.StringType{},
		"keywrap_mack":                  basetypes.StringType{},
		"port":                          basetypes.StringType{},
		"require_message_authenticator": basetypes.BoolType{},
		"secret":                        basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = RadsecType{}

type RadsecType struct {
	basetypes.ObjectType
}

func (t RadsecType) Equal(o attr.Type) bool {
	other, ok := o.(RadsecType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t RadsecType) String() string {
	return "RadsecType"
}

func (t RadsecType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	coaEnabledAttribute, ok := attributes["coa_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`coa_enabled is missing from object`)

		return nil, diags
	}

	coaEnabledVal, ok := coaEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`coa_enabled expected to be basetypes.BoolValue, was: %T`, coaEnabledAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	idleTimeoutAttribute, ok := attributes["idle_timeout"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`idle_timeout is missing from object`)

		return nil, diags
	}

	idleTimeoutVal, ok := idleTimeoutAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`idle_timeout expected to be basetypes.StringValue, was: %T`, idleTimeoutAttribute))
	}

	mxclusterIdsAttribute, ok := attributes["mxcluster_ids"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mxcluster_ids is missing from object`)

		return nil, diags
	}

	mxclusterIdsVal, ok := mxclusterIdsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mxcluster_ids expected to be basetypes.ListValue, was: %T`, mxclusterIdsAttribute))
	}

	proxyHostsAttribute, ok := attributes["proxy_hosts"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`proxy_hosts is missing from object`)

		return nil, diags
	}

	proxyHostsVal, ok := proxyHostsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`proxy_hosts expected to be basetypes.ListValue, was: %T`, proxyHostsAttribute))
	}

	serverNameAttribute, ok := attributes["server_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`server_name is missing from object`)

		return nil, diags
	}

	serverNameVal, ok := serverNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`server_name expected to be basetypes.StringValue, was: %T`, serverNameAttribute))
	}

	serversAttribute, ok := attributes["servers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`servers is missing from object`)

		return nil, diags
	}

	serversVal, ok := serversAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`servers expected to be basetypes.ListValue, was: %T`, serversAttribute))
	}

	useMxedgeAttribute, ok := attributes["use_mxedge"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`use_mxedge is missing from object`)

		return nil, diags
	}

	useMxedgeVal, ok := useMxedgeAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`use_mxedge expected to be basetypes.BoolValue, was: %T`, useMxedgeAttribute))
	}

	useSiteMxedgeAttribute, ok := attributes["use_site_mxedge"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`use_site_mxedge is missing from object`)

		return nil, diags
	}

	useSiteMxedgeVal, ok := useSiteMxedgeAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`use_site_mxedge expected to be basetypes.BoolValue, was: %T`, useSiteMxedgeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return RadsecValue{
		CoaEnabled:    coaEnabledVal,
		Enabled:       enabledVal,
		IdleTimeout:   idleTimeoutVal,
		MxclusterIds:  mxclusterIdsVal,
		ProxyHosts:    proxyHostsVal,
		ServerName:    serverNameVal,
		Servers:       serversVal,
		UseMxedge:     useMxedgeVal,
		UseSiteMxedge: useSiteMxedgeVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewRadsecValueNull() RadsecValue {
	return RadsecValue{
		state: attr.ValueStateNull,
	}
}

func NewRadsecValueUnknown() RadsecValue {
	return RadsecValue{
		state: attr.ValueStateUnknown,
	}
}

func NewRadsecValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (RadsecValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing RadsecValue Attribute Value",
				"While creating a RadsecValue value, a missing attribute value was detected. "+
					"A RadsecValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RadsecValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid RadsecValue Attribute Type",
				"While creating a RadsecValue value, an invalid attribute value was detected. "+
					"A RadsecValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RadsecValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("RadsecValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra RadsecValue Attribute Value",
				"While creating a RadsecValue value, an extra attribute value was detected. "+
					"A RadsecValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra RadsecValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewRadsecValueUnknown(), diags
	}

	coaEnabledAttribute, ok := attributes["coa_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`coa_enabled is missing from object`)

		return NewRadsecValueUnknown(), diags
	}

	coaEnabledVal, ok := coaEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`coa_enabled expected to be basetypes.BoolValue, was: %T`, coaEnabledAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewRadsecValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	idleTimeoutAttribute, ok := attributes["idle_timeout"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`idle_timeout is missing from object`)

		return NewRadsecValueUnknown(), diags
	}

	idleTimeoutVal, ok := idleTimeoutAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`idle_timeout expected to be basetypes.StringValue, was: %T`, idleTimeoutAttribute))
	}

	mxclusterIdsAttribute, ok := attributes["mxcluster_ids"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mxcluster_ids is missing from object`)

		return NewRadsecValueUnknown(), diags
	}

	mxclusterIdsVal, ok := mxclusterIdsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mxcluster_ids expected to be basetypes.ListValue, was: %T`, mxclusterIdsAttribute))
	}

	proxyHostsAttribute, ok := attributes["proxy_hosts"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`proxy_hosts is missing from object`)

		return NewRadsecValueUnknown(), diags
	}

	proxyHostsVal, ok := proxyHostsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`proxy_hosts expected to be basetypes.ListValue, was: %T`, proxyHostsAttribute))
	}

	serverNameAttribute, ok := attributes["server_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`server_name is missing from object`)

		return NewRadsecValueUnknown(), diags
	}

	serverNameVal, ok := serverNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`server_name expected to be basetypes.StringValue, was: %T`, serverNameAttribute))
	}

	serversAttribute, ok := attributes["servers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`servers is missing from object`)

		return NewRadsecValueUnknown(), diags
	}

	serversVal, ok := serversAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`servers expected to be basetypes.ListValue, was: %T`, serversAttribute))
	}

	useMxedgeAttribute, ok := attributes["use_mxedge"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`use_mxedge is missing from object`)

		return NewRadsecValueUnknown(), diags
	}

	useMxedgeVal, ok := useMxedgeAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`use_mxedge expected to be basetypes.BoolValue, was: %T`, useMxedgeAttribute))
	}

	useSiteMxedgeAttribute, ok := attributes["use_site_mxedge"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`use_site_mxedge is missing from object`)

		return NewRadsecValueUnknown(), diags
	}

	useSiteMxedgeVal, ok := useSiteMxedgeAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`use_site_mxedge expected to be basetypes.BoolValue, was: %T`, useSiteMxedgeAttribute))
	}

	if diags.HasError() {
		return NewRadsecValueUnknown(), diags
	}

	return RadsecValue{
		CoaEnabled:    coaEnabledVal,
		Enabled:       enabledVal,
		IdleTimeout:   idleTimeoutVal,
		MxclusterIds:  mxclusterIdsVal,
		ProxyHosts:    proxyHostsVal,
		ServerName:    serverNameVal,
		Servers:       serversVal,
		UseMxedge:     useMxedgeVal,
		UseSiteMxedge: useSiteMxedgeVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewRadsecValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) RadsecValue {
	object, diags := NewRadsecValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewRadsecValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t RadsecType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewRadsecValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewRadsecValueUnknown(), nil
	}

	if in.IsNull() {
		return NewRadsecValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewRadsecValueMust(RadsecValue{}.AttributeTypes(ctx), attributes), nil
}

func (t RadsecType) ValueType(ctx context.Context) attr.Value {
	return RadsecValue{}
}

var _ basetypes.ObjectValuable = RadsecValue{}

type RadsecValue struct {
	CoaEnabled    basetypes.BoolValue   `tfsdk:"coa_enabled"`
	Enabled       basetypes.BoolValue   `tfsdk:"enabled"`
	IdleTimeout   basetypes.StringValue `tfsdk:"idle_timeout"`
	MxclusterIds  basetypes.ListValue   `tfsdk:"mxcluster_ids"`
	ProxyHosts    basetypes.ListValue   `tfsdk:"proxy_hosts"`
	ServerName    basetypes.StringValue `tfsdk:"server_name"`
	Servers       basetypes.ListValue   `tfsdk:"servers"`
	UseMxedge     basetypes.BoolValue   `tfsdk:"use_mxedge"`
	UseSiteMxedge basetypes.BoolValue   `tfsdk:"use_site_mxedge"`
	state         attr.ValueState
}

func (v RadsecValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 9)

	var val tftypes.Value
	var err error

	attrTypes["coa_enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["idle_timeout"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["mxcluster_ids"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["proxy_hosts"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["server_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["servers"] = basetypes.ListType{
		ElemType: ServersValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["use_mxedge"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["use_site_mxedge"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 9)

		val, err = v.CoaEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["coa_enabled"] = val

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.IdleTimeout.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["idle_timeout"] = val

		val, err = v.MxclusterIds.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mxcluster_ids"] = val

		val, err = v.ProxyHosts.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["proxy_hosts"] = val

		val, err = v.ServerName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["server_name"] = val

		val, err = v.Servers.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["servers"] = val

		val, err = v.UseMxedge.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["use_mxedge"] = val

		val, err = v.UseSiteMxedge.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["use_site_mxedge"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v RadsecValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v RadsecValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v RadsecValue) String() string {
	return "RadsecValue"
}

func (v RadsecValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	servers := types.ListValueMust(
		ServersType{
			basetypes.ObjectType{
				AttrTypes: ServersValue{}.AttributeTypes(ctx),
			},
		},
		v.Servers.Elements(),
	)

	if v.Servers.IsNull() {
		servers = types.ListNull(
			ServersType{
				basetypes.ObjectType{
					AttrTypes: ServersValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Servers.IsUnknown() {
		servers = types.ListUnknown(
			ServersType{
				basetypes.ObjectType{
					AttrTypes: ServersValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var mxclusterIdsVal basetypes.ListValue
	switch {
	case v.MxclusterIds.IsUnknown():
		mxclusterIdsVal = types.ListUnknown(types.StringType)
	case v.MxclusterIds.IsNull():
		mxclusterIdsVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		mxclusterIdsVal, d = types.ListValue(types.StringType, v.MxclusterIds.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"coa_enabled":  basetypes.BoolType{},
			"enabled":      basetypes.BoolType{},
			"idle_timeout": basetypes.StringType{},
			"mxcluster_ids": basetypes.ListType{
				ElemType: types.StringType,
			},
			"proxy_hosts": basetypes.ListType{
				ElemType: types.StringType,
			},
			"server_name": basetypes.StringType{},
			"servers": basetypes.ListType{
				ElemType: ServersValue{}.Type(ctx),
			},
			"use_mxedge":      basetypes.BoolType{},
			"use_site_mxedge": basetypes.BoolType{},
		}), diags
	}

	var proxyHostsVal basetypes.ListValue
	switch {
	case v.ProxyHosts.IsUnknown():
		proxyHostsVal = types.ListUnknown(types.StringType)
	case v.ProxyHosts.IsNull():
		proxyHostsVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		proxyHostsVal, d = types.ListValue(types.StringType, v.ProxyHosts.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"coa_enabled":  basetypes.BoolType{},
			"enabled":      basetypes.BoolType{},
			"idle_timeout": basetypes.StringType{},
			"mxcluster_ids": basetypes.ListType{
				ElemType: types.StringType,
			},
			"proxy_hosts": basetypes.ListType{
				ElemType: types.StringType,
			},
			"server_name": basetypes.StringType{},
			"servers": basetypes.ListType{
				ElemType: ServersValue{}.Type(ctx),
			},
			"use_mxedge":      basetypes.BoolType{},
			"use_site_mxedge": basetypes.BoolType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"coa_enabled":  basetypes.BoolType{},
		"enabled":      basetypes.BoolType{},
		"idle_timeout": basetypes.StringType{},
		"mxcluster_ids": basetypes.ListType{
			ElemType: types.StringType,
		},
		"proxy_hosts": basetypes.ListType{
			ElemType: types.StringType,
		},
		"server_name": basetypes.StringType{},
		"servers": basetypes.ListType{
			ElemType: ServersValue{}.Type(ctx),
		},
		"use_mxedge":      basetypes.BoolType{},
		"use_site_mxedge": basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"coa_enabled":     v.CoaEnabled,
			"enabled":         v.Enabled,
			"idle_timeout":    v.IdleTimeout,
			"mxcluster_ids":   mxclusterIdsVal,
			"proxy_hosts":     proxyHostsVal,
			"server_name":     v.ServerName,
			"servers":         servers,
			"use_mxedge":      v.UseMxedge,
			"use_site_mxedge": v.UseSiteMxedge,
		})

	return objVal, diags
}

func (v RadsecValue) Equal(o attr.Value) bool {
	other, ok := o.(RadsecValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.CoaEnabled.Equal(other.CoaEnabled) {
		return false
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.IdleTimeout.Equal(other.IdleTimeout) {
		return false
	}

	if !v.MxclusterIds.Equal(other.MxclusterIds) {
		return false
	}

	if !v.ProxyHosts.Equal(other.ProxyHosts) {
		return false
	}

	if !v.ServerName.Equal(other.ServerName) {
		return false
	}

	if !v.Servers.Equal(other.Servers) {
		return false
	}

	if !v.UseMxedge.Equal(other.UseMxedge) {
		return false
	}

	if !v.UseSiteMxedge.Equal(other.UseSiteMxedge) {
		return false
	}

	return true
}

func (v RadsecValue) Type(ctx context.Context) attr.Type {
	return RadsecType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v RadsecValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"coa_enabled":  basetypes.BoolType{},
		"enabled":      basetypes.BoolType{},
		"idle_timeout": basetypes.StringType{},
		"mxcluster_ids": basetypes.ListType{
			ElemType: types.StringType,
		},
		"proxy_hosts": basetypes.ListType{
			ElemType: types.StringType,
		},
		"server_name": basetypes.StringType{},
		"servers": basetypes.ListType{
			ElemType: ServersValue{}.Type(ctx),
		},
		"use_mxedge":      basetypes.BoolType{},
		"use_site_mxedge": basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = ServersType{}

type ServersType struct {
	basetypes.ObjectType
}

func (t ServersType) Equal(o attr.Type) bool {
	other, ok := o.(ServersType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ServersType) String() string {
	return "ServersType"
}

func (t ServersType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	hostAttribute, ok := attributes["host"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`host is missing from object`)

		return nil, diags
	}

	hostVal, ok := hostAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`host expected to be basetypes.StringValue, was: %T`, hostAttribute))
	}

	portAttribute, ok := attributes["port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port is missing from object`)

		return nil, diags
	}

	portVal, ok := portAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port expected to be basetypes.Int64Value, was: %T`, portAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ServersValue{
		Host:  hostVal,
		Port:  portVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewServersValueNull() ServersValue {
	return ServersValue{
		state: attr.ValueStateNull,
	}
}

func NewServersValueUnknown() ServersValue {
	return ServersValue{
		state: attr.ValueStateUnknown,
	}
}

func NewServersValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ServersValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ServersValue Attribute Value",
				"While creating a ServersValue value, a missing attribute value was detected. "+
					"A ServersValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ServersValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ServersValue Attribute Type",
				"While creating a ServersValue value, an invalid attribute value was detected. "+
					"A ServersValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ServersValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ServersValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ServersValue Attribute Value",
				"While creating a ServersValue value, an extra attribute value was detected. "+
					"A ServersValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ServersValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewServersValueUnknown(), diags
	}

	hostAttribute, ok := attributes["host"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`host is missing from object`)

		return NewServersValueUnknown(), diags
	}

	hostVal, ok := hostAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`host expected to be basetypes.StringValue, was: %T`, hostAttribute))
	}

	portAttribute, ok := attributes["port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port is missing from object`)

		return NewServersValueUnknown(), diags
	}

	portVal, ok := portAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port expected to be basetypes.Int64Value, was: %T`, portAttribute))
	}

	if diags.HasError() {
		return NewServersValueUnknown(), diags
	}

	return ServersValue{
		Host:  hostVal,
		Port:  portVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewServersValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ServersValue {
	object, diags := NewServersValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewServersValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ServersType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewServersValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewServersValueUnknown(), nil
	}

	if in.IsNull() {
		return NewServersValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewServersValueMust(ServersValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ServersType) ValueType(ctx context.Context) attr.Value {
	return ServersValue{}
}

var _ basetypes.ObjectValuable = ServersValue{}

type ServersValue struct {
	Host  basetypes.StringValue `tfsdk:"host"`
	Port  basetypes.Int64Value  `tfsdk:"port"`
	state attr.ValueState
}

func (v ServersValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["host"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["port"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Host.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["host"] = val

		val, err = v.Port.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ServersValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ServersValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ServersValue) String() string {
	return "ServersValue"
}

func (v ServersValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"host": basetypes.StringType{},
		"port": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"host": v.Host,
			"port": v.Port,
		})

	return objVal, diags
}

func (v ServersValue) Equal(o attr.Value) bool {
	other, ok := o.(ServersValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Host.Equal(other.Host) {
		return false
	}

	if !v.Port.Equal(other.Port) {
		return false
	}

	return true
}

func (v ServersValue) Type(ctx context.Context) attr.Type {
	return ServersType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ServersValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"host": basetypes.StringType{},
		"port": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = PwrConfigType{}

type PwrConfigType struct {
	basetypes.ObjectType
}

func (t PwrConfigType) Equal(o attr.Type) bool {
	other, ok := o.(PwrConfigType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PwrConfigType) String() string {
	return "PwrConfigType"
}

func (t PwrConfigType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	baseAttribute, ok := attributes["base"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`base is missing from object`)

		return nil, diags
	}

	baseVal, ok := baseAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`base expected to be basetypes.Int64Value, was: %T`, baseAttribute))
	}

	preferUsbOverWifiAttribute, ok := attributes["prefer_usb_over_wifi"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefer_usb_over_wifi is missing from object`)

		return nil, diags
	}

	preferUsbOverWifiVal, ok := preferUsbOverWifiAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefer_usb_over_wifi expected to be basetypes.BoolValue, was: %T`, preferUsbOverWifiAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PwrConfigValue{
		Base:              baseVal,
		PreferUsbOverWifi: preferUsbOverWifiVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewPwrConfigValueNull() PwrConfigValue {
	return PwrConfigValue{
		state: attr.ValueStateNull,
	}
}

func NewPwrConfigValueUnknown() PwrConfigValue {
	return PwrConfigValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPwrConfigValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PwrConfigValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PwrConfigValue Attribute Value",
				"While creating a PwrConfigValue value, a missing attribute value was detected. "+
					"A PwrConfigValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PwrConfigValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PwrConfigValue Attribute Type",
				"While creating a PwrConfigValue value, an invalid attribute value was detected. "+
					"A PwrConfigValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PwrConfigValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PwrConfigValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PwrConfigValue Attribute Value",
				"While creating a PwrConfigValue value, an extra attribute value was detected. "+
					"A PwrConfigValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PwrConfigValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPwrConfigValueUnknown(), diags
	}

	baseAttribute, ok := attributes["base"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`base is missing from object`)

		return NewPwrConfigValueUnknown(), diags
	}

	baseVal, ok := baseAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`base expected to be basetypes.Int64Value, was: %T`, baseAttribute))
	}

	preferUsbOverWifiAttribute, ok := attributes["prefer_usb_over_wifi"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefer_usb_over_wifi is missing from object`)

		return NewPwrConfigValueUnknown(), diags
	}

	preferUsbOverWifiVal, ok := preferUsbOverWifiAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefer_usb_over_wifi expected to be basetypes.BoolValue, was: %T`, preferUsbOverWifiAttribute))
	}

	if diags.HasError() {
		return NewPwrConfigValueUnknown(), diags
	}

	return PwrConfigValue{
		Base:              baseVal,
		PreferUsbOverWifi: preferUsbOverWifiVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewPwrConfigValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PwrConfigValue {
	object, diags := NewPwrConfigValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPwrConfigValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PwrConfigType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPwrConfigValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPwrConfigValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPwrConfigValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPwrConfigValueMust(PwrConfigValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PwrConfigType) ValueType(ctx context.Context) attr.Value {
	return PwrConfigValue{}
}

var _ basetypes.ObjectValuable = PwrConfigValue{}

type PwrConfigValue struct {
	Base              basetypes.Int64Value `tfsdk:"base"`
	PreferUsbOverWifi basetypes.BoolValue  `tfsdk:"prefer_usb_over_wifi"`
	state             attr.ValueState
}

func (v PwrConfigValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["base"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["prefer_usb_over_wifi"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Base.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["base"] = val

		val, err = v.PreferUsbOverWifi.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["prefer_usb_over_wifi"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PwrConfigValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PwrConfigValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PwrConfigValue) String() string {
	return "PwrConfigValue"
}

func (v PwrConfigValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"base":                 basetypes.Int64Type{},
		"prefer_usb_over_wifi": basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"base":                 v.Base,
			"prefer_usb_over_wifi": v.PreferUsbOverWifi,
		})

	return objVal, diags
}

func (v PwrConfigValue) Equal(o attr.Value) bool {
	other, ok := o.(PwrConfigValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Base.Equal(other.Base) {
		return false
	}

	if !v.PreferUsbOverWifi.Equal(other.PreferUsbOverWifi) {
		return false
	}

	return true
}

func (v PwrConfigValue) Type(ctx context.Context) attr.Type {
	return PwrConfigType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PwrConfigValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"base":                 basetypes.Int64Type{},
		"prefer_usb_over_wifi": basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = RadioConfigType{}

type RadioConfigType struct {
	basetypes.ObjectType
}

func (t RadioConfigType) Equal(o attr.Type) bool {
	other, ok := o.(RadioConfigType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t RadioConfigType) String() string {
	return "RadioConfigType"
}

func (t RadioConfigType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	allowRrmDisableAttribute, ok := attributes["allow_rrm_disable"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allow_rrm_disable is missing from object`)

		return nil, diags
	}

	allowRrmDisableVal, ok := allowRrmDisableAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allow_rrm_disable expected to be basetypes.BoolValue, was: %T`, allowRrmDisableAttribute))
	}

	antGain24Attribute, ok := attributes["ant_gain_24"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ant_gain_24 is missing from object`)

		return nil, diags
	}

	antGain24Val, ok := antGain24Attribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ant_gain_24 expected to be basetypes.Int64Value, was: %T`, antGain24Attribute))
	}

	antGain5Attribute, ok := attributes["ant_gain_5"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ant_gain_5 is missing from object`)

		return nil, diags
	}

	antGain5Val, ok := antGain5Attribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ant_gain_5 expected to be basetypes.Int64Value, was: %T`, antGain5Attribute))
	}

	antGain6Attribute, ok := attributes["ant_gain_6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ant_gain_6 is missing from object`)

		return nil, diags
	}

	antGain6Val, ok := antGain6Attribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ant_gain_6 expected to be basetypes.Int64Value, was: %T`, antGain6Attribute))
	}

	antennaModeAttribute, ok := attributes["antenna_mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`antenna_mode is missing from object`)

		return nil, diags
	}

	antennaModeVal, ok := antennaModeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`antenna_mode expected to be basetypes.StringValue, was: %T`, antennaModeAttribute))
	}

	band24Attribute, ok := attributes["band_24"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`band_24 is missing from object`)

		return nil, diags
	}

	band24Val, ok := band24Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`band_24 expected to be basetypes.ObjectValue, was: %T`, band24Attribute))
	}

	band24UsageAttribute, ok := attributes["band_24_usage"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`band_24_usage is missing from object`)

		return nil, diags
	}

	band24UsageVal, ok := band24UsageAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`band_24_usage expected to be basetypes.StringValue, was: %T`, band24UsageAttribute))
	}

	band5Attribute, ok := attributes["band_5"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`band_5 is missing from object`)

		return nil, diags
	}

	band5Val, ok := band5Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`band_5 expected to be basetypes.ObjectValue, was: %T`, band5Attribute))
	}

	band5On24RadioAttribute, ok := attributes["band_5_on_24_radio"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`band_5_on_24_radio is missing from object`)

		return nil, diags
	}

	band5On24RadioVal, ok := band5On24RadioAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`band_5_on_24_radio expected to be basetypes.ObjectValue, was: %T`, band5On24RadioAttribute))
	}

	band6Attribute, ok := attributes["band_6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`band_6 is missing from object`)

		return nil, diags
	}

	band6Val, ok := band6Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`band_6 expected to be basetypes.ObjectValue, was: %T`, band6Attribute))
	}

	fullAutomaticRrmAttribute, ok := attributes["full_automatic_rrm"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`full_automatic_rrm is missing from object`)

		return nil, diags
	}

	fullAutomaticRrmVal, ok := fullAutomaticRrmAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`full_automatic_rrm expected to be basetypes.BoolValue, was: %T`, fullAutomaticRrmAttribute))
	}

	indoorUseAttribute, ok := attributes["indoor_use"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`indoor_use is missing from object`)

		return nil, diags
	}

	indoorUseVal, ok := indoorUseAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`indoor_use expected to be basetypes.BoolValue, was: %T`, indoorUseAttribute))
	}

	scanningEnabledAttribute, ok := attributes["scanning_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`scanning_enabled is missing from object`)

		return nil, diags
	}

	scanningEnabledVal, ok := scanningEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`scanning_enabled expected to be basetypes.BoolValue, was: %T`, scanningEnabledAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return RadioConfigValue{
		AllowRrmDisable:  allowRrmDisableVal,
		AntGain24:        antGain24Val,
		AntGain5:         antGain5Val,
		AntGain6:         antGain6Val,
		AntennaMode:      antennaModeVal,
		Band24:           band24Val,
		Band24Usage:      band24UsageVal,
		Band5:            band5Val,
		Band5On24Radio:   band5On24RadioVal,
		Band6:            band6Val,
		FullAutomaticRrm: fullAutomaticRrmVal,
		IndoorUse:        indoorUseVal,
		ScanningEnabled:  scanningEnabledVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewRadioConfigValueNull() RadioConfigValue {
	return RadioConfigValue{
		state: attr.ValueStateNull,
	}
}

func NewRadioConfigValueUnknown() RadioConfigValue {
	return RadioConfigValue{
		state: attr.ValueStateUnknown,
	}
}

func NewRadioConfigValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (RadioConfigValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing RadioConfigValue Attribute Value",
				"While creating a RadioConfigValue value, a missing attribute value was detected. "+
					"A RadioConfigValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RadioConfigValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid RadioConfigValue Attribute Type",
				"While creating a RadioConfigValue value, an invalid attribute value was detected. "+
					"A RadioConfigValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RadioConfigValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("RadioConfigValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra RadioConfigValue Attribute Value",
				"While creating a RadioConfigValue value, an extra attribute value was detected. "+
					"A RadioConfigValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra RadioConfigValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewRadioConfigValueUnknown(), diags
	}

	allowRrmDisableAttribute, ok := attributes["allow_rrm_disable"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allow_rrm_disable is missing from object`)

		return NewRadioConfigValueUnknown(), diags
	}

	allowRrmDisableVal, ok := allowRrmDisableAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allow_rrm_disable expected to be basetypes.BoolValue, was: %T`, allowRrmDisableAttribute))
	}

	antGain24Attribute, ok := attributes["ant_gain_24"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ant_gain_24 is missing from object`)

		return NewRadioConfigValueUnknown(), diags
	}

	antGain24Val, ok := antGain24Attribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ant_gain_24 expected to be basetypes.Int64Value, was: %T`, antGain24Attribute))
	}

	antGain5Attribute, ok := attributes["ant_gain_5"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ant_gain_5 is missing from object`)

		return NewRadioConfigValueUnknown(), diags
	}

	antGain5Val, ok := antGain5Attribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ant_gain_5 expected to be basetypes.Int64Value, was: %T`, antGain5Attribute))
	}

	antGain6Attribute, ok := attributes["ant_gain_6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ant_gain_6 is missing from object`)

		return NewRadioConfigValueUnknown(), diags
	}

	antGain6Val, ok := antGain6Attribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ant_gain_6 expected to be basetypes.Int64Value, was: %T`, antGain6Attribute))
	}

	antennaModeAttribute, ok := attributes["antenna_mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`antenna_mode is missing from object`)

		return NewRadioConfigValueUnknown(), diags
	}

	antennaModeVal, ok := antennaModeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`antenna_mode expected to be basetypes.StringValue, was: %T`, antennaModeAttribute))
	}

	band24Attribute, ok := attributes["band_24"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`band_24 is missing from object`)

		return NewRadioConfigValueUnknown(), diags
	}

	band24Val, ok := band24Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`band_24 expected to be basetypes.ObjectValue, was: %T`, band24Attribute))
	}

	band24UsageAttribute, ok := attributes["band_24_usage"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`band_24_usage is missing from object`)

		return NewRadioConfigValueUnknown(), diags
	}

	band24UsageVal, ok := band24UsageAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`band_24_usage expected to be basetypes.StringValue, was: %T`, band24UsageAttribute))
	}

	band5Attribute, ok := attributes["band_5"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`band_5 is missing from object`)

		return NewRadioConfigValueUnknown(), diags
	}

	band5Val, ok := band5Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`band_5 expected to be basetypes.ObjectValue, was: %T`, band5Attribute))
	}

	band5On24RadioAttribute, ok := attributes["band_5_on_24_radio"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`band_5_on_24_radio is missing from object`)

		return NewRadioConfigValueUnknown(), diags
	}

	band5On24RadioVal, ok := band5On24RadioAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`band_5_on_24_radio expected to be basetypes.ObjectValue, was: %T`, band5On24RadioAttribute))
	}

	band6Attribute, ok := attributes["band_6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`band_6 is missing from object`)

		return NewRadioConfigValueUnknown(), diags
	}

	band6Val, ok := band6Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`band_6 expected to be basetypes.ObjectValue, was: %T`, band6Attribute))
	}

	fullAutomaticRrmAttribute, ok := attributes["full_automatic_rrm"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`full_automatic_rrm is missing from object`)

		return NewRadioConfigValueUnknown(), diags
	}

	fullAutomaticRrmVal, ok := fullAutomaticRrmAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`full_automatic_rrm expected to be basetypes.BoolValue, was: %T`, fullAutomaticRrmAttribute))
	}

	indoorUseAttribute, ok := attributes["indoor_use"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`indoor_use is missing from object`)

		return NewRadioConfigValueUnknown(), diags
	}

	indoorUseVal, ok := indoorUseAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`indoor_use expected to be basetypes.BoolValue, was: %T`, indoorUseAttribute))
	}

	scanningEnabledAttribute, ok := attributes["scanning_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`scanning_enabled is missing from object`)

		return NewRadioConfigValueUnknown(), diags
	}

	scanningEnabledVal, ok := scanningEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`scanning_enabled expected to be basetypes.BoolValue, was: %T`, scanningEnabledAttribute))
	}

	if diags.HasError() {
		return NewRadioConfigValueUnknown(), diags
	}

	return RadioConfigValue{
		AllowRrmDisable:  allowRrmDisableVal,
		AntGain24:        antGain24Val,
		AntGain5:         antGain5Val,
		AntGain6:         antGain6Val,
		AntennaMode:      antennaModeVal,
		Band24:           band24Val,
		Band24Usage:      band24UsageVal,
		Band5:            band5Val,
		Band5On24Radio:   band5On24RadioVal,
		Band6:            band6Val,
		FullAutomaticRrm: fullAutomaticRrmVal,
		IndoorUse:        indoorUseVal,
		ScanningEnabled:  scanningEnabledVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewRadioConfigValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) RadioConfigValue {
	object, diags := NewRadioConfigValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewRadioConfigValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t RadioConfigType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewRadioConfigValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewRadioConfigValueUnknown(), nil
	}

	if in.IsNull() {
		return NewRadioConfigValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewRadioConfigValueMust(RadioConfigValue{}.AttributeTypes(ctx), attributes), nil
}

func (t RadioConfigType) ValueType(ctx context.Context) attr.Value {
	return RadioConfigValue{}
}

var _ basetypes.ObjectValuable = RadioConfigValue{}

type RadioConfigValue struct {
	AllowRrmDisable  basetypes.BoolValue   `tfsdk:"allow_rrm_disable"`
	AntGain24        basetypes.Int64Value  `tfsdk:"ant_gain_24"`
	AntGain5         basetypes.Int64Value  `tfsdk:"ant_gain_5"`
	AntGain6         basetypes.Int64Value  `tfsdk:"ant_gain_6"`
	AntennaMode      basetypes.StringValue `tfsdk:"antenna_mode"`
	Band24           basetypes.ObjectValue `tfsdk:"band_24"`
	Band24Usage      basetypes.StringValue `tfsdk:"band_24_usage"`
	Band5            basetypes.ObjectValue `tfsdk:"band_5"`
	Band5On24Radio   basetypes.ObjectValue `tfsdk:"band_5_on_24_radio"`
	Band6            basetypes.ObjectValue `tfsdk:"band_6"`
	FullAutomaticRrm basetypes.BoolValue   `tfsdk:"full_automatic_rrm"`
	IndoorUse        basetypes.BoolValue   `tfsdk:"indoor_use"`
	ScanningEnabled  basetypes.BoolValue   `tfsdk:"scanning_enabled"`
	state            attr.ValueState
}

func (v RadioConfigValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 13)

	var val tftypes.Value
	var err error

	attrTypes["allow_rrm_disable"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["ant_gain_24"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["ant_gain_5"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["ant_gain_6"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["antenna_mode"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["band_24"] = basetypes.ObjectType{
		AttrTypes: Band24Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["band_24_usage"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["band_5"] = basetypes.ObjectType{
		AttrTypes: Band5Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["band_5_on_24_radio"] = basetypes.ObjectType{
		AttrTypes: Band5On24RadioValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["band_6"] = basetypes.ObjectType{
		AttrTypes: Band6Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["full_automatic_rrm"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["indoor_use"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["scanning_enabled"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 13)

		val, err = v.AllowRrmDisable.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["allow_rrm_disable"] = val

		val, err = v.AntGain24.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ant_gain_24"] = val

		val, err = v.AntGain5.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ant_gain_5"] = val

		val, err = v.AntGain6.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ant_gain_6"] = val

		val, err = v.AntennaMode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["antenna_mode"] = val

		val, err = v.Band24.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["band_24"] = val

		val, err = v.Band24Usage.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["band_24_usage"] = val

		val, err = v.Band5.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["band_5"] = val

		val, err = v.Band5On24Radio.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["band_5_on_24_radio"] = val

		val, err = v.Band6.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["band_6"] = val

		val, err = v.FullAutomaticRrm.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["full_automatic_rrm"] = val

		val, err = v.IndoorUse.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["indoor_use"] = val

		val, err = v.ScanningEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["scanning_enabled"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v RadioConfigValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v RadioConfigValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v RadioConfigValue) String() string {
	return "RadioConfigValue"
}

func (v RadioConfigValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var band24 basetypes.ObjectValue

	if v.Band24.IsNull() {
		band24 = types.ObjectNull(
			Band24Value{}.AttributeTypes(ctx),
		)
	}

	if v.Band24.IsUnknown() {
		band24 = types.ObjectUnknown(
			Band24Value{}.AttributeTypes(ctx),
		)
	}

	if !v.Band24.IsNull() && !v.Band24.IsUnknown() {
		band24 = types.ObjectValueMust(
			Band24Value{}.AttributeTypes(ctx),
			v.Band24.Attributes(),
		)
	}

	var band5 basetypes.ObjectValue

	if v.Band5.IsNull() {
		band5 = types.ObjectNull(
			Band5Value{}.AttributeTypes(ctx),
		)
	}

	if v.Band5.IsUnknown() {
		band5 = types.ObjectUnknown(
			Band5Value{}.AttributeTypes(ctx),
		)
	}

	if !v.Band5.IsNull() && !v.Band5.IsUnknown() {
		band5 = types.ObjectValueMust(
			Band5Value{}.AttributeTypes(ctx),
			v.Band5.Attributes(),
		)
	}

	var band5On24Radio basetypes.ObjectValue

	if v.Band5On24Radio.IsNull() {
		band5On24Radio = types.ObjectNull(
			Band5On24RadioValue{}.AttributeTypes(ctx),
		)
	}

	if v.Band5On24Radio.IsUnknown() {
		band5On24Radio = types.ObjectUnknown(
			Band5On24RadioValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Band5On24Radio.IsNull() && !v.Band5On24Radio.IsUnknown() {
		band5On24Radio = types.ObjectValueMust(
			Band5On24RadioValue{}.AttributeTypes(ctx),
			v.Band5On24Radio.Attributes(),
		)
	}

	var band6 basetypes.ObjectValue

	if v.Band6.IsNull() {
		band6 = types.ObjectNull(
			Band6Value{}.AttributeTypes(ctx),
		)
	}

	if v.Band6.IsUnknown() {
		band6 = types.ObjectUnknown(
			Band6Value{}.AttributeTypes(ctx),
		)
	}

	if !v.Band6.IsNull() && !v.Band6.IsUnknown() {
		band6 = types.ObjectValueMust(
			Band6Value{}.AttributeTypes(ctx),
			v.Band6.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"allow_rrm_disable": basetypes.BoolType{},
		"ant_gain_24":       basetypes.Int64Type{},
		"ant_gain_5":        basetypes.Int64Type{},
		"ant_gain_6":        basetypes.Int64Type{},
		"antenna_mode":      basetypes.StringType{},
		"band_24": basetypes.ObjectType{
			AttrTypes: Band24Value{}.AttributeTypes(ctx),
		},
		"band_24_usage": basetypes.StringType{},
		"band_5": basetypes.ObjectType{
			AttrTypes: Band5Value{}.AttributeTypes(ctx),
		},
		"band_5_on_24_radio": basetypes.ObjectType{
			AttrTypes: Band5On24RadioValue{}.AttributeTypes(ctx),
		},
		"band_6": basetypes.ObjectType{
			AttrTypes: Band6Value{}.AttributeTypes(ctx),
		},
		"full_automatic_rrm": basetypes.BoolType{},
		"indoor_use":         basetypes.BoolType{},
		"scanning_enabled":   basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"allow_rrm_disable":  v.AllowRrmDisable,
			"ant_gain_24":        v.AntGain24,
			"ant_gain_5":         v.AntGain5,
			"ant_gain_6":         v.AntGain6,
			"antenna_mode":       v.AntennaMode,
			"band_24":            band24,
			"band_24_usage":      v.Band24Usage,
			"band_5":             band5,
			"band_5_on_24_radio": band5On24Radio,
			"band_6":             band6,
			"full_automatic_rrm": v.FullAutomaticRrm,
			"indoor_use":         v.IndoorUse,
			"scanning_enabled":   v.ScanningEnabled,
		})

	return objVal, diags
}

func (v RadioConfigValue) Equal(o attr.Value) bool {
	other, ok := o.(RadioConfigValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AllowRrmDisable.Equal(other.AllowRrmDisable) {
		return false
	}

	if !v.AntGain24.Equal(other.AntGain24) {
		return false
	}

	if !v.AntGain5.Equal(other.AntGain5) {
		return false
	}

	if !v.AntGain6.Equal(other.AntGain6) {
		return false
	}

	if !v.AntennaMode.Equal(other.AntennaMode) {
		return false
	}

	if !v.Band24.Equal(other.Band24) {
		return false
	}

	if !v.Band24Usage.Equal(other.Band24Usage) {
		return false
	}

	if !v.Band5.Equal(other.Band5) {
		return false
	}

	if !v.Band5On24Radio.Equal(other.Band5On24Radio) {
		return false
	}

	if !v.Band6.Equal(other.Band6) {
		return false
	}

	if !v.FullAutomaticRrm.Equal(other.FullAutomaticRrm) {
		return false
	}

	if !v.IndoorUse.Equal(other.IndoorUse) {
		return false
	}

	if !v.ScanningEnabled.Equal(other.ScanningEnabled) {
		return false
	}

	return true
}

func (v RadioConfigValue) Type(ctx context.Context) attr.Type {
	return RadioConfigType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v RadioConfigValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"allow_rrm_disable": basetypes.BoolType{},
		"ant_gain_24":       basetypes.Int64Type{},
		"ant_gain_5":        basetypes.Int64Type{},
		"ant_gain_6":        basetypes.Int64Type{},
		"antenna_mode":      basetypes.StringType{},
		"band_24": basetypes.ObjectType{
			AttrTypes: Band24Value{}.AttributeTypes(ctx),
		},
		"band_24_usage": basetypes.StringType{},
		"band_5": basetypes.ObjectType{
			AttrTypes: Band5Value{}.AttributeTypes(ctx),
		},
		"band_5_on_24_radio": basetypes.ObjectType{
			AttrTypes: Band5On24RadioValue{}.AttributeTypes(ctx),
		},
		"band_6": basetypes.ObjectType{
			AttrTypes: Band6Value{}.AttributeTypes(ctx),
		},
		"full_automatic_rrm": basetypes.BoolType{},
		"indoor_use":         basetypes.BoolType{},
		"scanning_enabled":   basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = Band24Type{}

type Band24Type struct {
	basetypes.ObjectType
}

func (t Band24Type) Equal(o attr.Type) bool {
	other, ok := o.(Band24Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Band24Type) String() string {
	return "Band24Type"
}

func (t Band24Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	allowRrmDisableAttribute, ok := attributes["allow_rrm_disable"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allow_rrm_disable is missing from object`)

		return nil, diags
	}

	allowRrmDisableVal, ok := allowRrmDisableAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allow_rrm_disable expected to be basetypes.BoolValue, was: %T`, allowRrmDisableAttribute))
	}

	antGainAttribute, ok := attributes["ant_gain"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ant_gain is missing from object`)

		return nil, diags
	}

	antGainVal, ok := antGainAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ant_gain expected to be basetypes.Int64Value, was: %T`, antGainAttribute))
	}

	antennaModeAttribute, ok := attributes["antenna_mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`antenna_mode is missing from object`)

		return nil, diags
	}

	antennaModeVal, ok := antennaModeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`antenna_mode expected to be basetypes.StringValue, was: %T`, antennaModeAttribute))
	}

	bandwidthAttribute, ok := attributes["bandwidth"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bandwidth is missing from object`)

		return nil, diags
	}

	bandwidthVal, ok := bandwidthAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bandwidth expected to be basetypes.Int64Value, was: %T`, bandwidthAttribute))
	}

	channelAttribute, ok := attributes["channel"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`channel is missing from object`)

		return nil, diags
	}

	channelVal, ok := channelAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`channel expected to be basetypes.Int64Value, was: %T`, channelAttribute))
	}

	channelsAttribute, ok := attributes["channels"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`channels is missing from object`)

		return nil, diags
	}

	channelsVal, ok := channelsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`channels expected to be basetypes.ListValue, was: %T`, channelsAttribute))
	}

	disabledAttribute, ok := attributes["disabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disabled is missing from object`)

		return nil, diags
	}

	disabledVal, ok := disabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disabled expected to be basetypes.BoolValue, was: %T`, disabledAttribute))
	}

	powerAttribute, ok := attributes["power"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`power is missing from object`)

		return nil, diags
	}

	powerVal, ok := powerAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`power expected to be basetypes.Int64Value, was: %T`, powerAttribute))
	}

	powerMaxAttribute, ok := attributes["power_max"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`power_max is missing from object`)

		return nil, diags
	}

	powerMaxVal, ok := powerMaxAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`power_max expected to be basetypes.Int64Value, was: %T`, powerMaxAttribute))
	}

	powerMinAttribute, ok := attributes["power_min"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`power_min is missing from object`)

		return nil, diags
	}

	powerMinVal, ok := powerMinAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`power_min expected to be basetypes.Int64Value, was: %T`, powerMinAttribute))
	}

	preambleAttribute, ok := attributes["preamble"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`preamble is missing from object`)

		return nil, diags
	}

	preambleVal, ok := preambleAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`preamble expected to be basetypes.StringValue, was: %T`, preambleAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Band24Value{
		AllowRrmDisable: allowRrmDisableVal,
		AntGain:         antGainVal,
		AntennaMode:     antennaModeVal,
		Bandwidth:       bandwidthVal,
		Channel:         channelVal,
		Channels:        channelsVal,
		Disabled:        disabledVal,
		Power:           powerVal,
		PowerMax:        powerMaxVal,
		PowerMin:        powerMinVal,
		Preamble:        preambleVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewBand24ValueNull() Band24Value {
	return Band24Value{
		state: attr.ValueStateNull,
	}
}

func NewBand24ValueUnknown() Band24Value {
	return Band24Value{
		state: attr.ValueStateUnknown,
	}
}

func NewBand24Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Band24Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Band24Value Attribute Value",
				"While creating a Band24Value value, a missing attribute value was detected. "+
					"A Band24Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Band24Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Band24Value Attribute Type",
				"While creating a Band24Value value, an invalid attribute value was detected. "+
					"A Band24Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Band24Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Band24Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Band24Value Attribute Value",
				"While creating a Band24Value value, an extra attribute value was detected. "+
					"A Band24Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Band24Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewBand24ValueUnknown(), diags
	}

	allowRrmDisableAttribute, ok := attributes["allow_rrm_disable"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allow_rrm_disable is missing from object`)

		return NewBand24ValueUnknown(), diags
	}

	allowRrmDisableVal, ok := allowRrmDisableAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allow_rrm_disable expected to be basetypes.BoolValue, was: %T`, allowRrmDisableAttribute))
	}

	antGainAttribute, ok := attributes["ant_gain"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ant_gain is missing from object`)

		return NewBand24ValueUnknown(), diags
	}

	antGainVal, ok := antGainAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ant_gain expected to be basetypes.Int64Value, was: %T`, antGainAttribute))
	}

	antennaModeAttribute, ok := attributes["antenna_mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`antenna_mode is missing from object`)

		return NewBand24ValueUnknown(), diags
	}

	antennaModeVal, ok := antennaModeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`antenna_mode expected to be basetypes.StringValue, was: %T`, antennaModeAttribute))
	}

	bandwidthAttribute, ok := attributes["bandwidth"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bandwidth is missing from object`)

		return NewBand24ValueUnknown(), diags
	}

	bandwidthVal, ok := bandwidthAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bandwidth expected to be basetypes.Int64Value, was: %T`, bandwidthAttribute))
	}

	channelAttribute, ok := attributes["channel"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`channel is missing from object`)

		return NewBand24ValueUnknown(), diags
	}

	channelVal, ok := channelAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`channel expected to be basetypes.Int64Value, was: %T`, channelAttribute))
	}

	channelsAttribute, ok := attributes["channels"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`channels is missing from object`)

		return NewBand24ValueUnknown(), diags
	}

	channelsVal, ok := channelsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`channels expected to be basetypes.ListValue, was: %T`, channelsAttribute))
	}

	disabledAttribute, ok := attributes["disabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disabled is missing from object`)

		return NewBand24ValueUnknown(), diags
	}

	disabledVal, ok := disabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disabled expected to be basetypes.BoolValue, was: %T`, disabledAttribute))
	}

	powerAttribute, ok := attributes["power"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`power is missing from object`)

		return NewBand24ValueUnknown(), diags
	}

	powerVal, ok := powerAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`power expected to be basetypes.Int64Value, was: %T`, powerAttribute))
	}

	powerMaxAttribute, ok := attributes["power_max"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`power_max is missing from object`)

		return NewBand24ValueUnknown(), diags
	}

	powerMaxVal, ok := powerMaxAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`power_max expected to be basetypes.Int64Value, was: %T`, powerMaxAttribute))
	}

	powerMinAttribute, ok := attributes["power_min"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`power_min is missing from object`)

		return NewBand24ValueUnknown(), diags
	}

	powerMinVal, ok := powerMinAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`power_min expected to be basetypes.Int64Value, was: %T`, powerMinAttribute))
	}

	preambleAttribute, ok := attributes["preamble"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`preamble is missing from object`)

		return NewBand24ValueUnknown(), diags
	}

	preambleVal, ok := preambleAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`preamble expected to be basetypes.StringValue, was: %T`, preambleAttribute))
	}

	if diags.HasError() {
		return NewBand24ValueUnknown(), diags
	}

	return Band24Value{
		AllowRrmDisable: allowRrmDisableVal,
		AntGain:         antGainVal,
		AntennaMode:     antennaModeVal,
		Bandwidth:       bandwidthVal,
		Channel:         channelVal,
		Channels:        channelsVal,
		Disabled:        disabledVal,
		Power:           powerVal,
		PowerMax:        powerMaxVal,
		PowerMin:        powerMinVal,
		Preamble:        preambleVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewBand24ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Band24Value {
	object, diags := NewBand24Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewBand24ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Band24Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewBand24ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewBand24ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewBand24ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewBand24ValueMust(Band24Value{}.AttributeTypes(ctx), attributes), nil
}

func (t Band24Type) ValueType(ctx context.Context) attr.Value {
	return Band24Value{}
}

var _ basetypes.ObjectValuable = Band24Value{}

type Band24Value struct {
	AllowRrmDisable basetypes.BoolValue   `tfsdk:"allow_rrm_disable"`
	AntGain         basetypes.Int64Value  `tfsdk:"ant_gain"`
	AntennaMode     basetypes.StringValue `tfsdk:"antenna_mode"`
	Bandwidth       basetypes.Int64Value  `tfsdk:"bandwidth"`
	Channel         basetypes.Int64Value  `tfsdk:"channel"`
	Channels        basetypes.ListValue   `tfsdk:"channels"`
	Disabled        basetypes.BoolValue   `tfsdk:"disabled"`
	Power           basetypes.Int64Value  `tfsdk:"power"`
	PowerMax        basetypes.Int64Value  `tfsdk:"power_max"`
	PowerMin        basetypes.Int64Value  `tfsdk:"power_min"`
	Preamble        basetypes.StringValue `tfsdk:"preamble"`
	state           attr.ValueState
}

func (v Band24Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 11)

	var val tftypes.Value
	var err error

	attrTypes["allow_rrm_disable"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["ant_gain"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["antenna_mode"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["bandwidth"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["channel"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["channels"] = basetypes.ListType{
		ElemType: types.Int64Type,
	}.TerraformType(ctx)
	attrTypes["disabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["power"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["power_max"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["power_min"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["preamble"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 11)

		val, err = v.AllowRrmDisable.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["allow_rrm_disable"] = val

		val, err = v.AntGain.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ant_gain"] = val

		val, err = v.AntennaMode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["antenna_mode"] = val

		val, err = v.Bandwidth.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bandwidth"] = val

		val, err = v.Channel.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["channel"] = val

		val, err = v.Channels.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["channels"] = val

		val, err = v.Disabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["disabled"] = val

		val, err = v.Power.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["power"] = val

		val, err = v.PowerMax.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["power_max"] = val

		val, err = v.PowerMin.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["power_min"] = val

		val, err = v.Preamble.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["preamble"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Band24Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Band24Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Band24Value) String() string {
	return "Band24Value"
}

func (v Band24Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var channelsVal basetypes.ListValue
	switch {
	case v.Channels.IsUnknown():
		channelsVal = types.ListUnknown(types.Int64Type)
	case v.Channels.IsNull():
		channelsVal = types.ListNull(types.Int64Type)
	default:
		var d diag.Diagnostics
		channelsVal, d = types.ListValue(types.Int64Type, v.Channels.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"allow_rrm_disable": basetypes.BoolType{},
			"ant_gain":          basetypes.Int64Type{},
			"antenna_mode":      basetypes.StringType{},
			"bandwidth":         basetypes.Int64Type{},
			"channel":           basetypes.Int64Type{},
			"channels": basetypes.ListType{
				ElemType: types.Int64Type,
			},
			"disabled":  basetypes.BoolType{},
			"power":     basetypes.Int64Type{},
			"power_max": basetypes.Int64Type{},
			"power_min": basetypes.Int64Type{},
			"preamble":  basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"allow_rrm_disable": basetypes.BoolType{},
		"ant_gain":          basetypes.Int64Type{},
		"antenna_mode":      basetypes.StringType{},
		"bandwidth":         basetypes.Int64Type{},
		"channel":           basetypes.Int64Type{},
		"channels": basetypes.ListType{
			ElemType: types.Int64Type,
		},
		"disabled":  basetypes.BoolType{},
		"power":     basetypes.Int64Type{},
		"power_max": basetypes.Int64Type{},
		"power_min": basetypes.Int64Type{},
		"preamble":  basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"allow_rrm_disable": v.AllowRrmDisable,
			"ant_gain":          v.AntGain,
			"antenna_mode":      v.AntennaMode,
			"bandwidth":         v.Bandwidth,
			"channel":           v.Channel,
			"channels":          channelsVal,
			"disabled":          v.Disabled,
			"power":             v.Power,
			"power_max":         v.PowerMax,
			"power_min":         v.PowerMin,
			"preamble":          v.Preamble,
		})

	return objVal, diags
}

func (v Band24Value) Equal(o attr.Value) bool {
	other, ok := o.(Band24Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AllowRrmDisable.Equal(other.AllowRrmDisable) {
		return false
	}

	if !v.AntGain.Equal(other.AntGain) {
		return false
	}

	if !v.AntennaMode.Equal(other.AntennaMode) {
		return false
	}

	if !v.Bandwidth.Equal(other.Bandwidth) {
		return false
	}

	if !v.Channel.Equal(other.Channel) {
		return false
	}

	if !v.Channels.Equal(other.Channels) {
		return false
	}

	if !v.Disabled.Equal(other.Disabled) {
		return false
	}

	if !v.Power.Equal(other.Power) {
		return false
	}

	if !v.PowerMax.Equal(other.PowerMax) {
		return false
	}

	if !v.PowerMin.Equal(other.PowerMin) {
		return false
	}

	if !v.Preamble.Equal(other.Preamble) {
		return false
	}

	return true
}

func (v Band24Value) Type(ctx context.Context) attr.Type {
	return Band24Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Band24Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"allow_rrm_disable": basetypes.BoolType{},
		"ant_gain":          basetypes.Int64Type{},
		"antenna_mode":      basetypes.StringType{},
		"bandwidth":         basetypes.Int64Type{},
		"channel":           basetypes.Int64Type{},
		"channels": basetypes.ListType{
			ElemType: types.Int64Type,
		},
		"disabled":  basetypes.BoolType{},
		"power":     basetypes.Int64Type{},
		"power_max": basetypes.Int64Type{},
		"power_min": basetypes.Int64Type{},
		"preamble":  basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = Band5Type{}

type Band5Type struct {
	basetypes.ObjectType
}

func (t Band5Type) Equal(o attr.Type) bool {
	other, ok := o.(Band5Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Band5Type) String() string {
	return "Band5Type"
}

func (t Band5Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	allowRrmDisableAttribute, ok := attributes["allow_rrm_disable"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allow_rrm_disable is missing from object`)

		return nil, diags
	}

	allowRrmDisableVal, ok := allowRrmDisableAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allow_rrm_disable expected to be basetypes.BoolValue, was: %T`, allowRrmDisableAttribute))
	}

	antGainAttribute, ok := attributes["ant_gain"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ant_gain is missing from object`)

		return nil, diags
	}

	antGainVal, ok := antGainAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ant_gain expected to be basetypes.Int64Value, was: %T`, antGainAttribute))
	}

	antennaModeAttribute, ok := attributes["antenna_mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`antenna_mode is missing from object`)

		return nil, diags
	}

	antennaModeVal, ok := antennaModeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`antenna_mode expected to be basetypes.StringValue, was: %T`, antennaModeAttribute))
	}

	bandwidthAttribute, ok := attributes["bandwidth"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bandwidth is missing from object`)

		return nil, diags
	}

	bandwidthVal, ok := bandwidthAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bandwidth expected to be basetypes.Int64Value, was: %T`, bandwidthAttribute))
	}

	channelAttribute, ok := attributes["channel"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`channel is missing from object`)

		return nil, diags
	}

	channelVal, ok := channelAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`channel expected to be basetypes.Int64Value, was: %T`, channelAttribute))
	}

	channelsAttribute, ok := attributes["channels"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`channels is missing from object`)

		return nil, diags
	}

	channelsVal, ok := channelsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`channels expected to be basetypes.ListValue, was: %T`, channelsAttribute))
	}

	disabledAttribute, ok := attributes["disabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disabled is missing from object`)

		return nil, diags
	}

	disabledVal, ok := disabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disabled expected to be basetypes.BoolValue, was: %T`, disabledAttribute))
	}

	powerAttribute, ok := attributes["power"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`power is missing from object`)

		return nil, diags
	}

	powerVal, ok := powerAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`power expected to be basetypes.Int64Value, was: %T`, powerAttribute))
	}

	powerMaxAttribute, ok := attributes["power_max"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`power_max is missing from object`)

		return nil, diags
	}

	powerMaxVal, ok := powerMaxAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`power_max expected to be basetypes.Int64Value, was: %T`, powerMaxAttribute))
	}

	powerMinAttribute, ok := attributes["power_min"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`power_min is missing from object`)

		return nil, diags
	}

	powerMinVal, ok := powerMinAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`power_min expected to be basetypes.Int64Value, was: %T`, powerMinAttribute))
	}

	preambleAttribute, ok := attributes["preamble"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`preamble is missing from object`)

		return nil, diags
	}

	preambleVal, ok := preambleAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`preamble expected to be basetypes.StringValue, was: %T`, preambleAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Band5Value{
		AllowRrmDisable: allowRrmDisableVal,
		AntGain:         antGainVal,
		AntennaMode:     antennaModeVal,
		Bandwidth:       bandwidthVal,
		Channel:         channelVal,
		Channels:        channelsVal,
		Disabled:        disabledVal,
		Power:           powerVal,
		PowerMax:        powerMaxVal,
		PowerMin:        powerMinVal,
		Preamble:        preambleVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewBand5ValueNull() Band5Value {
	return Band5Value{
		state: attr.ValueStateNull,
	}
}

func NewBand5ValueUnknown() Band5Value {
	return Band5Value{
		state: attr.ValueStateUnknown,
	}
}

func NewBand5Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Band5Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Band5Value Attribute Value",
				"While creating a Band5Value value, a missing attribute value was detected. "+
					"A Band5Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Band5Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Band5Value Attribute Type",
				"While creating a Band5Value value, an invalid attribute value was detected. "+
					"A Band5Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Band5Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Band5Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Band5Value Attribute Value",
				"While creating a Band5Value value, an extra attribute value was detected. "+
					"A Band5Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Band5Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewBand5ValueUnknown(), diags
	}

	allowRrmDisableAttribute, ok := attributes["allow_rrm_disable"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allow_rrm_disable is missing from object`)

		return NewBand5ValueUnknown(), diags
	}

	allowRrmDisableVal, ok := allowRrmDisableAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allow_rrm_disable expected to be basetypes.BoolValue, was: %T`, allowRrmDisableAttribute))
	}

	antGainAttribute, ok := attributes["ant_gain"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ant_gain is missing from object`)

		return NewBand5ValueUnknown(), diags
	}

	antGainVal, ok := antGainAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ant_gain expected to be basetypes.Int64Value, was: %T`, antGainAttribute))
	}

	antennaModeAttribute, ok := attributes["antenna_mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`antenna_mode is missing from object`)

		return NewBand5ValueUnknown(), diags
	}

	antennaModeVal, ok := antennaModeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`antenna_mode expected to be basetypes.StringValue, was: %T`, antennaModeAttribute))
	}

	bandwidthAttribute, ok := attributes["bandwidth"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bandwidth is missing from object`)

		return NewBand5ValueUnknown(), diags
	}

	bandwidthVal, ok := bandwidthAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bandwidth expected to be basetypes.Int64Value, was: %T`, bandwidthAttribute))
	}

	channelAttribute, ok := attributes["channel"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`channel is missing from object`)

		return NewBand5ValueUnknown(), diags
	}

	channelVal, ok := channelAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`channel expected to be basetypes.Int64Value, was: %T`, channelAttribute))
	}

	channelsAttribute, ok := attributes["channels"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`channels is missing from object`)

		return NewBand5ValueUnknown(), diags
	}

	channelsVal, ok := channelsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`channels expected to be basetypes.ListValue, was: %T`, channelsAttribute))
	}

	disabledAttribute, ok := attributes["disabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disabled is missing from object`)

		return NewBand5ValueUnknown(), diags
	}

	disabledVal, ok := disabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disabled expected to be basetypes.BoolValue, was: %T`, disabledAttribute))
	}

	powerAttribute, ok := attributes["power"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`power is missing from object`)

		return NewBand5ValueUnknown(), diags
	}

	powerVal, ok := powerAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`power expected to be basetypes.Int64Value, was: %T`, powerAttribute))
	}

	powerMaxAttribute, ok := attributes["power_max"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`power_max is missing from object`)

		return NewBand5ValueUnknown(), diags
	}

	powerMaxVal, ok := powerMaxAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`power_max expected to be basetypes.Int64Value, was: %T`, powerMaxAttribute))
	}

	powerMinAttribute, ok := attributes["power_min"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`power_min is missing from object`)

		return NewBand5ValueUnknown(), diags
	}

	powerMinVal, ok := powerMinAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`power_min expected to be basetypes.Int64Value, was: %T`, powerMinAttribute))
	}

	preambleAttribute, ok := attributes["preamble"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`preamble is missing from object`)

		return NewBand5ValueUnknown(), diags
	}

	preambleVal, ok := preambleAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`preamble expected to be basetypes.StringValue, was: %T`, preambleAttribute))
	}

	if diags.HasError() {
		return NewBand5ValueUnknown(), diags
	}

	return Band5Value{
		AllowRrmDisable: allowRrmDisableVal,
		AntGain:         antGainVal,
		AntennaMode:     antennaModeVal,
		Bandwidth:       bandwidthVal,
		Channel:         channelVal,
		Channels:        channelsVal,
		Disabled:        disabledVal,
		Power:           powerVal,
		PowerMax:        powerMaxVal,
		PowerMin:        powerMinVal,
		Preamble:        preambleVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewBand5ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Band5Value {
	object, diags := NewBand5Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewBand5ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Band5Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewBand5ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewBand5ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewBand5ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewBand5ValueMust(Band5Value{}.AttributeTypes(ctx), attributes), nil
}

func (t Band5Type) ValueType(ctx context.Context) attr.Value {
	return Band5Value{}
}

var _ basetypes.ObjectValuable = Band5Value{}

type Band5Value struct {
	AllowRrmDisable basetypes.BoolValue   `tfsdk:"allow_rrm_disable"`
	AntGain         basetypes.Int64Value  `tfsdk:"ant_gain"`
	AntennaMode     basetypes.StringValue `tfsdk:"antenna_mode"`
	Bandwidth       basetypes.Int64Value  `tfsdk:"bandwidth"`
	Channel         basetypes.Int64Value  `tfsdk:"channel"`
	Channels        basetypes.ListValue   `tfsdk:"channels"`
	Disabled        basetypes.BoolValue   `tfsdk:"disabled"`
	Power           basetypes.Int64Value  `tfsdk:"power"`
	PowerMax        basetypes.Int64Value  `tfsdk:"power_max"`
	PowerMin        basetypes.Int64Value  `tfsdk:"power_min"`
	Preamble        basetypes.StringValue `tfsdk:"preamble"`
	state           attr.ValueState
}

func (v Band5Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 11)

	var val tftypes.Value
	var err error

	attrTypes["allow_rrm_disable"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["ant_gain"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["antenna_mode"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["bandwidth"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["channel"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["channels"] = basetypes.ListType{
		ElemType: types.Int64Type,
	}.TerraformType(ctx)
	attrTypes["disabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["power"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["power_max"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["power_min"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["preamble"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 11)

		val, err = v.AllowRrmDisable.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["allow_rrm_disable"] = val

		val, err = v.AntGain.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ant_gain"] = val

		val, err = v.AntennaMode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["antenna_mode"] = val

		val, err = v.Bandwidth.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bandwidth"] = val

		val, err = v.Channel.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["channel"] = val

		val, err = v.Channels.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["channels"] = val

		val, err = v.Disabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["disabled"] = val

		val, err = v.Power.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["power"] = val

		val, err = v.PowerMax.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["power_max"] = val

		val, err = v.PowerMin.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["power_min"] = val

		val, err = v.Preamble.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["preamble"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Band5Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Band5Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Band5Value) String() string {
	return "Band5Value"
}

func (v Band5Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var channelsVal basetypes.ListValue
	switch {
	case v.Channels.IsUnknown():
		channelsVal = types.ListUnknown(types.Int64Type)
	case v.Channels.IsNull():
		channelsVal = types.ListNull(types.Int64Type)
	default:
		var d diag.Diagnostics
		channelsVal, d = types.ListValue(types.Int64Type, v.Channels.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"allow_rrm_disable": basetypes.BoolType{},
			"ant_gain":          basetypes.Int64Type{},
			"antenna_mode":      basetypes.StringType{},
			"bandwidth":         basetypes.Int64Type{},
			"channel":           basetypes.Int64Type{},
			"channels": basetypes.ListType{
				ElemType: types.Int64Type,
			},
			"disabled":  basetypes.BoolType{},
			"power":     basetypes.Int64Type{},
			"power_max": basetypes.Int64Type{},
			"power_min": basetypes.Int64Type{},
			"preamble":  basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"allow_rrm_disable": basetypes.BoolType{},
		"ant_gain":          basetypes.Int64Type{},
		"antenna_mode":      basetypes.StringType{},
		"bandwidth":         basetypes.Int64Type{},
		"channel":           basetypes.Int64Type{},
		"channels": basetypes.ListType{
			ElemType: types.Int64Type,
		},
		"disabled":  basetypes.BoolType{},
		"power":     basetypes.Int64Type{},
		"power_max": basetypes.Int64Type{},
		"power_min": basetypes.Int64Type{},
		"preamble":  basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"allow_rrm_disable": v.AllowRrmDisable,
			"ant_gain":          v.AntGain,
			"antenna_mode":      v.AntennaMode,
			"bandwidth":         v.Bandwidth,
			"channel":           v.Channel,
			"channels":          channelsVal,
			"disabled":          v.Disabled,
			"power":             v.Power,
			"power_max":         v.PowerMax,
			"power_min":         v.PowerMin,
			"preamble":          v.Preamble,
		})

	return objVal, diags
}

func (v Band5Value) Equal(o attr.Value) bool {
	other, ok := o.(Band5Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AllowRrmDisable.Equal(other.AllowRrmDisable) {
		return false
	}

	if !v.AntGain.Equal(other.AntGain) {
		return false
	}

	if !v.AntennaMode.Equal(other.AntennaMode) {
		return false
	}

	if !v.Bandwidth.Equal(other.Bandwidth) {
		return false
	}

	if !v.Channel.Equal(other.Channel) {
		return false
	}

	if !v.Channels.Equal(other.Channels) {
		return false
	}

	if !v.Disabled.Equal(other.Disabled) {
		return false
	}

	if !v.Power.Equal(other.Power) {
		return false
	}

	if !v.PowerMax.Equal(other.PowerMax) {
		return false
	}

	if !v.PowerMin.Equal(other.PowerMin) {
		return false
	}

	if !v.Preamble.Equal(other.Preamble) {
		return false
	}

	return true
}

func (v Band5Value) Type(ctx context.Context) attr.Type {
	return Band5Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Band5Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"allow_rrm_disable": basetypes.BoolType{},
		"ant_gain":          basetypes.Int64Type{},
		"antenna_mode":      basetypes.StringType{},
		"bandwidth":         basetypes.Int64Type{},
		"channel":           basetypes.Int64Type{},
		"channels": basetypes.ListType{
			ElemType: types.Int64Type,
		},
		"disabled":  basetypes.BoolType{},
		"power":     basetypes.Int64Type{},
		"power_max": basetypes.Int64Type{},
		"power_min": basetypes.Int64Type{},
		"preamble":  basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = Band5On24RadioType{}

type Band5On24RadioType struct {
	basetypes.ObjectType
}

func (t Band5On24RadioType) Equal(o attr.Type) bool {
	other, ok := o.(Band5On24RadioType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Band5On24RadioType) String() string {
	return "Band5On24RadioType"
}

func (t Band5On24RadioType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	allowRrmDisableAttribute, ok := attributes["allow_rrm_disable"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allow_rrm_disable is missing from object`)

		return nil, diags
	}

	allowRrmDisableVal, ok := allowRrmDisableAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allow_rrm_disable expected to be basetypes.BoolValue, was: %T`, allowRrmDisableAttribute))
	}

	antGainAttribute, ok := attributes["ant_gain"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ant_gain is missing from object`)

		return nil, diags
	}

	antGainVal, ok := antGainAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ant_gain expected to be basetypes.Int64Value, was: %T`, antGainAttribute))
	}

	antennaModeAttribute, ok := attributes["antenna_mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`antenna_mode is missing from object`)

		return nil, diags
	}

	antennaModeVal, ok := antennaModeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`antenna_mode expected to be basetypes.StringValue, was: %T`, antennaModeAttribute))
	}

	bandwidthAttribute, ok := attributes["bandwidth"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bandwidth is missing from object`)

		return nil, diags
	}

	bandwidthVal, ok := bandwidthAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bandwidth expected to be basetypes.Int64Value, was: %T`, bandwidthAttribute))
	}

	channelAttribute, ok := attributes["channel"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`channel is missing from object`)

		return nil, diags
	}

	channelVal, ok := channelAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`channel expected to be basetypes.Int64Value, was: %T`, channelAttribute))
	}

	channelsAttribute, ok := attributes["channels"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`channels is missing from object`)

		return nil, diags
	}

	channelsVal, ok := channelsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`channels expected to be basetypes.ListValue, was: %T`, channelsAttribute))
	}

	disabledAttribute, ok := attributes["disabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disabled is missing from object`)

		return nil, diags
	}

	disabledVal, ok := disabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disabled expected to be basetypes.BoolValue, was: %T`, disabledAttribute))
	}

	powerAttribute, ok := attributes["power"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`power is missing from object`)

		return nil, diags
	}

	powerVal, ok := powerAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`power expected to be basetypes.Int64Value, was: %T`, powerAttribute))
	}

	powerMaxAttribute, ok := attributes["power_max"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`power_max is missing from object`)

		return nil, diags
	}

	powerMaxVal, ok := powerMaxAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`power_max expected to be basetypes.Int64Value, was: %T`, powerMaxAttribute))
	}

	powerMinAttribute, ok := attributes["power_min"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`power_min is missing from object`)

		return nil, diags
	}

	powerMinVal, ok := powerMinAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`power_min expected to be basetypes.Int64Value, was: %T`, powerMinAttribute))
	}

	preambleAttribute, ok := attributes["preamble"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`preamble is missing from object`)

		return nil, diags
	}

	preambleVal, ok := preambleAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`preamble expected to be basetypes.StringValue, was: %T`, preambleAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Band5On24RadioValue{
		AllowRrmDisable: allowRrmDisableVal,
		AntGain:         antGainVal,
		AntennaMode:     antennaModeVal,
		Bandwidth:       bandwidthVal,
		Channel:         channelVal,
		Channels:        channelsVal,
		Disabled:        disabledVal,
		Power:           powerVal,
		PowerMax:        powerMaxVal,
		PowerMin:        powerMinVal,
		Preamble:        preambleVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewBand5On24RadioValueNull() Band5On24RadioValue {
	return Band5On24RadioValue{
		state: attr.ValueStateNull,
	}
}

func NewBand5On24RadioValueUnknown() Band5On24RadioValue {
	return Band5On24RadioValue{
		state: attr.ValueStateUnknown,
	}
}

func NewBand5On24RadioValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Band5On24RadioValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Band5On24RadioValue Attribute Value",
				"While creating a Band5On24RadioValue value, a missing attribute value was detected. "+
					"A Band5On24RadioValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Band5On24RadioValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Band5On24RadioValue Attribute Type",
				"While creating a Band5On24RadioValue value, an invalid attribute value was detected. "+
					"A Band5On24RadioValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Band5On24RadioValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Band5On24RadioValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Band5On24RadioValue Attribute Value",
				"While creating a Band5On24RadioValue value, an extra attribute value was detected. "+
					"A Band5On24RadioValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Band5On24RadioValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewBand5On24RadioValueUnknown(), diags
	}

	allowRrmDisableAttribute, ok := attributes["allow_rrm_disable"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allow_rrm_disable is missing from object`)

		return NewBand5On24RadioValueUnknown(), diags
	}

	allowRrmDisableVal, ok := allowRrmDisableAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allow_rrm_disable expected to be basetypes.BoolValue, was: %T`, allowRrmDisableAttribute))
	}

	antGainAttribute, ok := attributes["ant_gain"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ant_gain is missing from object`)

		return NewBand5On24RadioValueUnknown(), diags
	}

	antGainVal, ok := antGainAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ant_gain expected to be basetypes.Int64Value, was: %T`, antGainAttribute))
	}

	antennaModeAttribute, ok := attributes["antenna_mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`antenna_mode is missing from object`)

		return NewBand5On24RadioValueUnknown(), diags
	}

	antennaModeVal, ok := antennaModeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`antenna_mode expected to be basetypes.StringValue, was: %T`, antennaModeAttribute))
	}

	bandwidthAttribute, ok := attributes["bandwidth"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bandwidth is missing from object`)

		return NewBand5On24RadioValueUnknown(), diags
	}

	bandwidthVal, ok := bandwidthAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bandwidth expected to be basetypes.Int64Value, was: %T`, bandwidthAttribute))
	}

	channelAttribute, ok := attributes["channel"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`channel is missing from object`)

		return NewBand5On24RadioValueUnknown(), diags
	}

	channelVal, ok := channelAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`channel expected to be basetypes.Int64Value, was: %T`, channelAttribute))
	}

	channelsAttribute, ok := attributes["channels"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`channels is missing from object`)

		return NewBand5On24RadioValueUnknown(), diags
	}

	channelsVal, ok := channelsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`channels expected to be basetypes.ListValue, was: %T`, channelsAttribute))
	}

	disabledAttribute, ok := attributes["disabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disabled is missing from object`)

		return NewBand5On24RadioValueUnknown(), diags
	}

	disabledVal, ok := disabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disabled expected to be basetypes.BoolValue, was: %T`, disabledAttribute))
	}

	powerAttribute, ok := attributes["power"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`power is missing from object`)

		return NewBand5On24RadioValueUnknown(), diags
	}

	powerVal, ok := powerAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`power expected to be basetypes.Int64Value, was: %T`, powerAttribute))
	}

	powerMaxAttribute, ok := attributes["power_max"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`power_max is missing from object`)

		return NewBand5On24RadioValueUnknown(), diags
	}

	powerMaxVal, ok := powerMaxAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`power_max expected to be basetypes.Int64Value, was: %T`, powerMaxAttribute))
	}

	powerMinAttribute, ok := attributes["power_min"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`power_min is missing from object`)

		return NewBand5On24RadioValueUnknown(), diags
	}

	powerMinVal, ok := powerMinAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`power_min expected to be basetypes.Int64Value, was: %T`, powerMinAttribute))
	}

	preambleAttribute, ok := attributes["preamble"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`preamble is missing from object`)

		return NewBand5On24RadioValueUnknown(), diags
	}

	preambleVal, ok := preambleAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`preamble expected to be basetypes.StringValue, was: %T`, preambleAttribute))
	}

	if diags.HasError() {
		return NewBand5On24RadioValueUnknown(), diags
	}

	return Band5On24RadioValue{
		AllowRrmDisable: allowRrmDisableVal,
		AntGain:         antGainVal,
		AntennaMode:     antennaModeVal,
		Bandwidth:       bandwidthVal,
		Channel:         channelVal,
		Channels:        channelsVal,
		Disabled:        disabledVal,
		Power:           powerVal,
		PowerMax:        powerMaxVal,
		PowerMin:        powerMinVal,
		Preamble:        preambleVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewBand5On24RadioValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Band5On24RadioValue {
	object, diags := NewBand5On24RadioValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewBand5On24RadioValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Band5On24RadioType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewBand5On24RadioValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewBand5On24RadioValueUnknown(), nil
	}

	if in.IsNull() {
		return NewBand5On24RadioValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewBand5On24RadioValueMust(Band5On24RadioValue{}.AttributeTypes(ctx), attributes), nil
}

func (t Band5On24RadioType) ValueType(ctx context.Context) attr.Value {
	return Band5On24RadioValue{}
}

var _ basetypes.ObjectValuable = Band5On24RadioValue{}

type Band5On24RadioValue struct {
	AllowRrmDisable basetypes.BoolValue   `tfsdk:"allow_rrm_disable"`
	AntGain         basetypes.Int64Value  `tfsdk:"ant_gain"`
	AntennaMode     basetypes.StringValue `tfsdk:"antenna_mode"`
	Bandwidth       basetypes.Int64Value  `tfsdk:"bandwidth"`
	Channel         basetypes.Int64Value  `tfsdk:"channel"`
	Channels        basetypes.ListValue   `tfsdk:"channels"`
	Disabled        basetypes.BoolValue   `tfsdk:"disabled"`
	Power           basetypes.Int64Value  `tfsdk:"power"`
	PowerMax        basetypes.Int64Value  `tfsdk:"power_max"`
	PowerMin        basetypes.Int64Value  `tfsdk:"power_min"`
	Preamble        basetypes.StringValue `tfsdk:"preamble"`
	state           attr.ValueState
}

func (v Band5On24RadioValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 11)

	var val tftypes.Value
	var err error

	attrTypes["allow_rrm_disable"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["ant_gain"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["antenna_mode"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["bandwidth"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["channel"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["channels"] = basetypes.ListType{
		ElemType: types.Int64Type,
	}.TerraformType(ctx)
	attrTypes["disabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["power"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["power_max"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["power_min"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["preamble"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 11)

		val, err = v.AllowRrmDisable.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["allow_rrm_disable"] = val

		val, err = v.AntGain.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ant_gain"] = val

		val, err = v.AntennaMode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["antenna_mode"] = val

		val, err = v.Bandwidth.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bandwidth"] = val

		val, err = v.Channel.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["channel"] = val

		val, err = v.Channels.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["channels"] = val

		val, err = v.Disabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["disabled"] = val

		val, err = v.Power.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["power"] = val

		val, err = v.PowerMax.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["power_max"] = val

		val, err = v.PowerMin.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["power_min"] = val

		val, err = v.Preamble.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["preamble"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Band5On24RadioValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Band5On24RadioValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Band5On24RadioValue) String() string {
	return "Band5On24RadioValue"
}

func (v Band5On24RadioValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var channelsVal basetypes.ListValue
	switch {
	case v.Channels.IsUnknown():
		channelsVal = types.ListUnknown(types.Int64Type)
	case v.Channels.IsNull():
		channelsVal = types.ListNull(types.Int64Type)
	default:
		var d diag.Diagnostics
		channelsVal, d = types.ListValue(types.Int64Type, v.Channels.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"allow_rrm_disable": basetypes.BoolType{},
			"ant_gain":          basetypes.Int64Type{},
			"antenna_mode":      basetypes.StringType{},
			"bandwidth":         basetypes.Int64Type{},
			"channel":           basetypes.Int64Type{},
			"channels": basetypes.ListType{
				ElemType: types.Int64Type,
			},
			"disabled":  basetypes.BoolType{},
			"power":     basetypes.Int64Type{},
			"power_max": basetypes.Int64Type{},
			"power_min": basetypes.Int64Type{},
			"preamble":  basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"allow_rrm_disable": basetypes.BoolType{},
		"ant_gain":          basetypes.Int64Type{},
		"antenna_mode":      basetypes.StringType{},
		"bandwidth":         basetypes.Int64Type{},
		"channel":           basetypes.Int64Type{},
		"channels": basetypes.ListType{
			ElemType: types.Int64Type,
		},
		"disabled":  basetypes.BoolType{},
		"power":     basetypes.Int64Type{},
		"power_max": basetypes.Int64Type{},
		"power_min": basetypes.Int64Type{},
		"preamble":  basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"allow_rrm_disable": v.AllowRrmDisable,
			"ant_gain":          v.AntGain,
			"antenna_mode":      v.AntennaMode,
			"bandwidth":         v.Bandwidth,
			"channel":           v.Channel,
			"channels":          channelsVal,
			"disabled":          v.Disabled,
			"power":             v.Power,
			"power_max":         v.PowerMax,
			"power_min":         v.PowerMin,
			"preamble":          v.Preamble,
		})

	return objVal, diags
}

func (v Band5On24RadioValue) Equal(o attr.Value) bool {
	other, ok := o.(Band5On24RadioValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AllowRrmDisable.Equal(other.AllowRrmDisable) {
		return false
	}

	if !v.AntGain.Equal(other.AntGain) {
		return false
	}

	if !v.AntennaMode.Equal(other.AntennaMode) {
		return false
	}

	if !v.Bandwidth.Equal(other.Bandwidth) {
		return false
	}

	if !v.Channel.Equal(other.Channel) {
		return false
	}

	if !v.Channels.Equal(other.Channels) {
		return false
	}

	if !v.Disabled.Equal(other.Disabled) {
		return false
	}

	if !v.Power.Equal(other.Power) {
		return false
	}

	if !v.PowerMax.Equal(other.PowerMax) {
		return false
	}

	if !v.PowerMin.Equal(other.PowerMin) {
		return false
	}

	if !v.Preamble.Equal(other.Preamble) {
		return false
	}

	return true
}

func (v Band5On24RadioValue) Type(ctx context.Context) attr.Type {
	return Band5On24RadioType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Band5On24RadioValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"allow_rrm_disable": basetypes.BoolType{},
		"ant_gain":          basetypes.Int64Type{},
		"antenna_mode":      basetypes.StringType{},
		"bandwidth":         basetypes.Int64Type{},
		"channel":           basetypes.Int64Type{},
		"channels": basetypes.ListType{
			ElemType: types.Int64Type,
		},
		"disabled":  basetypes.BoolType{},
		"power":     basetypes.Int64Type{},
		"power_max": basetypes.Int64Type{},
		"power_min": basetypes.Int64Type{},
		"preamble":  basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = Band6Type{}

type Band6Type struct {
	basetypes.ObjectType
}

func (t Band6Type) Equal(o attr.Type) bool {
	other, ok := o.(Band6Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Band6Type) String() string {
	return "Band6Type"
}

func (t Band6Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	allowRrmDisableAttribute, ok := attributes["allow_rrm_disable"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allow_rrm_disable is missing from object`)

		return nil, diags
	}

	allowRrmDisableVal, ok := allowRrmDisableAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allow_rrm_disable expected to be basetypes.BoolValue, was: %T`, allowRrmDisableAttribute))
	}

	antGainAttribute, ok := attributes["ant_gain"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ant_gain is missing from object`)

		return nil, diags
	}

	antGainVal, ok := antGainAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ant_gain expected to be basetypes.Int64Value, was: %T`, antGainAttribute))
	}

	antennaModeAttribute, ok := attributes["antenna_mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`antenna_mode is missing from object`)

		return nil, diags
	}

	antennaModeVal, ok := antennaModeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`antenna_mode expected to be basetypes.StringValue, was: %T`, antennaModeAttribute))
	}

	bandwidthAttribute, ok := attributes["bandwidth"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bandwidth is missing from object`)

		return nil, diags
	}

	bandwidthVal, ok := bandwidthAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bandwidth expected to be basetypes.Int64Value, was: %T`, bandwidthAttribute))
	}

	channelAttribute, ok := attributes["channel"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`channel is missing from object`)

		return nil, diags
	}

	channelVal, ok := channelAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`channel expected to be basetypes.Int64Value, was: %T`, channelAttribute))
	}

	channelsAttribute, ok := attributes["channels"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`channels is missing from object`)

		return nil, diags
	}

	channelsVal, ok := channelsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`channels expected to be basetypes.ListValue, was: %T`, channelsAttribute))
	}

	disabledAttribute, ok := attributes["disabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disabled is missing from object`)

		return nil, diags
	}

	disabledVal, ok := disabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disabled expected to be basetypes.BoolValue, was: %T`, disabledAttribute))
	}

	powerAttribute, ok := attributes["power"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`power is missing from object`)

		return nil, diags
	}

	powerVal, ok := powerAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`power expected to be basetypes.Int64Value, was: %T`, powerAttribute))
	}

	powerMaxAttribute, ok := attributes["power_max"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`power_max is missing from object`)

		return nil, diags
	}

	powerMaxVal, ok := powerMaxAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`power_max expected to be basetypes.Int64Value, was: %T`, powerMaxAttribute))
	}

	powerMinAttribute, ok := attributes["power_min"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`power_min is missing from object`)

		return nil, diags
	}

	powerMinVal, ok := powerMinAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`power_min expected to be basetypes.Int64Value, was: %T`, powerMinAttribute))
	}

	preambleAttribute, ok := attributes["preamble"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`preamble is missing from object`)

		return nil, diags
	}

	preambleVal, ok := preambleAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`preamble expected to be basetypes.StringValue, was: %T`, preambleAttribute))
	}

	standardPowerAttribute, ok := attributes["standard_power"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`standard_power is missing from object`)

		return nil, diags
	}

	standardPowerVal, ok := standardPowerAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`standard_power expected to be basetypes.BoolValue, was: %T`, standardPowerAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Band6Value{
		AllowRrmDisable: allowRrmDisableVal,
		AntGain:         antGainVal,
		AntennaMode:     antennaModeVal,
		Bandwidth:       bandwidthVal,
		Channel:         channelVal,
		Channels:        channelsVal,
		Disabled:        disabledVal,
		Power:           powerVal,
		PowerMax:        powerMaxVal,
		PowerMin:        powerMinVal,
		Preamble:        preambleVal,
		StandardPower:   standardPowerVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewBand6ValueNull() Band6Value {
	return Band6Value{
		state: attr.ValueStateNull,
	}
}

func NewBand6ValueUnknown() Band6Value {
	return Band6Value{
		state: attr.ValueStateUnknown,
	}
}

func NewBand6Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Band6Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Band6Value Attribute Value",
				"While creating a Band6Value value, a missing attribute value was detected. "+
					"A Band6Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Band6Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Band6Value Attribute Type",
				"While creating a Band6Value value, an invalid attribute value was detected. "+
					"A Band6Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Band6Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Band6Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Band6Value Attribute Value",
				"While creating a Band6Value value, an extra attribute value was detected. "+
					"A Band6Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Band6Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewBand6ValueUnknown(), diags
	}

	allowRrmDisableAttribute, ok := attributes["allow_rrm_disable"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allow_rrm_disable is missing from object`)

		return NewBand6ValueUnknown(), diags
	}

	allowRrmDisableVal, ok := allowRrmDisableAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allow_rrm_disable expected to be basetypes.BoolValue, was: %T`, allowRrmDisableAttribute))
	}

	antGainAttribute, ok := attributes["ant_gain"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ant_gain is missing from object`)

		return NewBand6ValueUnknown(), diags
	}

	antGainVal, ok := antGainAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ant_gain expected to be basetypes.Int64Value, was: %T`, antGainAttribute))
	}

	antennaModeAttribute, ok := attributes["antenna_mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`antenna_mode is missing from object`)

		return NewBand6ValueUnknown(), diags
	}

	antennaModeVal, ok := antennaModeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`antenna_mode expected to be basetypes.StringValue, was: %T`, antennaModeAttribute))
	}

	bandwidthAttribute, ok := attributes["bandwidth"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bandwidth is missing from object`)

		return NewBand6ValueUnknown(), diags
	}

	bandwidthVal, ok := bandwidthAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bandwidth expected to be basetypes.Int64Value, was: %T`, bandwidthAttribute))
	}

	channelAttribute, ok := attributes["channel"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`channel is missing from object`)

		return NewBand6ValueUnknown(), diags
	}

	channelVal, ok := channelAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`channel expected to be basetypes.Int64Value, was: %T`, channelAttribute))
	}

	channelsAttribute, ok := attributes["channels"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`channels is missing from object`)

		return NewBand6ValueUnknown(), diags
	}

	channelsVal, ok := channelsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`channels expected to be basetypes.ListValue, was: %T`, channelsAttribute))
	}

	disabledAttribute, ok := attributes["disabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disabled is missing from object`)

		return NewBand6ValueUnknown(), diags
	}

	disabledVal, ok := disabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disabled expected to be basetypes.BoolValue, was: %T`, disabledAttribute))
	}

	powerAttribute, ok := attributes["power"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`power is missing from object`)

		return NewBand6ValueUnknown(), diags
	}

	powerVal, ok := powerAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`power expected to be basetypes.Int64Value, was: %T`, powerAttribute))
	}

	powerMaxAttribute, ok := attributes["power_max"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`power_max is missing from object`)

		return NewBand6ValueUnknown(), diags
	}

	powerMaxVal, ok := powerMaxAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`power_max expected to be basetypes.Int64Value, was: %T`, powerMaxAttribute))
	}

	powerMinAttribute, ok := attributes["power_min"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`power_min is missing from object`)

		return NewBand6ValueUnknown(), diags
	}

	powerMinVal, ok := powerMinAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`power_min expected to be basetypes.Int64Value, was: %T`, powerMinAttribute))
	}

	preambleAttribute, ok := attributes["preamble"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`preamble is missing from object`)

		return NewBand6ValueUnknown(), diags
	}

	preambleVal, ok := preambleAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`preamble expected to be basetypes.StringValue, was: %T`, preambleAttribute))
	}

	standardPowerAttribute, ok := attributes["standard_power"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`standard_power is missing from object`)

		return NewBand6ValueUnknown(), diags
	}

	standardPowerVal, ok := standardPowerAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`standard_power expected to be basetypes.BoolValue, was: %T`, standardPowerAttribute))
	}

	if diags.HasError() {
		return NewBand6ValueUnknown(), diags
	}

	return Band6Value{
		AllowRrmDisable: allowRrmDisableVal,
		AntGain:         antGainVal,
		AntennaMode:     antennaModeVal,
		Bandwidth:       bandwidthVal,
		Channel:         channelVal,
		Channels:        channelsVal,
		Disabled:        disabledVal,
		Power:           powerVal,
		PowerMax:        powerMaxVal,
		PowerMin:        powerMinVal,
		Preamble:        preambleVal,
		StandardPower:   standardPowerVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewBand6ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Band6Value {
	object, diags := NewBand6Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewBand6ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Band6Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewBand6ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewBand6ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewBand6ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewBand6ValueMust(Band6Value{}.AttributeTypes(ctx), attributes), nil
}

func (t Band6Type) ValueType(ctx context.Context) attr.Value {
	return Band6Value{}
}

var _ basetypes.ObjectValuable = Band6Value{}

type Band6Value struct {
	AllowRrmDisable basetypes.BoolValue   `tfsdk:"allow_rrm_disable"`
	AntGain         basetypes.Int64Value  `tfsdk:"ant_gain"`
	AntennaMode     basetypes.StringValue `tfsdk:"antenna_mode"`
	Bandwidth       basetypes.Int64Value  `tfsdk:"bandwidth"`
	Channel         basetypes.Int64Value  `tfsdk:"channel"`
	Channels        basetypes.ListValue   `tfsdk:"channels"`
	Disabled        basetypes.BoolValue   `tfsdk:"disabled"`
	Power           basetypes.Int64Value  `tfsdk:"power"`
	PowerMax        basetypes.Int64Value  `tfsdk:"power_max"`
	PowerMin        basetypes.Int64Value  `tfsdk:"power_min"`
	Preamble        basetypes.StringValue `tfsdk:"preamble"`
	StandardPower   basetypes.BoolValue   `tfsdk:"standard_power"`
	state           attr.ValueState
}

func (v Band6Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 12)

	var val tftypes.Value
	var err error

	attrTypes["allow_rrm_disable"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["ant_gain"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["antenna_mode"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["bandwidth"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["channel"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["channels"] = basetypes.ListType{
		ElemType: types.Int64Type,
	}.TerraformType(ctx)
	attrTypes["disabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["power"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["power_max"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["power_min"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["preamble"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["standard_power"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 12)

		val, err = v.AllowRrmDisable.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["allow_rrm_disable"] = val

		val, err = v.AntGain.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ant_gain"] = val

		val, err = v.AntennaMode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["antenna_mode"] = val

		val, err = v.Bandwidth.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bandwidth"] = val

		val, err = v.Channel.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["channel"] = val

		val, err = v.Channels.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["channels"] = val

		val, err = v.Disabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["disabled"] = val

		val, err = v.Power.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["power"] = val

		val, err = v.PowerMax.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["power_max"] = val

		val, err = v.PowerMin.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["power_min"] = val

		val, err = v.Preamble.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["preamble"] = val

		val, err = v.StandardPower.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["standard_power"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Band6Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Band6Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Band6Value) String() string {
	return "Band6Value"
}

func (v Band6Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var channelsVal basetypes.ListValue
	switch {
	case v.Channels.IsUnknown():
		channelsVal = types.ListUnknown(types.Int64Type)
	case v.Channels.IsNull():
		channelsVal = types.ListNull(types.Int64Type)
	default:
		var d diag.Diagnostics
		channelsVal, d = types.ListValue(types.Int64Type, v.Channels.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"allow_rrm_disable": basetypes.BoolType{},
			"ant_gain":          basetypes.Int64Type{},
			"antenna_mode":      basetypes.StringType{},
			"bandwidth":         basetypes.Int64Type{},
			"channel":           basetypes.Int64Type{},
			"channels": basetypes.ListType{
				ElemType: types.Int64Type,
			},
			"disabled":       basetypes.BoolType{},
			"power":          basetypes.Int64Type{},
			"power_max":      basetypes.Int64Type{},
			"power_min":      basetypes.Int64Type{},
			"preamble":       basetypes.StringType{},
			"standard_power": basetypes.BoolType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"allow_rrm_disable": basetypes.BoolType{},
		"ant_gain":          basetypes.Int64Type{},
		"antenna_mode":      basetypes.StringType{},
		"bandwidth":         basetypes.Int64Type{},
		"channel":           basetypes.Int64Type{},
		"channels": basetypes.ListType{
			ElemType: types.Int64Type,
		},
		"disabled":       basetypes.BoolType{},
		"power":          basetypes.Int64Type{},
		"power_max":      basetypes.Int64Type{},
		"power_min":      basetypes.Int64Type{},
		"preamble":       basetypes.StringType{},
		"standard_power": basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"allow_rrm_disable": v.AllowRrmDisable,
			"ant_gain":          v.AntGain,
			"antenna_mode":      v.AntennaMode,
			"bandwidth":         v.Bandwidth,
			"channel":           v.Channel,
			"channels":          channelsVal,
			"disabled":          v.Disabled,
			"power":             v.Power,
			"power_max":         v.PowerMax,
			"power_min":         v.PowerMin,
			"preamble":          v.Preamble,
			"standard_power":    v.StandardPower,
		})

	return objVal, diags
}

func (v Band6Value) Equal(o attr.Value) bool {
	other, ok := o.(Band6Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AllowRrmDisable.Equal(other.AllowRrmDisable) {
		return false
	}

	if !v.AntGain.Equal(other.AntGain) {
		return false
	}

	if !v.AntennaMode.Equal(other.AntennaMode) {
		return false
	}

	if !v.Bandwidth.Equal(other.Bandwidth) {
		return false
	}

	if !v.Channel.Equal(other.Channel) {
		return false
	}

	if !v.Channels.Equal(other.Channels) {
		return false
	}

	if !v.Disabled.Equal(other.Disabled) {
		return false
	}

	if !v.Power.Equal(other.Power) {
		return false
	}

	if !v.PowerMax.Equal(other.PowerMax) {
		return false
	}

	if !v.PowerMin.Equal(other.PowerMin) {
		return false
	}

	if !v.Preamble.Equal(other.Preamble) {
		return false
	}

	if !v.StandardPower.Equal(other.StandardPower) {
		return false
	}

	return true
}

func (v Band6Value) Type(ctx context.Context) attr.Type {
	return Band6Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Band6Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"allow_rrm_disable": basetypes.BoolType{},
		"ant_gain":          basetypes.Int64Type{},
		"antenna_mode":      basetypes.StringType{},
		"bandwidth":         basetypes.Int64Type{},
		"channel":           basetypes.Int64Type{},
		"channels": basetypes.ListType{
			ElemType: types.Int64Type,
		},
		"disabled":       basetypes.BoolType{},
		"power":          basetypes.Int64Type{},
		"power_max":      basetypes.Int64Type{},
		"power_min":      basetypes.Int64Type{},
		"preamble":       basetypes.StringType{},
		"standard_power": basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = UplinkPortConfigType{}

type UplinkPortConfigType struct {
	basetypes.ObjectType
}

func (t UplinkPortConfigType) Equal(o attr.Type) bool {
	other, ok := o.(UplinkPortConfigType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t UplinkPortConfigType) String() string {
	return "UplinkPortConfigType"
}

func (t UplinkPortConfigType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	dot1xAttribute, ok := attributes["dot1x"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dot1x is missing from object`)

		return nil, diags
	}

	dot1xVal, ok := dot1xAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dot1x expected to be basetypes.BoolValue, was: %T`, dot1xAttribute))
	}

	keepWlansUpIfDownAttribute, ok := attributes["keep_wlans_up_if_down"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keep_wlans_up_if_down is missing from object`)

		return nil, diags
	}

	keepWlansUpIfDownVal, ok := keepWlansUpIfDownAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keep_wlans_up_if_down expected to be basetypes.BoolValue, was: %T`, keepWlansUpIfDownAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return UplinkPortConfigValue{
		Dot1x:             dot1xVal,
		KeepWlansUpIfDown: keepWlansUpIfDownVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewUplinkPortConfigValueNull() UplinkPortConfigValue {
	return UplinkPortConfigValue{
		state: attr.ValueStateNull,
	}
}

func NewUplinkPortConfigValueUnknown() UplinkPortConfigValue {
	return UplinkPortConfigValue{
		state: attr.ValueStateUnknown,
	}
}

func NewUplinkPortConfigValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (UplinkPortConfigValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing UplinkPortConfigValue Attribute Value",
				"While creating a UplinkPortConfigValue value, a missing attribute value was detected. "+
					"A UplinkPortConfigValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("UplinkPortConfigValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid UplinkPortConfigValue Attribute Type",
				"While creating a UplinkPortConfigValue value, an invalid attribute value was detected. "+
					"A UplinkPortConfigValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("UplinkPortConfigValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("UplinkPortConfigValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra UplinkPortConfigValue Attribute Value",
				"While creating a UplinkPortConfigValue value, an extra attribute value was detected. "+
					"A UplinkPortConfigValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra UplinkPortConfigValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewUplinkPortConfigValueUnknown(), diags
	}

	dot1xAttribute, ok := attributes["dot1x"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dot1x is missing from object`)

		return NewUplinkPortConfigValueUnknown(), diags
	}

	dot1xVal, ok := dot1xAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dot1x expected to be basetypes.BoolValue, was: %T`, dot1xAttribute))
	}

	keepWlansUpIfDownAttribute, ok := attributes["keep_wlans_up_if_down"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keep_wlans_up_if_down is missing from object`)

		return NewUplinkPortConfigValueUnknown(), diags
	}

	keepWlansUpIfDownVal, ok := keepWlansUpIfDownAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keep_wlans_up_if_down expected to be basetypes.BoolValue, was: %T`, keepWlansUpIfDownAttribute))
	}

	if diags.HasError() {
		return NewUplinkPortConfigValueUnknown(), diags
	}

	return UplinkPortConfigValue{
		Dot1x:             dot1xVal,
		KeepWlansUpIfDown: keepWlansUpIfDownVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewUplinkPortConfigValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) UplinkPortConfigValue {
	object, diags := NewUplinkPortConfigValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewUplinkPortConfigValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t UplinkPortConfigType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewUplinkPortConfigValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewUplinkPortConfigValueUnknown(), nil
	}

	if in.IsNull() {
		return NewUplinkPortConfigValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewUplinkPortConfigValueMust(UplinkPortConfigValue{}.AttributeTypes(ctx), attributes), nil
}

func (t UplinkPortConfigType) ValueType(ctx context.Context) attr.Value {
	return UplinkPortConfigValue{}
}

var _ basetypes.ObjectValuable = UplinkPortConfigValue{}

type UplinkPortConfigValue struct {
	Dot1x             basetypes.BoolValue `tfsdk:"dot1x"`
	KeepWlansUpIfDown basetypes.BoolValue `tfsdk:"keep_wlans_up_if_down"`
	state             attr.ValueState
}

func (v UplinkPortConfigValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["dot1x"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["keep_wlans_up_if_down"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Dot1x.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dot1x"] = val

		val, err = v.KeepWlansUpIfDown.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["keep_wlans_up_if_down"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v UplinkPortConfigValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v UplinkPortConfigValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v UplinkPortConfigValue) String() string {
	return "UplinkPortConfigValue"
}

func (v UplinkPortConfigValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"dot1x":                 basetypes.BoolType{},
		"keep_wlans_up_if_down": basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"dot1x":                 v.Dot1x,
			"keep_wlans_up_if_down": v.KeepWlansUpIfDown,
		})

	return objVal, diags
}

func (v UplinkPortConfigValue) Equal(o attr.Value) bool {
	other, ok := o.(UplinkPortConfigValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Dot1x.Equal(other.Dot1x) {
		return false
	}

	if !v.KeepWlansUpIfDown.Equal(other.KeepWlansUpIfDown) {
		return false
	}

	return true
}

func (v UplinkPortConfigValue) Type(ctx context.Context) attr.Type {
	return UplinkPortConfigType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v UplinkPortConfigValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"dot1x":                 basetypes.BoolType{},
		"keep_wlans_up_if_down": basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = UsbConfigType{}

type UsbConfigType struct {
	basetypes.ObjectType
}

func (t UsbConfigType) Equal(o attr.Type) bool {
	other, ok := o.(UsbConfigType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t UsbConfigType) String() string {
	return "UsbConfigType"
}

func (t UsbConfigType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	cacertAttribute, ok := attributes["cacert"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cacert is missing from object`)

		return nil, diags
	}

	cacertVal, ok := cacertAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cacert expected to be basetypes.StringValue, was: %T`, cacertAttribute))
	}

	channelAttribute, ok := attributes["channel"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`channel is missing from object`)

		return nil, diags
	}

	channelVal, ok := channelAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`channel expected to be basetypes.Int64Value, was: %T`, channelAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	hostAttribute, ok := attributes["host"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`host is missing from object`)

		return nil, diags
	}

	hostVal, ok := hostAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`host expected to be basetypes.StringValue, was: %T`, hostAttribute))
	}

	portAttribute, ok := attributes["port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port is missing from object`)

		return nil, diags
	}

	portVal, ok := portAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port expected to be basetypes.Int64Value, was: %T`, portAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	verifyCertAttribute, ok := attributes["verify_cert"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`verify_cert is missing from object`)

		return nil, diags
	}

	verifyCertVal, ok := verifyCertAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`verify_cert expected to be basetypes.BoolValue, was: %T`, verifyCertAttribute))
	}

	vlanIdAttribute, ok := attributes["vlan_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan_id is missing from object`)

		return nil, diags
	}

	vlanIdVal, ok := vlanIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan_id expected to be basetypes.Int64Value, was: %T`, vlanIdAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return UsbConfigValue{
		Cacert:        cacertVal,
		Channel:       channelVal,
		Enabled:       enabledVal,
		Host:          hostVal,
		Port:          portVal,
		UsbConfigType: typeVal,
		VerifyCert:    verifyCertVal,
		VlanId:        vlanIdVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewUsbConfigValueNull() UsbConfigValue {
	return UsbConfigValue{
		state: attr.ValueStateNull,
	}
}

func NewUsbConfigValueUnknown() UsbConfigValue {
	return UsbConfigValue{
		state: attr.ValueStateUnknown,
	}
}

func NewUsbConfigValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (UsbConfigValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing UsbConfigValue Attribute Value",
				"While creating a UsbConfigValue value, a missing attribute value was detected. "+
					"A UsbConfigValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("UsbConfigValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid UsbConfigValue Attribute Type",
				"While creating a UsbConfigValue value, an invalid attribute value was detected. "+
					"A UsbConfigValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("UsbConfigValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("UsbConfigValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra UsbConfigValue Attribute Value",
				"While creating a UsbConfigValue value, an extra attribute value was detected. "+
					"A UsbConfigValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra UsbConfigValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewUsbConfigValueUnknown(), diags
	}

	cacertAttribute, ok := attributes["cacert"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cacert is missing from object`)

		return NewUsbConfigValueUnknown(), diags
	}

	cacertVal, ok := cacertAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cacert expected to be basetypes.StringValue, was: %T`, cacertAttribute))
	}

	channelAttribute, ok := attributes["channel"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`channel is missing from object`)

		return NewUsbConfigValueUnknown(), diags
	}

	channelVal, ok := channelAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`channel expected to be basetypes.Int64Value, was: %T`, channelAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewUsbConfigValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	hostAttribute, ok := attributes["host"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`host is missing from object`)

		return NewUsbConfigValueUnknown(), diags
	}

	hostVal, ok := hostAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`host expected to be basetypes.StringValue, was: %T`, hostAttribute))
	}

	portAttribute, ok := attributes["port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port is missing from object`)

		return NewUsbConfigValueUnknown(), diags
	}

	portVal, ok := portAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port expected to be basetypes.Int64Value, was: %T`, portAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewUsbConfigValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	verifyCertAttribute, ok := attributes["verify_cert"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`verify_cert is missing from object`)

		return NewUsbConfigValueUnknown(), diags
	}

	verifyCertVal, ok := verifyCertAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`verify_cert expected to be basetypes.BoolValue, was: %T`, verifyCertAttribute))
	}

	vlanIdAttribute, ok := attributes["vlan_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan_id is missing from object`)

		return NewUsbConfigValueUnknown(), diags
	}

	vlanIdVal, ok := vlanIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan_id expected to be basetypes.Int64Value, was: %T`, vlanIdAttribute))
	}

	if diags.HasError() {
		return NewUsbConfigValueUnknown(), diags
	}

	return UsbConfigValue{
		Cacert:        cacertVal,
		Channel:       channelVal,
		Enabled:       enabledVal,
		Host:          hostVal,
		Port:          portVal,
		UsbConfigType: typeVal,
		VerifyCert:    verifyCertVal,
		VlanId:        vlanIdVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewUsbConfigValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) UsbConfigValue {
	object, diags := NewUsbConfigValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewUsbConfigValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t UsbConfigType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewUsbConfigValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewUsbConfigValueUnknown(), nil
	}

	if in.IsNull() {
		return NewUsbConfigValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewUsbConfigValueMust(UsbConfigValue{}.AttributeTypes(ctx), attributes), nil
}

func (t UsbConfigType) ValueType(ctx context.Context) attr.Value {
	return UsbConfigValue{}
}

var _ basetypes.ObjectValuable = UsbConfigValue{}

type UsbConfigValue struct {
	Cacert        basetypes.StringValue `tfsdk:"cacert"`
	Channel       basetypes.Int64Value  `tfsdk:"channel"`
	Enabled       basetypes.BoolValue   `tfsdk:"enabled"`
	Host          basetypes.StringValue `tfsdk:"host"`
	Port          basetypes.Int64Value  `tfsdk:"port"`
	UsbConfigType basetypes.StringValue `tfsdk:"type"`
	VerifyCert    basetypes.BoolValue   `tfsdk:"verify_cert"`
	VlanId        basetypes.Int64Value  `tfsdk:"vlan_id"`
	state         attr.ValueState
}

func (v UsbConfigValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 8)

	var val tftypes.Value
	var err error

	attrTypes["cacert"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["channel"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["host"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["port"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["verify_cert"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["vlan_id"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 8)

		val, err = v.Cacert.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cacert"] = val

		val, err = v.Channel.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["channel"] = val

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.Host.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["host"] = val

		val, err = v.Port.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port"] = val

		val, err = v.UsbConfigType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		val, err = v.VerifyCert.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["verify_cert"] = val

		val, err = v.VlanId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vlan_id"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v UsbConfigValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v UsbConfigValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v UsbConfigValue) String() string {
	return "UsbConfigValue"
}

func (v UsbConfigValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"cacert":      basetypes.StringType{},
		"channel":     basetypes.Int64Type{},
		"enabled":     basetypes.BoolType{},
		"host":        basetypes.StringType{},
		"port":        basetypes.Int64Type{},
		"type":        basetypes.StringType{},
		"verify_cert": basetypes.BoolType{},
		"vlan_id":     basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"cacert":      v.Cacert,
			"channel":     v.Channel,
			"enabled":     v.Enabled,
			"host":        v.Host,
			"port":        v.Port,
			"type":        v.UsbConfigType,
			"verify_cert": v.VerifyCert,
			"vlan_id":     v.VlanId,
		})

	return objVal, diags
}

func (v UsbConfigValue) Equal(o attr.Value) bool {
	other, ok := o.(UsbConfigValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Cacert.Equal(other.Cacert) {
		return false
	}

	if !v.Channel.Equal(other.Channel) {
		return false
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.Host.Equal(other.Host) {
		return false
	}

	if !v.Port.Equal(other.Port) {
		return false
	}

	if !v.UsbConfigType.Equal(other.UsbConfigType) {
		return false
	}

	if !v.VerifyCert.Equal(other.VerifyCert) {
		return false
	}

	if !v.VlanId.Equal(other.VlanId) {
		return false
	}

	return true
}

func (v UsbConfigValue) Type(ctx context.Context) attr.Type {
	return UsbConfigType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v UsbConfigValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"cacert":      basetypes.StringType{},
		"channel":     basetypes.Int64Type{},
		"enabled":     basetypes.BoolType{},
		"host":        basetypes.StringType{},
		"port":        basetypes.Int64Type{},
		"type":        basetypes.StringType{},
		"verify_cert": basetypes.BoolType{},
		"vlan_id":     basetypes.Int64Type{},
	}
}
