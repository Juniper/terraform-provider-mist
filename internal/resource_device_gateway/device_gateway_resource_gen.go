// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package resource_device_gateway

import (
	"context"
	"fmt"
	"github.com/Juniper/terraform-provider-mist/internal/validators"
	"github.com/hashicorp/terraform-plugin-framework-validators/int64validator"
	"github.com/hashicorp/terraform-plugin-framework-validators/listvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/mapvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/objectvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/booldefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/int64default"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/listdefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/objectdefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
)

func DeviceGatewayResourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"additional_config_cmds": schema.ListAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Description:         "additional CLI commands to append to the generated Junos config. **Note**: no check is done",
				MarkdownDescription: "additional CLI commands to append to the generated Junos config. **Note**: no check is done",
				Validators: []validator.List{
					listvalidator.SizeAtLeast(1),
				},
			},
			"bgp_config": schema.MapNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"auth_key": schema.StringAttribute{
							Optional: true,
						},
						"bfd_minimum_interval": schema.Int64Attribute{
							Optional:            true,
							Computed:            true,
							Description:         "When bfd_multiplier is configured alone. Default:\n  * 1000 if `type`==`external`\n  * 350 `type`==`internal`",
							MarkdownDescription: "When bfd_multiplier is configured alone. Default:\n  * 1000 if `type`==`external`\n  * 350 `type`==`internal`",
							Validators: []validator.Int64{
								int64validator.Between(1, 255000),
							},
							Default: int64default.StaticInt64(350),
						},
						"bfd_multiplier": schema.Int64Attribute{
							Optional:            true,
							Computed:            true,
							Description:         "When bfd_minimum_interval_is_configured alone",
							MarkdownDescription: "When bfd_minimum_interval_is_configured alone",
							Validators: []validator.Int64{
								int64validator.Between(1, 255),
							},
							Default: int64default.StaticInt64(3),
						},
						"disable_bfd": schema.BoolAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "BFD provides faster path failure detection and is enabled by default",
							MarkdownDescription: "BFD provides faster path failure detection and is enabled by default",
							Default:             booldefault.StaticBool(false),
						},
						"export": schema.StringAttribute{
							Optional: true,
						},
						"export_policy": schema.StringAttribute{
							Optional:            true,
							Description:         "Default export policies if no per-neighbor policies defined",
							MarkdownDescription: "Default export policies if no per-neighbor policies defined",
						},
						"extended_v4_nexthop": schema.BoolAttribute{
							Optional:            true,
							Description:         "By default, either inet/net6 unicast depending on neighbor IP family (v4 or v6). For v6 neighbors, to exchange v4 nexthop, which allows dual-stack support, enable this",
							MarkdownDescription: "By default, either inet/net6 unicast depending on neighbor IP family (v4 or v6). For v6 neighbors, to exchange v4 nexthop, which allows dual-stack support, enable this",
						},
						"graceful_restart_time": schema.Int64Attribute{
							Optional:            true,
							Computed:            true,
							Description:         "`0` means disable",
							MarkdownDescription: "`0` means disable",
							Validators: []validator.Int64{
								int64validator.Between(0, 4095),
							},
							Default: int64default.StaticInt64(0),
						},
						"hold_time": schema.Int64Attribute{
							Optional: true,
							Computed: true,
							Validators: []validator.Int64{
								int64validator.Between(0, 65535),
							},
							Default: int64default.StaticInt64(90),
						},
						"import": schema.StringAttribute{
							Optional: true,
						},
						"import_policy": schema.StringAttribute{
							Optional:            true,
							Description:         "Default import policies if no per-neighbor policies defined",
							MarkdownDescription: "Default import policies if no per-neighbor policies defined",
						},
						"local_as": schema.StringAttribute{
							Optional:            true,
							Description:         "Local AS. Value must be in range 1-4294967295 or a variable (e.g. `{{as_variable}}`)",
							MarkdownDescription: "Local AS. Value must be in range 1-4294967295 or a variable (e.g. `{{as_variable}}`)",
							Validators: []validator.String{
								stringvalidator.Any(
									mistvalidator.ParseInt(1, 4294967295),
									mistvalidator.ParseVar(),
								),
							},
						},
						"neighbor_as": schema.StringAttribute{
							Optional:            true,
							Description:         "Neighbor AS. Value must be in range 1-4294967295 or a variable (e.g. `{{as_variable}}`)",
							MarkdownDescription: "Neighbor AS. Value must be in range 1-4294967295 or a variable (e.g. `{{as_variable}}`)",
							Validators: []validator.String{
								stringvalidator.Any(
									mistvalidator.ParseInt(1, 4294967295),
									mistvalidator.ParseVar(),
								),
							},
						},
						"neighbors": schema.MapNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"disabled": schema.BoolAttribute{
										Optional:            true,
										Computed:            true,
										Description:         "If true, the BGP session to this neighbor will be administratively disabled/shutdown",
										MarkdownDescription: "If true, the BGP session to this neighbor will be administratively disabled/shutdown",
										Default:             booldefault.StaticBool(false),
									},
									"export_policy": schema.StringAttribute{
										Optional: true,
									},
									"hold_time": schema.Int64Attribute{
										Optional: true,
										Computed: true,
										Validators: []validator.Int64{
											int64validator.Between(0, 65535),
										},
										Default: int64default.StaticInt64(90),
									},
									"import_policy": schema.StringAttribute{
										Optional: true,
									},
									"multihop_ttl": schema.Int64Attribute{
										Optional:            true,
										Description:         "Assuming BGP neighbor is directly connected",
										MarkdownDescription: "Assuming BGP neighbor is directly connected",
										Validators: []validator.Int64{
											int64validator.Between(0, 255),
										},
									},
									"neighbor_as": schema.StringAttribute{
										Optional:            true,
										Description:         "Neighbor AS. Value must be in range 1-4294967295 or a variable (e.g. `{{as_variable}}`)",
										MarkdownDescription: "Neighbor AS. Value must be in range 1-4294967295 or a variable (e.g. `{{as_variable}}`)",
										Validators: []validator.String{
											stringvalidator.Any(
												mistvalidator.ParseInt(1, 4294967295),
												mistvalidator.ParseVar(),
											),
										},
									},
								},
								CustomType: NeighborsType{
									ObjectType: types.ObjectType{
										AttrTypes: NeighborsValue{}.AttributeTypes(ctx),
									},
								},
							},
							Optional:            true,
							Description:         "If per-neighbor as is desired. Property key is the neighbor address",
							MarkdownDescription: "If per-neighbor as is desired. Property key is the neighbor address",
							Validators: []validator.Map{
								mapvalidator.SizeAtLeast(1),
							},
						},
						"networks": schema.ListAttribute{
							ElementType:         types.StringType,
							Optional:            true,
							Computed:            true,
							Description:         "If `type`!=`external`or `via`==`wan`networks where we expect BGP neighbor to connect to/from",
							MarkdownDescription: "If `type`!=`external`or `via`==`wan`networks where we expect BGP neighbor to connect to/from",
							Validators: []validator.List{
								listvalidator.Any(
									mistvalidator.ForbiddenWhenValueIs(path.MatchRelative().AtParent().AtMapKey("type"), types.StringValue("external")),
									mistvalidator.RequiredWhenValueIs(path.MatchRelative().AtParent().AtMapKey("via"), types.StringValue("wan")),
								),
							},
							Default: listdefault.StaticValue(types.ListNull(types.StringType)),
						},
						"no_private_as": schema.BoolAttribute{
							Optional: true,
							Computed: true,
							Default:  booldefault.StaticBool(false),
						},
						"no_readvertise_to_overlay": schema.BoolAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "By default, we'll re-advertise all learned BGP routers toward overlay",
							MarkdownDescription: "By default, we'll re-advertise all learned BGP routers toward overlay",
							Default:             booldefault.StaticBool(false),
						},
						"tunnel_name": schema.StringAttribute{
							Optional:            true,
							Description:         "If `type`==`tunnel`",
							MarkdownDescription: "If `type`==`tunnel`",
						},
						"type": schema.StringAttribute{
							Optional:            true,
							Description:         "enum: `external`, `internal`",
							MarkdownDescription: "enum: `external`, `internal`",
							Validators: []validator.String{
								stringvalidator.OneOf(
									"",
									"external",
									"internal",
								),
								stringvalidator.LengthAtLeast(1),
							},
						},
						"via": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "network name. enum: `lan`, `tunnel`, `vpn`, `wan`",
							MarkdownDescription: "network name. enum: `lan`, `tunnel`, `vpn`, `wan`",
							Validators: []validator.String{
								stringvalidator.OneOf(
									"",
									"lan",
									"tunnel",
									"vpn",
									"wan",
								),
							},
							Default: stringdefault.StaticString("lan"),
						},
						"vpn_name": schema.StringAttribute{
							Optional: true,
						},
						"wan_name": schema.StringAttribute{
							Optional:            true,
							Description:         "If `via`==`wan`",
							MarkdownDescription: "If `via`==`wan`",
							Validators: []validator.String{
								mistvalidator.RequiredWhenValueIs(path.MatchRelative().AtParent().AtName("via"), types.StringValue("wan")),
								mistvalidator.ForbiddenWhenValueIs(path.MatchRelative().AtParent().AtName("via"), types.StringValue("lan")),
								mistvalidator.ForbiddenWhenValueIs(path.MatchRelative().AtParent().AtName("via"), types.StringValue("wan")),
							},
						},
					},
					CustomType: BgpConfigType{
						ObjectType: types.ObjectType{
							AttrTypes: BgpConfigValue{}.AttributeTypes(ctx),
						},
					},
				},
				Optional: true,
				Validators: []validator.Map{
					mapvalidator.SizeAtLeast(1),
				},
			},
			"device_id": schema.StringAttribute{
				Required: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"dhcpd_config": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"config": schema.MapNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"dns_servers": schema.ListAttribute{
									ElementType:         types.StringType,
									Optional:            true,
									Computed:            true,
									Description:         "If `type`==`local` or `type6`==`local` - optional, if not defined, system one will be used",
									MarkdownDescription: "If `type`==`local` or `type6`==`local` - optional, if not defined, system one will be used",
									Validators: []validator.List{
										listvalidator.ValueStringsAre(stringvalidator.Any(mistvalidator.ParseIp(true, false), mistvalidator.ParseVar())),
									},
								},
								"dns_suffix": schema.ListAttribute{
									ElementType:         types.StringType,
									Optional:            true,
									Computed:            true,
									Description:         "If `type`==`local` or `type6`==`local` - optional, if not defined, system one will be used",
									MarkdownDescription: "If `type`==`local` or `type6`==`local` - optional, if not defined, system one will be used",
									Default:             listdefault.StaticValue(types.ListNull(types.StringType)),
								},
								"fixed_bindings": schema.MapNestedAttribute{
									NestedObject: schema.NestedAttributeObject{
										Attributes: map[string]schema.Attribute{
											"ip": schema.StringAttribute{
												Required: true,
												Validators: []validator.String{
													mistvalidator.ParseIp(true, false),
												},
											},
											"name": schema.StringAttribute{
												Optional: true,
											},
										},
										CustomType: FixedBindingsType{
											ObjectType: types.ObjectType{
												AttrTypes: FixedBindingsValue{}.AttributeTypes(ctx),
											},
										},
									},
									Optional:            true,
									Description:         "If `type`==`local` or `type6`==`local`. Property key is the MAC Address. Format is `[0-9a-f]{12}` (e.g. \"5684dae9ac8b\")",
									MarkdownDescription: "If `type`==`local` or `type6`==`local`. Property key is the MAC Address. Format is `[0-9a-f]{12}` (e.g. \"5684dae9ac8b\")",
									Validators: []validator.Map{
										mapvalidator.SizeAtLeast(1),
										mapvalidator.KeysAre(mistvalidator.ParseMac()),
									},
								},
								"gateway": schema.StringAttribute{
									Optional:            true,
									Description:         "If `type`==`local` - optional, `ip` will be used if not provided",
									MarkdownDescription: "If `type`==`local` - optional, `ip` will be used if not provided",
									Validators: []validator.String{
										stringvalidator.Any(mistvalidator.ParseIp(true, false), mistvalidator.ParseVar()),
									},
								},
								"ip_end": schema.StringAttribute{
									Optional:            true,
									Description:         "If `type`==`local`",
									MarkdownDescription: "If `type`==`local`",
									Validators: []validator.String{
										stringvalidator.Any(mistvalidator.ParseIp(true, false), mistvalidator.ParseVar()),
										mistvalidator.RequiredWhenValueIs(path.MatchRelative().AtParent().AtName("type"), types.StringValue("local")),
									},
								},
								"ip_end6": schema.StringAttribute{
									Optional:            true,
									Description:         "If `type6`==`local`",
									MarkdownDescription: "If `type6`==`local`",
									Validators: []validator.String{
										stringvalidator.Any(mistvalidator.ParseIp(false, true), mistvalidator.ParseVar()),
										mistvalidator.RequiredWhenValueIs(path.MatchRelative().AtParent().AtName("type6"), types.StringValue("local")),
									},
								},
								"ip_start": schema.StringAttribute{
									Optional:            true,
									Description:         "If `type`==`local`",
									MarkdownDescription: "If `type`==`local`",
									Validators: []validator.String{
										stringvalidator.Any(mistvalidator.ParseIp(true, false), mistvalidator.ParseVar()),
										mistvalidator.RequiredWhenValueIs(path.MatchRelative().AtParent().AtName("type"), types.StringValue("local")),
									},
								},
								"ip_start6": schema.StringAttribute{
									Optional:            true,
									Description:         "If `type6`==`local`",
									MarkdownDescription: "If `type6`==`local`",
									Validators: []validator.String{
										stringvalidator.Any(mistvalidator.ParseIp(false, true), mistvalidator.ParseVar()),
										mistvalidator.RequiredWhenValueIs(path.MatchRelative().AtParent().AtName("type6"), types.StringValue("local")),
									},
								},
								"lease_time": schema.Int64Attribute{
									Optional:            true,
									Computed:            true,
									Description:         "In seconds, lease time has to be between 3600 [1hr] - 604800 [1 week], default is 86400 [1 day]",
									MarkdownDescription: "In seconds, lease time has to be between 3600 [1hr] - 604800 [1 week], default is 86400 [1 day]",
									Validators: []validator.Int64{
										int64validator.Between(3600, 604800),
									},
									Default: int64default.StaticInt64(86400),
								},
								"options": schema.MapNestedAttribute{
									NestedObject: schema.NestedAttributeObject{
										Attributes: map[string]schema.Attribute{
											"type": schema.StringAttribute{
												Optional:            true,
												Description:         "enum: `boolean`, `hex`, `int16`, `int32`, `ip`, `string`, `uint16`, `uint32`",
												MarkdownDescription: "enum: `boolean`, `hex`, `int16`, `int32`, `ip`, `string`, `uint16`, `uint32`",
												Validators: []validator.String{
													stringvalidator.OneOf(
														"",
														"boolean",
														"hex",
														"int16",
														"int32",
														"ip",
														"string",
														"uint16",
														"uint32",
													),
												},
											},
											"value": schema.StringAttribute{
												Optional: true,
											},
										},
										CustomType: OptionsType{
											ObjectType: types.ObjectType{
												AttrTypes: OptionsValue{}.AttributeTypes(ctx),
											},
										},
									},
									Optional:            true,
									Description:         "If `type`==`local` or `type6`==`local`. Property key is the DHCP option number",
									MarkdownDescription: "If `type`==`local` or `type6`==`local`. Property key is the DHCP option number",
									Validators: []validator.Map{
										mapvalidator.SizeAtLeast(1),
									},
								},
								"server_id_override": schema.BoolAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "`server_id_override`==`true` means the device, when acts as DHCP relay and forwards DHCP responses from DHCP server to clients, \nshould overwrite the Sever Identifier option (i.e. DHCP option 54) in DHCP responses with its own IP address.",
									MarkdownDescription: "`server_id_override`==`true` means the device, when acts as DHCP relay and forwards DHCP responses from DHCP server to clients, \nshould overwrite the Sever Identifier option (i.e. DHCP option 54) in DHCP responses with its own IP address.",
									Default:             booldefault.StaticBool(false),
								},
								"servers": schema.ListAttribute{
									ElementType:         types.StringType,
									Optional:            true,
									Computed:            true,
									Description:         "If `type`==`relay`",
									MarkdownDescription: "If `type`==`relay`",
									Validators: []validator.List{
										listvalidator.ValueStringsAre(stringvalidator.Any(mistvalidator.ParseIp(false, false), mistvalidator.ParseVar())),
										mistvalidator.RequiredWhenValueIs(path.MatchRelative().AtParent().AtName("type"), types.StringValue("relay")),
									},
									Default: listdefault.StaticValue(types.ListNull(types.StringType)),
								},
								"servers6": schema.ListAttribute{
									ElementType:         types.StringType,
									Optional:            true,
									Computed:            true,
									Description:         "If `type6`==`relay`",
									MarkdownDescription: "If `type6`==`relay`",
									Validators: []validator.List{
										listvalidator.ValueStringsAre(stringvalidator.Any(mistvalidator.ParseIp(false, false), mistvalidator.ParseVar())),
										mistvalidator.RequiredWhenValueIs(path.MatchRelative().AtParent().AtName("type6"), types.StringValue("relay")),
									},
									Default: listdefault.StaticValue(types.ListNull(types.StringType)),
								},
								"type": schema.StringAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "enum: `local` (DHCP Server), `none`, `relay` (DHCP Relay)",
									MarkdownDescription: "enum: `local` (DHCP Server), `none`, `relay` (DHCP Relay)",
									Validators: []validator.String{
										stringvalidator.OneOf(
											"",
											"local",
											"none",
											"relay",
										),
									},
									Default: stringdefault.StaticString("local"),
								},
								"type6": schema.StringAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "enum: `local` (DHCP Server), `none`, `relay` (DHCP Relay)",
									MarkdownDescription: "enum: `local` (DHCP Server), `none`, `relay` (DHCP Relay)",
									Validators: []validator.String{
										stringvalidator.OneOf(
											"",
											"local",
											"none",
											"relay",
										),
									},
									Default: stringdefault.StaticString("none"),
								},
								"vendor_encapsulated": schema.MapNestedAttribute{
									NestedObject: schema.NestedAttributeObject{
										Attributes: map[string]schema.Attribute{
											"type": schema.StringAttribute{
												Optional:            true,
												Description:         "enum: `boolean`, `hex`, `int16`, `int32`, `ip`, `string`, `uint16`, `uint32`",
												MarkdownDescription: "enum: `boolean`, `hex`, `int16`, `int32`, `ip`, `string`, `uint16`, `uint32`",
												Validators: []validator.String{
													stringvalidator.OneOf(
														"",
														"boolean",
														"hex",
														"int16",
														"int32",
														"ip",
														"string",
														"uint16",
														"uint32",
													),
												},
											},
											"value": schema.StringAttribute{
												Optional: true,
											},
										},
										CustomType: VendorEncapsulatedType{
											ObjectType: types.ObjectType{
												AttrTypes: VendorEncapsulatedValue{}.AttributeTypes(ctx),
											},
										},
									},
									Optional:            true,
									Description:         "If `type`==`local` or `type6`==`local`. Property key is <enterprise number>:<sub option code>, with\n  * enterprise number: 1-65535 (https://www.iana.org/assignments/enterprise-numbers/enterprise-numbers)\n  * sub option code: 1-255, sub-option code",
									MarkdownDescription: "If `type`==`local` or `type6`==`local`. Property key is <enterprise number>:<sub option code>, with\n  * enterprise number: 1-65535 (https://www.iana.org/assignments/enterprise-numbers/enterprise-numbers)\n  * sub option code: 1-255, sub-option code",
									Validators: []validator.Map{
										mapvalidator.SizeAtLeast(1),
									},
								},
							},
							CustomType: ConfigType{
								ObjectType: types.ObjectType{
									AttrTypes: ConfigValue{}.AttributeTypes(ctx),
								},
							},
						},
						Optional:            true,
						Description:         "Property key is the network name",
						MarkdownDescription: "Property key is the network name",
						Validators: []validator.Map{
							mapvalidator.SizeAtLeast(1),
						},
					},
					"enabled": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "If set to `false`, disable the DHCP server",
						MarkdownDescription: "If set to `false`, disable the DHCP server",
						Default:             booldefault.StaticBool(true),
					},
				},
				CustomType: DhcpdConfigType{
					ObjectType: types.ObjectType{
						AttrTypes: DhcpdConfigValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
			},
			"dns_servers": schema.ListAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Description:         "Global dns settings. To keep compatibility, dns settings in `ip_config` and `oob_ip_config` will overwrite this setting",
				MarkdownDescription: "Global dns settings. To keep compatibility, dns settings in `ip_config` and `oob_ip_config` will overwrite this setting",
			},
			"dns_suffix": schema.ListAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Description:         "Global dns settings. To keep compatibility, dns settings in `ip_config` and `oob_ip_config` will overwrite this setting",
				MarkdownDescription: "Global dns settings. To keep compatibility, dns settings in `ip_config` and `oob_ip_config` will overwrite this setting",
			},
			"extra_routes": schema.MapNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"via": schema.StringAttribute{
							Required: true,
							Validators: []validator.String{
								stringvalidator.Any(mistvalidator.ParseIp(true, false), mistvalidator.ParseVar()),
							},
						},
					},
					CustomType: ExtraRoutesType{
						ObjectType: types.ObjectType{
							AttrTypes: ExtraRoutesValue{}.AttributeTypes(ctx),
						},
					},
				},
				Optional:            true,
				Description:         "Property key is the destination CIDR (e.g. \"10.0.0.0/8\"), the destination Network name or a variable (e.g. \"{{myvar}}\")",
				MarkdownDescription: "Property key is the destination CIDR (e.g. \"10.0.0.0/8\"), the destination Network name or a variable (e.g. \"{{myvar}}\")",
				Validators: []validator.Map{
					mapvalidator.SizeAtLeast(1),
				},
			},
			"extra_routes6": schema.MapNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"via": schema.StringAttribute{
							Required: true,
							Validators: []validator.String{
								stringvalidator.Any(mistvalidator.ParseIp(false, true), mistvalidator.ParseVar()),
							},
						},
					},
					CustomType: ExtraRoutes6Type{
						ObjectType: types.ObjectType{
							AttrTypes: ExtraRoutes6Value{}.AttributeTypes(ctx),
						},
					},
				},
				Optional:            true,
				Description:         "Property key is the destination CIDR (e.g. \"2a02:1234:420a:10c9::/64\"), the destination Network name or a variable (e.g. \"{{myvar}}\")",
				MarkdownDescription: "Property key is the destination CIDR (e.g. \"2a02:1234:420a:10c9::/64\"), the destination Network name or a variable (e.g. \"{{myvar}}\")",
				Validators: []validator.Map{
					mapvalidator.SizeAtLeast(1),
				},
			},
			"idp_profiles": schema.MapNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"base_profile": schema.StringAttribute{
							Optional:            true,
							Description:         "enum: `critical`, `standard`, `strict`",
							MarkdownDescription: "enum: `critical`, `standard`, `strict`",
							Validators: []validator.String{
								stringvalidator.OneOf(
									"",
									"critical",
									"standard",
									"strict",
								),
							},
						},
						"id": schema.StringAttribute{
							Optional:            true,
							Description:         "Unique ID of the object instance in the Mist Organization",
							MarkdownDescription: "Unique ID of the object instance in the Mist Organization",
						},
						"name": schema.StringAttribute{
							Optional: true,
						},
						"org_id": schema.StringAttribute{
							Optional: true,
						},
						"overwrites": schema.ListNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"action": schema.StringAttribute{
										Optional:            true,
										Computed:            true,
										Description:         "enum:\n  * alert (default)\n  * drop: silently dropping packets\n  * close: notify client/server to close connection",
										MarkdownDescription: "enum:\n  * alert (default)\n  * drop: silently dropping packets\n  * close: notify client/server to close connection",
										Validators: []validator.String{
											stringvalidator.OneOf(
												"",
												"alert",
												"close",
												"drop",
											),
										},
										Default: stringdefault.StaticString("alert"),
									},
									"matching": schema.SingleNestedAttribute{
										Attributes: map[string]schema.Attribute{
											"attack_name": schema.ListAttribute{
												ElementType: types.StringType,
												Optional:    true,
											},
											"dst_subnet": schema.ListAttribute{
												ElementType: types.StringType,
												Optional:    true,
											},
											"severity": schema.ListAttribute{
												ElementType: types.StringType,
												Optional:    true,
											},
										},
										CustomType: IpdProfileOverwriteMatchingType{
											ObjectType: types.ObjectType{
												AttrTypes: IpdProfileOverwriteMatchingValue{}.AttributeTypes(ctx),
											},
										},
										Optional: true,
									},
									"name": schema.StringAttribute{
										Optional: true,
									},
								},
								CustomType: OverwritesType{
									ObjectType: types.ObjectType{
										AttrTypes: OverwritesValue{}.AttributeTypes(ctx),
									},
								},
							},
							Optional: true,
						},
					},
					CustomType: IdpProfilesType{
						ObjectType: types.ObjectType{
							AttrTypes: IdpProfilesValue{}.AttributeTypes(ctx),
						},
					},
				},
				Optional:            true,
				Description:         "Property key is the profile name",
				MarkdownDescription: "Property key is the profile name",
				Validators: []validator.Map{
					mapvalidator.SizeAtLeast(1),
				},
			},
			"image1_url": schema.StringAttribute{
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"image2_url": schema.StringAttribute{
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"image3_url": schema.StringAttribute{
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"ip_configs": schema.MapNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"ip": schema.StringAttribute{
							Optional: true,
							Validators: []validator.String{
								stringvalidator.Any(mistvalidator.ParseIp(true, false), mistvalidator.ParseVar()),
								mistvalidator.RequiredWhenValueIs(path.MatchRelative().AtParent().AtName("type"), types.StringValue("static")),
								mistvalidator.ForbiddenWhenValueIs(path.MatchRelative().AtParent().AtName("type"), types.StringValue("dhcp")),
							},
						},
						"netmask": schema.StringAttribute{
							Optional: true,
							Validators: []validator.String{
								stringvalidator.Any(mistvalidator.ParseNetmask(false, false), mistvalidator.ParseVar()),
							},
						},
						"secondary_ips": schema.ListAttribute{
							ElementType:         types.StringType,
							Optional:            true,
							Computed:            true,
							Description:         "Optional list of secondary IPs in CIDR format",
							MarkdownDescription: "Optional list of secondary IPs in CIDR format",
							Default:             listdefault.StaticValue(types.ListNull(types.StringType)),
						},
						"type": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "enum: `dhcp`, `static`",
							MarkdownDescription: "enum: `dhcp`, `static`",
							Validators: []validator.String{
								stringvalidator.OneOf(
									"",
									"dhcp",
									"static",
								),
							},
							Default: stringdefault.StaticString("dhcp"),
						},
					},
					CustomType: IpConfigsType{
						ObjectType: types.ObjectType{
							AttrTypes: IpConfigsValue{}.AttributeTypes(ctx),
						},
					},
				},
				Optional:            true,
				Description:         "Property key is the network name",
				MarkdownDescription: "Property key is the network name",
				Validators: []validator.Map{
					mapvalidator.SizeAtLeast(1),
				},
			},
			"mac": schema.StringAttribute{
				Computed:            true,
				Description:         "Device MAC address",
				MarkdownDescription: "Device MAC address",
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"managed": schema.BoolAttribute{
				Optional: true,
			},
			"map_id": schema.StringAttribute{
				Optional:            true,
				Description:         "Map where the device belongs to",
				MarkdownDescription: "Map where the device belongs to",
			},
			"model": schema.StringAttribute{
				Computed:            true,
				Description:         "Device Model",
				MarkdownDescription: "Device Model",
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"msp_id": schema.StringAttribute{
				Optional: true,
			},
			"name": schema.StringAttribute{
				Required: true,
			},
			"networks": schema.ListNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"disallow_mist_services": schema.BoolAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "Whether to disallow Mist Devices in the network",
							MarkdownDescription: "Whether to disallow Mist Devices in the network",
							Default:             booldefault.StaticBool(false),
						},
						"gateway": schema.StringAttribute{
							Optional: true,
							Validators: []validator.String{
								stringvalidator.Any(mistvalidator.ParseIp(true, false), mistvalidator.ParseVar()),
							},
						},
						"gateway6": schema.StringAttribute{
							Optional: true,
							Validators: []validator.String{
								stringvalidator.Any(mistvalidator.ParseIp(false, true), mistvalidator.ParseVar()),
							},
						},
						"internal_access": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"enabled": schema.BoolAttribute{
									Optional: true,
								},
							},
							CustomType: InternalAccessType{
								ObjectType: types.ObjectType{
									AttrTypes: InternalAccessValue{}.AttributeTypes(ctx),
								},
							},
							Optional: true,
						},
						"internet_access": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"create_simple_service_policy": schema.BoolAttribute{
									Optional: true,
									Computed: true,
									Default:  booldefault.StaticBool(false),
								},
								"enabled": schema.BoolAttribute{
									Optional: true,
								},
								"destination_nat": schema.MapNestedAttribute{
									NestedObject: schema.NestedAttributeObject{
										Attributes: map[string]schema.Attribute{
											"internal_ip": schema.StringAttribute{
												Optional:            true,
												Description:         "The Destination NAT destination IP Address. Must be an IP (i.e. \"192.168.70.30\") or a Variable (i.e. \"{{myvar}}\")",
												MarkdownDescription: "The Destination NAT destination IP Address. Must be an IP (i.e. \"192.168.70.30\") or a Variable (i.e. \"{{myvar}}\")",
												Validators: []validator.String{
													stringvalidator.Any(
														mistvalidator.ParseIp(false, false),
														mistvalidator.ParseVar(),
													),
												},
											},
											"name": schema.StringAttribute{
												Optional: true,
											},
											"port": schema.StringAttribute{
												Optional:            true,
												Description:         "The Destination NAT destination IP Address. Must be a Port (i.e. \"443\") or a Variable (i.e. \"{{myvar}}\")",
												MarkdownDescription: "The Destination NAT destination IP Address. Must be a Port (i.e. \"443\") or a Variable (i.e. \"{{myvar}}\")",
												Validators: []validator.String{
													stringvalidator.Any(
														mistvalidator.ParseInt(0, 65535),
														mistvalidator.ParseVar(),
													),
												},
											},
											"wan_name": schema.StringAttribute{
												Optional:            true,
												Description:         "SRX Only. If not set, we configure the nat policies against all WAN ports for simplicity",
												MarkdownDescription: "SRX Only. If not set, we configure the nat policies against all WAN ports for simplicity",
											},
										},
										CustomType: InternetAccessDestinationNatType{
											ObjectType: types.ObjectType{
												AttrTypes: InternetAccessDestinationNatValue{}.AttributeTypes(ctx),
											},
										},
										Validators: []validator.Object{
											objectvalidator.AtLeastOneOf(
												path.MatchRelative().AtName("internal_ip"),
												path.MatchRelative().AtName("port"),
											),
										},
									},
									Optional:            true,
									Description:         "Property key can be an External IP (i.e. \"63.16.0.3\"), an External IP:Port (i.e. \"63.16.0.3:443\"), an External Port (i.e. \":443\"), an External CIDR (i.e. \"63.16.0.0/30\"), an External CIDR:Port (i.e. \"63.16.0.0/30:443\") or a Variable (i.e. \"{{myvar}}\"). At least one of the `internal_ip` or `port` must be defined",
									MarkdownDescription: "Property key can be an External IP (i.e. \"63.16.0.3\"), an External IP:Port (i.e. \"63.16.0.3:443\"), an External Port (i.e. \":443\"), an External CIDR (i.e. \"63.16.0.0/30\"), an External CIDR:Port (i.e. \"63.16.0.0/30:443\") or a Variable (i.e. \"{{myvar}}\"). At least one of the `internal_ip` or `port` must be defined",
									Validators: []validator.Map{
										mapvalidator.KeysAre(
											stringvalidator.Any(
												mistvalidator.ParseIp(false, false),
												mistvalidator.ParseIpPort(false, true),
												mistvalidator.ParseCidr(false, false),
												mistvalidator.ParseIpPort(false, true),
												mistvalidator.ParseVar(),
											),
										),
									},
								},
								"static_nat": schema.MapNestedAttribute{
									NestedObject: schema.NestedAttributeObject{
										Attributes: map[string]schema.Attribute{
											"internal_ip": schema.StringAttribute{
												Required:            true,
												Description:         "The Static NAT destination IP Address. Must be an IP Address (i.e. \"192.168.70.3\") or a Variable (i.e. \"{{myvar}}\")",
												MarkdownDescription: "The Static NAT destination IP Address. Must be an IP Address (i.e. \"192.168.70.3\") or a Variable (i.e. \"{{myvar}}\")",
												Validators: []validator.String{
													stringvalidator.Any(
														mistvalidator.ParseIp(false, false),
														mistvalidator.ParseCidr(false, false),
														mistvalidator.ParseVar(),
													),
												},
											},
											"name": schema.StringAttribute{
												Required: true,
											},
											"wan_name": schema.StringAttribute{
												Optional:            true,
												Description:         "SRX Only. If not set, we configure the nat policies against all WAN ports for simplicity. Can be a Variable (i.e. \"{{myvar}}\")",
												MarkdownDescription: "SRX Only. If not set, we configure the nat policies against all WAN ports for simplicity. Can be a Variable (i.e. \"{{myvar}}\")",
											},
										},
										CustomType: InternetAccessStaticNatType{
											ObjectType: types.ObjectType{
												AttrTypes: InternetAccessStaticNatValue{}.AttributeTypes(ctx),
											},
										},
									},
									Optional:            true,
									Description:         "Property key may be an External IP Address (i.e. \"63.16.0.3\"), a CIDR (i.e. \"63.16.0.12/20\") or a Variable (i.e. \"{{myvar}}\")",
									MarkdownDescription: "Property key may be an External IP Address (i.e. \"63.16.0.3\"), a CIDR (i.e. \"63.16.0.12/20\") or a Variable (i.e. \"{{myvar}}\")",
									Validators: []validator.Map{
										mapvalidator.KeysAre(
											stringvalidator.Any(
												mistvalidator.ParseIp(false, false),
												mistvalidator.ParseCidr(false, false),
												mistvalidator.ParseVar(),
											),
										),
									},
								},
								"restricted": schema.BoolAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "By default, all access is allowed, to only allow certain traffic, make `restricted`=`true` and define service_policies",
									MarkdownDescription: "By default, all access is allowed, to only allow certain traffic, make `restricted`=`true` and define service_policies",
									Default:             booldefault.StaticBool(false),
								},
							},
							CustomType: InternetAccessType{
								ObjectType: types.ObjectType{
									AttrTypes: InternetAccessValue{}.AttributeTypes(ctx),
								},
							},
							Optional:            true,
							Description:         "Whether this network has direct internet access",
							MarkdownDescription: "Whether this network has direct internet access",
						},
						"isolation": schema.BoolAttribute{
							Optional:            true,
							Description:         "Whether to allow clients in the network to talk to each other",
							MarkdownDescription: "Whether to allow clients in the network to talk to each other",
						},
						"multicast": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"disable_igmp": schema.BoolAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "If the network will only be the source of the multicast traffic, IGMP can be disabled",
									MarkdownDescription: "If the network will only be the source of the multicast traffic, IGMP can be disabled",
									Default:             booldefault.StaticBool(false),
								},
								"enabled": schema.BoolAttribute{
									Optional: true,
									Computed: true,
									Default:  booldefault.StaticBool(false),
								},
								"groups": schema.MapNestedAttribute{
									NestedObject: schema.NestedAttributeObject{
										Attributes: map[string]schema.Attribute{
											"rp_ip": schema.StringAttribute{
												Optional:            true,
												Description:         "RP (rendezvous point) IP Address",
												MarkdownDescription: "RP (rendezvous point) IP Address",
											},
										},
										CustomType: GroupsType{
											ObjectType: types.ObjectType{
												AttrTypes: GroupsValue{}.AttributeTypes(ctx),
											},
										},
									},
									Optional:            true,
									Description:         "Group address to RP (rendezvous point) mapping. Property Key is the CIDR (example \"225.1.0.3/32\")",
									MarkdownDescription: "Group address to RP (rendezvous point) mapping. Property Key is the CIDR (example \"225.1.0.3/32\")",
									Validators: []validator.Map{
										mapvalidator.SizeAtLeast(1),
									},
								},
							},
							CustomType: MulticastType{
								ObjectType: types.ObjectType{
									AttrTypes: MulticastValue{}.AttributeTypes(ctx),
								},
							},
							Optional:            true,
							Description:         "Whether to enable multicast support (only PIM-sparse mode is supported)",
							MarkdownDescription: "Whether to enable multicast support (only PIM-sparse mode is supported)",
						},
						"name": schema.StringAttribute{
							Required: true,
							Validators: []validator.String{
								stringvalidator.All(stringvalidator.LengthBetween(2, 32), mistvalidator.ParseName()),
							},
						},
						"routed_for_networks": schema.ListAttribute{
							ElementType:         types.StringType,
							Optional:            true,
							Description:         "For a Network (usually LAN), it can be routable to other networks (e.g. OSPF)",
							MarkdownDescription: "For a Network (usually LAN), it can be routable to other networks (e.g. OSPF)",
						},
						"subnet": schema.StringAttribute{
							Required: true,
							Validators: []validator.String{
								stringvalidator.Any(mistvalidator.ParseCidr(true, false), mistvalidator.ParseVar()),
							},
						},
						"subnet6": schema.StringAttribute{
							Optional: true,
							Validators: []validator.String{
								stringvalidator.Any(mistvalidator.ParseCidr(false, true), mistvalidator.ParseVar()),
							},
						},
						"tenants": schema.MapNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"addresses": schema.ListAttribute{
										ElementType: types.StringType,
										Optional:    true,
									},
								},
								CustomType: TenantsType{
									ObjectType: types.ObjectType{
										AttrTypes: TenantsValue{}.AttributeTypes(ctx),
									},
								},
							},
							Optional:            true,
							Description:         "Property key must be the user/tenant name (i.e. \"printer-1\") or a Variable (i.e. \"{{myvar}}\")",
							MarkdownDescription: "Property key must be the user/tenant name (i.e. \"printer-1\") or a Variable (i.e. \"{{myvar}}\")",
							Validators: []validator.Map{
								mapvalidator.SizeAtLeast(1),
							},
						},
						"vlan_id": schema.StringAttribute{
							Optional: true,
							Validators: []validator.String{
								stringvalidator.Any(mistvalidator.ParseInt(1, 4094), mistvalidator.ParseVar()),
							},
						},
						"vpn_access": schema.MapNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"advertised_subnet": schema.StringAttribute{
										Optional:            true,
										Description:         "If `routed`==`true`, whether to advertise an aggregated subnet toward HUB this is useful when there are multiple networks on SPOKE's side",
										MarkdownDescription: "If `routed`==`true`, whether to advertise an aggregated subnet toward HUB this is useful when there are multiple networks on SPOKE's side",
									},
									"allow_ping": schema.BoolAttribute{
										Optional:            true,
										Description:         "Whether to allow ping from vpn into this routed network",
										MarkdownDescription: "Whether to allow ping from vpn into this routed network",
									},
									"nat_pool": schema.StringAttribute{
										Optional:            true,
										Description:         "If `routed`==`false` (usually at Spoke), but some hosts needs to be reachable from Hub, a subnet is required to create and advertise the route to Hub",
										MarkdownDescription: "If `routed`==`false` (usually at Spoke), but some hosts needs to be reachable from Hub, a subnet is required to create and advertise the route to Hub",
									},
									"no_readvertise_to_lan_bgp": schema.BoolAttribute{
										Optional:            true,
										Computed:            true,
										Description:         "toward LAN-side BGP peers",
										MarkdownDescription: "toward LAN-side BGP peers",
										Default:             booldefault.StaticBool(false),
									},
									"no_readvertise_to_lan_ospf": schema.BoolAttribute{
										Optional:            true,
										Computed:            true,
										Description:         "toward LAN-side OSPF peers",
										MarkdownDescription: "toward LAN-side OSPF peers",
										Default:             booldefault.StaticBool(false),
									},
									"no_readvertise_to_overlay": schema.BoolAttribute{
										Optional:            true,
										Description:         "toward overlay, how HUB should deal with routes it received from Spokes",
										MarkdownDescription: "toward overlay, how HUB should deal with routes it received from Spokes",
									},
									"other_vrfs": schema.ListAttribute{
										ElementType:         types.StringType,
										Optional:            true,
										Computed:            true,
										Description:         "By default, the routes are only readvertised toward the same vrf on spoke. To allow it to be leaked to other vrfs",
										MarkdownDescription: "By default, the routes are only readvertised toward the same vrf on spoke. To allow it to be leaked to other vrfs",
										Default:             listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
									},
									"routed": schema.BoolAttribute{
										Optional:            true,
										Description:         "Whether this network is routable",
										MarkdownDescription: "Whether this network is routable",
									},
									"source_nat": schema.SingleNestedAttribute{
										Attributes: map[string]schema.Attribute{
											"external_ip": schema.StringAttribute{
												Optional: true,
											},
										},
										CustomType: SourceNatType{
											ObjectType: types.ObjectType{
												AttrTypes: SourceNatValue{}.AttributeTypes(ctx),
											},
										},
										Optional:            true,
										Computed:            true,
										Description:         "If `routed`==`false` (usually at Spoke), but some hosts needs to be reachable from Hub",
										MarkdownDescription: "If `routed`==`false` (usually at Spoke), but some hosts needs to be reachable from Hub",
									},
									"summarized_subnet": schema.StringAttribute{
										Optional:            true,
										Description:         "toward overlay, how HUB should deal with routes it received from Spokes",
										MarkdownDescription: "toward overlay, how HUB should deal with routes it received from Spokes",
									},
									"summarized_subnet_to_lan_bgp": schema.StringAttribute{
										Optional:            true,
										Description:         "toward LAN-side BGP peers",
										MarkdownDescription: "toward LAN-side BGP peers",
									},
									"summarized_subnet_to_lan_ospf": schema.StringAttribute{
										Optional:            true,
										Description:         "toward LAN-side OSPF peers",
										MarkdownDescription: "toward LAN-side OSPF peers",
									},
									"destination_nat": schema.MapNestedAttribute{
										NestedObject: schema.NestedAttributeObject{
											Attributes: map[string]schema.Attribute{
												"internal_ip": schema.StringAttribute{
													Optional:            true,
													Description:         "The Destination NAT destination IP Address. Must be an IP (i.e. \"192.168.70.30\") or a Variable (i.e. \"{{myvar}}\")",
													MarkdownDescription: "The Destination NAT destination IP Address. Must be an IP (i.e. \"192.168.70.30\") or a Variable (i.e. \"{{myvar}}\")",
													Validators: []validator.String{
														stringvalidator.Any(
															mistvalidator.ParseIp(false, false),
															mistvalidator.ParseVar(),
														),
													},
												},
												"name": schema.StringAttribute{
													Optional: true,
												},
												"port": schema.StringAttribute{
													Optional: true,
													Validators: []validator.String{
														stringvalidator.Any(
															mistvalidator.ParseInt(0, 65535),
															mistvalidator.ParseVar(),
														),
													},
												},
											},
											CustomType: VpnAccessDestinationNatType{
												ObjectType: types.ObjectType{
													AttrTypes: VpnAccessDestinationNatValue{}.AttributeTypes(ctx),
												},
											},
											Validators: []validator.Object{
												objectvalidator.AtLeastOneOf(
													path.MatchRelative().AtName("internal_ip"),
													path.MatchRelative().AtName("port"),
												),
											},
										},
										Optional:            true,
										Description:         "Property key can be an External IP (i.e. \"63.16.0.3\"), an External IP:Port (i.e. \"63.16.0.3:443\"), an External Port (i.e. \":443\"), an External CIDR (i.e. \"63.16.0.0/30\"), an External CIDR:Port (i.e. \"63.16.0.0/30:443\") or a Variable (i.e. \"{{myvar}}\"). At least one of the `internal_ip` or `port` must be defined",
										MarkdownDescription: "Property key can be an External IP (i.e. \"63.16.0.3\"), an External IP:Port (i.e. \"63.16.0.3:443\"), an External Port (i.e. \":443\"), an External CIDR (i.e. \"63.16.0.0/30\"), an External CIDR:Port (i.e. \"63.16.0.0/30:443\") or a Variable (i.e. \"{{myvar}}\"). At least one of the `internal_ip` or `port` must be defined",
										Validators: []validator.Map{
											mapvalidator.KeysAre(
												stringvalidator.Any(
													mistvalidator.ParseIp(false, false),
													mistvalidator.ParseIpPort(false, true),
													mistvalidator.ParseCidr(false, false),
													mistvalidator.ParseIpPort(false, true),
													mistvalidator.ParseVar(),
												),
											),
										},
									},
									"static_nat": schema.MapNestedAttribute{
										NestedObject: schema.NestedAttributeObject{
											Attributes: map[string]schema.Attribute{
												"internal_ip": schema.StringAttribute{
													Required:            true,
													Description:         "The Static NAT destination IP Address. Must be an IP Address (i.e. \"192.168.70.3\") or a Variable (i.e. \"{{myvar}}\")",
													MarkdownDescription: "The Static NAT destination IP Address. Must be an IP Address (i.e. \"192.168.70.3\") or a Variable (i.e. \"{{myvar}}\")",
													Validators: []validator.String{
														stringvalidator.Any(
															mistvalidator.ParseIp(false, false),
															mistvalidator.ParseCidr(false, false),
															mistvalidator.ParseVar(),
														),
													},
												},
												"name": schema.StringAttribute{
													Required: true,
												},
											},
											CustomType: VpnAccessStaticNatType{
												ObjectType: types.ObjectType{
													AttrTypes: VpnAccessStaticNatValue{}.AttributeTypes(ctx),
												},
											},
										},
										Optional:            true,
										Computed:            true,
										Description:         "Property key may be an External IP Address (i.e. \"63.16.0.3\"), a CIDR (i.e. \"63.16.0.12/20\") or a Variable (i.e. \"{{myvar}}\")",
										MarkdownDescription: "Property key may be an External IP Address (i.e. \"63.16.0.3\"), a CIDR (i.e. \"63.16.0.12/20\") or a Variable (i.e. \"{{myvar}}\")",
										Validators: []validator.Map{
											mapvalidator.KeysAre(
												stringvalidator.Any(
													mistvalidator.ParseIp(false, false),
													mistvalidator.ParseCidr(false, false),
													mistvalidator.ParseVar(),
												),
											),
										},
									},
								},
								CustomType: VpnAccessType{
									ObjectType: types.ObjectType{
										AttrTypes: VpnAccessValue{}.AttributeTypes(ctx),
									},
								},
							},
							Optional:            true,
							Description:         "Property key is the VPN name. Whether this network can be accessed from vpn",
							MarkdownDescription: "Property key is the VPN name. Whether this network can be accessed from vpn",
							Validators: []validator.Map{
								mapvalidator.SizeAtLeast(1),
							},
						},
					},
					CustomType: NetworksType{
						ObjectType: types.ObjectType{
							AttrTypes: NetworksValue{}.AttributeTypes(ctx),
						},
					},
				},
				Optional: true,
			},
			"notes": schema.StringAttribute{
				Optional: true,
			},
			"ntp_servers": schema.ListAttribute{
				ElementType: types.StringType,
				Optional:    true,
				Validators: []validator.List{
					listvalidator.UniqueValues(),
				},
			},
			"oob_ip_config": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"gateway": schema.StringAttribute{
						Optional:            true,
						Description:         "If `type`==`static`",
						MarkdownDescription: "If `type`==`static`",
						Validators: []validator.String{
							mistvalidator.ParseIp(true, false),
							mistvalidator.RequiredWhenValueIs(path.MatchRelative().AtParent().AtName("type"), types.StringValue("static")),
							mistvalidator.ForbiddenWhenValueIs(path.MatchRelative().AtParent().AtName("type"), types.StringValue("dhcp")),
						},
					},
					"ip": schema.StringAttribute{
						Optional:            true,
						Description:         "If `type`==`static`",
						MarkdownDescription: "If `type`==`static`",
						Validators: []validator.String{
							mistvalidator.ParseIp(true, false),
							mistvalidator.RequiredWhenValueIs(path.MatchRelative().AtParent().AtName("type"), types.StringValue("static")),
							mistvalidator.ForbiddenWhenValueIs(path.MatchRelative().AtParent().AtName("type"), types.StringValue("dhcp")),
						},
					},
					"netmask": schema.StringAttribute{
						Optional:            true,
						Description:         "If `type`==`static`",
						MarkdownDescription: "If `type`==`static`",
						Validators: []validator.String{
							stringvalidator.Any(mistvalidator.ParseNetmask(false, false), mistvalidator.ParseVar()),
							mistvalidator.RequiredWhenValueIs(path.MatchRelative().AtParent().AtName("type"), types.StringValue("static")),
							mistvalidator.ForbiddenWhenValueIs(path.MatchRelative().AtParent().AtName("type"), types.StringValue("dhcp")),
						},
					},
					"node1": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"gateway": schema.StringAttribute{
								Optional:            true,
								Description:         "If `type`==`static`",
								MarkdownDescription: "If `type`==`static`",
								Validators: []validator.String{
									mistvalidator.ParseIp(true, false),
									mistvalidator.RequiredWhenValueIs(path.MatchRelative().AtParent().AtName("type"), types.StringValue("static")),
									mistvalidator.ForbiddenWhenValueIs(path.MatchRelative().AtParent().AtName("type"), types.StringValue("dhcp")),
								},
							},
							"ip": schema.StringAttribute{
								Optional: true,
								Validators: []validator.String{
									mistvalidator.ParseIp(true, false),
									mistvalidator.RequiredWhenValueIs(path.MatchRelative().AtParent().AtName("type"), types.StringValue("static")),
									mistvalidator.ForbiddenWhenValueIs(path.MatchRelative().AtParent().AtName("type"), types.StringValue("dhcp")),
								},
							},
							"netmask": schema.StringAttribute{
								Optional:            true,
								Description:         "Used only if `subnet` is not specified in `networks`",
								MarkdownDescription: "Used only if `subnet` is not specified in `networks`",
								Validators: []validator.String{
									stringvalidator.Any(mistvalidator.ParseNetmask(false, false), mistvalidator.ParseVar()),
									mistvalidator.RequiredWhenValueIs(path.MatchRelative().AtParent().AtName("type"), types.StringValue("static")),
									mistvalidator.ForbiddenWhenValueIs(path.MatchRelative().AtParent().AtName("type"), types.StringValue("dhcp")),
								},
							},
							"type": schema.StringAttribute{
								Optional:            true,
								Computed:            true,
								Description:         "enum: `dhcp`, `static`",
								MarkdownDescription: "enum: `dhcp`, `static`",
								Validators: []validator.String{
									stringvalidator.OneOf(
										"",
										"dhcp",
										"static",
									),
								},
								Default: stringdefault.StaticString("dhcp"),
							},
							"use_mgmt_vrf": schema.BoolAttribute{
								Optional:            true,
								Description:         "If supported on the platform. If enabled, DNS will be using this routing-instance, too",
								MarkdownDescription: "If supported on the platform. If enabled, DNS will be using this routing-instance, too",
							},
							"use_mgmt_vrf_for_host_out": schema.BoolAttribute{
								Optional:            true,
								Description:         "Whether to use `mgmt_junos` for host-out traffic (NTP/TACPLUS/RADIUS/SYSLOG/SNMP), if alternative source network/ip is desired",
								MarkdownDescription: "Whether to use `mgmt_junos` for host-out traffic (NTP/TACPLUS/RADIUS/SYSLOG/SNMP), if alternative source network/ip is desired",
							},
							"vlan_id": schema.StringAttribute{
								Optional: true,
								Validators: []validator.String{
									stringvalidator.Any(mistvalidator.ParseInt(1, 4094), mistvalidator.ParseVar()),
								},
							},
						},
						CustomType: Node1Type{
							ObjectType: types.ObjectType{
								AttrTypes: Node1Value{}.AttributeTypes(ctx),
							},
						},
						Optional:            true,
						Computed:            true,
						Description:         "For HA Cluster, node1 can have different IP Config",
						MarkdownDescription: "For HA Cluster, node1 can have different IP Config",
						Default: objectdefault.StaticValue(
							types.ObjectValueMust(
								Node1Value{}.AttributeTypes(ctx),
								map[string]attr.Value{
									"gateway":                   types.StringNull(),
									"ip":                        types.StringNull(),
									"netmask":                   types.StringNull(),
									"type":                      types.StringValue("dhcp"),
									"use_mgmt_vrf":              types.BoolNull(),
									"use_mgmt_vrf_for_host_out": types.BoolNull(),
									"vlan_id":                   types.StringNull(),
								},
							),
						),
					},
					"type": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "enum: `dhcp`, `static`",
						MarkdownDescription: "enum: `dhcp`, `static`",
						Validators: []validator.String{
							stringvalidator.OneOf(
								"",
								"dhcp",
								"static",
							),
						},
						Default: stringdefault.StaticString("dhcp"),
					},
					"use_mgmt_vrf": schema.BoolAttribute{
						Optional:            true,
						Description:         "If supported on the platform. If enabled, DNS will be using this routing-instance, too",
						MarkdownDescription: "If supported on the platform. If enabled, DNS will be using this routing-instance, too",
					},
					"use_mgmt_vrf_for_host_out": schema.BoolAttribute{
						Optional:            true,
						Description:         "For host-out traffic (NTP/TACPLUS/RADIUS/SYSLOG/SNMP), if alternative source network/ip is desired",
						MarkdownDescription: "For host-out traffic (NTP/TACPLUS/RADIUS/SYSLOG/SNMP), if alternative source network/ip is desired",
					},
					"vlan_id": schema.StringAttribute{
						Optional: true,
						Validators: []validator.String{
							stringvalidator.Any(mistvalidator.ParseInt(1, 4094), mistvalidator.ParseVar()),
						},
					},
				},
				CustomType: OobIpConfigType{
					ObjectType: types.ObjectType{
						AttrTypes: OobIpConfigValue{}.AttributeTypes(ctx),
					},
				},
				Optional:            true,
				Computed:            true,
				Description:         "Out-of-band (vme/em0/fxp0) IP config",
				MarkdownDescription: "Out-of-band (vme/em0/fxp0) IP config",
				Default: objectdefault.StaticValue(
					types.ObjectValueMust(
						OobIpConfigValue{}.AttributeTypes(ctx),
						map[string]attr.Value{
							"gateway":                   types.StringNull(),
							"ip":                        types.StringNull(),
							"netmask":                   types.StringNull(),
							"type":                      types.StringValue("dhcp"),
							"use_mgmt_vrf":              types.BoolNull(),
							"use_mgmt_vrf_for_host_out": types.BoolNull(),
							"vlan_id":                   types.StringNull(),
							"node1": types.ObjectValueMust(
								Node1Value{}.AttributeTypes(ctx),
								map[string]attr.Value{
									"gateway":                   types.StringNull(),
									"ip":                        types.StringNull(),
									"netmask":                   types.StringNull(),
									"type":                      types.StringValue("dhcp"),
									"use_mgmt_vrf":              types.BoolNull(),
									"use_mgmt_vrf_for_host_out": types.BoolNull(),
									"vlan_id":                   types.StringNull(),
								},
							),
						},
					),
				),
			},
			"org_id": schema.StringAttribute{
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"path_preferences": schema.MapNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"paths": schema.ListNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"cost": schema.Int64Attribute{
										Optional: true,
									},
									"disabled": schema.BoolAttribute{
										Optional:            true,
										Description:         "For SSR Only. `true`, if this specific path is undesired",
										MarkdownDescription: "For SSR Only. `true`, if this specific path is undesired",
									},
									"gateway_ip": schema.StringAttribute{
										Optional:            true,
										Description:         "Only if `type`==`local`, if a different gateway is desired",
										MarkdownDescription: "Only if `type`==`local`, if a different gateway is desired",
										Validators: []validator.String{
											stringvalidator.Any(mistvalidator.ParseIp(false, false), mistvalidator.ParseVar()),
											mistvalidator.AllowedWhenValueIs(path.MatchRelative().AtParent().AtName("type"), types.StringValue("local")),
										},
									},
									"internet_access": schema.BoolAttribute{
										Optional:            true,
										Description:         "Only if `type`==`vpn`, if this vpn path can be used for internet",
										MarkdownDescription: "Only if `type`==`vpn`, if this vpn path can be used for internet",
										Validators: []validator.Bool{
											mistvalidator.AllowedWhenValueIs(path.MatchRelative().AtParent().AtName("type"), types.StringValue("vpn")),
										},
									},
									"name": schema.StringAttribute{
										Optional:            true,
										Description:         "Required when \n  * `type`==`vpn`: the name of the VPN Path to use \n  * `type`==`wan`: the name of the WAN interface to use",
										MarkdownDescription: "Required when \n  * `type`==`vpn`: the name of the VPN Path to use \n  * `type`==`wan`: the name of the WAN interface to use",
										Validators: []validator.String{
											mistvalidator.RequiredWhenValueIs(path.MatchRelative().AtParent().AtName("type"), types.StringValue("vpn")),
											mistvalidator.RequiredWhenValueIs(path.MatchRelative().AtParent().AtName("type"), types.StringValue("wan")),
										},
									},
									"networks": schema.ListAttribute{
										ElementType:         types.StringType,
										Optional:            true,
										Computed:            true,
										Description:         "Required when `type`==`local`",
										MarkdownDescription: "Required when `type`==`local`",
										Validators: []validator.List{
											mistvalidator.AllowedWhenValueIs(path.MatchRelative().AtParent().AtName("type"), types.StringValue("local")),
										},
										Default: listdefault.StaticValue(types.ListNull(types.StringType)),
									},
									"target_ips": schema.ListAttribute{
										ElementType:         types.StringType,
										Optional:            true,
										Computed:            true,
										Description:         "If `type`==`local`, if destination IP is to be replaced",
										MarkdownDescription: "If `type`==`local`, if destination IP is to be replaced",
										Validators: []validator.List{
											mistvalidator.AllowedWhenValueIs(path.MatchRelative().AtParent().AtName("type"), types.StringValue("local")),
										},
										Default: listdefault.StaticValue(types.ListNull(types.StringType)),
									},
									"type": schema.StringAttribute{
										Optional:            true,
										Description:         "enum: `local`, `tunnel`, `vpn`, `wan`",
										MarkdownDescription: "enum: `local`, `tunnel`, `vpn`, `wan`",
										Validators: []validator.String{
											stringvalidator.OneOf(
												"",
												"local",
												"tunnel",
												"vpn",
												"wan",
											),
										},
									},
									"wan_name": schema.StringAttribute{
										Optional:            true,
										Description:         "Optional if `type`==`vpn`",
										MarkdownDescription: "Optional if `type`==`vpn`",
										Validators: []validator.String{
											mistvalidator.AllowedWhenValueIs(path.MatchRelative().AtParent().AtName("type"), types.StringValue("vpn")),
										},
									},
								},
								CustomType: PathsType{
									ObjectType: types.ObjectType{
										AttrTypes: PathsValue{}.AttributeTypes(ctx),
									},
								},
							},
							Optional: true,
						},
						"strategy": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "enum: `ecmp`, `ordered`, `weighted`",
							MarkdownDescription: "enum: `ecmp`, `ordered`, `weighted`",
							Validators: []validator.String{
								stringvalidator.OneOf(
									"",
									"ecmp",
									"ordered",
									"weighted",
								),
							},
							Default: stringdefault.StaticString("ordered"),
						},
					},
					CustomType: PathPreferencesType{
						ObjectType: types.ObjectType{
							AttrTypes: PathPreferencesValue{}.AttributeTypes(ctx),
						},
					},
				},
				Optional:            true,
				Description:         "Property key is the path name",
				MarkdownDescription: "Property key is the path name",
				Validators: []validator.Map{
					mapvalidator.SizeAtLeast(1),
				},
			},
			"port_config": schema.MapNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"ae_disable_lacp": schema.BoolAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "If `aggregated`==`true`. To disable LCP support for the AE interface",
							MarkdownDescription: "If `aggregated`==`true`. To disable LCP support for the AE interface",
							Default:             booldefault.StaticBool(false),
						},
						"ae_idx": schema.StringAttribute{
							Optional:            true,
							Description:         "If `aggregated`==`true`. Users could force to use the designated AE name (must be an integer between 0 and 127)",
							MarkdownDescription: "If `aggregated`==`true`. Users could force to use the designated AE name (must be an integer between 0 and 127)",
						},
						"ae_lacp_force_up": schema.BoolAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "For SRX Only, if `aggregated`==`true`.Sets the state of the interface as UP when the peer has limited LACP capability. Use case: When a device connected to this AE port is ZTPing for the first time, it will not have LACP configured on the other end. **Note:** Turning this on will enable force-up on one of the interfaces in the bundle only",
							MarkdownDescription: "For SRX Only, if `aggregated`==`true`.Sets the state of the interface as UP when the peer has limited LACP capability. Use case: When a device connected to this AE port is ZTPing for the first time, it will not have LACP configured on the other end. **Note:** Turning this on will enable force-up on one of the interfaces in the bundle only",
							Default:             booldefault.StaticBool(false),
						},
						"aggregated": schema.BoolAttribute{
							Optional: true,
							Computed: true,
							Default:  booldefault.StaticBool(false),
						},
						"critical": schema.BoolAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "To generate port up/down alarm, set it to true",
							MarkdownDescription: "To generate port up/down alarm, set it to true",
							Default:             booldefault.StaticBool(false),
						},
						"description": schema.StringAttribute{
							Optional:            true,
							Description:         "Interface Description. Can be a variable (i.e. \"{{myvar}}\")",
							MarkdownDescription: "Interface Description. Can be a variable (i.e. \"{{myvar}}\")",
						},
						"disable_autoneg": schema.BoolAttribute{
							Optional: true,
							Computed: true,
							Default:  booldefault.StaticBool(false),
						},
						"disabled": schema.BoolAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "Port admin up (true) / down (false)",
							MarkdownDescription: "Port admin up (true) / down (false)",
							Default:             booldefault.StaticBool(false),
						},
						"dsl_type": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "if `wan_type`==`dsl`. enum: `adsl`, `vdsl`",
							MarkdownDescription: "if `wan_type`==`dsl`. enum: `adsl`, `vdsl`",
							Validators: []validator.String{
								stringvalidator.OneOf(
									"",
									"vdsl",
									"adsl",
								),
								mistvalidator.AllowedWhenValueIsWithDefault(path.MatchRelative().AtParent().AtName("wan_type"), types.StringValue("dsl"), types.StringValue("vdsl")),
							},
							Default: stringdefault.StaticString("vdsl"),
						},
						"dsl_vci": schema.Int64Attribute{
							Optional:            true,
							Computed:            true,
							Description:         "If `wan_type`==`dsl`, 16 bit int",
							MarkdownDescription: "If `wan_type`==`dsl`, 16 bit int",
							Validators: []validator.Int64{
								mistvalidator.AllowedWhenValueIsWithDefault(path.MatchRelative().AtParent().AtName("wan_type"), types.StringValue("dsl"), types.Int64Value(35)),
							},
							Default: int64default.StaticInt64(35),
						},
						"dsl_vpi": schema.Int64Attribute{
							Optional:            true,
							Computed:            true,
							Description:         "If `wan_type`==`dsl`, 8 bit int",
							MarkdownDescription: "If `wan_type`==`dsl`, 8 bit int",
							Validators: []validator.Int64{
								mistvalidator.AllowedWhenValueIsWithDefault(path.MatchRelative().AtParent().AtName("wan_type"), types.StringValue("dsl"), types.Int64Value(0)),
							},
							Default: int64default.StaticInt64(0),
						},
						"duplex": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "enum: `auto`, `full`, `half`",
							MarkdownDescription: "enum: `auto`, `full`, `half`",
							Validators: []validator.String{
								stringvalidator.OneOf(
									"",
									"auto",
									"full",
									"half",
								),
							},
							Default: stringdefault.StaticString("auto"),
						},
						"lte_apn": schema.StringAttribute{
							Optional:            true,
							Description:         "If `wan_type`==`lte`",
							MarkdownDescription: "If `wan_type`==`lte`",
							Validators: []validator.String{
								mistvalidator.AllowedWhenValueIs(path.MatchRelative().AtParent().AtName("wan_type"), types.StringValue("lte")),
							},
						},
						"lte_auth": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "if `wan_type`==`lte`. enum: `chap`, `none`, `pap`",
							MarkdownDescription: "if `wan_type`==`lte`. enum: `chap`, `none`, `pap`",
							Validators: []validator.String{
								stringvalidator.OneOf(
									"",
									"none",
									"chap",
									"pap",
								),
								mistvalidator.AllowedWhenValueIsWithDefault(path.MatchRelative().AtParent().AtName("wan_type"), types.StringValue("lte"), types.StringValue("none")),
							},
							Default: stringdefault.StaticString("none"),
						},
						"lte_backup": schema.BoolAttribute{
							Optional: true,
						},
						"lte_password": schema.StringAttribute{
							Optional:            true,
							Sensitive:           true,
							Description:         "If `wan_type`==`lte`",
							MarkdownDescription: "If `wan_type`==`lte`",
						},
						"lte_username": schema.StringAttribute{
							Optional:            true,
							Description:         "If `wan_type`==`lte`",
							MarkdownDescription: "If `wan_type`==`lte`",
							Validators: []validator.String{
								mistvalidator.AllowedWhenValueIs(path.MatchRelative().AtParent().AtName("wan_type"), types.StringValue("lte")),
							},
						},
						"mtu": schema.Int64Attribute{
							Optional: true,
						},
						"name": schema.StringAttribute{
							Optional:            true,
							Description:         "Name that we'll use to derive config",
							MarkdownDescription: "Name that we'll use to derive config",
							Validators: []validator.String{
								mistvalidator.RequiredWhenValueIs(path.MatchRelative().AtParent().AtName("usage"), types.StringValue("wan")),
								mistvalidator.ForbiddenWhenValueIs(path.MatchRelative().AtParent().AtName("usage"), types.StringValue("lan")),
								mistvalidator.ForbiddenWhenValueIs(path.MatchRelative().AtParent().AtName("usage"), types.StringValue("ha_data")),
								mistvalidator.ForbiddenWhenValueIs(path.MatchRelative().AtParent().AtName("usage"), types.StringValue("ha_control")),
							},
						},
						"networks": schema.ListAttribute{
							ElementType:         types.StringType,
							Optional:            true,
							Computed:            true,
							Description:         "if `usage`==`lan`, name of the `mist_org_network` resource",
							MarkdownDescription: "if `usage`==`lan`, name of the `mist_org_network` resource",
							Validators: []validator.List{
								mistvalidator.RequiredWhenValueIs(path.MatchRelative().AtParent().AtName("usage"), types.StringValue("lan")),
								mistvalidator.ForbiddenWhenValueIs(path.MatchRelative().AtParent().AtName("usage"), types.StringValue("wan")),
								mistvalidator.ForbiddenWhenValueIs(path.MatchRelative().AtParent().AtName("usage"), types.StringValue("ha_data")),
								mistvalidator.ForbiddenWhenValueIs(path.MatchRelative().AtParent().AtName("usage"), types.StringValue("ha_control")),
							},
							Default: listdefault.StaticValue(types.ListNull(types.StringType)),
						},
						"outer_vlan_id": schema.Int64Attribute{
							Optional:            true,
							Description:         "For Q-in-Q",
							MarkdownDescription: "For Q-in-Q",
						},
						"poe_disabled": schema.BoolAttribute{
							Optional: true,
							Computed: true,
							Default:  booldefault.StaticBool(false),
						},
						"ip_config": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"dns": schema.ListAttribute{
									ElementType:         types.StringType,
									Optional:            true,
									Description:         "Except for out-of_band interface (vme/em0/fxp0)",
									MarkdownDescription: "Except for out-of_band interface (vme/em0/fxp0)",
								},
								"dns_suffix": schema.ListAttribute{
									ElementType:         types.StringType,
									Optional:            true,
									Description:         "Except for out-of_band interface (vme/em0/fxp0)",
									MarkdownDescription: "Except for out-of_band interface (vme/em0/fxp0)",
								},
								"gateway": schema.StringAttribute{
									Optional:            true,
									Description:         "Except for out-of_band interface (vme/em0/fxp0). Interface Default Gateway IP Address (i.e. \"192.168.1.1\") or a Variable (i.e. \"{{myvar}}\")",
									MarkdownDescription: "Except for out-of_band interface (vme/em0/fxp0). Interface Default Gateway IP Address (i.e. \"192.168.1.1\") or a Variable (i.e. \"{{myvar}}\")",
								},
								"ip": schema.StringAttribute{
									Optional:            true,
									Description:         "Interface IP Address (i.e. \"192.168.1.8\") or a Variable (i.e. \"{{myvar}}\")",
									MarkdownDescription: "Interface IP Address (i.e. \"192.168.1.8\") or a Variable (i.e. \"{{myvar}}\")",
									Validators: []validator.String{
										stringvalidator.Any(mistvalidator.ParseIp(false, false), mistvalidator.ParseVar()),
										mistvalidator.RequiredWhenValueIs(path.MatchRelative().AtParent().AtName("type"), types.StringValue("static")),
									},
								},
								"netmask": schema.StringAttribute{
									Optional:            true,
									Description:         "Used only if `subnet` is not specified in `networks`. Interface Netmask (i.e. \"/24\") or a Variable (i.e. \"{{myvar}}\")",
									MarkdownDescription: "Used only if `subnet` is not specified in `networks`. Interface Netmask (i.e. \"/24\") or a Variable (i.e. \"{{myvar}}\")",
									Validators: []validator.String{
										stringvalidator.Any(mistvalidator.ParseNetmask(false, false), mistvalidator.ParseVar()),
										mistvalidator.RequiredWhenValueIs(path.MatchRelative().AtParent().AtName("type"), types.StringValue("static")),
									},
								},
								"network": schema.StringAttribute{
									Optional:            true,
									Description:         "Optional, the network to be used for mgmt",
									MarkdownDescription: "Optional, the network to be used for mgmt",
								},
								"poser_password": schema.StringAttribute{
									Optional:            true,
									Sensitive:           true,
									Description:         "If `type`==`pppoe`",
									MarkdownDescription: "If `type`==`pppoe`",
									Validators: []validator.String{
										mistvalidator.RequiredWhenValueIs(path.MatchRelative().AtParent().AtName("type"), types.StringValue("pppoe")),
									},
								},
								"pppoe_auth": schema.StringAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "if `type`==`pppoe`. enum: `chap`, `none`, `pap`",
									MarkdownDescription: "if `type`==`pppoe`. enum: `chap`, `none`, `pap`",
									Validators: []validator.String{
										stringvalidator.OneOf(
											"",
											"none",
											"chap",
											"pap",
										),
										mistvalidator.RequiredWhenValueIs(path.MatchRelative().AtParent().AtName("type"), types.StringValue("pppoe")),
									},
									Default: stringdefault.StaticString("none"),
								},
								"pppoe_username": schema.StringAttribute{
									Optional:            true,
									Description:         "If `type`==`pppoe`",
									MarkdownDescription: "If `type`==`pppoe`",
									Validators: []validator.String{
										mistvalidator.RequiredWhenValueIs(path.MatchRelative().AtParent().AtName("type"), types.StringValue("pppoe")),
									},
								},
								"type": schema.StringAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "enum: `dhcp`, `pppoe`, `static`",
									MarkdownDescription: "enum: `dhcp`, `pppoe`, `static`",
									Validators: []validator.String{
										stringvalidator.OneOf(
											"",
											"dhcp",
											"pppoe",
											"static",
										),
									},
									Default: stringdefault.StaticString("dhcp"),
								},
							},
							CustomType: PortIpConfigType{
								ObjectType: types.ObjectType{
									AttrTypes: PortIpConfigValue{}.AttributeTypes(ctx),
								},
							},
							Optional:            true,
							Description:         "Junos IP Config",
							MarkdownDescription: "Junos IP Config",
						},
						"port_network": schema.StringAttribute{
							Optional:            true,
							Description:         "Only for SRX and if `usage`==`lan`, the name of the Network to be used as the Untagged VLAN",
							MarkdownDescription: "Only for SRX and if `usage`==`lan`, the name of the Network to be used as the Untagged VLAN",
							Validators: []validator.String{
								mistvalidator.ForbiddenWhenValueIs(path.MatchRelative().AtParent().AtName("usage"), types.StringValue("wan")),
								mistvalidator.ForbiddenWhenValueIs(path.MatchRelative().AtParent().AtName("usage"), types.StringValue("ha_data")),
								mistvalidator.ForbiddenWhenValueIs(path.MatchRelative().AtParent().AtName("usage"), types.StringValue("ha_control")),
							},
						},
						"preserve_dscp": schema.BoolAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "Whether to preserve dscp when sending traffic over VPN (SSR-only)",
							MarkdownDescription: "Whether to preserve dscp when sending traffic over VPN (SSR-only)",
							Default:             booldefault.StaticBool(true),
						},
						"redundant": schema.BoolAttribute{
							Optional:            true,
							Description:         "If HA mode",
							MarkdownDescription: "If HA mode",
						},
						"redundant_group": schema.Int64Attribute{
							Optional:            true,
							Description:         "If HA mode, SRX Only - support redundancy-group. 1-128 for physical SRX, 1-64 for virtual SRX",
							MarkdownDescription: "If HA mode, SRX Only - support redundancy-group. 1-128 for physical SRX, 1-64 for virtual SRX",
							Validators: []validator.Int64{
								int64validator.Between(1, 128),
							},
						},
						"reth_idx": schema.StringAttribute{
							Optional:            true,
							Description:         "For SRX only and if HA Mode",
							MarkdownDescription: "For SRX only and if HA Mode",
						},
						"reth_node": schema.StringAttribute{
							Optional:            true,
							Description:         "If HA mode",
							MarkdownDescription: "If HA mode",
						},
						"reth_nodes": schema.ListAttribute{
							ElementType:         types.StringType,
							Optional:            true,
							Computed:            true,
							Description:         "SSR only - supporting vlan-based redundancy (matching the size of `networks`)",
							MarkdownDescription: "SSR only - supporting vlan-based redundancy (matching the size of `networks`)",
							Default:             listdefault.StaticValue(types.ListNull(types.StringType)),
						},
						"speed": schema.StringAttribute{
							Optional: true,
							Computed: true,
							Default:  stringdefault.StaticString("auto"),
						},
						"ssr_no_virtual_mac": schema.BoolAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "When SSR is running as VM, this is required on certain hosting platforms",
							MarkdownDescription: "When SSR is running as VM, this is required on certain hosting platforms",
							Default:             booldefault.StaticBool(false),
						},
						"svr_port_range": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "For SSR only",
							MarkdownDescription: "For SSR only",
							Default:             stringdefault.StaticString("none"),
						},
						"traffic_shaping": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"class_percentages": schema.ListAttribute{
									ElementType:         types.Int64Type,
									Optional:            true,
									Description:         "percentages for different class of traffic: high / medium / low / best-effort. Sum must be equal to 100",
									MarkdownDescription: "percentages for different class of traffic: high / medium / low / best-effort. Sum must be equal to 100",
								},
								"enabled": schema.BoolAttribute{
									Optional: true,
									Computed: true,
									Default:  booldefault.StaticBool(false),
								},
								"max_tx_kbps": schema.Int64Attribute{
									Optional:            true,
									Description:         "Interface Transmit Cap in kbps",
									MarkdownDescription: "Interface Transmit Cap in kbps",
								},
							},
							CustomType: TrafficShapingType{
								ObjectType: types.ObjectType{
									AttrTypes: TrafficShapingValue{}.AttributeTypes(ctx),
								},
							},
							Optional: true,
						},
						"usage": schema.StringAttribute{
							Required:            true,
							Description:         "port usage name. enum: `ha_control`, `ha_data`, `lan`, `wan`",
							MarkdownDescription: "port usage name. enum: `ha_control`, `ha_data`, `lan`, `wan`",
							Validators: []validator.String{
								stringvalidator.OneOf(
									"",
									"ha_control",
									"ha_data",
									"lan",
									"wan",
								),
							},
						},
						"vlan_id": schema.StringAttribute{
							Optional: true,
						},
						"vpn_paths": schema.MapNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"bfd_profile": schema.StringAttribute{
										Optional:            true,
										Computed:            true,
										Description:         "Only if the VPN `type`==`hub_spoke`. enum: `broadband`, `lte`",
										MarkdownDescription: "Only if the VPN `type`==`hub_spoke`. enum: `broadband`, `lte`",
										Validators: []validator.String{
											stringvalidator.OneOf(
												"",
												"broadband",
												"lte",
											),
										},
										Default: stringdefault.StaticString("broadband"),
									},
									"bfd_use_tunnel_mode": schema.BoolAttribute{
										Optional:            true,
										Computed:            true,
										Description:         "Only if the VPN `type`==`hub_spoke`. Whether to use tunnel mode. SSR only",
										MarkdownDescription: "Only if the VPN `type`==`hub_spoke`. Whether to use tunnel mode. SSR only",
										Default:             booldefault.StaticBool(false),
									},
									"preference": schema.Int64Attribute{
										Optional:            true,
										Description:         "Only if the VPN `type`==`hub_spoke`. For a given VPN, when `path_selection.strategy`==`simple`, the preference for a path (lower is preferred)",
										MarkdownDescription: "Only if the VPN `type`==`hub_spoke`. For a given VPN, when `path_selection.strategy`==`simple`, the preference for a path (lower is preferred)",
									},
									"role": schema.StringAttribute{
										Optional:            true,
										Computed:            true,
										Description:         "If the VPN `type`==`hub_spoke`, enum: `hub`, `spoke`. If the VPN `type`==`mesh`, enum: `mesh`",
										MarkdownDescription: "If the VPN `type`==`hub_spoke`, enum: `hub`, `spoke`. If the VPN `type`==`mesh`, enum: `mesh`",
										Validators: []validator.String{
											stringvalidator.OneOf(
												"",
												"hub",
												"mesh",
												"spoke",
											),
										},
										Default: stringdefault.StaticString("spoke"),
									},
									"traffic_shaping": schema.SingleNestedAttribute{
										Attributes: map[string]schema.Attribute{
											"class_percentages": schema.ListAttribute{
												ElementType:         types.Int64Type,
												Optional:            true,
												Description:         "percentages for different class of traffic: high / medium / low / best-effort. Sum must be equal to 100",
												MarkdownDescription: "percentages for different class of traffic: high / medium / low / best-effort. Sum must be equal to 100",
											},
											"enabled": schema.BoolAttribute{
												Optional: true,
												Computed: true,
												Default:  booldefault.StaticBool(false),
											},
											"max_tx_kbps": schema.Int64Attribute{
												Optional:            true,
												Description:         "Interface Transmit Cap in kbps",
												MarkdownDescription: "Interface Transmit Cap in kbps",
											},
										},
										CustomType: TrafficShapingType{
											ObjectType: types.ObjectType{
												AttrTypes: TrafficShapingValue{}.AttributeTypes(ctx),
											},
										},
										Optional: true,
									},
								},
								CustomType: VpnPathsType{
									ObjectType: types.ObjectType{
										AttrTypes: VpnPathsValue{}.AttributeTypes(ctx),
									},
								},
							},
							Optional:            true,
							Description:         "Property key is the VPN name",
							MarkdownDescription: "Property key is the VPN name",
							Validators: []validator.Map{
								mapvalidator.SizeAtLeast(1),
							},
						},
						"wan_arp_policer": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "Only when `wan_type`==`broadband`. enum: `default`, `max`, `recommended`",
							MarkdownDescription: "Only when `wan_type`==`broadband`. enum: `default`, `max`, `recommended`",
							Validators: []validator.String{
								stringvalidator.OneOf(
									"",
									"recommended",
									"default",
									"max",
								),
								mistvalidator.AllowedWhenValueIs(path.MatchRelative().AtParent().AtName("wan_type"), types.StringValue("broadband")),
							},
							Default: stringdefault.StaticString("default"),
						},
						"wan_ext_ip": schema.StringAttribute{
							Optional:            true,
							Description:         "Only if `usage`==`wan`, optional. If spoke should reach this port by a different IP",
							MarkdownDescription: "Only if `usage`==`wan`, optional. If spoke should reach this port by a different IP",
							Validators: []validator.String{
								mistvalidator.AllowedWhenValueIs(path.MatchRelative().AtParent().AtName("usage"), types.StringValue("wan")),
							},
						},
						"wan_extra_routes": schema.MapNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"via": schema.StringAttribute{
										Optional: true,
									},
								},
								CustomType: WanExtraRoutesType{
									ObjectType: types.ObjectType{
										AttrTypes: WanExtraRoutesValue{}.AttributeTypes(ctx),
									},
								},
							},
							Optional:            true,
							Description:         "Only if `usage`==`wan`. Property Key is the destination CIDR (e.g. \"100.100.100.0/24\")",
							MarkdownDescription: "Only if `usage`==`wan`. Property Key is the destination CIDR (e.g. \"100.100.100.0/24\")",
							Validators: []validator.Map{
								mistvalidator.AllowedWhenValueIsWithDefault(
									path.MatchRelative().AtParent().AtName("usage"),
									types.StringValue("wan"),
									types.MapValueMust(WanExtraRoutesValue{}.Type(ctx), map[string]attr.Value{}),
								),
							},
						},
						"wan_networks": schema.ListAttribute{
							ElementType:         types.StringType,
							Optional:            true,
							Computed:            true,
							Description:         "Only if `usage`==`wan`. If some networks are connected to this WAN port, it can be added here so policies can be defined",
							MarkdownDescription: "Only if `usage`==`wan`. If some networks are connected to this WAN port, it can be added here so policies can be defined",
							Validators: []validator.List{
								mistvalidator.AllowedWhenValueIs(path.MatchRelative().AtParent().AtName("usage"), types.StringValue("wan")),
							},
						},
						"wan_probe_override": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"ips": schema.ListAttribute{
									ElementType: types.StringType,
									Optional:    true,
									Validators: []validator.List{
										listvalidator.UniqueValues(),
									},
								},
								"probe_profile": schema.StringAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "enum: `broadband`, `lte`",
									MarkdownDescription: "enum: `broadband`, `lte`",
									Validators: []validator.String{
										stringvalidator.OneOf(
											"",
											"broadband",
											"lte",
										),
									},
									Default: stringdefault.StaticString("broadband"),
								},
							},
							CustomType: WanProbeOverrideType{
								ObjectType: types.ObjectType{
									AttrTypes: WanProbeOverrideValue{}.AttributeTypes(ctx),
								},
							},
							Optional:            true,
							Description:         "Only if `usage`==`wan`",
							MarkdownDescription: "Only if `usage`==`wan`",
							Validators: []validator.Object{
								mistvalidator.AllowedWhenValueIs(path.MatchRelative().AtParent().AtName("usage"), types.StringValue("wan")),
							},
						},
						"wan_source_nat": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"disabled": schema.BoolAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "Or to disable the source-nat",
									MarkdownDescription: "Or to disable the source-nat",
									Default:             booldefault.StaticBool(false),
								},
								"nat_pool": schema.StringAttribute{
									Optional:            true,
									Description:         "If alternative nat_pool is desired",
									MarkdownDescription: "If alternative nat_pool is desired",
								},
							},
							CustomType: WanSourceNatType{
								ObjectType: types.ObjectType{
									AttrTypes: WanSourceNatValue{}.AttributeTypes(ctx),
								},
							},
							Optional:            true,
							Description:         "Only if `usage`==`wan`, optional. By default, source-NAT is performed on all WAN Ports using the interface-ip",
							MarkdownDescription: "Only if `usage`==`wan`, optional. By default, source-NAT is performed on all WAN Ports using the interface-ip",
							Validators: []validator.Object{
								mistvalidator.AllowedWhenValueIs(path.MatchRelative().AtParent().AtName("usage"), types.StringValue("wan")),
							},
						},
						"wan_type": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "Only if `usage`==`wan`. enum: `broadband`, `dsl`, `lte`",
							MarkdownDescription: "Only if `usage`==`wan`. enum: `broadband`, `dsl`, `lte`",
							Validators: []validator.String{
								stringvalidator.OneOf(
									"",
									"broadband",
									"dsl",
									"lte",
								),
								mistvalidator.AllowedWhenValueIsWithDefault(path.MatchRelative().AtParent().AtName("usage"), types.StringValue("wan"), types.StringValue("broadband")),
							},
							Default: stringdefault.StaticString("broadband"),
						},
					},
					CustomType: PortConfigType{
						ObjectType: types.ObjectType{
							AttrTypes: PortConfigValue{}.AttributeTypes(ctx),
						},
					},
				},
				Optional:            true,
				Description:         "Property key is the port name or range (e.g. \"ge-0/0/0-10\")",
				MarkdownDescription: "Property key is the port name or range (e.g. \"ge-0/0/0-10\")",
				Validators: []validator.Map{
					mapvalidator.SizeAtLeast(1),
				},
			},
			"port_mirroring": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"port_mirror": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"family_type": schema.StringAttribute{
								Optional: true,
							},
							"ingress_port_ids": schema.ListAttribute{
								ElementType: types.StringType,
								Optional:    true,
							},
							"output_port_id": schema.StringAttribute{
								Optional: true,
							},
							"rate": schema.Int64Attribute{
								Optional: true,
							},
							"run_length": schema.Int64Attribute{
								Optional: true,
								Validators: []validator.Int64{
									int64validator.AtLeast(0),
								},
							},
						},
						CustomType: PortMirrorType{
							ObjectType: types.ObjectType{
								AttrTypes: PortMirrorValue{}.AttributeTypes(ctx),
							},
						},
						Optional: true,
					},
				},
				CustomType: PortMirroringType{
					ObjectType: types.ObjectType{
						AttrTypes: PortMirroringValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
			},
			"router_id": schema.StringAttribute{
				Optional:            true,
				Description:         "Auto assigned if not set",
				MarkdownDescription: "Auto assigned if not set",
			},
			"routing_policies": schema.MapNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"terms": schema.ListNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"action": schema.SingleNestedAttribute{
										Attributes: map[string]schema.Attribute{
											"accept": schema.BoolAttribute{
												Optional: true,
											},
											"add_community": schema.ListAttribute{
												ElementType: types.StringType,
												Optional:    true,
											},
											"add_target_vrfs": schema.ListAttribute{
												ElementType:         types.StringType,
												Optional:            true,
												Description:         "For SSR, hub decides how VRF routes are leaked on spoke",
												MarkdownDescription: "For SSR, hub decides how VRF routes are leaked on spoke",
											},
											"community": schema.ListAttribute{
												ElementType:         types.StringType,
												Optional:            true,
												Description:         "When used as export policy, optional",
												MarkdownDescription: "When used as export policy, optional",
											},
											"exclude_as_path": schema.ListAttribute{
												ElementType:         types.StringType,
												Optional:            true,
												Description:         "When used as export policy, optional. To exclude certain AS",
												MarkdownDescription: "When used as export policy, optional. To exclude certain AS",
											},
											"exclude_community": schema.ListAttribute{
												ElementType: types.StringType,
												Optional:    true,
											},
											"export_communities": schema.ListAttribute{
												ElementType:         types.StringType,
												Optional:            true,
												Description:         "When used as export policy, optional",
												MarkdownDescription: "When used as export policy, optional",
											},
											"local_preference": schema.StringAttribute{
												Optional:            true,
												Description:         "Optional, for an import policy, local_preference can be changed",
												MarkdownDescription: "Optional, for an import policy, local_preference can be changed",
											},
											"prepend_as_path": schema.ListAttribute{
												ElementType:         types.StringType,
												Optional:            true,
												Description:         "When used as export policy, optional. By default, the local AS will be prepended, to change it",
												MarkdownDescription: "When used as export policy, optional. By default, the local AS will be prepended, to change it",
											},
										},
										CustomType: ActionType{
											ObjectType: types.ObjectType{
												AttrTypes: ActionValue{}.AttributeTypes(ctx),
											},
										},
										Optional:            true,
										Description:         "When used as import policy",
										MarkdownDescription: "When used as import policy",
									},
									"matching": schema.SingleNestedAttribute{
										Attributes: map[string]schema.Attribute{
											"as_path": schema.ListAttribute{
												ElementType:         types.StringType,
												Optional:            true,
												Description:         "takes regular expression",
												MarkdownDescription: "takes regular expression",
											},
											"community": schema.ListAttribute{
												ElementType: types.StringType,
												Optional:    true,
											},
											"network": schema.ListAttribute{
												ElementType: types.StringType,
												Optional:    true,
												Validators: []validator.List{
													listvalidator.UniqueValues(),
												},
											},
											"prefix": schema.ListAttribute{
												ElementType:         types.StringType,
												Optional:            true,
												Description:         "zero or more criteria/filter can be specified to match the term, all criteria have to be met",
												MarkdownDescription: "zero or more criteria/filter can be specified to match the term, all criteria have to be met",
											},
											"protocol": schema.ListAttribute{
												ElementType:         types.StringType,
												Optional:            true,
												Description:         "`direct`, `bgp`, `osp`, `static`, `aggregate`...",
												MarkdownDescription: "`direct`, `bgp`, `osp`, `static`, `aggregate`...",
											},
											"route_exists": schema.SingleNestedAttribute{
												Attributes: map[string]schema.Attribute{
													"route": schema.StringAttribute{
														Optional: true,
													},
													"vrf_name": schema.StringAttribute{
														Optional:            true,
														Computed:            true,
														Description:         "Name of the vrf instance, it can also be the name of the VPN or wan if they",
														MarkdownDescription: "Name of the vrf instance, it can also be the name of the VPN or wan if they",
														Default:             stringdefault.StaticString("default"),
													},
												},
												CustomType: RouteExistsType{
													ObjectType: types.ObjectType{
														AttrTypes: RouteExistsValue{}.AttributeTypes(ctx),
													},
												},
												Optional: true,
											},
											"vpn_neighbor_mac": schema.ListAttribute{
												ElementType:         types.StringType,
												Optional:            true,
												Description:         "overlay-facing criteria (used for bgp_config where via=vpn)",
												MarkdownDescription: "overlay-facing criteria (used for bgp_config where via=vpn)",
											},
											"vpn_path": schema.ListAttribute{
												ElementType:         types.StringType,
												Optional:            true,
												Description:         "overlay-facing criteria (used for bgp_config where via=vpn). ordered-",
												MarkdownDescription: "overlay-facing criteria (used for bgp_config where via=vpn). ordered-",
											},
											"vpn_path_sla": schema.SingleNestedAttribute{
												Attributes: map[string]schema.Attribute{
													"max_jitter": schema.Int64Attribute{
														Optional: true,
													},
													"max_latency": schema.Int64Attribute{
														Optional: true,
													},
													"max_loss": schema.Int64Attribute{
														Optional: true,
													},
												},
												CustomType: VpnPathSlaType{
													ObjectType: types.ObjectType{
														AttrTypes: VpnPathSlaValue{}.AttributeTypes(ctx),
													},
												},
												Optional: true,
											},
										},
										CustomType: RoutingPolicyTermMatchingType{
											ObjectType: types.ObjectType{
												AttrTypes: RoutingPolicyTermMatchingValue{}.AttributeTypes(ctx),
											},
										},
										Optional:            true,
										Description:         "zero or more criteria/filter can be specified to match the term, all criteria have to be met",
										MarkdownDescription: "zero or more criteria/filter can be specified to match the term, all criteria have to be met",
									},
								},
								CustomType: TermsType{
									ObjectType: types.ObjectType{
										AttrTypes: TermsValue{}.AttributeTypes(ctx),
									},
								},
							},
							Optional:            true,
							Description:         "zero or more criteria/filter can be specified to match the term, all criteria have to be met",
							MarkdownDescription: "zero or more criteria/filter can be specified to match the term, all criteria have to be met",
							Validators: []validator.List{
								listvalidator.UniqueValues(),
							},
						},
					},
					CustomType: RoutingPoliciesType{
						ObjectType: types.ObjectType{
							AttrTypes: RoutingPoliciesValue{}.AttributeTypes(ctx),
						},
					},
				},
				Optional:            true,
				Description:         "Property key is the routing policy name",
				MarkdownDescription: "Property key is the routing policy name",
				Validators: []validator.Map{
					mapvalidator.SizeAtLeast(1),
				},
			},
			"serial": schema.StringAttribute{
				Computed:            true,
				Description:         "Device Serial",
				MarkdownDescription: "Device Serial",
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"service_policies": schema.ListNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"action": schema.StringAttribute{
							Optional:            true,
							Description:         "Required when `servicepolicy_id` is not defined, optional otherwise (override the servicepolicy action). enum: `allow`, `deny`",
							MarkdownDescription: "Required when `servicepolicy_id` is not defined, optional otherwise (override the servicepolicy action). enum: `allow`, `deny`",
							Validators: []validator.String{
								stringvalidator.OneOf(
									"",
									"allow",
									"deny",
								),
								mistvalidator.RequiredWhenValueIsNull(path.MatchRelative().AtParent().AtName("servicepolicy_id")),
							},
						},
						"antivirus": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"avprofile_id": schema.StringAttribute{
									Optional:            true,
									Description:         "org-level AV Profile can be used, this takes precedence over 'profile'",
									MarkdownDescription: "org-level AV Profile can be used, this takes precedence over 'profile'",
								},
								"enabled": schema.BoolAttribute{
									Optional: true,
									Computed: true,
									Default:  booldefault.StaticBool(false),
								},
								"profile": schema.StringAttribute{
									Optional:            true,
									Description:         "Default / noftp / httponly / or keys from av_profiles",
									MarkdownDescription: "Default / noftp / httponly / or keys from av_profiles",
								},
							},
							CustomType: AntivirusType{
								ObjectType: types.ObjectType{
									AttrTypes: AntivirusValue{}.AttributeTypes(ctx),
								},
							},
							Optional:            true,
							Description:         "For SRX-only",
							MarkdownDescription: "For SRX-only",
						},
						"appqoe": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"enabled": schema.BoolAttribute{
									Optional: true,
									Computed: true,
									Default:  booldefault.StaticBool(false),
								},
							},
							CustomType: AppqoeType{
								ObjectType: types.ObjectType{
									AttrTypes: AppqoeValue{}.AttributeTypes(ctx),
								},
							},
							Optional:            true,
							Description:         "For SRX Only",
							MarkdownDescription: "For SRX Only",
						},
						"ewf": schema.ListNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"alert_only": schema.BoolAttribute{
										Optional: true,
									},
									"block_message": schema.StringAttribute{
										Optional: true,
									},
									"enabled": schema.BoolAttribute{
										Optional: true,
										Computed: true,
										Default:  booldefault.StaticBool(false),
									},
									"profile": schema.StringAttribute{
										Optional:            true,
										Computed:            true,
										Description:         "enum: `critical`, `standard`, `strict`",
										MarkdownDescription: "enum: `critical`, `standard`, `strict`",
										Validators: []validator.String{
											stringvalidator.OneOf(
												"",
												"critical",
												"standard",
												"strict",
											),
										},
										Default: stringdefault.StaticString("strict"),
									},
								},
								CustomType: EwfType{
									ObjectType: types.ObjectType{
										AttrTypes: EwfValue{}.AttributeTypes(ctx),
									},
								},
							},
							Optional: true,
							Validators: []validator.List{
								mistvalidator.AllowedWhenValueIsNull(path.MatchRelative().AtParent().AtName("servicepolicy_id")),
							},
						},
						"idp": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"alert_only": schema.BoolAttribute{
									Optional: true,
								},
								"enabled": schema.BoolAttribute{
									Optional: true,
									Computed: true,
									Default:  booldefault.StaticBool(false),
								},
								"idpprofile_id": schema.StringAttribute{
									Optional:            true,
									Description:         "org_level IDP Profile can be used, this takes precedence over `profile`",
									MarkdownDescription: "org_level IDP Profile can be used, this takes precedence over `profile`",
									Validators: []validator.String{
										mistvalidator.AllowedWhenValueIs(path.MatchRelative().AtParent().AtName("enabled"), types.BoolValue(true)),
										mistvalidator.AllowedWhenValueIs(path.MatchRelative().AtParent().AtName("profile"), types.StringValue("Custom")),
									},
								},
								"profile": schema.StringAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "enum: `Custom`, `strict` (default), `standard` or keys from idp_profiles",
									MarkdownDescription: "enum: `Custom`, `strict` (default), `standard` or keys from idp_profiles",
									Default:             stringdefault.StaticString("strict"),
								},
							},
							CustomType: IdpType{
								ObjectType: types.ObjectType{
									AttrTypes: IdpValue{}.AttributeTypes(ctx),
								},
							},
							Optional: true,
							Validators: []validator.Object{
								mistvalidator.AllowedWhenValueIsNull(path.MatchRelative().AtParent().AtName("servicepolicy_id")),
							},
						},
						"local_routing": schema.BoolAttribute{
							Optional:            true,
							Description:         "access within the same VRF",
							MarkdownDescription: "access within the same VRF",
						},
						"name": schema.StringAttribute{
							Optional:            true,
							Description:         "Required when `servicepolicy_id` is not defined, optional otherwise (override the servicepolicy name)",
							MarkdownDescription: "Required when `servicepolicy_id` is not defined, optional otherwise (override the servicepolicy name)",
							Validators: []validator.String{
								mistvalidator.RequiredWhenValueIsNull(path.MatchRelative().AtParent().AtName("servicepolicy_id")),
								mistvalidator.AllowedWhenValueIsNull(path.MatchRelative().AtParent().AtName("servicepolicy_id")),
							},
						},
						"path_preference": schema.StringAttribute{
							Optional:            true,
							Description:         "By default, we derive all paths available and use them. Optionally, you can customize by using `path_preference`",
							MarkdownDescription: "By default, we derive all paths available and use them. Optionally, you can customize by using `path_preference`",
						},
						"servicepolicy_id": schema.StringAttribute{
							Optional:            true,
							Description:         "Used to link servicepolicy defined at org level and overwrite some attributes",
							MarkdownDescription: "Used to link servicepolicy defined at org level and overwrite some attributes",
						},
						"services": schema.ListAttribute{
							ElementType:         types.StringType,
							Optional:            true,
							Computed:            true,
							Description:         "Required when `servicepolicy_id` is not defined. List of Applications / Destinations",
							MarkdownDescription: "Required when `servicepolicy_id` is not defined. List of Applications / Destinations",
							Validators: []validator.List{
								listvalidator.UniqueValues(),
								mistvalidator.RequiredWhenValueIsNull(path.MatchRelative().AtParent().AtName("servicepolicy_id")),
							},
						},
						"ssl_proxy": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"ciphers_category": schema.StringAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "enum: `medium`, `strong`, `weak`",
									MarkdownDescription: "enum: `medium`, `strong`, `weak`",
									Validators: []validator.String{
										stringvalidator.OneOf(
											"",
											"medium",
											"strong",
											"weak",
										),
									},
									Default: stringdefault.StaticString("strong"),
								},
								"enabled": schema.BoolAttribute{
									Optional: true,
									Computed: true,
									Default:  booldefault.StaticBool(false),
								},
							},
							CustomType: SslProxyType{
								ObjectType: types.ObjectType{
									AttrTypes: SslProxyValue{}.AttributeTypes(ctx),
								},
							},
							Optional:            true,
							Description:         "For SRX-only",
							MarkdownDescription: "For SRX-only",
						},
						"tenants": schema.ListAttribute{
							ElementType:         types.StringType,
							Optional:            true,
							Computed:            true,
							Description:         "Required when `servicepolicy_id` is not defined. List of Networks / Users",
							MarkdownDescription: "Required when `servicepolicy_id` is not defined. List of Networks / Users",
							Validators: []validator.List{
								listvalidator.UniqueValues(),
								mistvalidator.RequiredWhenValueIsNull(path.MatchRelative().AtParent().AtName("servicepolicy_id")),
							},
						},
					},
					CustomType: ServicePoliciesType{
						ObjectType: types.ObjectType{
							AttrTypes: ServicePoliciesValue{}.AttributeTypes(ctx),
						},
					},
				},
				Optional: true,
			},
			"site_id": schema.StringAttribute{
				Required: true,
			},
			"tunnel_configs": schema.MapNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"auto_provision": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"primary": schema.SingleNestedAttribute{
									Attributes: map[string]schema.Attribute{
										"probe_ips": schema.ListAttribute{
											ElementType: types.StringType,
											Optional:    true,
											Validators: []validator.List{
												listvalidator.SizeAtLeast(1),
												listvalidator.UniqueValues(),
											},
										},
										"wan_names": schema.ListAttribute{
											ElementType:         types.StringType,
											Optional:            true,
											Description:         "Optional, only needed if `vars_only`==`false`",
											MarkdownDescription: "Optional, only needed if `vars_only`==`false`",
										},
									},
									CustomType: AutoProvisionPrimaryType{
										ObjectType: types.ObjectType{
											AttrTypes: AutoProvisionPrimaryValue{}.AttributeTypes(ctx),
										},
									},
									Optional: true,
								},
								"secondary": schema.SingleNestedAttribute{
									Attributes: map[string]schema.Attribute{
										"probe_ips": schema.ListAttribute{
											ElementType: types.StringType,
											Optional:    true,
											Validators: []validator.List{
												listvalidator.SizeAtLeast(1),
												listvalidator.UniqueValues(),
											},
										},
										"wan_names": schema.ListAttribute{
											ElementType:         types.StringType,
											Optional:            true,
											Description:         "Optional, only needed if `vars_only`==`false`",
											MarkdownDescription: "Optional, only needed if `vars_only`==`false`",
										},
									},
									CustomType: AutoProvisionSecondaryType{
										ObjectType: types.ObjectType{
											AttrTypes: AutoProvisionSecondaryValue{}.AttributeTypes(ctx),
										},
									},
									Optional: true,
								},
								"enable": schema.BoolAttribute{
									Optional: true,
								},
								"latlng": schema.SingleNestedAttribute{
									Attributes: map[string]schema.Attribute{
										"lat": schema.Float64Attribute{
											Required: true,
										},
										"lng": schema.Float64Attribute{
											Required: true,
										},
									},
									CustomType: LatlngType{
										ObjectType: types.ObjectType{
											AttrTypes: LatlngValue{}.AttributeTypes(ctx),
										},
									},
									Optional:            true,
									Description:         "API override for POP selection",
									MarkdownDescription: "API override for POP selection",
								},
								"provider": schema.StringAttribute{
									Required:            true,
									Description:         "enum: `jse-ipsec`, `zscaler-ipsec`",
									MarkdownDescription: "enum: `jse-ipsec`, `zscaler-ipsec`",
									Validators: []validator.String{
										stringvalidator.OneOf(
											"",
											"jse-ipsec",
											"zscaler-ipsec",
										),
									},
								},
								"region": schema.StringAttribute{
									Optional:            true,
									Description:         "API override for POP selection",
									MarkdownDescription: "API override for POP selection",
								},
							},
							CustomType: AutoProvisionType{
								ObjectType: types.ObjectType{
									AttrTypes: AutoProvisionValue{}.AttributeTypes(ctx),
								},
							},
							Optional: true,
						},
						"ike_lifetime": schema.Int64Attribute{
							Optional:            true,
							Description:         "Only if `provider`==`custom-ipsec`. Must be between 180 and 86400",
							MarkdownDescription: "Only if `provider`==`custom-ipsec`. Must be between 180 and 86400",
							Validators: []validator.Int64{
								mistvalidator.RequiredWhenValueIs(path.MatchRelative().AtParent().AtName("provider"), types.StringValue("custom-ipsec")),
								int64validator.Between(180, 86400),
							},
						},
						"ike_mode": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "Only if `provider`==`custom-ipsec`. enum: `aggressive`, `main`",
							MarkdownDescription: "Only if `provider`==`custom-ipsec`. enum: `aggressive`, `main`",
							Validators: []validator.String{
								stringvalidator.OneOf(
									"",
									"main",
									"aggressive",
								),
							},
							Default: stringdefault.StaticString("main"),
						},
						"ike_proposals": schema.ListNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"auth_algo": schema.StringAttribute{
										Optional:            true,
										Description:         "enum: `md5`, `sha1`, `sha2`",
										MarkdownDescription: "enum: `md5`, `sha1`, `sha2`",
										Validators: []validator.String{
											stringvalidator.OneOf(
												"",
												"md5",
												"sha1",
												"sha2",
											),
										},
									},
									"dh_group": schema.StringAttribute{
										Optional:            true,
										Computed:            true,
										Description:         "enum:\n  * 1\n  * 2 (1024-bit)\n  * 5\n  * 14 (default, 2048-bit)\n  * 15 (3072-bit)\n  * 16 (4096-bit)\n  * 19 (256-bit ECP)\n  * 20 (384-bit ECP)\n  * 21 (521-bit ECP)\n  * 24 (2048-bit ECP)",
										MarkdownDescription: "enum:\n  * 1\n  * 2 (1024-bit)\n  * 5\n  * 14 (default, 2048-bit)\n  * 15 (3072-bit)\n  * 16 (4096-bit)\n  * 19 (256-bit ECP)\n  * 20 (384-bit ECP)\n  * 21 (521-bit ECP)\n  * 24 (2048-bit ECP)",
										Validators: []validator.String{
											stringvalidator.OneOf(
												"",
												"1",
												"14",
												"15",
												"16",
												"19",
												"2",
												"20",
												"21",
												"24",
												"5",
											),
										},
										Default: stringdefault.StaticString("14"),
									},
									"enc_algo": schema.StringAttribute{
										Optional:            true,
										Computed:            true,
										Description:         "enum: `3des`, `aes128`, `aes256`, `aes_gcm128`, `aes_gcm256`",
										MarkdownDescription: "enum: `3des`, `aes128`, `aes256`, `aes_gcm128`, `aes_gcm256`",
										Validators: []validator.String{
											stringvalidator.OneOf(
												"",
												"3des",
												"aes128",
												"aes256",
												"aes_gcm128",
												"aes_gcm256",
											),
										},
										Default: stringdefault.StaticString("aes256"),
									},
								},
								CustomType: IkeProposalsType{
									ObjectType: types.ObjectType{
										AttrTypes: IkeProposalsValue{}.AttributeTypes(ctx),
									},
								},
							},
							Optional:            true,
							Description:         "If `provider`==`custom-ipsec`",
							MarkdownDescription: "If `provider`==`custom-ipsec`",
							Validators: []validator.List{
								mistvalidator.RequiredWhenValueIs(path.MatchRelative().AtParent().AtName("provider"), types.StringValue("custom-ipsec")),
							},
						},
						"ipsec_lifetime": schema.Int64Attribute{
							Optional:            true,
							Description:         "Only if `provider`==`custom-ipsec`. Must be between 180 and 86400",
							MarkdownDescription: "Only if `provider`==`custom-ipsec`. Must be between 180 and 86400",
							Validators: []validator.Int64{
								mistvalidator.RequiredWhenValueIs(path.MatchRelative().AtParent().AtName("provider"), types.StringValue("custom-ipsec")),
								int64validator.Between(180, 86400),
							},
						},
						"ipsec_proposals": schema.ListNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"auth_algo": schema.StringAttribute{
										Optional:            true,
										Description:         "enum: `md5`, `sha1`, `sha2`",
										MarkdownDescription: "enum: `md5`, `sha1`, `sha2`",
										Validators: []validator.String{
											stringvalidator.OneOf(
												"",
												"md5",
												"sha1",
												"sha2",
											),
										},
									},
									"dh_group": schema.StringAttribute{
										Optional:            true,
										Computed:            true,
										Description:         "Only if `provider`==`custom-ipsec`. enum:\n  * 1\n  * 2 (1024-bit)\n  * 5\n  * 14 (default, 2048-bit)\n  * 15 (3072-bit)\n  * 16 (4096-bit)\n  * 19 (256-bit ECP)\n  * 20 (384-bit ECP)\n  * 21 (521-bit ECP)\n  * 24 (2048-bit ECP)",
										MarkdownDescription: "Only if `provider`==`custom-ipsec`. enum:\n  * 1\n  * 2 (1024-bit)\n  * 5\n  * 14 (default, 2048-bit)\n  * 15 (3072-bit)\n  * 16 (4096-bit)\n  * 19 (256-bit ECP)\n  * 20 (384-bit ECP)\n  * 21 (521-bit ECP)\n  * 24 (2048-bit ECP)",
										Validators: []validator.String{
											stringvalidator.OneOf(
												"",
												"1",
												"14",
												"15",
												"16",
												"19",
												"2",
												"20",
												"21",
												"24",
												"5",
											),
										},
										Default: stringdefault.StaticString("14"),
									},
									"enc_algo": schema.StringAttribute{
										Optional:            true,
										Computed:            true,
										Description:         "enum: `3des`, `aes128`, `aes256`, `aes_gcm128`, `aes_gcm256`",
										MarkdownDescription: "enum: `3des`, `aes128`, `aes256`, `aes_gcm128`, `aes_gcm256`",
										Validators: []validator.String{
											stringvalidator.OneOf(
												"",
												"3des",
												"aes128",
												"aes256",
												"aes_gcm128",
												"aes_gcm256",
											),
										},
										Default: stringdefault.StaticString("aes256"),
									},
								},
								CustomType: IpsecProposalsType{
									ObjectType: types.ObjectType{
										AttrTypes: IpsecProposalsValue{}.AttributeTypes(ctx),
									},
								},
							},
							Optional:            true,
							Description:         "Only if  `provider`==`custom-ipsec`",
							MarkdownDescription: "Only if  `provider`==`custom-ipsec`",
							Validators: []validator.List{
								mistvalidator.RequiredWhenValueIs(path.MatchRelative().AtParent().AtName("provider"), types.StringValue("custom-ipsec")),
							},
						},
						"local_id": schema.StringAttribute{
							Optional:            true,
							Description:         "Required if `provider`==`zscaler-ipsec`, `provider`==`jse-ipsec` or `provider`==`custom-ipsec`",
							MarkdownDescription: "Required if `provider`==`zscaler-ipsec`, `provider`==`jse-ipsec` or `provider`==`custom-ipsec`",
							Validators: []validator.String{
								mistvalidator.RequiredWhenValueIs(path.MatchRelative().AtParent().AtName("provider"), types.StringValue("zscaler-ipsec")),
								mistvalidator.RequiredWhenValueIs(path.MatchRelative().AtParent().AtName("provider"), types.StringValue("jse-ipsec")),
								mistvalidator.RequiredWhenValueIs(path.MatchRelative().AtParent().AtName("provider"), types.StringValue("customer-ipsec")),
							},
						},
						"mode": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "Required if `provider`==`zscaler-gre`, `provider`==`jse-ipsec`. enum: `active-active`, `active-standby`",
							MarkdownDescription: "Required if `provider`==`zscaler-gre`, `provider`==`jse-ipsec`. enum: `active-active`, `active-standby`",
							Validators: []validator.String{
								stringvalidator.OneOf(
									"",
									"active-active",
									"active-standby",
								),
							},
							Default: stringdefault.StaticString("active-standby"),
						},
						"networks": schema.ListAttribute{
							ElementType:         types.StringType,
							Optional:            true,
							Computed:            true,
							Description:         "If `provider`==`custom-ipsec`, networks reachable via this tunnel",
							MarkdownDescription: "If `provider`==`custom-ipsec`, networks reachable via this tunnel",
							Validators: []validator.List{
								mistvalidator.AllowedWhenValueIs(path.MatchRelative().AtParent().AtName("provider"), types.StringValue("customer-ipsec")),
							},
						},
						"primary": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"hosts": schema.ListAttribute{
									ElementType: types.StringType,
									Required:    true,
								},
								"internal_ips": schema.ListAttribute{
									ElementType:         types.StringType,
									Optional:            true,
									Description:         "Only if `provider`==`zscaler-gre`, `provider`==`jse-ipsec`, `provider`==`custom-ipsec` or `provider`==`custom-gre`",
									MarkdownDescription: "Only if `provider`==`zscaler-gre`, `provider`==`jse-ipsec`, `provider`==`custom-ipsec` or `provider`==`custom-gre`",
								},
								"probe_ips": schema.ListAttribute{
									ElementType: types.StringType,
									Optional:    true,
									Validators: []validator.List{
										listvalidator.UniqueValues(),
									},
								},
								"remote_ids": schema.ListAttribute{
									ElementType:         types.StringType,
									Optional:            true,
									Description:         "Only if  `provider`==`jse-ipsec` or `provider`==`custom-ipsec`",
									MarkdownDescription: "Only if  `provider`==`jse-ipsec` or `provider`==`custom-ipsec`",
								},
								"wan_names": schema.ListAttribute{
									ElementType: types.StringType,
									Required:    true,
								},
							},
							CustomType: PrimaryType{
								ObjectType: types.ObjectType{
									AttrTypes: PrimaryValue{}.AttributeTypes(ctx),
								},
							},
							Optional:            true,
							Description:         "Only if `provider`==`zscaler-ipsec`, `provider`==`jse-ipsec` or `provider`==`custom-ipsec`",
							MarkdownDescription: "Only if `provider`==`zscaler-ipsec`, `provider`==`jse-ipsec` or `provider`==`custom-ipsec`",
						},
						"probe": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"interval": schema.Int64Attribute{
									Optional:            true,
									Description:         "How often to trigger the probe",
									MarkdownDescription: "How often to trigger the probe",
								},
								"threshold": schema.Int64Attribute{
									Optional:            true,
									Description:         "Number of consecutive misses before declaring the tunnel down",
									MarkdownDescription: "Number of consecutive misses before declaring the tunnel down",
								},
								"timeout": schema.Int64Attribute{
									Optional:            true,
									Description:         "Time within which to complete the connectivity check",
									MarkdownDescription: "Time within which to complete the connectivity check",
								},
								"type": schema.StringAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "enum: `http`, `icmp`",
									MarkdownDescription: "enum: `http`, `icmp`",
									Validators: []validator.String{
										stringvalidator.OneOf(
											"",
											"http",
											"icmp",
										),
									},
									Default: stringdefault.StaticString("icmp"),
								},
							},
							CustomType: ProbeType{
								ObjectType: types.ObjectType{
									AttrTypes: ProbeValue{}.AttributeTypes(ctx),
								},
							},
							Optional:            true,
							Description:         "Only if `provider`==`custom-ipsec`",
							MarkdownDescription: "Only if `provider`==`custom-ipsec`",
						},
						"protocol": schema.StringAttribute{
							Optional:            true,
							Description:         "Only if `provider`==`custom-ipsec`. enum: `gre`, `ipsec`",
							MarkdownDescription: "Only if `provider`==`custom-ipsec`. enum: `gre`, `ipsec`",
							Validators: []validator.String{
								stringvalidator.OneOf(
									"",
									"gre",
									"ipsec",
								),
							},
						},
						"provider": schema.StringAttribute{
							Optional:            true,
							Description:         "Only if `auto_provision.enabled`==`false`. enum: `custom-ipsec`, `customer-gre`, `jse-ipsec`, `zscaler-gre`, `zscaler-ipsec`",
							MarkdownDescription: "Only if `auto_provision.enabled`==`false`. enum: `custom-ipsec`, `customer-gre`, `jse-ipsec`, `zscaler-gre`, `zscaler-ipsec`",
							Validators: []validator.String{
								stringvalidator.OneOf(
									"",
									"custom-ipsec",
									"customer-gre",
									"jse-ipsec",
									"zscaler-gre",
									"zscaler-ipsec",
								),
							},
						},
						"psk": schema.StringAttribute{
							Optional:            true,
							Sensitive:           true,
							Description:         "Required if `provider`==`zscaler-ipsec`, `provider`==`jse-ipsec` or `provider`==`custom-ipsec`",
							MarkdownDescription: "Required if `provider`==`zscaler-ipsec`, `provider`==`jse-ipsec` or `provider`==`custom-ipsec`",
							Validators: []validator.String{
								mistvalidator.RequiredWhenValueIs(path.MatchRelative().AtParent().AtName("provider"), types.StringValue("zscaler-ipsec")),
								mistvalidator.RequiredWhenValueIs(path.MatchRelative().AtParent().AtName("provider"), types.StringValue("jse-ipsec")),
								mistvalidator.RequiredWhenValueIs(path.MatchRelative().AtParent().AtName("provider"), types.StringValue("custom-ipsec")),
							},
						},
						"secondary": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"hosts": schema.ListAttribute{
									ElementType: types.StringType,
									Required:    true,
								},
								"internal_ips": schema.ListAttribute{
									ElementType:         types.StringType,
									Optional:            true,
									Description:         "Only if `provider`==`zscaler-gre`, `provider`==`jse-ipsec`, `provider`==`custom-ipsec` or `provider`==`custom-gre`",
									MarkdownDescription: "Only if `provider`==`zscaler-gre`, `provider`==`jse-ipsec`, `provider`==`custom-ipsec` or `provider`==`custom-gre`",
								},
								"probe_ips": schema.ListAttribute{
									ElementType: types.StringType,
									Optional:    true,
									Validators: []validator.List{
										listvalidator.UniqueValues(),
									},
								},
								"remote_ids": schema.ListAttribute{
									ElementType:         types.StringType,
									Optional:            true,
									Description:         "Only if  `provider`==`jse-ipsec` or `provider`==`custom-ipsec`",
									MarkdownDescription: "Only if  `provider`==`jse-ipsec` or `provider`==`custom-ipsec`",
								},
								"wan_names": schema.ListAttribute{
									ElementType: types.StringType,
									Required:    true,
								},
							},
							CustomType: SecondaryType{
								ObjectType: types.ObjectType{
									AttrTypes: SecondaryValue{}.AttributeTypes(ctx),
								},
							},
							Optional:            true,
							Description:         "Only if `provider`==`zscaler-ipsec`, `provider`==`jse-ipsec` or `provider`==`custom-ipsec`",
							MarkdownDescription: "Only if `provider`==`zscaler-ipsec`, `provider`==`jse-ipsec` or `provider`==`custom-ipsec`",
						},
						"version": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "Only if `provider`==`custom-gre` or `provider`==`custom-ipsec`. enum: `1`, `2`",
							MarkdownDescription: "Only if `provider`==`custom-gre` or `provider`==`custom-ipsec`. enum: `1`, `2`",
							Validators: []validator.String{
								stringvalidator.OneOf(
									"",
									"1",
									"2",
								),
							},
							Default: stringdefault.StaticString("2"),
						},
					},
					CustomType: TunnelConfigsType{
						ObjectType: types.ObjectType{
							AttrTypes: TunnelConfigsValue{}.AttributeTypes(ctx),
						},
					},
				},
				Optional:            true,
				Description:         "Property key is the tunnel name",
				MarkdownDescription: "Property key is the tunnel name",
				Validators: []validator.Map{
					mapvalidator.SizeAtLeast(1),
				},
			},
			"tunnel_provider_options": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"jse": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"num_users": schema.Int64Attribute{
								Optional: true,
							},
							"org_name": schema.StringAttribute{
								Optional:            true,
								Description:         "JSE Organization name",
								MarkdownDescription: "JSE Organization name",
							},
						},
						CustomType: JseType{
							ObjectType: types.ObjectType{
								AttrTypes: JseValue{}.AttributeTypes(ctx),
							},
						},
						Optional:            true,
						Description:         "For jse-ipsec, this allows provisioning of adequate resource on JSE. Make sure adequate licenses are added",
						MarkdownDescription: "For jse-ipsec, this allows provisioning of adequate resource on JSE. Make sure adequate licenses are added",
					},
					"zscaler": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"aup_block_internet_until_accepted": schema.BoolAttribute{
								Optional: true,
							},
							"aup_enabled": schema.BoolAttribute{
								Optional:            true,
								Description:         "Can only be `true` when `auth_required`==`false`, display Acceptable Use Policy (AUP)",
								MarkdownDescription: "Can only be `true` when `auth_required`==`false`, display Acceptable Use Policy (AUP)",
								Validators: []validator.Bool{
									mistvalidator.CannotBeTrueWhenValueIs(path.MatchRelative().AtParent().AtName("auth_required"), types.BoolValue(true)),
								},
							},
							"aup_force_ssl_inspection": schema.BoolAttribute{
								Optional:            true,
								Description:         "Proxy HTTPs traffic, requiring Zscaler cert to be installed in browser",
								MarkdownDescription: "Proxy HTTPs traffic, requiring Zscaler cert to be installed in browser",
							},
							"aup_timeout_in_days": schema.Int64Attribute{
								Optional:            true,
								Description:         "Required if `aup_enabled`==`true`. Days before AUP is requested again",
								MarkdownDescription: "Required if `aup_enabled`==`true`. Days before AUP is requested again",
								Validators: []validator.Int64{
									int64validator.Between(1, 180),
									mistvalidator.RequiredWhenValueIs(path.MatchRelative().AtParent().AtName("aup_enabled"), types.BoolValue(true)),
								},
							},
							"auth_required": schema.BoolAttribute{
								Optional:            true,
								Description:         "Enable this option to enforce user authentication",
								MarkdownDescription: "Enable this option to enforce user authentication",
							},
							"caution_enabled": schema.BoolAttribute{
								Optional:            true,
								Description:         "Can only be `true` when `auth_required`==`false`, display caution notification for non-authenticated users",
								MarkdownDescription: "Can only be `true` when `auth_required`==`false`, display caution notification for non-authenticated users",
							},
							"dn_bandwidth": schema.Float64Attribute{
								Optional:            true,
								Description:         "Download bandwidth cap of the link, in Mbps. Disabled if not set",
								MarkdownDescription: "Download bandwidth cap of the link, in Mbps. Disabled if not set",
							},
							"idle_time_in_minutes": schema.Int64Attribute{
								Optional:            true,
								Description:         "Required if `surrogate_IP`==`true`, idle Time to Disassociation",
								MarkdownDescription: "Required if `surrogate_IP`==`true`, idle Time to Disassociation",
								Validators: []validator.Int64{
									int64validator.Between(0, 43200),
									mistvalidator.RequiredWhenValueIs(path.MatchRelative().AtParent().AtName("surrogate_IP"), types.BoolValue(true)),
								},
							},
							"ofw_enabled": schema.BoolAttribute{
								Optional:            true,
								Description:         "If `true`, enable the firewall control option",
								MarkdownDescription: "If `true`, enable the firewall control option",
							},
							"sub_locations": schema.ListNestedAttribute{
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"aup_block_internet_until_accepted": schema.BoolAttribute{
											Optional: true,
										},
										"aup_enabled": schema.BoolAttribute{
											Optional:            true,
											Description:         "Can only be `true` when `auth_required`==`false`, display Acceptable Use Policy (AUP)",
											MarkdownDescription: "Can only be `true` when `auth_required`==`false`, display Acceptable Use Policy (AUP)",
											Validators: []validator.Bool{
												mistvalidator.CannotBeTrueWhenValueIs(path.MatchRelative().AtParent().AtName("auth_required"), types.BoolValue(true)),
											},
										},
										"aup_force_ssl_inspection": schema.BoolAttribute{
											Optional:            true,
											Description:         "Proxy HTTPs traffic, requiring Zscaler cert to be installed in browser",
											MarkdownDescription: "Proxy HTTPs traffic, requiring Zscaler cert to be installed in browser",
										},
										"aup_timeout_in_days": schema.Int64Attribute{
											Optional:            true,
											Description:         "Required if `aup_enabled`==`true`. Days before AUP is requested again",
											MarkdownDescription: "Required if `aup_enabled`==`true`. Days before AUP is requested again",
											Validators: []validator.Int64{
												int64validator.Between(1, 180),
												mistvalidator.RequiredWhenValueIs(path.MatchRelative().AtParent().AtName("aup_enabled"), types.BoolValue(true)),
											},
										},
										"auth_required": schema.BoolAttribute{
											Optional:            true,
											Description:         "Enable this option to authenticate users",
											MarkdownDescription: "Enable this option to authenticate users",
										},
										"caution_enabled": schema.BoolAttribute{
											Optional:            true,
											Description:         "Can only be `true` when `auth_required`==`false`, display caution notification for non-authenticated users",
											MarkdownDescription: "Can only be `true` when `auth_required`==`false`, display caution notification for non-authenticated users",
										},
										"dn_bandwidth": schema.Float64Attribute{
											Optional:            true,
											Description:         "Download bandwidth cap of the link, in Mbps. Disabled if not set",
											MarkdownDescription: "Download bandwidth cap of the link, in Mbps. Disabled if not set",
										},
										"idle_time_in_minutes": schema.Int64Attribute{
											Optional:            true,
											Description:         "Required if `surrogate_IP`==`true`, idle Time to Disassociation",
											MarkdownDescription: "Required if `surrogate_IP`==`true`, idle Time to Disassociation",
											Validators: []validator.Int64{
												int64validator.Between(0, 43200),
												mistvalidator.RequiredWhenValueIs(path.MatchRelative().AtParent().AtName("surrogate_IP"), types.BoolValue(true)),
											},
										},
										"name": schema.StringAttribute{
											Optional:            true,
											Description:         "Network name",
											MarkdownDescription: "Network name",
										},
										"ofw_enabled": schema.BoolAttribute{
											Optional:            true,
											Description:         "If `true`, enable the firewall control option",
											MarkdownDescription: "If `true`, enable the firewall control option",
										},
										"surrogate_ip": schema.BoolAttribute{
											Optional:            true,
											Description:         "Can only be `true` when `auth_required`==`true`. Map a user to a private IP address so it applies the user's policies, instead of the location's policies",
											MarkdownDescription: "Can only be `true` when `auth_required`==`true`. Map a user to a private IP address so it applies the user's policies, instead of the location's policies",
											Validators: []validator.Bool{
												mistvalidator.CanOnlyBeTrueWhenValueIs(path.MatchRelative().AtParent().AtName("auth_required"), types.BoolValue(true)),
											},
										},
										"surrogate_ip_enforced_for_known_browsers": schema.BoolAttribute{
											Optional:            true,
											Description:         "Can only be `true` when `surrogate_IP`==`true`, enforce surrogate IP for known browsers",
											MarkdownDescription: "Can only be `true` when `surrogate_IP`==`true`, enforce surrogate IP for known browsers",
											Validators: []validator.Bool{
												mistvalidator.CanOnlyBeTrueWhenValueIs(path.MatchRelative().AtParent().AtName("surrogate_ip"), types.BoolValue(true)),
											},
										},
										"surrogate_refresh_time_in_minutes": schema.Int64Attribute{
											Optional:            true,
											Description:         "Required if `surrogate_IP_enforced_for_known_browsers`==`true`, must be lower or equal than `idle_time_in_minutes`, refresh Time for re-validation of Surrogacy",
											MarkdownDescription: "Required if `surrogate_IP_enforced_for_known_browsers`==`true`, must be lower or equal than `idle_time_in_minutes`, refresh Time for re-validation of Surrogacy",
											Validators: []validator.Int64{
												int64validator.Between(1, 43200),
												mistvalidator.RequiredWhenValueIs(path.MatchRelative().AtParent().AtName("surrogate_refresh_time_in_minutes"), types.BoolValue(true)),
											},
										},
										"up_bandwidth": schema.Float64Attribute{
											Optional:            true,
											Description:         "Download bandwidth cap of the link, in Mbps. Disabled if not set",
											MarkdownDescription: "Download bandwidth cap of the link, in Mbps. Disabled if not set",
										},
									},
									CustomType: SubLocationsType{
										ObjectType: types.ObjectType{
											AttrTypes: SubLocationsValue{}.AttributeTypes(ctx),
										},
									},
								},
								Optional:            true,
								Description:         "`sub-locations` can be used for specific uses cases to define different configuration based on the user network",
								MarkdownDescription: "`sub-locations` can be used for specific uses cases to define different configuration based on the user network",
							},
							"surrogate_ip": schema.BoolAttribute{
								Optional:            true,
								Description:         "Can only be `true` when `auth_required`==`true`. Map a user to a private IP address so it applies the user's policies, instead of the location's policies",
								MarkdownDescription: "Can only be `true` when `auth_required`==`true`. Map a user to a private IP address so it applies the user's policies, instead of the location's policies",
								Validators: []validator.Bool{
									mistvalidator.CanOnlyBeTrueWhenValueIs(path.MatchRelative().AtParent().AtName("auth_required"), types.BoolValue(true)),
								},
							},
							"surrogate_ip_enforced_for_known_browsers": schema.BoolAttribute{
								Optional:            true,
								Description:         "Can only be `true` when `surrogate_IP`==`true`, enforce surrogate IP for known browsers",
								MarkdownDescription: "Can only be `true` when `surrogate_IP`==`true`, enforce surrogate IP for known browsers",
								Validators: []validator.Bool{
									mistvalidator.CanOnlyBeTrueWhenValueIs(path.MatchRelative().AtParent().AtName("surrogate_ip"), types.BoolValue(true)),
								},
							},
							"surrogate_refresh_time_in_minutes": schema.Int64Attribute{
								Optional:            true,
								Description:         "Required if `surrogate_IP_enforced_for_known_browsers`==`true`, must be lower or equal than `idle_time_in_minutes`, refresh Time for re-validation of Surrogacy",
								MarkdownDescription: "Required if `surrogate_IP_enforced_for_known_browsers`==`true`, must be lower or equal than `idle_time_in_minutes`, refresh Time for re-validation of Surrogacy",
								Validators: []validator.Int64{
									int64validator.Between(1, 43200),
									mistvalidator.RequiredWhenValueIs(path.MatchRelative().AtParent().AtName("surrogate_refresh_time_in_minutes"), types.BoolValue(true)),
								},
							},
							"up_bandwidth": schema.Float64Attribute{
								Optional:            true,
								Description:         "Download bandwidth cap of the link, in Mbps. Disabled if not set",
								MarkdownDescription: "Download bandwidth cap of the link, in Mbps. Disabled if not set",
							},
							"xff_forward_enabled": schema.BoolAttribute{
								Optional:            true,
								Description:         "Location uses proxy chaining to forward traffic",
								MarkdownDescription: "Location uses proxy chaining to forward traffic",
							},
						},
						CustomType: ZscalerType{
							ObjectType: types.ObjectType{
								AttrTypes: ZscalerValue{}.AttributeTypes(ctx),
							},
						},
						Optional:            true,
						Description:         "For zscaler-ipsec and zscaler-gre",
						MarkdownDescription: "For zscaler-ipsec and zscaler-gre",
					},
				},
				CustomType: TunnelProviderOptionsType{
					ObjectType: types.ObjectType{
						AttrTypes: TunnelProviderOptionsValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
			},
			"type": schema.StringAttribute{
				Computed:            true,
				Description:         "Device Type. enum: `gateway`",
				MarkdownDescription: "Device Type. enum: `gateway`",
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
				Validators: []validator.String{
					stringvalidator.OneOf(
						"",
						"gateway",
					),
				},
				Default: stringdefault.StaticString("gateway"),
			},
			"vars": schema.MapAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Description:         "Dictionary of name->value, the vars can then be used in Wlans. This can overwrite those from Site Vars",
				MarkdownDescription: "Dictionary of name->value, the vars can then be used in Wlans. This can overwrite those from Site Vars",
			},
			"vrf_config": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"enabled": schema.BoolAttribute{
						Optional:            true,
						Description:         "Whether to enable VRF (when supported on the device)",
						MarkdownDescription: "Whether to enable VRF (when supported on the device)",
					},
				},
				CustomType: VrfConfigType{
					ObjectType: types.ObjectType{
						AttrTypes: VrfConfigValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
			},
			"vrf_instances": schema.MapNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"networks": schema.ListAttribute{
							ElementType: types.StringType,
							Optional:    true,
							Validators: []validator.List{
								listvalidator.UniqueValues(),
							},
						},
					},
					CustomType: VrfInstancesType{
						ObjectType: types.ObjectType{
							AttrTypes: VrfInstancesValue{}.AttributeTypes(ctx),
						},
					},
				},
				Optional:            true,
				Description:         "Property key is the network name",
				MarkdownDescription: "Property key is the network name",
				Validators: []validator.Map{
					mapvalidator.KeysAre(mistvalidator.ParseName()),
				},
			},
			"x": schema.Float64Attribute{
				Optional:            true,
				Description:         "X in pixel",
				MarkdownDescription: "X in pixel",
			},
			"y": schema.Float64Attribute{
				Optional:            true,
				Description:         "Y in pixel",
				MarkdownDescription: "Y in pixel",
			},
		},
	}
}

type DeviceGatewayModel struct {
	AdditionalConfigCmds  types.List                 `tfsdk:"additional_config_cmds"`
	BgpConfig             types.Map                  `tfsdk:"bgp_config"`
	DeviceId              types.String               `tfsdk:"device_id"`
	DhcpdConfig           DhcpdConfigValue           `tfsdk:"dhcpd_config"`
	DnsServers            types.List                 `tfsdk:"dns_servers"`
	DnsSuffix             types.List                 `tfsdk:"dns_suffix"`
	ExtraRoutes           types.Map                  `tfsdk:"extra_routes"`
	ExtraRoutes6          types.Map                  `tfsdk:"extra_routes6"`
	IdpProfiles           types.Map                  `tfsdk:"idp_profiles"`
	Image1Url             types.String               `tfsdk:"image1_url"`
	Image2Url             types.String               `tfsdk:"image2_url"`
	Image3Url             types.String               `tfsdk:"image3_url"`
	IpConfigs             types.Map                  `tfsdk:"ip_configs"`
	Mac                   types.String               `tfsdk:"mac"`
	Managed               types.Bool                 `tfsdk:"managed"`
	MapId                 types.String               `tfsdk:"map_id"`
	Model                 types.String               `tfsdk:"model"`
	MspId                 types.String               `tfsdk:"msp_id"`
	Name                  types.String               `tfsdk:"name"`
	Networks              types.List                 `tfsdk:"networks"`
	Notes                 types.String               `tfsdk:"notes"`
	NtpServers            types.List                 `tfsdk:"ntp_servers"`
	OobIpConfig           OobIpConfigValue           `tfsdk:"oob_ip_config"`
	OrgId                 types.String               `tfsdk:"org_id"`
	PathPreferences       types.Map                  `tfsdk:"path_preferences"`
	PortConfig            types.Map                  `tfsdk:"port_config"`
	PortMirroring         PortMirroringValue         `tfsdk:"port_mirroring"`
	RouterId              types.String               `tfsdk:"router_id"`
	RoutingPolicies       types.Map                  `tfsdk:"routing_policies"`
	Serial                types.String               `tfsdk:"serial"`
	ServicePolicies       types.List                 `tfsdk:"service_policies"`
	SiteId                types.String               `tfsdk:"site_id"`
	TunnelConfigs         types.Map                  `tfsdk:"tunnel_configs"`
	TunnelProviderOptions TunnelProviderOptionsValue `tfsdk:"tunnel_provider_options"`
	Type                  types.String               `tfsdk:"type"`
	Vars                  types.Map                  `tfsdk:"vars"`
	VrfConfig             VrfConfigValue             `tfsdk:"vrf_config"`
	VrfInstances          types.Map                  `tfsdk:"vrf_instances"`
	X                     types.Float64              `tfsdk:"x"`
	Y                     types.Float64              `tfsdk:"y"`
}

var _ basetypes.ObjectTypable = BgpConfigType{}

type BgpConfigType struct {
	basetypes.ObjectType
}

func (t BgpConfigType) Equal(o attr.Type) bool {
	other, ok := o.(BgpConfigType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t BgpConfigType) String() string {
	return "BgpConfigType"
}

func (t BgpConfigType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	authKeyAttribute, ok := attributes["auth_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auth_key is missing from object`)

		return nil, diags
	}

	authKeyVal, ok := authKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auth_key expected to be basetypes.StringValue, was: %T`, authKeyAttribute))
	}

	bfdMinimumIntervalAttribute, ok := attributes["bfd_minimum_interval"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bfd_minimum_interval is missing from object`)

		return nil, diags
	}

	bfdMinimumIntervalVal, ok := bfdMinimumIntervalAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bfd_minimum_interval expected to be basetypes.Int64Value, was: %T`, bfdMinimumIntervalAttribute))
	}

	bfdMultiplierAttribute, ok := attributes["bfd_multiplier"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bfd_multiplier is missing from object`)

		return nil, diags
	}

	bfdMultiplierVal, ok := bfdMultiplierAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bfd_multiplier expected to be basetypes.Int64Value, was: %T`, bfdMultiplierAttribute))
	}

	disableBfdAttribute, ok := attributes["disable_bfd"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disable_bfd is missing from object`)

		return nil, diags
	}

	disableBfdVal, ok := disableBfdAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disable_bfd expected to be basetypes.BoolValue, was: %T`, disableBfdAttribute))
	}

	exportAttribute, ok := attributes["export"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`export is missing from object`)

		return nil, diags
	}

	exportVal, ok := exportAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`export expected to be basetypes.StringValue, was: %T`, exportAttribute))
	}

	exportPolicyAttribute, ok := attributes["export_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`export_policy is missing from object`)

		return nil, diags
	}

	exportPolicyVal, ok := exportPolicyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`export_policy expected to be basetypes.StringValue, was: %T`, exportPolicyAttribute))
	}

	extendedV4NexthopAttribute, ok := attributes["extended_v4_nexthop"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`extended_v4_nexthop is missing from object`)

		return nil, diags
	}

	extendedV4NexthopVal, ok := extendedV4NexthopAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`extended_v4_nexthop expected to be basetypes.BoolValue, was: %T`, extendedV4NexthopAttribute))
	}

	gracefulRestartTimeAttribute, ok := attributes["graceful_restart_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`graceful_restart_time is missing from object`)

		return nil, diags
	}

	gracefulRestartTimeVal, ok := gracefulRestartTimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`graceful_restart_time expected to be basetypes.Int64Value, was: %T`, gracefulRestartTimeAttribute))
	}

	holdTimeAttribute, ok := attributes["hold_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`hold_time is missing from object`)

		return nil, diags
	}

	holdTimeVal, ok := holdTimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`hold_time expected to be basetypes.Int64Value, was: %T`, holdTimeAttribute))
	}

	importAttribute, ok := attributes["import"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`import is missing from object`)

		return nil, diags
	}

	importVal, ok := importAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`import expected to be basetypes.StringValue, was: %T`, importAttribute))
	}

	importPolicyAttribute, ok := attributes["import_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`import_policy is missing from object`)

		return nil, diags
	}

	importPolicyVal, ok := importPolicyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`import_policy expected to be basetypes.StringValue, was: %T`, importPolicyAttribute))
	}

	localAsAttribute, ok := attributes["local_as"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`local_as is missing from object`)

		return nil, diags
	}

	localAsVal, ok := localAsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`local_as expected to be basetypes.StringValue, was: %T`, localAsAttribute))
	}

	neighborAsAttribute, ok := attributes["neighbor_as"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`neighbor_as is missing from object`)

		return nil, diags
	}

	neighborAsVal, ok := neighborAsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`neighbor_as expected to be basetypes.StringValue, was: %T`, neighborAsAttribute))
	}

	neighborsAttribute, ok := attributes["neighbors"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`neighbors is missing from object`)

		return nil, diags
	}

	neighborsVal, ok := neighborsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`neighbors expected to be basetypes.MapValue, was: %T`, neighborsAttribute))
	}

	networksAttribute, ok := attributes["networks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`networks is missing from object`)

		return nil, diags
	}

	networksVal, ok := networksAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`networks expected to be basetypes.ListValue, was: %T`, networksAttribute))
	}

	noPrivateAsAttribute, ok := attributes["no_private_as"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`no_private_as is missing from object`)

		return nil, diags
	}

	noPrivateAsVal, ok := noPrivateAsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`no_private_as expected to be basetypes.BoolValue, was: %T`, noPrivateAsAttribute))
	}

	noReadvertiseToOverlayAttribute, ok := attributes["no_readvertise_to_overlay"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`no_readvertise_to_overlay is missing from object`)

		return nil, diags
	}

	noReadvertiseToOverlayVal, ok := noReadvertiseToOverlayAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`no_readvertise_to_overlay expected to be basetypes.BoolValue, was: %T`, noReadvertiseToOverlayAttribute))
	}

	tunnelNameAttribute, ok := attributes["tunnel_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tunnel_name is missing from object`)

		return nil, diags
	}

	tunnelNameVal, ok := tunnelNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tunnel_name expected to be basetypes.StringValue, was: %T`, tunnelNameAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	viaAttribute, ok := attributes["via"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`via is missing from object`)

		return nil, diags
	}

	viaVal, ok := viaAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`via expected to be basetypes.StringValue, was: %T`, viaAttribute))
	}

	vpnNameAttribute, ok := attributes["vpn_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vpn_name is missing from object`)

		return nil, diags
	}

	vpnNameVal, ok := vpnNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vpn_name expected to be basetypes.StringValue, was: %T`, vpnNameAttribute))
	}

	wanNameAttribute, ok := attributes["wan_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wan_name is missing from object`)

		return nil, diags
	}

	wanNameVal, ok := wanNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wan_name expected to be basetypes.StringValue, was: %T`, wanNameAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return BgpConfigValue{
		AuthKey:                authKeyVal,
		BfdMinimumInterval:     bfdMinimumIntervalVal,
		BfdMultiplier:          bfdMultiplierVal,
		DisableBfd:             disableBfdVal,
		Export:                 exportVal,
		ExportPolicy:           exportPolicyVal,
		ExtendedV4Nexthop:      extendedV4NexthopVal,
		GracefulRestartTime:    gracefulRestartTimeVal,
		HoldTime:               holdTimeVal,
		Import:                 importVal,
		ImportPolicy:           importPolicyVal,
		LocalAs:                localAsVal,
		NeighborAs:             neighborAsVal,
		Neighbors:              neighborsVal,
		Networks:               networksVal,
		NoPrivateAs:            noPrivateAsVal,
		NoReadvertiseToOverlay: noReadvertiseToOverlayVal,
		TunnelName:             tunnelNameVal,
		BgpConfigType:          typeVal,
		Via:                    viaVal,
		VpnName:                vpnNameVal,
		WanName:                wanNameVal,
		state:                  attr.ValueStateKnown,
	}, diags
}

func NewBgpConfigValueNull() BgpConfigValue {
	return BgpConfigValue{
		state: attr.ValueStateNull,
	}
}

func NewBgpConfigValueUnknown() BgpConfigValue {
	return BgpConfigValue{
		state: attr.ValueStateUnknown,
	}
}

func NewBgpConfigValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (BgpConfigValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing BgpConfigValue Attribute Value",
				"While creating a BgpConfigValue value, a missing attribute value was detected. "+
					"A BgpConfigValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("BgpConfigValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid BgpConfigValue Attribute Type",
				"While creating a BgpConfigValue value, an invalid attribute value was detected. "+
					"A BgpConfigValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("BgpConfigValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("BgpConfigValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra BgpConfigValue Attribute Value",
				"While creating a BgpConfigValue value, an extra attribute value was detected. "+
					"A BgpConfigValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra BgpConfigValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewBgpConfigValueUnknown(), diags
	}

	authKeyAttribute, ok := attributes["auth_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auth_key is missing from object`)

		return NewBgpConfigValueUnknown(), diags
	}

	authKeyVal, ok := authKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auth_key expected to be basetypes.StringValue, was: %T`, authKeyAttribute))
	}

	bfdMinimumIntervalAttribute, ok := attributes["bfd_minimum_interval"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bfd_minimum_interval is missing from object`)

		return NewBgpConfigValueUnknown(), diags
	}

	bfdMinimumIntervalVal, ok := bfdMinimumIntervalAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bfd_minimum_interval expected to be basetypes.Int64Value, was: %T`, bfdMinimumIntervalAttribute))
	}

	bfdMultiplierAttribute, ok := attributes["bfd_multiplier"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bfd_multiplier is missing from object`)

		return NewBgpConfigValueUnknown(), diags
	}

	bfdMultiplierVal, ok := bfdMultiplierAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bfd_multiplier expected to be basetypes.Int64Value, was: %T`, bfdMultiplierAttribute))
	}

	disableBfdAttribute, ok := attributes["disable_bfd"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disable_bfd is missing from object`)

		return NewBgpConfigValueUnknown(), diags
	}

	disableBfdVal, ok := disableBfdAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disable_bfd expected to be basetypes.BoolValue, was: %T`, disableBfdAttribute))
	}

	exportAttribute, ok := attributes["export"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`export is missing from object`)

		return NewBgpConfigValueUnknown(), diags
	}

	exportVal, ok := exportAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`export expected to be basetypes.StringValue, was: %T`, exportAttribute))
	}

	exportPolicyAttribute, ok := attributes["export_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`export_policy is missing from object`)

		return NewBgpConfigValueUnknown(), diags
	}

	exportPolicyVal, ok := exportPolicyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`export_policy expected to be basetypes.StringValue, was: %T`, exportPolicyAttribute))
	}

	extendedV4NexthopAttribute, ok := attributes["extended_v4_nexthop"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`extended_v4_nexthop is missing from object`)

		return NewBgpConfigValueUnknown(), diags
	}

	extendedV4NexthopVal, ok := extendedV4NexthopAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`extended_v4_nexthop expected to be basetypes.BoolValue, was: %T`, extendedV4NexthopAttribute))
	}

	gracefulRestartTimeAttribute, ok := attributes["graceful_restart_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`graceful_restart_time is missing from object`)

		return NewBgpConfigValueUnknown(), diags
	}

	gracefulRestartTimeVal, ok := gracefulRestartTimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`graceful_restart_time expected to be basetypes.Int64Value, was: %T`, gracefulRestartTimeAttribute))
	}

	holdTimeAttribute, ok := attributes["hold_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`hold_time is missing from object`)

		return NewBgpConfigValueUnknown(), diags
	}

	holdTimeVal, ok := holdTimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`hold_time expected to be basetypes.Int64Value, was: %T`, holdTimeAttribute))
	}

	importAttribute, ok := attributes["import"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`import is missing from object`)

		return NewBgpConfigValueUnknown(), diags
	}

	importVal, ok := importAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`import expected to be basetypes.StringValue, was: %T`, importAttribute))
	}

	importPolicyAttribute, ok := attributes["import_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`import_policy is missing from object`)

		return NewBgpConfigValueUnknown(), diags
	}

	importPolicyVal, ok := importPolicyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`import_policy expected to be basetypes.StringValue, was: %T`, importPolicyAttribute))
	}

	localAsAttribute, ok := attributes["local_as"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`local_as is missing from object`)

		return NewBgpConfigValueUnknown(), diags
	}

	localAsVal, ok := localAsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`local_as expected to be basetypes.StringValue, was: %T`, localAsAttribute))
	}

	neighborAsAttribute, ok := attributes["neighbor_as"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`neighbor_as is missing from object`)

		return NewBgpConfigValueUnknown(), diags
	}

	neighborAsVal, ok := neighborAsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`neighbor_as expected to be basetypes.StringValue, was: %T`, neighborAsAttribute))
	}

	neighborsAttribute, ok := attributes["neighbors"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`neighbors is missing from object`)

		return NewBgpConfigValueUnknown(), diags
	}

	neighborsVal, ok := neighborsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`neighbors expected to be basetypes.MapValue, was: %T`, neighborsAttribute))
	}

	networksAttribute, ok := attributes["networks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`networks is missing from object`)

		return NewBgpConfigValueUnknown(), diags
	}

	networksVal, ok := networksAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`networks expected to be basetypes.ListValue, was: %T`, networksAttribute))
	}

	noPrivateAsAttribute, ok := attributes["no_private_as"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`no_private_as is missing from object`)

		return NewBgpConfigValueUnknown(), diags
	}

	noPrivateAsVal, ok := noPrivateAsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`no_private_as expected to be basetypes.BoolValue, was: %T`, noPrivateAsAttribute))
	}

	noReadvertiseToOverlayAttribute, ok := attributes["no_readvertise_to_overlay"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`no_readvertise_to_overlay is missing from object`)

		return NewBgpConfigValueUnknown(), diags
	}

	noReadvertiseToOverlayVal, ok := noReadvertiseToOverlayAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`no_readvertise_to_overlay expected to be basetypes.BoolValue, was: %T`, noReadvertiseToOverlayAttribute))
	}

	tunnelNameAttribute, ok := attributes["tunnel_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tunnel_name is missing from object`)

		return NewBgpConfigValueUnknown(), diags
	}

	tunnelNameVal, ok := tunnelNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tunnel_name expected to be basetypes.StringValue, was: %T`, tunnelNameAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewBgpConfigValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	viaAttribute, ok := attributes["via"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`via is missing from object`)

		return NewBgpConfigValueUnknown(), diags
	}

	viaVal, ok := viaAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`via expected to be basetypes.StringValue, was: %T`, viaAttribute))
	}

	vpnNameAttribute, ok := attributes["vpn_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vpn_name is missing from object`)

		return NewBgpConfigValueUnknown(), diags
	}

	vpnNameVal, ok := vpnNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vpn_name expected to be basetypes.StringValue, was: %T`, vpnNameAttribute))
	}

	wanNameAttribute, ok := attributes["wan_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wan_name is missing from object`)

		return NewBgpConfigValueUnknown(), diags
	}

	wanNameVal, ok := wanNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wan_name expected to be basetypes.StringValue, was: %T`, wanNameAttribute))
	}

	if diags.HasError() {
		return NewBgpConfigValueUnknown(), diags
	}

	return BgpConfigValue{
		AuthKey:                authKeyVal,
		BfdMinimumInterval:     bfdMinimumIntervalVal,
		BfdMultiplier:          bfdMultiplierVal,
		DisableBfd:             disableBfdVal,
		Export:                 exportVal,
		ExportPolicy:           exportPolicyVal,
		ExtendedV4Nexthop:      extendedV4NexthopVal,
		GracefulRestartTime:    gracefulRestartTimeVal,
		HoldTime:               holdTimeVal,
		Import:                 importVal,
		ImportPolicy:           importPolicyVal,
		LocalAs:                localAsVal,
		NeighborAs:             neighborAsVal,
		Neighbors:              neighborsVal,
		Networks:               networksVal,
		NoPrivateAs:            noPrivateAsVal,
		NoReadvertiseToOverlay: noReadvertiseToOverlayVal,
		TunnelName:             tunnelNameVal,
		BgpConfigType:          typeVal,
		Via:                    viaVal,
		VpnName:                vpnNameVal,
		WanName:                wanNameVal,
		state:                  attr.ValueStateKnown,
	}, diags
}

func NewBgpConfigValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) BgpConfigValue {
	object, diags := NewBgpConfigValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewBgpConfigValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t BgpConfigType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewBgpConfigValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewBgpConfigValueUnknown(), nil
	}

	if in.IsNull() {
		return NewBgpConfigValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewBgpConfigValueMust(BgpConfigValue{}.AttributeTypes(ctx), attributes), nil
}

func (t BgpConfigType) ValueType(ctx context.Context) attr.Value {
	return BgpConfigValue{}
}

var _ basetypes.ObjectValuable = BgpConfigValue{}

type BgpConfigValue struct {
	AuthKey                basetypes.StringValue `tfsdk:"auth_key"`
	BfdMinimumInterval     basetypes.Int64Value  `tfsdk:"bfd_minimum_interval"`
	BfdMultiplier          basetypes.Int64Value  `tfsdk:"bfd_multiplier"`
	DisableBfd             basetypes.BoolValue   `tfsdk:"disable_bfd"`
	Export                 basetypes.StringValue `tfsdk:"export"`
	ExportPolicy           basetypes.StringValue `tfsdk:"export_policy"`
	ExtendedV4Nexthop      basetypes.BoolValue   `tfsdk:"extended_v4_nexthop"`
	GracefulRestartTime    basetypes.Int64Value  `tfsdk:"graceful_restart_time"`
	HoldTime               basetypes.Int64Value  `tfsdk:"hold_time"`
	Import                 basetypes.StringValue `tfsdk:"import"`
	ImportPolicy           basetypes.StringValue `tfsdk:"import_policy"`
	LocalAs                basetypes.StringValue `tfsdk:"local_as"`
	NeighborAs             basetypes.StringValue `tfsdk:"neighbor_as"`
	Neighbors              basetypes.MapValue    `tfsdk:"neighbors"`
	Networks               basetypes.ListValue   `tfsdk:"networks"`
	NoPrivateAs            basetypes.BoolValue   `tfsdk:"no_private_as"`
	NoReadvertiseToOverlay basetypes.BoolValue   `tfsdk:"no_readvertise_to_overlay"`
	TunnelName             basetypes.StringValue `tfsdk:"tunnel_name"`
	BgpConfigType          basetypes.StringValue `tfsdk:"type"`
	Via                    basetypes.StringValue `tfsdk:"via"`
	VpnName                basetypes.StringValue `tfsdk:"vpn_name"`
	WanName                basetypes.StringValue `tfsdk:"wan_name"`
	state                  attr.ValueState
}

func (v BgpConfigValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 22)

	var val tftypes.Value
	var err error

	attrTypes["auth_key"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["bfd_minimum_interval"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["bfd_multiplier"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["disable_bfd"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["export"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["export_policy"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["extended_v4_nexthop"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["graceful_restart_time"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["hold_time"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["import"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["import_policy"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["local_as"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["neighbor_as"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["neighbors"] = basetypes.MapType{
		ElemType: NeighborsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["networks"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["no_private_as"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["no_readvertise_to_overlay"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["tunnel_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["via"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["vpn_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["wan_name"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 22)

		val, err = v.AuthKey.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["auth_key"] = val

		val, err = v.BfdMinimumInterval.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bfd_minimum_interval"] = val

		val, err = v.BfdMultiplier.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bfd_multiplier"] = val

		val, err = v.DisableBfd.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["disable_bfd"] = val

		val, err = v.Export.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["export"] = val

		val, err = v.ExportPolicy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["export_policy"] = val

		val, err = v.ExtendedV4Nexthop.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["extended_v4_nexthop"] = val

		val, err = v.GracefulRestartTime.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["graceful_restart_time"] = val

		val, err = v.HoldTime.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["hold_time"] = val

		val, err = v.Import.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["import"] = val

		val, err = v.ImportPolicy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["import_policy"] = val

		val, err = v.LocalAs.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["local_as"] = val

		val, err = v.NeighborAs.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["neighbor_as"] = val

		val, err = v.Neighbors.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["neighbors"] = val

		val, err = v.Networks.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["networks"] = val

		val, err = v.NoPrivateAs.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["no_private_as"] = val

		val, err = v.NoReadvertiseToOverlay.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["no_readvertise_to_overlay"] = val

		val, err = v.TunnelName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tunnel_name"] = val

		val, err = v.BgpConfigType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		val, err = v.Via.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["via"] = val

		val, err = v.VpnName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vpn_name"] = val

		val, err = v.WanName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["wan_name"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v BgpConfigValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v BgpConfigValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v BgpConfigValue) String() string {
	return "BgpConfigValue"
}

func (v BgpConfigValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	neighbors := types.MapValueMust(
		NeighborsType{
			basetypes.ObjectType{
				AttrTypes: NeighborsValue{}.AttributeTypes(ctx),
			},
		},
		v.Neighbors.Elements(),
	)

	if v.Neighbors.IsNull() {
		neighbors = types.MapNull(
			NeighborsType{
				basetypes.ObjectType{
					AttrTypes: NeighborsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Neighbors.IsUnknown() {
		neighbors = types.MapUnknown(
			NeighborsType{
				basetypes.ObjectType{
					AttrTypes: NeighborsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var networksVal basetypes.ListValue
	switch {
	case v.Networks.IsUnknown():
		networksVal = types.ListUnknown(types.StringType)
	case v.Networks.IsNull():
		networksVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		networksVal, d = types.ListValue(types.StringType, v.Networks.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"auth_key":              basetypes.StringType{},
			"bfd_minimum_interval":  basetypes.Int64Type{},
			"bfd_multiplier":        basetypes.Int64Type{},
			"disable_bfd":           basetypes.BoolType{},
			"export":                basetypes.StringType{},
			"export_policy":         basetypes.StringType{},
			"extended_v4_nexthop":   basetypes.BoolType{},
			"graceful_restart_time": basetypes.Int64Type{},
			"hold_time":             basetypes.Int64Type{},
			"import":                basetypes.StringType{},
			"import_policy":         basetypes.StringType{},
			"local_as":              basetypes.StringType{},
			"neighbor_as":           basetypes.StringType{},
			"neighbors": basetypes.MapType{
				ElemType: NeighborsValue{}.Type(ctx),
			},
			"networks": basetypes.ListType{
				ElemType: types.StringType,
			},
			"no_private_as":             basetypes.BoolType{},
			"no_readvertise_to_overlay": basetypes.BoolType{},
			"tunnel_name":               basetypes.StringType{},
			"type":                      basetypes.StringType{},
			"via":                       basetypes.StringType{},
			"vpn_name":                  basetypes.StringType{},
			"wan_name":                  basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"auth_key":              basetypes.StringType{},
		"bfd_minimum_interval":  basetypes.Int64Type{},
		"bfd_multiplier":        basetypes.Int64Type{},
		"disable_bfd":           basetypes.BoolType{},
		"export":                basetypes.StringType{},
		"export_policy":         basetypes.StringType{},
		"extended_v4_nexthop":   basetypes.BoolType{},
		"graceful_restart_time": basetypes.Int64Type{},
		"hold_time":             basetypes.Int64Type{},
		"import":                basetypes.StringType{},
		"import_policy":         basetypes.StringType{},
		"local_as":              basetypes.StringType{},
		"neighbor_as":           basetypes.StringType{},
		"neighbors": basetypes.MapType{
			ElemType: NeighborsValue{}.Type(ctx),
		},
		"networks": basetypes.ListType{
			ElemType: types.StringType,
		},
		"no_private_as":             basetypes.BoolType{},
		"no_readvertise_to_overlay": basetypes.BoolType{},
		"tunnel_name":               basetypes.StringType{},
		"type":                      basetypes.StringType{},
		"via":                       basetypes.StringType{},
		"vpn_name":                  basetypes.StringType{},
		"wan_name":                  basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"auth_key":                  v.AuthKey,
			"bfd_minimum_interval":      v.BfdMinimumInterval,
			"bfd_multiplier":            v.BfdMultiplier,
			"disable_bfd":               v.DisableBfd,
			"export":                    v.Export,
			"export_policy":             v.ExportPolicy,
			"extended_v4_nexthop":       v.ExtendedV4Nexthop,
			"graceful_restart_time":     v.GracefulRestartTime,
			"hold_time":                 v.HoldTime,
			"import":                    v.Import,
			"import_policy":             v.ImportPolicy,
			"local_as":                  v.LocalAs,
			"neighbor_as":               v.NeighborAs,
			"neighbors":                 neighbors,
			"networks":                  networksVal,
			"no_private_as":             v.NoPrivateAs,
			"no_readvertise_to_overlay": v.NoReadvertiseToOverlay,
			"tunnel_name":               v.TunnelName,
			"type":                      v.BgpConfigType,
			"via":                       v.Via,
			"vpn_name":                  v.VpnName,
			"wan_name":                  v.WanName,
		})

	return objVal, diags
}

func (v BgpConfigValue) Equal(o attr.Value) bool {
	other, ok := o.(BgpConfigValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AuthKey.Equal(other.AuthKey) {
		return false
	}

	if !v.BfdMinimumInterval.Equal(other.BfdMinimumInterval) {
		return false
	}

	if !v.BfdMultiplier.Equal(other.BfdMultiplier) {
		return false
	}

	if !v.DisableBfd.Equal(other.DisableBfd) {
		return false
	}

	if !v.Export.Equal(other.Export) {
		return false
	}

	if !v.ExportPolicy.Equal(other.ExportPolicy) {
		return false
	}

	if !v.ExtendedV4Nexthop.Equal(other.ExtendedV4Nexthop) {
		return false
	}

	if !v.GracefulRestartTime.Equal(other.GracefulRestartTime) {
		return false
	}

	if !v.HoldTime.Equal(other.HoldTime) {
		return false
	}

	if !v.Import.Equal(other.Import) {
		return false
	}

	if !v.ImportPolicy.Equal(other.ImportPolicy) {
		return false
	}

	if !v.LocalAs.Equal(other.LocalAs) {
		return false
	}

	if !v.NeighborAs.Equal(other.NeighborAs) {
		return false
	}

	if !v.Neighbors.Equal(other.Neighbors) {
		return false
	}

	if !v.Networks.Equal(other.Networks) {
		return false
	}

	if !v.NoPrivateAs.Equal(other.NoPrivateAs) {
		return false
	}

	if !v.NoReadvertiseToOverlay.Equal(other.NoReadvertiseToOverlay) {
		return false
	}

	if !v.TunnelName.Equal(other.TunnelName) {
		return false
	}

	if !v.BgpConfigType.Equal(other.BgpConfigType) {
		return false
	}

	if !v.Via.Equal(other.Via) {
		return false
	}

	if !v.VpnName.Equal(other.VpnName) {
		return false
	}

	if !v.WanName.Equal(other.WanName) {
		return false
	}

	return true
}

func (v BgpConfigValue) Type(ctx context.Context) attr.Type {
	return BgpConfigType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v BgpConfigValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"auth_key":              basetypes.StringType{},
		"bfd_minimum_interval":  basetypes.Int64Type{},
		"bfd_multiplier":        basetypes.Int64Type{},
		"disable_bfd":           basetypes.BoolType{},
		"export":                basetypes.StringType{},
		"export_policy":         basetypes.StringType{},
		"extended_v4_nexthop":   basetypes.BoolType{},
		"graceful_restart_time": basetypes.Int64Type{},
		"hold_time":             basetypes.Int64Type{},
		"import":                basetypes.StringType{},
		"import_policy":         basetypes.StringType{},
		"local_as":              basetypes.StringType{},
		"neighbor_as":           basetypes.StringType{},
		"neighbors": basetypes.MapType{
			ElemType: NeighborsValue{}.Type(ctx),
		},
		"networks": basetypes.ListType{
			ElemType: types.StringType,
		},
		"no_private_as":             basetypes.BoolType{},
		"no_readvertise_to_overlay": basetypes.BoolType{},
		"tunnel_name":               basetypes.StringType{},
		"type":                      basetypes.StringType{},
		"via":                       basetypes.StringType{},
		"vpn_name":                  basetypes.StringType{},
		"wan_name":                  basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = NeighborsType{}

type NeighborsType struct {
	basetypes.ObjectType
}

func (t NeighborsType) Equal(o attr.Type) bool {
	other, ok := o.(NeighborsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t NeighborsType) String() string {
	return "NeighborsType"
}

func (t NeighborsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	disabledAttribute, ok := attributes["disabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disabled is missing from object`)

		return nil, diags
	}

	disabledVal, ok := disabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disabled expected to be basetypes.BoolValue, was: %T`, disabledAttribute))
	}

	exportPolicyAttribute, ok := attributes["export_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`export_policy is missing from object`)

		return nil, diags
	}

	exportPolicyVal, ok := exportPolicyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`export_policy expected to be basetypes.StringValue, was: %T`, exportPolicyAttribute))
	}

	holdTimeAttribute, ok := attributes["hold_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`hold_time is missing from object`)

		return nil, diags
	}

	holdTimeVal, ok := holdTimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`hold_time expected to be basetypes.Int64Value, was: %T`, holdTimeAttribute))
	}

	importPolicyAttribute, ok := attributes["import_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`import_policy is missing from object`)

		return nil, diags
	}

	importPolicyVal, ok := importPolicyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`import_policy expected to be basetypes.StringValue, was: %T`, importPolicyAttribute))
	}

	multihopTtlAttribute, ok := attributes["multihop_ttl"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`multihop_ttl is missing from object`)

		return nil, diags
	}

	multihopTtlVal, ok := multihopTtlAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`multihop_ttl expected to be basetypes.Int64Value, was: %T`, multihopTtlAttribute))
	}

	neighborAsAttribute, ok := attributes["neighbor_as"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`neighbor_as is missing from object`)

		return nil, diags
	}

	neighborAsVal, ok := neighborAsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`neighbor_as expected to be basetypes.StringValue, was: %T`, neighborAsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return NeighborsValue{
		Disabled:     disabledVal,
		ExportPolicy: exportPolicyVal,
		HoldTime:     holdTimeVal,
		ImportPolicy: importPolicyVal,
		MultihopTtl:  multihopTtlVal,
		NeighborAs:   neighborAsVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewNeighborsValueNull() NeighborsValue {
	return NeighborsValue{
		state: attr.ValueStateNull,
	}
}

func NewNeighborsValueUnknown() NeighborsValue {
	return NeighborsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewNeighborsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (NeighborsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing NeighborsValue Attribute Value",
				"While creating a NeighborsValue value, a missing attribute value was detected. "+
					"A NeighborsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NeighborsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid NeighborsValue Attribute Type",
				"While creating a NeighborsValue value, an invalid attribute value was detected. "+
					"A NeighborsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NeighborsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("NeighborsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra NeighborsValue Attribute Value",
				"While creating a NeighborsValue value, an extra attribute value was detected. "+
					"A NeighborsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra NeighborsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewNeighborsValueUnknown(), diags
	}

	disabledAttribute, ok := attributes["disabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disabled is missing from object`)

		return NewNeighborsValueUnknown(), diags
	}

	disabledVal, ok := disabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disabled expected to be basetypes.BoolValue, was: %T`, disabledAttribute))
	}

	exportPolicyAttribute, ok := attributes["export_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`export_policy is missing from object`)

		return NewNeighborsValueUnknown(), diags
	}

	exportPolicyVal, ok := exportPolicyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`export_policy expected to be basetypes.StringValue, was: %T`, exportPolicyAttribute))
	}

	holdTimeAttribute, ok := attributes["hold_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`hold_time is missing from object`)

		return NewNeighborsValueUnknown(), diags
	}

	holdTimeVal, ok := holdTimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`hold_time expected to be basetypes.Int64Value, was: %T`, holdTimeAttribute))
	}

	importPolicyAttribute, ok := attributes["import_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`import_policy is missing from object`)

		return NewNeighborsValueUnknown(), diags
	}

	importPolicyVal, ok := importPolicyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`import_policy expected to be basetypes.StringValue, was: %T`, importPolicyAttribute))
	}

	multihopTtlAttribute, ok := attributes["multihop_ttl"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`multihop_ttl is missing from object`)

		return NewNeighborsValueUnknown(), diags
	}

	multihopTtlVal, ok := multihopTtlAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`multihop_ttl expected to be basetypes.Int64Value, was: %T`, multihopTtlAttribute))
	}

	neighborAsAttribute, ok := attributes["neighbor_as"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`neighbor_as is missing from object`)

		return NewNeighborsValueUnknown(), diags
	}

	neighborAsVal, ok := neighborAsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`neighbor_as expected to be basetypes.StringValue, was: %T`, neighborAsAttribute))
	}

	if diags.HasError() {
		return NewNeighborsValueUnknown(), diags
	}

	return NeighborsValue{
		Disabled:     disabledVal,
		ExportPolicy: exportPolicyVal,
		HoldTime:     holdTimeVal,
		ImportPolicy: importPolicyVal,
		MultihopTtl:  multihopTtlVal,
		NeighborAs:   neighborAsVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewNeighborsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) NeighborsValue {
	object, diags := NewNeighborsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewNeighborsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t NeighborsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewNeighborsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewNeighborsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewNeighborsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewNeighborsValueMust(NeighborsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t NeighborsType) ValueType(ctx context.Context) attr.Value {
	return NeighborsValue{}
}

var _ basetypes.ObjectValuable = NeighborsValue{}

type NeighborsValue struct {
	Disabled     basetypes.BoolValue   `tfsdk:"disabled"`
	ExportPolicy basetypes.StringValue `tfsdk:"export_policy"`
	HoldTime     basetypes.Int64Value  `tfsdk:"hold_time"`
	ImportPolicy basetypes.StringValue `tfsdk:"import_policy"`
	MultihopTtl  basetypes.Int64Value  `tfsdk:"multihop_ttl"`
	NeighborAs   basetypes.StringValue `tfsdk:"neighbor_as"`
	state        attr.ValueState
}

func (v NeighborsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 6)

	var val tftypes.Value
	var err error

	attrTypes["disabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["export_policy"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["hold_time"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["import_policy"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["multihop_ttl"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["neighbor_as"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 6)

		val, err = v.Disabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["disabled"] = val

		val, err = v.ExportPolicy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["export_policy"] = val

		val, err = v.HoldTime.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["hold_time"] = val

		val, err = v.ImportPolicy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["import_policy"] = val

		val, err = v.MultihopTtl.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["multihop_ttl"] = val

		val, err = v.NeighborAs.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["neighbor_as"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v NeighborsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v NeighborsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v NeighborsValue) String() string {
	return "NeighborsValue"
}

func (v NeighborsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"disabled":      basetypes.BoolType{},
		"export_policy": basetypes.StringType{},
		"hold_time":     basetypes.Int64Type{},
		"import_policy": basetypes.StringType{},
		"multihop_ttl":  basetypes.Int64Type{},
		"neighbor_as":   basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"disabled":      v.Disabled,
			"export_policy": v.ExportPolicy,
			"hold_time":     v.HoldTime,
			"import_policy": v.ImportPolicy,
			"multihop_ttl":  v.MultihopTtl,
			"neighbor_as":   v.NeighborAs,
		})

	return objVal, diags
}

func (v NeighborsValue) Equal(o attr.Value) bool {
	other, ok := o.(NeighborsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Disabled.Equal(other.Disabled) {
		return false
	}

	if !v.ExportPolicy.Equal(other.ExportPolicy) {
		return false
	}

	if !v.HoldTime.Equal(other.HoldTime) {
		return false
	}

	if !v.ImportPolicy.Equal(other.ImportPolicy) {
		return false
	}

	if !v.MultihopTtl.Equal(other.MultihopTtl) {
		return false
	}

	if !v.NeighborAs.Equal(other.NeighborAs) {
		return false
	}

	return true
}

func (v NeighborsValue) Type(ctx context.Context) attr.Type {
	return NeighborsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v NeighborsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"disabled":      basetypes.BoolType{},
		"export_policy": basetypes.StringType{},
		"hold_time":     basetypes.Int64Type{},
		"import_policy": basetypes.StringType{},
		"multihop_ttl":  basetypes.Int64Type{},
		"neighbor_as":   basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = DhcpdConfigType{}

type DhcpdConfigType struct {
	basetypes.ObjectType
}

func (t DhcpdConfigType) Equal(o attr.Type) bool {
	other, ok := o.(DhcpdConfigType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t DhcpdConfigType) String() string {
	return "DhcpdConfigType"
}

func (t DhcpdConfigType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	configAttribute, ok := attributes["config"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`config is missing from object`)

		return nil, diags
	}

	configVal, ok := configAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`config expected to be basetypes.MapValue, was: %T`, configAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return DhcpdConfigValue{
		Config:  configVal,
		Enabled: enabledVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewDhcpdConfigValueNull() DhcpdConfigValue {
	return DhcpdConfigValue{
		state: attr.ValueStateNull,
	}
}

func NewDhcpdConfigValueUnknown() DhcpdConfigValue {
	return DhcpdConfigValue{
		state: attr.ValueStateUnknown,
	}
}

func NewDhcpdConfigValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (DhcpdConfigValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing DhcpdConfigValue Attribute Value",
				"While creating a DhcpdConfigValue value, a missing attribute value was detected. "+
					"A DhcpdConfigValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DhcpdConfigValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid DhcpdConfigValue Attribute Type",
				"While creating a DhcpdConfigValue value, an invalid attribute value was detected. "+
					"A DhcpdConfigValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DhcpdConfigValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("DhcpdConfigValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra DhcpdConfigValue Attribute Value",
				"While creating a DhcpdConfigValue value, an extra attribute value was detected. "+
					"A DhcpdConfigValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra DhcpdConfigValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewDhcpdConfigValueUnknown(), diags
	}

	configAttribute, ok := attributes["config"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`config is missing from object`)

		return NewDhcpdConfigValueUnknown(), diags
	}

	configVal, ok := configAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`config expected to be basetypes.MapValue, was: %T`, configAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewDhcpdConfigValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	if diags.HasError() {
		return NewDhcpdConfigValueUnknown(), diags
	}

	return DhcpdConfigValue{
		Config:  configVal,
		Enabled: enabledVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewDhcpdConfigValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) DhcpdConfigValue {
	object, diags := NewDhcpdConfigValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewDhcpdConfigValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t DhcpdConfigType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewDhcpdConfigValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewDhcpdConfigValueUnknown(), nil
	}

	if in.IsNull() {
		return NewDhcpdConfigValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewDhcpdConfigValueMust(DhcpdConfigValue{}.AttributeTypes(ctx), attributes), nil
}

func (t DhcpdConfigType) ValueType(ctx context.Context) attr.Value {
	return DhcpdConfigValue{}
}

var _ basetypes.ObjectValuable = DhcpdConfigValue{}

type DhcpdConfigValue struct {
	Config  basetypes.MapValue  `tfsdk:"config"`
	Enabled basetypes.BoolValue `tfsdk:"enabled"`
	state   attr.ValueState
}

func (v DhcpdConfigValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["config"] = basetypes.MapType{
		ElemType: ConfigValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Config.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["config"] = val

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v DhcpdConfigValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v DhcpdConfigValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v DhcpdConfigValue) String() string {
	return "DhcpdConfigValue"
}

func (v DhcpdConfigValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	config := types.MapValueMust(
		ConfigType{
			basetypes.ObjectType{
				AttrTypes: ConfigValue{}.AttributeTypes(ctx),
			},
		},
		v.Config.Elements(),
	)

	if v.Config.IsNull() {
		config = types.MapNull(
			ConfigType{
				basetypes.ObjectType{
					AttrTypes: ConfigValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Config.IsUnknown() {
		config = types.MapUnknown(
			ConfigType{
				basetypes.ObjectType{
					AttrTypes: ConfigValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"config": basetypes.MapType{
			ElemType: ConfigValue{}.Type(ctx),
		},
		"enabled": basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"config":  config,
			"enabled": v.Enabled,
		})

	return objVal, diags
}

func (v DhcpdConfigValue) Equal(o attr.Value) bool {
	other, ok := o.(DhcpdConfigValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Config.Equal(other.Config) {
		return false
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	return true
}

func (v DhcpdConfigValue) Type(ctx context.Context) attr.Type {
	return DhcpdConfigType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v DhcpdConfigValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"config": basetypes.MapType{
			ElemType: ConfigValue{}.Type(ctx),
		},
		"enabled": basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = ConfigType{}

type ConfigType struct {
	basetypes.ObjectType
}

func (t ConfigType) Equal(o attr.Type) bool {
	other, ok := o.(ConfigType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ConfigType) String() string {
	return "ConfigType"
}

func (t ConfigType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	dnsServersAttribute, ok := attributes["dns_servers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dns_servers is missing from object`)

		return nil, diags
	}

	dnsServersVal, ok := dnsServersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dns_servers expected to be basetypes.ListValue, was: %T`, dnsServersAttribute))
	}

	dnsSuffixAttribute, ok := attributes["dns_suffix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dns_suffix is missing from object`)

		return nil, diags
	}

	dnsSuffixVal, ok := dnsSuffixAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dns_suffix expected to be basetypes.ListValue, was: %T`, dnsSuffixAttribute))
	}

	fixedBindingsAttribute, ok := attributes["fixed_bindings"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fixed_bindings is missing from object`)

		return nil, diags
	}

	fixedBindingsVal, ok := fixedBindingsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fixed_bindings expected to be basetypes.MapValue, was: %T`, fixedBindingsAttribute))
	}

	gatewayAttribute, ok := attributes["gateway"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gateway is missing from object`)

		return nil, diags
	}

	gatewayVal, ok := gatewayAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gateway expected to be basetypes.StringValue, was: %T`, gatewayAttribute))
	}

	ipEnd4Attribute, ok := attributes["ip_end"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_end is missing from object`)

		return nil, diags
	}

	ipEnd4Val, ok := ipEnd4Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_end expected to be basetypes.StringValue, was: %T`, ipEnd4Attribute))
	}

	ipEnd6Attribute, ok := attributes["ip_end6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_end6 is missing from object`)

		return nil, diags
	}

	ipEnd6Val, ok := ipEnd6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_end6 expected to be basetypes.StringValue, was: %T`, ipEnd6Attribute))
	}

	ipStart4Attribute, ok := attributes["ip_start"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_start is missing from object`)

		return nil, diags
	}

	ipStart4Val, ok := ipStart4Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_start expected to be basetypes.StringValue, was: %T`, ipStart4Attribute))
	}

	ipStart6Attribute, ok := attributes["ip_start6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_start6 is missing from object`)

		return nil, diags
	}

	ipStart6Val, ok := ipStart6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_start6 expected to be basetypes.StringValue, was: %T`, ipStart6Attribute))
	}

	leaseTimeAttribute, ok := attributes["lease_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lease_time is missing from object`)

		return nil, diags
	}

	leaseTimeVal, ok := leaseTimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lease_time expected to be basetypes.Int64Value, was: %T`, leaseTimeAttribute))
	}

	optionsAttribute, ok := attributes["options"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`options is missing from object`)

		return nil, diags
	}

	optionsVal, ok := optionsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`options expected to be basetypes.MapValue, was: %T`, optionsAttribute))
	}

	serverIdOverrideAttribute, ok := attributes["server_id_override"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`server_id_override is missing from object`)

		return nil, diags
	}

	serverIdOverrideVal, ok := serverIdOverrideAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`server_id_override expected to be basetypes.BoolValue, was: %T`, serverIdOverrideAttribute))
	}

	serversAttribute, ok := attributes["servers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`servers is missing from object`)

		return nil, diags
	}

	serversVal, ok := serversAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`servers expected to be basetypes.ListValue, was: %T`, serversAttribute))
	}

	servers6Attribute, ok := attributes["servers6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`servers6 is missing from object`)

		return nil, diags
	}

	servers6Val, ok := servers6Attribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`servers6 expected to be basetypes.ListValue, was: %T`, servers6Attribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	type6Attribute, ok := attributes["type6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type6 is missing from object`)

		return nil, diags
	}

	type6Val, ok := type6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type6 expected to be basetypes.StringValue, was: %T`, type6Attribute))
	}

	vendorEncapsulatedAttribute, ok := attributes["vendor_encapsulated"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vendor_encapsulated is missing from object`)

		return nil, diags
	}

	vendorEncapsulatedVal, ok := vendorEncapsulatedAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vendor_encapsulated expected to be basetypes.MapValue, was: %T`, vendorEncapsulatedAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ConfigValue{
		DnsServers:         dnsServersVal,
		DnsSuffix:          dnsSuffixVal,
		FixedBindings:      fixedBindingsVal,
		Gateway:            gatewayVal,
		IpEnd4:             ipEnd4Val,
		IpEnd6:             ipEnd6Val,
		IpStart4:           ipStart4Val,
		IpStart6:           ipStart6Val,
		LeaseTime:          leaseTimeVal,
		Options:            optionsVal,
		ServerIdOverride:   serverIdOverrideVal,
		Servers4:           serversVal,
		Servers6:           servers6Val,
		Type4:              typeVal,
		Type6:              type6Val,
		VendorEncapsulated: vendorEncapsulatedVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewConfigValueNull() ConfigValue {
	return ConfigValue{
		state: attr.ValueStateNull,
	}
}

func NewConfigValueUnknown() ConfigValue {
	return ConfigValue{
		state: attr.ValueStateUnknown,
	}
}

func NewConfigValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ConfigValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ConfigValue Attribute Value",
				"While creating a ConfigValue value, a missing attribute value was detected. "+
					"A ConfigValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ConfigValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ConfigValue Attribute Type",
				"While creating a ConfigValue value, an invalid attribute value was detected. "+
					"A ConfigValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ConfigValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ConfigValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ConfigValue Attribute Value",
				"While creating a ConfigValue value, an extra attribute value was detected. "+
					"A ConfigValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ConfigValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewConfigValueUnknown(), diags
	}

	dnsServersAttribute, ok := attributes["dns_servers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dns_servers is missing from object`)

		return NewConfigValueUnknown(), diags
	}

	dnsServersVal, ok := dnsServersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dns_servers expected to be basetypes.ListValue, was: %T`, dnsServersAttribute))
	}

	dnsSuffixAttribute, ok := attributes["dns_suffix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dns_suffix is missing from object`)

		return NewConfigValueUnknown(), diags
	}

	dnsSuffixVal, ok := dnsSuffixAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dns_suffix expected to be basetypes.ListValue, was: %T`, dnsSuffixAttribute))
	}

	fixedBindingsAttribute, ok := attributes["fixed_bindings"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fixed_bindings is missing from object`)

		return NewConfigValueUnknown(), diags
	}

	fixedBindingsVal, ok := fixedBindingsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fixed_bindings expected to be basetypes.MapValue, was: %T`, fixedBindingsAttribute))
	}

	gatewayAttribute, ok := attributes["gateway"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gateway is missing from object`)

		return NewConfigValueUnknown(), diags
	}

	gatewayVal, ok := gatewayAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gateway expected to be basetypes.StringValue, was: %T`, gatewayAttribute))
	}

	ipEnd4Attribute, ok := attributes["ip_end"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_end is missing from object`)

		return NewConfigValueUnknown(), diags
	}

	ipEnd4Val, ok := ipEnd4Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_end expected to be basetypes.StringValue, was: %T`, ipEnd4Attribute))
	}

	ipEnd6Attribute, ok := attributes["ip_end6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_end6 is missing from object`)

		return NewConfigValueUnknown(), diags
	}

	ipEnd6Val, ok := ipEnd6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_end6 expected to be basetypes.StringValue, was: %T`, ipEnd6Attribute))
	}

	ipStart4Attribute, ok := attributes["ip_start"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_start is missing from object`)

		return NewConfigValueUnknown(), diags
	}

	ipStart4Val, ok := ipStart4Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_start expected to be basetypes.StringValue, was: %T`, ipStart4Attribute))
	}

	ipStart6Attribute, ok := attributes["ip_start6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_start6 is missing from object`)

		return NewConfigValueUnknown(), diags
	}

	ipStart6Val, ok := ipStart6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_start6 expected to be basetypes.StringValue, was: %T`, ipStart6Attribute))
	}

	leaseTimeAttribute, ok := attributes["lease_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lease_time is missing from object`)

		return NewConfigValueUnknown(), diags
	}

	leaseTimeVal, ok := leaseTimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lease_time expected to be basetypes.Int64Value, was: %T`, leaseTimeAttribute))
	}

	optionsAttribute, ok := attributes["options"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`options is missing from object`)

		return NewConfigValueUnknown(), diags
	}

	optionsVal, ok := optionsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`options expected to be basetypes.MapValue, was: %T`, optionsAttribute))
	}

	serverIdOverrideAttribute, ok := attributes["server_id_override"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`server_id_override is missing from object`)

		return NewConfigValueUnknown(), diags
	}

	serverIdOverrideVal, ok := serverIdOverrideAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`server_id_override expected to be basetypes.BoolValue, was: %T`, serverIdOverrideAttribute))
	}

	serversAttribute, ok := attributes["servers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`servers is missing from object`)

		return NewConfigValueUnknown(), diags
	}

	serversVal, ok := serversAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`servers expected to be basetypes.ListValue, was: %T`, serversAttribute))
	}

	servers6Attribute, ok := attributes["servers6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`servers6 is missing from object`)

		return NewConfigValueUnknown(), diags
	}

	servers6Val, ok := servers6Attribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`servers6 expected to be basetypes.ListValue, was: %T`, servers6Attribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewConfigValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	type6Attribute, ok := attributes["type6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type6 is missing from object`)

		return NewConfigValueUnknown(), diags
	}

	type6Val, ok := type6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type6 expected to be basetypes.StringValue, was: %T`, type6Attribute))
	}

	vendorEncapsulatedAttribute, ok := attributes["vendor_encapsulated"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vendor_encapsulated is missing from object`)

		return NewConfigValueUnknown(), diags
	}

	vendorEncapsulatedVal, ok := vendorEncapsulatedAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vendor_encapsulated expected to be basetypes.MapValue, was: %T`, vendorEncapsulatedAttribute))
	}

	if diags.HasError() {
		return NewConfigValueUnknown(), diags
	}

	return ConfigValue{
		DnsServers:         dnsServersVal,
		DnsSuffix:          dnsSuffixVal,
		FixedBindings:      fixedBindingsVal,
		Gateway:            gatewayVal,
		IpEnd4:             ipEnd4Val,
		IpEnd6:             ipEnd6Val,
		IpStart4:           ipStart4Val,
		IpStart6:           ipStart6Val,
		LeaseTime:          leaseTimeVal,
		Options:            optionsVal,
		ServerIdOverride:   serverIdOverrideVal,
		Servers4:           serversVal,
		Servers6:           servers6Val,
		Type4:              typeVal,
		Type6:              type6Val,
		VendorEncapsulated: vendorEncapsulatedVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewConfigValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ConfigValue {
	object, diags := NewConfigValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewConfigValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ConfigType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewConfigValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewConfigValueUnknown(), nil
	}

	if in.IsNull() {
		return NewConfigValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewConfigValueMust(ConfigValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ConfigType) ValueType(ctx context.Context) attr.Value {
	return ConfigValue{}
}

var _ basetypes.ObjectValuable = ConfigValue{}

type ConfigValue struct {
	DnsServers         basetypes.ListValue   `tfsdk:"dns_servers"`
	DnsSuffix          basetypes.ListValue   `tfsdk:"dns_suffix"`
	FixedBindings      basetypes.MapValue    `tfsdk:"fixed_bindings"`
	Gateway            basetypes.StringValue `tfsdk:"gateway"`
	IpEnd4             basetypes.StringValue `tfsdk:"ip_end"`
	IpEnd6             basetypes.StringValue `tfsdk:"ip_end6"`
	IpStart4           basetypes.StringValue `tfsdk:"ip_start"`
	IpStart6           basetypes.StringValue `tfsdk:"ip_start6"`
	LeaseTime          basetypes.Int64Value  `tfsdk:"lease_time"`
	Options            basetypes.MapValue    `tfsdk:"options"`
	ServerIdOverride   basetypes.BoolValue   `tfsdk:"server_id_override"`
	Servers4           basetypes.ListValue   `tfsdk:"servers"`
	Servers6           basetypes.ListValue   `tfsdk:"servers6"`
	Type4              basetypes.StringValue `tfsdk:"type"`
	Type6              basetypes.StringValue `tfsdk:"type6"`
	VendorEncapsulated basetypes.MapValue    `tfsdk:"vendor_encapsulated"`
	state              attr.ValueState
}

func (v ConfigValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 16)

	var val tftypes.Value
	var err error

	attrTypes["dns_servers"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["dns_suffix"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["fixed_bindings"] = basetypes.MapType{
		ElemType: FixedBindingsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["gateway"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ip_end"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ip_end6"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ip_start"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ip_start6"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["lease_time"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["options"] = basetypes.MapType{
		ElemType: OptionsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["server_id_override"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["servers"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["servers6"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["type6"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["vendor_encapsulated"] = basetypes.MapType{
		ElemType: VendorEncapsulatedValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 16)

		val, err = v.DnsServers.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dns_servers"] = val

		val, err = v.DnsSuffix.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dns_suffix"] = val

		val, err = v.FixedBindings.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["fixed_bindings"] = val

		val, err = v.Gateway.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["gateway"] = val

		val, err = v.IpEnd4.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip_end"] = val

		val, err = v.IpEnd6.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip_end6"] = val

		val, err = v.IpStart4.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip_start"] = val

		val, err = v.IpStart6.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip_start6"] = val

		val, err = v.LeaseTime.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["lease_time"] = val

		val, err = v.Options.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["options"] = val

		val, err = v.ServerIdOverride.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["server_id_override"] = val

		val, err = v.Servers4.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["servers"] = val

		val, err = v.Servers6.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["servers6"] = val

		val, err = v.Type4.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		val, err = v.Type6.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type6"] = val

		val, err = v.VendorEncapsulated.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vendor_encapsulated"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ConfigValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ConfigValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ConfigValue) String() string {
	return "ConfigValue"
}

func (v ConfigValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	fixedBindings := types.MapValueMust(
		FixedBindingsType{
			basetypes.ObjectType{
				AttrTypes: FixedBindingsValue{}.AttributeTypes(ctx),
			},
		},
		v.FixedBindings.Elements(),
	)

	if v.FixedBindings.IsNull() {
		fixedBindings = types.MapNull(
			FixedBindingsType{
				basetypes.ObjectType{
					AttrTypes: FixedBindingsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.FixedBindings.IsUnknown() {
		fixedBindings = types.MapUnknown(
			FixedBindingsType{
				basetypes.ObjectType{
					AttrTypes: FixedBindingsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	options := types.MapValueMust(
		OptionsType{
			basetypes.ObjectType{
				AttrTypes: OptionsValue{}.AttributeTypes(ctx),
			},
		},
		v.Options.Elements(),
	)

	if v.Options.IsNull() {
		options = types.MapNull(
			OptionsType{
				basetypes.ObjectType{
					AttrTypes: OptionsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Options.IsUnknown() {
		options = types.MapUnknown(
			OptionsType{
				basetypes.ObjectType{
					AttrTypes: OptionsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	vendorEncapsulated := types.MapValueMust(
		VendorEncapsulatedType{
			basetypes.ObjectType{
				AttrTypes: VendorEncapsulatedValue{}.AttributeTypes(ctx),
			},
		},
		v.VendorEncapsulated.Elements(),
	)

	if v.VendorEncapsulated.IsNull() {
		vendorEncapsulated = types.MapNull(
			VendorEncapsulatedType{
				basetypes.ObjectType{
					AttrTypes: VendorEncapsulatedValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.VendorEncapsulated.IsUnknown() {
		vendorEncapsulated = types.MapUnknown(
			VendorEncapsulatedType{
				basetypes.ObjectType{
					AttrTypes: VendorEncapsulatedValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var dnsServersVal basetypes.ListValue
	switch {
	case v.DnsServers.IsUnknown():
		dnsServersVal = types.ListUnknown(types.StringType)
	case v.DnsServers.IsNull():
		dnsServersVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		dnsServersVal, d = types.ListValue(types.StringType, v.DnsServers.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"dns_servers": basetypes.ListType{
				ElemType: types.StringType,
			},
			"dns_suffix": basetypes.ListType{
				ElemType: types.StringType,
			},
			"fixed_bindings": basetypes.MapType{
				ElemType: FixedBindingsValue{}.Type(ctx),
			},
			"gateway":    basetypes.StringType{},
			"ip_end":     basetypes.StringType{},
			"ip_end6":    basetypes.StringType{},
			"ip_start":   basetypes.StringType{},
			"ip_start6":  basetypes.StringType{},
			"lease_time": basetypes.Int64Type{},
			"options": basetypes.MapType{
				ElemType: OptionsValue{}.Type(ctx),
			},
			"server_id_override": basetypes.BoolType{},
			"servers": basetypes.ListType{
				ElemType: types.StringType,
			},
			"servers6": basetypes.ListType{
				ElemType: types.StringType,
			},
			"type":  basetypes.StringType{},
			"type6": basetypes.StringType{},
			"vendor_encapsulated": basetypes.MapType{
				ElemType: VendorEncapsulatedValue{}.Type(ctx),
			},
		}), diags
	}

	var dnsSuffixVal basetypes.ListValue
	switch {
	case v.DnsSuffix.IsUnknown():
		dnsSuffixVal = types.ListUnknown(types.StringType)
	case v.DnsSuffix.IsNull():
		dnsSuffixVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		dnsSuffixVal, d = types.ListValue(types.StringType, v.DnsSuffix.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"dns_servers": basetypes.ListType{
				ElemType: types.StringType,
			},
			"dns_suffix": basetypes.ListType{
				ElemType: types.StringType,
			},
			"fixed_bindings": basetypes.MapType{
				ElemType: FixedBindingsValue{}.Type(ctx),
			},
			"gateway":    basetypes.StringType{},
			"ip_end":     basetypes.StringType{},
			"ip_end6":    basetypes.StringType{},
			"ip_start":   basetypes.StringType{},
			"ip_start6":  basetypes.StringType{},
			"lease_time": basetypes.Int64Type{},
			"options": basetypes.MapType{
				ElemType: OptionsValue{}.Type(ctx),
			},
			"server_id_override": basetypes.BoolType{},
			"servers": basetypes.ListType{
				ElemType: types.StringType,
			},
			"servers6": basetypes.ListType{
				ElemType: types.StringType,
			},
			"type":  basetypes.StringType{},
			"type6": basetypes.StringType{},
			"vendor_encapsulated": basetypes.MapType{
				ElemType: VendorEncapsulatedValue{}.Type(ctx),
			},
		}), diags
	}

	var serversVal basetypes.ListValue
	switch {
	case v.Servers4.IsUnknown():
		serversVal = types.ListUnknown(types.StringType)
	case v.Servers4.IsNull():
		serversVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		serversVal, d = types.ListValue(types.StringType, v.Servers4.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"dns_servers": basetypes.ListType{
				ElemType: types.StringType,
			},
			"dns_suffix": basetypes.ListType{
				ElemType: types.StringType,
			},
			"fixed_bindings": basetypes.MapType{
				ElemType: FixedBindingsValue{}.Type(ctx),
			},
			"gateway":    basetypes.StringType{},
			"ip_end":     basetypes.StringType{},
			"ip_end6":    basetypes.StringType{},
			"ip_start":   basetypes.StringType{},
			"ip_start6":  basetypes.StringType{},
			"lease_time": basetypes.Int64Type{},
			"options": basetypes.MapType{
				ElemType: OptionsValue{}.Type(ctx),
			},
			"server_id_override": basetypes.BoolType{},
			"servers": basetypes.ListType{
				ElemType: types.StringType,
			},
			"servers6": basetypes.ListType{
				ElemType: types.StringType,
			},
			"type":  basetypes.StringType{},
			"type6": basetypes.StringType{},
			"vendor_encapsulated": basetypes.MapType{
				ElemType: VendorEncapsulatedValue{}.Type(ctx),
			},
		}), diags
	}

	var servers6Val basetypes.ListValue
	switch {
	case v.Servers6.IsUnknown():
		servers6Val = types.ListUnknown(types.StringType)
	case v.Servers6.IsNull():
		servers6Val = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		servers6Val, d = types.ListValue(types.StringType, v.Servers6.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"dns_servers": basetypes.ListType{
				ElemType: types.StringType,
			},
			"dns_suffix": basetypes.ListType{
				ElemType: types.StringType,
			},
			"fixed_bindings": basetypes.MapType{
				ElemType: FixedBindingsValue{}.Type(ctx),
			},
			"gateway":    basetypes.StringType{},
			"ip_end":     basetypes.StringType{},
			"ip_end6":    basetypes.StringType{},
			"ip_start":   basetypes.StringType{},
			"ip_start6":  basetypes.StringType{},
			"lease_time": basetypes.Int64Type{},
			"options": basetypes.MapType{
				ElemType: OptionsValue{}.Type(ctx),
			},
			"server_id_override": basetypes.BoolType{},
			"servers": basetypes.ListType{
				ElemType: types.StringType,
			},
			"servers6": basetypes.ListType{
				ElemType: types.StringType,
			},
			"type":  basetypes.StringType{},
			"type6": basetypes.StringType{},
			"vendor_encapsulated": basetypes.MapType{
				ElemType: VendorEncapsulatedValue{}.Type(ctx),
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"dns_servers": basetypes.ListType{
			ElemType: types.StringType,
		},
		"dns_suffix": basetypes.ListType{
			ElemType: types.StringType,
		},
		"fixed_bindings": basetypes.MapType{
			ElemType: FixedBindingsValue{}.Type(ctx),
		},
		"gateway":    basetypes.StringType{},
		"ip_end":     basetypes.StringType{},
		"ip_end6":    basetypes.StringType{},
		"ip_start":   basetypes.StringType{},
		"ip_start6":  basetypes.StringType{},
		"lease_time": basetypes.Int64Type{},
		"options": basetypes.MapType{
			ElemType: OptionsValue{}.Type(ctx),
		},
		"server_id_override": basetypes.BoolType{},
		"servers": basetypes.ListType{
			ElemType: types.StringType,
		},
		"servers6": basetypes.ListType{
			ElemType: types.StringType,
		},
		"type":  basetypes.StringType{},
		"type6": basetypes.StringType{},
		"vendor_encapsulated": basetypes.MapType{
			ElemType: VendorEncapsulatedValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"dns_servers":         dnsServersVal,
			"dns_suffix":          dnsSuffixVal,
			"fixed_bindings":      fixedBindings,
			"gateway":             v.Gateway,
			"ip_end":              v.IpEnd4,
			"ip_end6":             v.IpEnd6,
			"ip_start":            v.IpStart4,
			"ip_start6":           v.IpStart6,
			"lease_time":          v.LeaseTime,
			"options":             options,
			"server_id_override":  v.ServerIdOverride,
			"servers":             serversVal,
			"servers6":            servers6Val,
			"type":                v.Type4,
			"type6":               v.Type6,
			"vendor_encapsulated": vendorEncapsulated,
		})

	return objVal, diags
}

func (v ConfigValue) Equal(o attr.Value) bool {
	other, ok := o.(ConfigValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.DnsServers.Equal(other.DnsServers) {
		return false
	}

	if !v.DnsSuffix.Equal(other.DnsSuffix) {
		return false
	}

	if !v.FixedBindings.Equal(other.FixedBindings) {
		return false
	}

	if !v.Gateway.Equal(other.Gateway) {
		return false
	}

	if !v.IpEnd4.Equal(other.IpEnd4) {
		return false
	}

	if !v.IpEnd6.Equal(other.IpEnd6) {
		return false
	}

	if !v.IpStart4.Equal(other.IpStart4) {
		return false
	}

	if !v.IpStart6.Equal(other.IpStart6) {
		return false
	}

	if !v.LeaseTime.Equal(other.LeaseTime) {
		return false
	}

	if !v.Options.Equal(other.Options) {
		return false
	}

	if !v.ServerIdOverride.Equal(other.ServerIdOverride) {
		return false
	}

	if !v.Servers4.Equal(other.Servers4) {
		return false
	}

	if !v.Servers6.Equal(other.Servers6) {
		return false
	}

	if !v.Type4.Equal(other.Type4) {
		return false
	}

	if !v.Type6.Equal(other.Type6) {
		return false
	}

	if !v.VendorEncapsulated.Equal(other.VendorEncapsulated) {
		return false
	}

	return true
}

func (v ConfigValue) Type(ctx context.Context) attr.Type {
	return ConfigType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ConfigValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"dns_servers": basetypes.ListType{
			ElemType: types.StringType,
		},
		"dns_suffix": basetypes.ListType{
			ElemType: types.StringType,
		},
		"fixed_bindings": basetypes.MapType{
			ElemType: FixedBindingsValue{}.Type(ctx),
		},
		"gateway":    basetypes.StringType{},
		"ip_end":     basetypes.StringType{},
		"ip_end6":    basetypes.StringType{},
		"ip_start":   basetypes.StringType{},
		"ip_start6":  basetypes.StringType{},
		"lease_time": basetypes.Int64Type{},
		"options": basetypes.MapType{
			ElemType: OptionsValue{}.Type(ctx),
		},
		"server_id_override": basetypes.BoolType{},
		"servers": basetypes.ListType{
			ElemType: types.StringType,
		},
		"servers6": basetypes.ListType{
			ElemType: types.StringType,
		},
		"type":  basetypes.StringType{},
		"type6": basetypes.StringType{},
		"vendor_encapsulated": basetypes.MapType{
			ElemType: VendorEncapsulatedValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = FixedBindingsType{}

type FixedBindingsType struct {
	basetypes.ObjectType
}

func (t FixedBindingsType) Equal(o attr.Type) bool {
	other, ok := o.(FixedBindingsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t FixedBindingsType) String() string {
	return "FixedBindingsType"
}

func (t FixedBindingsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	ipAttribute, ok := attributes["ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip is missing from object`)

		return nil, diags
	}

	ipVal, ok := ipAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip expected to be basetypes.StringValue, was: %T`, ipAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return FixedBindingsValue{
		Ip:    ipVal,
		Name:  nameVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewFixedBindingsValueNull() FixedBindingsValue {
	return FixedBindingsValue{
		state: attr.ValueStateNull,
	}
}

func NewFixedBindingsValueUnknown() FixedBindingsValue {
	return FixedBindingsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewFixedBindingsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (FixedBindingsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing FixedBindingsValue Attribute Value",
				"While creating a FixedBindingsValue value, a missing attribute value was detected. "+
					"A FixedBindingsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("FixedBindingsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid FixedBindingsValue Attribute Type",
				"While creating a FixedBindingsValue value, an invalid attribute value was detected. "+
					"A FixedBindingsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("FixedBindingsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("FixedBindingsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra FixedBindingsValue Attribute Value",
				"While creating a FixedBindingsValue value, an extra attribute value was detected. "+
					"A FixedBindingsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra FixedBindingsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewFixedBindingsValueUnknown(), diags
	}

	ipAttribute, ok := attributes["ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip is missing from object`)

		return NewFixedBindingsValueUnknown(), diags
	}

	ipVal, ok := ipAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip expected to be basetypes.StringValue, was: %T`, ipAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewFixedBindingsValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	if diags.HasError() {
		return NewFixedBindingsValueUnknown(), diags
	}

	return FixedBindingsValue{
		Ip:    ipVal,
		Name:  nameVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewFixedBindingsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) FixedBindingsValue {
	object, diags := NewFixedBindingsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewFixedBindingsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t FixedBindingsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewFixedBindingsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewFixedBindingsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewFixedBindingsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewFixedBindingsValueMust(FixedBindingsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t FixedBindingsType) ValueType(ctx context.Context) attr.Value {
	return FixedBindingsValue{}
}

var _ basetypes.ObjectValuable = FixedBindingsValue{}

type FixedBindingsValue struct {
	Ip    basetypes.StringValue `tfsdk:"ip"`
	Name  basetypes.StringValue `tfsdk:"name"`
	state attr.ValueState
}

func (v FixedBindingsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["ip"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Ip.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v FixedBindingsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v FixedBindingsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v FixedBindingsValue) String() string {
	return "FixedBindingsValue"
}

func (v FixedBindingsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"ip":   basetypes.StringType{},
		"name": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"ip":   v.Ip,
			"name": v.Name,
		})

	return objVal, diags
}

func (v FixedBindingsValue) Equal(o attr.Value) bool {
	other, ok := o.(FixedBindingsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Ip.Equal(other.Ip) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	return true
}

func (v FixedBindingsValue) Type(ctx context.Context) attr.Type {
	return FixedBindingsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v FixedBindingsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"ip":   basetypes.StringType{},
		"name": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = OptionsType{}

type OptionsType struct {
	basetypes.ObjectType
}

func (t OptionsType) Equal(o attr.Type) bool {
	other, ok := o.(OptionsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t OptionsType) String() string {
	return "OptionsType"
}

func (t OptionsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return nil, diags
	}

	valueVal, ok := valueAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.StringValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return OptionsValue{
		OptionsType: typeVal,
		Value:       valueVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewOptionsValueNull() OptionsValue {
	return OptionsValue{
		state: attr.ValueStateNull,
	}
}

func NewOptionsValueUnknown() OptionsValue {
	return OptionsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewOptionsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (OptionsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing OptionsValue Attribute Value",
				"While creating a OptionsValue value, a missing attribute value was detected. "+
					"A OptionsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OptionsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid OptionsValue Attribute Type",
				"While creating a OptionsValue value, an invalid attribute value was detected. "+
					"A OptionsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OptionsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("OptionsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra OptionsValue Attribute Value",
				"While creating a OptionsValue value, an extra attribute value was detected. "+
					"A OptionsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra OptionsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewOptionsValueUnknown(), diags
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewOptionsValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return NewOptionsValueUnknown(), diags
	}

	valueVal, ok := valueAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.StringValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return NewOptionsValueUnknown(), diags
	}

	return OptionsValue{
		OptionsType: typeVal,
		Value:       valueVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewOptionsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) OptionsValue {
	object, diags := NewOptionsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewOptionsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t OptionsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewOptionsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewOptionsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewOptionsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewOptionsValueMust(OptionsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t OptionsType) ValueType(ctx context.Context) attr.Value {
	return OptionsValue{}
}

var _ basetypes.ObjectValuable = OptionsValue{}

type OptionsValue struct {
	OptionsType basetypes.StringValue `tfsdk:"type"`
	Value       basetypes.StringValue `tfsdk:"value"`
	state       attr.ValueState
}

func (v OptionsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["value"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.OptionsType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		val, err = v.Value.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["value"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v OptionsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v OptionsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v OptionsValue) String() string {
	return "OptionsValue"
}

func (v OptionsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"type":  basetypes.StringType{},
		"value": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"type":  v.OptionsType,
			"value": v.Value,
		})

	return objVal, diags
}

func (v OptionsValue) Equal(o attr.Value) bool {
	other, ok := o.(OptionsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.OptionsType.Equal(other.OptionsType) {
		return false
	}

	if !v.Value.Equal(other.Value) {
		return false
	}

	return true
}

func (v OptionsValue) Type(ctx context.Context) attr.Type {
	return OptionsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v OptionsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"type":  basetypes.StringType{},
		"value": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = VendorEncapsulatedType{}

type VendorEncapsulatedType struct {
	basetypes.ObjectType
}

func (t VendorEncapsulatedType) Equal(o attr.Type) bool {
	other, ok := o.(VendorEncapsulatedType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t VendorEncapsulatedType) String() string {
	return "VendorEncapsulatedType"
}

func (t VendorEncapsulatedType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return nil, diags
	}

	valueVal, ok := valueAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.StringValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return VendorEncapsulatedValue{
		VendorEncapsulatedType: typeVal,
		Value:                  valueVal,
		state:                  attr.ValueStateKnown,
	}, diags
}

func NewVendorEncapsulatedValueNull() VendorEncapsulatedValue {
	return VendorEncapsulatedValue{
		state: attr.ValueStateNull,
	}
}

func NewVendorEncapsulatedValueUnknown() VendorEncapsulatedValue {
	return VendorEncapsulatedValue{
		state: attr.ValueStateUnknown,
	}
}

func NewVendorEncapsulatedValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (VendorEncapsulatedValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing VendorEncapsulatedValue Attribute Value",
				"While creating a VendorEncapsulatedValue value, a missing attribute value was detected. "+
					"A VendorEncapsulatedValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VendorEncapsulatedValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid VendorEncapsulatedValue Attribute Type",
				"While creating a VendorEncapsulatedValue value, an invalid attribute value was detected. "+
					"A VendorEncapsulatedValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VendorEncapsulatedValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("VendorEncapsulatedValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra VendorEncapsulatedValue Attribute Value",
				"While creating a VendorEncapsulatedValue value, an extra attribute value was detected. "+
					"A VendorEncapsulatedValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra VendorEncapsulatedValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewVendorEncapsulatedValueUnknown(), diags
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewVendorEncapsulatedValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return NewVendorEncapsulatedValueUnknown(), diags
	}

	valueVal, ok := valueAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.StringValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return NewVendorEncapsulatedValueUnknown(), diags
	}

	return VendorEncapsulatedValue{
		VendorEncapsulatedType: typeVal,
		Value:                  valueVal,
		state:                  attr.ValueStateKnown,
	}, diags
}

func NewVendorEncapsulatedValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) VendorEncapsulatedValue {
	object, diags := NewVendorEncapsulatedValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewVendorEncapsulatedValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t VendorEncapsulatedType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewVendorEncapsulatedValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewVendorEncapsulatedValueUnknown(), nil
	}

	if in.IsNull() {
		return NewVendorEncapsulatedValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewVendorEncapsulatedValueMust(VendorEncapsulatedValue{}.AttributeTypes(ctx), attributes), nil
}

func (t VendorEncapsulatedType) ValueType(ctx context.Context) attr.Value {
	return VendorEncapsulatedValue{}
}

var _ basetypes.ObjectValuable = VendorEncapsulatedValue{}

type VendorEncapsulatedValue struct {
	VendorEncapsulatedType basetypes.StringValue `tfsdk:"type"`
	Value                  basetypes.StringValue `tfsdk:"value"`
	state                  attr.ValueState
}

func (v VendorEncapsulatedValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["value"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.VendorEncapsulatedType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		val, err = v.Value.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["value"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v VendorEncapsulatedValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v VendorEncapsulatedValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v VendorEncapsulatedValue) String() string {
	return "VendorEncapsulatedValue"
}

func (v VendorEncapsulatedValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"type":  basetypes.StringType{},
		"value": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"type":  v.VendorEncapsulatedType,
			"value": v.Value,
		})

	return objVal, diags
}

func (v VendorEncapsulatedValue) Equal(o attr.Value) bool {
	other, ok := o.(VendorEncapsulatedValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.VendorEncapsulatedType.Equal(other.VendorEncapsulatedType) {
		return false
	}

	if !v.Value.Equal(other.Value) {
		return false
	}

	return true
}

func (v VendorEncapsulatedValue) Type(ctx context.Context) attr.Type {
	return VendorEncapsulatedType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v VendorEncapsulatedValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"type":  basetypes.StringType{},
		"value": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = ExtraRoutesType{}

type ExtraRoutesType struct {
	basetypes.ObjectType
}

func (t ExtraRoutesType) Equal(o attr.Type) bool {
	other, ok := o.(ExtraRoutesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ExtraRoutesType) String() string {
	return "ExtraRoutesType"
}

func (t ExtraRoutesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	viaAttribute, ok := attributes["via"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`via is missing from object`)

		return nil, diags
	}

	viaVal, ok := viaAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`via expected to be basetypes.StringValue, was: %T`, viaAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ExtraRoutesValue{
		Via:   viaVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewExtraRoutesValueNull() ExtraRoutesValue {
	return ExtraRoutesValue{
		state: attr.ValueStateNull,
	}
}

func NewExtraRoutesValueUnknown() ExtraRoutesValue {
	return ExtraRoutesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewExtraRoutesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ExtraRoutesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ExtraRoutesValue Attribute Value",
				"While creating a ExtraRoutesValue value, a missing attribute value was detected. "+
					"A ExtraRoutesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ExtraRoutesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ExtraRoutesValue Attribute Type",
				"While creating a ExtraRoutesValue value, an invalid attribute value was detected. "+
					"A ExtraRoutesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ExtraRoutesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ExtraRoutesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ExtraRoutesValue Attribute Value",
				"While creating a ExtraRoutesValue value, an extra attribute value was detected. "+
					"A ExtraRoutesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ExtraRoutesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewExtraRoutesValueUnknown(), diags
	}

	viaAttribute, ok := attributes["via"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`via is missing from object`)

		return NewExtraRoutesValueUnknown(), diags
	}

	viaVal, ok := viaAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`via expected to be basetypes.StringValue, was: %T`, viaAttribute))
	}

	if diags.HasError() {
		return NewExtraRoutesValueUnknown(), diags
	}

	return ExtraRoutesValue{
		Via:   viaVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewExtraRoutesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ExtraRoutesValue {
	object, diags := NewExtraRoutesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewExtraRoutesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ExtraRoutesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewExtraRoutesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewExtraRoutesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewExtraRoutesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewExtraRoutesValueMust(ExtraRoutesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ExtraRoutesType) ValueType(ctx context.Context) attr.Value {
	return ExtraRoutesValue{}
}

var _ basetypes.ObjectValuable = ExtraRoutesValue{}

type ExtraRoutesValue struct {
	Via   basetypes.StringValue `tfsdk:"via"`
	state attr.ValueState
}

func (v ExtraRoutesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["via"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Via.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["via"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ExtraRoutesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ExtraRoutesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ExtraRoutesValue) String() string {
	return "ExtraRoutesValue"
}

func (v ExtraRoutesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"via": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"via": v.Via,
		})

	return objVal, diags
}

func (v ExtraRoutesValue) Equal(o attr.Value) bool {
	other, ok := o.(ExtraRoutesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Via.Equal(other.Via) {
		return false
	}

	return true
}

func (v ExtraRoutesValue) Type(ctx context.Context) attr.Type {
	return ExtraRoutesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ExtraRoutesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"via": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = ExtraRoutes6Type{}

type ExtraRoutes6Type struct {
	basetypes.ObjectType
}

func (t ExtraRoutes6Type) Equal(o attr.Type) bool {
	other, ok := o.(ExtraRoutes6Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ExtraRoutes6Type) String() string {
	return "ExtraRoutes6Type"
}

func (t ExtraRoutes6Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	viaAttribute, ok := attributes["via"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`via is missing from object`)

		return nil, diags
	}

	viaVal, ok := viaAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`via expected to be basetypes.StringValue, was: %T`, viaAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ExtraRoutes6Value{
		Via:   viaVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewExtraRoutes6ValueNull() ExtraRoutes6Value {
	return ExtraRoutes6Value{
		state: attr.ValueStateNull,
	}
}

func NewExtraRoutes6ValueUnknown() ExtraRoutes6Value {
	return ExtraRoutes6Value{
		state: attr.ValueStateUnknown,
	}
}

func NewExtraRoutes6Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ExtraRoutes6Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ExtraRoutes6Value Attribute Value",
				"While creating a ExtraRoutes6Value value, a missing attribute value was detected. "+
					"A ExtraRoutes6Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ExtraRoutes6Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ExtraRoutes6Value Attribute Type",
				"While creating a ExtraRoutes6Value value, an invalid attribute value was detected. "+
					"A ExtraRoutes6Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ExtraRoutes6Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ExtraRoutes6Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ExtraRoutes6Value Attribute Value",
				"While creating a ExtraRoutes6Value value, an extra attribute value was detected. "+
					"A ExtraRoutes6Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ExtraRoutes6Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewExtraRoutes6ValueUnknown(), diags
	}

	viaAttribute, ok := attributes["via"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`via is missing from object`)

		return NewExtraRoutes6ValueUnknown(), diags
	}

	viaVal, ok := viaAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`via expected to be basetypes.StringValue, was: %T`, viaAttribute))
	}

	if diags.HasError() {
		return NewExtraRoutes6ValueUnknown(), diags
	}

	return ExtraRoutes6Value{
		Via:   viaVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewExtraRoutes6ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ExtraRoutes6Value {
	object, diags := NewExtraRoutes6Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewExtraRoutes6ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ExtraRoutes6Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewExtraRoutes6ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewExtraRoutes6ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewExtraRoutes6ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewExtraRoutes6ValueMust(ExtraRoutes6Value{}.AttributeTypes(ctx), attributes), nil
}

func (t ExtraRoutes6Type) ValueType(ctx context.Context) attr.Value {
	return ExtraRoutes6Value{}
}

var _ basetypes.ObjectValuable = ExtraRoutes6Value{}

type ExtraRoutes6Value struct {
	Via   basetypes.StringValue `tfsdk:"via"`
	state attr.ValueState
}

func (v ExtraRoutes6Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["via"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Via.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["via"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ExtraRoutes6Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ExtraRoutes6Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ExtraRoutes6Value) String() string {
	return "ExtraRoutes6Value"
}

func (v ExtraRoutes6Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"via": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"via": v.Via,
		})

	return objVal, diags
}

func (v ExtraRoutes6Value) Equal(o attr.Value) bool {
	other, ok := o.(ExtraRoutes6Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Via.Equal(other.Via) {
		return false
	}

	return true
}

func (v ExtraRoutes6Value) Type(ctx context.Context) attr.Type {
	return ExtraRoutes6Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ExtraRoutes6Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"via": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = IdpProfilesType{}

type IdpProfilesType struct {
	basetypes.ObjectType
}

func (t IdpProfilesType) Equal(o attr.Type) bool {
	other, ok := o.(IdpProfilesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t IdpProfilesType) String() string {
	return "IdpProfilesType"
}

func (t IdpProfilesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	baseProfileAttribute, ok := attributes["base_profile"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`base_profile is missing from object`)

		return nil, diags
	}

	baseProfileVal, ok := baseProfileAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`base_profile expected to be basetypes.StringValue, was: %T`, baseProfileAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	orgIdAttribute, ok := attributes["org_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`org_id is missing from object`)

		return nil, diags
	}

	orgIdVal, ok := orgIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`org_id expected to be basetypes.StringValue, was: %T`, orgIdAttribute))
	}

	overwritesAttribute, ok := attributes["overwrites"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`overwrites is missing from object`)

		return nil, diags
	}

	overwritesVal, ok := overwritesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`overwrites expected to be basetypes.ListValue, was: %T`, overwritesAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return IdpProfilesValue{
		BaseProfile: baseProfileVal,
		Id:          idVal,
		Name:        nameVal,
		OrgId:       orgIdVal,
		Overwrites:  overwritesVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewIdpProfilesValueNull() IdpProfilesValue {
	return IdpProfilesValue{
		state: attr.ValueStateNull,
	}
}

func NewIdpProfilesValueUnknown() IdpProfilesValue {
	return IdpProfilesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewIdpProfilesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (IdpProfilesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing IdpProfilesValue Attribute Value",
				"While creating a IdpProfilesValue value, a missing attribute value was detected. "+
					"A IdpProfilesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("IdpProfilesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid IdpProfilesValue Attribute Type",
				"While creating a IdpProfilesValue value, an invalid attribute value was detected. "+
					"A IdpProfilesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("IdpProfilesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("IdpProfilesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra IdpProfilesValue Attribute Value",
				"While creating a IdpProfilesValue value, an extra attribute value was detected. "+
					"A IdpProfilesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra IdpProfilesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewIdpProfilesValueUnknown(), diags
	}

	baseProfileAttribute, ok := attributes["base_profile"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`base_profile is missing from object`)

		return NewIdpProfilesValueUnknown(), diags
	}

	baseProfileVal, ok := baseProfileAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`base_profile expected to be basetypes.StringValue, was: %T`, baseProfileAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewIdpProfilesValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewIdpProfilesValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	orgIdAttribute, ok := attributes["org_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`org_id is missing from object`)

		return NewIdpProfilesValueUnknown(), diags
	}

	orgIdVal, ok := orgIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`org_id expected to be basetypes.StringValue, was: %T`, orgIdAttribute))
	}

	overwritesAttribute, ok := attributes["overwrites"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`overwrites is missing from object`)

		return NewIdpProfilesValueUnknown(), diags
	}

	overwritesVal, ok := overwritesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`overwrites expected to be basetypes.ListValue, was: %T`, overwritesAttribute))
	}

	if diags.HasError() {
		return NewIdpProfilesValueUnknown(), diags
	}

	return IdpProfilesValue{
		BaseProfile: baseProfileVal,
		Id:          idVal,
		Name:        nameVal,
		OrgId:       orgIdVal,
		Overwrites:  overwritesVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewIdpProfilesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) IdpProfilesValue {
	object, diags := NewIdpProfilesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewIdpProfilesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t IdpProfilesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewIdpProfilesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewIdpProfilesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewIdpProfilesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewIdpProfilesValueMust(IdpProfilesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t IdpProfilesType) ValueType(ctx context.Context) attr.Value {
	return IdpProfilesValue{}
}

var _ basetypes.ObjectValuable = IdpProfilesValue{}

type IdpProfilesValue struct {
	BaseProfile basetypes.StringValue `tfsdk:"base_profile"`
	Id          basetypes.StringValue `tfsdk:"id"`
	Name        basetypes.StringValue `tfsdk:"name"`
	OrgId       basetypes.StringValue `tfsdk:"org_id"`
	Overwrites  basetypes.ListValue   `tfsdk:"overwrites"`
	state       attr.ValueState
}

func (v IdpProfilesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["base_profile"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["org_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["overwrites"] = basetypes.ListType{
		ElemType: OverwritesValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.BaseProfile.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["base_profile"] = val

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.OrgId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["org_id"] = val

		val, err = v.Overwrites.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["overwrites"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v IdpProfilesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v IdpProfilesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v IdpProfilesValue) String() string {
	return "IdpProfilesValue"
}

func (v IdpProfilesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	overwrites := types.ListValueMust(
		OverwritesType{
			basetypes.ObjectType{
				AttrTypes: OverwritesValue{}.AttributeTypes(ctx),
			},
		},
		v.Overwrites.Elements(),
	)

	if v.Overwrites.IsNull() {
		overwrites = types.ListNull(
			OverwritesType{
				basetypes.ObjectType{
					AttrTypes: OverwritesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Overwrites.IsUnknown() {
		overwrites = types.ListUnknown(
			OverwritesType{
				basetypes.ObjectType{
					AttrTypes: OverwritesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"base_profile": basetypes.StringType{},
		"id":           basetypes.StringType{},
		"name":         basetypes.StringType{},
		"org_id":       basetypes.StringType{},
		"overwrites": basetypes.ListType{
			ElemType: OverwritesValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"base_profile": v.BaseProfile,
			"id":           v.Id,
			"name":         v.Name,
			"org_id":       v.OrgId,
			"overwrites":   overwrites,
		})

	return objVal, diags
}

func (v IdpProfilesValue) Equal(o attr.Value) bool {
	other, ok := o.(IdpProfilesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.BaseProfile.Equal(other.BaseProfile) {
		return false
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.OrgId.Equal(other.OrgId) {
		return false
	}

	if !v.Overwrites.Equal(other.Overwrites) {
		return false
	}

	return true
}

func (v IdpProfilesValue) Type(ctx context.Context) attr.Type {
	return IdpProfilesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v IdpProfilesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"base_profile": basetypes.StringType{},
		"id":           basetypes.StringType{},
		"name":         basetypes.StringType{},
		"org_id":       basetypes.StringType{},
		"overwrites": basetypes.ListType{
			ElemType: OverwritesValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = OverwritesType{}

type OverwritesType struct {
	basetypes.ObjectType
}

func (t OverwritesType) Equal(o attr.Type) bool {
	other, ok := o.(OverwritesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t OverwritesType) String() string {
	return "OverwritesType"
}

func (t OverwritesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	actionAttribute, ok := attributes["action"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`action is missing from object`)

		return nil, diags
	}

	actionVal, ok := actionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`action expected to be basetypes.StringValue, was: %T`, actionAttribute))
	}

	ipdProfileOverwriteMatchingAttribute, ok := attributes["matching"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`matching is missing from object`)

		return nil, diags
	}

	ipdProfileOverwriteMatchingVal, ok := ipdProfileOverwriteMatchingAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`matching expected to be basetypes.ObjectValue, was: %T`, ipdProfileOverwriteMatchingAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return OverwritesValue{
		Action:                      actionVal,
		IpdProfileOverwriteMatching: ipdProfileOverwriteMatchingVal,
		Name:                        nameVal,
		state:                       attr.ValueStateKnown,
	}, diags
}

func NewOverwritesValueNull() OverwritesValue {
	return OverwritesValue{
		state: attr.ValueStateNull,
	}
}

func NewOverwritesValueUnknown() OverwritesValue {
	return OverwritesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewOverwritesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (OverwritesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing OverwritesValue Attribute Value",
				"While creating a OverwritesValue value, a missing attribute value was detected. "+
					"A OverwritesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OverwritesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid OverwritesValue Attribute Type",
				"While creating a OverwritesValue value, an invalid attribute value was detected. "+
					"A OverwritesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OverwritesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("OverwritesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra OverwritesValue Attribute Value",
				"While creating a OverwritesValue value, an extra attribute value was detected. "+
					"A OverwritesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra OverwritesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewOverwritesValueUnknown(), diags
	}

	actionAttribute, ok := attributes["action"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`action is missing from object`)

		return NewOverwritesValueUnknown(), diags
	}

	actionVal, ok := actionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`action expected to be basetypes.StringValue, was: %T`, actionAttribute))
	}

	ipdProfileOverwriteMatchingAttribute, ok := attributes["matching"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`matching is missing from object`)

		return NewOverwritesValueUnknown(), diags
	}

	ipdProfileOverwriteMatchingVal, ok := ipdProfileOverwriteMatchingAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`matching expected to be basetypes.ObjectValue, was: %T`, ipdProfileOverwriteMatchingAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewOverwritesValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	if diags.HasError() {
		return NewOverwritesValueUnknown(), diags
	}

	return OverwritesValue{
		Action:                      actionVal,
		IpdProfileOverwriteMatching: ipdProfileOverwriteMatchingVal,
		Name:                        nameVal,
		state:                       attr.ValueStateKnown,
	}, diags
}

func NewOverwritesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) OverwritesValue {
	object, diags := NewOverwritesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewOverwritesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t OverwritesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewOverwritesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewOverwritesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewOverwritesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewOverwritesValueMust(OverwritesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t OverwritesType) ValueType(ctx context.Context) attr.Value {
	return OverwritesValue{}
}

var _ basetypes.ObjectValuable = OverwritesValue{}

type OverwritesValue struct {
	Action                      basetypes.StringValue `tfsdk:"action"`
	IpdProfileOverwriteMatching basetypes.ObjectValue `tfsdk:"matching"`
	Name                        basetypes.StringValue `tfsdk:"name"`
	state                       attr.ValueState
}

func (v OverwritesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["action"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["matching"] = basetypes.ObjectType{
		AttrTypes: IpdProfileOverwriteMatchingValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Action.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["action"] = val

		val, err = v.IpdProfileOverwriteMatching.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["matching"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v OverwritesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v OverwritesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v OverwritesValue) String() string {
	return "OverwritesValue"
}

func (v OverwritesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var ipdProfileOverwriteMatching basetypes.ObjectValue

	if v.IpdProfileOverwriteMatching.IsNull() {
		ipdProfileOverwriteMatching = types.ObjectNull(
			IpdProfileOverwriteMatchingValue{}.AttributeTypes(ctx),
		)
	}

	if v.IpdProfileOverwriteMatching.IsUnknown() {
		ipdProfileOverwriteMatching = types.ObjectUnknown(
			IpdProfileOverwriteMatchingValue{}.AttributeTypes(ctx),
		)
	}

	if !v.IpdProfileOverwriteMatching.IsNull() && !v.IpdProfileOverwriteMatching.IsUnknown() {
		ipdProfileOverwriteMatching = types.ObjectValueMust(
			IpdProfileOverwriteMatchingValue{}.AttributeTypes(ctx),
			v.IpdProfileOverwriteMatching.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"action": basetypes.StringType{},
		"matching": basetypes.ObjectType{
			AttrTypes: IpdProfileOverwriteMatchingValue{}.AttributeTypes(ctx),
		},
		"name": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"action":   v.Action,
			"matching": ipdProfileOverwriteMatching,
			"name":     v.Name,
		})

	return objVal, diags
}

func (v OverwritesValue) Equal(o attr.Value) bool {
	other, ok := o.(OverwritesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Action.Equal(other.Action) {
		return false
	}

	if !v.IpdProfileOverwriteMatching.Equal(other.IpdProfileOverwriteMatching) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	return true
}

func (v OverwritesValue) Type(ctx context.Context) attr.Type {
	return OverwritesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v OverwritesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"action": basetypes.StringType{},
		"matching": basetypes.ObjectType{
			AttrTypes: IpdProfileOverwriteMatchingValue{}.AttributeTypes(ctx),
		},
		"name": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = IpdProfileOverwriteMatchingType{}

type IpdProfileOverwriteMatchingType struct {
	basetypes.ObjectType
}

func (t IpdProfileOverwriteMatchingType) Equal(o attr.Type) bool {
	other, ok := o.(IpdProfileOverwriteMatchingType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t IpdProfileOverwriteMatchingType) String() string {
	return "IpdProfileOverwriteMatchingType"
}

func (t IpdProfileOverwriteMatchingType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	attackNameAttribute, ok := attributes["attack_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`attack_name is missing from object`)

		return nil, diags
	}

	attackNameVal, ok := attackNameAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`attack_name expected to be basetypes.ListValue, was: %T`, attackNameAttribute))
	}

	dstSubnetAttribute, ok := attributes["dst_subnet"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dst_subnet is missing from object`)

		return nil, diags
	}

	dstSubnetVal, ok := dstSubnetAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dst_subnet expected to be basetypes.ListValue, was: %T`, dstSubnetAttribute))
	}

	severityAttribute, ok := attributes["severity"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`severity is missing from object`)

		return nil, diags
	}

	severityVal, ok := severityAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`severity expected to be basetypes.ListValue, was: %T`, severityAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return IpdProfileOverwriteMatchingValue{
		AttackName: attackNameVal,
		DstSubnet:  dstSubnetVal,
		Severity:   severityVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewIpdProfileOverwriteMatchingValueNull() IpdProfileOverwriteMatchingValue {
	return IpdProfileOverwriteMatchingValue{
		state: attr.ValueStateNull,
	}
}

func NewIpdProfileOverwriteMatchingValueUnknown() IpdProfileOverwriteMatchingValue {
	return IpdProfileOverwriteMatchingValue{
		state: attr.ValueStateUnknown,
	}
}

func NewIpdProfileOverwriteMatchingValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (IpdProfileOverwriteMatchingValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing IpdProfileOverwriteMatchingValue Attribute Value",
				"While creating a IpdProfileOverwriteMatchingValue value, a missing attribute value was detected. "+
					"A IpdProfileOverwriteMatchingValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("IpdProfileOverwriteMatchingValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid IpdProfileOverwriteMatchingValue Attribute Type",
				"While creating a IpdProfileOverwriteMatchingValue value, an invalid attribute value was detected. "+
					"A IpdProfileOverwriteMatchingValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("IpdProfileOverwriteMatchingValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("IpdProfileOverwriteMatchingValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra IpdProfileOverwriteMatchingValue Attribute Value",
				"While creating a IpdProfileOverwriteMatchingValue value, an extra attribute value was detected. "+
					"A IpdProfileOverwriteMatchingValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra IpdProfileOverwriteMatchingValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewIpdProfileOverwriteMatchingValueUnknown(), diags
	}

	attackNameAttribute, ok := attributes["attack_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`attack_name is missing from object`)

		return NewIpdProfileOverwriteMatchingValueUnknown(), diags
	}

	attackNameVal, ok := attackNameAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`attack_name expected to be basetypes.ListValue, was: %T`, attackNameAttribute))
	}

	dstSubnetAttribute, ok := attributes["dst_subnet"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dst_subnet is missing from object`)

		return NewIpdProfileOverwriteMatchingValueUnknown(), diags
	}

	dstSubnetVal, ok := dstSubnetAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dst_subnet expected to be basetypes.ListValue, was: %T`, dstSubnetAttribute))
	}

	severityAttribute, ok := attributes["severity"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`severity is missing from object`)

		return NewIpdProfileOverwriteMatchingValueUnknown(), diags
	}

	severityVal, ok := severityAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`severity expected to be basetypes.ListValue, was: %T`, severityAttribute))
	}

	if diags.HasError() {
		return NewIpdProfileOverwriteMatchingValueUnknown(), diags
	}

	return IpdProfileOverwriteMatchingValue{
		AttackName: attackNameVal,
		DstSubnet:  dstSubnetVal,
		Severity:   severityVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewIpdProfileOverwriteMatchingValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) IpdProfileOverwriteMatchingValue {
	object, diags := NewIpdProfileOverwriteMatchingValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewIpdProfileOverwriteMatchingValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t IpdProfileOverwriteMatchingType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewIpdProfileOverwriteMatchingValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewIpdProfileOverwriteMatchingValueUnknown(), nil
	}

	if in.IsNull() {
		return NewIpdProfileOverwriteMatchingValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewIpdProfileOverwriteMatchingValueMust(IpdProfileOverwriteMatchingValue{}.AttributeTypes(ctx), attributes), nil
}

func (t IpdProfileOverwriteMatchingType) ValueType(ctx context.Context) attr.Value {
	return IpdProfileOverwriteMatchingValue{}
}

var _ basetypes.ObjectValuable = IpdProfileOverwriteMatchingValue{}

type IpdProfileOverwriteMatchingValue struct {
	AttackName basetypes.ListValue `tfsdk:"attack_name"`
	DstSubnet  basetypes.ListValue `tfsdk:"dst_subnet"`
	Severity   basetypes.ListValue `tfsdk:"severity"`
	state      attr.ValueState
}

func (v IpdProfileOverwriteMatchingValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["attack_name"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["dst_subnet"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["severity"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.AttackName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["attack_name"] = val

		val, err = v.DstSubnet.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dst_subnet"] = val

		val, err = v.Severity.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["severity"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v IpdProfileOverwriteMatchingValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v IpdProfileOverwriteMatchingValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v IpdProfileOverwriteMatchingValue) String() string {
	return "IpdProfileOverwriteMatchingValue"
}

func (v IpdProfileOverwriteMatchingValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var attackNameVal basetypes.ListValue
	switch {
	case v.AttackName.IsUnknown():
		attackNameVal = types.ListUnknown(types.StringType)
	case v.AttackName.IsNull():
		attackNameVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		attackNameVal, d = types.ListValue(types.StringType, v.AttackName.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"attack_name": basetypes.ListType{
				ElemType: types.StringType,
			},
			"dst_subnet": basetypes.ListType{
				ElemType: types.StringType,
			},
			"severity": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	var dstSubnetVal basetypes.ListValue
	switch {
	case v.DstSubnet.IsUnknown():
		dstSubnetVal = types.ListUnknown(types.StringType)
	case v.DstSubnet.IsNull():
		dstSubnetVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		dstSubnetVal, d = types.ListValue(types.StringType, v.DstSubnet.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"attack_name": basetypes.ListType{
				ElemType: types.StringType,
			},
			"dst_subnet": basetypes.ListType{
				ElemType: types.StringType,
			},
			"severity": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	var severityVal basetypes.ListValue
	switch {
	case v.Severity.IsUnknown():
		severityVal = types.ListUnknown(types.StringType)
	case v.Severity.IsNull():
		severityVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		severityVal, d = types.ListValue(types.StringType, v.Severity.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"attack_name": basetypes.ListType{
				ElemType: types.StringType,
			},
			"dst_subnet": basetypes.ListType{
				ElemType: types.StringType,
			},
			"severity": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"attack_name": basetypes.ListType{
			ElemType: types.StringType,
		},
		"dst_subnet": basetypes.ListType{
			ElemType: types.StringType,
		},
		"severity": basetypes.ListType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"attack_name": attackNameVal,
			"dst_subnet":  dstSubnetVal,
			"severity":    severityVal,
		})

	return objVal, diags
}

func (v IpdProfileOverwriteMatchingValue) Equal(o attr.Value) bool {
	other, ok := o.(IpdProfileOverwriteMatchingValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AttackName.Equal(other.AttackName) {
		return false
	}

	if !v.DstSubnet.Equal(other.DstSubnet) {
		return false
	}

	if !v.Severity.Equal(other.Severity) {
		return false
	}

	return true
}

func (v IpdProfileOverwriteMatchingValue) Type(ctx context.Context) attr.Type {
	return IpdProfileOverwriteMatchingType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v IpdProfileOverwriteMatchingValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"attack_name": basetypes.ListType{
			ElemType: types.StringType,
		},
		"dst_subnet": basetypes.ListType{
			ElemType: types.StringType,
		},
		"severity": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = IpConfigsType{}

type IpConfigsType struct {
	basetypes.ObjectType
}

func (t IpConfigsType) Equal(o attr.Type) bool {
	other, ok := o.(IpConfigsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t IpConfigsType) String() string {
	return "IpConfigsType"
}

func (t IpConfigsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	ipAttribute, ok := attributes["ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip is missing from object`)

		return nil, diags
	}

	ipVal, ok := ipAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip expected to be basetypes.StringValue, was: %T`, ipAttribute))
	}

	netmaskAttribute, ok := attributes["netmask"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`netmask is missing from object`)

		return nil, diags
	}

	netmaskVal, ok := netmaskAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`netmask expected to be basetypes.StringValue, was: %T`, netmaskAttribute))
	}

	secondaryIpsAttribute, ok := attributes["secondary_ips"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`secondary_ips is missing from object`)

		return nil, diags
	}

	secondaryIpsVal, ok := secondaryIpsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`secondary_ips expected to be basetypes.ListValue, was: %T`, secondaryIpsAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return IpConfigsValue{
		Ip:            ipVal,
		Netmask:       netmaskVal,
		SecondaryIps:  secondaryIpsVal,
		IpConfigsType: typeVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewIpConfigsValueNull() IpConfigsValue {
	return IpConfigsValue{
		state: attr.ValueStateNull,
	}
}

func NewIpConfigsValueUnknown() IpConfigsValue {
	return IpConfigsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewIpConfigsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (IpConfigsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing IpConfigsValue Attribute Value",
				"While creating a IpConfigsValue value, a missing attribute value was detected. "+
					"A IpConfigsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("IpConfigsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid IpConfigsValue Attribute Type",
				"While creating a IpConfigsValue value, an invalid attribute value was detected. "+
					"A IpConfigsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("IpConfigsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("IpConfigsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra IpConfigsValue Attribute Value",
				"While creating a IpConfigsValue value, an extra attribute value was detected. "+
					"A IpConfigsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra IpConfigsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewIpConfigsValueUnknown(), diags
	}

	ipAttribute, ok := attributes["ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip is missing from object`)

		return NewIpConfigsValueUnknown(), diags
	}

	ipVal, ok := ipAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip expected to be basetypes.StringValue, was: %T`, ipAttribute))
	}

	netmaskAttribute, ok := attributes["netmask"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`netmask is missing from object`)

		return NewIpConfigsValueUnknown(), diags
	}

	netmaskVal, ok := netmaskAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`netmask expected to be basetypes.StringValue, was: %T`, netmaskAttribute))
	}

	secondaryIpsAttribute, ok := attributes["secondary_ips"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`secondary_ips is missing from object`)

		return NewIpConfigsValueUnknown(), diags
	}

	secondaryIpsVal, ok := secondaryIpsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`secondary_ips expected to be basetypes.ListValue, was: %T`, secondaryIpsAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewIpConfigsValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return NewIpConfigsValueUnknown(), diags
	}

	return IpConfigsValue{
		Ip:            ipVal,
		Netmask:       netmaskVal,
		SecondaryIps:  secondaryIpsVal,
		IpConfigsType: typeVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewIpConfigsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) IpConfigsValue {
	object, diags := NewIpConfigsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewIpConfigsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t IpConfigsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewIpConfigsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewIpConfigsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewIpConfigsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewIpConfigsValueMust(IpConfigsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t IpConfigsType) ValueType(ctx context.Context) attr.Value {
	return IpConfigsValue{}
}

var _ basetypes.ObjectValuable = IpConfigsValue{}

type IpConfigsValue struct {
	Ip            basetypes.StringValue `tfsdk:"ip"`
	Netmask       basetypes.StringValue `tfsdk:"netmask"`
	SecondaryIps  basetypes.ListValue   `tfsdk:"secondary_ips"`
	IpConfigsType basetypes.StringValue `tfsdk:"type"`
	state         attr.ValueState
}

func (v IpConfigsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["ip"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["netmask"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["secondary_ips"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Ip.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip"] = val

		val, err = v.Netmask.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["netmask"] = val

		val, err = v.SecondaryIps.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["secondary_ips"] = val

		val, err = v.IpConfigsType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v IpConfigsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v IpConfigsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v IpConfigsValue) String() string {
	return "IpConfigsValue"
}

func (v IpConfigsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var secondaryIpsVal basetypes.ListValue
	switch {
	case v.SecondaryIps.IsUnknown():
		secondaryIpsVal = types.ListUnknown(types.StringType)
	case v.SecondaryIps.IsNull():
		secondaryIpsVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		secondaryIpsVal, d = types.ListValue(types.StringType, v.SecondaryIps.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"ip":      basetypes.StringType{},
			"netmask": basetypes.StringType{},
			"secondary_ips": basetypes.ListType{
				ElemType: types.StringType,
			},
			"type": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"ip":      basetypes.StringType{},
		"netmask": basetypes.StringType{},
		"secondary_ips": basetypes.ListType{
			ElemType: types.StringType,
		},
		"type": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"ip":            v.Ip,
			"netmask":       v.Netmask,
			"secondary_ips": secondaryIpsVal,
			"type":          v.IpConfigsType,
		})

	return objVal, diags
}

func (v IpConfigsValue) Equal(o attr.Value) bool {
	other, ok := o.(IpConfigsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Ip.Equal(other.Ip) {
		return false
	}

	if !v.Netmask.Equal(other.Netmask) {
		return false
	}

	if !v.SecondaryIps.Equal(other.SecondaryIps) {
		return false
	}

	if !v.IpConfigsType.Equal(other.IpConfigsType) {
		return false
	}

	return true
}

func (v IpConfigsValue) Type(ctx context.Context) attr.Type {
	return IpConfigsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v IpConfigsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"ip":      basetypes.StringType{},
		"netmask": basetypes.StringType{},
		"secondary_ips": basetypes.ListType{
			ElemType: types.StringType,
		},
		"type": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = NetworksType{}

type NetworksType struct {
	basetypes.ObjectType
}

func (t NetworksType) Equal(o attr.Type) bool {
	other, ok := o.(NetworksType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t NetworksType) String() string {
	return "NetworksType"
}

func (t NetworksType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	disallowMistServicesAttribute, ok := attributes["disallow_mist_services"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disallow_mist_services is missing from object`)

		return nil, diags
	}

	disallowMistServicesVal, ok := disallowMistServicesAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disallow_mist_services expected to be basetypes.BoolValue, was: %T`, disallowMistServicesAttribute))
	}

	gatewayAttribute, ok := attributes["gateway"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gateway is missing from object`)

		return nil, diags
	}

	gatewayVal, ok := gatewayAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gateway expected to be basetypes.StringValue, was: %T`, gatewayAttribute))
	}

	gateway6Attribute, ok := attributes["gateway6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gateway6 is missing from object`)

		return nil, diags
	}

	gateway6Val, ok := gateway6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gateway6 expected to be basetypes.StringValue, was: %T`, gateway6Attribute))
	}

	internalAccessAttribute, ok := attributes["internal_access"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`internal_access is missing from object`)

		return nil, diags
	}

	internalAccessVal, ok := internalAccessAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`internal_access expected to be basetypes.ObjectValue, was: %T`, internalAccessAttribute))
	}

	internetAccessAttribute, ok := attributes["internet_access"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`internet_access is missing from object`)

		return nil, diags
	}

	internetAccessVal, ok := internetAccessAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`internet_access expected to be basetypes.ObjectValue, was: %T`, internetAccessAttribute))
	}

	isolationAttribute, ok := attributes["isolation"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`isolation is missing from object`)

		return nil, diags
	}

	isolationVal, ok := isolationAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`isolation expected to be basetypes.BoolValue, was: %T`, isolationAttribute))
	}

	multicastAttribute, ok := attributes["multicast"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`multicast is missing from object`)

		return nil, diags
	}

	multicastVal, ok := multicastAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`multicast expected to be basetypes.ObjectValue, was: %T`, multicastAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	routedForNetworksAttribute, ok := attributes["routed_for_networks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`routed_for_networks is missing from object`)

		return nil, diags
	}

	routedForNetworksVal, ok := routedForNetworksAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`routed_for_networks expected to be basetypes.ListValue, was: %T`, routedForNetworksAttribute))
	}

	subnetAttribute, ok := attributes["subnet"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet is missing from object`)

		return nil, diags
	}

	subnetVal, ok := subnetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet expected to be basetypes.StringValue, was: %T`, subnetAttribute))
	}

	subnet6Attribute, ok := attributes["subnet6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet6 is missing from object`)

		return nil, diags
	}

	subnet6Val, ok := subnet6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet6 expected to be basetypes.StringValue, was: %T`, subnet6Attribute))
	}

	tenantsAttribute, ok := attributes["tenants"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tenants is missing from object`)

		return nil, diags
	}

	tenantsVal, ok := tenantsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tenants expected to be basetypes.MapValue, was: %T`, tenantsAttribute))
	}

	vlanIdAttribute, ok := attributes["vlan_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan_id is missing from object`)

		return nil, diags
	}

	vlanIdVal, ok := vlanIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan_id expected to be basetypes.StringValue, was: %T`, vlanIdAttribute))
	}

	vpnAccessAttribute, ok := attributes["vpn_access"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vpn_access is missing from object`)

		return nil, diags
	}

	vpnAccessVal, ok := vpnAccessAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vpn_access expected to be basetypes.MapValue, was: %T`, vpnAccessAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return NetworksValue{
		DisallowMistServices: disallowMistServicesVal,
		Gateway:              gatewayVal,
		Gateway6:             gateway6Val,
		InternalAccess:       internalAccessVal,
		InternetAccess:       internetAccessVal,
		Isolation:            isolationVal,
		Multicast:            multicastVal,
		Name:                 nameVal,
		RoutedForNetworks:    routedForNetworksVal,
		Subnet:               subnetVal,
		Subnet6:              subnet6Val,
		Tenants:              tenantsVal,
		VlanId:               vlanIdVal,
		VpnAccess:            vpnAccessVal,
		state:                attr.ValueStateKnown,
	}, diags
}

func NewNetworksValueNull() NetworksValue {
	return NetworksValue{
		state: attr.ValueStateNull,
	}
}

func NewNetworksValueUnknown() NetworksValue {
	return NetworksValue{
		state: attr.ValueStateUnknown,
	}
}

func NewNetworksValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (NetworksValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing NetworksValue Attribute Value",
				"While creating a NetworksValue value, a missing attribute value was detected. "+
					"A NetworksValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NetworksValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid NetworksValue Attribute Type",
				"While creating a NetworksValue value, an invalid attribute value was detected. "+
					"A NetworksValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NetworksValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("NetworksValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra NetworksValue Attribute Value",
				"While creating a NetworksValue value, an extra attribute value was detected. "+
					"A NetworksValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra NetworksValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewNetworksValueUnknown(), diags
	}

	disallowMistServicesAttribute, ok := attributes["disallow_mist_services"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disallow_mist_services is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	disallowMistServicesVal, ok := disallowMistServicesAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disallow_mist_services expected to be basetypes.BoolValue, was: %T`, disallowMistServicesAttribute))
	}

	gatewayAttribute, ok := attributes["gateway"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gateway is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	gatewayVal, ok := gatewayAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gateway expected to be basetypes.StringValue, was: %T`, gatewayAttribute))
	}

	gateway6Attribute, ok := attributes["gateway6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gateway6 is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	gateway6Val, ok := gateway6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gateway6 expected to be basetypes.StringValue, was: %T`, gateway6Attribute))
	}

	internalAccessAttribute, ok := attributes["internal_access"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`internal_access is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	internalAccessVal, ok := internalAccessAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`internal_access expected to be basetypes.ObjectValue, was: %T`, internalAccessAttribute))
	}

	internetAccessAttribute, ok := attributes["internet_access"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`internet_access is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	internetAccessVal, ok := internetAccessAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`internet_access expected to be basetypes.ObjectValue, was: %T`, internetAccessAttribute))
	}

	isolationAttribute, ok := attributes["isolation"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`isolation is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	isolationVal, ok := isolationAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`isolation expected to be basetypes.BoolValue, was: %T`, isolationAttribute))
	}

	multicastAttribute, ok := attributes["multicast"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`multicast is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	multicastVal, ok := multicastAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`multicast expected to be basetypes.ObjectValue, was: %T`, multicastAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	routedForNetworksAttribute, ok := attributes["routed_for_networks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`routed_for_networks is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	routedForNetworksVal, ok := routedForNetworksAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`routed_for_networks expected to be basetypes.ListValue, was: %T`, routedForNetworksAttribute))
	}

	subnetAttribute, ok := attributes["subnet"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	subnetVal, ok := subnetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet expected to be basetypes.StringValue, was: %T`, subnetAttribute))
	}

	subnet6Attribute, ok := attributes["subnet6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet6 is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	subnet6Val, ok := subnet6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet6 expected to be basetypes.StringValue, was: %T`, subnet6Attribute))
	}

	tenantsAttribute, ok := attributes["tenants"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tenants is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	tenantsVal, ok := tenantsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tenants expected to be basetypes.MapValue, was: %T`, tenantsAttribute))
	}

	vlanIdAttribute, ok := attributes["vlan_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan_id is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	vlanIdVal, ok := vlanIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan_id expected to be basetypes.StringValue, was: %T`, vlanIdAttribute))
	}

	vpnAccessAttribute, ok := attributes["vpn_access"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vpn_access is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	vpnAccessVal, ok := vpnAccessAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vpn_access expected to be basetypes.MapValue, was: %T`, vpnAccessAttribute))
	}

	if diags.HasError() {
		return NewNetworksValueUnknown(), diags
	}

	return NetworksValue{
		DisallowMistServices: disallowMistServicesVal,
		Gateway:              gatewayVal,
		Gateway6:             gateway6Val,
		InternalAccess:       internalAccessVal,
		InternetAccess:       internetAccessVal,
		Isolation:            isolationVal,
		Multicast:            multicastVal,
		Name:                 nameVal,
		RoutedForNetworks:    routedForNetworksVal,
		Subnet:               subnetVal,
		Subnet6:              subnet6Val,
		Tenants:              tenantsVal,
		VlanId:               vlanIdVal,
		VpnAccess:            vpnAccessVal,
		state:                attr.ValueStateKnown,
	}, diags
}

func NewNetworksValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) NetworksValue {
	object, diags := NewNetworksValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewNetworksValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t NetworksType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewNetworksValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewNetworksValueUnknown(), nil
	}

	if in.IsNull() {
		return NewNetworksValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewNetworksValueMust(NetworksValue{}.AttributeTypes(ctx), attributes), nil
}

func (t NetworksType) ValueType(ctx context.Context) attr.Value {
	return NetworksValue{}
}

var _ basetypes.ObjectValuable = NetworksValue{}

type NetworksValue struct {
	DisallowMistServices basetypes.BoolValue   `tfsdk:"disallow_mist_services"`
	Gateway              basetypes.StringValue `tfsdk:"gateway"`
	Gateway6             basetypes.StringValue `tfsdk:"gateway6"`
	InternalAccess       basetypes.ObjectValue `tfsdk:"internal_access"`
	InternetAccess       basetypes.ObjectValue `tfsdk:"internet_access"`
	Isolation            basetypes.BoolValue   `tfsdk:"isolation"`
	Multicast            basetypes.ObjectValue `tfsdk:"multicast"`
	Name                 basetypes.StringValue `tfsdk:"name"`
	RoutedForNetworks    basetypes.ListValue   `tfsdk:"routed_for_networks"`
	Subnet               basetypes.StringValue `tfsdk:"subnet"`
	Subnet6              basetypes.StringValue `tfsdk:"subnet6"`
	Tenants              basetypes.MapValue    `tfsdk:"tenants"`
	VlanId               basetypes.StringValue `tfsdk:"vlan_id"`
	VpnAccess            basetypes.MapValue    `tfsdk:"vpn_access"`
	state                attr.ValueState
}

func (v NetworksValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 14)

	var val tftypes.Value
	var err error

	attrTypes["disallow_mist_services"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["gateway"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["gateway6"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["internal_access"] = basetypes.ObjectType{
		AttrTypes: InternalAccessValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["internet_access"] = basetypes.ObjectType{
		AttrTypes: InternetAccessValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["isolation"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["multicast"] = basetypes.ObjectType{
		AttrTypes: MulticastValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["routed_for_networks"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["subnet"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["subnet6"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["tenants"] = basetypes.MapType{
		ElemType: TenantsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["vlan_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["vpn_access"] = basetypes.MapType{
		ElemType: VpnAccessValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 14)

		val, err = v.DisallowMistServices.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["disallow_mist_services"] = val

		val, err = v.Gateway.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["gateway"] = val

		val, err = v.Gateway6.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["gateway6"] = val

		val, err = v.InternalAccess.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["internal_access"] = val

		val, err = v.InternetAccess.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["internet_access"] = val

		val, err = v.Isolation.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["isolation"] = val

		val, err = v.Multicast.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["multicast"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.RoutedForNetworks.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["routed_for_networks"] = val

		val, err = v.Subnet.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["subnet"] = val

		val, err = v.Subnet6.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["subnet6"] = val

		val, err = v.Tenants.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tenants"] = val

		val, err = v.VlanId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vlan_id"] = val

		val, err = v.VpnAccess.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vpn_access"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v NetworksValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v NetworksValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v NetworksValue) String() string {
	return "NetworksValue"
}

func (v NetworksValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var internalAccess basetypes.ObjectValue

	if v.InternalAccess.IsNull() {
		internalAccess = types.ObjectNull(
			InternalAccessValue{}.AttributeTypes(ctx),
		)
	}

	if v.InternalAccess.IsUnknown() {
		internalAccess = types.ObjectUnknown(
			InternalAccessValue{}.AttributeTypes(ctx),
		)
	}

	if !v.InternalAccess.IsNull() && !v.InternalAccess.IsUnknown() {
		internalAccess = types.ObjectValueMust(
			InternalAccessValue{}.AttributeTypes(ctx),
			v.InternalAccess.Attributes(),
		)
	}

	var internetAccess basetypes.ObjectValue

	if v.InternetAccess.IsNull() {
		internetAccess = types.ObjectNull(
			InternetAccessValue{}.AttributeTypes(ctx),
		)
	}

	if v.InternetAccess.IsUnknown() {
		internetAccess = types.ObjectUnknown(
			InternetAccessValue{}.AttributeTypes(ctx),
		)
	}

	if !v.InternetAccess.IsNull() && !v.InternetAccess.IsUnknown() {
		internetAccess = types.ObjectValueMust(
			InternetAccessValue{}.AttributeTypes(ctx),
			v.InternetAccess.Attributes(),
		)
	}

	var multicast basetypes.ObjectValue

	if v.Multicast.IsNull() {
		multicast = types.ObjectNull(
			MulticastValue{}.AttributeTypes(ctx),
		)
	}

	if v.Multicast.IsUnknown() {
		multicast = types.ObjectUnknown(
			MulticastValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Multicast.IsNull() && !v.Multicast.IsUnknown() {
		multicast = types.ObjectValueMust(
			MulticastValue{}.AttributeTypes(ctx),
			v.Multicast.Attributes(),
		)
	}

	tenants := types.MapValueMust(
		TenantsType{
			basetypes.ObjectType{
				AttrTypes: TenantsValue{}.AttributeTypes(ctx),
			},
		},
		v.Tenants.Elements(),
	)

	if v.Tenants.IsNull() {
		tenants = types.MapNull(
			TenantsType{
				basetypes.ObjectType{
					AttrTypes: TenantsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Tenants.IsUnknown() {
		tenants = types.MapUnknown(
			TenantsType{
				basetypes.ObjectType{
					AttrTypes: TenantsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	vpnAccess := types.MapValueMust(
		VpnAccessType{
			basetypes.ObjectType{
				AttrTypes: VpnAccessValue{}.AttributeTypes(ctx),
			},
		},
		v.VpnAccess.Elements(),
	)

	if v.VpnAccess.IsNull() {
		vpnAccess = types.MapNull(
			VpnAccessType{
				basetypes.ObjectType{
					AttrTypes: VpnAccessValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.VpnAccess.IsUnknown() {
		vpnAccess = types.MapUnknown(
			VpnAccessType{
				basetypes.ObjectType{
					AttrTypes: VpnAccessValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var routedForNetworksVal basetypes.ListValue
	switch {
	case v.RoutedForNetworks.IsUnknown():
		routedForNetworksVal = types.ListUnknown(types.StringType)
	case v.RoutedForNetworks.IsNull():
		routedForNetworksVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		routedForNetworksVal, d = types.ListValue(types.StringType, v.RoutedForNetworks.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"disallow_mist_services": basetypes.BoolType{},
			"gateway":                basetypes.StringType{},
			"gateway6":               basetypes.StringType{},
			"internal_access": basetypes.ObjectType{
				AttrTypes: InternalAccessValue{}.AttributeTypes(ctx),
			},
			"internet_access": basetypes.ObjectType{
				AttrTypes: InternetAccessValue{}.AttributeTypes(ctx),
			},
			"isolation": basetypes.BoolType{},
			"multicast": basetypes.ObjectType{
				AttrTypes: MulticastValue{}.AttributeTypes(ctx),
			},
			"name": basetypes.StringType{},
			"routed_for_networks": basetypes.ListType{
				ElemType: types.StringType,
			},
			"subnet":  basetypes.StringType{},
			"subnet6": basetypes.StringType{},
			"tenants": basetypes.MapType{
				ElemType: TenantsValue{}.Type(ctx),
			},
			"vlan_id": basetypes.StringType{},
			"vpn_access": basetypes.MapType{
				ElemType: VpnAccessValue{}.Type(ctx),
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"disallow_mist_services": basetypes.BoolType{},
		"gateway":                basetypes.StringType{},
		"gateway6":               basetypes.StringType{},
		"internal_access": basetypes.ObjectType{
			AttrTypes: InternalAccessValue{}.AttributeTypes(ctx),
		},
		"internet_access": basetypes.ObjectType{
			AttrTypes: InternetAccessValue{}.AttributeTypes(ctx),
		},
		"isolation": basetypes.BoolType{},
		"multicast": basetypes.ObjectType{
			AttrTypes: MulticastValue{}.AttributeTypes(ctx),
		},
		"name": basetypes.StringType{},
		"routed_for_networks": basetypes.ListType{
			ElemType: types.StringType,
		},
		"subnet":  basetypes.StringType{},
		"subnet6": basetypes.StringType{},
		"tenants": basetypes.MapType{
			ElemType: TenantsValue{}.Type(ctx),
		},
		"vlan_id": basetypes.StringType{},
		"vpn_access": basetypes.MapType{
			ElemType: VpnAccessValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"disallow_mist_services": v.DisallowMistServices,
			"gateway":                v.Gateway,
			"gateway6":               v.Gateway6,
			"internal_access":        internalAccess,
			"internet_access":        internetAccess,
			"isolation":              v.Isolation,
			"multicast":              multicast,
			"name":                   v.Name,
			"routed_for_networks":    routedForNetworksVal,
			"subnet":                 v.Subnet,
			"subnet6":                v.Subnet6,
			"tenants":                tenants,
			"vlan_id":                v.VlanId,
			"vpn_access":             vpnAccess,
		})

	return objVal, diags
}

func (v NetworksValue) Equal(o attr.Value) bool {
	other, ok := o.(NetworksValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.DisallowMistServices.Equal(other.DisallowMistServices) {
		return false
	}

	if !v.Gateway.Equal(other.Gateway) {
		return false
	}

	if !v.Gateway6.Equal(other.Gateway6) {
		return false
	}

	if !v.InternalAccess.Equal(other.InternalAccess) {
		return false
	}

	if !v.InternetAccess.Equal(other.InternetAccess) {
		return false
	}

	if !v.Isolation.Equal(other.Isolation) {
		return false
	}

	if !v.Multicast.Equal(other.Multicast) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.RoutedForNetworks.Equal(other.RoutedForNetworks) {
		return false
	}

	if !v.Subnet.Equal(other.Subnet) {
		return false
	}

	if !v.Subnet6.Equal(other.Subnet6) {
		return false
	}

	if !v.Tenants.Equal(other.Tenants) {
		return false
	}

	if !v.VlanId.Equal(other.VlanId) {
		return false
	}

	if !v.VpnAccess.Equal(other.VpnAccess) {
		return false
	}

	return true
}

func (v NetworksValue) Type(ctx context.Context) attr.Type {
	return NetworksType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v NetworksValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"disallow_mist_services": basetypes.BoolType{},
		"gateway":                basetypes.StringType{},
		"gateway6":               basetypes.StringType{},
		"internal_access": basetypes.ObjectType{
			AttrTypes: InternalAccessValue{}.AttributeTypes(ctx),
		},
		"internet_access": basetypes.ObjectType{
			AttrTypes: InternetAccessValue{}.AttributeTypes(ctx),
		},
		"isolation": basetypes.BoolType{},
		"multicast": basetypes.ObjectType{
			AttrTypes: MulticastValue{}.AttributeTypes(ctx),
		},
		"name": basetypes.StringType{},
		"routed_for_networks": basetypes.ListType{
			ElemType: types.StringType,
		},
		"subnet":  basetypes.StringType{},
		"subnet6": basetypes.StringType{},
		"tenants": basetypes.MapType{
			ElemType: TenantsValue{}.Type(ctx),
		},
		"vlan_id": basetypes.StringType{},
		"vpn_access": basetypes.MapType{
			ElemType: VpnAccessValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = InternalAccessType{}

type InternalAccessType struct {
	basetypes.ObjectType
}

func (t InternalAccessType) Equal(o attr.Type) bool {
	other, ok := o.(InternalAccessType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t InternalAccessType) String() string {
	return "InternalAccessType"
}

func (t InternalAccessType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return InternalAccessValue{
		Enabled: enabledVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewInternalAccessValueNull() InternalAccessValue {
	return InternalAccessValue{
		state: attr.ValueStateNull,
	}
}

func NewInternalAccessValueUnknown() InternalAccessValue {
	return InternalAccessValue{
		state: attr.ValueStateUnknown,
	}
}

func NewInternalAccessValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (InternalAccessValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing InternalAccessValue Attribute Value",
				"While creating a InternalAccessValue value, a missing attribute value was detected. "+
					"A InternalAccessValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("InternalAccessValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid InternalAccessValue Attribute Type",
				"While creating a InternalAccessValue value, an invalid attribute value was detected. "+
					"A InternalAccessValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("InternalAccessValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("InternalAccessValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra InternalAccessValue Attribute Value",
				"While creating a InternalAccessValue value, an extra attribute value was detected. "+
					"A InternalAccessValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra InternalAccessValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewInternalAccessValueUnknown(), diags
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewInternalAccessValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	if diags.HasError() {
		return NewInternalAccessValueUnknown(), diags
	}

	return InternalAccessValue{
		Enabled: enabledVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewInternalAccessValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) InternalAccessValue {
	object, diags := NewInternalAccessValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewInternalAccessValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t InternalAccessType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewInternalAccessValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewInternalAccessValueUnknown(), nil
	}

	if in.IsNull() {
		return NewInternalAccessValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewInternalAccessValueMust(InternalAccessValue{}.AttributeTypes(ctx), attributes), nil
}

func (t InternalAccessType) ValueType(ctx context.Context) attr.Value {
	return InternalAccessValue{}
}

var _ basetypes.ObjectValuable = InternalAccessValue{}

type InternalAccessValue struct {
	Enabled basetypes.BoolValue `tfsdk:"enabled"`
	state   attr.ValueState
}

func (v InternalAccessValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v InternalAccessValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v InternalAccessValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v InternalAccessValue) String() string {
	return "InternalAccessValue"
}

func (v InternalAccessValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"enabled": basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"enabled": v.Enabled,
		})

	return objVal, diags
}

func (v InternalAccessValue) Equal(o attr.Value) bool {
	other, ok := o.(InternalAccessValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	return true
}

func (v InternalAccessValue) Type(ctx context.Context) attr.Type {
	return InternalAccessType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v InternalAccessValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"enabled": basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = InternetAccessType{}

type InternetAccessType struct {
	basetypes.ObjectType
}

func (t InternetAccessType) Equal(o attr.Type) bool {
	other, ok := o.(InternetAccessType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t InternetAccessType) String() string {
	return "InternetAccessType"
}

func (t InternetAccessType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	createSimpleServicePolicyAttribute, ok := attributes["create_simple_service_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`create_simple_service_policy is missing from object`)

		return nil, diags
	}

	createSimpleServicePolicyVal, ok := createSimpleServicePolicyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`create_simple_service_policy expected to be basetypes.BoolValue, was: %T`, createSimpleServicePolicyAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	internetAccessDestinationNatAttribute, ok := attributes["destination_nat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`destination_nat is missing from object`)

		return nil, diags
	}

	internetAccessDestinationNatVal, ok := internetAccessDestinationNatAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`destination_nat expected to be basetypes.MapValue, was: %T`, internetAccessDestinationNatAttribute))
	}

	internetAccessStaticNatAttribute, ok := attributes["static_nat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`static_nat is missing from object`)

		return nil, diags
	}

	internetAccessStaticNatVal, ok := internetAccessStaticNatAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`static_nat expected to be basetypes.MapValue, was: %T`, internetAccessStaticNatAttribute))
	}

	restrictedAttribute, ok := attributes["restricted"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`restricted is missing from object`)

		return nil, diags
	}

	restrictedVal, ok := restrictedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`restricted expected to be basetypes.BoolValue, was: %T`, restrictedAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return InternetAccessValue{
		CreateSimpleServicePolicy:    createSimpleServicePolicyVal,
		Enabled:                      enabledVal,
		InternetAccessDestinationNat: internetAccessDestinationNatVal,
		InternetAccessStaticNat:      internetAccessStaticNatVal,
		Restricted:                   restrictedVal,
		state:                        attr.ValueStateKnown,
	}, diags
}

func NewInternetAccessValueNull() InternetAccessValue {
	return InternetAccessValue{
		state: attr.ValueStateNull,
	}
}

func NewInternetAccessValueUnknown() InternetAccessValue {
	return InternetAccessValue{
		state: attr.ValueStateUnknown,
	}
}

func NewInternetAccessValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (InternetAccessValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing InternetAccessValue Attribute Value",
				"While creating a InternetAccessValue value, a missing attribute value was detected. "+
					"A InternetAccessValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("InternetAccessValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid InternetAccessValue Attribute Type",
				"While creating a InternetAccessValue value, an invalid attribute value was detected. "+
					"A InternetAccessValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("InternetAccessValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("InternetAccessValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra InternetAccessValue Attribute Value",
				"While creating a InternetAccessValue value, an extra attribute value was detected. "+
					"A InternetAccessValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra InternetAccessValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewInternetAccessValueUnknown(), diags
	}

	createSimpleServicePolicyAttribute, ok := attributes["create_simple_service_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`create_simple_service_policy is missing from object`)

		return NewInternetAccessValueUnknown(), diags
	}

	createSimpleServicePolicyVal, ok := createSimpleServicePolicyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`create_simple_service_policy expected to be basetypes.BoolValue, was: %T`, createSimpleServicePolicyAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewInternetAccessValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	internetAccessDestinationNatAttribute, ok := attributes["destination_nat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`destination_nat is missing from object`)

		return NewInternetAccessValueUnknown(), diags
	}

	internetAccessDestinationNatVal, ok := internetAccessDestinationNatAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`destination_nat expected to be basetypes.MapValue, was: %T`, internetAccessDestinationNatAttribute))
	}

	internetAccessStaticNatAttribute, ok := attributes["static_nat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`static_nat is missing from object`)

		return NewInternetAccessValueUnknown(), diags
	}

	internetAccessStaticNatVal, ok := internetAccessStaticNatAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`static_nat expected to be basetypes.MapValue, was: %T`, internetAccessStaticNatAttribute))
	}

	restrictedAttribute, ok := attributes["restricted"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`restricted is missing from object`)

		return NewInternetAccessValueUnknown(), diags
	}

	restrictedVal, ok := restrictedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`restricted expected to be basetypes.BoolValue, was: %T`, restrictedAttribute))
	}

	if diags.HasError() {
		return NewInternetAccessValueUnknown(), diags
	}

	return InternetAccessValue{
		CreateSimpleServicePolicy:    createSimpleServicePolicyVal,
		Enabled:                      enabledVal,
		InternetAccessDestinationNat: internetAccessDestinationNatVal,
		InternetAccessStaticNat:      internetAccessStaticNatVal,
		Restricted:                   restrictedVal,
		state:                        attr.ValueStateKnown,
	}, diags
}

func NewInternetAccessValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) InternetAccessValue {
	object, diags := NewInternetAccessValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewInternetAccessValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t InternetAccessType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewInternetAccessValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewInternetAccessValueUnknown(), nil
	}

	if in.IsNull() {
		return NewInternetAccessValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewInternetAccessValueMust(InternetAccessValue{}.AttributeTypes(ctx), attributes), nil
}

func (t InternetAccessType) ValueType(ctx context.Context) attr.Value {
	return InternetAccessValue{}
}

var _ basetypes.ObjectValuable = InternetAccessValue{}

type InternetAccessValue struct {
	CreateSimpleServicePolicy    basetypes.BoolValue `tfsdk:"create_simple_service_policy"`
	Enabled                      basetypes.BoolValue `tfsdk:"enabled"`
	InternetAccessDestinationNat basetypes.MapValue  `tfsdk:"destination_nat"`
	InternetAccessStaticNat      basetypes.MapValue  `tfsdk:"static_nat"`
	Restricted                   basetypes.BoolValue `tfsdk:"restricted"`
	state                        attr.ValueState
}

func (v InternetAccessValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["create_simple_service_policy"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["destination_nat"] = basetypes.MapType{
		ElemType: InternetAccessDestinationNatValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["static_nat"] = basetypes.MapType{
		ElemType: InternetAccessStaticNatValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["restricted"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.CreateSimpleServicePolicy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["create_simple_service_policy"] = val

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.InternetAccessDestinationNat.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["destination_nat"] = val

		val, err = v.InternetAccessStaticNat.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["static_nat"] = val

		val, err = v.Restricted.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["restricted"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v InternetAccessValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v InternetAccessValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v InternetAccessValue) String() string {
	return "InternetAccessValue"
}

func (v InternetAccessValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	internetAccessDestinationNat := types.MapValueMust(
		InternetAccessDestinationNatType{
			basetypes.ObjectType{
				AttrTypes: InternetAccessDestinationNatValue{}.AttributeTypes(ctx),
			},
		},
		v.InternetAccessDestinationNat.Elements(),
	)

	if v.InternetAccessDestinationNat.IsNull() {
		internetAccessDestinationNat = types.MapNull(
			InternetAccessDestinationNatType{
				basetypes.ObjectType{
					AttrTypes: InternetAccessDestinationNatValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.InternetAccessDestinationNat.IsUnknown() {
		internetAccessDestinationNat = types.MapUnknown(
			InternetAccessDestinationNatType{
				basetypes.ObjectType{
					AttrTypes: InternetAccessDestinationNatValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	internetAccessStaticNat := types.MapValueMust(
		InternetAccessStaticNatType{
			basetypes.ObjectType{
				AttrTypes: InternetAccessStaticNatValue{}.AttributeTypes(ctx),
			},
		},
		v.InternetAccessStaticNat.Elements(),
	)

	if v.InternetAccessStaticNat.IsNull() {
		internetAccessStaticNat = types.MapNull(
			InternetAccessStaticNatType{
				basetypes.ObjectType{
					AttrTypes: InternetAccessStaticNatValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.InternetAccessStaticNat.IsUnknown() {
		internetAccessStaticNat = types.MapUnknown(
			InternetAccessStaticNatType{
				basetypes.ObjectType{
					AttrTypes: InternetAccessStaticNatValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"create_simple_service_policy": basetypes.BoolType{},
		"enabled":                      basetypes.BoolType{},
		"destination_nat": basetypes.MapType{
			ElemType: InternetAccessDestinationNatValue{}.Type(ctx),
		},
		"static_nat": basetypes.MapType{
			ElemType: InternetAccessStaticNatValue{}.Type(ctx),
		},
		"restricted": basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"create_simple_service_policy": v.CreateSimpleServicePolicy,
			"enabled":                      v.Enabled,
			"destination_nat":              internetAccessDestinationNat,
			"static_nat":                   internetAccessStaticNat,
			"restricted":                   v.Restricted,
		})

	return objVal, diags
}

func (v InternetAccessValue) Equal(o attr.Value) bool {
	other, ok := o.(InternetAccessValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.CreateSimpleServicePolicy.Equal(other.CreateSimpleServicePolicy) {
		return false
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.InternetAccessDestinationNat.Equal(other.InternetAccessDestinationNat) {
		return false
	}

	if !v.InternetAccessStaticNat.Equal(other.InternetAccessStaticNat) {
		return false
	}

	if !v.Restricted.Equal(other.Restricted) {
		return false
	}

	return true
}

func (v InternetAccessValue) Type(ctx context.Context) attr.Type {
	return InternetAccessType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v InternetAccessValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"create_simple_service_policy": basetypes.BoolType{},
		"enabled":                      basetypes.BoolType{},
		"destination_nat": basetypes.MapType{
			ElemType: InternetAccessDestinationNatValue{}.Type(ctx),
		},
		"static_nat": basetypes.MapType{
			ElemType: InternetAccessStaticNatValue{}.Type(ctx),
		},
		"restricted": basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = InternetAccessDestinationNatType{}

type InternetAccessDestinationNatType struct {
	basetypes.ObjectType
}

func (t InternetAccessDestinationNatType) Equal(o attr.Type) bool {
	other, ok := o.(InternetAccessDestinationNatType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t InternetAccessDestinationNatType) String() string {
	return "InternetAccessDestinationNatType"
}

func (t InternetAccessDestinationNatType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	internalIpAttribute, ok := attributes["internal_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`internal_ip is missing from object`)

		return nil, diags
	}

	internalIpVal, ok := internalIpAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`internal_ip expected to be basetypes.StringValue, was: %T`, internalIpAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	portAttribute, ok := attributes["port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port is missing from object`)

		return nil, diags
	}

	portVal, ok := portAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port expected to be basetypes.StringValue, was: %T`, portAttribute))
	}

	wanNameAttribute, ok := attributes["wan_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wan_name is missing from object`)

		return nil, diags
	}

	wanNameVal, ok := wanNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wan_name expected to be basetypes.StringValue, was: %T`, wanNameAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return InternetAccessDestinationNatValue{
		InternalIp: internalIpVal,
		Name:       nameVal,
		Port:       portVal,
		WanName:    wanNameVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewInternetAccessDestinationNatValueNull() InternetAccessDestinationNatValue {
	return InternetAccessDestinationNatValue{
		state: attr.ValueStateNull,
	}
}

func NewInternetAccessDestinationNatValueUnknown() InternetAccessDestinationNatValue {
	return InternetAccessDestinationNatValue{
		state: attr.ValueStateUnknown,
	}
}

func NewInternetAccessDestinationNatValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (InternetAccessDestinationNatValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing InternetAccessDestinationNatValue Attribute Value",
				"While creating a InternetAccessDestinationNatValue value, a missing attribute value was detected. "+
					"A InternetAccessDestinationNatValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("InternetAccessDestinationNatValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid InternetAccessDestinationNatValue Attribute Type",
				"While creating a InternetAccessDestinationNatValue value, an invalid attribute value was detected. "+
					"A InternetAccessDestinationNatValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("InternetAccessDestinationNatValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("InternetAccessDestinationNatValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra InternetAccessDestinationNatValue Attribute Value",
				"While creating a InternetAccessDestinationNatValue value, an extra attribute value was detected. "+
					"A InternetAccessDestinationNatValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra InternetAccessDestinationNatValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewInternetAccessDestinationNatValueUnknown(), diags
	}

	internalIpAttribute, ok := attributes["internal_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`internal_ip is missing from object`)

		return NewInternetAccessDestinationNatValueUnknown(), diags
	}

	internalIpVal, ok := internalIpAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`internal_ip expected to be basetypes.StringValue, was: %T`, internalIpAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewInternetAccessDestinationNatValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	portAttribute, ok := attributes["port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port is missing from object`)

		return NewInternetAccessDestinationNatValueUnknown(), diags
	}

	portVal, ok := portAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port expected to be basetypes.StringValue, was: %T`, portAttribute))
	}

	wanNameAttribute, ok := attributes["wan_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wan_name is missing from object`)

		return NewInternetAccessDestinationNatValueUnknown(), diags
	}

	wanNameVal, ok := wanNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wan_name expected to be basetypes.StringValue, was: %T`, wanNameAttribute))
	}

	if diags.HasError() {
		return NewInternetAccessDestinationNatValueUnknown(), diags
	}

	return InternetAccessDestinationNatValue{
		InternalIp: internalIpVal,
		Name:       nameVal,
		Port:       portVal,
		WanName:    wanNameVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewInternetAccessDestinationNatValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) InternetAccessDestinationNatValue {
	object, diags := NewInternetAccessDestinationNatValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewInternetAccessDestinationNatValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t InternetAccessDestinationNatType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewInternetAccessDestinationNatValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewInternetAccessDestinationNatValueUnknown(), nil
	}

	if in.IsNull() {
		return NewInternetAccessDestinationNatValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewInternetAccessDestinationNatValueMust(InternetAccessDestinationNatValue{}.AttributeTypes(ctx), attributes), nil
}

func (t InternetAccessDestinationNatType) ValueType(ctx context.Context) attr.Value {
	return InternetAccessDestinationNatValue{}
}

var _ basetypes.ObjectValuable = InternetAccessDestinationNatValue{}

type InternetAccessDestinationNatValue struct {
	InternalIp basetypes.StringValue `tfsdk:"internal_ip"`
	Name       basetypes.StringValue `tfsdk:"name"`
	Port       basetypes.StringValue `tfsdk:"port"`
	WanName    basetypes.StringValue `tfsdk:"wan_name"`
	state      attr.ValueState
}

func (v InternetAccessDestinationNatValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["internal_ip"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["port"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["wan_name"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.InternalIp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["internal_ip"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Port.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port"] = val

		val, err = v.WanName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["wan_name"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v InternetAccessDestinationNatValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v InternetAccessDestinationNatValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v InternetAccessDestinationNatValue) String() string {
	return "InternetAccessDestinationNatValue"
}

func (v InternetAccessDestinationNatValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"internal_ip": basetypes.StringType{},
		"name":        basetypes.StringType{},
		"port":        basetypes.StringType{},
		"wan_name":    basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"internal_ip": v.InternalIp,
			"name":        v.Name,
			"port":        v.Port,
			"wan_name":    v.WanName,
		})

	return objVal, diags
}

func (v InternetAccessDestinationNatValue) Equal(o attr.Value) bool {
	other, ok := o.(InternetAccessDestinationNatValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.InternalIp.Equal(other.InternalIp) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Port.Equal(other.Port) {
		return false
	}

	if !v.WanName.Equal(other.WanName) {
		return false
	}

	return true
}

func (v InternetAccessDestinationNatValue) Type(ctx context.Context) attr.Type {
	return InternetAccessDestinationNatType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v InternetAccessDestinationNatValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"internal_ip": basetypes.StringType{},
		"name":        basetypes.StringType{},
		"port":        basetypes.StringType{},
		"wan_name":    basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = InternetAccessStaticNatType{}

type InternetAccessStaticNatType struct {
	basetypes.ObjectType
}

func (t InternetAccessStaticNatType) Equal(o attr.Type) bool {
	other, ok := o.(InternetAccessStaticNatType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t InternetAccessStaticNatType) String() string {
	return "InternetAccessStaticNatType"
}

func (t InternetAccessStaticNatType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	internalIpAttribute, ok := attributes["internal_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`internal_ip is missing from object`)

		return nil, diags
	}

	internalIpVal, ok := internalIpAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`internal_ip expected to be basetypes.StringValue, was: %T`, internalIpAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	wanNameAttribute, ok := attributes["wan_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wan_name is missing from object`)

		return nil, diags
	}

	wanNameVal, ok := wanNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wan_name expected to be basetypes.StringValue, was: %T`, wanNameAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return InternetAccessStaticNatValue{
		InternalIp: internalIpVal,
		Name:       nameVal,
		WanName:    wanNameVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewInternetAccessStaticNatValueNull() InternetAccessStaticNatValue {
	return InternetAccessStaticNatValue{
		state: attr.ValueStateNull,
	}
}

func NewInternetAccessStaticNatValueUnknown() InternetAccessStaticNatValue {
	return InternetAccessStaticNatValue{
		state: attr.ValueStateUnknown,
	}
}

func NewInternetAccessStaticNatValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (InternetAccessStaticNatValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing InternetAccessStaticNatValue Attribute Value",
				"While creating a InternetAccessStaticNatValue value, a missing attribute value was detected. "+
					"A InternetAccessStaticNatValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("InternetAccessStaticNatValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid InternetAccessStaticNatValue Attribute Type",
				"While creating a InternetAccessStaticNatValue value, an invalid attribute value was detected. "+
					"A InternetAccessStaticNatValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("InternetAccessStaticNatValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("InternetAccessStaticNatValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra InternetAccessStaticNatValue Attribute Value",
				"While creating a InternetAccessStaticNatValue value, an extra attribute value was detected. "+
					"A InternetAccessStaticNatValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra InternetAccessStaticNatValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewInternetAccessStaticNatValueUnknown(), diags
	}

	internalIpAttribute, ok := attributes["internal_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`internal_ip is missing from object`)

		return NewInternetAccessStaticNatValueUnknown(), diags
	}

	internalIpVal, ok := internalIpAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`internal_ip expected to be basetypes.StringValue, was: %T`, internalIpAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewInternetAccessStaticNatValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	wanNameAttribute, ok := attributes["wan_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wan_name is missing from object`)

		return NewInternetAccessStaticNatValueUnknown(), diags
	}

	wanNameVal, ok := wanNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wan_name expected to be basetypes.StringValue, was: %T`, wanNameAttribute))
	}

	if diags.HasError() {
		return NewInternetAccessStaticNatValueUnknown(), diags
	}

	return InternetAccessStaticNatValue{
		InternalIp: internalIpVal,
		Name:       nameVal,
		WanName:    wanNameVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewInternetAccessStaticNatValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) InternetAccessStaticNatValue {
	object, diags := NewInternetAccessStaticNatValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewInternetAccessStaticNatValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t InternetAccessStaticNatType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewInternetAccessStaticNatValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewInternetAccessStaticNatValueUnknown(), nil
	}

	if in.IsNull() {
		return NewInternetAccessStaticNatValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewInternetAccessStaticNatValueMust(InternetAccessStaticNatValue{}.AttributeTypes(ctx), attributes), nil
}

func (t InternetAccessStaticNatType) ValueType(ctx context.Context) attr.Value {
	return InternetAccessStaticNatValue{}
}

var _ basetypes.ObjectValuable = InternetAccessStaticNatValue{}

type InternetAccessStaticNatValue struct {
	InternalIp basetypes.StringValue `tfsdk:"internal_ip"`
	Name       basetypes.StringValue `tfsdk:"name"`
	WanName    basetypes.StringValue `tfsdk:"wan_name"`
	state      attr.ValueState
}

func (v InternetAccessStaticNatValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["internal_ip"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["wan_name"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.InternalIp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["internal_ip"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.WanName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["wan_name"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v InternetAccessStaticNatValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v InternetAccessStaticNatValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v InternetAccessStaticNatValue) String() string {
	return "InternetAccessStaticNatValue"
}

func (v InternetAccessStaticNatValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"internal_ip": basetypes.StringType{},
		"name":        basetypes.StringType{},
		"wan_name":    basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"internal_ip": v.InternalIp,
			"name":        v.Name,
			"wan_name":    v.WanName,
		})

	return objVal, diags
}

func (v InternetAccessStaticNatValue) Equal(o attr.Value) bool {
	other, ok := o.(InternetAccessStaticNatValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.InternalIp.Equal(other.InternalIp) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.WanName.Equal(other.WanName) {
		return false
	}

	return true
}

func (v InternetAccessStaticNatValue) Type(ctx context.Context) attr.Type {
	return InternetAccessStaticNatType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v InternetAccessStaticNatValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"internal_ip": basetypes.StringType{},
		"name":        basetypes.StringType{},
		"wan_name":    basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = MulticastType{}

type MulticastType struct {
	basetypes.ObjectType
}

func (t MulticastType) Equal(o attr.Type) bool {
	other, ok := o.(MulticastType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t MulticastType) String() string {
	return "MulticastType"
}

func (t MulticastType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	disableIgmpAttribute, ok := attributes["disable_igmp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disable_igmp is missing from object`)

		return nil, diags
	}

	disableIgmpVal, ok := disableIgmpAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disable_igmp expected to be basetypes.BoolValue, was: %T`, disableIgmpAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	groupsAttribute, ok := attributes["groups"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`groups is missing from object`)

		return nil, diags
	}

	groupsVal, ok := groupsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`groups expected to be basetypes.MapValue, was: %T`, groupsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return MulticastValue{
		DisableIgmp: disableIgmpVal,
		Enabled:     enabledVal,
		Groups:      groupsVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewMulticastValueNull() MulticastValue {
	return MulticastValue{
		state: attr.ValueStateNull,
	}
}

func NewMulticastValueUnknown() MulticastValue {
	return MulticastValue{
		state: attr.ValueStateUnknown,
	}
}

func NewMulticastValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (MulticastValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing MulticastValue Attribute Value",
				"While creating a MulticastValue value, a missing attribute value was detected. "+
					"A MulticastValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MulticastValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid MulticastValue Attribute Type",
				"While creating a MulticastValue value, an invalid attribute value was detected. "+
					"A MulticastValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MulticastValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("MulticastValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra MulticastValue Attribute Value",
				"While creating a MulticastValue value, an extra attribute value was detected. "+
					"A MulticastValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra MulticastValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewMulticastValueUnknown(), diags
	}

	disableIgmpAttribute, ok := attributes["disable_igmp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disable_igmp is missing from object`)

		return NewMulticastValueUnknown(), diags
	}

	disableIgmpVal, ok := disableIgmpAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disable_igmp expected to be basetypes.BoolValue, was: %T`, disableIgmpAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewMulticastValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	groupsAttribute, ok := attributes["groups"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`groups is missing from object`)

		return NewMulticastValueUnknown(), diags
	}

	groupsVal, ok := groupsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`groups expected to be basetypes.MapValue, was: %T`, groupsAttribute))
	}

	if diags.HasError() {
		return NewMulticastValueUnknown(), diags
	}

	return MulticastValue{
		DisableIgmp: disableIgmpVal,
		Enabled:     enabledVal,
		Groups:      groupsVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewMulticastValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) MulticastValue {
	object, diags := NewMulticastValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewMulticastValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t MulticastType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewMulticastValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewMulticastValueUnknown(), nil
	}

	if in.IsNull() {
		return NewMulticastValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewMulticastValueMust(MulticastValue{}.AttributeTypes(ctx), attributes), nil
}

func (t MulticastType) ValueType(ctx context.Context) attr.Value {
	return MulticastValue{}
}

var _ basetypes.ObjectValuable = MulticastValue{}

type MulticastValue struct {
	DisableIgmp basetypes.BoolValue `tfsdk:"disable_igmp"`
	Enabled     basetypes.BoolValue `tfsdk:"enabled"`
	Groups      basetypes.MapValue  `tfsdk:"groups"`
	state       attr.ValueState
}

func (v MulticastValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["disable_igmp"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["groups"] = basetypes.MapType{
		ElemType: GroupsValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.DisableIgmp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["disable_igmp"] = val

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.Groups.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["groups"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v MulticastValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v MulticastValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v MulticastValue) String() string {
	return "MulticastValue"
}

func (v MulticastValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	groups := types.MapValueMust(
		GroupsType{
			basetypes.ObjectType{
				AttrTypes: GroupsValue{}.AttributeTypes(ctx),
			},
		},
		v.Groups.Elements(),
	)

	if v.Groups.IsNull() {
		groups = types.MapNull(
			GroupsType{
				basetypes.ObjectType{
					AttrTypes: GroupsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Groups.IsUnknown() {
		groups = types.MapUnknown(
			GroupsType{
				basetypes.ObjectType{
					AttrTypes: GroupsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"disable_igmp": basetypes.BoolType{},
		"enabled":      basetypes.BoolType{},
		"groups": basetypes.MapType{
			ElemType: GroupsValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"disable_igmp": v.DisableIgmp,
			"enabled":      v.Enabled,
			"groups":       groups,
		})

	return objVal, diags
}

func (v MulticastValue) Equal(o attr.Value) bool {
	other, ok := o.(MulticastValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.DisableIgmp.Equal(other.DisableIgmp) {
		return false
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.Groups.Equal(other.Groups) {
		return false
	}

	return true
}

func (v MulticastValue) Type(ctx context.Context) attr.Type {
	return MulticastType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v MulticastValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"disable_igmp": basetypes.BoolType{},
		"enabled":      basetypes.BoolType{},
		"groups": basetypes.MapType{
			ElemType: GroupsValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = GroupsType{}

type GroupsType struct {
	basetypes.ObjectType
}

func (t GroupsType) Equal(o attr.Type) bool {
	other, ok := o.(GroupsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t GroupsType) String() string {
	return "GroupsType"
}

func (t GroupsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	rpIpAttribute, ok := attributes["rp_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rp_ip is missing from object`)

		return nil, diags
	}

	rpIpVal, ok := rpIpAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rp_ip expected to be basetypes.StringValue, was: %T`, rpIpAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return GroupsValue{
		RpIp:  rpIpVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewGroupsValueNull() GroupsValue {
	return GroupsValue{
		state: attr.ValueStateNull,
	}
}

func NewGroupsValueUnknown() GroupsValue {
	return GroupsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewGroupsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (GroupsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing GroupsValue Attribute Value",
				"While creating a GroupsValue value, a missing attribute value was detected. "+
					"A GroupsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("GroupsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid GroupsValue Attribute Type",
				"While creating a GroupsValue value, an invalid attribute value was detected. "+
					"A GroupsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("GroupsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("GroupsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra GroupsValue Attribute Value",
				"While creating a GroupsValue value, an extra attribute value was detected. "+
					"A GroupsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra GroupsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewGroupsValueUnknown(), diags
	}

	rpIpAttribute, ok := attributes["rp_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rp_ip is missing from object`)

		return NewGroupsValueUnknown(), diags
	}

	rpIpVal, ok := rpIpAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rp_ip expected to be basetypes.StringValue, was: %T`, rpIpAttribute))
	}

	if diags.HasError() {
		return NewGroupsValueUnknown(), diags
	}

	return GroupsValue{
		RpIp:  rpIpVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewGroupsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) GroupsValue {
	object, diags := NewGroupsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewGroupsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t GroupsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewGroupsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewGroupsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewGroupsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewGroupsValueMust(GroupsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t GroupsType) ValueType(ctx context.Context) attr.Value {
	return GroupsValue{}
}

var _ basetypes.ObjectValuable = GroupsValue{}

type GroupsValue struct {
	RpIp  basetypes.StringValue `tfsdk:"rp_ip"`
	state attr.ValueState
}

func (v GroupsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["rp_ip"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.RpIp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["rp_ip"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v GroupsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v GroupsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v GroupsValue) String() string {
	return "GroupsValue"
}

func (v GroupsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"rp_ip": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"rp_ip": v.RpIp,
		})

	return objVal, diags
}

func (v GroupsValue) Equal(o attr.Value) bool {
	other, ok := o.(GroupsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.RpIp.Equal(other.RpIp) {
		return false
	}

	return true
}

func (v GroupsValue) Type(ctx context.Context) attr.Type {
	return GroupsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v GroupsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"rp_ip": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = TenantsType{}

type TenantsType struct {
	basetypes.ObjectType
}

func (t TenantsType) Equal(o attr.Type) bool {
	other, ok := o.(TenantsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t TenantsType) String() string {
	return "TenantsType"
}

func (t TenantsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	addressesAttribute, ok := attributes["addresses"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`addresses is missing from object`)

		return nil, diags
	}

	addressesVal, ok := addressesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`addresses expected to be basetypes.ListValue, was: %T`, addressesAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return TenantsValue{
		Addresses: addressesVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewTenantsValueNull() TenantsValue {
	return TenantsValue{
		state: attr.ValueStateNull,
	}
}

func NewTenantsValueUnknown() TenantsValue {
	return TenantsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewTenantsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (TenantsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing TenantsValue Attribute Value",
				"While creating a TenantsValue value, a missing attribute value was detected. "+
					"A TenantsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TenantsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid TenantsValue Attribute Type",
				"While creating a TenantsValue value, an invalid attribute value was detected. "+
					"A TenantsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TenantsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("TenantsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra TenantsValue Attribute Value",
				"While creating a TenantsValue value, an extra attribute value was detected. "+
					"A TenantsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra TenantsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewTenantsValueUnknown(), diags
	}

	addressesAttribute, ok := attributes["addresses"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`addresses is missing from object`)

		return NewTenantsValueUnknown(), diags
	}

	addressesVal, ok := addressesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`addresses expected to be basetypes.ListValue, was: %T`, addressesAttribute))
	}

	if diags.HasError() {
		return NewTenantsValueUnknown(), diags
	}

	return TenantsValue{
		Addresses: addressesVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewTenantsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) TenantsValue {
	object, diags := NewTenantsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewTenantsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t TenantsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewTenantsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewTenantsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewTenantsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewTenantsValueMust(TenantsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t TenantsType) ValueType(ctx context.Context) attr.Value {
	return TenantsValue{}
}

var _ basetypes.ObjectValuable = TenantsValue{}

type TenantsValue struct {
	Addresses basetypes.ListValue `tfsdk:"addresses"`
	state     attr.ValueState
}

func (v TenantsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["addresses"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Addresses.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["addresses"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v TenantsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v TenantsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v TenantsValue) String() string {
	return "TenantsValue"
}

func (v TenantsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var addressesVal basetypes.ListValue
	switch {
	case v.Addresses.IsUnknown():
		addressesVal = types.ListUnknown(types.StringType)
	case v.Addresses.IsNull():
		addressesVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		addressesVal, d = types.ListValue(types.StringType, v.Addresses.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"addresses": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"addresses": basetypes.ListType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"addresses": addressesVal,
		})

	return objVal, diags
}

func (v TenantsValue) Equal(o attr.Value) bool {
	other, ok := o.(TenantsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Addresses.Equal(other.Addresses) {
		return false
	}

	return true
}

func (v TenantsValue) Type(ctx context.Context) attr.Type {
	return TenantsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v TenantsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"addresses": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = VpnAccessType{}

type VpnAccessType struct {
	basetypes.ObjectType
}

func (t VpnAccessType) Equal(o attr.Type) bool {
	other, ok := o.(VpnAccessType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t VpnAccessType) String() string {
	return "VpnAccessType"
}

func (t VpnAccessType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	advertisedSubnetAttribute, ok := attributes["advertised_subnet"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`advertised_subnet is missing from object`)

		return nil, diags
	}

	advertisedSubnetVal, ok := advertisedSubnetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`advertised_subnet expected to be basetypes.StringValue, was: %T`, advertisedSubnetAttribute))
	}

	allowPingAttribute, ok := attributes["allow_ping"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allow_ping is missing from object`)

		return nil, diags
	}

	allowPingVal, ok := allowPingAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allow_ping expected to be basetypes.BoolValue, was: %T`, allowPingAttribute))
	}

	natPoolAttribute, ok := attributes["nat_pool"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`nat_pool is missing from object`)

		return nil, diags
	}

	natPoolVal, ok := natPoolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`nat_pool expected to be basetypes.StringValue, was: %T`, natPoolAttribute))
	}

	noReadvertiseToLanBgpAttribute, ok := attributes["no_readvertise_to_lan_bgp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`no_readvertise_to_lan_bgp is missing from object`)

		return nil, diags
	}

	noReadvertiseToLanBgpVal, ok := noReadvertiseToLanBgpAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`no_readvertise_to_lan_bgp expected to be basetypes.BoolValue, was: %T`, noReadvertiseToLanBgpAttribute))
	}

	noReadvertiseToLanOspfAttribute, ok := attributes["no_readvertise_to_lan_ospf"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`no_readvertise_to_lan_ospf is missing from object`)

		return nil, diags
	}

	noReadvertiseToLanOspfVal, ok := noReadvertiseToLanOspfAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`no_readvertise_to_lan_ospf expected to be basetypes.BoolValue, was: %T`, noReadvertiseToLanOspfAttribute))
	}

	noReadvertiseToOverlayAttribute, ok := attributes["no_readvertise_to_overlay"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`no_readvertise_to_overlay is missing from object`)

		return nil, diags
	}

	noReadvertiseToOverlayVal, ok := noReadvertiseToOverlayAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`no_readvertise_to_overlay expected to be basetypes.BoolValue, was: %T`, noReadvertiseToOverlayAttribute))
	}

	otherVrfsAttribute, ok := attributes["other_vrfs"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`other_vrfs is missing from object`)

		return nil, diags
	}

	otherVrfsVal, ok := otherVrfsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`other_vrfs expected to be basetypes.ListValue, was: %T`, otherVrfsAttribute))
	}

	routedAttribute, ok := attributes["routed"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`routed is missing from object`)

		return nil, diags
	}

	routedVal, ok := routedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`routed expected to be basetypes.BoolValue, was: %T`, routedAttribute))
	}

	sourceNatAttribute, ok := attributes["source_nat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`source_nat is missing from object`)

		return nil, diags
	}

	sourceNatVal, ok := sourceNatAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`source_nat expected to be basetypes.ObjectValue, was: %T`, sourceNatAttribute))
	}

	summarizedSubnetAttribute, ok := attributes["summarized_subnet"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`summarized_subnet is missing from object`)

		return nil, diags
	}

	summarizedSubnetVal, ok := summarizedSubnetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`summarized_subnet expected to be basetypes.StringValue, was: %T`, summarizedSubnetAttribute))
	}

	summarizedSubnetToLanBgpAttribute, ok := attributes["summarized_subnet_to_lan_bgp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`summarized_subnet_to_lan_bgp is missing from object`)

		return nil, diags
	}

	summarizedSubnetToLanBgpVal, ok := summarizedSubnetToLanBgpAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`summarized_subnet_to_lan_bgp expected to be basetypes.StringValue, was: %T`, summarizedSubnetToLanBgpAttribute))
	}

	summarizedSubnetToLanOspfAttribute, ok := attributes["summarized_subnet_to_lan_ospf"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`summarized_subnet_to_lan_ospf is missing from object`)

		return nil, diags
	}

	summarizedSubnetToLanOspfVal, ok := summarizedSubnetToLanOspfAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`summarized_subnet_to_lan_ospf expected to be basetypes.StringValue, was: %T`, summarizedSubnetToLanOspfAttribute))
	}

	vpnAccessDestinationNatAttribute, ok := attributes["destination_nat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`destination_nat is missing from object`)

		return nil, diags
	}

	vpnAccessDestinationNatVal, ok := vpnAccessDestinationNatAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`destination_nat expected to be basetypes.MapValue, was: %T`, vpnAccessDestinationNatAttribute))
	}

	vpnAccessStaticNatAttribute, ok := attributes["static_nat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`static_nat is missing from object`)

		return nil, diags
	}

	vpnAccessStaticNatVal, ok := vpnAccessStaticNatAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`static_nat expected to be basetypes.MapValue, was: %T`, vpnAccessStaticNatAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return VpnAccessValue{
		AdvertisedSubnet:          advertisedSubnetVal,
		AllowPing:                 allowPingVal,
		NatPool:                   natPoolVal,
		NoReadvertiseToLanBgp:     noReadvertiseToLanBgpVal,
		NoReadvertiseToLanOspf:    noReadvertiseToLanOspfVal,
		NoReadvertiseToOverlay:    noReadvertiseToOverlayVal,
		OtherVrfs:                 otherVrfsVal,
		Routed:                    routedVal,
		SourceNat:                 sourceNatVal,
		SummarizedSubnet:          summarizedSubnetVal,
		SummarizedSubnetToLanBgp:  summarizedSubnetToLanBgpVal,
		SummarizedSubnetToLanOspf: summarizedSubnetToLanOspfVal,
		VpnAccessDestinationNat:   vpnAccessDestinationNatVal,
		VpnAccessStaticNat:        vpnAccessStaticNatVal,
		state:                     attr.ValueStateKnown,
	}, diags
}

func NewVpnAccessValueNull() VpnAccessValue {
	return VpnAccessValue{
		state: attr.ValueStateNull,
	}
}

func NewVpnAccessValueUnknown() VpnAccessValue {
	return VpnAccessValue{
		state: attr.ValueStateUnknown,
	}
}

func NewVpnAccessValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (VpnAccessValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing VpnAccessValue Attribute Value",
				"While creating a VpnAccessValue value, a missing attribute value was detected. "+
					"A VpnAccessValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VpnAccessValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid VpnAccessValue Attribute Type",
				"While creating a VpnAccessValue value, an invalid attribute value was detected. "+
					"A VpnAccessValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VpnAccessValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("VpnAccessValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra VpnAccessValue Attribute Value",
				"While creating a VpnAccessValue value, an extra attribute value was detected. "+
					"A VpnAccessValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra VpnAccessValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewVpnAccessValueUnknown(), diags
	}

	advertisedSubnetAttribute, ok := attributes["advertised_subnet"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`advertised_subnet is missing from object`)

		return NewVpnAccessValueUnknown(), diags
	}

	advertisedSubnetVal, ok := advertisedSubnetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`advertised_subnet expected to be basetypes.StringValue, was: %T`, advertisedSubnetAttribute))
	}

	allowPingAttribute, ok := attributes["allow_ping"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allow_ping is missing from object`)

		return NewVpnAccessValueUnknown(), diags
	}

	allowPingVal, ok := allowPingAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allow_ping expected to be basetypes.BoolValue, was: %T`, allowPingAttribute))
	}

	natPoolAttribute, ok := attributes["nat_pool"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`nat_pool is missing from object`)

		return NewVpnAccessValueUnknown(), diags
	}

	natPoolVal, ok := natPoolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`nat_pool expected to be basetypes.StringValue, was: %T`, natPoolAttribute))
	}

	noReadvertiseToLanBgpAttribute, ok := attributes["no_readvertise_to_lan_bgp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`no_readvertise_to_lan_bgp is missing from object`)

		return NewVpnAccessValueUnknown(), diags
	}

	noReadvertiseToLanBgpVal, ok := noReadvertiseToLanBgpAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`no_readvertise_to_lan_bgp expected to be basetypes.BoolValue, was: %T`, noReadvertiseToLanBgpAttribute))
	}

	noReadvertiseToLanOspfAttribute, ok := attributes["no_readvertise_to_lan_ospf"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`no_readvertise_to_lan_ospf is missing from object`)

		return NewVpnAccessValueUnknown(), diags
	}

	noReadvertiseToLanOspfVal, ok := noReadvertiseToLanOspfAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`no_readvertise_to_lan_ospf expected to be basetypes.BoolValue, was: %T`, noReadvertiseToLanOspfAttribute))
	}

	noReadvertiseToOverlayAttribute, ok := attributes["no_readvertise_to_overlay"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`no_readvertise_to_overlay is missing from object`)

		return NewVpnAccessValueUnknown(), diags
	}

	noReadvertiseToOverlayVal, ok := noReadvertiseToOverlayAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`no_readvertise_to_overlay expected to be basetypes.BoolValue, was: %T`, noReadvertiseToOverlayAttribute))
	}

	otherVrfsAttribute, ok := attributes["other_vrfs"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`other_vrfs is missing from object`)

		return NewVpnAccessValueUnknown(), diags
	}

	otherVrfsVal, ok := otherVrfsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`other_vrfs expected to be basetypes.ListValue, was: %T`, otherVrfsAttribute))
	}

	routedAttribute, ok := attributes["routed"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`routed is missing from object`)

		return NewVpnAccessValueUnknown(), diags
	}

	routedVal, ok := routedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`routed expected to be basetypes.BoolValue, was: %T`, routedAttribute))
	}

	sourceNatAttribute, ok := attributes["source_nat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`source_nat is missing from object`)

		return NewVpnAccessValueUnknown(), diags
	}

	sourceNatVal, ok := sourceNatAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`source_nat expected to be basetypes.ObjectValue, was: %T`, sourceNatAttribute))
	}

	summarizedSubnetAttribute, ok := attributes["summarized_subnet"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`summarized_subnet is missing from object`)

		return NewVpnAccessValueUnknown(), diags
	}

	summarizedSubnetVal, ok := summarizedSubnetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`summarized_subnet expected to be basetypes.StringValue, was: %T`, summarizedSubnetAttribute))
	}

	summarizedSubnetToLanBgpAttribute, ok := attributes["summarized_subnet_to_lan_bgp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`summarized_subnet_to_lan_bgp is missing from object`)

		return NewVpnAccessValueUnknown(), diags
	}

	summarizedSubnetToLanBgpVal, ok := summarizedSubnetToLanBgpAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`summarized_subnet_to_lan_bgp expected to be basetypes.StringValue, was: %T`, summarizedSubnetToLanBgpAttribute))
	}

	summarizedSubnetToLanOspfAttribute, ok := attributes["summarized_subnet_to_lan_ospf"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`summarized_subnet_to_lan_ospf is missing from object`)

		return NewVpnAccessValueUnknown(), diags
	}

	summarizedSubnetToLanOspfVal, ok := summarizedSubnetToLanOspfAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`summarized_subnet_to_lan_ospf expected to be basetypes.StringValue, was: %T`, summarizedSubnetToLanOspfAttribute))
	}

	vpnAccessDestinationNatAttribute, ok := attributes["destination_nat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`destination_nat is missing from object`)

		return NewVpnAccessValueUnknown(), diags
	}

	vpnAccessDestinationNatVal, ok := vpnAccessDestinationNatAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`destination_nat expected to be basetypes.MapValue, was: %T`, vpnAccessDestinationNatAttribute))
	}

	vpnAccessStaticNatAttribute, ok := attributes["static_nat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`static_nat is missing from object`)

		return NewVpnAccessValueUnknown(), diags
	}

	vpnAccessStaticNatVal, ok := vpnAccessStaticNatAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`static_nat expected to be basetypes.MapValue, was: %T`, vpnAccessStaticNatAttribute))
	}

	if diags.HasError() {
		return NewVpnAccessValueUnknown(), diags
	}

	return VpnAccessValue{
		AdvertisedSubnet:          advertisedSubnetVal,
		AllowPing:                 allowPingVal,
		NatPool:                   natPoolVal,
		NoReadvertiseToLanBgp:     noReadvertiseToLanBgpVal,
		NoReadvertiseToLanOspf:    noReadvertiseToLanOspfVal,
		NoReadvertiseToOverlay:    noReadvertiseToOverlayVal,
		OtherVrfs:                 otherVrfsVal,
		Routed:                    routedVal,
		SourceNat:                 sourceNatVal,
		SummarizedSubnet:          summarizedSubnetVal,
		SummarizedSubnetToLanBgp:  summarizedSubnetToLanBgpVal,
		SummarizedSubnetToLanOspf: summarizedSubnetToLanOspfVal,
		VpnAccessDestinationNat:   vpnAccessDestinationNatVal,
		VpnAccessStaticNat:        vpnAccessStaticNatVal,
		state:                     attr.ValueStateKnown,
	}, diags
}

func NewVpnAccessValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) VpnAccessValue {
	object, diags := NewVpnAccessValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewVpnAccessValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t VpnAccessType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewVpnAccessValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewVpnAccessValueUnknown(), nil
	}

	if in.IsNull() {
		return NewVpnAccessValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewVpnAccessValueMust(VpnAccessValue{}.AttributeTypes(ctx), attributes), nil
}

func (t VpnAccessType) ValueType(ctx context.Context) attr.Value {
	return VpnAccessValue{}
}

var _ basetypes.ObjectValuable = VpnAccessValue{}

type VpnAccessValue struct {
	AdvertisedSubnet          basetypes.StringValue `tfsdk:"advertised_subnet"`
	AllowPing                 basetypes.BoolValue   `tfsdk:"allow_ping"`
	NatPool                   basetypes.StringValue `tfsdk:"nat_pool"`
	NoReadvertiseToLanBgp     basetypes.BoolValue   `tfsdk:"no_readvertise_to_lan_bgp"`
	NoReadvertiseToLanOspf    basetypes.BoolValue   `tfsdk:"no_readvertise_to_lan_ospf"`
	NoReadvertiseToOverlay    basetypes.BoolValue   `tfsdk:"no_readvertise_to_overlay"`
	OtherVrfs                 basetypes.ListValue   `tfsdk:"other_vrfs"`
	Routed                    basetypes.BoolValue   `tfsdk:"routed"`
	SourceNat                 basetypes.ObjectValue `tfsdk:"source_nat"`
	SummarizedSubnet          basetypes.StringValue `tfsdk:"summarized_subnet"`
	SummarizedSubnetToLanBgp  basetypes.StringValue `tfsdk:"summarized_subnet_to_lan_bgp"`
	SummarizedSubnetToLanOspf basetypes.StringValue `tfsdk:"summarized_subnet_to_lan_ospf"`
	VpnAccessDestinationNat   basetypes.MapValue    `tfsdk:"destination_nat"`
	VpnAccessStaticNat        basetypes.MapValue    `tfsdk:"static_nat"`
	state                     attr.ValueState
}

func (v VpnAccessValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 14)

	var val tftypes.Value
	var err error

	attrTypes["advertised_subnet"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["allow_ping"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["nat_pool"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["no_readvertise_to_lan_bgp"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["no_readvertise_to_lan_ospf"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["no_readvertise_to_overlay"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["other_vrfs"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["routed"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["source_nat"] = basetypes.ObjectType{
		AttrTypes: SourceNatValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["summarized_subnet"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["summarized_subnet_to_lan_bgp"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["summarized_subnet_to_lan_ospf"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["destination_nat"] = basetypes.MapType{
		ElemType: VpnAccessDestinationNatValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["static_nat"] = basetypes.MapType{
		ElemType: VpnAccessStaticNatValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 14)

		val, err = v.AdvertisedSubnet.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["advertised_subnet"] = val

		val, err = v.AllowPing.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["allow_ping"] = val

		val, err = v.NatPool.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["nat_pool"] = val

		val, err = v.NoReadvertiseToLanBgp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["no_readvertise_to_lan_bgp"] = val

		val, err = v.NoReadvertiseToLanOspf.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["no_readvertise_to_lan_ospf"] = val

		val, err = v.NoReadvertiseToOverlay.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["no_readvertise_to_overlay"] = val

		val, err = v.OtherVrfs.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["other_vrfs"] = val

		val, err = v.Routed.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["routed"] = val

		val, err = v.SourceNat.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["source_nat"] = val

		val, err = v.SummarizedSubnet.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["summarized_subnet"] = val

		val, err = v.SummarizedSubnetToLanBgp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["summarized_subnet_to_lan_bgp"] = val

		val, err = v.SummarizedSubnetToLanOspf.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["summarized_subnet_to_lan_ospf"] = val

		val, err = v.VpnAccessDestinationNat.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["destination_nat"] = val

		val, err = v.VpnAccessStaticNat.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["static_nat"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v VpnAccessValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v VpnAccessValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v VpnAccessValue) String() string {
	return "VpnAccessValue"
}

func (v VpnAccessValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var sourceNat basetypes.ObjectValue

	if v.SourceNat.IsNull() {
		sourceNat = types.ObjectNull(
			SourceNatValue{}.AttributeTypes(ctx),
		)
	}

	if v.SourceNat.IsUnknown() {
		sourceNat = types.ObjectUnknown(
			SourceNatValue{}.AttributeTypes(ctx),
		)
	}

	if !v.SourceNat.IsNull() && !v.SourceNat.IsUnknown() {
		sourceNat = types.ObjectValueMust(
			SourceNatValue{}.AttributeTypes(ctx),
			v.SourceNat.Attributes(),
		)
	}

	vpnAccessDestinationNat := types.MapValueMust(
		VpnAccessDestinationNatType{
			basetypes.ObjectType{
				AttrTypes: VpnAccessDestinationNatValue{}.AttributeTypes(ctx),
			},
		},
		v.VpnAccessDestinationNat.Elements(),
	)

	if v.VpnAccessDestinationNat.IsNull() {
		vpnAccessDestinationNat = types.MapNull(
			VpnAccessDestinationNatType{
				basetypes.ObjectType{
					AttrTypes: VpnAccessDestinationNatValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.VpnAccessDestinationNat.IsUnknown() {
		vpnAccessDestinationNat = types.MapUnknown(
			VpnAccessDestinationNatType{
				basetypes.ObjectType{
					AttrTypes: VpnAccessDestinationNatValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	vpnAccessStaticNat := types.MapValueMust(
		VpnAccessStaticNatType{
			basetypes.ObjectType{
				AttrTypes: VpnAccessStaticNatValue{}.AttributeTypes(ctx),
			},
		},
		v.VpnAccessStaticNat.Elements(),
	)

	if v.VpnAccessStaticNat.IsNull() {
		vpnAccessStaticNat = types.MapNull(
			VpnAccessStaticNatType{
				basetypes.ObjectType{
					AttrTypes: VpnAccessStaticNatValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.VpnAccessStaticNat.IsUnknown() {
		vpnAccessStaticNat = types.MapUnknown(
			VpnAccessStaticNatType{
				basetypes.ObjectType{
					AttrTypes: VpnAccessStaticNatValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var otherVrfsVal basetypes.ListValue
	switch {
	case v.OtherVrfs.IsUnknown():
		otherVrfsVal = types.ListUnknown(types.StringType)
	case v.OtherVrfs.IsNull():
		otherVrfsVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		otherVrfsVal, d = types.ListValue(types.StringType, v.OtherVrfs.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"advertised_subnet":          basetypes.StringType{},
			"allow_ping":                 basetypes.BoolType{},
			"nat_pool":                   basetypes.StringType{},
			"no_readvertise_to_lan_bgp":  basetypes.BoolType{},
			"no_readvertise_to_lan_ospf": basetypes.BoolType{},
			"no_readvertise_to_overlay":  basetypes.BoolType{},
			"other_vrfs": basetypes.ListType{
				ElemType: types.StringType,
			},
			"routed": basetypes.BoolType{},
			"source_nat": basetypes.ObjectType{
				AttrTypes: SourceNatValue{}.AttributeTypes(ctx),
			},
			"summarized_subnet":             basetypes.StringType{},
			"summarized_subnet_to_lan_bgp":  basetypes.StringType{},
			"summarized_subnet_to_lan_ospf": basetypes.StringType{},
			"destination_nat": basetypes.MapType{
				ElemType: VpnAccessDestinationNatValue{}.Type(ctx),
			},
			"static_nat": basetypes.MapType{
				ElemType: VpnAccessStaticNatValue{}.Type(ctx),
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"advertised_subnet":          basetypes.StringType{},
		"allow_ping":                 basetypes.BoolType{},
		"nat_pool":                   basetypes.StringType{},
		"no_readvertise_to_lan_bgp":  basetypes.BoolType{},
		"no_readvertise_to_lan_ospf": basetypes.BoolType{},
		"no_readvertise_to_overlay":  basetypes.BoolType{},
		"other_vrfs": basetypes.ListType{
			ElemType: types.StringType,
		},
		"routed": basetypes.BoolType{},
		"source_nat": basetypes.ObjectType{
			AttrTypes: SourceNatValue{}.AttributeTypes(ctx),
		},
		"summarized_subnet":             basetypes.StringType{},
		"summarized_subnet_to_lan_bgp":  basetypes.StringType{},
		"summarized_subnet_to_lan_ospf": basetypes.StringType{},
		"destination_nat": basetypes.MapType{
			ElemType: VpnAccessDestinationNatValue{}.Type(ctx),
		},
		"static_nat": basetypes.MapType{
			ElemType: VpnAccessStaticNatValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"advertised_subnet":             v.AdvertisedSubnet,
			"allow_ping":                    v.AllowPing,
			"nat_pool":                      v.NatPool,
			"no_readvertise_to_lan_bgp":     v.NoReadvertiseToLanBgp,
			"no_readvertise_to_lan_ospf":    v.NoReadvertiseToLanOspf,
			"no_readvertise_to_overlay":     v.NoReadvertiseToOverlay,
			"other_vrfs":                    otherVrfsVal,
			"routed":                        v.Routed,
			"source_nat":                    sourceNat,
			"summarized_subnet":             v.SummarizedSubnet,
			"summarized_subnet_to_lan_bgp":  v.SummarizedSubnetToLanBgp,
			"summarized_subnet_to_lan_ospf": v.SummarizedSubnetToLanOspf,
			"destination_nat":               vpnAccessDestinationNat,
			"static_nat":                    vpnAccessStaticNat,
		})

	return objVal, diags
}

func (v VpnAccessValue) Equal(o attr.Value) bool {
	other, ok := o.(VpnAccessValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AdvertisedSubnet.Equal(other.AdvertisedSubnet) {
		return false
	}

	if !v.AllowPing.Equal(other.AllowPing) {
		return false
	}

	if !v.NatPool.Equal(other.NatPool) {
		return false
	}

	if !v.NoReadvertiseToLanBgp.Equal(other.NoReadvertiseToLanBgp) {
		return false
	}

	if !v.NoReadvertiseToLanOspf.Equal(other.NoReadvertiseToLanOspf) {
		return false
	}

	if !v.NoReadvertiseToOverlay.Equal(other.NoReadvertiseToOverlay) {
		return false
	}

	if !v.OtherVrfs.Equal(other.OtherVrfs) {
		return false
	}

	if !v.Routed.Equal(other.Routed) {
		return false
	}

	if !v.SourceNat.Equal(other.SourceNat) {
		return false
	}

	if !v.SummarizedSubnet.Equal(other.SummarizedSubnet) {
		return false
	}

	if !v.SummarizedSubnetToLanBgp.Equal(other.SummarizedSubnetToLanBgp) {
		return false
	}

	if !v.SummarizedSubnetToLanOspf.Equal(other.SummarizedSubnetToLanOspf) {
		return false
	}

	if !v.VpnAccessDestinationNat.Equal(other.VpnAccessDestinationNat) {
		return false
	}

	if !v.VpnAccessStaticNat.Equal(other.VpnAccessStaticNat) {
		return false
	}

	return true
}

func (v VpnAccessValue) Type(ctx context.Context) attr.Type {
	return VpnAccessType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v VpnAccessValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"advertised_subnet":          basetypes.StringType{},
		"allow_ping":                 basetypes.BoolType{},
		"nat_pool":                   basetypes.StringType{},
		"no_readvertise_to_lan_bgp":  basetypes.BoolType{},
		"no_readvertise_to_lan_ospf": basetypes.BoolType{},
		"no_readvertise_to_overlay":  basetypes.BoolType{},
		"other_vrfs": basetypes.ListType{
			ElemType: types.StringType,
		},
		"routed": basetypes.BoolType{},
		"source_nat": basetypes.ObjectType{
			AttrTypes: SourceNatValue{}.AttributeTypes(ctx),
		},
		"summarized_subnet":             basetypes.StringType{},
		"summarized_subnet_to_lan_bgp":  basetypes.StringType{},
		"summarized_subnet_to_lan_ospf": basetypes.StringType{},
		"destination_nat": basetypes.MapType{
			ElemType: VpnAccessDestinationNatValue{}.Type(ctx),
		},
		"static_nat": basetypes.MapType{
			ElemType: VpnAccessStaticNatValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = SourceNatType{}

type SourceNatType struct {
	basetypes.ObjectType
}

func (t SourceNatType) Equal(o attr.Type) bool {
	other, ok := o.(SourceNatType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SourceNatType) String() string {
	return "SourceNatType"
}

func (t SourceNatType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	externalIpAttribute, ok := attributes["external_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`external_ip is missing from object`)

		return nil, diags
	}

	externalIpVal, ok := externalIpAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`external_ip expected to be basetypes.StringValue, was: %T`, externalIpAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SourceNatValue{
		ExternalIp: externalIpVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewSourceNatValueNull() SourceNatValue {
	return SourceNatValue{
		state: attr.ValueStateNull,
	}
}

func NewSourceNatValueUnknown() SourceNatValue {
	return SourceNatValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSourceNatValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SourceNatValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SourceNatValue Attribute Value",
				"While creating a SourceNatValue value, a missing attribute value was detected. "+
					"A SourceNatValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SourceNatValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SourceNatValue Attribute Type",
				"While creating a SourceNatValue value, an invalid attribute value was detected. "+
					"A SourceNatValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SourceNatValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SourceNatValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SourceNatValue Attribute Value",
				"While creating a SourceNatValue value, an extra attribute value was detected. "+
					"A SourceNatValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SourceNatValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSourceNatValueUnknown(), diags
	}

	externalIpAttribute, ok := attributes["external_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`external_ip is missing from object`)

		return NewSourceNatValueUnknown(), diags
	}

	externalIpVal, ok := externalIpAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`external_ip expected to be basetypes.StringValue, was: %T`, externalIpAttribute))
	}

	if diags.HasError() {
		return NewSourceNatValueUnknown(), diags
	}

	return SourceNatValue{
		ExternalIp: externalIpVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewSourceNatValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SourceNatValue {
	object, diags := NewSourceNatValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSourceNatValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SourceNatType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSourceNatValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSourceNatValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSourceNatValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSourceNatValueMust(SourceNatValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SourceNatType) ValueType(ctx context.Context) attr.Value {
	return SourceNatValue{}
}

var _ basetypes.ObjectValuable = SourceNatValue{}

type SourceNatValue struct {
	ExternalIp basetypes.StringValue `tfsdk:"external_ip"`
	state      attr.ValueState
}

func (v SourceNatValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["external_ip"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.ExternalIp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["external_ip"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SourceNatValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SourceNatValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SourceNatValue) String() string {
	return "SourceNatValue"
}

func (v SourceNatValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"external_ip": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"external_ip": v.ExternalIp,
		})

	return objVal, diags
}

func (v SourceNatValue) Equal(o attr.Value) bool {
	other, ok := o.(SourceNatValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.ExternalIp.Equal(other.ExternalIp) {
		return false
	}

	return true
}

func (v SourceNatValue) Type(ctx context.Context) attr.Type {
	return SourceNatType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SourceNatValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"external_ip": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = VpnAccessDestinationNatType{}

type VpnAccessDestinationNatType struct {
	basetypes.ObjectType
}

func (t VpnAccessDestinationNatType) Equal(o attr.Type) bool {
	other, ok := o.(VpnAccessDestinationNatType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t VpnAccessDestinationNatType) String() string {
	return "VpnAccessDestinationNatType"
}

func (t VpnAccessDestinationNatType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	internalIpAttribute, ok := attributes["internal_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`internal_ip is missing from object`)

		return nil, diags
	}

	internalIpVal, ok := internalIpAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`internal_ip expected to be basetypes.StringValue, was: %T`, internalIpAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	portAttribute, ok := attributes["port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port is missing from object`)

		return nil, diags
	}

	portVal, ok := portAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port expected to be basetypes.StringValue, was: %T`, portAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return VpnAccessDestinationNatValue{
		InternalIp: internalIpVal,
		Name:       nameVal,
		Port:       portVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewVpnAccessDestinationNatValueNull() VpnAccessDestinationNatValue {
	return VpnAccessDestinationNatValue{
		state: attr.ValueStateNull,
	}
}

func NewVpnAccessDestinationNatValueUnknown() VpnAccessDestinationNatValue {
	return VpnAccessDestinationNatValue{
		state: attr.ValueStateUnknown,
	}
}

func NewVpnAccessDestinationNatValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (VpnAccessDestinationNatValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing VpnAccessDestinationNatValue Attribute Value",
				"While creating a VpnAccessDestinationNatValue value, a missing attribute value was detected. "+
					"A VpnAccessDestinationNatValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VpnAccessDestinationNatValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid VpnAccessDestinationNatValue Attribute Type",
				"While creating a VpnAccessDestinationNatValue value, an invalid attribute value was detected. "+
					"A VpnAccessDestinationNatValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VpnAccessDestinationNatValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("VpnAccessDestinationNatValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra VpnAccessDestinationNatValue Attribute Value",
				"While creating a VpnAccessDestinationNatValue value, an extra attribute value was detected. "+
					"A VpnAccessDestinationNatValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra VpnAccessDestinationNatValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewVpnAccessDestinationNatValueUnknown(), diags
	}

	internalIpAttribute, ok := attributes["internal_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`internal_ip is missing from object`)

		return NewVpnAccessDestinationNatValueUnknown(), diags
	}

	internalIpVal, ok := internalIpAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`internal_ip expected to be basetypes.StringValue, was: %T`, internalIpAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewVpnAccessDestinationNatValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	portAttribute, ok := attributes["port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port is missing from object`)

		return NewVpnAccessDestinationNatValueUnknown(), diags
	}

	portVal, ok := portAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port expected to be basetypes.StringValue, was: %T`, portAttribute))
	}

	if diags.HasError() {
		return NewVpnAccessDestinationNatValueUnknown(), diags
	}

	return VpnAccessDestinationNatValue{
		InternalIp: internalIpVal,
		Name:       nameVal,
		Port:       portVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewVpnAccessDestinationNatValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) VpnAccessDestinationNatValue {
	object, diags := NewVpnAccessDestinationNatValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewVpnAccessDestinationNatValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t VpnAccessDestinationNatType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewVpnAccessDestinationNatValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewVpnAccessDestinationNatValueUnknown(), nil
	}

	if in.IsNull() {
		return NewVpnAccessDestinationNatValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewVpnAccessDestinationNatValueMust(VpnAccessDestinationNatValue{}.AttributeTypes(ctx), attributes), nil
}

func (t VpnAccessDestinationNatType) ValueType(ctx context.Context) attr.Value {
	return VpnAccessDestinationNatValue{}
}

var _ basetypes.ObjectValuable = VpnAccessDestinationNatValue{}

type VpnAccessDestinationNatValue struct {
	InternalIp basetypes.StringValue `tfsdk:"internal_ip"`
	Name       basetypes.StringValue `tfsdk:"name"`
	Port       basetypes.StringValue `tfsdk:"port"`
	state      attr.ValueState
}

func (v VpnAccessDestinationNatValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["internal_ip"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["port"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.InternalIp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["internal_ip"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Port.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v VpnAccessDestinationNatValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v VpnAccessDestinationNatValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v VpnAccessDestinationNatValue) String() string {
	return "VpnAccessDestinationNatValue"
}

func (v VpnAccessDestinationNatValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"internal_ip": basetypes.StringType{},
		"name":        basetypes.StringType{},
		"port":        basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"internal_ip": v.InternalIp,
			"name":        v.Name,
			"port":        v.Port,
		})

	return objVal, diags
}

func (v VpnAccessDestinationNatValue) Equal(o attr.Value) bool {
	other, ok := o.(VpnAccessDestinationNatValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.InternalIp.Equal(other.InternalIp) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Port.Equal(other.Port) {
		return false
	}

	return true
}

func (v VpnAccessDestinationNatValue) Type(ctx context.Context) attr.Type {
	return VpnAccessDestinationNatType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v VpnAccessDestinationNatValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"internal_ip": basetypes.StringType{},
		"name":        basetypes.StringType{},
		"port":        basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = VpnAccessStaticNatType{}

type VpnAccessStaticNatType struct {
	basetypes.ObjectType
}

func (t VpnAccessStaticNatType) Equal(o attr.Type) bool {
	other, ok := o.(VpnAccessStaticNatType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t VpnAccessStaticNatType) String() string {
	return "VpnAccessStaticNatType"
}

func (t VpnAccessStaticNatType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	internalIpAttribute, ok := attributes["internal_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`internal_ip is missing from object`)

		return nil, diags
	}

	internalIpVal, ok := internalIpAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`internal_ip expected to be basetypes.StringValue, was: %T`, internalIpAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return VpnAccessStaticNatValue{
		InternalIp: internalIpVal,
		Name:       nameVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewVpnAccessStaticNatValueNull() VpnAccessStaticNatValue {
	return VpnAccessStaticNatValue{
		state: attr.ValueStateNull,
	}
}

func NewVpnAccessStaticNatValueUnknown() VpnAccessStaticNatValue {
	return VpnAccessStaticNatValue{
		state: attr.ValueStateUnknown,
	}
}

func NewVpnAccessStaticNatValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (VpnAccessStaticNatValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing VpnAccessStaticNatValue Attribute Value",
				"While creating a VpnAccessStaticNatValue value, a missing attribute value was detected. "+
					"A VpnAccessStaticNatValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VpnAccessStaticNatValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid VpnAccessStaticNatValue Attribute Type",
				"While creating a VpnAccessStaticNatValue value, an invalid attribute value was detected. "+
					"A VpnAccessStaticNatValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VpnAccessStaticNatValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("VpnAccessStaticNatValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra VpnAccessStaticNatValue Attribute Value",
				"While creating a VpnAccessStaticNatValue value, an extra attribute value was detected. "+
					"A VpnAccessStaticNatValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra VpnAccessStaticNatValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewVpnAccessStaticNatValueUnknown(), diags
	}

	internalIpAttribute, ok := attributes["internal_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`internal_ip is missing from object`)

		return NewVpnAccessStaticNatValueUnknown(), diags
	}

	internalIpVal, ok := internalIpAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`internal_ip expected to be basetypes.StringValue, was: %T`, internalIpAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewVpnAccessStaticNatValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	if diags.HasError() {
		return NewVpnAccessStaticNatValueUnknown(), diags
	}

	return VpnAccessStaticNatValue{
		InternalIp: internalIpVal,
		Name:       nameVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewVpnAccessStaticNatValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) VpnAccessStaticNatValue {
	object, diags := NewVpnAccessStaticNatValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewVpnAccessStaticNatValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t VpnAccessStaticNatType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewVpnAccessStaticNatValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewVpnAccessStaticNatValueUnknown(), nil
	}

	if in.IsNull() {
		return NewVpnAccessStaticNatValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewVpnAccessStaticNatValueMust(VpnAccessStaticNatValue{}.AttributeTypes(ctx), attributes), nil
}

func (t VpnAccessStaticNatType) ValueType(ctx context.Context) attr.Value {
	return VpnAccessStaticNatValue{}
}

var _ basetypes.ObjectValuable = VpnAccessStaticNatValue{}

type VpnAccessStaticNatValue struct {
	InternalIp basetypes.StringValue `tfsdk:"internal_ip"`
	Name       basetypes.StringValue `tfsdk:"name"`
	state      attr.ValueState
}

func (v VpnAccessStaticNatValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["internal_ip"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.InternalIp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["internal_ip"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v VpnAccessStaticNatValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v VpnAccessStaticNatValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v VpnAccessStaticNatValue) String() string {
	return "VpnAccessStaticNatValue"
}

func (v VpnAccessStaticNatValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"internal_ip": basetypes.StringType{},
		"name":        basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"internal_ip": v.InternalIp,
			"name":        v.Name,
		})

	return objVal, diags
}

func (v VpnAccessStaticNatValue) Equal(o attr.Value) bool {
	other, ok := o.(VpnAccessStaticNatValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.InternalIp.Equal(other.InternalIp) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	return true
}

func (v VpnAccessStaticNatValue) Type(ctx context.Context) attr.Type {
	return VpnAccessStaticNatType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v VpnAccessStaticNatValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"internal_ip": basetypes.StringType{},
		"name":        basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = OobIpConfigType{}

type OobIpConfigType struct {
	basetypes.ObjectType
}

func (t OobIpConfigType) Equal(o attr.Type) bool {
	other, ok := o.(OobIpConfigType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t OobIpConfigType) String() string {
	return "OobIpConfigType"
}

func (t OobIpConfigType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	gatewayAttribute, ok := attributes["gateway"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gateway is missing from object`)

		return nil, diags
	}

	gatewayVal, ok := gatewayAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gateway expected to be basetypes.StringValue, was: %T`, gatewayAttribute))
	}

	ipAttribute, ok := attributes["ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip is missing from object`)

		return nil, diags
	}

	ipVal, ok := ipAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip expected to be basetypes.StringValue, was: %T`, ipAttribute))
	}

	netmaskAttribute, ok := attributes["netmask"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`netmask is missing from object`)

		return nil, diags
	}

	netmaskVal, ok := netmaskAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`netmask expected to be basetypes.StringValue, was: %T`, netmaskAttribute))
	}

	node1Attribute, ok := attributes["node1"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node1 is missing from object`)

		return nil, diags
	}

	node1Val, ok := node1Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node1 expected to be basetypes.ObjectValue, was: %T`, node1Attribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	useMgmtVrfAttribute, ok := attributes["use_mgmt_vrf"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`use_mgmt_vrf is missing from object`)

		return nil, diags
	}

	useMgmtVrfVal, ok := useMgmtVrfAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`use_mgmt_vrf expected to be basetypes.BoolValue, was: %T`, useMgmtVrfAttribute))
	}

	useMgmtVrfForHostOutAttribute, ok := attributes["use_mgmt_vrf_for_host_out"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`use_mgmt_vrf_for_host_out is missing from object`)

		return nil, diags
	}

	useMgmtVrfForHostOutVal, ok := useMgmtVrfForHostOutAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`use_mgmt_vrf_for_host_out expected to be basetypes.BoolValue, was: %T`, useMgmtVrfForHostOutAttribute))
	}

	vlanIdAttribute, ok := attributes["vlan_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan_id is missing from object`)

		return nil, diags
	}

	vlanIdVal, ok := vlanIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan_id expected to be basetypes.StringValue, was: %T`, vlanIdAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return OobIpConfigValue{
		Gateway:              gatewayVal,
		Ip:                   ipVal,
		Netmask:              netmaskVal,
		Node1:                node1Val,
		OobIpConfigType:      typeVal,
		UseMgmtVrf:           useMgmtVrfVal,
		UseMgmtVrfForHostOut: useMgmtVrfForHostOutVal,
		VlanId:               vlanIdVal,
		state:                attr.ValueStateKnown,
	}, diags
}

func NewOobIpConfigValueNull() OobIpConfigValue {
	return OobIpConfigValue{
		state: attr.ValueStateNull,
	}
}

func NewOobIpConfigValueUnknown() OobIpConfigValue {
	return OobIpConfigValue{
		state: attr.ValueStateUnknown,
	}
}

func NewOobIpConfigValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (OobIpConfigValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing OobIpConfigValue Attribute Value",
				"While creating a OobIpConfigValue value, a missing attribute value was detected. "+
					"A OobIpConfigValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OobIpConfigValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid OobIpConfigValue Attribute Type",
				"While creating a OobIpConfigValue value, an invalid attribute value was detected. "+
					"A OobIpConfigValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OobIpConfigValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("OobIpConfigValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra OobIpConfigValue Attribute Value",
				"While creating a OobIpConfigValue value, an extra attribute value was detected. "+
					"A OobIpConfigValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra OobIpConfigValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewOobIpConfigValueUnknown(), diags
	}

	gatewayAttribute, ok := attributes["gateway"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gateway is missing from object`)

		return NewOobIpConfigValueUnknown(), diags
	}

	gatewayVal, ok := gatewayAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gateway expected to be basetypes.StringValue, was: %T`, gatewayAttribute))
	}

	ipAttribute, ok := attributes["ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip is missing from object`)

		return NewOobIpConfigValueUnknown(), diags
	}

	ipVal, ok := ipAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip expected to be basetypes.StringValue, was: %T`, ipAttribute))
	}

	netmaskAttribute, ok := attributes["netmask"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`netmask is missing from object`)

		return NewOobIpConfigValueUnknown(), diags
	}

	netmaskVal, ok := netmaskAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`netmask expected to be basetypes.StringValue, was: %T`, netmaskAttribute))
	}

	node1Attribute, ok := attributes["node1"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node1 is missing from object`)

		return NewOobIpConfigValueUnknown(), diags
	}

	node1Val, ok := node1Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node1 expected to be basetypes.ObjectValue, was: %T`, node1Attribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewOobIpConfigValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	useMgmtVrfAttribute, ok := attributes["use_mgmt_vrf"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`use_mgmt_vrf is missing from object`)

		return NewOobIpConfigValueUnknown(), diags
	}

	useMgmtVrfVal, ok := useMgmtVrfAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`use_mgmt_vrf expected to be basetypes.BoolValue, was: %T`, useMgmtVrfAttribute))
	}

	useMgmtVrfForHostOutAttribute, ok := attributes["use_mgmt_vrf_for_host_out"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`use_mgmt_vrf_for_host_out is missing from object`)

		return NewOobIpConfigValueUnknown(), diags
	}

	useMgmtVrfForHostOutVal, ok := useMgmtVrfForHostOutAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`use_mgmt_vrf_for_host_out expected to be basetypes.BoolValue, was: %T`, useMgmtVrfForHostOutAttribute))
	}

	vlanIdAttribute, ok := attributes["vlan_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan_id is missing from object`)

		return NewOobIpConfigValueUnknown(), diags
	}

	vlanIdVal, ok := vlanIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan_id expected to be basetypes.StringValue, was: %T`, vlanIdAttribute))
	}

	if diags.HasError() {
		return NewOobIpConfigValueUnknown(), diags
	}

	return OobIpConfigValue{
		Gateway:              gatewayVal,
		Ip:                   ipVal,
		Netmask:              netmaskVal,
		Node1:                node1Val,
		OobIpConfigType:      typeVal,
		UseMgmtVrf:           useMgmtVrfVal,
		UseMgmtVrfForHostOut: useMgmtVrfForHostOutVal,
		VlanId:               vlanIdVal,
		state:                attr.ValueStateKnown,
	}, diags
}

func NewOobIpConfigValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) OobIpConfigValue {
	object, diags := NewOobIpConfigValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewOobIpConfigValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t OobIpConfigType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewOobIpConfigValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewOobIpConfigValueUnknown(), nil
	}

	if in.IsNull() {
		return NewOobIpConfigValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewOobIpConfigValueMust(OobIpConfigValue{}.AttributeTypes(ctx), attributes), nil
}

func (t OobIpConfigType) ValueType(ctx context.Context) attr.Value {
	return OobIpConfigValue{}
}

var _ basetypes.ObjectValuable = OobIpConfigValue{}

type OobIpConfigValue struct {
	Gateway              basetypes.StringValue `tfsdk:"gateway"`
	Ip                   basetypes.StringValue `tfsdk:"ip"`
	Netmask              basetypes.StringValue `tfsdk:"netmask"`
	Node1                basetypes.ObjectValue `tfsdk:"node1"`
	OobIpConfigType      basetypes.StringValue `tfsdk:"type"`
	UseMgmtVrf           basetypes.BoolValue   `tfsdk:"use_mgmt_vrf"`
	UseMgmtVrfForHostOut basetypes.BoolValue   `tfsdk:"use_mgmt_vrf_for_host_out"`
	VlanId               basetypes.StringValue `tfsdk:"vlan_id"`
	state                attr.ValueState
}

func (v OobIpConfigValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 8)

	var val tftypes.Value
	var err error

	attrTypes["gateway"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ip"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["netmask"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["node1"] = basetypes.ObjectType{
		AttrTypes: Node1Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["use_mgmt_vrf"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["use_mgmt_vrf_for_host_out"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["vlan_id"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 8)

		val, err = v.Gateway.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["gateway"] = val

		val, err = v.Ip.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip"] = val

		val, err = v.Netmask.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["netmask"] = val

		val, err = v.Node1.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["node1"] = val

		val, err = v.OobIpConfigType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		val, err = v.UseMgmtVrf.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["use_mgmt_vrf"] = val

		val, err = v.UseMgmtVrfForHostOut.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["use_mgmt_vrf_for_host_out"] = val

		val, err = v.VlanId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vlan_id"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v OobIpConfigValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v OobIpConfigValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v OobIpConfigValue) String() string {
	return "OobIpConfigValue"
}

func (v OobIpConfigValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var node1 basetypes.ObjectValue

	if v.Node1.IsNull() {
		node1 = types.ObjectNull(
			Node1Value{}.AttributeTypes(ctx),
		)
	}

	if v.Node1.IsUnknown() {
		node1 = types.ObjectUnknown(
			Node1Value{}.AttributeTypes(ctx),
		)
	}

	if !v.Node1.IsNull() && !v.Node1.IsUnknown() {
		node1 = types.ObjectValueMust(
			Node1Value{}.AttributeTypes(ctx),
			v.Node1.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"gateway": basetypes.StringType{},
		"ip":      basetypes.StringType{},
		"netmask": basetypes.StringType{},
		"node1": basetypes.ObjectType{
			AttrTypes: Node1Value{}.AttributeTypes(ctx),
		},
		"type":                      basetypes.StringType{},
		"use_mgmt_vrf":              basetypes.BoolType{},
		"use_mgmt_vrf_for_host_out": basetypes.BoolType{},
		"vlan_id":                   basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"gateway":                   v.Gateway,
			"ip":                        v.Ip,
			"netmask":                   v.Netmask,
			"node1":                     node1,
			"type":                      v.OobIpConfigType,
			"use_mgmt_vrf":              v.UseMgmtVrf,
			"use_mgmt_vrf_for_host_out": v.UseMgmtVrfForHostOut,
			"vlan_id":                   v.VlanId,
		})

	return objVal, diags
}

func (v OobIpConfigValue) Equal(o attr.Value) bool {
	other, ok := o.(OobIpConfigValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Gateway.Equal(other.Gateway) {
		return false
	}

	if !v.Ip.Equal(other.Ip) {
		return false
	}

	if !v.Netmask.Equal(other.Netmask) {
		return false
	}

	if !v.Node1.Equal(other.Node1) {
		return false
	}

	if !v.OobIpConfigType.Equal(other.OobIpConfigType) {
		return false
	}

	if !v.UseMgmtVrf.Equal(other.UseMgmtVrf) {
		return false
	}

	if !v.UseMgmtVrfForHostOut.Equal(other.UseMgmtVrfForHostOut) {
		return false
	}

	if !v.VlanId.Equal(other.VlanId) {
		return false
	}

	return true
}

func (v OobIpConfigValue) Type(ctx context.Context) attr.Type {
	return OobIpConfigType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v OobIpConfigValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"gateway": basetypes.StringType{},
		"ip":      basetypes.StringType{},
		"netmask": basetypes.StringType{},
		"node1": basetypes.ObjectType{
			AttrTypes: Node1Value{}.AttributeTypes(ctx),
		},
		"type":                      basetypes.StringType{},
		"use_mgmt_vrf":              basetypes.BoolType{},
		"use_mgmt_vrf_for_host_out": basetypes.BoolType{},
		"vlan_id":                   basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = Node1Type{}

type Node1Type struct {
	basetypes.ObjectType
}

func (t Node1Type) Equal(o attr.Type) bool {
	other, ok := o.(Node1Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Node1Type) String() string {
	return "Node1Type"
}

func (t Node1Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	gatewayAttribute, ok := attributes["gateway"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gateway is missing from object`)

		return nil, diags
	}

	gatewayVal, ok := gatewayAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gateway expected to be basetypes.StringValue, was: %T`, gatewayAttribute))
	}

	ipAttribute, ok := attributes["ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip is missing from object`)

		return nil, diags
	}

	ipVal, ok := ipAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip expected to be basetypes.StringValue, was: %T`, ipAttribute))
	}

	netmaskAttribute, ok := attributes["netmask"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`netmask is missing from object`)

		return nil, diags
	}

	netmaskVal, ok := netmaskAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`netmask expected to be basetypes.StringValue, was: %T`, netmaskAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	useMgmtVrfAttribute, ok := attributes["use_mgmt_vrf"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`use_mgmt_vrf is missing from object`)

		return nil, diags
	}

	useMgmtVrfVal, ok := useMgmtVrfAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`use_mgmt_vrf expected to be basetypes.BoolValue, was: %T`, useMgmtVrfAttribute))
	}

	useMgmtVrfForHostOutAttribute, ok := attributes["use_mgmt_vrf_for_host_out"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`use_mgmt_vrf_for_host_out is missing from object`)

		return nil, diags
	}

	useMgmtVrfForHostOutVal, ok := useMgmtVrfForHostOutAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`use_mgmt_vrf_for_host_out expected to be basetypes.BoolValue, was: %T`, useMgmtVrfForHostOutAttribute))
	}

	vlanIdAttribute, ok := attributes["vlan_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan_id is missing from object`)

		return nil, diags
	}

	vlanIdVal, ok := vlanIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan_id expected to be basetypes.StringValue, was: %T`, vlanIdAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Node1Value{
		Gateway:              gatewayVal,
		Ip:                   ipVal,
		Netmask:              netmaskVal,
		Node1Type:            typeVal,
		UseMgmtVrf:           useMgmtVrfVal,
		UseMgmtVrfForHostOut: useMgmtVrfForHostOutVal,
		VlanId:               vlanIdVal,
		state:                attr.ValueStateKnown,
	}, diags
}

func NewNode1ValueNull() Node1Value {
	return Node1Value{
		state: attr.ValueStateNull,
	}
}

func NewNode1ValueUnknown() Node1Value {
	return Node1Value{
		state: attr.ValueStateUnknown,
	}
}

func NewNode1Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Node1Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Node1Value Attribute Value",
				"While creating a Node1Value value, a missing attribute value was detected. "+
					"A Node1Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Node1Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Node1Value Attribute Type",
				"While creating a Node1Value value, an invalid attribute value was detected. "+
					"A Node1Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Node1Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Node1Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Node1Value Attribute Value",
				"While creating a Node1Value value, an extra attribute value was detected. "+
					"A Node1Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Node1Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewNode1ValueUnknown(), diags
	}

	gatewayAttribute, ok := attributes["gateway"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gateway is missing from object`)

		return NewNode1ValueUnknown(), diags
	}

	gatewayVal, ok := gatewayAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gateway expected to be basetypes.StringValue, was: %T`, gatewayAttribute))
	}

	ipAttribute, ok := attributes["ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip is missing from object`)

		return NewNode1ValueUnknown(), diags
	}

	ipVal, ok := ipAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip expected to be basetypes.StringValue, was: %T`, ipAttribute))
	}

	netmaskAttribute, ok := attributes["netmask"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`netmask is missing from object`)

		return NewNode1ValueUnknown(), diags
	}

	netmaskVal, ok := netmaskAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`netmask expected to be basetypes.StringValue, was: %T`, netmaskAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewNode1ValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	useMgmtVrfAttribute, ok := attributes["use_mgmt_vrf"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`use_mgmt_vrf is missing from object`)

		return NewNode1ValueUnknown(), diags
	}

	useMgmtVrfVal, ok := useMgmtVrfAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`use_mgmt_vrf expected to be basetypes.BoolValue, was: %T`, useMgmtVrfAttribute))
	}

	useMgmtVrfForHostOutAttribute, ok := attributes["use_mgmt_vrf_for_host_out"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`use_mgmt_vrf_for_host_out is missing from object`)

		return NewNode1ValueUnknown(), diags
	}

	useMgmtVrfForHostOutVal, ok := useMgmtVrfForHostOutAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`use_mgmt_vrf_for_host_out expected to be basetypes.BoolValue, was: %T`, useMgmtVrfForHostOutAttribute))
	}

	vlanIdAttribute, ok := attributes["vlan_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan_id is missing from object`)

		return NewNode1ValueUnknown(), diags
	}

	vlanIdVal, ok := vlanIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan_id expected to be basetypes.StringValue, was: %T`, vlanIdAttribute))
	}

	if diags.HasError() {
		return NewNode1ValueUnknown(), diags
	}

	return Node1Value{
		Gateway:              gatewayVal,
		Ip:                   ipVal,
		Netmask:              netmaskVal,
		Node1Type:            typeVal,
		UseMgmtVrf:           useMgmtVrfVal,
		UseMgmtVrfForHostOut: useMgmtVrfForHostOutVal,
		VlanId:               vlanIdVal,
		state:                attr.ValueStateKnown,
	}, diags
}

func NewNode1ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Node1Value {
	object, diags := NewNode1Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewNode1ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Node1Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewNode1ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewNode1ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewNode1ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewNode1ValueMust(Node1Value{}.AttributeTypes(ctx), attributes), nil
}

func (t Node1Type) ValueType(ctx context.Context) attr.Value {
	return Node1Value{}
}

var _ basetypes.ObjectValuable = Node1Value{}

type Node1Value struct {
	Gateway              basetypes.StringValue `tfsdk:"gateway"`
	Ip                   basetypes.StringValue `tfsdk:"ip"`
	Netmask              basetypes.StringValue `tfsdk:"netmask"`
	Node1Type            basetypes.StringValue `tfsdk:"type"`
	UseMgmtVrf           basetypes.BoolValue   `tfsdk:"use_mgmt_vrf"`
	UseMgmtVrfForHostOut basetypes.BoolValue   `tfsdk:"use_mgmt_vrf_for_host_out"`
	VlanId               basetypes.StringValue `tfsdk:"vlan_id"`
	state                attr.ValueState
}

func (v Node1Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 7)

	var val tftypes.Value
	var err error

	attrTypes["gateway"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ip"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["netmask"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["use_mgmt_vrf"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["use_mgmt_vrf_for_host_out"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["vlan_id"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 7)

		val, err = v.Gateway.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["gateway"] = val

		val, err = v.Ip.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip"] = val

		val, err = v.Netmask.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["netmask"] = val

		val, err = v.Node1Type.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		val, err = v.UseMgmtVrf.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["use_mgmt_vrf"] = val

		val, err = v.UseMgmtVrfForHostOut.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["use_mgmt_vrf_for_host_out"] = val

		val, err = v.VlanId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vlan_id"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Node1Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Node1Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Node1Value) String() string {
	return "Node1Value"
}

func (v Node1Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"gateway":                   basetypes.StringType{},
		"ip":                        basetypes.StringType{},
		"netmask":                   basetypes.StringType{},
		"type":                      basetypes.StringType{},
		"use_mgmt_vrf":              basetypes.BoolType{},
		"use_mgmt_vrf_for_host_out": basetypes.BoolType{},
		"vlan_id":                   basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"gateway":                   v.Gateway,
			"ip":                        v.Ip,
			"netmask":                   v.Netmask,
			"type":                      v.Node1Type,
			"use_mgmt_vrf":              v.UseMgmtVrf,
			"use_mgmt_vrf_for_host_out": v.UseMgmtVrfForHostOut,
			"vlan_id":                   v.VlanId,
		})

	return objVal, diags
}

func (v Node1Value) Equal(o attr.Value) bool {
	other, ok := o.(Node1Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Gateway.Equal(other.Gateway) {
		return false
	}

	if !v.Ip.Equal(other.Ip) {
		return false
	}

	if !v.Netmask.Equal(other.Netmask) {
		return false
	}

	if !v.Node1Type.Equal(other.Node1Type) {
		return false
	}

	if !v.UseMgmtVrf.Equal(other.UseMgmtVrf) {
		return false
	}

	if !v.UseMgmtVrfForHostOut.Equal(other.UseMgmtVrfForHostOut) {
		return false
	}

	if !v.VlanId.Equal(other.VlanId) {
		return false
	}

	return true
}

func (v Node1Value) Type(ctx context.Context) attr.Type {
	return Node1Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Node1Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"gateway":                   basetypes.StringType{},
		"ip":                        basetypes.StringType{},
		"netmask":                   basetypes.StringType{},
		"type":                      basetypes.StringType{},
		"use_mgmt_vrf":              basetypes.BoolType{},
		"use_mgmt_vrf_for_host_out": basetypes.BoolType{},
		"vlan_id":                   basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = PathPreferencesType{}

type PathPreferencesType struct {
	basetypes.ObjectType
}

func (t PathPreferencesType) Equal(o attr.Type) bool {
	other, ok := o.(PathPreferencesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PathPreferencesType) String() string {
	return "PathPreferencesType"
}

func (t PathPreferencesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	pathsAttribute, ok := attributes["paths"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`paths is missing from object`)

		return nil, diags
	}

	pathsVal, ok := pathsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`paths expected to be basetypes.ListValue, was: %T`, pathsAttribute))
	}

	strategyAttribute, ok := attributes["strategy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`strategy is missing from object`)

		return nil, diags
	}

	strategyVal, ok := strategyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`strategy expected to be basetypes.StringValue, was: %T`, strategyAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PathPreferencesValue{
		Paths:    pathsVal,
		Strategy: strategyVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewPathPreferencesValueNull() PathPreferencesValue {
	return PathPreferencesValue{
		state: attr.ValueStateNull,
	}
}

func NewPathPreferencesValueUnknown() PathPreferencesValue {
	return PathPreferencesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPathPreferencesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PathPreferencesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PathPreferencesValue Attribute Value",
				"While creating a PathPreferencesValue value, a missing attribute value was detected. "+
					"A PathPreferencesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PathPreferencesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PathPreferencesValue Attribute Type",
				"While creating a PathPreferencesValue value, an invalid attribute value was detected. "+
					"A PathPreferencesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PathPreferencesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PathPreferencesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PathPreferencesValue Attribute Value",
				"While creating a PathPreferencesValue value, an extra attribute value was detected. "+
					"A PathPreferencesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PathPreferencesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPathPreferencesValueUnknown(), diags
	}

	pathsAttribute, ok := attributes["paths"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`paths is missing from object`)

		return NewPathPreferencesValueUnknown(), diags
	}

	pathsVal, ok := pathsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`paths expected to be basetypes.ListValue, was: %T`, pathsAttribute))
	}

	strategyAttribute, ok := attributes["strategy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`strategy is missing from object`)

		return NewPathPreferencesValueUnknown(), diags
	}

	strategyVal, ok := strategyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`strategy expected to be basetypes.StringValue, was: %T`, strategyAttribute))
	}

	if diags.HasError() {
		return NewPathPreferencesValueUnknown(), diags
	}

	return PathPreferencesValue{
		Paths:    pathsVal,
		Strategy: strategyVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewPathPreferencesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PathPreferencesValue {
	object, diags := NewPathPreferencesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPathPreferencesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PathPreferencesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPathPreferencesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPathPreferencesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPathPreferencesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPathPreferencesValueMust(PathPreferencesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PathPreferencesType) ValueType(ctx context.Context) attr.Value {
	return PathPreferencesValue{}
}

var _ basetypes.ObjectValuable = PathPreferencesValue{}

type PathPreferencesValue struct {
	Paths    basetypes.ListValue   `tfsdk:"paths"`
	Strategy basetypes.StringValue `tfsdk:"strategy"`
	state    attr.ValueState
}

func (v PathPreferencesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["paths"] = basetypes.ListType{
		ElemType: PathsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["strategy"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Paths.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["paths"] = val

		val, err = v.Strategy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["strategy"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PathPreferencesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PathPreferencesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PathPreferencesValue) String() string {
	return "PathPreferencesValue"
}

func (v PathPreferencesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	paths := types.ListValueMust(
		PathsType{
			basetypes.ObjectType{
				AttrTypes: PathsValue{}.AttributeTypes(ctx),
			},
		},
		v.Paths.Elements(),
	)

	if v.Paths.IsNull() {
		paths = types.ListNull(
			PathsType{
				basetypes.ObjectType{
					AttrTypes: PathsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Paths.IsUnknown() {
		paths = types.ListUnknown(
			PathsType{
				basetypes.ObjectType{
					AttrTypes: PathsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"paths": basetypes.ListType{
			ElemType: PathsValue{}.Type(ctx),
		},
		"strategy": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"paths":    paths,
			"strategy": v.Strategy,
		})

	return objVal, diags
}

func (v PathPreferencesValue) Equal(o attr.Value) bool {
	other, ok := o.(PathPreferencesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Paths.Equal(other.Paths) {
		return false
	}

	if !v.Strategy.Equal(other.Strategy) {
		return false
	}

	return true
}

func (v PathPreferencesValue) Type(ctx context.Context) attr.Type {
	return PathPreferencesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PathPreferencesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"paths": basetypes.ListType{
			ElemType: PathsValue{}.Type(ctx),
		},
		"strategy": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = PathsType{}

type PathsType struct {
	basetypes.ObjectType
}

func (t PathsType) Equal(o attr.Type) bool {
	other, ok := o.(PathsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PathsType) String() string {
	return "PathsType"
}

func (t PathsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	costAttribute, ok := attributes["cost"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cost is missing from object`)

		return nil, diags
	}

	costVal, ok := costAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cost expected to be basetypes.Int64Value, was: %T`, costAttribute))
	}

	disabledAttribute, ok := attributes["disabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disabled is missing from object`)

		return nil, diags
	}

	disabledVal, ok := disabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disabled expected to be basetypes.BoolValue, was: %T`, disabledAttribute))
	}

	gatewayIpAttribute, ok := attributes["gateway_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gateway_ip is missing from object`)

		return nil, diags
	}

	gatewayIpVal, ok := gatewayIpAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gateway_ip expected to be basetypes.StringValue, was: %T`, gatewayIpAttribute))
	}

	internetAccessAttribute, ok := attributes["internet_access"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`internet_access is missing from object`)

		return nil, diags
	}

	internetAccessVal, ok := internetAccessAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`internet_access expected to be basetypes.BoolValue, was: %T`, internetAccessAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	networksAttribute, ok := attributes["networks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`networks is missing from object`)

		return nil, diags
	}

	networksVal, ok := networksAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`networks expected to be basetypes.ListValue, was: %T`, networksAttribute))
	}

	targetIpsAttribute, ok := attributes["target_ips"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`target_ips is missing from object`)

		return nil, diags
	}

	targetIpsVal, ok := targetIpsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`target_ips expected to be basetypes.ListValue, was: %T`, targetIpsAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	wanNameAttribute, ok := attributes["wan_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wan_name is missing from object`)

		return nil, diags
	}

	wanNameVal, ok := wanNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wan_name expected to be basetypes.StringValue, was: %T`, wanNameAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PathsValue{
		Cost:           costVal,
		Disabled:       disabledVal,
		GatewayIp:      gatewayIpVal,
		InternetAccess: internetAccessVal,
		Name:           nameVal,
		Networks:       networksVal,
		TargetIps:      targetIpsVal,
		PathsType:      typeVal,
		WanName:        wanNameVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewPathsValueNull() PathsValue {
	return PathsValue{
		state: attr.ValueStateNull,
	}
}

func NewPathsValueUnknown() PathsValue {
	return PathsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPathsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PathsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PathsValue Attribute Value",
				"While creating a PathsValue value, a missing attribute value was detected. "+
					"A PathsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PathsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PathsValue Attribute Type",
				"While creating a PathsValue value, an invalid attribute value was detected. "+
					"A PathsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PathsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PathsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PathsValue Attribute Value",
				"While creating a PathsValue value, an extra attribute value was detected. "+
					"A PathsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PathsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPathsValueUnknown(), diags
	}

	costAttribute, ok := attributes["cost"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cost is missing from object`)

		return NewPathsValueUnknown(), diags
	}

	costVal, ok := costAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cost expected to be basetypes.Int64Value, was: %T`, costAttribute))
	}

	disabledAttribute, ok := attributes["disabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disabled is missing from object`)

		return NewPathsValueUnknown(), diags
	}

	disabledVal, ok := disabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disabled expected to be basetypes.BoolValue, was: %T`, disabledAttribute))
	}

	gatewayIpAttribute, ok := attributes["gateway_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gateway_ip is missing from object`)

		return NewPathsValueUnknown(), diags
	}

	gatewayIpVal, ok := gatewayIpAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gateway_ip expected to be basetypes.StringValue, was: %T`, gatewayIpAttribute))
	}

	internetAccessAttribute, ok := attributes["internet_access"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`internet_access is missing from object`)

		return NewPathsValueUnknown(), diags
	}

	internetAccessVal, ok := internetAccessAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`internet_access expected to be basetypes.BoolValue, was: %T`, internetAccessAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewPathsValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	networksAttribute, ok := attributes["networks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`networks is missing from object`)

		return NewPathsValueUnknown(), diags
	}

	networksVal, ok := networksAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`networks expected to be basetypes.ListValue, was: %T`, networksAttribute))
	}

	targetIpsAttribute, ok := attributes["target_ips"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`target_ips is missing from object`)

		return NewPathsValueUnknown(), diags
	}

	targetIpsVal, ok := targetIpsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`target_ips expected to be basetypes.ListValue, was: %T`, targetIpsAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewPathsValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	wanNameAttribute, ok := attributes["wan_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wan_name is missing from object`)

		return NewPathsValueUnknown(), diags
	}

	wanNameVal, ok := wanNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wan_name expected to be basetypes.StringValue, was: %T`, wanNameAttribute))
	}

	if diags.HasError() {
		return NewPathsValueUnknown(), diags
	}

	return PathsValue{
		Cost:           costVal,
		Disabled:       disabledVal,
		GatewayIp:      gatewayIpVal,
		InternetAccess: internetAccessVal,
		Name:           nameVal,
		Networks:       networksVal,
		TargetIps:      targetIpsVal,
		PathsType:      typeVal,
		WanName:        wanNameVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewPathsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PathsValue {
	object, diags := NewPathsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPathsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PathsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPathsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPathsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPathsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPathsValueMust(PathsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PathsType) ValueType(ctx context.Context) attr.Value {
	return PathsValue{}
}

var _ basetypes.ObjectValuable = PathsValue{}

type PathsValue struct {
	Cost           basetypes.Int64Value  `tfsdk:"cost"`
	Disabled       basetypes.BoolValue   `tfsdk:"disabled"`
	GatewayIp      basetypes.StringValue `tfsdk:"gateway_ip"`
	InternetAccess basetypes.BoolValue   `tfsdk:"internet_access"`
	Name           basetypes.StringValue `tfsdk:"name"`
	Networks       basetypes.ListValue   `tfsdk:"networks"`
	TargetIps      basetypes.ListValue   `tfsdk:"target_ips"`
	PathsType      basetypes.StringValue `tfsdk:"type"`
	WanName        basetypes.StringValue `tfsdk:"wan_name"`
	state          attr.ValueState
}

func (v PathsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 9)

	var val tftypes.Value
	var err error

	attrTypes["cost"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["disabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["gateway_ip"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["internet_access"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["networks"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["target_ips"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["wan_name"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 9)

		val, err = v.Cost.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cost"] = val

		val, err = v.Disabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["disabled"] = val

		val, err = v.GatewayIp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["gateway_ip"] = val

		val, err = v.InternetAccess.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["internet_access"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Networks.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["networks"] = val

		val, err = v.TargetIps.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["target_ips"] = val

		val, err = v.PathsType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		val, err = v.WanName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["wan_name"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PathsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PathsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PathsValue) String() string {
	return "PathsValue"
}

func (v PathsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var networksVal basetypes.ListValue
	switch {
	case v.Networks.IsUnknown():
		networksVal = types.ListUnknown(types.StringType)
	case v.Networks.IsNull():
		networksVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		networksVal, d = types.ListValue(types.StringType, v.Networks.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"cost":            basetypes.Int64Type{},
			"disabled":        basetypes.BoolType{},
			"gateway_ip":      basetypes.StringType{},
			"internet_access": basetypes.BoolType{},
			"name":            basetypes.StringType{},
			"networks": basetypes.ListType{
				ElemType: types.StringType,
			},
			"target_ips": basetypes.ListType{
				ElemType: types.StringType,
			},
			"type":     basetypes.StringType{},
			"wan_name": basetypes.StringType{},
		}), diags
	}

	var targetIpsVal basetypes.ListValue
	switch {
	case v.TargetIps.IsUnknown():
		targetIpsVal = types.ListUnknown(types.StringType)
	case v.TargetIps.IsNull():
		targetIpsVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		targetIpsVal, d = types.ListValue(types.StringType, v.TargetIps.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"cost":            basetypes.Int64Type{},
			"disabled":        basetypes.BoolType{},
			"gateway_ip":      basetypes.StringType{},
			"internet_access": basetypes.BoolType{},
			"name":            basetypes.StringType{},
			"networks": basetypes.ListType{
				ElemType: types.StringType,
			},
			"target_ips": basetypes.ListType{
				ElemType: types.StringType,
			},
			"type":     basetypes.StringType{},
			"wan_name": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"cost":            basetypes.Int64Type{},
		"disabled":        basetypes.BoolType{},
		"gateway_ip":      basetypes.StringType{},
		"internet_access": basetypes.BoolType{},
		"name":            basetypes.StringType{},
		"networks": basetypes.ListType{
			ElemType: types.StringType,
		},
		"target_ips": basetypes.ListType{
			ElemType: types.StringType,
		},
		"type":     basetypes.StringType{},
		"wan_name": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"cost":            v.Cost,
			"disabled":        v.Disabled,
			"gateway_ip":      v.GatewayIp,
			"internet_access": v.InternetAccess,
			"name":            v.Name,
			"networks":        networksVal,
			"target_ips":      targetIpsVal,
			"type":            v.PathsType,
			"wan_name":        v.WanName,
		})

	return objVal, diags
}

func (v PathsValue) Equal(o attr.Value) bool {
	other, ok := o.(PathsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Cost.Equal(other.Cost) {
		return false
	}

	if !v.Disabled.Equal(other.Disabled) {
		return false
	}

	if !v.GatewayIp.Equal(other.GatewayIp) {
		return false
	}

	if !v.InternetAccess.Equal(other.InternetAccess) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Networks.Equal(other.Networks) {
		return false
	}

	if !v.TargetIps.Equal(other.TargetIps) {
		return false
	}

	if !v.PathsType.Equal(other.PathsType) {
		return false
	}

	if !v.WanName.Equal(other.WanName) {
		return false
	}

	return true
}

func (v PathsValue) Type(ctx context.Context) attr.Type {
	return PathsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PathsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"cost":            basetypes.Int64Type{},
		"disabled":        basetypes.BoolType{},
		"gateway_ip":      basetypes.StringType{},
		"internet_access": basetypes.BoolType{},
		"name":            basetypes.StringType{},
		"networks": basetypes.ListType{
			ElemType: types.StringType,
		},
		"target_ips": basetypes.ListType{
			ElemType: types.StringType,
		},
		"type":     basetypes.StringType{},
		"wan_name": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = PortConfigType{}

type PortConfigType struct {
	basetypes.ObjectType
}

func (t PortConfigType) Equal(o attr.Type) bool {
	other, ok := o.(PortConfigType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PortConfigType) String() string {
	return "PortConfigType"
}

func (t PortConfigType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	aeDisableLacpAttribute, ok := attributes["ae_disable_lacp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ae_disable_lacp is missing from object`)

		return nil, diags
	}

	aeDisableLacpVal, ok := aeDisableLacpAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ae_disable_lacp expected to be basetypes.BoolValue, was: %T`, aeDisableLacpAttribute))
	}

	aeIdxAttribute, ok := attributes["ae_idx"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ae_idx is missing from object`)

		return nil, diags
	}

	aeIdxVal, ok := aeIdxAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ae_idx expected to be basetypes.StringValue, was: %T`, aeIdxAttribute))
	}

	aeLacpForceUpAttribute, ok := attributes["ae_lacp_force_up"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ae_lacp_force_up is missing from object`)

		return nil, diags
	}

	aeLacpForceUpVal, ok := aeLacpForceUpAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ae_lacp_force_up expected to be basetypes.BoolValue, was: %T`, aeLacpForceUpAttribute))
	}

	aggregatedAttribute, ok := attributes["aggregated"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`aggregated is missing from object`)

		return nil, diags
	}

	aggregatedVal, ok := aggregatedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`aggregated expected to be basetypes.BoolValue, was: %T`, aggregatedAttribute))
	}

	criticalAttribute, ok := attributes["critical"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`critical is missing from object`)

		return nil, diags
	}

	criticalVal, ok := criticalAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`critical expected to be basetypes.BoolValue, was: %T`, criticalAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return nil, diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	disableAutonegAttribute, ok := attributes["disable_autoneg"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disable_autoneg is missing from object`)

		return nil, diags
	}

	disableAutonegVal, ok := disableAutonegAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disable_autoneg expected to be basetypes.BoolValue, was: %T`, disableAutonegAttribute))
	}

	disabledAttribute, ok := attributes["disabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disabled is missing from object`)

		return nil, diags
	}

	disabledVal, ok := disabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disabled expected to be basetypes.BoolValue, was: %T`, disabledAttribute))
	}

	dslTypeAttribute, ok := attributes["dsl_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dsl_type is missing from object`)

		return nil, diags
	}

	dslTypeVal, ok := dslTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dsl_type expected to be basetypes.StringValue, was: %T`, dslTypeAttribute))
	}

	dslVciAttribute, ok := attributes["dsl_vci"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dsl_vci is missing from object`)

		return nil, diags
	}

	dslVciVal, ok := dslVciAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dsl_vci expected to be basetypes.Int64Value, was: %T`, dslVciAttribute))
	}

	dslVpiAttribute, ok := attributes["dsl_vpi"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dsl_vpi is missing from object`)

		return nil, diags
	}

	dslVpiVal, ok := dslVpiAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dsl_vpi expected to be basetypes.Int64Value, was: %T`, dslVpiAttribute))
	}

	duplexAttribute, ok := attributes["duplex"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`duplex is missing from object`)

		return nil, diags
	}

	duplexVal, ok := duplexAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`duplex expected to be basetypes.StringValue, was: %T`, duplexAttribute))
	}

	lteApnAttribute, ok := attributes["lte_apn"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lte_apn is missing from object`)

		return nil, diags
	}

	lteApnVal, ok := lteApnAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lte_apn expected to be basetypes.StringValue, was: %T`, lteApnAttribute))
	}

	lteAuthAttribute, ok := attributes["lte_auth"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lte_auth is missing from object`)

		return nil, diags
	}

	lteAuthVal, ok := lteAuthAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lte_auth expected to be basetypes.StringValue, was: %T`, lteAuthAttribute))
	}

	lteBackupAttribute, ok := attributes["lte_backup"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lte_backup is missing from object`)

		return nil, diags
	}

	lteBackupVal, ok := lteBackupAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lte_backup expected to be basetypes.BoolValue, was: %T`, lteBackupAttribute))
	}

	ltePasswordAttribute, ok := attributes["lte_password"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lte_password is missing from object`)

		return nil, diags
	}

	ltePasswordVal, ok := ltePasswordAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lte_password expected to be basetypes.StringValue, was: %T`, ltePasswordAttribute))
	}

	lteUsernameAttribute, ok := attributes["lte_username"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lte_username is missing from object`)

		return nil, diags
	}

	lteUsernameVal, ok := lteUsernameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lte_username expected to be basetypes.StringValue, was: %T`, lteUsernameAttribute))
	}

	mtuAttribute, ok := attributes["mtu"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mtu is missing from object`)

		return nil, diags
	}

	mtuVal, ok := mtuAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mtu expected to be basetypes.Int64Value, was: %T`, mtuAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	networksAttribute, ok := attributes["networks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`networks is missing from object`)

		return nil, diags
	}

	networksVal, ok := networksAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`networks expected to be basetypes.ListValue, was: %T`, networksAttribute))
	}

	outerVlanIdAttribute, ok := attributes["outer_vlan_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`outer_vlan_id is missing from object`)

		return nil, diags
	}

	outerVlanIdVal, ok := outerVlanIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`outer_vlan_id expected to be basetypes.Int64Value, was: %T`, outerVlanIdAttribute))
	}

	poeDisabledAttribute, ok := attributes["poe_disabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`poe_disabled is missing from object`)

		return nil, diags
	}

	poeDisabledVal, ok := poeDisabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`poe_disabled expected to be basetypes.BoolValue, was: %T`, poeDisabledAttribute))
	}

	portIpConfigAttribute, ok := attributes["ip_config"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_config is missing from object`)

		return nil, diags
	}

	portIpConfigVal, ok := portIpConfigAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_config expected to be basetypes.ObjectValue, was: %T`, portIpConfigAttribute))
	}

	portNetworkAttribute, ok := attributes["port_network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_network is missing from object`)

		return nil, diags
	}

	portNetworkVal, ok := portNetworkAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_network expected to be basetypes.StringValue, was: %T`, portNetworkAttribute))
	}

	preserveDscpAttribute, ok := attributes["preserve_dscp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`preserve_dscp is missing from object`)

		return nil, diags
	}

	preserveDscpVal, ok := preserveDscpAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`preserve_dscp expected to be basetypes.BoolValue, was: %T`, preserveDscpAttribute))
	}

	redundantAttribute, ok := attributes["redundant"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`redundant is missing from object`)

		return nil, diags
	}

	redundantVal, ok := redundantAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`redundant expected to be basetypes.BoolValue, was: %T`, redundantAttribute))
	}

	redundantGroupAttribute, ok := attributes["redundant_group"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`redundant_group is missing from object`)

		return nil, diags
	}

	redundantGroupVal, ok := redundantGroupAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`redundant_group expected to be basetypes.Int64Value, was: %T`, redundantGroupAttribute))
	}

	rethIdxAttribute, ok := attributes["reth_idx"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`reth_idx is missing from object`)

		return nil, diags
	}

	rethIdxVal, ok := rethIdxAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`reth_idx expected to be basetypes.StringValue, was: %T`, rethIdxAttribute))
	}

	rethNodeAttribute, ok := attributes["reth_node"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`reth_node is missing from object`)

		return nil, diags
	}

	rethNodeVal, ok := rethNodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`reth_node expected to be basetypes.StringValue, was: %T`, rethNodeAttribute))
	}

	rethNodesAttribute, ok := attributes["reth_nodes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`reth_nodes is missing from object`)

		return nil, diags
	}

	rethNodesVal, ok := rethNodesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`reth_nodes expected to be basetypes.ListValue, was: %T`, rethNodesAttribute))
	}

	speedAttribute, ok := attributes["speed"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`speed is missing from object`)

		return nil, diags
	}

	speedVal, ok := speedAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`speed expected to be basetypes.StringValue, was: %T`, speedAttribute))
	}

	ssrNoVirtualMacAttribute, ok := attributes["ssr_no_virtual_mac"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ssr_no_virtual_mac is missing from object`)

		return nil, diags
	}

	ssrNoVirtualMacVal, ok := ssrNoVirtualMacAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ssr_no_virtual_mac expected to be basetypes.BoolValue, was: %T`, ssrNoVirtualMacAttribute))
	}

	svrPortRangeAttribute, ok := attributes["svr_port_range"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`svr_port_range is missing from object`)

		return nil, diags
	}

	svrPortRangeVal, ok := svrPortRangeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`svr_port_range expected to be basetypes.StringValue, was: %T`, svrPortRangeAttribute))
	}

	trafficShapingAttribute, ok := attributes["traffic_shaping"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`traffic_shaping is missing from object`)

		return nil, diags
	}

	trafficShapingVal, ok := trafficShapingAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`traffic_shaping expected to be basetypes.ObjectValue, was: %T`, trafficShapingAttribute))
	}

	usageAttribute, ok := attributes["usage"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`usage is missing from object`)

		return nil, diags
	}

	usageVal, ok := usageAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`usage expected to be basetypes.StringValue, was: %T`, usageAttribute))
	}

	vlanIdAttribute, ok := attributes["vlan_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan_id is missing from object`)

		return nil, diags
	}

	vlanIdVal, ok := vlanIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan_id expected to be basetypes.StringValue, was: %T`, vlanIdAttribute))
	}

	vpnPathsAttribute, ok := attributes["vpn_paths"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vpn_paths is missing from object`)

		return nil, diags
	}

	vpnPathsVal, ok := vpnPathsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vpn_paths expected to be basetypes.MapValue, was: %T`, vpnPathsAttribute))
	}

	wanArpPolicerAttribute, ok := attributes["wan_arp_policer"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wan_arp_policer is missing from object`)

		return nil, diags
	}

	wanArpPolicerVal, ok := wanArpPolicerAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wan_arp_policer expected to be basetypes.StringValue, was: %T`, wanArpPolicerAttribute))
	}

	wanExtIpAttribute, ok := attributes["wan_ext_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wan_ext_ip is missing from object`)

		return nil, diags
	}

	wanExtIpVal, ok := wanExtIpAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wan_ext_ip expected to be basetypes.StringValue, was: %T`, wanExtIpAttribute))
	}

	wanExtraRoutesAttribute, ok := attributes["wan_extra_routes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wan_extra_routes is missing from object`)

		return nil, diags
	}

	wanExtraRoutesVal, ok := wanExtraRoutesAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wan_extra_routes expected to be basetypes.MapValue, was: %T`, wanExtraRoutesAttribute))
	}

	wanNetworksAttribute, ok := attributes["wan_networks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wan_networks is missing from object`)

		return nil, diags
	}

	wanNetworksVal, ok := wanNetworksAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wan_networks expected to be basetypes.ListValue, was: %T`, wanNetworksAttribute))
	}

	wanProbeOverrideAttribute, ok := attributes["wan_probe_override"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wan_probe_override is missing from object`)

		return nil, diags
	}

	wanProbeOverrideVal, ok := wanProbeOverrideAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wan_probe_override expected to be basetypes.ObjectValue, was: %T`, wanProbeOverrideAttribute))
	}

	wanSourceNatAttribute, ok := attributes["wan_source_nat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wan_source_nat is missing from object`)

		return nil, diags
	}

	wanSourceNatVal, ok := wanSourceNatAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wan_source_nat expected to be basetypes.ObjectValue, was: %T`, wanSourceNatAttribute))
	}

	wanTypeAttribute, ok := attributes["wan_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wan_type is missing from object`)

		return nil, diags
	}

	wanTypeVal, ok := wanTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wan_type expected to be basetypes.StringValue, was: %T`, wanTypeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PortConfigValue{
		AeDisableLacp:    aeDisableLacpVal,
		AeIdx:            aeIdxVal,
		AeLacpForceUp:    aeLacpForceUpVal,
		Aggregated:       aggregatedVal,
		Critical:         criticalVal,
		Description:      descriptionVal,
		DisableAutoneg:   disableAutonegVal,
		Disabled:         disabledVal,
		DslType:          dslTypeVal,
		DslVci:           dslVciVal,
		DslVpi:           dslVpiVal,
		Duplex:           duplexVal,
		LteApn:           lteApnVal,
		LteAuth:          lteAuthVal,
		LteBackup:        lteBackupVal,
		LtePassword:      ltePasswordVal,
		LteUsername:      lteUsernameVal,
		Mtu:              mtuVal,
		Name:             nameVal,
		Networks:         networksVal,
		OuterVlanId:      outerVlanIdVal,
		PoeDisabled:      poeDisabledVal,
		PortIpConfig:     portIpConfigVal,
		PortNetwork:      portNetworkVal,
		PreserveDscp:     preserveDscpVal,
		Redundant:        redundantVal,
		RedundantGroup:   redundantGroupVal,
		RethIdx:          rethIdxVal,
		RethNode:         rethNodeVal,
		RethNodes:        rethNodesVal,
		Speed:            speedVal,
		SsrNoVirtualMac:  ssrNoVirtualMacVal,
		SvrPortRange:     svrPortRangeVal,
		TrafficShaping:   trafficShapingVal,
		Usage:            usageVal,
		VlanId:           vlanIdVal,
		VpnPaths:         vpnPathsVal,
		WanArpPolicer:    wanArpPolicerVal,
		WanExtIp:         wanExtIpVal,
		WanExtraRoutes:   wanExtraRoutesVal,
		WanNetworks:      wanNetworksVal,
		WanProbeOverride: wanProbeOverrideVal,
		WanSourceNat:     wanSourceNatVal,
		WanType:          wanTypeVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewPortConfigValueNull() PortConfigValue {
	return PortConfigValue{
		state: attr.ValueStateNull,
	}
}

func NewPortConfigValueUnknown() PortConfigValue {
	return PortConfigValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPortConfigValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PortConfigValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PortConfigValue Attribute Value",
				"While creating a PortConfigValue value, a missing attribute value was detected. "+
					"A PortConfigValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PortConfigValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PortConfigValue Attribute Type",
				"While creating a PortConfigValue value, an invalid attribute value was detected. "+
					"A PortConfigValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PortConfigValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PortConfigValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PortConfigValue Attribute Value",
				"While creating a PortConfigValue value, an extra attribute value was detected. "+
					"A PortConfigValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PortConfigValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPortConfigValueUnknown(), diags
	}

	aeDisableLacpAttribute, ok := attributes["ae_disable_lacp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ae_disable_lacp is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	aeDisableLacpVal, ok := aeDisableLacpAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ae_disable_lacp expected to be basetypes.BoolValue, was: %T`, aeDisableLacpAttribute))
	}

	aeIdxAttribute, ok := attributes["ae_idx"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ae_idx is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	aeIdxVal, ok := aeIdxAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ae_idx expected to be basetypes.StringValue, was: %T`, aeIdxAttribute))
	}

	aeLacpForceUpAttribute, ok := attributes["ae_lacp_force_up"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ae_lacp_force_up is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	aeLacpForceUpVal, ok := aeLacpForceUpAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ae_lacp_force_up expected to be basetypes.BoolValue, was: %T`, aeLacpForceUpAttribute))
	}

	aggregatedAttribute, ok := attributes["aggregated"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`aggregated is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	aggregatedVal, ok := aggregatedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`aggregated expected to be basetypes.BoolValue, was: %T`, aggregatedAttribute))
	}

	criticalAttribute, ok := attributes["critical"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`critical is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	criticalVal, ok := criticalAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`critical expected to be basetypes.BoolValue, was: %T`, criticalAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	disableAutonegAttribute, ok := attributes["disable_autoneg"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disable_autoneg is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	disableAutonegVal, ok := disableAutonegAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disable_autoneg expected to be basetypes.BoolValue, was: %T`, disableAutonegAttribute))
	}

	disabledAttribute, ok := attributes["disabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disabled is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	disabledVal, ok := disabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disabled expected to be basetypes.BoolValue, was: %T`, disabledAttribute))
	}

	dslTypeAttribute, ok := attributes["dsl_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dsl_type is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	dslTypeVal, ok := dslTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dsl_type expected to be basetypes.StringValue, was: %T`, dslTypeAttribute))
	}

	dslVciAttribute, ok := attributes["dsl_vci"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dsl_vci is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	dslVciVal, ok := dslVciAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dsl_vci expected to be basetypes.Int64Value, was: %T`, dslVciAttribute))
	}

	dslVpiAttribute, ok := attributes["dsl_vpi"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dsl_vpi is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	dslVpiVal, ok := dslVpiAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dsl_vpi expected to be basetypes.Int64Value, was: %T`, dslVpiAttribute))
	}

	duplexAttribute, ok := attributes["duplex"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`duplex is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	duplexVal, ok := duplexAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`duplex expected to be basetypes.StringValue, was: %T`, duplexAttribute))
	}

	lteApnAttribute, ok := attributes["lte_apn"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lte_apn is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	lteApnVal, ok := lteApnAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lte_apn expected to be basetypes.StringValue, was: %T`, lteApnAttribute))
	}

	lteAuthAttribute, ok := attributes["lte_auth"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lte_auth is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	lteAuthVal, ok := lteAuthAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lte_auth expected to be basetypes.StringValue, was: %T`, lteAuthAttribute))
	}

	lteBackupAttribute, ok := attributes["lte_backup"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lte_backup is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	lteBackupVal, ok := lteBackupAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lte_backup expected to be basetypes.BoolValue, was: %T`, lteBackupAttribute))
	}

	ltePasswordAttribute, ok := attributes["lte_password"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lte_password is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	ltePasswordVal, ok := ltePasswordAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lte_password expected to be basetypes.StringValue, was: %T`, ltePasswordAttribute))
	}

	lteUsernameAttribute, ok := attributes["lte_username"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lte_username is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	lteUsernameVal, ok := lteUsernameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lte_username expected to be basetypes.StringValue, was: %T`, lteUsernameAttribute))
	}

	mtuAttribute, ok := attributes["mtu"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mtu is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	mtuVal, ok := mtuAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mtu expected to be basetypes.Int64Value, was: %T`, mtuAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	networksAttribute, ok := attributes["networks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`networks is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	networksVal, ok := networksAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`networks expected to be basetypes.ListValue, was: %T`, networksAttribute))
	}

	outerVlanIdAttribute, ok := attributes["outer_vlan_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`outer_vlan_id is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	outerVlanIdVal, ok := outerVlanIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`outer_vlan_id expected to be basetypes.Int64Value, was: %T`, outerVlanIdAttribute))
	}

	poeDisabledAttribute, ok := attributes["poe_disabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`poe_disabled is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	poeDisabledVal, ok := poeDisabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`poe_disabled expected to be basetypes.BoolValue, was: %T`, poeDisabledAttribute))
	}

	portIpConfigAttribute, ok := attributes["ip_config"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_config is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	portIpConfigVal, ok := portIpConfigAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_config expected to be basetypes.ObjectValue, was: %T`, portIpConfigAttribute))
	}

	portNetworkAttribute, ok := attributes["port_network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_network is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	portNetworkVal, ok := portNetworkAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_network expected to be basetypes.StringValue, was: %T`, portNetworkAttribute))
	}

	preserveDscpAttribute, ok := attributes["preserve_dscp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`preserve_dscp is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	preserveDscpVal, ok := preserveDscpAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`preserve_dscp expected to be basetypes.BoolValue, was: %T`, preserveDscpAttribute))
	}

	redundantAttribute, ok := attributes["redundant"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`redundant is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	redundantVal, ok := redundantAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`redundant expected to be basetypes.BoolValue, was: %T`, redundantAttribute))
	}

	redundantGroupAttribute, ok := attributes["redundant_group"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`redundant_group is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	redundantGroupVal, ok := redundantGroupAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`redundant_group expected to be basetypes.Int64Value, was: %T`, redundantGroupAttribute))
	}

	rethIdxAttribute, ok := attributes["reth_idx"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`reth_idx is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	rethIdxVal, ok := rethIdxAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`reth_idx expected to be basetypes.StringValue, was: %T`, rethIdxAttribute))
	}

	rethNodeAttribute, ok := attributes["reth_node"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`reth_node is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	rethNodeVal, ok := rethNodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`reth_node expected to be basetypes.StringValue, was: %T`, rethNodeAttribute))
	}

	rethNodesAttribute, ok := attributes["reth_nodes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`reth_nodes is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	rethNodesVal, ok := rethNodesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`reth_nodes expected to be basetypes.ListValue, was: %T`, rethNodesAttribute))
	}

	speedAttribute, ok := attributes["speed"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`speed is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	speedVal, ok := speedAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`speed expected to be basetypes.StringValue, was: %T`, speedAttribute))
	}

	ssrNoVirtualMacAttribute, ok := attributes["ssr_no_virtual_mac"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ssr_no_virtual_mac is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	ssrNoVirtualMacVal, ok := ssrNoVirtualMacAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ssr_no_virtual_mac expected to be basetypes.BoolValue, was: %T`, ssrNoVirtualMacAttribute))
	}

	svrPortRangeAttribute, ok := attributes["svr_port_range"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`svr_port_range is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	svrPortRangeVal, ok := svrPortRangeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`svr_port_range expected to be basetypes.StringValue, was: %T`, svrPortRangeAttribute))
	}

	trafficShapingAttribute, ok := attributes["traffic_shaping"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`traffic_shaping is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	trafficShapingVal, ok := trafficShapingAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`traffic_shaping expected to be basetypes.ObjectValue, was: %T`, trafficShapingAttribute))
	}

	usageAttribute, ok := attributes["usage"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`usage is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	usageVal, ok := usageAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`usage expected to be basetypes.StringValue, was: %T`, usageAttribute))
	}

	vlanIdAttribute, ok := attributes["vlan_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan_id is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	vlanIdVal, ok := vlanIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan_id expected to be basetypes.StringValue, was: %T`, vlanIdAttribute))
	}

	vpnPathsAttribute, ok := attributes["vpn_paths"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vpn_paths is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	vpnPathsVal, ok := vpnPathsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vpn_paths expected to be basetypes.MapValue, was: %T`, vpnPathsAttribute))
	}

	wanArpPolicerAttribute, ok := attributes["wan_arp_policer"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wan_arp_policer is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	wanArpPolicerVal, ok := wanArpPolicerAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wan_arp_policer expected to be basetypes.StringValue, was: %T`, wanArpPolicerAttribute))
	}

	wanExtIpAttribute, ok := attributes["wan_ext_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wan_ext_ip is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	wanExtIpVal, ok := wanExtIpAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wan_ext_ip expected to be basetypes.StringValue, was: %T`, wanExtIpAttribute))
	}

	wanExtraRoutesAttribute, ok := attributes["wan_extra_routes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wan_extra_routes is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	wanExtraRoutesVal, ok := wanExtraRoutesAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wan_extra_routes expected to be basetypes.MapValue, was: %T`, wanExtraRoutesAttribute))
	}

	wanNetworksAttribute, ok := attributes["wan_networks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wan_networks is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	wanNetworksVal, ok := wanNetworksAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wan_networks expected to be basetypes.ListValue, was: %T`, wanNetworksAttribute))
	}

	wanProbeOverrideAttribute, ok := attributes["wan_probe_override"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wan_probe_override is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	wanProbeOverrideVal, ok := wanProbeOverrideAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wan_probe_override expected to be basetypes.ObjectValue, was: %T`, wanProbeOverrideAttribute))
	}

	wanSourceNatAttribute, ok := attributes["wan_source_nat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wan_source_nat is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	wanSourceNatVal, ok := wanSourceNatAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wan_source_nat expected to be basetypes.ObjectValue, was: %T`, wanSourceNatAttribute))
	}

	wanTypeAttribute, ok := attributes["wan_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wan_type is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	wanTypeVal, ok := wanTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wan_type expected to be basetypes.StringValue, was: %T`, wanTypeAttribute))
	}

	if diags.HasError() {
		return NewPortConfigValueUnknown(), diags
	}

	return PortConfigValue{
		AeDisableLacp:    aeDisableLacpVal,
		AeIdx:            aeIdxVal,
		AeLacpForceUp:    aeLacpForceUpVal,
		Aggregated:       aggregatedVal,
		Critical:         criticalVal,
		Description:      descriptionVal,
		DisableAutoneg:   disableAutonegVal,
		Disabled:         disabledVal,
		DslType:          dslTypeVal,
		DslVci:           dslVciVal,
		DslVpi:           dslVpiVal,
		Duplex:           duplexVal,
		LteApn:           lteApnVal,
		LteAuth:          lteAuthVal,
		LteBackup:        lteBackupVal,
		LtePassword:      ltePasswordVal,
		LteUsername:      lteUsernameVal,
		Mtu:              mtuVal,
		Name:             nameVal,
		Networks:         networksVal,
		OuterVlanId:      outerVlanIdVal,
		PoeDisabled:      poeDisabledVal,
		PortIpConfig:     portIpConfigVal,
		PortNetwork:      portNetworkVal,
		PreserveDscp:     preserveDscpVal,
		Redundant:        redundantVal,
		RedundantGroup:   redundantGroupVal,
		RethIdx:          rethIdxVal,
		RethNode:         rethNodeVal,
		RethNodes:        rethNodesVal,
		Speed:            speedVal,
		SsrNoVirtualMac:  ssrNoVirtualMacVal,
		SvrPortRange:     svrPortRangeVal,
		TrafficShaping:   trafficShapingVal,
		Usage:            usageVal,
		VlanId:           vlanIdVal,
		VpnPaths:         vpnPathsVal,
		WanArpPolicer:    wanArpPolicerVal,
		WanExtIp:         wanExtIpVal,
		WanExtraRoutes:   wanExtraRoutesVal,
		WanNetworks:      wanNetworksVal,
		WanProbeOverride: wanProbeOverrideVal,
		WanSourceNat:     wanSourceNatVal,
		WanType:          wanTypeVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewPortConfigValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PortConfigValue {
	object, diags := NewPortConfigValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPortConfigValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PortConfigType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPortConfigValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPortConfigValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPortConfigValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPortConfigValueMust(PortConfigValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PortConfigType) ValueType(ctx context.Context) attr.Value {
	return PortConfigValue{}
}

var _ basetypes.ObjectValuable = PortConfigValue{}

type PortConfigValue struct {
	AeDisableLacp    basetypes.BoolValue   `tfsdk:"ae_disable_lacp"`
	AeIdx            basetypes.StringValue `tfsdk:"ae_idx"`
	AeLacpForceUp    basetypes.BoolValue   `tfsdk:"ae_lacp_force_up"`
	Aggregated       basetypes.BoolValue   `tfsdk:"aggregated"`
	Critical         basetypes.BoolValue   `tfsdk:"critical"`
	Description      basetypes.StringValue `tfsdk:"description"`
	DisableAutoneg   basetypes.BoolValue   `tfsdk:"disable_autoneg"`
	Disabled         basetypes.BoolValue   `tfsdk:"disabled"`
	DslType          basetypes.StringValue `tfsdk:"dsl_type"`
	DslVci           basetypes.Int64Value  `tfsdk:"dsl_vci"`
	DslVpi           basetypes.Int64Value  `tfsdk:"dsl_vpi"`
	Duplex           basetypes.StringValue `tfsdk:"duplex"`
	LteApn           basetypes.StringValue `tfsdk:"lte_apn"`
	LteAuth          basetypes.StringValue `tfsdk:"lte_auth"`
	LteBackup        basetypes.BoolValue   `tfsdk:"lte_backup"`
	LtePassword      basetypes.StringValue `tfsdk:"lte_password"`
	LteUsername      basetypes.StringValue `tfsdk:"lte_username"`
	Mtu              basetypes.Int64Value  `tfsdk:"mtu"`
	Name             basetypes.StringValue `tfsdk:"name"`
	Networks         basetypes.ListValue   `tfsdk:"networks"`
	OuterVlanId      basetypes.Int64Value  `tfsdk:"outer_vlan_id"`
	PoeDisabled      basetypes.BoolValue   `tfsdk:"poe_disabled"`
	PortIpConfig     basetypes.ObjectValue `tfsdk:"ip_config"`
	PortNetwork      basetypes.StringValue `tfsdk:"port_network"`
	PreserveDscp     basetypes.BoolValue   `tfsdk:"preserve_dscp"`
	Redundant        basetypes.BoolValue   `tfsdk:"redundant"`
	RedundantGroup   basetypes.Int64Value  `tfsdk:"redundant_group"`
	RethIdx          basetypes.StringValue `tfsdk:"reth_idx"`
	RethNode         basetypes.StringValue `tfsdk:"reth_node"`
	RethNodes        basetypes.ListValue   `tfsdk:"reth_nodes"`
	Speed            basetypes.StringValue `tfsdk:"speed"`
	SsrNoVirtualMac  basetypes.BoolValue   `tfsdk:"ssr_no_virtual_mac"`
	SvrPortRange     basetypes.StringValue `tfsdk:"svr_port_range"`
	TrafficShaping   basetypes.ObjectValue `tfsdk:"traffic_shaping"`
	Usage            basetypes.StringValue `tfsdk:"usage"`
	VlanId           basetypes.StringValue `tfsdk:"vlan_id"`
	VpnPaths         basetypes.MapValue    `tfsdk:"vpn_paths"`
	WanArpPolicer    basetypes.StringValue `tfsdk:"wan_arp_policer"`
	WanExtIp         basetypes.StringValue `tfsdk:"wan_ext_ip"`
	WanExtraRoutes   basetypes.MapValue    `tfsdk:"wan_extra_routes"`
	WanNetworks      basetypes.ListValue   `tfsdk:"wan_networks"`
	WanProbeOverride basetypes.ObjectValue `tfsdk:"wan_probe_override"`
	WanSourceNat     basetypes.ObjectValue `tfsdk:"wan_source_nat"`
	WanType          basetypes.StringValue `tfsdk:"wan_type"`
	state            attr.ValueState
}

func (v PortConfigValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 44)

	var val tftypes.Value
	var err error

	attrTypes["ae_disable_lacp"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["ae_idx"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ae_lacp_force_up"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["aggregated"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["critical"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["disable_autoneg"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["disabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["dsl_type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["dsl_vci"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["dsl_vpi"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["duplex"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["lte_apn"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["lte_auth"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["lte_backup"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["lte_password"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["lte_username"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["mtu"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["networks"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["outer_vlan_id"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["poe_disabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["ip_config"] = basetypes.ObjectType{
		AttrTypes: PortIpConfigValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["port_network"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["preserve_dscp"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["redundant"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["redundant_group"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["reth_idx"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["reth_node"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["reth_nodes"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["speed"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ssr_no_virtual_mac"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["svr_port_range"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["traffic_shaping"] = basetypes.ObjectType{
		AttrTypes: TrafficShapingValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["usage"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["vlan_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["vpn_paths"] = basetypes.MapType{
		ElemType: VpnPathsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["wan_arp_policer"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["wan_ext_ip"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["wan_extra_routes"] = basetypes.MapType{
		ElemType: WanExtraRoutesValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["wan_networks"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["wan_probe_override"] = basetypes.ObjectType{
		AttrTypes: WanProbeOverrideValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["wan_source_nat"] = basetypes.ObjectType{
		AttrTypes: WanSourceNatValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["wan_type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 44)

		val, err = v.AeDisableLacp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ae_disable_lacp"] = val

		val, err = v.AeIdx.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ae_idx"] = val

		val, err = v.AeLacpForceUp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ae_lacp_force_up"] = val

		val, err = v.Aggregated.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["aggregated"] = val

		val, err = v.Critical.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["critical"] = val

		val, err = v.Description.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["description"] = val

		val, err = v.DisableAutoneg.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["disable_autoneg"] = val

		val, err = v.Disabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["disabled"] = val

		val, err = v.DslType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dsl_type"] = val

		val, err = v.DslVci.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dsl_vci"] = val

		val, err = v.DslVpi.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dsl_vpi"] = val

		val, err = v.Duplex.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["duplex"] = val

		val, err = v.LteApn.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["lte_apn"] = val

		val, err = v.LteAuth.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["lte_auth"] = val

		val, err = v.LteBackup.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["lte_backup"] = val

		val, err = v.LtePassword.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["lte_password"] = val

		val, err = v.LteUsername.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["lte_username"] = val

		val, err = v.Mtu.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mtu"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Networks.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["networks"] = val

		val, err = v.OuterVlanId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["outer_vlan_id"] = val

		val, err = v.PoeDisabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["poe_disabled"] = val

		val, err = v.PortIpConfig.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip_config"] = val

		val, err = v.PortNetwork.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port_network"] = val

		val, err = v.PreserveDscp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["preserve_dscp"] = val

		val, err = v.Redundant.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["redundant"] = val

		val, err = v.RedundantGroup.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["redundant_group"] = val

		val, err = v.RethIdx.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["reth_idx"] = val

		val, err = v.RethNode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["reth_node"] = val

		val, err = v.RethNodes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["reth_nodes"] = val

		val, err = v.Speed.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["speed"] = val

		val, err = v.SsrNoVirtualMac.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ssr_no_virtual_mac"] = val

		val, err = v.SvrPortRange.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["svr_port_range"] = val

		val, err = v.TrafficShaping.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["traffic_shaping"] = val

		val, err = v.Usage.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["usage"] = val

		val, err = v.VlanId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vlan_id"] = val

		val, err = v.VpnPaths.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vpn_paths"] = val

		val, err = v.WanArpPolicer.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["wan_arp_policer"] = val

		val, err = v.WanExtIp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["wan_ext_ip"] = val

		val, err = v.WanExtraRoutes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["wan_extra_routes"] = val

		val, err = v.WanNetworks.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["wan_networks"] = val

		val, err = v.WanProbeOverride.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["wan_probe_override"] = val

		val, err = v.WanSourceNat.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["wan_source_nat"] = val

		val, err = v.WanType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["wan_type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PortConfigValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PortConfigValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PortConfigValue) String() string {
	return "PortConfigValue"
}

func (v PortConfigValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var portIpConfig basetypes.ObjectValue

	if v.PortIpConfig.IsNull() {
		portIpConfig = types.ObjectNull(
			PortIpConfigValue{}.AttributeTypes(ctx),
		)
	}

	if v.PortIpConfig.IsUnknown() {
		portIpConfig = types.ObjectUnknown(
			PortIpConfigValue{}.AttributeTypes(ctx),
		)
	}

	if !v.PortIpConfig.IsNull() && !v.PortIpConfig.IsUnknown() {
		portIpConfig = types.ObjectValueMust(
			PortIpConfigValue{}.AttributeTypes(ctx),
			v.PortIpConfig.Attributes(),
		)
	}

	var trafficShaping basetypes.ObjectValue

	if v.TrafficShaping.IsNull() {
		trafficShaping = types.ObjectNull(
			TrafficShapingValue{}.AttributeTypes(ctx),
		)
	}

	if v.TrafficShaping.IsUnknown() {
		trafficShaping = types.ObjectUnknown(
			TrafficShapingValue{}.AttributeTypes(ctx),
		)
	}

	if !v.TrafficShaping.IsNull() && !v.TrafficShaping.IsUnknown() {
		trafficShaping = types.ObjectValueMust(
			TrafficShapingValue{}.AttributeTypes(ctx),
			v.TrafficShaping.Attributes(),
		)
	}

	vpnPaths := types.MapValueMust(
		VpnPathsType{
			basetypes.ObjectType{
				AttrTypes: VpnPathsValue{}.AttributeTypes(ctx),
			},
		},
		v.VpnPaths.Elements(),
	)

	if v.VpnPaths.IsNull() {
		vpnPaths = types.MapNull(
			VpnPathsType{
				basetypes.ObjectType{
					AttrTypes: VpnPathsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.VpnPaths.IsUnknown() {
		vpnPaths = types.MapUnknown(
			VpnPathsType{
				basetypes.ObjectType{
					AttrTypes: VpnPathsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	wanExtraRoutes := types.MapValueMust(
		WanExtraRoutesType{
			basetypes.ObjectType{
				AttrTypes: WanExtraRoutesValue{}.AttributeTypes(ctx),
			},
		},
		v.WanExtraRoutes.Elements(),
	)

	if v.WanExtraRoutes.IsNull() {
		wanExtraRoutes = types.MapNull(
			WanExtraRoutesType{
				basetypes.ObjectType{
					AttrTypes: WanExtraRoutesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.WanExtraRoutes.IsUnknown() {
		wanExtraRoutes = types.MapUnknown(
			WanExtraRoutesType{
				basetypes.ObjectType{
					AttrTypes: WanExtraRoutesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var wanProbeOverride basetypes.ObjectValue

	if v.WanProbeOverride.IsNull() {
		wanProbeOverride = types.ObjectNull(
			WanProbeOverrideValue{}.AttributeTypes(ctx),
		)
	}

	if v.WanProbeOverride.IsUnknown() {
		wanProbeOverride = types.ObjectUnknown(
			WanProbeOverrideValue{}.AttributeTypes(ctx),
		)
	}

	if !v.WanProbeOverride.IsNull() && !v.WanProbeOverride.IsUnknown() {
		wanProbeOverride = types.ObjectValueMust(
			WanProbeOverrideValue{}.AttributeTypes(ctx),
			v.WanProbeOverride.Attributes(),
		)
	}

	var wanSourceNat basetypes.ObjectValue

	if v.WanSourceNat.IsNull() {
		wanSourceNat = types.ObjectNull(
			WanSourceNatValue{}.AttributeTypes(ctx),
		)
	}

	if v.WanSourceNat.IsUnknown() {
		wanSourceNat = types.ObjectUnknown(
			WanSourceNatValue{}.AttributeTypes(ctx),
		)
	}

	if !v.WanSourceNat.IsNull() && !v.WanSourceNat.IsUnknown() {
		wanSourceNat = types.ObjectValueMust(
			WanSourceNatValue{}.AttributeTypes(ctx),
			v.WanSourceNat.Attributes(),
		)
	}

	var networksVal basetypes.ListValue
	switch {
	case v.Networks.IsUnknown():
		networksVal = types.ListUnknown(types.StringType)
	case v.Networks.IsNull():
		networksVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		networksVal, d = types.ListValue(types.StringType, v.Networks.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"ae_disable_lacp":  basetypes.BoolType{},
			"ae_idx":           basetypes.StringType{},
			"ae_lacp_force_up": basetypes.BoolType{},
			"aggregated":       basetypes.BoolType{},
			"critical":         basetypes.BoolType{},
			"description":      basetypes.StringType{},
			"disable_autoneg":  basetypes.BoolType{},
			"disabled":         basetypes.BoolType{},
			"dsl_type":         basetypes.StringType{},
			"dsl_vci":          basetypes.Int64Type{},
			"dsl_vpi":          basetypes.Int64Type{},
			"duplex":           basetypes.StringType{},
			"lte_apn":          basetypes.StringType{},
			"lte_auth":         basetypes.StringType{},
			"lte_backup":       basetypes.BoolType{},
			"lte_password":     basetypes.StringType{},
			"lte_username":     basetypes.StringType{},
			"mtu":              basetypes.Int64Type{},
			"name":             basetypes.StringType{},
			"networks": basetypes.ListType{
				ElemType: types.StringType,
			},
			"outer_vlan_id": basetypes.Int64Type{},
			"poe_disabled":  basetypes.BoolType{},
			"ip_config": basetypes.ObjectType{
				AttrTypes: PortIpConfigValue{}.AttributeTypes(ctx),
			},
			"port_network":    basetypes.StringType{},
			"preserve_dscp":   basetypes.BoolType{},
			"redundant":       basetypes.BoolType{},
			"redundant_group": basetypes.Int64Type{},
			"reth_idx":        basetypes.StringType{},
			"reth_node":       basetypes.StringType{},
			"reth_nodes": basetypes.ListType{
				ElemType: types.StringType,
			},
			"speed":              basetypes.StringType{},
			"ssr_no_virtual_mac": basetypes.BoolType{},
			"svr_port_range":     basetypes.StringType{},
			"traffic_shaping": basetypes.ObjectType{
				AttrTypes: TrafficShapingValue{}.AttributeTypes(ctx),
			},
			"usage":   basetypes.StringType{},
			"vlan_id": basetypes.StringType{},
			"vpn_paths": basetypes.MapType{
				ElemType: VpnPathsValue{}.Type(ctx),
			},
			"wan_arp_policer": basetypes.StringType{},
			"wan_ext_ip":      basetypes.StringType{},
			"wan_extra_routes": basetypes.MapType{
				ElemType: WanExtraRoutesValue{}.Type(ctx),
			},
			"wan_networks": basetypes.ListType{
				ElemType: types.StringType,
			},
			"wan_probe_override": basetypes.ObjectType{
				AttrTypes: WanProbeOverrideValue{}.AttributeTypes(ctx),
			},
			"wan_source_nat": basetypes.ObjectType{
				AttrTypes: WanSourceNatValue{}.AttributeTypes(ctx),
			},
			"wan_type": basetypes.StringType{},
		}), diags
	}

	var rethNodesVal basetypes.ListValue
	switch {
	case v.RethNodes.IsUnknown():
		rethNodesVal = types.ListUnknown(types.StringType)
	case v.RethNodes.IsNull():
		rethNodesVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		rethNodesVal, d = types.ListValue(types.StringType, v.RethNodes.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"ae_disable_lacp":  basetypes.BoolType{},
			"ae_idx":           basetypes.StringType{},
			"ae_lacp_force_up": basetypes.BoolType{},
			"aggregated":       basetypes.BoolType{},
			"critical":         basetypes.BoolType{},
			"description":      basetypes.StringType{},
			"disable_autoneg":  basetypes.BoolType{},
			"disabled":         basetypes.BoolType{},
			"dsl_type":         basetypes.StringType{},
			"dsl_vci":          basetypes.Int64Type{},
			"dsl_vpi":          basetypes.Int64Type{},
			"duplex":           basetypes.StringType{},
			"lte_apn":          basetypes.StringType{},
			"lte_auth":         basetypes.StringType{},
			"lte_backup":       basetypes.BoolType{},
			"lte_password":     basetypes.StringType{},
			"lte_username":     basetypes.StringType{},
			"mtu":              basetypes.Int64Type{},
			"name":             basetypes.StringType{},
			"networks": basetypes.ListType{
				ElemType: types.StringType,
			},
			"outer_vlan_id": basetypes.Int64Type{},
			"poe_disabled":  basetypes.BoolType{},
			"ip_config": basetypes.ObjectType{
				AttrTypes: PortIpConfigValue{}.AttributeTypes(ctx),
			},
			"port_network":    basetypes.StringType{},
			"preserve_dscp":   basetypes.BoolType{},
			"redundant":       basetypes.BoolType{},
			"redundant_group": basetypes.Int64Type{},
			"reth_idx":        basetypes.StringType{},
			"reth_node":       basetypes.StringType{},
			"reth_nodes": basetypes.ListType{
				ElemType: types.StringType,
			},
			"speed":              basetypes.StringType{},
			"ssr_no_virtual_mac": basetypes.BoolType{},
			"svr_port_range":     basetypes.StringType{},
			"traffic_shaping": basetypes.ObjectType{
				AttrTypes: TrafficShapingValue{}.AttributeTypes(ctx),
			},
			"usage":   basetypes.StringType{},
			"vlan_id": basetypes.StringType{},
			"vpn_paths": basetypes.MapType{
				ElemType: VpnPathsValue{}.Type(ctx),
			},
			"wan_arp_policer": basetypes.StringType{},
			"wan_ext_ip":      basetypes.StringType{},
			"wan_extra_routes": basetypes.MapType{
				ElemType: WanExtraRoutesValue{}.Type(ctx),
			},
			"wan_networks": basetypes.ListType{
				ElemType: types.StringType,
			},
			"wan_probe_override": basetypes.ObjectType{
				AttrTypes: WanProbeOverrideValue{}.AttributeTypes(ctx),
			},
			"wan_source_nat": basetypes.ObjectType{
				AttrTypes: WanSourceNatValue{}.AttributeTypes(ctx),
			},
			"wan_type": basetypes.StringType{},
		}), diags
	}

	var wanNetworksVal basetypes.ListValue
	switch {
	case v.WanNetworks.IsUnknown():
		wanNetworksVal = types.ListUnknown(types.StringType)
	case v.WanNetworks.IsNull():
		wanNetworksVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		wanNetworksVal, d = types.ListValue(types.StringType, v.WanNetworks.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"ae_disable_lacp":  basetypes.BoolType{},
			"ae_idx":           basetypes.StringType{},
			"ae_lacp_force_up": basetypes.BoolType{},
			"aggregated":       basetypes.BoolType{},
			"critical":         basetypes.BoolType{},
			"description":      basetypes.StringType{},
			"disable_autoneg":  basetypes.BoolType{},
			"disabled":         basetypes.BoolType{},
			"dsl_type":         basetypes.StringType{},
			"dsl_vci":          basetypes.Int64Type{},
			"dsl_vpi":          basetypes.Int64Type{},
			"duplex":           basetypes.StringType{},
			"lte_apn":          basetypes.StringType{},
			"lte_auth":         basetypes.StringType{},
			"lte_backup":       basetypes.BoolType{},
			"lte_password":     basetypes.StringType{},
			"lte_username":     basetypes.StringType{},
			"mtu":              basetypes.Int64Type{},
			"name":             basetypes.StringType{},
			"networks": basetypes.ListType{
				ElemType: types.StringType,
			},
			"outer_vlan_id": basetypes.Int64Type{},
			"poe_disabled":  basetypes.BoolType{},
			"ip_config": basetypes.ObjectType{
				AttrTypes: PortIpConfigValue{}.AttributeTypes(ctx),
			},
			"port_network":    basetypes.StringType{},
			"preserve_dscp":   basetypes.BoolType{},
			"redundant":       basetypes.BoolType{},
			"redundant_group": basetypes.Int64Type{},
			"reth_idx":        basetypes.StringType{},
			"reth_node":       basetypes.StringType{},
			"reth_nodes": basetypes.ListType{
				ElemType: types.StringType,
			},
			"speed":              basetypes.StringType{},
			"ssr_no_virtual_mac": basetypes.BoolType{},
			"svr_port_range":     basetypes.StringType{},
			"traffic_shaping": basetypes.ObjectType{
				AttrTypes: TrafficShapingValue{}.AttributeTypes(ctx),
			},
			"usage":   basetypes.StringType{},
			"vlan_id": basetypes.StringType{},
			"vpn_paths": basetypes.MapType{
				ElemType: VpnPathsValue{}.Type(ctx),
			},
			"wan_arp_policer": basetypes.StringType{},
			"wan_ext_ip":      basetypes.StringType{},
			"wan_extra_routes": basetypes.MapType{
				ElemType: WanExtraRoutesValue{}.Type(ctx),
			},
			"wan_networks": basetypes.ListType{
				ElemType: types.StringType,
			},
			"wan_probe_override": basetypes.ObjectType{
				AttrTypes: WanProbeOverrideValue{}.AttributeTypes(ctx),
			},
			"wan_source_nat": basetypes.ObjectType{
				AttrTypes: WanSourceNatValue{}.AttributeTypes(ctx),
			},
			"wan_type": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"ae_disable_lacp":  basetypes.BoolType{},
		"ae_idx":           basetypes.StringType{},
		"ae_lacp_force_up": basetypes.BoolType{},
		"aggregated":       basetypes.BoolType{},
		"critical":         basetypes.BoolType{},
		"description":      basetypes.StringType{},
		"disable_autoneg":  basetypes.BoolType{},
		"disabled":         basetypes.BoolType{},
		"dsl_type":         basetypes.StringType{},
		"dsl_vci":          basetypes.Int64Type{},
		"dsl_vpi":          basetypes.Int64Type{},
		"duplex":           basetypes.StringType{},
		"lte_apn":          basetypes.StringType{},
		"lte_auth":         basetypes.StringType{},
		"lte_backup":       basetypes.BoolType{},
		"lte_password":     basetypes.StringType{},
		"lte_username":     basetypes.StringType{},
		"mtu":              basetypes.Int64Type{},
		"name":             basetypes.StringType{},
		"networks": basetypes.ListType{
			ElemType: types.StringType,
		},
		"outer_vlan_id": basetypes.Int64Type{},
		"poe_disabled":  basetypes.BoolType{},
		"ip_config": basetypes.ObjectType{
			AttrTypes: PortIpConfigValue{}.AttributeTypes(ctx),
		},
		"port_network":    basetypes.StringType{},
		"preserve_dscp":   basetypes.BoolType{},
		"redundant":       basetypes.BoolType{},
		"redundant_group": basetypes.Int64Type{},
		"reth_idx":        basetypes.StringType{},
		"reth_node":       basetypes.StringType{},
		"reth_nodes": basetypes.ListType{
			ElemType: types.StringType,
		},
		"speed":              basetypes.StringType{},
		"ssr_no_virtual_mac": basetypes.BoolType{},
		"svr_port_range":     basetypes.StringType{},
		"traffic_shaping": basetypes.ObjectType{
			AttrTypes: TrafficShapingValue{}.AttributeTypes(ctx),
		},
		"usage":   basetypes.StringType{},
		"vlan_id": basetypes.StringType{},
		"vpn_paths": basetypes.MapType{
			ElemType: VpnPathsValue{}.Type(ctx),
		},
		"wan_arp_policer": basetypes.StringType{},
		"wan_ext_ip":      basetypes.StringType{},
		"wan_extra_routes": basetypes.MapType{
			ElemType: WanExtraRoutesValue{}.Type(ctx),
		},
		"wan_networks": basetypes.ListType{
			ElemType: types.StringType,
		},
		"wan_probe_override": basetypes.ObjectType{
			AttrTypes: WanProbeOverrideValue{}.AttributeTypes(ctx),
		},
		"wan_source_nat": basetypes.ObjectType{
			AttrTypes: WanSourceNatValue{}.AttributeTypes(ctx),
		},
		"wan_type": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"ae_disable_lacp":    v.AeDisableLacp,
			"ae_idx":             v.AeIdx,
			"ae_lacp_force_up":   v.AeLacpForceUp,
			"aggregated":         v.Aggregated,
			"critical":           v.Critical,
			"description":        v.Description,
			"disable_autoneg":    v.DisableAutoneg,
			"disabled":           v.Disabled,
			"dsl_type":           v.DslType,
			"dsl_vci":            v.DslVci,
			"dsl_vpi":            v.DslVpi,
			"duplex":             v.Duplex,
			"lte_apn":            v.LteApn,
			"lte_auth":           v.LteAuth,
			"lte_backup":         v.LteBackup,
			"lte_password":       v.LtePassword,
			"lte_username":       v.LteUsername,
			"mtu":                v.Mtu,
			"name":               v.Name,
			"networks":           networksVal,
			"outer_vlan_id":      v.OuterVlanId,
			"poe_disabled":       v.PoeDisabled,
			"ip_config":          portIpConfig,
			"port_network":       v.PortNetwork,
			"preserve_dscp":      v.PreserveDscp,
			"redundant":          v.Redundant,
			"redundant_group":    v.RedundantGroup,
			"reth_idx":           v.RethIdx,
			"reth_node":          v.RethNode,
			"reth_nodes":         rethNodesVal,
			"speed":              v.Speed,
			"ssr_no_virtual_mac": v.SsrNoVirtualMac,
			"svr_port_range":     v.SvrPortRange,
			"traffic_shaping":    trafficShaping,
			"usage":              v.Usage,
			"vlan_id":            v.VlanId,
			"vpn_paths":          vpnPaths,
			"wan_arp_policer":    v.WanArpPolicer,
			"wan_ext_ip":         v.WanExtIp,
			"wan_extra_routes":   wanExtraRoutes,
			"wan_networks":       wanNetworksVal,
			"wan_probe_override": wanProbeOverride,
			"wan_source_nat":     wanSourceNat,
			"wan_type":           v.WanType,
		})

	return objVal, diags
}

func (v PortConfigValue) Equal(o attr.Value) bool {
	other, ok := o.(PortConfigValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AeDisableLacp.Equal(other.AeDisableLacp) {
		return false
	}

	if !v.AeIdx.Equal(other.AeIdx) {
		return false
	}

	if !v.AeLacpForceUp.Equal(other.AeLacpForceUp) {
		return false
	}

	if !v.Aggregated.Equal(other.Aggregated) {
		return false
	}

	if !v.Critical.Equal(other.Critical) {
		return false
	}

	if !v.Description.Equal(other.Description) {
		return false
	}

	if !v.DisableAutoneg.Equal(other.DisableAutoneg) {
		return false
	}

	if !v.Disabled.Equal(other.Disabled) {
		return false
	}

	if !v.DslType.Equal(other.DslType) {
		return false
	}

	if !v.DslVci.Equal(other.DslVci) {
		return false
	}

	if !v.DslVpi.Equal(other.DslVpi) {
		return false
	}

	if !v.Duplex.Equal(other.Duplex) {
		return false
	}

	if !v.LteApn.Equal(other.LteApn) {
		return false
	}

	if !v.LteAuth.Equal(other.LteAuth) {
		return false
	}

	if !v.LteBackup.Equal(other.LteBackup) {
		return false
	}

	if !v.LtePassword.Equal(other.LtePassword) {
		return false
	}

	if !v.LteUsername.Equal(other.LteUsername) {
		return false
	}

	if !v.Mtu.Equal(other.Mtu) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Networks.Equal(other.Networks) {
		return false
	}

	if !v.OuterVlanId.Equal(other.OuterVlanId) {
		return false
	}

	if !v.PoeDisabled.Equal(other.PoeDisabled) {
		return false
	}

	if !v.PortIpConfig.Equal(other.PortIpConfig) {
		return false
	}

	if !v.PortNetwork.Equal(other.PortNetwork) {
		return false
	}

	if !v.PreserveDscp.Equal(other.PreserveDscp) {
		return false
	}

	if !v.Redundant.Equal(other.Redundant) {
		return false
	}

	if !v.RedundantGroup.Equal(other.RedundantGroup) {
		return false
	}

	if !v.RethIdx.Equal(other.RethIdx) {
		return false
	}

	if !v.RethNode.Equal(other.RethNode) {
		return false
	}

	if !v.RethNodes.Equal(other.RethNodes) {
		return false
	}

	if !v.Speed.Equal(other.Speed) {
		return false
	}

	if !v.SsrNoVirtualMac.Equal(other.SsrNoVirtualMac) {
		return false
	}

	if !v.SvrPortRange.Equal(other.SvrPortRange) {
		return false
	}

	if !v.TrafficShaping.Equal(other.TrafficShaping) {
		return false
	}

	if !v.Usage.Equal(other.Usage) {
		return false
	}

	if !v.VlanId.Equal(other.VlanId) {
		return false
	}

	if !v.VpnPaths.Equal(other.VpnPaths) {
		return false
	}

	if !v.WanArpPolicer.Equal(other.WanArpPolicer) {
		return false
	}

	if !v.WanExtIp.Equal(other.WanExtIp) {
		return false
	}

	if !v.WanExtraRoutes.Equal(other.WanExtraRoutes) {
		return false
	}

	if !v.WanNetworks.Equal(other.WanNetworks) {
		return false
	}

	if !v.WanProbeOverride.Equal(other.WanProbeOverride) {
		return false
	}

	if !v.WanSourceNat.Equal(other.WanSourceNat) {
		return false
	}

	if !v.WanType.Equal(other.WanType) {
		return false
	}

	return true
}

func (v PortConfigValue) Type(ctx context.Context) attr.Type {
	return PortConfigType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PortConfigValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"ae_disable_lacp":  basetypes.BoolType{},
		"ae_idx":           basetypes.StringType{},
		"ae_lacp_force_up": basetypes.BoolType{},
		"aggregated":       basetypes.BoolType{},
		"critical":         basetypes.BoolType{},
		"description":      basetypes.StringType{},
		"disable_autoneg":  basetypes.BoolType{},
		"disabled":         basetypes.BoolType{},
		"dsl_type":         basetypes.StringType{},
		"dsl_vci":          basetypes.Int64Type{},
		"dsl_vpi":          basetypes.Int64Type{},
		"duplex":           basetypes.StringType{},
		"lte_apn":          basetypes.StringType{},
		"lte_auth":         basetypes.StringType{},
		"lte_backup":       basetypes.BoolType{},
		"lte_password":     basetypes.StringType{},
		"lte_username":     basetypes.StringType{},
		"mtu":              basetypes.Int64Type{},
		"name":             basetypes.StringType{},
		"networks": basetypes.ListType{
			ElemType: types.StringType,
		},
		"outer_vlan_id": basetypes.Int64Type{},
		"poe_disabled":  basetypes.BoolType{},
		"ip_config": basetypes.ObjectType{
			AttrTypes: PortIpConfigValue{}.AttributeTypes(ctx),
		},
		"port_network":    basetypes.StringType{},
		"preserve_dscp":   basetypes.BoolType{},
		"redundant":       basetypes.BoolType{},
		"redundant_group": basetypes.Int64Type{},
		"reth_idx":        basetypes.StringType{},
		"reth_node":       basetypes.StringType{},
		"reth_nodes": basetypes.ListType{
			ElemType: types.StringType,
		},
		"speed":              basetypes.StringType{},
		"ssr_no_virtual_mac": basetypes.BoolType{},
		"svr_port_range":     basetypes.StringType{},
		"traffic_shaping": basetypes.ObjectType{
			AttrTypes: TrafficShapingValue{}.AttributeTypes(ctx),
		},
		"usage":   basetypes.StringType{},
		"vlan_id": basetypes.StringType{},
		"vpn_paths": basetypes.MapType{
			ElemType: VpnPathsValue{}.Type(ctx),
		},
		"wan_arp_policer": basetypes.StringType{},
		"wan_ext_ip":      basetypes.StringType{},
		"wan_extra_routes": basetypes.MapType{
			ElemType: WanExtraRoutesValue{}.Type(ctx),
		},
		"wan_networks": basetypes.ListType{
			ElemType: types.StringType,
		},
		"wan_probe_override": basetypes.ObjectType{
			AttrTypes: WanProbeOverrideValue{}.AttributeTypes(ctx),
		},
		"wan_source_nat": basetypes.ObjectType{
			AttrTypes: WanSourceNatValue{}.AttributeTypes(ctx),
		},
		"wan_type": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = PortIpConfigType{}

type PortIpConfigType struct {
	basetypes.ObjectType
}

func (t PortIpConfigType) Equal(o attr.Type) bool {
	other, ok := o.(PortIpConfigType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PortIpConfigType) String() string {
	return "PortIpConfigType"
}

func (t PortIpConfigType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	dnsAttribute, ok := attributes["dns"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dns is missing from object`)

		return nil, diags
	}

	dnsVal, ok := dnsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dns expected to be basetypes.ListValue, was: %T`, dnsAttribute))
	}

	dnsSuffixAttribute, ok := attributes["dns_suffix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dns_suffix is missing from object`)

		return nil, diags
	}

	dnsSuffixVal, ok := dnsSuffixAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dns_suffix expected to be basetypes.ListValue, was: %T`, dnsSuffixAttribute))
	}

	gatewayAttribute, ok := attributes["gateway"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gateway is missing from object`)

		return nil, diags
	}

	gatewayVal, ok := gatewayAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gateway expected to be basetypes.StringValue, was: %T`, gatewayAttribute))
	}

	ipAttribute, ok := attributes["ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip is missing from object`)

		return nil, diags
	}

	ipVal, ok := ipAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip expected to be basetypes.StringValue, was: %T`, ipAttribute))
	}

	netmaskAttribute, ok := attributes["netmask"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`netmask is missing from object`)

		return nil, diags
	}

	netmaskVal, ok := netmaskAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`netmask expected to be basetypes.StringValue, was: %T`, netmaskAttribute))
	}

	networkAttribute, ok := attributes["network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`network is missing from object`)

		return nil, diags
	}

	networkVal, ok := networkAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`network expected to be basetypes.StringValue, was: %T`, networkAttribute))
	}

	poserPasswordAttribute, ok := attributes["poser_password"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`poser_password is missing from object`)

		return nil, diags
	}

	poserPasswordVal, ok := poserPasswordAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`poser_password expected to be basetypes.StringValue, was: %T`, poserPasswordAttribute))
	}

	pppoeAuthAttribute, ok := attributes["pppoe_auth"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pppoe_auth is missing from object`)

		return nil, diags
	}

	pppoeAuthVal, ok := pppoeAuthAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pppoe_auth expected to be basetypes.StringValue, was: %T`, pppoeAuthAttribute))
	}

	pppoeUsernameAttribute, ok := attributes["pppoe_username"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pppoe_username is missing from object`)

		return nil, diags
	}

	pppoeUsernameVal, ok := pppoeUsernameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pppoe_username expected to be basetypes.StringValue, was: %T`, pppoeUsernameAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PortIpConfigValue{
		Dns:              dnsVal,
		DnsSuffix:        dnsSuffixVal,
		Gateway:          gatewayVal,
		Ip:               ipVal,
		Netmask:          netmaskVal,
		Network:          networkVal,
		PoserPassword:    poserPasswordVal,
		PppoeAuth:        pppoeAuthVal,
		PppoeUsername:    pppoeUsernameVal,
		PortIpConfigType: typeVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewPortIpConfigValueNull() PortIpConfigValue {
	return PortIpConfigValue{
		state: attr.ValueStateNull,
	}
}

func NewPortIpConfigValueUnknown() PortIpConfigValue {
	return PortIpConfigValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPortIpConfigValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PortIpConfigValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PortIpConfigValue Attribute Value",
				"While creating a PortIpConfigValue value, a missing attribute value was detected. "+
					"A PortIpConfigValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PortIpConfigValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PortIpConfigValue Attribute Type",
				"While creating a PortIpConfigValue value, an invalid attribute value was detected. "+
					"A PortIpConfigValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PortIpConfigValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PortIpConfigValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PortIpConfigValue Attribute Value",
				"While creating a PortIpConfigValue value, an extra attribute value was detected. "+
					"A PortIpConfigValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PortIpConfigValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPortIpConfigValueUnknown(), diags
	}

	dnsAttribute, ok := attributes["dns"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dns is missing from object`)

		return NewPortIpConfigValueUnknown(), diags
	}

	dnsVal, ok := dnsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dns expected to be basetypes.ListValue, was: %T`, dnsAttribute))
	}

	dnsSuffixAttribute, ok := attributes["dns_suffix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dns_suffix is missing from object`)

		return NewPortIpConfigValueUnknown(), diags
	}

	dnsSuffixVal, ok := dnsSuffixAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dns_suffix expected to be basetypes.ListValue, was: %T`, dnsSuffixAttribute))
	}

	gatewayAttribute, ok := attributes["gateway"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gateway is missing from object`)

		return NewPortIpConfigValueUnknown(), diags
	}

	gatewayVal, ok := gatewayAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gateway expected to be basetypes.StringValue, was: %T`, gatewayAttribute))
	}

	ipAttribute, ok := attributes["ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip is missing from object`)

		return NewPortIpConfigValueUnknown(), diags
	}

	ipVal, ok := ipAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip expected to be basetypes.StringValue, was: %T`, ipAttribute))
	}

	netmaskAttribute, ok := attributes["netmask"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`netmask is missing from object`)

		return NewPortIpConfigValueUnknown(), diags
	}

	netmaskVal, ok := netmaskAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`netmask expected to be basetypes.StringValue, was: %T`, netmaskAttribute))
	}

	networkAttribute, ok := attributes["network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`network is missing from object`)

		return NewPortIpConfigValueUnknown(), diags
	}

	networkVal, ok := networkAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`network expected to be basetypes.StringValue, was: %T`, networkAttribute))
	}

	poserPasswordAttribute, ok := attributes["poser_password"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`poser_password is missing from object`)

		return NewPortIpConfigValueUnknown(), diags
	}

	poserPasswordVal, ok := poserPasswordAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`poser_password expected to be basetypes.StringValue, was: %T`, poserPasswordAttribute))
	}

	pppoeAuthAttribute, ok := attributes["pppoe_auth"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pppoe_auth is missing from object`)

		return NewPortIpConfigValueUnknown(), diags
	}

	pppoeAuthVal, ok := pppoeAuthAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pppoe_auth expected to be basetypes.StringValue, was: %T`, pppoeAuthAttribute))
	}

	pppoeUsernameAttribute, ok := attributes["pppoe_username"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pppoe_username is missing from object`)

		return NewPortIpConfigValueUnknown(), diags
	}

	pppoeUsernameVal, ok := pppoeUsernameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pppoe_username expected to be basetypes.StringValue, was: %T`, pppoeUsernameAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewPortIpConfigValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return NewPortIpConfigValueUnknown(), diags
	}

	return PortIpConfigValue{
		Dns:              dnsVal,
		DnsSuffix:        dnsSuffixVal,
		Gateway:          gatewayVal,
		Ip:               ipVal,
		Netmask:          netmaskVal,
		Network:          networkVal,
		PoserPassword:    poserPasswordVal,
		PppoeAuth:        pppoeAuthVal,
		PppoeUsername:    pppoeUsernameVal,
		PortIpConfigType: typeVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewPortIpConfigValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PortIpConfigValue {
	object, diags := NewPortIpConfigValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPortIpConfigValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PortIpConfigType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPortIpConfigValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPortIpConfigValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPortIpConfigValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPortIpConfigValueMust(PortIpConfigValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PortIpConfigType) ValueType(ctx context.Context) attr.Value {
	return PortIpConfigValue{}
}

var _ basetypes.ObjectValuable = PortIpConfigValue{}

type PortIpConfigValue struct {
	Dns              basetypes.ListValue   `tfsdk:"dns"`
	DnsSuffix        basetypes.ListValue   `tfsdk:"dns_suffix"`
	Gateway          basetypes.StringValue `tfsdk:"gateway"`
	Ip               basetypes.StringValue `tfsdk:"ip"`
	Netmask          basetypes.StringValue `tfsdk:"netmask"`
	Network          basetypes.StringValue `tfsdk:"network"`
	PoserPassword    basetypes.StringValue `tfsdk:"poser_password"`
	PppoeAuth        basetypes.StringValue `tfsdk:"pppoe_auth"`
	PppoeUsername    basetypes.StringValue `tfsdk:"pppoe_username"`
	PortIpConfigType basetypes.StringValue `tfsdk:"type"`
	state            attr.ValueState
}

func (v PortIpConfigValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 10)

	var val tftypes.Value
	var err error

	attrTypes["dns"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["dns_suffix"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["gateway"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ip"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["netmask"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["network"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["poser_password"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["pppoe_auth"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["pppoe_username"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 10)

		val, err = v.Dns.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dns"] = val

		val, err = v.DnsSuffix.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dns_suffix"] = val

		val, err = v.Gateway.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["gateway"] = val

		val, err = v.Ip.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip"] = val

		val, err = v.Netmask.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["netmask"] = val

		val, err = v.Network.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["network"] = val

		val, err = v.PoserPassword.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["poser_password"] = val

		val, err = v.PppoeAuth.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["pppoe_auth"] = val

		val, err = v.PppoeUsername.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["pppoe_username"] = val

		val, err = v.PortIpConfigType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PortIpConfigValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PortIpConfigValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PortIpConfigValue) String() string {
	return "PortIpConfigValue"
}

func (v PortIpConfigValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var dnsVal basetypes.ListValue
	switch {
	case v.Dns.IsUnknown():
		dnsVal = types.ListUnknown(types.StringType)
	case v.Dns.IsNull():
		dnsVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		dnsVal, d = types.ListValue(types.StringType, v.Dns.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"dns": basetypes.ListType{
				ElemType: types.StringType,
			},
			"dns_suffix": basetypes.ListType{
				ElemType: types.StringType,
			},
			"gateway":        basetypes.StringType{},
			"ip":             basetypes.StringType{},
			"netmask":        basetypes.StringType{},
			"network":        basetypes.StringType{},
			"poser_password": basetypes.StringType{},
			"pppoe_auth":     basetypes.StringType{},
			"pppoe_username": basetypes.StringType{},
			"type":           basetypes.StringType{},
		}), diags
	}

	var dnsSuffixVal basetypes.ListValue
	switch {
	case v.DnsSuffix.IsUnknown():
		dnsSuffixVal = types.ListUnknown(types.StringType)
	case v.DnsSuffix.IsNull():
		dnsSuffixVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		dnsSuffixVal, d = types.ListValue(types.StringType, v.DnsSuffix.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"dns": basetypes.ListType{
				ElemType: types.StringType,
			},
			"dns_suffix": basetypes.ListType{
				ElemType: types.StringType,
			},
			"gateway":        basetypes.StringType{},
			"ip":             basetypes.StringType{},
			"netmask":        basetypes.StringType{},
			"network":        basetypes.StringType{},
			"poser_password": basetypes.StringType{},
			"pppoe_auth":     basetypes.StringType{},
			"pppoe_username": basetypes.StringType{},
			"type":           basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"dns": basetypes.ListType{
			ElemType: types.StringType,
		},
		"dns_suffix": basetypes.ListType{
			ElemType: types.StringType,
		},
		"gateway":        basetypes.StringType{},
		"ip":             basetypes.StringType{},
		"netmask":        basetypes.StringType{},
		"network":        basetypes.StringType{},
		"poser_password": basetypes.StringType{},
		"pppoe_auth":     basetypes.StringType{},
		"pppoe_username": basetypes.StringType{},
		"type":           basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"dns":            dnsVal,
			"dns_suffix":     dnsSuffixVal,
			"gateway":        v.Gateway,
			"ip":             v.Ip,
			"netmask":        v.Netmask,
			"network":        v.Network,
			"poser_password": v.PoserPassword,
			"pppoe_auth":     v.PppoeAuth,
			"pppoe_username": v.PppoeUsername,
			"type":           v.PortIpConfigType,
		})

	return objVal, diags
}

func (v PortIpConfigValue) Equal(o attr.Value) bool {
	other, ok := o.(PortIpConfigValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Dns.Equal(other.Dns) {
		return false
	}

	if !v.DnsSuffix.Equal(other.DnsSuffix) {
		return false
	}

	if !v.Gateway.Equal(other.Gateway) {
		return false
	}

	if !v.Ip.Equal(other.Ip) {
		return false
	}

	if !v.Netmask.Equal(other.Netmask) {
		return false
	}

	if !v.Network.Equal(other.Network) {
		return false
	}

	if !v.PoserPassword.Equal(other.PoserPassword) {
		return false
	}

	if !v.PppoeAuth.Equal(other.PppoeAuth) {
		return false
	}

	if !v.PppoeUsername.Equal(other.PppoeUsername) {
		return false
	}

	if !v.PortIpConfigType.Equal(other.PortIpConfigType) {
		return false
	}

	return true
}

func (v PortIpConfigValue) Type(ctx context.Context) attr.Type {
	return PortIpConfigType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PortIpConfigValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"dns": basetypes.ListType{
			ElemType: types.StringType,
		},
		"dns_suffix": basetypes.ListType{
			ElemType: types.StringType,
		},
		"gateway":        basetypes.StringType{},
		"ip":             basetypes.StringType{},
		"netmask":        basetypes.StringType{},
		"network":        basetypes.StringType{},
		"poser_password": basetypes.StringType{},
		"pppoe_auth":     basetypes.StringType{},
		"pppoe_username": basetypes.StringType{},
		"type":           basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = TrafficShapingType{}

type TrafficShapingType struct {
	basetypes.ObjectType
}

func (t TrafficShapingType) Equal(o attr.Type) bool {
	other, ok := o.(TrafficShapingType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t TrafficShapingType) String() string {
	return "TrafficShapingType"
}

func (t TrafficShapingType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	classPercentagesAttribute, ok := attributes["class_percentages"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`class_percentages is missing from object`)

		return nil, diags
	}

	classPercentagesVal, ok := classPercentagesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`class_percentages expected to be basetypes.ListValue, was: %T`, classPercentagesAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	maxTxKbpsAttribute, ok := attributes["max_tx_kbps"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_tx_kbps is missing from object`)

		return nil, diags
	}

	maxTxKbpsVal, ok := maxTxKbpsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_tx_kbps expected to be basetypes.Int64Value, was: %T`, maxTxKbpsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return TrafficShapingValue{
		ClassPercentages: classPercentagesVal,
		Enabled:          enabledVal,
		MaxTxKbps:        maxTxKbpsVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewTrafficShapingValueNull() TrafficShapingValue {
	return TrafficShapingValue{
		state: attr.ValueStateNull,
	}
}

func NewTrafficShapingValueUnknown() TrafficShapingValue {
	return TrafficShapingValue{
		state: attr.ValueStateUnknown,
	}
}

func NewTrafficShapingValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (TrafficShapingValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing TrafficShapingValue Attribute Value",
				"While creating a TrafficShapingValue value, a missing attribute value was detected. "+
					"A TrafficShapingValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TrafficShapingValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid TrafficShapingValue Attribute Type",
				"While creating a TrafficShapingValue value, an invalid attribute value was detected. "+
					"A TrafficShapingValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TrafficShapingValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("TrafficShapingValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra TrafficShapingValue Attribute Value",
				"While creating a TrafficShapingValue value, an extra attribute value was detected. "+
					"A TrafficShapingValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra TrafficShapingValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewTrafficShapingValueUnknown(), diags
	}

	classPercentagesAttribute, ok := attributes["class_percentages"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`class_percentages is missing from object`)

		return NewTrafficShapingValueUnknown(), diags
	}

	classPercentagesVal, ok := classPercentagesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`class_percentages expected to be basetypes.ListValue, was: %T`, classPercentagesAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewTrafficShapingValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	maxTxKbpsAttribute, ok := attributes["max_tx_kbps"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_tx_kbps is missing from object`)

		return NewTrafficShapingValueUnknown(), diags
	}

	maxTxKbpsVal, ok := maxTxKbpsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_tx_kbps expected to be basetypes.Int64Value, was: %T`, maxTxKbpsAttribute))
	}

	if diags.HasError() {
		return NewTrafficShapingValueUnknown(), diags
	}

	return TrafficShapingValue{
		ClassPercentages: classPercentagesVal,
		Enabled:          enabledVal,
		MaxTxKbps:        maxTxKbpsVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewTrafficShapingValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) TrafficShapingValue {
	object, diags := NewTrafficShapingValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewTrafficShapingValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t TrafficShapingType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewTrafficShapingValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewTrafficShapingValueUnknown(), nil
	}

	if in.IsNull() {
		return NewTrafficShapingValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewTrafficShapingValueMust(TrafficShapingValue{}.AttributeTypes(ctx), attributes), nil
}

func (t TrafficShapingType) ValueType(ctx context.Context) attr.Value {
	return TrafficShapingValue{}
}

var _ basetypes.ObjectValuable = TrafficShapingValue{}

type TrafficShapingValue struct {
	ClassPercentages basetypes.ListValue  `tfsdk:"class_percentages"`
	Enabled          basetypes.BoolValue  `tfsdk:"enabled"`
	MaxTxKbps        basetypes.Int64Value `tfsdk:"max_tx_kbps"`
	state            attr.ValueState
}

func (v TrafficShapingValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["class_percentages"] = basetypes.ListType{
		ElemType: types.Int64Type,
	}.TerraformType(ctx)
	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["max_tx_kbps"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.ClassPercentages.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["class_percentages"] = val

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.MaxTxKbps.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_tx_kbps"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v TrafficShapingValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v TrafficShapingValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v TrafficShapingValue) String() string {
	return "TrafficShapingValue"
}

func (v TrafficShapingValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var classPercentagesVal basetypes.ListValue
	switch {
	case v.ClassPercentages.IsUnknown():
		classPercentagesVal = types.ListUnknown(types.Int64Type)
	case v.ClassPercentages.IsNull():
		classPercentagesVal = types.ListNull(types.Int64Type)
	default:
		var d diag.Diagnostics
		classPercentagesVal, d = types.ListValue(types.Int64Type, v.ClassPercentages.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"class_percentages": basetypes.ListType{
				ElemType: types.Int64Type,
			},
			"enabled":     basetypes.BoolType{},
			"max_tx_kbps": basetypes.Int64Type{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"class_percentages": basetypes.ListType{
			ElemType: types.Int64Type,
		},
		"enabled":     basetypes.BoolType{},
		"max_tx_kbps": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"class_percentages": classPercentagesVal,
			"enabled":           v.Enabled,
			"max_tx_kbps":       v.MaxTxKbps,
		})

	return objVal, diags
}

func (v TrafficShapingValue) Equal(o attr.Value) bool {
	other, ok := o.(TrafficShapingValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.ClassPercentages.Equal(other.ClassPercentages) {
		return false
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.MaxTxKbps.Equal(other.MaxTxKbps) {
		return false
	}

	return true
}

func (v TrafficShapingValue) Type(ctx context.Context) attr.Type {
	return TrafficShapingType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v TrafficShapingValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"class_percentages": basetypes.ListType{
			ElemType: types.Int64Type,
		},
		"enabled":     basetypes.BoolType{},
		"max_tx_kbps": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = VpnPathsType{}

type VpnPathsType struct {
	basetypes.ObjectType
}

func (t VpnPathsType) Equal(o attr.Type) bool {
	other, ok := o.(VpnPathsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t VpnPathsType) String() string {
	return "VpnPathsType"
}

func (t VpnPathsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	bfdProfileAttribute, ok := attributes["bfd_profile"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bfd_profile is missing from object`)

		return nil, diags
	}

	bfdProfileVal, ok := bfdProfileAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bfd_profile expected to be basetypes.StringValue, was: %T`, bfdProfileAttribute))
	}

	bfdUseTunnelModeAttribute, ok := attributes["bfd_use_tunnel_mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bfd_use_tunnel_mode is missing from object`)

		return nil, diags
	}

	bfdUseTunnelModeVal, ok := bfdUseTunnelModeAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bfd_use_tunnel_mode expected to be basetypes.BoolValue, was: %T`, bfdUseTunnelModeAttribute))
	}

	preferenceAttribute, ok := attributes["preference"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`preference is missing from object`)

		return nil, diags
	}

	preferenceVal, ok := preferenceAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`preference expected to be basetypes.Int64Value, was: %T`, preferenceAttribute))
	}

	roleAttribute, ok := attributes["role"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`role is missing from object`)

		return nil, diags
	}

	roleVal, ok := roleAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`role expected to be basetypes.StringValue, was: %T`, roleAttribute))
	}

	trafficShapingAttribute, ok := attributes["traffic_shaping"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`traffic_shaping is missing from object`)

		return nil, diags
	}

	trafficShapingVal, ok := trafficShapingAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`traffic_shaping expected to be basetypes.ObjectValue, was: %T`, trafficShapingAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return VpnPathsValue{
		BfdProfile:       bfdProfileVal,
		BfdUseTunnelMode: bfdUseTunnelModeVal,
		Preference:       preferenceVal,
		Role:             roleVal,
		TrafficShaping:   trafficShapingVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewVpnPathsValueNull() VpnPathsValue {
	return VpnPathsValue{
		state: attr.ValueStateNull,
	}
}

func NewVpnPathsValueUnknown() VpnPathsValue {
	return VpnPathsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewVpnPathsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (VpnPathsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing VpnPathsValue Attribute Value",
				"While creating a VpnPathsValue value, a missing attribute value was detected. "+
					"A VpnPathsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VpnPathsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid VpnPathsValue Attribute Type",
				"While creating a VpnPathsValue value, an invalid attribute value was detected. "+
					"A VpnPathsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VpnPathsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("VpnPathsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra VpnPathsValue Attribute Value",
				"While creating a VpnPathsValue value, an extra attribute value was detected. "+
					"A VpnPathsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra VpnPathsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewVpnPathsValueUnknown(), diags
	}

	bfdProfileAttribute, ok := attributes["bfd_profile"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bfd_profile is missing from object`)

		return NewVpnPathsValueUnknown(), diags
	}

	bfdProfileVal, ok := bfdProfileAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bfd_profile expected to be basetypes.StringValue, was: %T`, bfdProfileAttribute))
	}

	bfdUseTunnelModeAttribute, ok := attributes["bfd_use_tunnel_mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bfd_use_tunnel_mode is missing from object`)

		return NewVpnPathsValueUnknown(), diags
	}

	bfdUseTunnelModeVal, ok := bfdUseTunnelModeAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bfd_use_tunnel_mode expected to be basetypes.BoolValue, was: %T`, bfdUseTunnelModeAttribute))
	}

	preferenceAttribute, ok := attributes["preference"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`preference is missing from object`)

		return NewVpnPathsValueUnknown(), diags
	}

	preferenceVal, ok := preferenceAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`preference expected to be basetypes.Int64Value, was: %T`, preferenceAttribute))
	}

	roleAttribute, ok := attributes["role"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`role is missing from object`)

		return NewVpnPathsValueUnknown(), diags
	}

	roleVal, ok := roleAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`role expected to be basetypes.StringValue, was: %T`, roleAttribute))
	}

	trafficShapingAttribute, ok := attributes["traffic_shaping"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`traffic_shaping is missing from object`)

		return NewVpnPathsValueUnknown(), diags
	}

	trafficShapingVal, ok := trafficShapingAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`traffic_shaping expected to be basetypes.ObjectValue, was: %T`, trafficShapingAttribute))
	}

	if diags.HasError() {
		return NewVpnPathsValueUnknown(), diags
	}

	return VpnPathsValue{
		BfdProfile:       bfdProfileVal,
		BfdUseTunnelMode: bfdUseTunnelModeVal,
		Preference:       preferenceVal,
		Role:             roleVal,
		TrafficShaping:   trafficShapingVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewVpnPathsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) VpnPathsValue {
	object, diags := NewVpnPathsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewVpnPathsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t VpnPathsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewVpnPathsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewVpnPathsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewVpnPathsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewVpnPathsValueMust(VpnPathsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t VpnPathsType) ValueType(ctx context.Context) attr.Value {
	return VpnPathsValue{}
}

var _ basetypes.ObjectValuable = VpnPathsValue{}

type VpnPathsValue struct {
	BfdProfile       basetypes.StringValue `tfsdk:"bfd_profile"`
	BfdUseTunnelMode basetypes.BoolValue   `tfsdk:"bfd_use_tunnel_mode"`
	Preference       basetypes.Int64Value  `tfsdk:"preference"`
	Role             basetypes.StringValue `tfsdk:"role"`
	TrafficShaping   basetypes.ObjectValue `tfsdk:"traffic_shaping"`
	state            attr.ValueState
}

func (v VpnPathsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["bfd_profile"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["bfd_use_tunnel_mode"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["preference"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["role"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["traffic_shaping"] = basetypes.ObjectType{
		AttrTypes: TrafficShapingValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.BfdProfile.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bfd_profile"] = val

		val, err = v.BfdUseTunnelMode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bfd_use_tunnel_mode"] = val

		val, err = v.Preference.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["preference"] = val

		val, err = v.Role.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["role"] = val

		val, err = v.TrafficShaping.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["traffic_shaping"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v VpnPathsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v VpnPathsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v VpnPathsValue) String() string {
	return "VpnPathsValue"
}

func (v VpnPathsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var trafficShaping basetypes.ObjectValue

	if v.TrafficShaping.IsNull() {
		trafficShaping = types.ObjectNull(
			TrafficShapingValue{}.AttributeTypes(ctx),
		)
	}

	if v.TrafficShaping.IsUnknown() {
		trafficShaping = types.ObjectUnknown(
			TrafficShapingValue{}.AttributeTypes(ctx),
		)
	}

	if !v.TrafficShaping.IsNull() && !v.TrafficShaping.IsUnknown() {
		trafficShaping = types.ObjectValueMust(
			TrafficShapingValue{}.AttributeTypes(ctx),
			v.TrafficShaping.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"bfd_profile":         basetypes.StringType{},
		"bfd_use_tunnel_mode": basetypes.BoolType{},
		"preference":          basetypes.Int64Type{},
		"role":                basetypes.StringType{},
		"traffic_shaping": basetypes.ObjectType{
			AttrTypes: TrafficShapingValue{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"bfd_profile":         v.BfdProfile,
			"bfd_use_tunnel_mode": v.BfdUseTunnelMode,
			"preference":          v.Preference,
			"role":                v.Role,
			"traffic_shaping":     trafficShaping,
		})

	return objVal, diags
}

func (v VpnPathsValue) Equal(o attr.Value) bool {
	other, ok := o.(VpnPathsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.BfdProfile.Equal(other.BfdProfile) {
		return false
	}

	if !v.BfdUseTunnelMode.Equal(other.BfdUseTunnelMode) {
		return false
	}

	if !v.Preference.Equal(other.Preference) {
		return false
	}

	if !v.Role.Equal(other.Role) {
		return false
	}

	if !v.TrafficShaping.Equal(other.TrafficShaping) {
		return false
	}

	return true
}

func (v VpnPathsValue) Type(ctx context.Context) attr.Type {
	return VpnPathsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v VpnPathsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"bfd_profile":         basetypes.StringType{},
		"bfd_use_tunnel_mode": basetypes.BoolType{},
		"preference":          basetypes.Int64Type{},
		"role":                basetypes.StringType{},
		"traffic_shaping": basetypes.ObjectType{
			AttrTypes: TrafficShapingValue{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = WanExtraRoutesType{}

type WanExtraRoutesType struct {
	basetypes.ObjectType
}

func (t WanExtraRoutesType) Equal(o attr.Type) bool {
	other, ok := o.(WanExtraRoutesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t WanExtraRoutesType) String() string {
	return "WanExtraRoutesType"
}

func (t WanExtraRoutesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	viaAttribute, ok := attributes["via"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`via is missing from object`)

		return nil, diags
	}

	viaVal, ok := viaAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`via expected to be basetypes.StringValue, was: %T`, viaAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return WanExtraRoutesValue{
		Via:   viaVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewWanExtraRoutesValueNull() WanExtraRoutesValue {
	return WanExtraRoutesValue{
		state: attr.ValueStateNull,
	}
}

func NewWanExtraRoutesValueUnknown() WanExtraRoutesValue {
	return WanExtraRoutesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewWanExtraRoutesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (WanExtraRoutesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing WanExtraRoutesValue Attribute Value",
				"While creating a WanExtraRoutesValue value, a missing attribute value was detected. "+
					"A WanExtraRoutesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("WanExtraRoutesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid WanExtraRoutesValue Attribute Type",
				"While creating a WanExtraRoutesValue value, an invalid attribute value was detected. "+
					"A WanExtraRoutesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("WanExtraRoutesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("WanExtraRoutesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra WanExtraRoutesValue Attribute Value",
				"While creating a WanExtraRoutesValue value, an extra attribute value was detected. "+
					"A WanExtraRoutesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra WanExtraRoutesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewWanExtraRoutesValueUnknown(), diags
	}

	viaAttribute, ok := attributes["via"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`via is missing from object`)

		return NewWanExtraRoutesValueUnknown(), diags
	}

	viaVal, ok := viaAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`via expected to be basetypes.StringValue, was: %T`, viaAttribute))
	}

	if diags.HasError() {
		return NewWanExtraRoutesValueUnknown(), diags
	}

	return WanExtraRoutesValue{
		Via:   viaVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewWanExtraRoutesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) WanExtraRoutesValue {
	object, diags := NewWanExtraRoutesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewWanExtraRoutesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t WanExtraRoutesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewWanExtraRoutesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewWanExtraRoutesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewWanExtraRoutesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewWanExtraRoutesValueMust(WanExtraRoutesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t WanExtraRoutesType) ValueType(ctx context.Context) attr.Value {
	return WanExtraRoutesValue{}
}

var _ basetypes.ObjectValuable = WanExtraRoutesValue{}

type WanExtraRoutesValue struct {
	Via   basetypes.StringValue `tfsdk:"via"`
	state attr.ValueState
}

func (v WanExtraRoutesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["via"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Via.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["via"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v WanExtraRoutesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v WanExtraRoutesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v WanExtraRoutesValue) String() string {
	return "WanExtraRoutesValue"
}

func (v WanExtraRoutesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"via": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"via": v.Via,
		})

	return objVal, diags
}

func (v WanExtraRoutesValue) Equal(o attr.Value) bool {
	other, ok := o.(WanExtraRoutesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Via.Equal(other.Via) {
		return false
	}

	return true
}

func (v WanExtraRoutesValue) Type(ctx context.Context) attr.Type {
	return WanExtraRoutesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v WanExtraRoutesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"via": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = WanProbeOverrideType{}

type WanProbeOverrideType struct {
	basetypes.ObjectType
}

func (t WanProbeOverrideType) Equal(o attr.Type) bool {
	other, ok := o.(WanProbeOverrideType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t WanProbeOverrideType) String() string {
	return "WanProbeOverrideType"
}

func (t WanProbeOverrideType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	ipsAttribute, ok := attributes["ips"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ips is missing from object`)

		return nil, diags
	}

	ipsVal, ok := ipsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ips expected to be basetypes.ListValue, was: %T`, ipsAttribute))
	}

	probeProfileAttribute, ok := attributes["probe_profile"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`probe_profile is missing from object`)

		return nil, diags
	}

	probeProfileVal, ok := probeProfileAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`probe_profile expected to be basetypes.StringValue, was: %T`, probeProfileAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return WanProbeOverrideValue{
		Ips:          ipsVal,
		ProbeProfile: probeProfileVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewWanProbeOverrideValueNull() WanProbeOverrideValue {
	return WanProbeOverrideValue{
		state: attr.ValueStateNull,
	}
}

func NewWanProbeOverrideValueUnknown() WanProbeOverrideValue {
	return WanProbeOverrideValue{
		state: attr.ValueStateUnknown,
	}
}

func NewWanProbeOverrideValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (WanProbeOverrideValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing WanProbeOverrideValue Attribute Value",
				"While creating a WanProbeOverrideValue value, a missing attribute value was detected. "+
					"A WanProbeOverrideValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("WanProbeOverrideValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid WanProbeOverrideValue Attribute Type",
				"While creating a WanProbeOverrideValue value, an invalid attribute value was detected. "+
					"A WanProbeOverrideValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("WanProbeOverrideValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("WanProbeOverrideValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra WanProbeOverrideValue Attribute Value",
				"While creating a WanProbeOverrideValue value, an extra attribute value was detected. "+
					"A WanProbeOverrideValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra WanProbeOverrideValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewWanProbeOverrideValueUnknown(), diags
	}

	ipsAttribute, ok := attributes["ips"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ips is missing from object`)

		return NewWanProbeOverrideValueUnknown(), diags
	}

	ipsVal, ok := ipsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ips expected to be basetypes.ListValue, was: %T`, ipsAttribute))
	}

	probeProfileAttribute, ok := attributes["probe_profile"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`probe_profile is missing from object`)

		return NewWanProbeOverrideValueUnknown(), diags
	}

	probeProfileVal, ok := probeProfileAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`probe_profile expected to be basetypes.StringValue, was: %T`, probeProfileAttribute))
	}

	if diags.HasError() {
		return NewWanProbeOverrideValueUnknown(), diags
	}

	return WanProbeOverrideValue{
		Ips:          ipsVal,
		ProbeProfile: probeProfileVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewWanProbeOverrideValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) WanProbeOverrideValue {
	object, diags := NewWanProbeOverrideValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewWanProbeOverrideValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t WanProbeOverrideType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewWanProbeOverrideValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewWanProbeOverrideValueUnknown(), nil
	}

	if in.IsNull() {
		return NewWanProbeOverrideValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewWanProbeOverrideValueMust(WanProbeOverrideValue{}.AttributeTypes(ctx), attributes), nil
}

func (t WanProbeOverrideType) ValueType(ctx context.Context) attr.Value {
	return WanProbeOverrideValue{}
}

var _ basetypes.ObjectValuable = WanProbeOverrideValue{}

type WanProbeOverrideValue struct {
	Ips          basetypes.ListValue   `tfsdk:"ips"`
	ProbeProfile basetypes.StringValue `tfsdk:"probe_profile"`
	state        attr.ValueState
}

func (v WanProbeOverrideValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["ips"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["probe_profile"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Ips.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ips"] = val

		val, err = v.ProbeProfile.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["probe_profile"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v WanProbeOverrideValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v WanProbeOverrideValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v WanProbeOverrideValue) String() string {
	return "WanProbeOverrideValue"
}

func (v WanProbeOverrideValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var ipsVal basetypes.ListValue
	switch {
	case v.Ips.IsUnknown():
		ipsVal = types.ListUnknown(types.StringType)
	case v.Ips.IsNull():
		ipsVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		ipsVal, d = types.ListValue(types.StringType, v.Ips.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"ips": basetypes.ListType{
				ElemType: types.StringType,
			},
			"probe_profile": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"ips": basetypes.ListType{
			ElemType: types.StringType,
		},
		"probe_profile": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"ips":           ipsVal,
			"probe_profile": v.ProbeProfile,
		})

	return objVal, diags
}

func (v WanProbeOverrideValue) Equal(o attr.Value) bool {
	other, ok := o.(WanProbeOverrideValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Ips.Equal(other.Ips) {
		return false
	}

	if !v.ProbeProfile.Equal(other.ProbeProfile) {
		return false
	}

	return true
}

func (v WanProbeOverrideValue) Type(ctx context.Context) attr.Type {
	return WanProbeOverrideType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v WanProbeOverrideValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"ips": basetypes.ListType{
			ElemType: types.StringType,
		},
		"probe_profile": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = WanSourceNatType{}

type WanSourceNatType struct {
	basetypes.ObjectType
}

func (t WanSourceNatType) Equal(o attr.Type) bool {
	other, ok := o.(WanSourceNatType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t WanSourceNatType) String() string {
	return "WanSourceNatType"
}

func (t WanSourceNatType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	disabledAttribute, ok := attributes["disabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disabled is missing from object`)

		return nil, diags
	}

	disabledVal, ok := disabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disabled expected to be basetypes.BoolValue, was: %T`, disabledAttribute))
	}

	natPoolAttribute, ok := attributes["nat_pool"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`nat_pool is missing from object`)

		return nil, diags
	}

	natPoolVal, ok := natPoolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`nat_pool expected to be basetypes.StringValue, was: %T`, natPoolAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return WanSourceNatValue{
		Disabled: disabledVal,
		NatPool:  natPoolVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewWanSourceNatValueNull() WanSourceNatValue {
	return WanSourceNatValue{
		state: attr.ValueStateNull,
	}
}

func NewWanSourceNatValueUnknown() WanSourceNatValue {
	return WanSourceNatValue{
		state: attr.ValueStateUnknown,
	}
}

func NewWanSourceNatValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (WanSourceNatValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing WanSourceNatValue Attribute Value",
				"While creating a WanSourceNatValue value, a missing attribute value was detected. "+
					"A WanSourceNatValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("WanSourceNatValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid WanSourceNatValue Attribute Type",
				"While creating a WanSourceNatValue value, an invalid attribute value was detected. "+
					"A WanSourceNatValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("WanSourceNatValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("WanSourceNatValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra WanSourceNatValue Attribute Value",
				"While creating a WanSourceNatValue value, an extra attribute value was detected. "+
					"A WanSourceNatValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra WanSourceNatValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewWanSourceNatValueUnknown(), diags
	}

	disabledAttribute, ok := attributes["disabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disabled is missing from object`)

		return NewWanSourceNatValueUnknown(), diags
	}

	disabledVal, ok := disabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disabled expected to be basetypes.BoolValue, was: %T`, disabledAttribute))
	}

	natPoolAttribute, ok := attributes["nat_pool"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`nat_pool is missing from object`)

		return NewWanSourceNatValueUnknown(), diags
	}

	natPoolVal, ok := natPoolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`nat_pool expected to be basetypes.StringValue, was: %T`, natPoolAttribute))
	}

	if diags.HasError() {
		return NewWanSourceNatValueUnknown(), diags
	}

	return WanSourceNatValue{
		Disabled: disabledVal,
		NatPool:  natPoolVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewWanSourceNatValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) WanSourceNatValue {
	object, diags := NewWanSourceNatValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewWanSourceNatValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t WanSourceNatType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewWanSourceNatValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewWanSourceNatValueUnknown(), nil
	}

	if in.IsNull() {
		return NewWanSourceNatValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewWanSourceNatValueMust(WanSourceNatValue{}.AttributeTypes(ctx), attributes), nil
}

func (t WanSourceNatType) ValueType(ctx context.Context) attr.Value {
	return WanSourceNatValue{}
}

var _ basetypes.ObjectValuable = WanSourceNatValue{}

type WanSourceNatValue struct {
	Disabled basetypes.BoolValue   `tfsdk:"disabled"`
	NatPool  basetypes.StringValue `tfsdk:"nat_pool"`
	state    attr.ValueState
}

func (v WanSourceNatValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["disabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["nat_pool"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Disabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["disabled"] = val

		val, err = v.NatPool.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["nat_pool"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v WanSourceNatValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v WanSourceNatValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v WanSourceNatValue) String() string {
	return "WanSourceNatValue"
}

func (v WanSourceNatValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"disabled": basetypes.BoolType{},
		"nat_pool": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"disabled": v.Disabled,
			"nat_pool": v.NatPool,
		})

	return objVal, diags
}

func (v WanSourceNatValue) Equal(o attr.Value) bool {
	other, ok := o.(WanSourceNatValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Disabled.Equal(other.Disabled) {
		return false
	}

	if !v.NatPool.Equal(other.NatPool) {
		return false
	}

	return true
}

func (v WanSourceNatValue) Type(ctx context.Context) attr.Type {
	return WanSourceNatType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v WanSourceNatValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"disabled": basetypes.BoolType{},
		"nat_pool": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = PortMirroringType{}

type PortMirroringType struct {
	basetypes.ObjectType
}

func (t PortMirroringType) Equal(o attr.Type) bool {
	other, ok := o.(PortMirroringType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PortMirroringType) String() string {
	return "PortMirroringType"
}

func (t PortMirroringType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	portMirrorAttribute, ok := attributes["port_mirror"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_mirror is missing from object`)

		return nil, diags
	}

	portMirrorVal, ok := portMirrorAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_mirror expected to be basetypes.ObjectValue, was: %T`, portMirrorAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PortMirroringValue{
		PortMirror: portMirrorVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewPortMirroringValueNull() PortMirroringValue {
	return PortMirroringValue{
		state: attr.ValueStateNull,
	}
}

func NewPortMirroringValueUnknown() PortMirroringValue {
	return PortMirroringValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPortMirroringValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PortMirroringValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PortMirroringValue Attribute Value",
				"While creating a PortMirroringValue value, a missing attribute value was detected. "+
					"A PortMirroringValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PortMirroringValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PortMirroringValue Attribute Type",
				"While creating a PortMirroringValue value, an invalid attribute value was detected. "+
					"A PortMirroringValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PortMirroringValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PortMirroringValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PortMirroringValue Attribute Value",
				"While creating a PortMirroringValue value, an extra attribute value was detected. "+
					"A PortMirroringValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PortMirroringValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPortMirroringValueUnknown(), diags
	}

	portMirrorAttribute, ok := attributes["port_mirror"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_mirror is missing from object`)

		return NewPortMirroringValueUnknown(), diags
	}

	portMirrorVal, ok := portMirrorAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_mirror expected to be basetypes.ObjectValue, was: %T`, portMirrorAttribute))
	}

	if diags.HasError() {
		return NewPortMirroringValueUnknown(), diags
	}

	return PortMirroringValue{
		PortMirror: portMirrorVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewPortMirroringValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PortMirroringValue {
	object, diags := NewPortMirroringValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPortMirroringValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PortMirroringType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPortMirroringValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPortMirroringValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPortMirroringValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPortMirroringValueMust(PortMirroringValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PortMirroringType) ValueType(ctx context.Context) attr.Value {
	return PortMirroringValue{}
}

var _ basetypes.ObjectValuable = PortMirroringValue{}

type PortMirroringValue struct {
	PortMirror basetypes.ObjectValue `tfsdk:"port_mirror"`
	state      attr.ValueState
}

func (v PortMirroringValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["port_mirror"] = basetypes.ObjectType{
		AttrTypes: PortMirrorValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.PortMirror.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port_mirror"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PortMirroringValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PortMirroringValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PortMirroringValue) String() string {
	return "PortMirroringValue"
}

func (v PortMirroringValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var portMirror basetypes.ObjectValue

	if v.PortMirror.IsNull() {
		portMirror = types.ObjectNull(
			PortMirrorValue{}.AttributeTypes(ctx),
		)
	}

	if v.PortMirror.IsUnknown() {
		portMirror = types.ObjectUnknown(
			PortMirrorValue{}.AttributeTypes(ctx),
		)
	}

	if !v.PortMirror.IsNull() && !v.PortMirror.IsUnknown() {
		portMirror = types.ObjectValueMust(
			PortMirrorValue{}.AttributeTypes(ctx),
			v.PortMirror.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"port_mirror": basetypes.ObjectType{
			AttrTypes: PortMirrorValue{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"port_mirror": portMirror,
		})

	return objVal, diags
}

func (v PortMirroringValue) Equal(o attr.Value) bool {
	other, ok := o.(PortMirroringValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.PortMirror.Equal(other.PortMirror) {
		return false
	}

	return true
}

func (v PortMirroringValue) Type(ctx context.Context) attr.Type {
	return PortMirroringType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PortMirroringValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"port_mirror": basetypes.ObjectType{
			AttrTypes: PortMirrorValue{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = PortMirrorType{}

type PortMirrorType struct {
	basetypes.ObjectType
}

func (t PortMirrorType) Equal(o attr.Type) bool {
	other, ok := o.(PortMirrorType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PortMirrorType) String() string {
	return "PortMirrorType"
}

func (t PortMirrorType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	familyTypeAttribute, ok := attributes["family_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`family_type is missing from object`)

		return nil, diags
	}

	familyTypeVal, ok := familyTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`family_type expected to be basetypes.StringValue, was: %T`, familyTypeAttribute))
	}

	ingressPortIdsAttribute, ok := attributes["ingress_port_ids"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ingress_port_ids is missing from object`)

		return nil, diags
	}

	ingressPortIdsVal, ok := ingressPortIdsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ingress_port_ids expected to be basetypes.ListValue, was: %T`, ingressPortIdsAttribute))
	}

	outputPortIdAttribute, ok := attributes["output_port_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`output_port_id is missing from object`)

		return nil, diags
	}

	outputPortIdVal, ok := outputPortIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`output_port_id expected to be basetypes.StringValue, was: %T`, outputPortIdAttribute))
	}

	rateAttribute, ok := attributes["rate"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rate is missing from object`)

		return nil, diags
	}

	rateVal, ok := rateAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rate expected to be basetypes.Int64Value, was: %T`, rateAttribute))
	}

	runLengthAttribute, ok := attributes["run_length"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`run_length is missing from object`)

		return nil, diags
	}

	runLengthVal, ok := runLengthAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`run_length expected to be basetypes.Int64Value, was: %T`, runLengthAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PortMirrorValue{
		FamilyType:     familyTypeVal,
		IngressPortIds: ingressPortIdsVal,
		OutputPortId:   outputPortIdVal,
		Rate:           rateVal,
		RunLength:      runLengthVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewPortMirrorValueNull() PortMirrorValue {
	return PortMirrorValue{
		state: attr.ValueStateNull,
	}
}

func NewPortMirrorValueUnknown() PortMirrorValue {
	return PortMirrorValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPortMirrorValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PortMirrorValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PortMirrorValue Attribute Value",
				"While creating a PortMirrorValue value, a missing attribute value was detected. "+
					"A PortMirrorValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PortMirrorValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PortMirrorValue Attribute Type",
				"While creating a PortMirrorValue value, an invalid attribute value was detected. "+
					"A PortMirrorValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PortMirrorValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PortMirrorValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PortMirrorValue Attribute Value",
				"While creating a PortMirrorValue value, an extra attribute value was detected. "+
					"A PortMirrorValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PortMirrorValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPortMirrorValueUnknown(), diags
	}

	familyTypeAttribute, ok := attributes["family_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`family_type is missing from object`)

		return NewPortMirrorValueUnknown(), diags
	}

	familyTypeVal, ok := familyTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`family_type expected to be basetypes.StringValue, was: %T`, familyTypeAttribute))
	}

	ingressPortIdsAttribute, ok := attributes["ingress_port_ids"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ingress_port_ids is missing from object`)

		return NewPortMirrorValueUnknown(), diags
	}

	ingressPortIdsVal, ok := ingressPortIdsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ingress_port_ids expected to be basetypes.ListValue, was: %T`, ingressPortIdsAttribute))
	}

	outputPortIdAttribute, ok := attributes["output_port_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`output_port_id is missing from object`)

		return NewPortMirrorValueUnknown(), diags
	}

	outputPortIdVal, ok := outputPortIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`output_port_id expected to be basetypes.StringValue, was: %T`, outputPortIdAttribute))
	}

	rateAttribute, ok := attributes["rate"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rate is missing from object`)

		return NewPortMirrorValueUnknown(), diags
	}

	rateVal, ok := rateAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rate expected to be basetypes.Int64Value, was: %T`, rateAttribute))
	}

	runLengthAttribute, ok := attributes["run_length"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`run_length is missing from object`)

		return NewPortMirrorValueUnknown(), diags
	}

	runLengthVal, ok := runLengthAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`run_length expected to be basetypes.Int64Value, was: %T`, runLengthAttribute))
	}

	if diags.HasError() {
		return NewPortMirrorValueUnknown(), diags
	}

	return PortMirrorValue{
		FamilyType:     familyTypeVal,
		IngressPortIds: ingressPortIdsVal,
		OutputPortId:   outputPortIdVal,
		Rate:           rateVal,
		RunLength:      runLengthVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewPortMirrorValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PortMirrorValue {
	object, diags := NewPortMirrorValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPortMirrorValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PortMirrorType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPortMirrorValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPortMirrorValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPortMirrorValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPortMirrorValueMust(PortMirrorValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PortMirrorType) ValueType(ctx context.Context) attr.Value {
	return PortMirrorValue{}
}

var _ basetypes.ObjectValuable = PortMirrorValue{}

type PortMirrorValue struct {
	FamilyType     basetypes.StringValue `tfsdk:"family_type"`
	IngressPortIds basetypes.ListValue   `tfsdk:"ingress_port_ids"`
	OutputPortId   basetypes.StringValue `tfsdk:"output_port_id"`
	Rate           basetypes.Int64Value  `tfsdk:"rate"`
	RunLength      basetypes.Int64Value  `tfsdk:"run_length"`
	state          attr.ValueState
}

func (v PortMirrorValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["family_type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ingress_port_ids"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["output_port_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["rate"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["run_length"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.FamilyType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["family_type"] = val

		val, err = v.IngressPortIds.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ingress_port_ids"] = val

		val, err = v.OutputPortId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["output_port_id"] = val

		val, err = v.Rate.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["rate"] = val

		val, err = v.RunLength.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["run_length"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PortMirrorValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PortMirrorValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PortMirrorValue) String() string {
	return "PortMirrorValue"
}

func (v PortMirrorValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var ingressPortIdsVal basetypes.ListValue
	switch {
	case v.IngressPortIds.IsUnknown():
		ingressPortIdsVal = types.ListUnknown(types.StringType)
	case v.IngressPortIds.IsNull():
		ingressPortIdsVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		ingressPortIdsVal, d = types.ListValue(types.StringType, v.IngressPortIds.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"family_type": basetypes.StringType{},
			"ingress_port_ids": basetypes.ListType{
				ElemType: types.StringType,
			},
			"output_port_id": basetypes.StringType{},
			"rate":           basetypes.Int64Type{},
			"run_length":     basetypes.Int64Type{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"family_type": basetypes.StringType{},
		"ingress_port_ids": basetypes.ListType{
			ElemType: types.StringType,
		},
		"output_port_id": basetypes.StringType{},
		"rate":           basetypes.Int64Type{},
		"run_length":     basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"family_type":      v.FamilyType,
			"ingress_port_ids": ingressPortIdsVal,
			"output_port_id":   v.OutputPortId,
			"rate":             v.Rate,
			"run_length":       v.RunLength,
		})

	return objVal, diags
}

func (v PortMirrorValue) Equal(o attr.Value) bool {
	other, ok := o.(PortMirrorValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.FamilyType.Equal(other.FamilyType) {
		return false
	}

	if !v.IngressPortIds.Equal(other.IngressPortIds) {
		return false
	}

	if !v.OutputPortId.Equal(other.OutputPortId) {
		return false
	}

	if !v.Rate.Equal(other.Rate) {
		return false
	}

	if !v.RunLength.Equal(other.RunLength) {
		return false
	}

	return true
}

func (v PortMirrorValue) Type(ctx context.Context) attr.Type {
	return PortMirrorType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PortMirrorValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"family_type": basetypes.StringType{},
		"ingress_port_ids": basetypes.ListType{
			ElemType: types.StringType,
		},
		"output_port_id": basetypes.StringType{},
		"rate":           basetypes.Int64Type{},
		"run_length":     basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = RoutingPoliciesType{}

type RoutingPoliciesType struct {
	basetypes.ObjectType
}

func (t RoutingPoliciesType) Equal(o attr.Type) bool {
	other, ok := o.(RoutingPoliciesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t RoutingPoliciesType) String() string {
	return "RoutingPoliciesType"
}

func (t RoutingPoliciesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	termsAttribute, ok := attributes["terms"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`terms is missing from object`)

		return nil, diags
	}

	termsVal, ok := termsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`terms expected to be basetypes.ListValue, was: %T`, termsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return RoutingPoliciesValue{
		Terms: termsVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewRoutingPoliciesValueNull() RoutingPoliciesValue {
	return RoutingPoliciesValue{
		state: attr.ValueStateNull,
	}
}

func NewRoutingPoliciesValueUnknown() RoutingPoliciesValue {
	return RoutingPoliciesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewRoutingPoliciesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (RoutingPoliciesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing RoutingPoliciesValue Attribute Value",
				"While creating a RoutingPoliciesValue value, a missing attribute value was detected. "+
					"A RoutingPoliciesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RoutingPoliciesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid RoutingPoliciesValue Attribute Type",
				"While creating a RoutingPoliciesValue value, an invalid attribute value was detected. "+
					"A RoutingPoliciesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RoutingPoliciesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("RoutingPoliciesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra RoutingPoliciesValue Attribute Value",
				"While creating a RoutingPoliciesValue value, an extra attribute value was detected. "+
					"A RoutingPoliciesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra RoutingPoliciesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewRoutingPoliciesValueUnknown(), diags
	}

	termsAttribute, ok := attributes["terms"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`terms is missing from object`)

		return NewRoutingPoliciesValueUnknown(), diags
	}

	termsVal, ok := termsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`terms expected to be basetypes.ListValue, was: %T`, termsAttribute))
	}

	if diags.HasError() {
		return NewRoutingPoliciesValueUnknown(), diags
	}

	return RoutingPoliciesValue{
		Terms: termsVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewRoutingPoliciesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) RoutingPoliciesValue {
	object, diags := NewRoutingPoliciesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewRoutingPoliciesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t RoutingPoliciesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewRoutingPoliciesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewRoutingPoliciesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewRoutingPoliciesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewRoutingPoliciesValueMust(RoutingPoliciesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t RoutingPoliciesType) ValueType(ctx context.Context) attr.Value {
	return RoutingPoliciesValue{}
}

var _ basetypes.ObjectValuable = RoutingPoliciesValue{}

type RoutingPoliciesValue struct {
	Terms basetypes.ListValue `tfsdk:"terms"`
	state attr.ValueState
}

func (v RoutingPoliciesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["terms"] = basetypes.ListType{
		ElemType: TermsValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Terms.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["terms"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v RoutingPoliciesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v RoutingPoliciesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v RoutingPoliciesValue) String() string {
	return "RoutingPoliciesValue"
}

func (v RoutingPoliciesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	terms := types.ListValueMust(
		TermsType{
			basetypes.ObjectType{
				AttrTypes: TermsValue{}.AttributeTypes(ctx),
			},
		},
		v.Terms.Elements(),
	)

	if v.Terms.IsNull() {
		terms = types.ListNull(
			TermsType{
				basetypes.ObjectType{
					AttrTypes: TermsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Terms.IsUnknown() {
		terms = types.ListUnknown(
			TermsType{
				basetypes.ObjectType{
					AttrTypes: TermsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"terms": basetypes.ListType{
			ElemType: TermsValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"terms": terms,
		})

	return objVal, diags
}

func (v RoutingPoliciesValue) Equal(o attr.Value) bool {
	other, ok := o.(RoutingPoliciesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Terms.Equal(other.Terms) {
		return false
	}

	return true
}

func (v RoutingPoliciesValue) Type(ctx context.Context) attr.Type {
	return RoutingPoliciesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v RoutingPoliciesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"terms": basetypes.ListType{
			ElemType: TermsValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = TermsType{}

type TermsType struct {
	basetypes.ObjectType
}

func (t TermsType) Equal(o attr.Type) bool {
	other, ok := o.(TermsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t TermsType) String() string {
	return "TermsType"
}

func (t TermsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	actionAttribute, ok := attributes["action"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`action is missing from object`)

		return nil, diags
	}

	actionVal, ok := actionAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`action expected to be basetypes.ObjectValue, was: %T`, actionAttribute))
	}

	routingPolicyTermMatchingAttribute, ok := attributes["matching"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`matching is missing from object`)

		return nil, diags
	}

	routingPolicyTermMatchingVal, ok := routingPolicyTermMatchingAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`matching expected to be basetypes.ObjectValue, was: %T`, routingPolicyTermMatchingAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return TermsValue{
		Action:                    actionVal,
		RoutingPolicyTermMatching: routingPolicyTermMatchingVal,
		state:                     attr.ValueStateKnown,
	}, diags
}

func NewTermsValueNull() TermsValue {
	return TermsValue{
		state: attr.ValueStateNull,
	}
}

func NewTermsValueUnknown() TermsValue {
	return TermsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewTermsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (TermsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing TermsValue Attribute Value",
				"While creating a TermsValue value, a missing attribute value was detected. "+
					"A TermsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TermsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid TermsValue Attribute Type",
				"While creating a TermsValue value, an invalid attribute value was detected. "+
					"A TermsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TermsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("TermsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra TermsValue Attribute Value",
				"While creating a TermsValue value, an extra attribute value was detected. "+
					"A TermsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra TermsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewTermsValueUnknown(), diags
	}

	actionAttribute, ok := attributes["action"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`action is missing from object`)

		return NewTermsValueUnknown(), diags
	}

	actionVal, ok := actionAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`action expected to be basetypes.ObjectValue, was: %T`, actionAttribute))
	}

	routingPolicyTermMatchingAttribute, ok := attributes["matching"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`matching is missing from object`)

		return NewTermsValueUnknown(), diags
	}

	routingPolicyTermMatchingVal, ok := routingPolicyTermMatchingAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`matching expected to be basetypes.ObjectValue, was: %T`, routingPolicyTermMatchingAttribute))
	}

	if diags.HasError() {
		return NewTermsValueUnknown(), diags
	}

	return TermsValue{
		Action:                    actionVal,
		RoutingPolicyTermMatching: routingPolicyTermMatchingVal,
		state:                     attr.ValueStateKnown,
	}, diags
}

func NewTermsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) TermsValue {
	object, diags := NewTermsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewTermsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t TermsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewTermsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewTermsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewTermsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewTermsValueMust(TermsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t TermsType) ValueType(ctx context.Context) attr.Value {
	return TermsValue{}
}

var _ basetypes.ObjectValuable = TermsValue{}

type TermsValue struct {
	Action                    basetypes.ObjectValue `tfsdk:"action"`
	RoutingPolicyTermMatching basetypes.ObjectValue `tfsdk:"matching"`
	state                     attr.ValueState
}

func (v TermsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["action"] = basetypes.ObjectType{
		AttrTypes: ActionValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["matching"] = basetypes.ObjectType{
		AttrTypes: RoutingPolicyTermMatchingValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Action.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["action"] = val

		val, err = v.RoutingPolicyTermMatching.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["matching"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v TermsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v TermsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v TermsValue) String() string {
	return "TermsValue"
}

func (v TermsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var action basetypes.ObjectValue

	if v.Action.IsNull() {
		action = types.ObjectNull(
			ActionValue{}.AttributeTypes(ctx),
		)
	}

	if v.Action.IsUnknown() {
		action = types.ObjectUnknown(
			ActionValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Action.IsNull() && !v.Action.IsUnknown() {
		action = types.ObjectValueMust(
			ActionValue{}.AttributeTypes(ctx),
			v.Action.Attributes(),
		)
	}

	var routingPolicyTermMatching basetypes.ObjectValue

	if v.RoutingPolicyTermMatching.IsNull() {
		routingPolicyTermMatching = types.ObjectNull(
			RoutingPolicyTermMatchingValue{}.AttributeTypes(ctx),
		)
	}

	if v.RoutingPolicyTermMatching.IsUnknown() {
		routingPolicyTermMatching = types.ObjectUnknown(
			RoutingPolicyTermMatchingValue{}.AttributeTypes(ctx),
		)
	}

	if !v.RoutingPolicyTermMatching.IsNull() && !v.RoutingPolicyTermMatching.IsUnknown() {
		routingPolicyTermMatching = types.ObjectValueMust(
			RoutingPolicyTermMatchingValue{}.AttributeTypes(ctx),
			v.RoutingPolicyTermMatching.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"action": basetypes.ObjectType{
			AttrTypes: ActionValue{}.AttributeTypes(ctx),
		},
		"matching": basetypes.ObjectType{
			AttrTypes: RoutingPolicyTermMatchingValue{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"action":   action,
			"matching": routingPolicyTermMatching,
		})

	return objVal, diags
}

func (v TermsValue) Equal(o attr.Value) bool {
	other, ok := o.(TermsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Action.Equal(other.Action) {
		return false
	}

	if !v.RoutingPolicyTermMatching.Equal(other.RoutingPolicyTermMatching) {
		return false
	}

	return true
}

func (v TermsValue) Type(ctx context.Context) attr.Type {
	return TermsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v TermsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"action": basetypes.ObjectType{
			AttrTypes: ActionValue{}.AttributeTypes(ctx),
		},
		"matching": basetypes.ObjectType{
			AttrTypes: RoutingPolicyTermMatchingValue{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = ActionType{}

type ActionType struct {
	basetypes.ObjectType
}

func (t ActionType) Equal(o attr.Type) bool {
	other, ok := o.(ActionType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ActionType) String() string {
	return "ActionType"
}

func (t ActionType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	acceptAttribute, ok := attributes["accept"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`accept is missing from object`)

		return nil, diags
	}

	acceptVal, ok := acceptAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`accept expected to be basetypes.BoolValue, was: %T`, acceptAttribute))
	}

	addCommunityAttribute, ok := attributes["add_community"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`add_community is missing from object`)

		return nil, diags
	}

	addCommunityVal, ok := addCommunityAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`add_community expected to be basetypes.ListValue, was: %T`, addCommunityAttribute))
	}

	addTargetVrfsAttribute, ok := attributes["add_target_vrfs"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`add_target_vrfs is missing from object`)

		return nil, diags
	}

	addTargetVrfsVal, ok := addTargetVrfsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`add_target_vrfs expected to be basetypes.ListValue, was: %T`, addTargetVrfsAttribute))
	}

	communityAttribute, ok := attributes["community"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`community is missing from object`)

		return nil, diags
	}

	communityVal, ok := communityAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`community expected to be basetypes.ListValue, was: %T`, communityAttribute))
	}

	excludeAsPathAttribute, ok := attributes["exclude_as_path"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`exclude_as_path is missing from object`)

		return nil, diags
	}

	excludeAsPathVal, ok := excludeAsPathAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`exclude_as_path expected to be basetypes.ListValue, was: %T`, excludeAsPathAttribute))
	}

	excludeCommunityAttribute, ok := attributes["exclude_community"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`exclude_community is missing from object`)

		return nil, diags
	}

	excludeCommunityVal, ok := excludeCommunityAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`exclude_community expected to be basetypes.ListValue, was: %T`, excludeCommunityAttribute))
	}

	exportCommunitiesAttribute, ok := attributes["export_communities"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`export_communities is missing from object`)

		return nil, diags
	}

	exportCommunitiesVal, ok := exportCommunitiesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`export_communities expected to be basetypes.ListValue, was: %T`, exportCommunitiesAttribute))
	}

	localPreferenceAttribute, ok := attributes["local_preference"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`local_preference is missing from object`)

		return nil, diags
	}

	localPreferenceVal, ok := localPreferenceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`local_preference expected to be basetypes.StringValue, was: %T`, localPreferenceAttribute))
	}

	prependAsPathAttribute, ok := attributes["prepend_as_path"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prepend_as_path is missing from object`)

		return nil, diags
	}

	prependAsPathVal, ok := prependAsPathAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prepend_as_path expected to be basetypes.ListValue, was: %T`, prependAsPathAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ActionValue{
		Accept:            acceptVal,
		AddCommunity:      addCommunityVal,
		AddTargetVrfs:     addTargetVrfsVal,
		Community:         communityVal,
		ExcludeAsPath:     excludeAsPathVal,
		ExcludeCommunity:  excludeCommunityVal,
		ExportCommunities: exportCommunitiesVal,
		LocalPreference:   localPreferenceVal,
		PrependAsPath:     prependAsPathVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewActionValueNull() ActionValue {
	return ActionValue{
		state: attr.ValueStateNull,
	}
}

func NewActionValueUnknown() ActionValue {
	return ActionValue{
		state: attr.ValueStateUnknown,
	}
}

func NewActionValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ActionValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ActionValue Attribute Value",
				"While creating a ActionValue value, a missing attribute value was detected. "+
					"A ActionValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ActionValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ActionValue Attribute Type",
				"While creating a ActionValue value, an invalid attribute value was detected. "+
					"A ActionValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ActionValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ActionValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ActionValue Attribute Value",
				"While creating a ActionValue value, an extra attribute value was detected. "+
					"A ActionValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ActionValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewActionValueUnknown(), diags
	}

	acceptAttribute, ok := attributes["accept"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`accept is missing from object`)

		return NewActionValueUnknown(), diags
	}

	acceptVal, ok := acceptAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`accept expected to be basetypes.BoolValue, was: %T`, acceptAttribute))
	}

	addCommunityAttribute, ok := attributes["add_community"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`add_community is missing from object`)

		return NewActionValueUnknown(), diags
	}

	addCommunityVal, ok := addCommunityAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`add_community expected to be basetypes.ListValue, was: %T`, addCommunityAttribute))
	}

	addTargetVrfsAttribute, ok := attributes["add_target_vrfs"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`add_target_vrfs is missing from object`)

		return NewActionValueUnknown(), diags
	}

	addTargetVrfsVal, ok := addTargetVrfsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`add_target_vrfs expected to be basetypes.ListValue, was: %T`, addTargetVrfsAttribute))
	}

	communityAttribute, ok := attributes["community"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`community is missing from object`)

		return NewActionValueUnknown(), diags
	}

	communityVal, ok := communityAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`community expected to be basetypes.ListValue, was: %T`, communityAttribute))
	}

	excludeAsPathAttribute, ok := attributes["exclude_as_path"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`exclude_as_path is missing from object`)

		return NewActionValueUnknown(), diags
	}

	excludeAsPathVal, ok := excludeAsPathAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`exclude_as_path expected to be basetypes.ListValue, was: %T`, excludeAsPathAttribute))
	}

	excludeCommunityAttribute, ok := attributes["exclude_community"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`exclude_community is missing from object`)

		return NewActionValueUnknown(), diags
	}

	excludeCommunityVal, ok := excludeCommunityAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`exclude_community expected to be basetypes.ListValue, was: %T`, excludeCommunityAttribute))
	}

	exportCommunitiesAttribute, ok := attributes["export_communities"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`export_communities is missing from object`)

		return NewActionValueUnknown(), diags
	}

	exportCommunitiesVal, ok := exportCommunitiesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`export_communities expected to be basetypes.ListValue, was: %T`, exportCommunitiesAttribute))
	}

	localPreferenceAttribute, ok := attributes["local_preference"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`local_preference is missing from object`)

		return NewActionValueUnknown(), diags
	}

	localPreferenceVal, ok := localPreferenceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`local_preference expected to be basetypes.StringValue, was: %T`, localPreferenceAttribute))
	}

	prependAsPathAttribute, ok := attributes["prepend_as_path"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prepend_as_path is missing from object`)

		return NewActionValueUnknown(), diags
	}

	prependAsPathVal, ok := prependAsPathAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prepend_as_path expected to be basetypes.ListValue, was: %T`, prependAsPathAttribute))
	}

	if diags.HasError() {
		return NewActionValueUnknown(), diags
	}

	return ActionValue{
		Accept:            acceptVal,
		AddCommunity:      addCommunityVal,
		AddTargetVrfs:     addTargetVrfsVal,
		Community:         communityVal,
		ExcludeAsPath:     excludeAsPathVal,
		ExcludeCommunity:  excludeCommunityVal,
		ExportCommunities: exportCommunitiesVal,
		LocalPreference:   localPreferenceVal,
		PrependAsPath:     prependAsPathVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewActionValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ActionValue {
	object, diags := NewActionValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewActionValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ActionType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewActionValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewActionValueUnknown(), nil
	}

	if in.IsNull() {
		return NewActionValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewActionValueMust(ActionValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ActionType) ValueType(ctx context.Context) attr.Value {
	return ActionValue{}
}

var _ basetypes.ObjectValuable = ActionValue{}

type ActionValue struct {
	Accept            basetypes.BoolValue   `tfsdk:"accept"`
	AddCommunity      basetypes.ListValue   `tfsdk:"add_community"`
	AddTargetVrfs     basetypes.ListValue   `tfsdk:"add_target_vrfs"`
	Community         basetypes.ListValue   `tfsdk:"community"`
	ExcludeAsPath     basetypes.ListValue   `tfsdk:"exclude_as_path"`
	ExcludeCommunity  basetypes.ListValue   `tfsdk:"exclude_community"`
	ExportCommunities basetypes.ListValue   `tfsdk:"export_communities"`
	LocalPreference   basetypes.StringValue `tfsdk:"local_preference"`
	PrependAsPath     basetypes.ListValue   `tfsdk:"prepend_as_path"`
	state             attr.ValueState
}

func (v ActionValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 9)

	var val tftypes.Value
	var err error

	attrTypes["accept"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["add_community"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["add_target_vrfs"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["community"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["exclude_as_path"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["exclude_community"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["export_communities"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["local_preference"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["prepend_as_path"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 9)

		val, err = v.Accept.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["accept"] = val

		val, err = v.AddCommunity.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["add_community"] = val

		val, err = v.AddTargetVrfs.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["add_target_vrfs"] = val

		val, err = v.Community.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["community"] = val

		val, err = v.ExcludeAsPath.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["exclude_as_path"] = val

		val, err = v.ExcludeCommunity.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["exclude_community"] = val

		val, err = v.ExportCommunities.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["export_communities"] = val

		val, err = v.LocalPreference.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["local_preference"] = val

		val, err = v.PrependAsPath.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["prepend_as_path"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ActionValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ActionValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ActionValue) String() string {
	return "ActionValue"
}

func (v ActionValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var addCommunityVal basetypes.ListValue
	switch {
	case v.AddCommunity.IsUnknown():
		addCommunityVal = types.ListUnknown(types.StringType)
	case v.AddCommunity.IsNull():
		addCommunityVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		addCommunityVal, d = types.ListValue(types.StringType, v.AddCommunity.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"accept": basetypes.BoolType{},
			"add_community": basetypes.ListType{
				ElemType: types.StringType,
			},
			"add_target_vrfs": basetypes.ListType{
				ElemType: types.StringType,
			},
			"community": basetypes.ListType{
				ElemType: types.StringType,
			},
			"exclude_as_path": basetypes.ListType{
				ElemType: types.StringType,
			},
			"exclude_community": basetypes.ListType{
				ElemType: types.StringType,
			},
			"export_communities": basetypes.ListType{
				ElemType: types.StringType,
			},
			"local_preference": basetypes.StringType{},
			"prepend_as_path": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	var addTargetVrfsVal basetypes.ListValue
	switch {
	case v.AddTargetVrfs.IsUnknown():
		addTargetVrfsVal = types.ListUnknown(types.StringType)
	case v.AddTargetVrfs.IsNull():
		addTargetVrfsVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		addTargetVrfsVal, d = types.ListValue(types.StringType, v.AddTargetVrfs.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"accept": basetypes.BoolType{},
			"add_community": basetypes.ListType{
				ElemType: types.StringType,
			},
			"add_target_vrfs": basetypes.ListType{
				ElemType: types.StringType,
			},
			"community": basetypes.ListType{
				ElemType: types.StringType,
			},
			"exclude_as_path": basetypes.ListType{
				ElemType: types.StringType,
			},
			"exclude_community": basetypes.ListType{
				ElemType: types.StringType,
			},
			"export_communities": basetypes.ListType{
				ElemType: types.StringType,
			},
			"local_preference": basetypes.StringType{},
			"prepend_as_path": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	var communityVal basetypes.ListValue
	switch {
	case v.Community.IsUnknown():
		communityVal = types.ListUnknown(types.StringType)
	case v.Community.IsNull():
		communityVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		communityVal, d = types.ListValue(types.StringType, v.Community.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"accept": basetypes.BoolType{},
			"add_community": basetypes.ListType{
				ElemType: types.StringType,
			},
			"add_target_vrfs": basetypes.ListType{
				ElemType: types.StringType,
			},
			"community": basetypes.ListType{
				ElemType: types.StringType,
			},
			"exclude_as_path": basetypes.ListType{
				ElemType: types.StringType,
			},
			"exclude_community": basetypes.ListType{
				ElemType: types.StringType,
			},
			"export_communities": basetypes.ListType{
				ElemType: types.StringType,
			},
			"local_preference": basetypes.StringType{},
			"prepend_as_path": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	var excludeAsPathVal basetypes.ListValue
	switch {
	case v.ExcludeAsPath.IsUnknown():
		excludeAsPathVal = types.ListUnknown(types.StringType)
	case v.ExcludeAsPath.IsNull():
		excludeAsPathVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		excludeAsPathVal, d = types.ListValue(types.StringType, v.ExcludeAsPath.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"accept": basetypes.BoolType{},
			"add_community": basetypes.ListType{
				ElemType: types.StringType,
			},
			"add_target_vrfs": basetypes.ListType{
				ElemType: types.StringType,
			},
			"community": basetypes.ListType{
				ElemType: types.StringType,
			},
			"exclude_as_path": basetypes.ListType{
				ElemType: types.StringType,
			},
			"exclude_community": basetypes.ListType{
				ElemType: types.StringType,
			},
			"export_communities": basetypes.ListType{
				ElemType: types.StringType,
			},
			"local_preference": basetypes.StringType{},
			"prepend_as_path": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	var excludeCommunityVal basetypes.ListValue
	switch {
	case v.ExcludeCommunity.IsUnknown():
		excludeCommunityVal = types.ListUnknown(types.StringType)
	case v.ExcludeCommunity.IsNull():
		excludeCommunityVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		excludeCommunityVal, d = types.ListValue(types.StringType, v.ExcludeCommunity.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"accept": basetypes.BoolType{},
			"add_community": basetypes.ListType{
				ElemType: types.StringType,
			},
			"add_target_vrfs": basetypes.ListType{
				ElemType: types.StringType,
			},
			"community": basetypes.ListType{
				ElemType: types.StringType,
			},
			"exclude_as_path": basetypes.ListType{
				ElemType: types.StringType,
			},
			"exclude_community": basetypes.ListType{
				ElemType: types.StringType,
			},
			"export_communities": basetypes.ListType{
				ElemType: types.StringType,
			},
			"local_preference": basetypes.StringType{},
			"prepend_as_path": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	var exportCommunitiesVal basetypes.ListValue
	switch {
	case v.ExportCommunities.IsUnknown():
		exportCommunitiesVal = types.ListUnknown(types.StringType)
	case v.ExportCommunities.IsNull():
		exportCommunitiesVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		exportCommunitiesVal, d = types.ListValue(types.StringType, v.ExportCommunities.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"accept": basetypes.BoolType{},
			"add_community": basetypes.ListType{
				ElemType: types.StringType,
			},
			"add_target_vrfs": basetypes.ListType{
				ElemType: types.StringType,
			},
			"community": basetypes.ListType{
				ElemType: types.StringType,
			},
			"exclude_as_path": basetypes.ListType{
				ElemType: types.StringType,
			},
			"exclude_community": basetypes.ListType{
				ElemType: types.StringType,
			},
			"export_communities": basetypes.ListType{
				ElemType: types.StringType,
			},
			"local_preference": basetypes.StringType{},
			"prepend_as_path": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	var prependAsPathVal basetypes.ListValue
	switch {
	case v.PrependAsPath.IsUnknown():
		prependAsPathVal = types.ListUnknown(types.StringType)
	case v.PrependAsPath.IsNull():
		prependAsPathVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		prependAsPathVal, d = types.ListValue(types.StringType, v.PrependAsPath.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"accept": basetypes.BoolType{},
			"add_community": basetypes.ListType{
				ElemType: types.StringType,
			},
			"add_target_vrfs": basetypes.ListType{
				ElemType: types.StringType,
			},
			"community": basetypes.ListType{
				ElemType: types.StringType,
			},
			"exclude_as_path": basetypes.ListType{
				ElemType: types.StringType,
			},
			"exclude_community": basetypes.ListType{
				ElemType: types.StringType,
			},
			"export_communities": basetypes.ListType{
				ElemType: types.StringType,
			},
			"local_preference": basetypes.StringType{},
			"prepend_as_path": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"accept": basetypes.BoolType{},
		"add_community": basetypes.ListType{
			ElemType: types.StringType,
		},
		"add_target_vrfs": basetypes.ListType{
			ElemType: types.StringType,
		},
		"community": basetypes.ListType{
			ElemType: types.StringType,
		},
		"exclude_as_path": basetypes.ListType{
			ElemType: types.StringType,
		},
		"exclude_community": basetypes.ListType{
			ElemType: types.StringType,
		},
		"export_communities": basetypes.ListType{
			ElemType: types.StringType,
		},
		"local_preference": basetypes.StringType{},
		"prepend_as_path": basetypes.ListType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"accept":             v.Accept,
			"add_community":      addCommunityVal,
			"add_target_vrfs":    addTargetVrfsVal,
			"community":          communityVal,
			"exclude_as_path":    excludeAsPathVal,
			"exclude_community":  excludeCommunityVal,
			"export_communities": exportCommunitiesVal,
			"local_preference":   v.LocalPreference,
			"prepend_as_path":    prependAsPathVal,
		})

	return objVal, diags
}

func (v ActionValue) Equal(o attr.Value) bool {
	other, ok := o.(ActionValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Accept.Equal(other.Accept) {
		return false
	}

	if !v.AddCommunity.Equal(other.AddCommunity) {
		return false
	}

	if !v.AddTargetVrfs.Equal(other.AddTargetVrfs) {
		return false
	}

	if !v.Community.Equal(other.Community) {
		return false
	}

	if !v.ExcludeAsPath.Equal(other.ExcludeAsPath) {
		return false
	}

	if !v.ExcludeCommunity.Equal(other.ExcludeCommunity) {
		return false
	}

	if !v.ExportCommunities.Equal(other.ExportCommunities) {
		return false
	}

	if !v.LocalPreference.Equal(other.LocalPreference) {
		return false
	}

	if !v.PrependAsPath.Equal(other.PrependAsPath) {
		return false
	}

	return true
}

func (v ActionValue) Type(ctx context.Context) attr.Type {
	return ActionType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ActionValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"accept": basetypes.BoolType{},
		"add_community": basetypes.ListType{
			ElemType: types.StringType,
		},
		"add_target_vrfs": basetypes.ListType{
			ElemType: types.StringType,
		},
		"community": basetypes.ListType{
			ElemType: types.StringType,
		},
		"exclude_as_path": basetypes.ListType{
			ElemType: types.StringType,
		},
		"exclude_community": basetypes.ListType{
			ElemType: types.StringType,
		},
		"export_communities": basetypes.ListType{
			ElemType: types.StringType,
		},
		"local_preference": basetypes.StringType{},
		"prepend_as_path": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = RoutingPolicyTermMatchingType{}

type RoutingPolicyTermMatchingType struct {
	basetypes.ObjectType
}

func (t RoutingPolicyTermMatchingType) Equal(o attr.Type) bool {
	other, ok := o.(RoutingPolicyTermMatchingType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t RoutingPolicyTermMatchingType) String() string {
	return "RoutingPolicyTermMatchingType"
}

func (t RoutingPolicyTermMatchingType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	asPathAttribute, ok := attributes["as_path"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`as_path is missing from object`)

		return nil, diags
	}

	asPathVal, ok := asPathAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`as_path expected to be basetypes.ListValue, was: %T`, asPathAttribute))
	}

	communityAttribute, ok := attributes["community"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`community is missing from object`)

		return nil, diags
	}

	communityVal, ok := communityAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`community expected to be basetypes.ListValue, was: %T`, communityAttribute))
	}

	networkAttribute, ok := attributes["network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`network is missing from object`)

		return nil, diags
	}

	networkVal, ok := networkAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`network expected to be basetypes.ListValue, was: %T`, networkAttribute))
	}

	prefixAttribute, ok := attributes["prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix is missing from object`)

		return nil, diags
	}

	prefixVal, ok := prefixAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix expected to be basetypes.ListValue, was: %T`, prefixAttribute))
	}

	protocolAttribute, ok := attributes["protocol"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`protocol is missing from object`)

		return nil, diags
	}

	protocolVal, ok := protocolAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`protocol expected to be basetypes.ListValue, was: %T`, protocolAttribute))
	}

	routeExistsAttribute, ok := attributes["route_exists"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`route_exists is missing from object`)

		return nil, diags
	}

	routeExistsVal, ok := routeExistsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`route_exists expected to be basetypes.ObjectValue, was: %T`, routeExistsAttribute))
	}

	vpnNeighborMacAttribute, ok := attributes["vpn_neighbor_mac"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vpn_neighbor_mac is missing from object`)

		return nil, diags
	}

	vpnNeighborMacVal, ok := vpnNeighborMacAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vpn_neighbor_mac expected to be basetypes.ListValue, was: %T`, vpnNeighborMacAttribute))
	}

	vpnPathAttribute, ok := attributes["vpn_path"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vpn_path is missing from object`)

		return nil, diags
	}

	vpnPathVal, ok := vpnPathAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vpn_path expected to be basetypes.ListValue, was: %T`, vpnPathAttribute))
	}

	vpnPathSlaAttribute, ok := attributes["vpn_path_sla"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vpn_path_sla is missing from object`)

		return nil, diags
	}

	vpnPathSlaVal, ok := vpnPathSlaAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vpn_path_sla expected to be basetypes.ObjectValue, was: %T`, vpnPathSlaAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return RoutingPolicyTermMatchingValue{
		AsPath:         asPathVal,
		Community:      communityVal,
		Network:        networkVal,
		Prefix:         prefixVal,
		Protocol:       protocolVal,
		RouteExists:    routeExistsVal,
		VpnNeighborMac: vpnNeighborMacVal,
		VpnPath:        vpnPathVal,
		VpnPathSla:     vpnPathSlaVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewRoutingPolicyTermMatchingValueNull() RoutingPolicyTermMatchingValue {
	return RoutingPolicyTermMatchingValue{
		state: attr.ValueStateNull,
	}
}

func NewRoutingPolicyTermMatchingValueUnknown() RoutingPolicyTermMatchingValue {
	return RoutingPolicyTermMatchingValue{
		state: attr.ValueStateUnknown,
	}
}

func NewRoutingPolicyTermMatchingValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (RoutingPolicyTermMatchingValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing RoutingPolicyTermMatchingValue Attribute Value",
				"While creating a RoutingPolicyTermMatchingValue value, a missing attribute value was detected. "+
					"A RoutingPolicyTermMatchingValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RoutingPolicyTermMatchingValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid RoutingPolicyTermMatchingValue Attribute Type",
				"While creating a RoutingPolicyTermMatchingValue value, an invalid attribute value was detected. "+
					"A RoutingPolicyTermMatchingValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RoutingPolicyTermMatchingValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("RoutingPolicyTermMatchingValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra RoutingPolicyTermMatchingValue Attribute Value",
				"While creating a RoutingPolicyTermMatchingValue value, an extra attribute value was detected. "+
					"A RoutingPolicyTermMatchingValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra RoutingPolicyTermMatchingValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewRoutingPolicyTermMatchingValueUnknown(), diags
	}

	asPathAttribute, ok := attributes["as_path"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`as_path is missing from object`)

		return NewRoutingPolicyTermMatchingValueUnknown(), diags
	}

	asPathVal, ok := asPathAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`as_path expected to be basetypes.ListValue, was: %T`, asPathAttribute))
	}

	communityAttribute, ok := attributes["community"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`community is missing from object`)

		return NewRoutingPolicyTermMatchingValueUnknown(), diags
	}

	communityVal, ok := communityAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`community expected to be basetypes.ListValue, was: %T`, communityAttribute))
	}

	networkAttribute, ok := attributes["network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`network is missing from object`)

		return NewRoutingPolicyTermMatchingValueUnknown(), diags
	}

	networkVal, ok := networkAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`network expected to be basetypes.ListValue, was: %T`, networkAttribute))
	}

	prefixAttribute, ok := attributes["prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix is missing from object`)

		return NewRoutingPolicyTermMatchingValueUnknown(), diags
	}

	prefixVal, ok := prefixAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix expected to be basetypes.ListValue, was: %T`, prefixAttribute))
	}

	protocolAttribute, ok := attributes["protocol"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`protocol is missing from object`)

		return NewRoutingPolicyTermMatchingValueUnknown(), diags
	}

	protocolVal, ok := protocolAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`protocol expected to be basetypes.ListValue, was: %T`, protocolAttribute))
	}

	routeExistsAttribute, ok := attributes["route_exists"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`route_exists is missing from object`)

		return NewRoutingPolicyTermMatchingValueUnknown(), diags
	}

	routeExistsVal, ok := routeExistsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`route_exists expected to be basetypes.ObjectValue, was: %T`, routeExistsAttribute))
	}

	vpnNeighborMacAttribute, ok := attributes["vpn_neighbor_mac"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vpn_neighbor_mac is missing from object`)

		return NewRoutingPolicyTermMatchingValueUnknown(), diags
	}

	vpnNeighborMacVal, ok := vpnNeighborMacAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vpn_neighbor_mac expected to be basetypes.ListValue, was: %T`, vpnNeighborMacAttribute))
	}

	vpnPathAttribute, ok := attributes["vpn_path"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vpn_path is missing from object`)

		return NewRoutingPolicyTermMatchingValueUnknown(), diags
	}

	vpnPathVal, ok := vpnPathAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vpn_path expected to be basetypes.ListValue, was: %T`, vpnPathAttribute))
	}

	vpnPathSlaAttribute, ok := attributes["vpn_path_sla"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vpn_path_sla is missing from object`)

		return NewRoutingPolicyTermMatchingValueUnknown(), diags
	}

	vpnPathSlaVal, ok := vpnPathSlaAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vpn_path_sla expected to be basetypes.ObjectValue, was: %T`, vpnPathSlaAttribute))
	}

	if diags.HasError() {
		return NewRoutingPolicyTermMatchingValueUnknown(), diags
	}

	return RoutingPolicyTermMatchingValue{
		AsPath:         asPathVal,
		Community:      communityVal,
		Network:        networkVal,
		Prefix:         prefixVal,
		Protocol:       protocolVal,
		RouteExists:    routeExistsVal,
		VpnNeighborMac: vpnNeighborMacVal,
		VpnPath:        vpnPathVal,
		VpnPathSla:     vpnPathSlaVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewRoutingPolicyTermMatchingValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) RoutingPolicyTermMatchingValue {
	object, diags := NewRoutingPolicyTermMatchingValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewRoutingPolicyTermMatchingValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t RoutingPolicyTermMatchingType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewRoutingPolicyTermMatchingValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewRoutingPolicyTermMatchingValueUnknown(), nil
	}

	if in.IsNull() {
		return NewRoutingPolicyTermMatchingValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewRoutingPolicyTermMatchingValueMust(RoutingPolicyTermMatchingValue{}.AttributeTypes(ctx), attributes), nil
}

func (t RoutingPolicyTermMatchingType) ValueType(ctx context.Context) attr.Value {
	return RoutingPolicyTermMatchingValue{}
}

var _ basetypes.ObjectValuable = RoutingPolicyTermMatchingValue{}

type RoutingPolicyTermMatchingValue struct {
	AsPath         basetypes.ListValue   `tfsdk:"as_path"`
	Community      basetypes.ListValue   `tfsdk:"community"`
	Network        basetypes.ListValue   `tfsdk:"network"`
	Prefix         basetypes.ListValue   `tfsdk:"prefix"`
	Protocol       basetypes.ListValue   `tfsdk:"protocol"`
	RouteExists    basetypes.ObjectValue `tfsdk:"route_exists"`
	VpnNeighborMac basetypes.ListValue   `tfsdk:"vpn_neighbor_mac"`
	VpnPath        basetypes.ListValue   `tfsdk:"vpn_path"`
	VpnPathSla     basetypes.ObjectValue `tfsdk:"vpn_path_sla"`
	state          attr.ValueState
}

func (v RoutingPolicyTermMatchingValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 9)

	var val tftypes.Value
	var err error

	attrTypes["as_path"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["community"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["network"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["prefix"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["protocol"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["route_exists"] = basetypes.ObjectType{
		AttrTypes: RouteExistsValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["vpn_neighbor_mac"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["vpn_path"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["vpn_path_sla"] = basetypes.ObjectType{
		AttrTypes: VpnPathSlaValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 9)

		val, err = v.AsPath.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["as_path"] = val

		val, err = v.Community.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["community"] = val

		val, err = v.Network.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["network"] = val

		val, err = v.Prefix.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["prefix"] = val

		val, err = v.Protocol.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["protocol"] = val

		val, err = v.RouteExists.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["route_exists"] = val

		val, err = v.VpnNeighborMac.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vpn_neighbor_mac"] = val

		val, err = v.VpnPath.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vpn_path"] = val

		val, err = v.VpnPathSla.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vpn_path_sla"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v RoutingPolicyTermMatchingValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v RoutingPolicyTermMatchingValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v RoutingPolicyTermMatchingValue) String() string {
	return "RoutingPolicyTermMatchingValue"
}

func (v RoutingPolicyTermMatchingValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var routeExists basetypes.ObjectValue

	if v.RouteExists.IsNull() {
		routeExists = types.ObjectNull(
			RouteExistsValue{}.AttributeTypes(ctx),
		)
	}

	if v.RouteExists.IsUnknown() {
		routeExists = types.ObjectUnknown(
			RouteExistsValue{}.AttributeTypes(ctx),
		)
	}

	if !v.RouteExists.IsNull() && !v.RouteExists.IsUnknown() {
		routeExists = types.ObjectValueMust(
			RouteExistsValue{}.AttributeTypes(ctx),
			v.RouteExists.Attributes(),
		)
	}

	var vpnPathSla basetypes.ObjectValue

	if v.VpnPathSla.IsNull() {
		vpnPathSla = types.ObjectNull(
			VpnPathSlaValue{}.AttributeTypes(ctx),
		)
	}

	if v.VpnPathSla.IsUnknown() {
		vpnPathSla = types.ObjectUnknown(
			VpnPathSlaValue{}.AttributeTypes(ctx),
		)
	}

	if !v.VpnPathSla.IsNull() && !v.VpnPathSla.IsUnknown() {
		vpnPathSla = types.ObjectValueMust(
			VpnPathSlaValue{}.AttributeTypes(ctx),
			v.VpnPathSla.Attributes(),
		)
	}

	var asPathVal basetypes.ListValue
	switch {
	case v.AsPath.IsUnknown():
		asPathVal = types.ListUnknown(types.StringType)
	case v.AsPath.IsNull():
		asPathVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		asPathVal, d = types.ListValue(types.StringType, v.AsPath.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"as_path": basetypes.ListType{
				ElemType: types.StringType,
			},
			"community": basetypes.ListType{
				ElemType: types.StringType,
			},
			"network": basetypes.ListType{
				ElemType: types.StringType,
			},
			"prefix": basetypes.ListType{
				ElemType: types.StringType,
			},
			"protocol": basetypes.ListType{
				ElemType: types.StringType,
			},
			"route_exists": basetypes.ObjectType{
				AttrTypes: RouteExistsValue{}.AttributeTypes(ctx),
			},
			"vpn_neighbor_mac": basetypes.ListType{
				ElemType: types.StringType,
			},
			"vpn_path": basetypes.ListType{
				ElemType: types.StringType,
			},
			"vpn_path_sla": basetypes.ObjectType{
				AttrTypes: VpnPathSlaValue{}.AttributeTypes(ctx),
			},
		}), diags
	}

	var communityVal basetypes.ListValue
	switch {
	case v.Community.IsUnknown():
		communityVal = types.ListUnknown(types.StringType)
	case v.Community.IsNull():
		communityVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		communityVal, d = types.ListValue(types.StringType, v.Community.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"as_path": basetypes.ListType{
				ElemType: types.StringType,
			},
			"community": basetypes.ListType{
				ElemType: types.StringType,
			},
			"network": basetypes.ListType{
				ElemType: types.StringType,
			},
			"prefix": basetypes.ListType{
				ElemType: types.StringType,
			},
			"protocol": basetypes.ListType{
				ElemType: types.StringType,
			},
			"route_exists": basetypes.ObjectType{
				AttrTypes: RouteExistsValue{}.AttributeTypes(ctx),
			},
			"vpn_neighbor_mac": basetypes.ListType{
				ElemType: types.StringType,
			},
			"vpn_path": basetypes.ListType{
				ElemType: types.StringType,
			},
			"vpn_path_sla": basetypes.ObjectType{
				AttrTypes: VpnPathSlaValue{}.AttributeTypes(ctx),
			},
		}), diags
	}

	var networkVal basetypes.ListValue
	switch {
	case v.Network.IsUnknown():
		networkVal = types.ListUnknown(types.StringType)
	case v.Network.IsNull():
		networkVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		networkVal, d = types.ListValue(types.StringType, v.Network.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"as_path": basetypes.ListType{
				ElemType: types.StringType,
			},
			"community": basetypes.ListType{
				ElemType: types.StringType,
			},
			"network": basetypes.ListType{
				ElemType: types.StringType,
			},
			"prefix": basetypes.ListType{
				ElemType: types.StringType,
			},
			"protocol": basetypes.ListType{
				ElemType: types.StringType,
			},
			"route_exists": basetypes.ObjectType{
				AttrTypes: RouteExistsValue{}.AttributeTypes(ctx),
			},
			"vpn_neighbor_mac": basetypes.ListType{
				ElemType: types.StringType,
			},
			"vpn_path": basetypes.ListType{
				ElemType: types.StringType,
			},
			"vpn_path_sla": basetypes.ObjectType{
				AttrTypes: VpnPathSlaValue{}.AttributeTypes(ctx),
			},
		}), diags
	}

	var prefixVal basetypes.ListValue
	switch {
	case v.Prefix.IsUnknown():
		prefixVal = types.ListUnknown(types.StringType)
	case v.Prefix.IsNull():
		prefixVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		prefixVal, d = types.ListValue(types.StringType, v.Prefix.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"as_path": basetypes.ListType{
				ElemType: types.StringType,
			},
			"community": basetypes.ListType{
				ElemType: types.StringType,
			},
			"network": basetypes.ListType{
				ElemType: types.StringType,
			},
			"prefix": basetypes.ListType{
				ElemType: types.StringType,
			},
			"protocol": basetypes.ListType{
				ElemType: types.StringType,
			},
			"route_exists": basetypes.ObjectType{
				AttrTypes: RouteExistsValue{}.AttributeTypes(ctx),
			},
			"vpn_neighbor_mac": basetypes.ListType{
				ElemType: types.StringType,
			},
			"vpn_path": basetypes.ListType{
				ElemType: types.StringType,
			},
			"vpn_path_sla": basetypes.ObjectType{
				AttrTypes: VpnPathSlaValue{}.AttributeTypes(ctx),
			},
		}), diags
	}

	var protocolVal basetypes.ListValue
	switch {
	case v.Protocol.IsUnknown():
		protocolVal = types.ListUnknown(types.StringType)
	case v.Protocol.IsNull():
		protocolVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		protocolVal, d = types.ListValue(types.StringType, v.Protocol.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"as_path": basetypes.ListType{
				ElemType: types.StringType,
			},
			"community": basetypes.ListType{
				ElemType: types.StringType,
			},
			"network": basetypes.ListType{
				ElemType: types.StringType,
			},
			"prefix": basetypes.ListType{
				ElemType: types.StringType,
			},
			"protocol": basetypes.ListType{
				ElemType: types.StringType,
			},
			"route_exists": basetypes.ObjectType{
				AttrTypes: RouteExistsValue{}.AttributeTypes(ctx),
			},
			"vpn_neighbor_mac": basetypes.ListType{
				ElemType: types.StringType,
			},
			"vpn_path": basetypes.ListType{
				ElemType: types.StringType,
			},
			"vpn_path_sla": basetypes.ObjectType{
				AttrTypes: VpnPathSlaValue{}.AttributeTypes(ctx),
			},
		}), diags
	}

	var vpnNeighborMacVal basetypes.ListValue
	switch {
	case v.VpnNeighborMac.IsUnknown():
		vpnNeighborMacVal = types.ListUnknown(types.StringType)
	case v.VpnNeighborMac.IsNull():
		vpnNeighborMacVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		vpnNeighborMacVal, d = types.ListValue(types.StringType, v.VpnNeighborMac.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"as_path": basetypes.ListType{
				ElemType: types.StringType,
			},
			"community": basetypes.ListType{
				ElemType: types.StringType,
			},
			"network": basetypes.ListType{
				ElemType: types.StringType,
			},
			"prefix": basetypes.ListType{
				ElemType: types.StringType,
			},
			"protocol": basetypes.ListType{
				ElemType: types.StringType,
			},
			"route_exists": basetypes.ObjectType{
				AttrTypes: RouteExistsValue{}.AttributeTypes(ctx),
			},
			"vpn_neighbor_mac": basetypes.ListType{
				ElemType: types.StringType,
			},
			"vpn_path": basetypes.ListType{
				ElemType: types.StringType,
			},
			"vpn_path_sla": basetypes.ObjectType{
				AttrTypes: VpnPathSlaValue{}.AttributeTypes(ctx),
			},
		}), diags
	}

	var vpnPathVal basetypes.ListValue
	switch {
	case v.VpnPath.IsUnknown():
		vpnPathVal = types.ListUnknown(types.StringType)
	case v.VpnPath.IsNull():
		vpnPathVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		vpnPathVal, d = types.ListValue(types.StringType, v.VpnPath.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"as_path": basetypes.ListType{
				ElemType: types.StringType,
			},
			"community": basetypes.ListType{
				ElemType: types.StringType,
			},
			"network": basetypes.ListType{
				ElemType: types.StringType,
			},
			"prefix": basetypes.ListType{
				ElemType: types.StringType,
			},
			"protocol": basetypes.ListType{
				ElemType: types.StringType,
			},
			"route_exists": basetypes.ObjectType{
				AttrTypes: RouteExistsValue{}.AttributeTypes(ctx),
			},
			"vpn_neighbor_mac": basetypes.ListType{
				ElemType: types.StringType,
			},
			"vpn_path": basetypes.ListType{
				ElemType: types.StringType,
			},
			"vpn_path_sla": basetypes.ObjectType{
				AttrTypes: VpnPathSlaValue{}.AttributeTypes(ctx),
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"as_path": basetypes.ListType{
			ElemType: types.StringType,
		},
		"community": basetypes.ListType{
			ElemType: types.StringType,
		},
		"network": basetypes.ListType{
			ElemType: types.StringType,
		},
		"prefix": basetypes.ListType{
			ElemType: types.StringType,
		},
		"protocol": basetypes.ListType{
			ElemType: types.StringType,
		},
		"route_exists": basetypes.ObjectType{
			AttrTypes: RouteExistsValue{}.AttributeTypes(ctx),
		},
		"vpn_neighbor_mac": basetypes.ListType{
			ElemType: types.StringType,
		},
		"vpn_path": basetypes.ListType{
			ElemType: types.StringType,
		},
		"vpn_path_sla": basetypes.ObjectType{
			AttrTypes: VpnPathSlaValue{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"as_path":          asPathVal,
			"community":        communityVal,
			"network":          networkVal,
			"prefix":           prefixVal,
			"protocol":         protocolVal,
			"route_exists":     routeExists,
			"vpn_neighbor_mac": vpnNeighborMacVal,
			"vpn_path":         vpnPathVal,
			"vpn_path_sla":     vpnPathSla,
		})

	return objVal, diags
}

func (v RoutingPolicyTermMatchingValue) Equal(o attr.Value) bool {
	other, ok := o.(RoutingPolicyTermMatchingValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AsPath.Equal(other.AsPath) {
		return false
	}

	if !v.Community.Equal(other.Community) {
		return false
	}

	if !v.Network.Equal(other.Network) {
		return false
	}

	if !v.Prefix.Equal(other.Prefix) {
		return false
	}

	if !v.Protocol.Equal(other.Protocol) {
		return false
	}

	if !v.RouteExists.Equal(other.RouteExists) {
		return false
	}

	if !v.VpnNeighborMac.Equal(other.VpnNeighborMac) {
		return false
	}

	if !v.VpnPath.Equal(other.VpnPath) {
		return false
	}

	if !v.VpnPathSla.Equal(other.VpnPathSla) {
		return false
	}

	return true
}

func (v RoutingPolicyTermMatchingValue) Type(ctx context.Context) attr.Type {
	return RoutingPolicyTermMatchingType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v RoutingPolicyTermMatchingValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"as_path": basetypes.ListType{
			ElemType: types.StringType,
		},
		"community": basetypes.ListType{
			ElemType: types.StringType,
		},
		"network": basetypes.ListType{
			ElemType: types.StringType,
		},
		"prefix": basetypes.ListType{
			ElemType: types.StringType,
		},
		"protocol": basetypes.ListType{
			ElemType: types.StringType,
		},
		"route_exists": basetypes.ObjectType{
			AttrTypes: RouteExistsValue{}.AttributeTypes(ctx),
		},
		"vpn_neighbor_mac": basetypes.ListType{
			ElemType: types.StringType,
		},
		"vpn_path": basetypes.ListType{
			ElemType: types.StringType,
		},
		"vpn_path_sla": basetypes.ObjectType{
			AttrTypes: VpnPathSlaValue{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = RouteExistsType{}

type RouteExistsType struct {
	basetypes.ObjectType
}

func (t RouteExistsType) Equal(o attr.Type) bool {
	other, ok := o.(RouteExistsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t RouteExistsType) String() string {
	return "RouteExistsType"
}

func (t RouteExistsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	routeAttribute, ok := attributes["route"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`route is missing from object`)

		return nil, diags
	}

	routeVal, ok := routeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`route expected to be basetypes.StringValue, was: %T`, routeAttribute))
	}

	vrfNameAttribute, ok := attributes["vrf_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vrf_name is missing from object`)

		return nil, diags
	}

	vrfNameVal, ok := vrfNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vrf_name expected to be basetypes.StringValue, was: %T`, vrfNameAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return RouteExistsValue{
		Route:   routeVal,
		VrfName: vrfNameVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewRouteExistsValueNull() RouteExistsValue {
	return RouteExistsValue{
		state: attr.ValueStateNull,
	}
}

func NewRouteExistsValueUnknown() RouteExistsValue {
	return RouteExistsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewRouteExistsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (RouteExistsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing RouteExistsValue Attribute Value",
				"While creating a RouteExistsValue value, a missing attribute value was detected. "+
					"A RouteExistsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RouteExistsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid RouteExistsValue Attribute Type",
				"While creating a RouteExistsValue value, an invalid attribute value was detected. "+
					"A RouteExistsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RouteExistsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("RouteExistsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra RouteExistsValue Attribute Value",
				"While creating a RouteExistsValue value, an extra attribute value was detected. "+
					"A RouteExistsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra RouteExistsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewRouteExistsValueUnknown(), diags
	}

	routeAttribute, ok := attributes["route"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`route is missing from object`)

		return NewRouteExistsValueUnknown(), diags
	}

	routeVal, ok := routeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`route expected to be basetypes.StringValue, was: %T`, routeAttribute))
	}

	vrfNameAttribute, ok := attributes["vrf_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vrf_name is missing from object`)

		return NewRouteExistsValueUnknown(), diags
	}

	vrfNameVal, ok := vrfNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vrf_name expected to be basetypes.StringValue, was: %T`, vrfNameAttribute))
	}

	if diags.HasError() {
		return NewRouteExistsValueUnknown(), diags
	}

	return RouteExistsValue{
		Route:   routeVal,
		VrfName: vrfNameVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewRouteExistsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) RouteExistsValue {
	object, diags := NewRouteExistsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewRouteExistsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t RouteExistsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewRouteExistsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewRouteExistsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewRouteExistsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewRouteExistsValueMust(RouteExistsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t RouteExistsType) ValueType(ctx context.Context) attr.Value {
	return RouteExistsValue{}
}

var _ basetypes.ObjectValuable = RouteExistsValue{}

type RouteExistsValue struct {
	Route   basetypes.StringValue `tfsdk:"route"`
	VrfName basetypes.StringValue `tfsdk:"vrf_name"`
	state   attr.ValueState
}

func (v RouteExistsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["route"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["vrf_name"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Route.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["route"] = val

		val, err = v.VrfName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vrf_name"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v RouteExistsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v RouteExistsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v RouteExistsValue) String() string {
	return "RouteExistsValue"
}

func (v RouteExistsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"route":    basetypes.StringType{},
		"vrf_name": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"route":    v.Route,
			"vrf_name": v.VrfName,
		})

	return objVal, diags
}

func (v RouteExistsValue) Equal(o attr.Value) bool {
	other, ok := o.(RouteExistsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Route.Equal(other.Route) {
		return false
	}

	if !v.VrfName.Equal(other.VrfName) {
		return false
	}

	return true
}

func (v RouteExistsValue) Type(ctx context.Context) attr.Type {
	return RouteExistsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v RouteExistsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"route":    basetypes.StringType{},
		"vrf_name": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = VpnPathSlaType{}

type VpnPathSlaType struct {
	basetypes.ObjectType
}

func (t VpnPathSlaType) Equal(o attr.Type) bool {
	other, ok := o.(VpnPathSlaType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t VpnPathSlaType) String() string {
	return "VpnPathSlaType"
}

func (t VpnPathSlaType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	maxJitterAttribute, ok := attributes["max_jitter"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_jitter is missing from object`)

		return nil, diags
	}

	maxJitterVal, ok := maxJitterAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_jitter expected to be basetypes.Int64Value, was: %T`, maxJitterAttribute))
	}

	maxLatencyAttribute, ok := attributes["max_latency"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_latency is missing from object`)

		return nil, diags
	}

	maxLatencyVal, ok := maxLatencyAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_latency expected to be basetypes.Int64Value, was: %T`, maxLatencyAttribute))
	}

	maxLossAttribute, ok := attributes["max_loss"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_loss is missing from object`)

		return nil, diags
	}

	maxLossVal, ok := maxLossAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_loss expected to be basetypes.Int64Value, was: %T`, maxLossAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return VpnPathSlaValue{
		MaxJitter:  maxJitterVal,
		MaxLatency: maxLatencyVal,
		MaxLoss:    maxLossVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewVpnPathSlaValueNull() VpnPathSlaValue {
	return VpnPathSlaValue{
		state: attr.ValueStateNull,
	}
}

func NewVpnPathSlaValueUnknown() VpnPathSlaValue {
	return VpnPathSlaValue{
		state: attr.ValueStateUnknown,
	}
}

func NewVpnPathSlaValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (VpnPathSlaValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing VpnPathSlaValue Attribute Value",
				"While creating a VpnPathSlaValue value, a missing attribute value was detected. "+
					"A VpnPathSlaValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VpnPathSlaValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid VpnPathSlaValue Attribute Type",
				"While creating a VpnPathSlaValue value, an invalid attribute value was detected. "+
					"A VpnPathSlaValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VpnPathSlaValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("VpnPathSlaValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra VpnPathSlaValue Attribute Value",
				"While creating a VpnPathSlaValue value, an extra attribute value was detected. "+
					"A VpnPathSlaValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra VpnPathSlaValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewVpnPathSlaValueUnknown(), diags
	}

	maxJitterAttribute, ok := attributes["max_jitter"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_jitter is missing from object`)

		return NewVpnPathSlaValueUnknown(), diags
	}

	maxJitterVal, ok := maxJitterAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_jitter expected to be basetypes.Int64Value, was: %T`, maxJitterAttribute))
	}

	maxLatencyAttribute, ok := attributes["max_latency"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_latency is missing from object`)

		return NewVpnPathSlaValueUnknown(), diags
	}

	maxLatencyVal, ok := maxLatencyAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_latency expected to be basetypes.Int64Value, was: %T`, maxLatencyAttribute))
	}

	maxLossAttribute, ok := attributes["max_loss"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_loss is missing from object`)

		return NewVpnPathSlaValueUnknown(), diags
	}

	maxLossVal, ok := maxLossAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_loss expected to be basetypes.Int64Value, was: %T`, maxLossAttribute))
	}

	if diags.HasError() {
		return NewVpnPathSlaValueUnknown(), diags
	}

	return VpnPathSlaValue{
		MaxJitter:  maxJitterVal,
		MaxLatency: maxLatencyVal,
		MaxLoss:    maxLossVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewVpnPathSlaValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) VpnPathSlaValue {
	object, diags := NewVpnPathSlaValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewVpnPathSlaValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t VpnPathSlaType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewVpnPathSlaValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewVpnPathSlaValueUnknown(), nil
	}

	if in.IsNull() {
		return NewVpnPathSlaValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewVpnPathSlaValueMust(VpnPathSlaValue{}.AttributeTypes(ctx), attributes), nil
}

func (t VpnPathSlaType) ValueType(ctx context.Context) attr.Value {
	return VpnPathSlaValue{}
}

var _ basetypes.ObjectValuable = VpnPathSlaValue{}

type VpnPathSlaValue struct {
	MaxJitter  basetypes.Int64Value `tfsdk:"max_jitter"`
	MaxLatency basetypes.Int64Value `tfsdk:"max_latency"`
	MaxLoss    basetypes.Int64Value `tfsdk:"max_loss"`
	state      attr.ValueState
}

func (v VpnPathSlaValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["max_jitter"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["max_latency"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["max_loss"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.MaxJitter.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_jitter"] = val

		val, err = v.MaxLatency.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_latency"] = val

		val, err = v.MaxLoss.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_loss"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v VpnPathSlaValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v VpnPathSlaValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v VpnPathSlaValue) String() string {
	return "VpnPathSlaValue"
}

func (v VpnPathSlaValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"max_jitter":  basetypes.Int64Type{},
		"max_latency": basetypes.Int64Type{},
		"max_loss":    basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"max_jitter":  v.MaxJitter,
			"max_latency": v.MaxLatency,
			"max_loss":    v.MaxLoss,
		})

	return objVal, diags
}

func (v VpnPathSlaValue) Equal(o attr.Value) bool {
	other, ok := o.(VpnPathSlaValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.MaxJitter.Equal(other.MaxJitter) {
		return false
	}

	if !v.MaxLatency.Equal(other.MaxLatency) {
		return false
	}

	if !v.MaxLoss.Equal(other.MaxLoss) {
		return false
	}

	return true
}

func (v VpnPathSlaValue) Type(ctx context.Context) attr.Type {
	return VpnPathSlaType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v VpnPathSlaValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"max_jitter":  basetypes.Int64Type{},
		"max_latency": basetypes.Int64Type{},
		"max_loss":    basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = ServicePoliciesType{}

type ServicePoliciesType struct {
	basetypes.ObjectType
}

func (t ServicePoliciesType) Equal(o attr.Type) bool {
	other, ok := o.(ServicePoliciesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ServicePoliciesType) String() string {
	return "ServicePoliciesType"
}

func (t ServicePoliciesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	actionAttribute, ok := attributes["action"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`action is missing from object`)

		return nil, diags
	}

	actionVal, ok := actionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`action expected to be basetypes.StringValue, was: %T`, actionAttribute))
	}

	antivirusAttribute, ok := attributes["antivirus"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`antivirus is missing from object`)

		return nil, diags
	}

	antivirusVal, ok := antivirusAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`antivirus expected to be basetypes.ObjectValue, was: %T`, antivirusAttribute))
	}

	appqoeAttribute, ok := attributes["appqoe"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`appqoe is missing from object`)

		return nil, diags
	}

	appqoeVal, ok := appqoeAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`appqoe expected to be basetypes.ObjectValue, was: %T`, appqoeAttribute))
	}

	ewfAttribute, ok := attributes["ewf"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ewf is missing from object`)

		return nil, diags
	}

	ewfVal, ok := ewfAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ewf expected to be basetypes.ListValue, was: %T`, ewfAttribute))
	}

	idpAttribute, ok := attributes["idp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`idp is missing from object`)

		return nil, diags
	}

	idpVal, ok := idpAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`idp expected to be basetypes.ObjectValue, was: %T`, idpAttribute))
	}

	localRoutingAttribute, ok := attributes["local_routing"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`local_routing is missing from object`)

		return nil, diags
	}

	localRoutingVal, ok := localRoutingAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`local_routing expected to be basetypes.BoolValue, was: %T`, localRoutingAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	pathPreferenceAttribute, ok := attributes["path_preference"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`path_preference is missing from object`)

		return nil, diags
	}

	pathPreferenceVal, ok := pathPreferenceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`path_preference expected to be basetypes.StringValue, was: %T`, pathPreferenceAttribute))
	}

	servicepolicyIdAttribute, ok := attributes["servicepolicy_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`servicepolicy_id is missing from object`)

		return nil, diags
	}

	servicepolicyIdVal, ok := servicepolicyIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`servicepolicy_id expected to be basetypes.StringValue, was: %T`, servicepolicyIdAttribute))
	}

	servicesAttribute, ok := attributes["services"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`services is missing from object`)

		return nil, diags
	}

	servicesVal, ok := servicesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`services expected to be basetypes.ListValue, was: %T`, servicesAttribute))
	}

	sslProxyAttribute, ok := attributes["ssl_proxy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ssl_proxy is missing from object`)

		return nil, diags
	}

	sslProxyVal, ok := sslProxyAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ssl_proxy expected to be basetypes.ObjectValue, was: %T`, sslProxyAttribute))
	}

	tenantsAttribute, ok := attributes["tenants"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tenants is missing from object`)

		return nil, diags
	}

	tenantsVal, ok := tenantsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tenants expected to be basetypes.ListValue, was: %T`, tenantsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ServicePoliciesValue{
		Action:          actionVal,
		Antivirus:       antivirusVal,
		Appqoe:          appqoeVal,
		Ewf:             ewfVal,
		Idp:             idpVal,
		LocalRouting:    localRoutingVal,
		Name:            nameVal,
		PathPreference:  pathPreferenceVal,
		ServicepolicyId: servicepolicyIdVal,
		Services:        servicesVal,
		SslProxy:        sslProxyVal,
		Tenants:         tenantsVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewServicePoliciesValueNull() ServicePoliciesValue {
	return ServicePoliciesValue{
		state: attr.ValueStateNull,
	}
}

func NewServicePoliciesValueUnknown() ServicePoliciesValue {
	return ServicePoliciesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewServicePoliciesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ServicePoliciesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ServicePoliciesValue Attribute Value",
				"While creating a ServicePoliciesValue value, a missing attribute value was detected. "+
					"A ServicePoliciesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ServicePoliciesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ServicePoliciesValue Attribute Type",
				"While creating a ServicePoliciesValue value, an invalid attribute value was detected. "+
					"A ServicePoliciesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ServicePoliciesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ServicePoliciesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ServicePoliciesValue Attribute Value",
				"While creating a ServicePoliciesValue value, an extra attribute value was detected. "+
					"A ServicePoliciesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ServicePoliciesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewServicePoliciesValueUnknown(), diags
	}

	actionAttribute, ok := attributes["action"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`action is missing from object`)

		return NewServicePoliciesValueUnknown(), diags
	}

	actionVal, ok := actionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`action expected to be basetypes.StringValue, was: %T`, actionAttribute))
	}

	antivirusAttribute, ok := attributes["antivirus"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`antivirus is missing from object`)

		return NewServicePoliciesValueUnknown(), diags
	}

	antivirusVal, ok := antivirusAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`antivirus expected to be basetypes.ObjectValue, was: %T`, antivirusAttribute))
	}

	appqoeAttribute, ok := attributes["appqoe"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`appqoe is missing from object`)

		return NewServicePoliciesValueUnknown(), diags
	}

	appqoeVal, ok := appqoeAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`appqoe expected to be basetypes.ObjectValue, was: %T`, appqoeAttribute))
	}

	ewfAttribute, ok := attributes["ewf"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ewf is missing from object`)

		return NewServicePoliciesValueUnknown(), diags
	}

	ewfVal, ok := ewfAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ewf expected to be basetypes.ListValue, was: %T`, ewfAttribute))
	}

	idpAttribute, ok := attributes["idp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`idp is missing from object`)

		return NewServicePoliciesValueUnknown(), diags
	}

	idpVal, ok := idpAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`idp expected to be basetypes.ObjectValue, was: %T`, idpAttribute))
	}

	localRoutingAttribute, ok := attributes["local_routing"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`local_routing is missing from object`)

		return NewServicePoliciesValueUnknown(), diags
	}

	localRoutingVal, ok := localRoutingAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`local_routing expected to be basetypes.BoolValue, was: %T`, localRoutingAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewServicePoliciesValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	pathPreferenceAttribute, ok := attributes["path_preference"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`path_preference is missing from object`)

		return NewServicePoliciesValueUnknown(), diags
	}

	pathPreferenceVal, ok := pathPreferenceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`path_preference expected to be basetypes.StringValue, was: %T`, pathPreferenceAttribute))
	}

	servicepolicyIdAttribute, ok := attributes["servicepolicy_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`servicepolicy_id is missing from object`)

		return NewServicePoliciesValueUnknown(), diags
	}

	servicepolicyIdVal, ok := servicepolicyIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`servicepolicy_id expected to be basetypes.StringValue, was: %T`, servicepolicyIdAttribute))
	}

	servicesAttribute, ok := attributes["services"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`services is missing from object`)

		return NewServicePoliciesValueUnknown(), diags
	}

	servicesVal, ok := servicesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`services expected to be basetypes.ListValue, was: %T`, servicesAttribute))
	}

	sslProxyAttribute, ok := attributes["ssl_proxy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ssl_proxy is missing from object`)

		return NewServicePoliciesValueUnknown(), diags
	}

	sslProxyVal, ok := sslProxyAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ssl_proxy expected to be basetypes.ObjectValue, was: %T`, sslProxyAttribute))
	}

	tenantsAttribute, ok := attributes["tenants"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tenants is missing from object`)

		return NewServicePoliciesValueUnknown(), diags
	}

	tenantsVal, ok := tenantsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tenants expected to be basetypes.ListValue, was: %T`, tenantsAttribute))
	}

	if diags.HasError() {
		return NewServicePoliciesValueUnknown(), diags
	}

	return ServicePoliciesValue{
		Action:          actionVal,
		Antivirus:       antivirusVal,
		Appqoe:          appqoeVal,
		Ewf:             ewfVal,
		Idp:             idpVal,
		LocalRouting:    localRoutingVal,
		Name:            nameVal,
		PathPreference:  pathPreferenceVal,
		ServicepolicyId: servicepolicyIdVal,
		Services:        servicesVal,
		SslProxy:        sslProxyVal,
		Tenants:         tenantsVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewServicePoliciesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ServicePoliciesValue {
	object, diags := NewServicePoliciesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewServicePoliciesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ServicePoliciesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewServicePoliciesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewServicePoliciesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewServicePoliciesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewServicePoliciesValueMust(ServicePoliciesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ServicePoliciesType) ValueType(ctx context.Context) attr.Value {
	return ServicePoliciesValue{}
}

var _ basetypes.ObjectValuable = ServicePoliciesValue{}

type ServicePoliciesValue struct {
	Action          basetypes.StringValue `tfsdk:"action"`
	Antivirus       basetypes.ObjectValue `tfsdk:"antivirus"`
	Appqoe          basetypes.ObjectValue `tfsdk:"appqoe"`
	Ewf             basetypes.ListValue   `tfsdk:"ewf"`
	Idp             basetypes.ObjectValue `tfsdk:"idp"`
	LocalRouting    basetypes.BoolValue   `tfsdk:"local_routing"`
	Name            basetypes.StringValue `tfsdk:"name"`
	PathPreference  basetypes.StringValue `tfsdk:"path_preference"`
	ServicepolicyId basetypes.StringValue `tfsdk:"servicepolicy_id"`
	Services        basetypes.ListValue   `tfsdk:"services"`
	SslProxy        basetypes.ObjectValue `tfsdk:"ssl_proxy"`
	Tenants         basetypes.ListValue   `tfsdk:"tenants"`
	state           attr.ValueState
}

func (v ServicePoliciesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 12)

	var val tftypes.Value
	var err error

	attrTypes["action"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["antivirus"] = basetypes.ObjectType{
		AttrTypes: AntivirusValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["appqoe"] = basetypes.ObjectType{
		AttrTypes: AppqoeValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["ewf"] = basetypes.ListType{
		ElemType: EwfValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["idp"] = basetypes.ObjectType{
		AttrTypes: IdpValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["local_routing"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["path_preference"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["servicepolicy_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["services"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["ssl_proxy"] = basetypes.ObjectType{
		AttrTypes: SslProxyValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["tenants"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 12)

		val, err = v.Action.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["action"] = val

		val, err = v.Antivirus.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["antivirus"] = val

		val, err = v.Appqoe.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["appqoe"] = val

		val, err = v.Ewf.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ewf"] = val

		val, err = v.Idp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["idp"] = val

		val, err = v.LocalRouting.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["local_routing"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.PathPreference.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["path_preference"] = val

		val, err = v.ServicepolicyId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["servicepolicy_id"] = val

		val, err = v.Services.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["services"] = val

		val, err = v.SslProxy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ssl_proxy"] = val

		val, err = v.Tenants.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tenants"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ServicePoliciesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ServicePoliciesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ServicePoliciesValue) String() string {
	return "ServicePoliciesValue"
}

func (v ServicePoliciesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var antivirus basetypes.ObjectValue

	if v.Antivirus.IsNull() {
		antivirus = types.ObjectNull(
			AntivirusValue{}.AttributeTypes(ctx),
		)
	}

	if v.Antivirus.IsUnknown() {
		antivirus = types.ObjectUnknown(
			AntivirusValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Antivirus.IsNull() && !v.Antivirus.IsUnknown() {
		antivirus = types.ObjectValueMust(
			AntivirusValue{}.AttributeTypes(ctx),
			v.Antivirus.Attributes(),
		)
	}

	var appqoe basetypes.ObjectValue

	if v.Appqoe.IsNull() {
		appqoe = types.ObjectNull(
			AppqoeValue{}.AttributeTypes(ctx),
		)
	}

	if v.Appqoe.IsUnknown() {
		appqoe = types.ObjectUnknown(
			AppqoeValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Appqoe.IsNull() && !v.Appqoe.IsUnknown() {
		appqoe = types.ObjectValueMust(
			AppqoeValue{}.AttributeTypes(ctx),
			v.Appqoe.Attributes(),
		)
	}

	ewf := types.ListValueMust(
		EwfType{
			basetypes.ObjectType{
				AttrTypes: EwfValue{}.AttributeTypes(ctx),
			},
		},
		v.Ewf.Elements(),
	)

	if v.Ewf.IsNull() {
		ewf = types.ListNull(
			EwfType{
				basetypes.ObjectType{
					AttrTypes: EwfValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Ewf.IsUnknown() {
		ewf = types.ListUnknown(
			EwfType{
				basetypes.ObjectType{
					AttrTypes: EwfValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var idp basetypes.ObjectValue

	if v.Idp.IsNull() {
		idp = types.ObjectNull(
			IdpValue{}.AttributeTypes(ctx),
		)
	}

	if v.Idp.IsUnknown() {
		idp = types.ObjectUnknown(
			IdpValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Idp.IsNull() && !v.Idp.IsUnknown() {
		idp = types.ObjectValueMust(
			IdpValue{}.AttributeTypes(ctx),
			v.Idp.Attributes(),
		)
	}

	var sslProxy basetypes.ObjectValue

	if v.SslProxy.IsNull() {
		sslProxy = types.ObjectNull(
			SslProxyValue{}.AttributeTypes(ctx),
		)
	}

	if v.SslProxy.IsUnknown() {
		sslProxy = types.ObjectUnknown(
			SslProxyValue{}.AttributeTypes(ctx),
		)
	}

	if !v.SslProxy.IsNull() && !v.SslProxy.IsUnknown() {
		sslProxy = types.ObjectValueMust(
			SslProxyValue{}.AttributeTypes(ctx),
			v.SslProxy.Attributes(),
		)
	}

	var servicesVal basetypes.ListValue
	switch {
	case v.Services.IsUnknown():
		servicesVal = types.ListUnknown(types.StringType)
	case v.Services.IsNull():
		servicesVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		servicesVal, d = types.ListValue(types.StringType, v.Services.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"action": basetypes.StringType{},
			"antivirus": basetypes.ObjectType{
				AttrTypes: AntivirusValue{}.AttributeTypes(ctx),
			},
			"appqoe": basetypes.ObjectType{
				AttrTypes: AppqoeValue{}.AttributeTypes(ctx),
			},
			"ewf": basetypes.ListType{
				ElemType: EwfValue{}.Type(ctx),
			},
			"idp": basetypes.ObjectType{
				AttrTypes: IdpValue{}.AttributeTypes(ctx),
			},
			"local_routing":    basetypes.BoolType{},
			"name":             basetypes.StringType{},
			"path_preference":  basetypes.StringType{},
			"servicepolicy_id": basetypes.StringType{},
			"services": basetypes.ListType{
				ElemType: types.StringType,
			},
			"ssl_proxy": basetypes.ObjectType{
				AttrTypes: SslProxyValue{}.AttributeTypes(ctx),
			},
			"tenants": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	var tenantsVal basetypes.ListValue
	switch {
	case v.Tenants.IsUnknown():
		tenantsVal = types.ListUnknown(types.StringType)
	case v.Tenants.IsNull():
		tenantsVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		tenantsVal, d = types.ListValue(types.StringType, v.Tenants.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"action": basetypes.StringType{},
			"antivirus": basetypes.ObjectType{
				AttrTypes: AntivirusValue{}.AttributeTypes(ctx),
			},
			"appqoe": basetypes.ObjectType{
				AttrTypes: AppqoeValue{}.AttributeTypes(ctx),
			},
			"ewf": basetypes.ListType{
				ElemType: EwfValue{}.Type(ctx),
			},
			"idp": basetypes.ObjectType{
				AttrTypes: IdpValue{}.AttributeTypes(ctx),
			},
			"local_routing":    basetypes.BoolType{},
			"name":             basetypes.StringType{},
			"path_preference":  basetypes.StringType{},
			"servicepolicy_id": basetypes.StringType{},
			"services": basetypes.ListType{
				ElemType: types.StringType,
			},
			"ssl_proxy": basetypes.ObjectType{
				AttrTypes: SslProxyValue{}.AttributeTypes(ctx),
			},
			"tenants": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"action": basetypes.StringType{},
		"antivirus": basetypes.ObjectType{
			AttrTypes: AntivirusValue{}.AttributeTypes(ctx),
		},
		"appqoe": basetypes.ObjectType{
			AttrTypes: AppqoeValue{}.AttributeTypes(ctx),
		},
		"ewf": basetypes.ListType{
			ElemType: EwfValue{}.Type(ctx),
		},
		"idp": basetypes.ObjectType{
			AttrTypes: IdpValue{}.AttributeTypes(ctx),
		},
		"local_routing":    basetypes.BoolType{},
		"name":             basetypes.StringType{},
		"path_preference":  basetypes.StringType{},
		"servicepolicy_id": basetypes.StringType{},
		"services": basetypes.ListType{
			ElemType: types.StringType,
		},
		"ssl_proxy": basetypes.ObjectType{
			AttrTypes: SslProxyValue{}.AttributeTypes(ctx),
		},
		"tenants": basetypes.ListType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"action":           v.Action,
			"antivirus":        antivirus,
			"appqoe":           appqoe,
			"ewf":              ewf,
			"idp":              idp,
			"local_routing":    v.LocalRouting,
			"name":             v.Name,
			"path_preference":  v.PathPreference,
			"servicepolicy_id": v.ServicepolicyId,
			"services":         servicesVal,
			"ssl_proxy":        sslProxy,
			"tenants":          tenantsVal,
		})

	return objVal, diags
}

func (v ServicePoliciesValue) Equal(o attr.Value) bool {
	other, ok := o.(ServicePoliciesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Action.Equal(other.Action) {
		return false
	}

	if !v.Antivirus.Equal(other.Antivirus) {
		return false
	}

	if !v.Appqoe.Equal(other.Appqoe) {
		return false
	}

	if !v.Ewf.Equal(other.Ewf) {
		return false
	}

	if !v.Idp.Equal(other.Idp) {
		return false
	}

	if !v.LocalRouting.Equal(other.LocalRouting) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.PathPreference.Equal(other.PathPreference) {
		return false
	}

	if !v.ServicepolicyId.Equal(other.ServicepolicyId) {
		return false
	}

	if !v.Services.Equal(other.Services) {
		return false
	}

	if !v.SslProxy.Equal(other.SslProxy) {
		return false
	}

	if !v.Tenants.Equal(other.Tenants) {
		return false
	}

	return true
}

func (v ServicePoliciesValue) Type(ctx context.Context) attr.Type {
	return ServicePoliciesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ServicePoliciesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"action": basetypes.StringType{},
		"antivirus": basetypes.ObjectType{
			AttrTypes: AntivirusValue{}.AttributeTypes(ctx),
		},
		"appqoe": basetypes.ObjectType{
			AttrTypes: AppqoeValue{}.AttributeTypes(ctx),
		},
		"ewf": basetypes.ListType{
			ElemType: EwfValue{}.Type(ctx),
		},
		"idp": basetypes.ObjectType{
			AttrTypes: IdpValue{}.AttributeTypes(ctx),
		},
		"local_routing":    basetypes.BoolType{},
		"name":             basetypes.StringType{},
		"path_preference":  basetypes.StringType{},
		"servicepolicy_id": basetypes.StringType{},
		"services": basetypes.ListType{
			ElemType: types.StringType,
		},
		"ssl_proxy": basetypes.ObjectType{
			AttrTypes: SslProxyValue{}.AttributeTypes(ctx),
		},
		"tenants": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = AntivirusType{}

type AntivirusType struct {
	basetypes.ObjectType
}

func (t AntivirusType) Equal(o attr.Type) bool {
	other, ok := o.(AntivirusType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AntivirusType) String() string {
	return "AntivirusType"
}

func (t AntivirusType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	avprofileIdAttribute, ok := attributes["avprofile_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`avprofile_id is missing from object`)

		return nil, diags
	}

	avprofileIdVal, ok := avprofileIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`avprofile_id expected to be basetypes.StringValue, was: %T`, avprofileIdAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	profileAttribute, ok := attributes["profile"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`profile is missing from object`)

		return nil, diags
	}

	profileVal, ok := profileAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`profile expected to be basetypes.StringValue, was: %T`, profileAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AntivirusValue{
		AvprofileId: avprofileIdVal,
		Enabled:     enabledVal,
		Profile:     profileVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewAntivirusValueNull() AntivirusValue {
	return AntivirusValue{
		state: attr.ValueStateNull,
	}
}

func NewAntivirusValueUnknown() AntivirusValue {
	return AntivirusValue{
		state: attr.ValueStateUnknown,
	}
}

func NewAntivirusValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AntivirusValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AntivirusValue Attribute Value",
				"While creating a AntivirusValue value, a missing attribute value was detected. "+
					"A AntivirusValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AntivirusValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AntivirusValue Attribute Type",
				"While creating a AntivirusValue value, an invalid attribute value was detected. "+
					"A AntivirusValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AntivirusValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AntivirusValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AntivirusValue Attribute Value",
				"While creating a AntivirusValue value, an extra attribute value was detected. "+
					"A AntivirusValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AntivirusValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAntivirusValueUnknown(), diags
	}

	avprofileIdAttribute, ok := attributes["avprofile_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`avprofile_id is missing from object`)

		return NewAntivirusValueUnknown(), diags
	}

	avprofileIdVal, ok := avprofileIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`avprofile_id expected to be basetypes.StringValue, was: %T`, avprofileIdAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewAntivirusValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	profileAttribute, ok := attributes["profile"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`profile is missing from object`)

		return NewAntivirusValueUnknown(), diags
	}

	profileVal, ok := profileAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`profile expected to be basetypes.StringValue, was: %T`, profileAttribute))
	}

	if diags.HasError() {
		return NewAntivirusValueUnknown(), diags
	}

	return AntivirusValue{
		AvprofileId: avprofileIdVal,
		Enabled:     enabledVal,
		Profile:     profileVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewAntivirusValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AntivirusValue {
	object, diags := NewAntivirusValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAntivirusValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AntivirusType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAntivirusValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAntivirusValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAntivirusValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAntivirusValueMust(AntivirusValue{}.AttributeTypes(ctx), attributes), nil
}

func (t AntivirusType) ValueType(ctx context.Context) attr.Value {
	return AntivirusValue{}
}

var _ basetypes.ObjectValuable = AntivirusValue{}

type AntivirusValue struct {
	AvprofileId basetypes.StringValue `tfsdk:"avprofile_id"`
	Enabled     basetypes.BoolValue   `tfsdk:"enabled"`
	Profile     basetypes.StringValue `tfsdk:"profile"`
	state       attr.ValueState
}

func (v AntivirusValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["avprofile_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["profile"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.AvprofileId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["avprofile_id"] = val

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.Profile.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["profile"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AntivirusValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AntivirusValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AntivirusValue) String() string {
	return "AntivirusValue"
}

func (v AntivirusValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"avprofile_id": basetypes.StringType{},
		"enabled":      basetypes.BoolType{},
		"profile":      basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"avprofile_id": v.AvprofileId,
			"enabled":      v.Enabled,
			"profile":      v.Profile,
		})

	return objVal, diags
}

func (v AntivirusValue) Equal(o attr.Value) bool {
	other, ok := o.(AntivirusValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AvprofileId.Equal(other.AvprofileId) {
		return false
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.Profile.Equal(other.Profile) {
		return false
	}

	return true
}

func (v AntivirusValue) Type(ctx context.Context) attr.Type {
	return AntivirusType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AntivirusValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"avprofile_id": basetypes.StringType{},
		"enabled":      basetypes.BoolType{},
		"profile":      basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = AppqoeType{}

type AppqoeType struct {
	basetypes.ObjectType
}

func (t AppqoeType) Equal(o attr.Type) bool {
	other, ok := o.(AppqoeType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AppqoeType) String() string {
	return "AppqoeType"
}

func (t AppqoeType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AppqoeValue{
		Enabled: enabledVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewAppqoeValueNull() AppqoeValue {
	return AppqoeValue{
		state: attr.ValueStateNull,
	}
}

func NewAppqoeValueUnknown() AppqoeValue {
	return AppqoeValue{
		state: attr.ValueStateUnknown,
	}
}

func NewAppqoeValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AppqoeValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AppqoeValue Attribute Value",
				"While creating a AppqoeValue value, a missing attribute value was detected. "+
					"A AppqoeValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AppqoeValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AppqoeValue Attribute Type",
				"While creating a AppqoeValue value, an invalid attribute value was detected. "+
					"A AppqoeValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AppqoeValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AppqoeValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AppqoeValue Attribute Value",
				"While creating a AppqoeValue value, an extra attribute value was detected. "+
					"A AppqoeValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AppqoeValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAppqoeValueUnknown(), diags
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewAppqoeValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	if diags.HasError() {
		return NewAppqoeValueUnknown(), diags
	}

	return AppqoeValue{
		Enabled: enabledVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewAppqoeValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AppqoeValue {
	object, diags := NewAppqoeValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAppqoeValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AppqoeType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAppqoeValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAppqoeValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAppqoeValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAppqoeValueMust(AppqoeValue{}.AttributeTypes(ctx), attributes), nil
}

func (t AppqoeType) ValueType(ctx context.Context) attr.Value {
	return AppqoeValue{}
}

var _ basetypes.ObjectValuable = AppqoeValue{}

type AppqoeValue struct {
	Enabled basetypes.BoolValue `tfsdk:"enabled"`
	state   attr.ValueState
}

func (v AppqoeValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AppqoeValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AppqoeValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AppqoeValue) String() string {
	return "AppqoeValue"
}

func (v AppqoeValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"enabled": basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"enabled": v.Enabled,
		})

	return objVal, diags
}

func (v AppqoeValue) Equal(o attr.Value) bool {
	other, ok := o.(AppqoeValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	return true
}

func (v AppqoeValue) Type(ctx context.Context) attr.Type {
	return AppqoeType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AppqoeValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"enabled": basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = EwfType{}

type EwfType struct {
	basetypes.ObjectType
}

func (t EwfType) Equal(o attr.Type) bool {
	other, ok := o.(EwfType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t EwfType) String() string {
	return "EwfType"
}

func (t EwfType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	alertOnlyAttribute, ok := attributes["alert_only"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`alert_only is missing from object`)

		return nil, diags
	}

	alertOnlyVal, ok := alertOnlyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`alert_only expected to be basetypes.BoolValue, was: %T`, alertOnlyAttribute))
	}

	blockMessageAttribute, ok := attributes["block_message"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`block_message is missing from object`)

		return nil, diags
	}

	blockMessageVal, ok := blockMessageAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`block_message expected to be basetypes.StringValue, was: %T`, blockMessageAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	profileAttribute, ok := attributes["profile"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`profile is missing from object`)

		return nil, diags
	}

	profileVal, ok := profileAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`profile expected to be basetypes.StringValue, was: %T`, profileAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return EwfValue{
		AlertOnly:    alertOnlyVal,
		BlockMessage: blockMessageVal,
		Enabled:      enabledVal,
		Profile:      profileVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewEwfValueNull() EwfValue {
	return EwfValue{
		state: attr.ValueStateNull,
	}
}

func NewEwfValueUnknown() EwfValue {
	return EwfValue{
		state: attr.ValueStateUnknown,
	}
}

func NewEwfValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (EwfValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing EwfValue Attribute Value",
				"While creating a EwfValue value, a missing attribute value was detected. "+
					"A EwfValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("EwfValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid EwfValue Attribute Type",
				"While creating a EwfValue value, an invalid attribute value was detected. "+
					"A EwfValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("EwfValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("EwfValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra EwfValue Attribute Value",
				"While creating a EwfValue value, an extra attribute value was detected. "+
					"A EwfValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra EwfValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewEwfValueUnknown(), diags
	}

	alertOnlyAttribute, ok := attributes["alert_only"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`alert_only is missing from object`)

		return NewEwfValueUnknown(), diags
	}

	alertOnlyVal, ok := alertOnlyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`alert_only expected to be basetypes.BoolValue, was: %T`, alertOnlyAttribute))
	}

	blockMessageAttribute, ok := attributes["block_message"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`block_message is missing from object`)

		return NewEwfValueUnknown(), diags
	}

	blockMessageVal, ok := blockMessageAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`block_message expected to be basetypes.StringValue, was: %T`, blockMessageAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewEwfValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	profileAttribute, ok := attributes["profile"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`profile is missing from object`)

		return NewEwfValueUnknown(), diags
	}

	profileVal, ok := profileAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`profile expected to be basetypes.StringValue, was: %T`, profileAttribute))
	}

	if diags.HasError() {
		return NewEwfValueUnknown(), diags
	}

	return EwfValue{
		AlertOnly:    alertOnlyVal,
		BlockMessage: blockMessageVal,
		Enabled:      enabledVal,
		Profile:      profileVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewEwfValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) EwfValue {
	object, diags := NewEwfValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewEwfValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t EwfType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewEwfValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewEwfValueUnknown(), nil
	}

	if in.IsNull() {
		return NewEwfValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewEwfValueMust(EwfValue{}.AttributeTypes(ctx), attributes), nil
}

func (t EwfType) ValueType(ctx context.Context) attr.Value {
	return EwfValue{}
}

var _ basetypes.ObjectValuable = EwfValue{}

type EwfValue struct {
	AlertOnly    basetypes.BoolValue   `tfsdk:"alert_only"`
	BlockMessage basetypes.StringValue `tfsdk:"block_message"`
	Enabled      basetypes.BoolValue   `tfsdk:"enabled"`
	Profile      basetypes.StringValue `tfsdk:"profile"`
	state        attr.ValueState
}

func (v EwfValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["alert_only"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["block_message"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["profile"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.AlertOnly.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["alert_only"] = val

		val, err = v.BlockMessage.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["block_message"] = val

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.Profile.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["profile"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v EwfValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v EwfValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v EwfValue) String() string {
	return "EwfValue"
}

func (v EwfValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"alert_only":    basetypes.BoolType{},
		"block_message": basetypes.StringType{},
		"enabled":       basetypes.BoolType{},
		"profile":       basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"alert_only":    v.AlertOnly,
			"block_message": v.BlockMessage,
			"enabled":       v.Enabled,
			"profile":       v.Profile,
		})

	return objVal, diags
}

func (v EwfValue) Equal(o attr.Value) bool {
	other, ok := o.(EwfValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AlertOnly.Equal(other.AlertOnly) {
		return false
	}

	if !v.BlockMessage.Equal(other.BlockMessage) {
		return false
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.Profile.Equal(other.Profile) {
		return false
	}

	return true
}

func (v EwfValue) Type(ctx context.Context) attr.Type {
	return EwfType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v EwfValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"alert_only":    basetypes.BoolType{},
		"block_message": basetypes.StringType{},
		"enabled":       basetypes.BoolType{},
		"profile":       basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = IdpType{}

type IdpType struct {
	basetypes.ObjectType
}

func (t IdpType) Equal(o attr.Type) bool {
	other, ok := o.(IdpType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t IdpType) String() string {
	return "IdpType"
}

func (t IdpType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	alertOnlyAttribute, ok := attributes["alert_only"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`alert_only is missing from object`)

		return nil, diags
	}

	alertOnlyVal, ok := alertOnlyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`alert_only expected to be basetypes.BoolValue, was: %T`, alertOnlyAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	idpprofileIdAttribute, ok := attributes["idpprofile_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`idpprofile_id is missing from object`)

		return nil, diags
	}

	idpprofileIdVal, ok := idpprofileIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`idpprofile_id expected to be basetypes.StringValue, was: %T`, idpprofileIdAttribute))
	}

	profileAttribute, ok := attributes["profile"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`profile is missing from object`)

		return nil, diags
	}

	profileVal, ok := profileAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`profile expected to be basetypes.StringValue, was: %T`, profileAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return IdpValue{
		AlertOnly:    alertOnlyVal,
		Enabled:      enabledVal,
		IdpprofileId: idpprofileIdVal,
		Profile:      profileVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewIdpValueNull() IdpValue {
	return IdpValue{
		state: attr.ValueStateNull,
	}
}

func NewIdpValueUnknown() IdpValue {
	return IdpValue{
		state: attr.ValueStateUnknown,
	}
}

func NewIdpValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (IdpValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing IdpValue Attribute Value",
				"While creating a IdpValue value, a missing attribute value was detected. "+
					"A IdpValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("IdpValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid IdpValue Attribute Type",
				"While creating a IdpValue value, an invalid attribute value was detected. "+
					"A IdpValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("IdpValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("IdpValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra IdpValue Attribute Value",
				"While creating a IdpValue value, an extra attribute value was detected. "+
					"A IdpValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra IdpValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewIdpValueUnknown(), diags
	}

	alertOnlyAttribute, ok := attributes["alert_only"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`alert_only is missing from object`)

		return NewIdpValueUnknown(), diags
	}

	alertOnlyVal, ok := alertOnlyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`alert_only expected to be basetypes.BoolValue, was: %T`, alertOnlyAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewIdpValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	idpprofileIdAttribute, ok := attributes["idpprofile_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`idpprofile_id is missing from object`)

		return NewIdpValueUnknown(), diags
	}

	idpprofileIdVal, ok := idpprofileIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`idpprofile_id expected to be basetypes.StringValue, was: %T`, idpprofileIdAttribute))
	}

	profileAttribute, ok := attributes["profile"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`profile is missing from object`)

		return NewIdpValueUnknown(), diags
	}

	profileVal, ok := profileAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`profile expected to be basetypes.StringValue, was: %T`, profileAttribute))
	}

	if diags.HasError() {
		return NewIdpValueUnknown(), diags
	}

	return IdpValue{
		AlertOnly:    alertOnlyVal,
		Enabled:      enabledVal,
		IdpprofileId: idpprofileIdVal,
		Profile:      profileVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewIdpValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) IdpValue {
	object, diags := NewIdpValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewIdpValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t IdpType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewIdpValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewIdpValueUnknown(), nil
	}

	if in.IsNull() {
		return NewIdpValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewIdpValueMust(IdpValue{}.AttributeTypes(ctx), attributes), nil
}

func (t IdpType) ValueType(ctx context.Context) attr.Value {
	return IdpValue{}
}

var _ basetypes.ObjectValuable = IdpValue{}

type IdpValue struct {
	AlertOnly    basetypes.BoolValue   `tfsdk:"alert_only"`
	Enabled      basetypes.BoolValue   `tfsdk:"enabled"`
	IdpprofileId basetypes.StringValue `tfsdk:"idpprofile_id"`
	Profile      basetypes.StringValue `tfsdk:"profile"`
	state        attr.ValueState
}

func (v IdpValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["alert_only"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["idpprofile_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["profile"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.AlertOnly.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["alert_only"] = val

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.IdpprofileId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["idpprofile_id"] = val

		val, err = v.Profile.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["profile"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v IdpValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v IdpValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v IdpValue) String() string {
	return "IdpValue"
}

func (v IdpValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"alert_only":    basetypes.BoolType{},
		"enabled":       basetypes.BoolType{},
		"idpprofile_id": basetypes.StringType{},
		"profile":       basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"alert_only":    v.AlertOnly,
			"enabled":       v.Enabled,
			"idpprofile_id": v.IdpprofileId,
			"profile":       v.Profile,
		})

	return objVal, diags
}

func (v IdpValue) Equal(o attr.Value) bool {
	other, ok := o.(IdpValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AlertOnly.Equal(other.AlertOnly) {
		return false
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.IdpprofileId.Equal(other.IdpprofileId) {
		return false
	}

	if !v.Profile.Equal(other.Profile) {
		return false
	}

	return true
}

func (v IdpValue) Type(ctx context.Context) attr.Type {
	return IdpType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v IdpValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"alert_only":    basetypes.BoolType{},
		"enabled":       basetypes.BoolType{},
		"idpprofile_id": basetypes.StringType{},
		"profile":       basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = SslProxyType{}

type SslProxyType struct {
	basetypes.ObjectType
}

func (t SslProxyType) Equal(o attr.Type) bool {
	other, ok := o.(SslProxyType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SslProxyType) String() string {
	return "SslProxyType"
}

func (t SslProxyType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	ciphersCategoryAttribute, ok := attributes["ciphers_category"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ciphers_category is missing from object`)

		return nil, diags
	}

	ciphersCategoryVal, ok := ciphersCategoryAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ciphers_category expected to be basetypes.StringValue, was: %T`, ciphersCategoryAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SslProxyValue{
		CiphersCategory: ciphersCategoryVal,
		Enabled:         enabledVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewSslProxyValueNull() SslProxyValue {
	return SslProxyValue{
		state: attr.ValueStateNull,
	}
}

func NewSslProxyValueUnknown() SslProxyValue {
	return SslProxyValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSslProxyValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SslProxyValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SslProxyValue Attribute Value",
				"While creating a SslProxyValue value, a missing attribute value was detected. "+
					"A SslProxyValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SslProxyValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SslProxyValue Attribute Type",
				"While creating a SslProxyValue value, an invalid attribute value was detected. "+
					"A SslProxyValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SslProxyValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SslProxyValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SslProxyValue Attribute Value",
				"While creating a SslProxyValue value, an extra attribute value was detected. "+
					"A SslProxyValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SslProxyValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSslProxyValueUnknown(), diags
	}

	ciphersCategoryAttribute, ok := attributes["ciphers_category"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ciphers_category is missing from object`)

		return NewSslProxyValueUnknown(), diags
	}

	ciphersCategoryVal, ok := ciphersCategoryAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ciphers_category expected to be basetypes.StringValue, was: %T`, ciphersCategoryAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewSslProxyValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	if diags.HasError() {
		return NewSslProxyValueUnknown(), diags
	}

	return SslProxyValue{
		CiphersCategory: ciphersCategoryVal,
		Enabled:         enabledVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewSslProxyValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SslProxyValue {
	object, diags := NewSslProxyValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSslProxyValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SslProxyType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSslProxyValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSslProxyValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSslProxyValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSslProxyValueMust(SslProxyValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SslProxyType) ValueType(ctx context.Context) attr.Value {
	return SslProxyValue{}
}

var _ basetypes.ObjectValuable = SslProxyValue{}

type SslProxyValue struct {
	CiphersCategory basetypes.StringValue `tfsdk:"ciphers_category"`
	Enabled         basetypes.BoolValue   `tfsdk:"enabled"`
	state           attr.ValueState
}

func (v SslProxyValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["ciphers_category"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.CiphersCategory.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ciphers_category"] = val

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SslProxyValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SslProxyValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SslProxyValue) String() string {
	return "SslProxyValue"
}

func (v SslProxyValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"ciphers_category": basetypes.StringType{},
		"enabled":          basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"ciphers_category": v.CiphersCategory,
			"enabled":          v.Enabled,
		})

	return objVal, diags
}

func (v SslProxyValue) Equal(o attr.Value) bool {
	other, ok := o.(SslProxyValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.CiphersCategory.Equal(other.CiphersCategory) {
		return false
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	return true
}

func (v SslProxyValue) Type(ctx context.Context) attr.Type {
	return SslProxyType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SslProxyValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"ciphers_category": basetypes.StringType{},
		"enabled":          basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = TunnelConfigsType{}

type TunnelConfigsType struct {
	basetypes.ObjectType
}

func (t TunnelConfigsType) Equal(o attr.Type) bool {
	other, ok := o.(TunnelConfigsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t TunnelConfigsType) String() string {
	return "TunnelConfigsType"
}

func (t TunnelConfigsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	autoProvisionAttribute, ok := attributes["auto_provision"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auto_provision is missing from object`)

		return nil, diags
	}

	autoProvisionVal, ok := autoProvisionAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auto_provision expected to be basetypes.ObjectValue, was: %T`, autoProvisionAttribute))
	}

	ikeLifetimeAttribute, ok := attributes["ike_lifetime"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ike_lifetime is missing from object`)

		return nil, diags
	}

	ikeLifetimeVal, ok := ikeLifetimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ike_lifetime expected to be basetypes.Int64Value, was: %T`, ikeLifetimeAttribute))
	}

	ikeModeAttribute, ok := attributes["ike_mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ike_mode is missing from object`)

		return nil, diags
	}

	ikeModeVal, ok := ikeModeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ike_mode expected to be basetypes.StringValue, was: %T`, ikeModeAttribute))
	}

	ikeProposalsAttribute, ok := attributes["ike_proposals"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ike_proposals is missing from object`)

		return nil, diags
	}

	ikeProposalsVal, ok := ikeProposalsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ike_proposals expected to be basetypes.ListValue, was: %T`, ikeProposalsAttribute))
	}

	ipsecLifetimeAttribute, ok := attributes["ipsec_lifetime"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipsec_lifetime is missing from object`)

		return nil, diags
	}

	ipsecLifetimeVal, ok := ipsecLifetimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipsec_lifetime expected to be basetypes.Int64Value, was: %T`, ipsecLifetimeAttribute))
	}

	ipsecProposalsAttribute, ok := attributes["ipsec_proposals"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipsec_proposals is missing from object`)

		return nil, diags
	}

	ipsecProposalsVal, ok := ipsecProposalsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipsec_proposals expected to be basetypes.ListValue, was: %T`, ipsecProposalsAttribute))
	}

	localIdAttribute, ok := attributes["local_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`local_id is missing from object`)

		return nil, diags
	}

	localIdVal, ok := localIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`local_id expected to be basetypes.StringValue, was: %T`, localIdAttribute))
	}

	modeAttribute, ok := attributes["mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mode is missing from object`)

		return nil, diags
	}

	modeVal, ok := modeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mode expected to be basetypes.StringValue, was: %T`, modeAttribute))
	}

	networksAttribute, ok := attributes["networks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`networks is missing from object`)

		return nil, diags
	}

	networksVal, ok := networksAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`networks expected to be basetypes.ListValue, was: %T`, networksAttribute))
	}

	primaryAttribute, ok := attributes["primary"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`primary is missing from object`)

		return nil, diags
	}

	primaryVal, ok := primaryAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`primary expected to be basetypes.ObjectValue, was: %T`, primaryAttribute))
	}

	probeAttribute, ok := attributes["probe"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`probe is missing from object`)

		return nil, diags
	}

	probeVal, ok := probeAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`probe expected to be basetypes.ObjectValue, was: %T`, probeAttribute))
	}

	protocolAttribute, ok := attributes["protocol"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`protocol is missing from object`)

		return nil, diags
	}

	protocolVal, ok := protocolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`protocol expected to be basetypes.StringValue, was: %T`, protocolAttribute))
	}

	providerAttribute, ok := attributes["provider"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`provider is missing from object`)

		return nil, diags
	}

	providerVal, ok := providerAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`provider expected to be basetypes.StringValue, was: %T`, providerAttribute))
	}

	pskAttribute, ok := attributes["psk"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`psk is missing from object`)

		return nil, diags
	}

	pskVal, ok := pskAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`psk expected to be basetypes.StringValue, was: %T`, pskAttribute))
	}

	secondaryAttribute, ok := attributes["secondary"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`secondary is missing from object`)

		return nil, diags
	}

	secondaryVal, ok := secondaryAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`secondary expected to be basetypes.ObjectValue, was: %T`, secondaryAttribute))
	}

	versionAttribute, ok := attributes["version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`version is missing from object`)

		return nil, diags
	}

	versionVal, ok := versionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`version expected to be basetypes.StringValue, was: %T`, versionAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return TunnelConfigsValue{
		AutoProvision:  autoProvisionVal,
		IkeLifetime:    ikeLifetimeVal,
		IkeMode:        ikeModeVal,
		IkeProposals:   ikeProposalsVal,
		IpsecLifetime:  ipsecLifetimeVal,
		IpsecProposals: ipsecProposalsVal,
		LocalId:        localIdVal,
		Mode:           modeVal,
		Networks:       networksVal,
		Primary:        primaryVal,
		Probe:          probeVal,
		Protocol:       protocolVal,
		Provider:       providerVal,
		Psk:            pskVal,
		Secondary:      secondaryVal,
		Version:        versionVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewTunnelConfigsValueNull() TunnelConfigsValue {
	return TunnelConfigsValue{
		state: attr.ValueStateNull,
	}
}

func NewTunnelConfigsValueUnknown() TunnelConfigsValue {
	return TunnelConfigsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewTunnelConfigsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (TunnelConfigsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing TunnelConfigsValue Attribute Value",
				"While creating a TunnelConfigsValue value, a missing attribute value was detected. "+
					"A TunnelConfigsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TunnelConfigsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid TunnelConfigsValue Attribute Type",
				"While creating a TunnelConfigsValue value, an invalid attribute value was detected. "+
					"A TunnelConfigsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TunnelConfigsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("TunnelConfigsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra TunnelConfigsValue Attribute Value",
				"While creating a TunnelConfigsValue value, an extra attribute value was detected. "+
					"A TunnelConfigsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra TunnelConfigsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewTunnelConfigsValueUnknown(), diags
	}

	autoProvisionAttribute, ok := attributes["auto_provision"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auto_provision is missing from object`)

		return NewTunnelConfigsValueUnknown(), diags
	}

	autoProvisionVal, ok := autoProvisionAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auto_provision expected to be basetypes.ObjectValue, was: %T`, autoProvisionAttribute))
	}

	ikeLifetimeAttribute, ok := attributes["ike_lifetime"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ike_lifetime is missing from object`)

		return NewTunnelConfigsValueUnknown(), diags
	}

	ikeLifetimeVal, ok := ikeLifetimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ike_lifetime expected to be basetypes.Int64Value, was: %T`, ikeLifetimeAttribute))
	}

	ikeModeAttribute, ok := attributes["ike_mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ike_mode is missing from object`)

		return NewTunnelConfigsValueUnknown(), diags
	}

	ikeModeVal, ok := ikeModeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ike_mode expected to be basetypes.StringValue, was: %T`, ikeModeAttribute))
	}

	ikeProposalsAttribute, ok := attributes["ike_proposals"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ike_proposals is missing from object`)

		return NewTunnelConfigsValueUnknown(), diags
	}

	ikeProposalsVal, ok := ikeProposalsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ike_proposals expected to be basetypes.ListValue, was: %T`, ikeProposalsAttribute))
	}

	ipsecLifetimeAttribute, ok := attributes["ipsec_lifetime"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipsec_lifetime is missing from object`)

		return NewTunnelConfigsValueUnknown(), diags
	}

	ipsecLifetimeVal, ok := ipsecLifetimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipsec_lifetime expected to be basetypes.Int64Value, was: %T`, ipsecLifetimeAttribute))
	}

	ipsecProposalsAttribute, ok := attributes["ipsec_proposals"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipsec_proposals is missing from object`)

		return NewTunnelConfigsValueUnknown(), diags
	}

	ipsecProposalsVal, ok := ipsecProposalsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipsec_proposals expected to be basetypes.ListValue, was: %T`, ipsecProposalsAttribute))
	}

	localIdAttribute, ok := attributes["local_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`local_id is missing from object`)

		return NewTunnelConfigsValueUnknown(), diags
	}

	localIdVal, ok := localIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`local_id expected to be basetypes.StringValue, was: %T`, localIdAttribute))
	}

	modeAttribute, ok := attributes["mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mode is missing from object`)

		return NewTunnelConfigsValueUnknown(), diags
	}

	modeVal, ok := modeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mode expected to be basetypes.StringValue, was: %T`, modeAttribute))
	}

	networksAttribute, ok := attributes["networks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`networks is missing from object`)

		return NewTunnelConfigsValueUnknown(), diags
	}

	networksVal, ok := networksAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`networks expected to be basetypes.ListValue, was: %T`, networksAttribute))
	}

	primaryAttribute, ok := attributes["primary"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`primary is missing from object`)

		return NewTunnelConfigsValueUnknown(), diags
	}

	primaryVal, ok := primaryAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`primary expected to be basetypes.ObjectValue, was: %T`, primaryAttribute))
	}

	probeAttribute, ok := attributes["probe"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`probe is missing from object`)

		return NewTunnelConfigsValueUnknown(), diags
	}

	probeVal, ok := probeAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`probe expected to be basetypes.ObjectValue, was: %T`, probeAttribute))
	}

	protocolAttribute, ok := attributes["protocol"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`protocol is missing from object`)

		return NewTunnelConfigsValueUnknown(), diags
	}

	protocolVal, ok := protocolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`protocol expected to be basetypes.StringValue, was: %T`, protocolAttribute))
	}

	providerAttribute, ok := attributes["provider"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`provider is missing from object`)

		return NewTunnelConfigsValueUnknown(), diags
	}

	providerVal, ok := providerAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`provider expected to be basetypes.StringValue, was: %T`, providerAttribute))
	}

	pskAttribute, ok := attributes["psk"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`psk is missing from object`)

		return NewTunnelConfigsValueUnknown(), diags
	}

	pskVal, ok := pskAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`psk expected to be basetypes.StringValue, was: %T`, pskAttribute))
	}

	secondaryAttribute, ok := attributes["secondary"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`secondary is missing from object`)

		return NewTunnelConfigsValueUnknown(), diags
	}

	secondaryVal, ok := secondaryAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`secondary expected to be basetypes.ObjectValue, was: %T`, secondaryAttribute))
	}

	versionAttribute, ok := attributes["version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`version is missing from object`)

		return NewTunnelConfigsValueUnknown(), diags
	}

	versionVal, ok := versionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`version expected to be basetypes.StringValue, was: %T`, versionAttribute))
	}

	if diags.HasError() {
		return NewTunnelConfigsValueUnknown(), diags
	}

	return TunnelConfigsValue{
		AutoProvision:  autoProvisionVal,
		IkeLifetime:    ikeLifetimeVal,
		IkeMode:        ikeModeVal,
		IkeProposals:   ikeProposalsVal,
		IpsecLifetime:  ipsecLifetimeVal,
		IpsecProposals: ipsecProposalsVal,
		LocalId:        localIdVal,
		Mode:           modeVal,
		Networks:       networksVal,
		Primary:        primaryVal,
		Probe:          probeVal,
		Protocol:       protocolVal,
		Provider:       providerVal,
		Psk:            pskVal,
		Secondary:      secondaryVal,
		Version:        versionVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewTunnelConfigsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) TunnelConfigsValue {
	object, diags := NewTunnelConfigsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewTunnelConfigsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t TunnelConfigsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewTunnelConfigsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewTunnelConfigsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewTunnelConfigsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewTunnelConfigsValueMust(TunnelConfigsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t TunnelConfigsType) ValueType(ctx context.Context) attr.Value {
	return TunnelConfigsValue{}
}

var _ basetypes.ObjectValuable = TunnelConfigsValue{}

type TunnelConfigsValue struct {
	AutoProvision  basetypes.ObjectValue `tfsdk:"auto_provision"`
	IkeLifetime    basetypes.Int64Value  `tfsdk:"ike_lifetime"`
	IkeMode        basetypes.StringValue `tfsdk:"ike_mode"`
	IkeProposals   basetypes.ListValue   `tfsdk:"ike_proposals"`
	IpsecLifetime  basetypes.Int64Value  `tfsdk:"ipsec_lifetime"`
	IpsecProposals basetypes.ListValue   `tfsdk:"ipsec_proposals"`
	LocalId        basetypes.StringValue `tfsdk:"local_id"`
	Mode           basetypes.StringValue `tfsdk:"mode"`
	Networks       basetypes.ListValue   `tfsdk:"networks"`
	Primary        basetypes.ObjectValue `tfsdk:"primary"`
	Probe          basetypes.ObjectValue `tfsdk:"probe"`
	Protocol       basetypes.StringValue `tfsdk:"protocol"`
	Provider       basetypes.StringValue `tfsdk:"provider"`
	Psk            basetypes.StringValue `tfsdk:"psk"`
	Secondary      basetypes.ObjectValue `tfsdk:"secondary"`
	Version        basetypes.StringValue `tfsdk:"version"`
	state          attr.ValueState
}

func (v TunnelConfigsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 16)

	var val tftypes.Value
	var err error

	attrTypes["auto_provision"] = basetypes.ObjectType{
		AttrTypes: AutoProvisionValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["ike_lifetime"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["ike_mode"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ike_proposals"] = basetypes.ListType{
		ElemType: IkeProposalsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["ipsec_lifetime"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["ipsec_proposals"] = basetypes.ListType{
		ElemType: IpsecProposalsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["local_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["mode"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["networks"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["primary"] = basetypes.ObjectType{
		AttrTypes: PrimaryValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["probe"] = basetypes.ObjectType{
		AttrTypes: ProbeValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["protocol"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["provider"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["psk"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["secondary"] = basetypes.ObjectType{
		AttrTypes: SecondaryValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["version"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 16)

		val, err = v.AutoProvision.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["auto_provision"] = val

		val, err = v.IkeLifetime.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ike_lifetime"] = val

		val, err = v.IkeMode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ike_mode"] = val

		val, err = v.IkeProposals.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ike_proposals"] = val

		val, err = v.IpsecLifetime.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ipsec_lifetime"] = val

		val, err = v.IpsecProposals.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ipsec_proposals"] = val

		val, err = v.LocalId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["local_id"] = val

		val, err = v.Mode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mode"] = val

		val, err = v.Networks.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["networks"] = val

		val, err = v.Primary.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["primary"] = val

		val, err = v.Probe.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["probe"] = val

		val, err = v.Protocol.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["protocol"] = val

		val, err = v.Provider.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["provider"] = val

		val, err = v.Psk.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["psk"] = val

		val, err = v.Secondary.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["secondary"] = val

		val, err = v.Version.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["version"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v TunnelConfigsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v TunnelConfigsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v TunnelConfigsValue) String() string {
	return "TunnelConfigsValue"
}

func (v TunnelConfigsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var autoProvision basetypes.ObjectValue

	if v.AutoProvision.IsNull() {
		autoProvision = types.ObjectNull(
			AutoProvisionValue{}.AttributeTypes(ctx),
		)
	}

	if v.AutoProvision.IsUnknown() {
		autoProvision = types.ObjectUnknown(
			AutoProvisionValue{}.AttributeTypes(ctx),
		)
	}

	if !v.AutoProvision.IsNull() && !v.AutoProvision.IsUnknown() {
		autoProvision = types.ObjectValueMust(
			AutoProvisionValue{}.AttributeTypes(ctx),
			v.AutoProvision.Attributes(),
		)
	}

	ikeProposals := types.ListValueMust(
		IkeProposalsType{
			basetypes.ObjectType{
				AttrTypes: IkeProposalsValue{}.AttributeTypes(ctx),
			},
		},
		v.IkeProposals.Elements(),
	)

	if v.IkeProposals.IsNull() {
		ikeProposals = types.ListNull(
			IkeProposalsType{
				basetypes.ObjectType{
					AttrTypes: IkeProposalsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.IkeProposals.IsUnknown() {
		ikeProposals = types.ListUnknown(
			IkeProposalsType{
				basetypes.ObjectType{
					AttrTypes: IkeProposalsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	ipsecProposals := types.ListValueMust(
		IpsecProposalsType{
			basetypes.ObjectType{
				AttrTypes: IpsecProposalsValue{}.AttributeTypes(ctx),
			},
		},
		v.IpsecProposals.Elements(),
	)

	if v.IpsecProposals.IsNull() {
		ipsecProposals = types.ListNull(
			IpsecProposalsType{
				basetypes.ObjectType{
					AttrTypes: IpsecProposalsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.IpsecProposals.IsUnknown() {
		ipsecProposals = types.ListUnknown(
			IpsecProposalsType{
				basetypes.ObjectType{
					AttrTypes: IpsecProposalsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var primary basetypes.ObjectValue

	if v.Primary.IsNull() {
		primary = types.ObjectNull(
			PrimaryValue{}.AttributeTypes(ctx),
		)
	}

	if v.Primary.IsUnknown() {
		primary = types.ObjectUnknown(
			PrimaryValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Primary.IsNull() && !v.Primary.IsUnknown() {
		primary = types.ObjectValueMust(
			PrimaryValue{}.AttributeTypes(ctx),
			v.Primary.Attributes(),
		)
	}

	var probe basetypes.ObjectValue

	if v.Probe.IsNull() {
		probe = types.ObjectNull(
			ProbeValue{}.AttributeTypes(ctx),
		)
	}

	if v.Probe.IsUnknown() {
		probe = types.ObjectUnknown(
			ProbeValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Probe.IsNull() && !v.Probe.IsUnknown() {
		probe = types.ObjectValueMust(
			ProbeValue{}.AttributeTypes(ctx),
			v.Probe.Attributes(),
		)
	}

	var secondary basetypes.ObjectValue

	if v.Secondary.IsNull() {
		secondary = types.ObjectNull(
			SecondaryValue{}.AttributeTypes(ctx),
		)
	}

	if v.Secondary.IsUnknown() {
		secondary = types.ObjectUnknown(
			SecondaryValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Secondary.IsNull() && !v.Secondary.IsUnknown() {
		secondary = types.ObjectValueMust(
			SecondaryValue{}.AttributeTypes(ctx),
			v.Secondary.Attributes(),
		)
	}

	var networksVal basetypes.ListValue
	switch {
	case v.Networks.IsUnknown():
		networksVal = types.ListUnknown(types.StringType)
	case v.Networks.IsNull():
		networksVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		networksVal, d = types.ListValue(types.StringType, v.Networks.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"auto_provision": basetypes.ObjectType{
				AttrTypes: AutoProvisionValue{}.AttributeTypes(ctx),
			},
			"ike_lifetime": basetypes.Int64Type{},
			"ike_mode":     basetypes.StringType{},
			"ike_proposals": basetypes.ListType{
				ElemType: IkeProposalsValue{}.Type(ctx),
			},
			"ipsec_lifetime": basetypes.Int64Type{},
			"ipsec_proposals": basetypes.ListType{
				ElemType: IpsecProposalsValue{}.Type(ctx),
			},
			"local_id": basetypes.StringType{},
			"mode":     basetypes.StringType{},
			"networks": basetypes.ListType{
				ElemType: types.StringType,
			},
			"primary": basetypes.ObjectType{
				AttrTypes: PrimaryValue{}.AttributeTypes(ctx),
			},
			"probe": basetypes.ObjectType{
				AttrTypes: ProbeValue{}.AttributeTypes(ctx),
			},
			"protocol": basetypes.StringType{},
			"provider": basetypes.StringType{},
			"psk":      basetypes.StringType{},
			"secondary": basetypes.ObjectType{
				AttrTypes: SecondaryValue{}.AttributeTypes(ctx),
			},
			"version": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"auto_provision": basetypes.ObjectType{
			AttrTypes: AutoProvisionValue{}.AttributeTypes(ctx),
		},
		"ike_lifetime": basetypes.Int64Type{},
		"ike_mode":     basetypes.StringType{},
		"ike_proposals": basetypes.ListType{
			ElemType: IkeProposalsValue{}.Type(ctx),
		},
		"ipsec_lifetime": basetypes.Int64Type{},
		"ipsec_proposals": basetypes.ListType{
			ElemType: IpsecProposalsValue{}.Type(ctx),
		},
		"local_id": basetypes.StringType{},
		"mode":     basetypes.StringType{},
		"networks": basetypes.ListType{
			ElemType: types.StringType,
		},
		"primary": basetypes.ObjectType{
			AttrTypes: PrimaryValue{}.AttributeTypes(ctx),
		},
		"probe": basetypes.ObjectType{
			AttrTypes: ProbeValue{}.AttributeTypes(ctx),
		},
		"protocol": basetypes.StringType{},
		"provider": basetypes.StringType{},
		"psk":      basetypes.StringType{},
		"secondary": basetypes.ObjectType{
			AttrTypes: SecondaryValue{}.AttributeTypes(ctx),
		},
		"version": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"auto_provision":  autoProvision,
			"ike_lifetime":    v.IkeLifetime,
			"ike_mode":        v.IkeMode,
			"ike_proposals":   ikeProposals,
			"ipsec_lifetime":  v.IpsecLifetime,
			"ipsec_proposals": ipsecProposals,
			"local_id":        v.LocalId,
			"mode":            v.Mode,
			"networks":        networksVal,
			"primary":         primary,
			"probe":           probe,
			"protocol":        v.Protocol,
			"provider":        v.Provider,
			"psk":             v.Psk,
			"secondary":       secondary,
			"version":         v.Version,
		})

	return objVal, diags
}

func (v TunnelConfigsValue) Equal(o attr.Value) bool {
	other, ok := o.(TunnelConfigsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AutoProvision.Equal(other.AutoProvision) {
		return false
	}

	if !v.IkeLifetime.Equal(other.IkeLifetime) {
		return false
	}

	if !v.IkeMode.Equal(other.IkeMode) {
		return false
	}

	if !v.IkeProposals.Equal(other.IkeProposals) {
		return false
	}

	if !v.IpsecLifetime.Equal(other.IpsecLifetime) {
		return false
	}

	if !v.IpsecProposals.Equal(other.IpsecProposals) {
		return false
	}

	if !v.LocalId.Equal(other.LocalId) {
		return false
	}

	if !v.Mode.Equal(other.Mode) {
		return false
	}

	if !v.Networks.Equal(other.Networks) {
		return false
	}

	if !v.Primary.Equal(other.Primary) {
		return false
	}

	if !v.Probe.Equal(other.Probe) {
		return false
	}

	if !v.Protocol.Equal(other.Protocol) {
		return false
	}

	if !v.Provider.Equal(other.Provider) {
		return false
	}

	if !v.Psk.Equal(other.Psk) {
		return false
	}

	if !v.Secondary.Equal(other.Secondary) {
		return false
	}

	if !v.Version.Equal(other.Version) {
		return false
	}

	return true
}

func (v TunnelConfigsValue) Type(ctx context.Context) attr.Type {
	return TunnelConfigsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v TunnelConfigsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"auto_provision": basetypes.ObjectType{
			AttrTypes: AutoProvisionValue{}.AttributeTypes(ctx),
		},
		"ike_lifetime": basetypes.Int64Type{},
		"ike_mode":     basetypes.StringType{},
		"ike_proposals": basetypes.ListType{
			ElemType: IkeProposalsValue{}.Type(ctx),
		},
		"ipsec_lifetime": basetypes.Int64Type{},
		"ipsec_proposals": basetypes.ListType{
			ElemType: IpsecProposalsValue{}.Type(ctx),
		},
		"local_id": basetypes.StringType{},
		"mode":     basetypes.StringType{},
		"networks": basetypes.ListType{
			ElemType: types.StringType,
		},
		"primary": basetypes.ObjectType{
			AttrTypes: PrimaryValue{}.AttributeTypes(ctx),
		},
		"probe": basetypes.ObjectType{
			AttrTypes: ProbeValue{}.AttributeTypes(ctx),
		},
		"protocol": basetypes.StringType{},
		"provider": basetypes.StringType{},
		"psk":      basetypes.StringType{},
		"secondary": basetypes.ObjectType{
			AttrTypes: SecondaryValue{}.AttributeTypes(ctx),
		},
		"version": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = AutoProvisionType{}

type AutoProvisionType struct {
	basetypes.ObjectType
}

func (t AutoProvisionType) Equal(o attr.Type) bool {
	other, ok := o.(AutoProvisionType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AutoProvisionType) String() string {
	return "AutoProvisionType"
}

func (t AutoProvisionType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	autoProvisionPrimaryAttribute, ok := attributes["primary"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`primary is missing from object`)

		return nil, diags
	}

	autoProvisionPrimaryVal, ok := autoProvisionPrimaryAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`primary expected to be basetypes.ObjectValue, was: %T`, autoProvisionPrimaryAttribute))
	}

	autoProvisionSecondaryAttribute, ok := attributes["secondary"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`secondary is missing from object`)

		return nil, diags
	}

	autoProvisionSecondaryVal, ok := autoProvisionSecondaryAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`secondary expected to be basetypes.ObjectValue, was: %T`, autoProvisionSecondaryAttribute))
	}

	enableAttribute, ok := attributes["enable"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable is missing from object`)

		return nil, diags
	}

	enableVal, ok := enableAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable expected to be basetypes.BoolValue, was: %T`, enableAttribute))
	}

	latlngAttribute, ok := attributes["latlng"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`latlng is missing from object`)

		return nil, diags
	}

	latlngVal, ok := latlngAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`latlng expected to be basetypes.ObjectValue, was: %T`, latlngAttribute))
	}

	providerAttribute, ok := attributes["provider"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`provider is missing from object`)

		return nil, diags
	}

	providerVal, ok := providerAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`provider expected to be basetypes.StringValue, was: %T`, providerAttribute))
	}

	regionAttribute, ok := attributes["region"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`region is missing from object`)

		return nil, diags
	}

	regionVal, ok := regionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`region expected to be basetypes.StringValue, was: %T`, regionAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AutoProvisionValue{
		AutoProvisionPrimary:   autoProvisionPrimaryVal,
		AutoProvisionSecondary: autoProvisionSecondaryVal,
		Enable:                 enableVal,
		Latlng:                 latlngVal,
		Provider:               providerVal,
		Region:                 regionVal,
		state:                  attr.ValueStateKnown,
	}, diags
}

func NewAutoProvisionValueNull() AutoProvisionValue {
	return AutoProvisionValue{
		state: attr.ValueStateNull,
	}
}

func NewAutoProvisionValueUnknown() AutoProvisionValue {
	return AutoProvisionValue{
		state: attr.ValueStateUnknown,
	}
}

func NewAutoProvisionValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AutoProvisionValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AutoProvisionValue Attribute Value",
				"While creating a AutoProvisionValue value, a missing attribute value was detected. "+
					"A AutoProvisionValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AutoProvisionValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AutoProvisionValue Attribute Type",
				"While creating a AutoProvisionValue value, an invalid attribute value was detected. "+
					"A AutoProvisionValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AutoProvisionValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AutoProvisionValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AutoProvisionValue Attribute Value",
				"While creating a AutoProvisionValue value, an extra attribute value was detected. "+
					"A AutoProvisionValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AutoProvisionValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAutoProvisionValueUnknown(), diags
	}

	autoProvisionPrimaryAttribute, ok := attributes["primary"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`primary is missing from object`)

		return NewAutoProvisionValueUnknown(), diags
	}

	autoProvisionPrimaryVal, ok := autoProvisionPrimaryAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`primary expected to be basetypes.ObjectValue, was: %T`, autoProvisionPrimaryAttribute))
	}

	autoProvisionSecondaryAttribute, ok := attributes["secondary"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`secondary is missing from object`)

		return NewAutoProvisionValueUnknown(), diags
	}

	autoProvisionSecondaryVal, ok := autoProvisionSecondaryAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`secondary expected to be basetypes.ObjectValue, was: %T`, autoProvisionSecondaryAttribute))
	}

	enableAttribute, ok := attributes["enable"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable is missing from object`)

		return NewAutoProvisionValueUnknown(), diags
	}

	enableVal, ok := enableAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable expected to be basetypes.BoolValue, was: %T`, enableAttribute))
	}

	latlngAttribute, ok := attributes["latlng"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`latlng is missing from object`)

		return NewAutoProvisionValueUnknown(), diags
	}

	latlngVal, ok := latlngAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`latlng expected to be basetypes.ObjectValue, was: %T`, latlngAttribute))
	}

	providerAttribute, ok := attributes["provider"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`provider is missing from object`)

		return NewAutoProvisionValueUnknown(), diags
	}

	providerVal, ok := providerAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`provider expected to be basetypes.StringValue, was: %T`, providerAttribute))
	}

	regionAttribute, ok := attributes["region"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`region is missing from object`)

		return NewAutoProvisionValueUnknown(), diags
	}

	regionVal, ok := regionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`region expected to be basetypes.StringValue, was: %T`, regionAttribute))
	}

	if diags.HasError() {
		return NewAutoProvisionValueUnknown(), diags
	}

	return AutoProvisionValue{
		AutoProvisionPrimary:   autoProvisionPrimaryVal,
		AutoProvisionSecondary: autoProvisionSecondaryVal,
		Enable:                 enableVal,
		Latlng:                 latlngVal,
		Provider:               providerVal,
		Region:                 regionVal,
		state:                  attr.ValueStateKnown,
	}, diags
}

func NewAutoProvisionValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AutoProvisionValue {
	object, diags := NewAutoProvisionValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAutoProvisionValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AutoProvisionType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAutoProvisionValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAutoProvisionValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAutoProvisionValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAutoProvisionValueMust(AutoProvisionValue{}.AttributeTypes(ctx), attributes), nil
}

func (t AutoProvisionType) ValueType(ctx context.Context) attr.Value {
	return AutoProvisionValue{}
}

var _ basetypes.ObjectValuable = AutoProvisionValue{}

type AutoProvisionValue struct {
	AutoProvisionPrimary   basetypes.ObjectValue `tfsdk:"primary"`
	AutoProvisionSecondary basetypes.ObjectValue `tfsdk:"secondary"`
	Enable                 basetypes.BoolValue   `tfsdk:"enable"`
	Latlng                 basetypes.ObjectValue `tfsdk:"latlng"`
	Provider               basetypes.StringValue `tfsdk:"provider"`
	Region                 basetypes.StringValue `tfsdk:"region"`
	state                  attr.ValueState
}

func (v AutoProvisionValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 6)

	var val tftypes.Value
	var err error

	attrTypes["primary"] = basetypes.ObjectType{
		AttrTypes: AutoProvisionPrimaryValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["secondary"] = basetypes.ObjectType{
		AttrTypes: AutoProvisionSecondaryValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["enable"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["latlng"] = basetypes.ObjectType{
		AttrTypes: LatlngValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["provider"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["region"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 6)

		val, err = v.AutoProvisionPrimary.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["primary"] = val

		val, err = v.AutoProvisionSecondary.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["secondary"] = val

		val, err = v.Enable.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enable"] = val

		val, err = v.Latlng.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["latlng"] = val

		val, err = v.Provider.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["provider"] = val

		val, err = v.Region.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["region"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AutoProvisionValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AutoProvisionValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AutoProvisionValue) String() string {
	return "AutoProvisionValue"
}

func (v AutoProvisionValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var autoProvisionPrimary basetypes.ObjectValue

	if v.AutoProvisionPrimary.IsNull() {
		autoProvisionPrimary = types.ObjectNull(
			AutoProvisionPrimaryValue{}.AttributeTypes(ctx),
		)
	}

	if v.AutoProvisionPrimary.IsUnknown() {
		autoProvisionPrimary = types.ObjectUnknown(
			AutoProvisionPrimaryValue{}.AttributeTypes(ctx),
		)
	}

	if !v.AutoProvisionPrimary.IsNull() && !v.AutoProvisionPrimary.IsUnknown() {
		autoProvisionPrimary = types.ObjectValueMust(
			AutoProvisionPrimaryValue{}.AttributeTypes(ctx),
			v.AutoProvisionPrimary.Attributes(),
		)
	}

	var autoProvisionSecondary basetypes.ObjectValue

	if v.AutoProvisionSecondary.IsNull() {
		autoProvisionSecondary = types.ObjectNull(
			AutoProvisionSecondaryValue{}.AttributeTypes(ctx),
		)
	}

	if v.AutoProvisionSecondary.IsUnknown() {
		autoProvisionSecondary = types.ObjectUnknown(
			AutoProvisionSecondaryValue{}.AttributeTypes(ctx),
		)
	}

	if !v.AutoProvisionSecondary.IsNull() && !v.AutoProvisionSecondary.IsUnknown() {
		autoProvisionSecondary = types.ObjectValueMust(
			AutoProvisionSecondaryValue{}.AttributeTypes(ctx),
			v.AutoProvisionSecondary.Attributes(),
		)
	}

	var latlng basetypes.ObjectValue

	if v.Latlng.IsNull() {
		latlng = types.ObjectNull(
			LatlngValue{}.AttributeTypes(ctx),
		)
	}

	if v.Latlng.IsUnknown() {
		latlng = types.ObjectUnknown(
			LatlngValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Latlng.IsNull() && !v.Latlng.IsUnknown() {
		latlng = types.ObjectValueMust(
			LatlngValue{}.AttributeTypes(ctx),
			v.Latlng.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"primary": basetypes.ObjectType{
			AttrTypes: AutoProvisionPrimaryValue{}.AttributeTypes(ctx),
		},
		"secondary": basetypes.ObjectType{
			AttrTypes: AutoProvisionSecondaryValue{}.AttributeTypes(ctx),
		},
		"enable": basetypes.BoolType{},
		"latlng": basetypes.ObjectType{
			AttrTypes: LatlngValue{}.AttributeTypes(ctx),
		},
		"provider": basetypes.StringType{},
		"region":   basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"primary":   autoProvisionPrimary,
			"secondary": autoProvisionSecondary,
			"enable":    v.Enable,
			"latlng":    latlng,
			"provider":  v.Provider,
			"region":    v.Region,
		})

	return objVal, diags
}

func (v AutoProvisionValue) Equal(o attr.Value) bool {
	other, ok := o.(AutoProvisionValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AutoProvisionPrimary.Equal(other.AutoProvisionPrimary) {
		return false
	}

	if !v.AutoProvisionSecondary.Equal(other.AutoProvisionSecondary) {
		return false
	}

	if !v.Enable.Equal(other.Enable) {
		return false
	}

	if !v.Latlng.Equal(other.Latlng) {
		return false
	}

	if !v.Provider.Equal(other.Provider) {
		return false
	}

	if !v.Region.Equal(other.Region) {
		return false
	}

	return true
}

func (v AutoProvisionValue) Type(ctx context.Context) attr.Type {
	return AutoProvisionType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AutoProvisionValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"primary": basetypes.ObjectType{
			AttrTypes: AutoProvisionPrimaryValue{}.AttributeTypes(ctx),
		},
		"secondary": basetypes.ObjectType{
			AttrTypes: AutoProvisionSecondaryValue{}.AttributeTypes(ctx),
		},
		"enable": basetypes.BoolType{},
		"latlng": basetypes.ObjectType{
			AttrTypes: LatlngValue{}.AttributeTypes(ctx),
		},
		"provider": basetypes.StringType{},
		"region":   basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = AutoProvisionPrimaryType{}

type AutoProvisionPrimaryType struct {
	basetypes.ObjectType
}

func (t AutoProvisionPrimaryType) Equal(o attr.Type) bool {
	other, ok := o.(AutoProvisionPrimaryType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AutoProvisionPrimaryType) String() string {
	return "AutoProvisionPrimaryType"
}

func (t AutoProvisionPrimaryType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	probeIpsAttribute, ok := attributes["probe_ips"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`probe_ips is missing from object`)

		return nil, diags
	}

	probeIpsVal, ok := probeIpsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`probe_ips expected to be basetypes.ListValue, was: %T`, probeIpsAttribute))
	}

	wanNamesAttribute, ok := attributes["wan_names"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wan_names is missing from object`)

		return nil, diags
	}

	wanNamesVal, ok := wanNamesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wan_names expected to be basetypes.ListValue, was: %T`, wanNamesAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AutoProvisionPrimaryValue{
		ProbeIps: probeIpsVal,
		WanNames: wanNamesVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewAutoProvisionPrimaryValueNull() AutoProvisionPrimaryValue {
	return AutoProvisionPrimaryValue{
		state: attr.ValueStateNull,
	}
}

func NewAutoProvisionPrimaryValueUnknown() AutoProvisionPrimaryValue {
	return AutoProvisionPrimaryValue{
		state: attr.ValueStateUnknown,
	}
}

func NewAutoProvisionPrimaryValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AutoProvisionPrimaryValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AutoProvisionPrimaryValue Attribute Value",
				"While creating a AutoProvisionPrimaryValue value, a missing attribute value was detected. "+
					"A AutoProvisionPrimaryValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AutoProvisionPrimaryValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AutoProvisionPrimaryValue Attribute Type",
				"While creating a AutoProvisionPrimaryValue value, an invalid attribute value was detected. "+
					"A AutoProvisionPrimaryValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AutoProvisionPrimaryValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AutoProvisionPrimaryValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AutoProvisionPrimaryValue Attribute Value",
				"While creating a AutoProvisionPrimaryValue value, an extra attribute value was detected. "+
					"A AutoProvisionPrimaryValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AutoProvisionPrimaryValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAutoProvisionPrimaryValueUnknown(), diags
	}

	probeIpsAttribute, ok := attributes["probe_ips"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`probe_ips is missing from object`)

		return NewAutoProvisionPrimaryValueUnknown(), diags
	}

	probeIpsVal, ok := probeIpsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`probe_ips expected to be basetypes.ListValue, was: %T`, probeIpsAttribute))
	}

	wanNamesAttribute, ok := attributes["wan_names"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wan_names is missing from object`)

		return NewAutoProvisionPrimaryValueUnknown(), diags
	}

	wanNamesVal, ok := wanNamesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wan_names expected to be basetypes.ListValue, was: %T`, wanNamesAttribute))
	}

	if diags.HasError() {
		return NewAutoProvisionPrimaryValueUnknown(), diags
	}

	return AutoProvisionPrimaryValue{
		ProbeIps: probeIpsVal,
		WanNames: wanNamesVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewAutoProvisionPrimaryValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AutoProvisionPrimaryValue {
	object, diags := NewAutoProvisionPrimaryValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAutoProvisionPrimaryValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AutoProvisionPrimaryType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAutoProvisionPrimaryValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAutoProvisionPrimaryValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAutoProvisionPrimaryValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAutoProvisionPrimaryValueMust(AutoProvisionPrimaryValue{}.AttributeTypes(ctx), attributes), nil
}

func (t AutoProvisionPrimaryType) ValueType(ctx context.Context) attr.Value {
	return AutoProvisionPrimaryValue{}
}

var _ basetypes.ObjectValuable = AutoProvisionPrimaryValue{}

type AutoProvisionPrimaryValue struct {
	ProbeIps basetypes.ListValue `tfsdk:"probe_ips"`
	WanNames basetypes.ListValue `tfsdk:"wan_names"`
	state    attr.ValueState
}

func (v AutoProvisionPrimaryValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["probe_ips"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["wan_names"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.ProbeIps.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["probe_ips"] = val

		val, err = v.WanNames.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["wan_names"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AutoProvisionPrimaryValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AutoProvisionPrimaryValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AutoProvisionPrimaryValue) String() string {
	return "AutoProvisionPrimaryValue"
}

func (v AutoProvisionPrimaryValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var probeIpsVal basetypes.ListValue
	switch {
	case v.ProbeIps.IsUnknown():
		probeIpsVal = types.ListUnknown(types.StringType)
	case v.ProbeIps.IsNull():
		probeIpsVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		probeIpsVal, d = types.ListValue(types.StringType, v.ProbeIps.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"probe_ips": basetypes.ListType{
				ElemType: types.StringType,
			},
			"wan_names": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	var wanNamesVal basetypes.ListValue
	switch {
	case v.WanNames.IsUnknown():
		wanNamesVal = types.ListUnknown(types.StringType)
	case v.WanNames.IsNull():
		wanNamesVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		wanNamesVal, d = types.ListValue(types.StringType, v.WanNames.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"probe_ips": basetypes.ListType{
				ElemType: types.StringType,
			},
			"wan_names": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"probe_ips": basetypes.ListType{
			ElemType: types.StringType,
		},
		"wan_names": basetypes.ListType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"probe_ips": probeIpsVal,
			"wan_names": wanNamesVal,
		})

	return objVal, diags
}

func (v AutoProvisionPrimaryValue) Equal(o attr.Value) bool {
	other, ok := o.(AutoProvisionPrimaryValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.ProbeIps.Equal(other.ProbeIps) {
		return false
	}

	if !v.WanNames.Equal(other.WanNames) {
		return false
	}

	return true
}

func (v AutoProvisionPrimaryValue) Type(ctx context.Context) attr.Type {
	return AutoProvisionPrimaryType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AutoProvisionPrimaryValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"probe_ips": basetypes.ListType{
			ElemType: types.StringType,
		},
		"wan_names": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = AutoProvisionSecondaryType{}

type AutoProvisionSecondaryType struct {
	basetypes.ObjectType
}

func (t AutoProvisionSecondaryType) Equal(o attr.Type) bool {
	other, ok := o.(AutoProvisionSecondaryType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AutoProvisionSecondaryType) String() string {
	return "AutoProvisionSecondaryType"
}

func (t AutoProvisionSecondaryType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	probeIpsAttribute, ok := attributes["probe_ips"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`probe_ips is missing from object`)

		return nil, diags
	}

	probeIpsVal, ok := probeIpsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`probe_ips expected to be basetypes.ListValue, was: %T`, probeIpsAttribute))
	}

	wanNamesAttribute, ok := attributes["wan_names"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wan_names is missing from object`)

		return nil, diags
	}

	wanNamesVal, ok := wanNamesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wan_names expected to be basetypes.ListValue, was: %T`, wanNamesAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AutoProvisionSecondaryValue{
		ProbeIps: probeIpsVal,
		WanNames: wanNamesVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewAutoProvisionSecondaryValueNull() AutoProvisionSecondaryValue {
	return AutoProvisionSecondaryValue{
		state: attr.ValueStateNull,
	}
}

func NewAutoProvisionSecondaryValueUnknown() AutoProvisionSecondaryValue {
	return AutoProvisionSecondaryValue{
		state: attr.ValueStateUnknown,
	}
}

func NewAutoProvisionSecondaryValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AutoProvisionSecondaryValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AutoProvisionSecondaryValue Attribute Value",
				"While creating a AutoProvisionSecondaryValue value, a missing attribute value was detected. "+
					"A AutoProvisionSecondaryValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AutoProvisionSecondaryValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AutoProvisionSecondaryValue Attribute Type",
				"While creating a AutoProvisionSecondaryValue value, an invalid attribute value was detected. "+
					"A AutoProvisionSecondaryValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AutoProvisionSecondaryValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AutoProvisionSecondaryValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AutoProvisionSecondaryValue Attribute Value",
				"While creating a AutoProvisionSecondaryValue value, an extra attribute value was detected. "+
					"A AutoProvisionSecondaryValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AutoProvisionSecondaryValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAutoProvisionSecondaryValueUnknown(), diags
	}

	probeIpsAttribute, ok := attributes["probe_ips"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`probe_ips is missing from object`)

		return NewAutoProvisionSecondaryValueUnknown(), diags
	}

	probeIpsVal, ok := probeIpsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`probe_ips expected to be basetypes.ListValue, was: %T`, probeIpsAttribute))
	}

	wanNamesAttribute, ok := attributes["wan_names"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wan_names is missing from object`)

		return NewAutoProvisionSecondaryValueUnknown(), diags
	}

	wanNamesVal, ok := wanNamesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wan_names expected to be basetypes.ListValue, was: %T`, wanNamesAttribute))
	}

	if diags.HasError() {
		return NewAutoProvisionSecondaryValueUnknown(), diags
	}

	return AutoProvisionSecondaryValue{
		ProbeIps: probeIpsVal,
		WanNames: wanNamesVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewAutoProvisionSecondaryValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AutoProvisionSecondaryValue {
	object, diags := NewAutoProvisionSecondaryValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAutoProvisionSecondaryValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AutoProvisionSecondaryType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAutoProvisionSecondaryValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAutoProvisionSecondaryValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAutoProvisionSecondaryValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAutoProvisionSecondaryValueMust(AutoProvisionSecondaryValue{}.AttributeTypes(ctx), attributes), nil
}

func (t AutoProvisionSecondaryType) ValueType(ctx context.Context) attr.Value {
	return AutoProvisionSecondaryValue{}
}

var _ basetypes.ObjectValuable = AutoProvisionSecondaryValue{}

type AutoProvisionSecondaryValue struct {
	ProbeIps basetypes.ListValue `tfsdk:"probe_ips"`
	WanNames basetypes.ListValue `tfsdk:"wan_names"`
	state    attr.ValueState
}

func (v AutoProvisionSecondaryValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["probe_ips"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["wan_names"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.ProbeIps.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["probe_ips"] = val

		val, err = v.WanNames.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["wan_names"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AutoProvisionSecondaryValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AutoProvisionSecondaryValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AutoProvisionSecondaryValue) String() string {
	return "AutoProvisionSecondaryValue"
}

func (v AutoProvisionSecondaryValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var probeIpsVal basetypes.ListValue
	switch {
	case v.ProbeIps.IsUnknown():
		probeIpsVal = types.ListUnknown(types.StringType)
	case v.ProbeIps.IsNull():
		probeIpsVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		probeIpsVal, d = types.ListValue(types.StringType, v.ProbeIps.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"probe_ips": basetypes.ListType{
				ElemType: types.StringType,
			},
			"wan_names": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	var wanNamesVal basetypes.ListValue
	switch {
	case v.WanNames.IsUnknown():
		wanNamesVal = types.ListUnknown(types.StringType)
	case v.WanNames.IsNull():
		wanNamesVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		wanNamesVal, d = types.ListValue(types.StringType, v.WanNames.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"probe_ips": basetypes.ListType{
				ElemType: types.StringType,
			},
			"wan_names": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"probe_ips": basetypes.ListType{
			ElemType: types.StringType,
		},
		"wan_names": basetypes.ListType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"probe_ips": probeIpsVal,
			"wan_names": wanNamesVal,
		})

	return objVal, diags
}

func (v AutoProvisionSecondaryValue) Equal(o attr.Value) bool {
	other, ok := o.(AutoProvisionSecondaryValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.ProbeIps.Equal(other.ProbeIps) {
		return false
	}

	if !v.WanNames.Equal(other.WanNames) {
		return false
	}

	return true
}

func (v AutoProvisionSecondaryValue) Type(ctx context.Context) attr.Type {
	return AutoProvisionSecondaryType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AutoProvisionSecondaryValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"probe_ips": basetypes.ListType{
			ElemType: types.StringType,
		},
		"wan_names": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = LatlngType{}

type LatlngType struct {
	basetypes.ObjectType
}

func (t LatlngType) Equal(o attr.Type) bool {
	other, ok := o.(LatlngType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t LatlngType) String() string {
	return "LatlngType"
}

func (t LatlngType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	latAttribute, ok := attributes["lat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lat is missing from object`)

		return nil, diags
	}

	latVal, ok := latAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lat expected to be basetypes.Float64Value, was: %T`, latAttribute))
	}

	lngAttribute, ok := attributes["lng"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lng is missing from object`)

		return nil, diags
	}

	lngVal, ok := lngAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lng expected to be basetypes.Float64Value, was: %T`, lngAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return LatlngValue{
		Lat:   latVal,
		Lng:   lngVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewLatlngValueNull() LatlngValue {
	return LatlngValue{
		state: attr.ValueStateNull,
	}
}

func NewLatlngValueUnknown() LatlngValue {
	return LatlngValue{
		state: attr.ValueStateUnknown,
	}
}

func NewLatlngValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (LatlngValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing LatlngValue Attribute Value",
				"While creating a LatlngValue value, a missing attribute value was detected. "+
					"A LatlngValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("LatlngValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid LatlngValue Attribute Type",
				"While creating a LatlngValue value, an invalid attribute value was detected. "+
					"A LatlngValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("LatlngValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("LatlngValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra LatlngValue Attribute Value",
				"While creating a LatlngValue value, an extra attribute value was detected. "+
					"A LatlngValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra LatlngValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewLatlngValueUnknown(), diags
	}

	latAttribute, ok := attributes["lat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lat is missing from object`)

		return NewLatlngValueUnknown(), diags
	}

	latVal, ok := latAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lat expected to be basetypes.Float64Value, was: %T`, latAttribute))
	}

	lngAttribute, ok := attributes["lng"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lng is missing from object`)

		return NewLatlngValueUnknown(), diags
	}

	lngVal, ok := lngAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lng expected to be basetypes.Float64Value, was: %T`, lngAttribute))
	}

	if diags.HasError() {
		return NewLatlngValueUnknown(), diags
	}

	return LatlngValue{
		Lat:   latVal,
		Lng:   lngVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewLatlngValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) LatlngValue {
	object, diags := NewLatlngValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewLatlngValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t LatlngType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewLatlngValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewLatlngValueUnknown(), nil
	}

	if in.IsNull() {
		return NewLatlngValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewLatlngValueMust(LatlngValue{}.AttributeTypes(ctx), attributes), nil
}

func (t LatlngType) ValueType(ctx context.Context) attr.Value {
	return LatlngValue{}
}

var _ basetypes.ObjectValuable = LatlngValue{}

type LatlngValue struct {
	Lat   basetypes.Float64Value `tfsdk:"lat"`
	Lng   basetypes.Float64Value `tfsdk:"lng"`
	state attr.ValueState
}

func (v LatlngValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["lat"] = basetypes.Float64Type{}.TerraformType(ctx)
	attrTypes["lng"] = basetypes.Float64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Lat.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["lat"] = val

		val, err = v.Lng.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["lng"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v LatlngValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v LatlngValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v LatlngValue) String() string {
	return "LatlngValue"
}

func (v LatlngValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"lat": basetypes.Float64Type{},
		"lng": basetypes.Float64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"lat": v.Lat,
			"lng": v.Lng,
		})

	return objVal, diags
}

func (v LatlngValue) Equal(o attr.Value) bool {
	other, ok := o.(LatlngValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Lat.Equal(other.Lat) {
		return false
	}

	if !v.Lng.Equal(other.Lng) {
		return false
	}

	return true
}

func (v LatlngValue) Type(ctx context.Context) attr.Type {
	return LatlngType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v LatlngValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"lat": basetypes.Float64Type{},
		"lng": basetypes.Float64Type{},
	}
}

var _ basetypes.ObjectTypable = IkeProposalsType{}

type IkeProposalsType struct {
	basetypes.ObjectType
}

func (t IkeProposalsType) Equal(o attr.Type) bool {
	other, ok := o.(IkeProposalsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t IkeProposalsType) String() string {
	return "IkeProposalsType"
}

func (t IkeProposalsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	authAlgoAttribute, ok := attributes["auth_algo"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auth_algo is missing from object`)

		return nil, diags
	}

	authAlgoVal, ok := authAlgoAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auth_algo expected to be basetypes.StringValue, was: %T`, authAlgoAttribute))
	}

	dhGroupAttribute, ok := attributes["dh_group"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dh_group is missing from object`)

		return nil, diags
	}

	dhGroupVal, ok := dhGroupAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dh_group expected to be basetypes.StringValue, was: %T`, dhGroupAttribute))
	}

	encAlgoAttribute, ok := attributes["enc_algo"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enc_algo is missing from object`)

		return nil, diags
	}

	encAlgoVal, ok := encAlgoAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enc_algo expected to be basetypes.StringValue, was: %T`, encAlgoAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return IkeProposalsValue{
		AuthAlgo: authAlgoVal,
		DhGroup:  dhGroupVal,
		EncAlgo:  encAlgoVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewIkeProposalsValueNull() IkeProposalsValue {
	return IkeProposalsValue{
		state: attr.ValueStateNull,
	}
}

func NewIkeProposalsValueUnknown() IkeProposalsValue {
	return IkeProposalsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewIkeProposalsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (IkeProposalsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing IkeProposalsValue Attribute Value",
				"While creating a IkeProposalsValue value, a missing attribute value was detected. "+
					"A IkeProposalsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("IkeProposalsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid IkeProposalsValue Attribute Type",
				"While creating a IkeProposalsValue value, an invalid attribute value was detected. "+
					"A IkeProposalsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("IkeProposalsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("IkeProposalsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra IkeProposalsValue Attribute Value",
				"While creating a IkeProposalsValue value, an extra attribute value was detected. "+
					"A IkeProposalsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra IkeProposalsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewIkeProposalsValueUnknown(), diags
	}

	authAlgoAttribute, ok := attributes["auth_algo"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auth_algo is missing from object`)

		return NewIkeProposalsValueUnknown(), diags
	}

	authAlgoVal, ok := authAlgoAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auth_algo expected to be basetypes.StringValue, was: %T`, authAlgoAttribute))
	}

	dhGroupAttribute, ok := attributes["dh_group"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dh_group is missing from object`)

		return NewIkeProposalsValueUnknown(), diags
	}

	dhGroupVal, ok := dhGroupAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dh_group expected to be basetypes.StringValue, was: %T`, dhGroupAttribute))
	}

	encAlgoAttribute, ok := attributes["enc_algo"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enc_algo is missing from object`)

		return NewIkeProposalsValueUnknown(), diags
	}

	encAlgoVal, ok := encAlgoAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enc_algo expected to be basetypes.StringValue, was: %T`, encAlgoAttribute))
	}

	if diags.HasError() {
		return NewIkeProposalsValueUnknown(), diags
	}

	return IkeProposalsValue{
		AuthAlgo: authAlgoVal,
		DhGroup:  dhGroupVal,
		EncAlgo:  encAlgoVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewIkeProposalsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) IkeProposalsValue {
	object, diags := NewIkeProposalsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewIkeProposalsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t IkeProposalsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewIkeProposalsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewIkeProposalsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewIkeProposalsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewIkeProposalsValueMust(IkeProposalsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t IkeProposalsType) ValueType(ctx context.Context) attr.Value {
	return IkeProposalsValue{}
}

var _ basetypes.ObjectValuable = IkeProposalsValue{}

type IkeProposalsValue struct {
	AuthAlgo basetypes.StringValue `tfsdk:"auth_algo"`
	DhGroup  basetypes.StringValue `tfsdk:"dh_group"`
	EncAlgo  basetypes.StringValue `tfsdk:"enc_algo"`
	state    attr.ValueState
}

func (v IkeProposalsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["auth_algo"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["dh_group"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["enc_algo"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.AuthAlgo.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["auth_algo"] = val

		val, err = v.DhGroup.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dh_group"] = val

		val, err = v.EncAlgo.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enc_algo"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v IkeProposalsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v IkeProposalsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v IkeProposalsValue) String() string {
	return "IkeProposalsValue"
}

func (v IkeProposalsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"auth_algo": basetypes.StringType{},
		"dh_group":  basetypes.StringType{},
		"enc_algo":  basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"auth_algo": v.AuthAlgo,
			"dh_group":  v.DhGroup,
			"enc_algo":  v.EncAlgo,
		})

	return objVal, diags
}

func (v IkeProposalsValue) Equal(o attr.Value) bool {
	other, ok := o.(IkeProposalsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AuthAlgo.Equal(other.AuthAlgo) {
		return false
	}

	if !v.DhGroup.Equal(other.DhGroup) {
		return false
	}

	if !v.EncAlgo.Equal(other.EncAlgo) {
		return false
	}

	return true
}

func (v IkeProposalsValue) Type(ctx context.Context) attr.Type {
	return IkeProposalsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v IkeProposalsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"auth_algo": basetypes.StringType{},
		"dh_group":  basetypes.StringType{},
		"enc_algo":  basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = IpsecProposalsType{}

type IpsecProposalsType struct {
	basetypes.ObjectType
}

func (t IpsecProposalsType) Equal(o attr.Type) bool {
	other, ok := o.(IpsecProposalsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t IpsecProposalsType) String() string {
	return "IpsecProposalsType"
}

func (t IpsecProposalsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	authAlgoAttribute, ok := attributes["auth_algo"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auth_algo is missing from object`)

		return nil, diags
	}

	authAlgoVal, ok := authAlgoAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auth_algo expected to be basetypes.StringValue, was: %T`, authAlgoAttribute))
	}

	dhGroupAttribute, ok := attributes["dh_group"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dh_group is missing from object`)

		return nil, diags
	}

	dhGroupVal, ok := dhGroupAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dh_group expected to be basetypes.StringValue, was: %T`, dhGroupAttribute))
	}

	encAlgoAttribute, ok := attributes["enc_algo"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enc_algo is missing from object`)

		return nil, diags
	}

	encAlgoVal, ok := encAlgoAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enc_algo expected to be basetypes.StringValue, was: %T`, encAlgoAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return IpsecProposalsValue{
		AuthAlgo: authAlgoVal,
		DhGroup:  dhGroupVal,
		EncAlgo:  encAlgoVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewIpsecProposalsValueNull() IpsecProposalsValue {
	return IpsecProposalsValue{
		state: attr.ValueStateNull,
	}
}

func NewIpsecProposalsValueUnknown() IpsecProposalsValue {
	return IpsecProposalsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewIpsecProposalsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (IpsecProposalsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing IpsecProposalsValue Attribute Value",
				"While creating a IpsecProposalsValue value, a missing attribute value was detected. "+
					"A IpsecProposalsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("IpsecProposalsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid IpsecProposalsValue Attribute Type",
				"While creating a IpsecProposalsValue value, an invalid attribute value was detected. "+
					"A IpsecProposalsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("IpsecProposalsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("IpsecProposalsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra IpsecProposalsValue Attribute Value",
				"While creating a IpsecProposalsValue value, an extra attribute value was detected. "+
					"A IpsecProposalsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra IpsecProposalsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewIpsecProposalsValueUnknown(), diags
	}

	authAlgoAttribute, ok := attributes["auth_algo"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auth_algo is missing from object`)

		return NewIpsecProposalsValueUnknown(), diags
	}

	authAlgoVal, ok := authAlgoAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auth_algo expected to be basetypes.StringValue, was: %T`, authAlgoAttribute))
	}

	dhGroupAttribute, ok := attributes["dh_group"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dh_group is missing from object`)

		return NewIpsecProposalsValueUnknown(), diags
	}

	dhGroupVal, ok := dhGroupAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dh_group expected to be basetypes.StringValue, was: %T`, dhGroupAttribute))
	}

	encAlgoAttribute, ok := attributes["enc_algo"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enc_algo is missing from object`)

		return NewIpsecProposalsValueUnknown(), diags
	}

	encAlgoVal, ok := encAlgoAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enc_algo expected to be basetypes.StringValue, was: %T`, encAlgoAttribute))
	}

	if diags.HasError() {
		return NewIpsecProposalsValueUnknown(), diags
	}

	return IpsecProposalsValue{
		AuthAlgo: authAlgoVal,
		DhGroup:  dhGroupVal,
		EncAlgo:  encAlgoVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewIpsecProposalsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) IpsecProposalsValue {
	object, diags := NewIpsecProposalsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewIpsecProposalsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t IpsecProposalsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewIpsecProposalsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewIpsecProposalsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewIpsecProposalsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewIpsecProposalsValueMust(IpsecProposalsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t IpsecProposalsType) ValueType(ctx context.Context) attr.Value {
	return IpsecProposalsValue{}
}

var _ basetypes.ObjectValuable = IpsecProposalsValue{}

type IpsecProposalsValue struct {
	AuthAlgo basetypes.StringValue `tfsdk:"auth_algo"`
	DhGroup  basetypes.StringValue `tfsdk:"dh_group"`
	EncAlgo  basetypes.StringValue `tfsdk:"enc_algo"`
	state    attr.ValueState
}

func (v IpsecProposalsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["auth_algo"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["dh_group"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["enc_algo"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.AuthAlgo.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["auth_algo"] = val

		val, err = v.DhGroup.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dh_group"] = val

		val, err = v.EncAlgo.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enc_algo"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v IpsecProposalsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v IpsecProposalsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v IpsecProposalsValue) String() string {
	return "IpsecProposalsValue"
}

func (v IpsecProposalsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"auth_algo": basetypes.StringType{},
		"dh_group":  basetypes.StringType{},
		"enc_algo":  basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"auth_algo": v.AuthAlgo,
			"dh_group":  v.DhGroup,
			"enc_algo":  v.EncAlgo,
		})

	return objVal, diags
}

func (v IpsecProposalsValue) Equal(o attr.Value) bool {
	other, ok := o.(IpsecProposalsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AuthAlgo.Equal(other.AuthAlgo) {
		return false
	}

	if !v.DhGroup.Equal(other.DhGroup) {
		return false
	}

	if !v.EncAlgo.Equal(other.EncAlgo) {
		return false
	}

	return true
}

func (v IpsecProposalsValue) Type(ctx context.Context) attr.Type {
	return IpsecProposalsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v IpsecProposalsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"auth_algo": basetypes.StringType{},
		"dh_group":  basetypes.StringType{},
		"enc_algo":  basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = PrimaryType{}

type PrimaryType struct {
	basetypes.ObjectType
}

func (t PrimaryType) Equal(o attr.Type) bool {
	other, ok := o.(PrimaryType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PrimaryType) String() string {
	return "PrimaryType"
}

func (t PrimaryType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	hostsAttribute, ok := attributes["hosts"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`hosts is missing from object`)

		return nil, diags
	}

	hostsVal, ok := hostsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`hosts expected to be basetypes.ListValue, was: %T`, hostsAttribute))
	}

	internalIpsAttribute, ok := attributes["internal_ips"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`internal_ips is missing from object`)

		return nil, diags
	}

	internalIpsVal, ok := internalIpsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`internal_ips expected to be basetypes.ListValue, was: %T`, internalIpsAttribute))
	}

	probeIpsAttribute, ok := attributes["probe_ips"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`probe_ips is missing from object`)

		return nil, diags
	}

	probeIpsVal, ok := probeIpsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`probe_ips expected to be basetypes.ListValue, was: %T`, probeIpsAttribute))
	}

	remoteIdsAttribute, ok := attributes["remote_ids"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remote_ids is missing from object`)

		return nil, diags
	}

	remoteIdsVal, ok := remoteIdsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remote_ids expected to be basetypes.ListValue, was: %T`, remoteIdsAttribute))
	}

	wanNamesAttribute, ok := attributes["wan_names"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wan_names is missing from object`)

		return nil, diags
	}

	wanNamesVal, ok := wanNamesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wan_names expected to be basetypes.ListValue, was: %T`, wanNamesAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PrimaryValue{
		Hosts:       hostsVal,
		InternalIps: internalIpsVal,
		ProbeIps:    probeIpsVal,
		RemoteIds:   remoteIdsVal,
		WanNames:    wanNamesVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewPrimaryValueNull() PrimaryValue {
	return PrimaryValue{
		state: attr.ValueStateNull,
	}
}

func NewPrimaryValueUnknown() PrimaryValue {
	return PrimaryValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPrimaryValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PrimaryValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PrimaryValue Attribute Value",
				"While creating a PrimaryValue value, a missing attribute value was detected. "+
					"A PrimaryValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PrimaryValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PrimaryValue Attribute Type",
				"While creating a PrimaryValue value, an invalid attribute value was detected. "+
					"A PrimaryValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PrimaryValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PrimaryValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PrimaryValue Attribute Value",
				"While creating a PrimaryValue value, an extra attribute value was detected. "+
					"A PrimaryValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PrimaryValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPrimaryValueUnknown(), diags
	}

	hostsAttribute, ok := attributes["hosts"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`hosts is missing from object`)

		return NewPrimaryValueUnknown(), diags
	}

	hostsVal, ok := hostsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`hosts expected to be basetypes.ListValue, was: %T`, hostsAttribute))
	}

	internalIpsAttribute, ok := attributes["internal_ips"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`internal_ips is missing from object`)

		return NewPrimaryValueUnknown(), diags
	}

	internalIpsVal, ok := internalIpsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`internal_ips expected to be basetypes.ListValue, was: %T`, internalIpsAttribute))
	}

	probeIpsAttribute, ok := attributes["probe_ips"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`probe_ips is missing from object`)

		return NewPrimaryValueUnknown(), diags
	}

	probeIpsVal, ok := probeIpsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`probe_ips expected to be basetypes.ListValue, was: %T`, probeIpsAttribute))
	}

	remoteIdsAttribute, ok := attributes["remote_ids"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remote_ids is missing from object`)

		return NewPrimaryValueUnknown(), diags
	}

	remoteIdsVal, ok := remoteIdsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remote_ids expected to be basetypes.ListValue, was: %T`, remoteIdsAttribute))
	}

	wanNamesAttribute, ok := attributes["wan_names"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wan_names is missing from object`)

		return NewPrimaryValueUnknown(), diags
	}

	wanNamesVal, ok := wanNamesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wan_names expected to be basetypes.ListValue, was: %T`, wanNamesAttribute))
	}

	if diags.HasError() {
		return NewPrimaryValueUnknown(), diags
	}

	return PrimaryValue{
		Hosts:       hostsVal,
		InternalIps: internalIpsVal,
		ProbeIps:    probeIpsVal,
		RemoteIds:   remoteIdsVal,
		WanNames:    wanNamesVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewPrimaryValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PrimaryValue {
	object, diags := NewPrimaryValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPrimaryValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PrimaryType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPrimaryValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPrimaryValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPrimaryValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPrimaryValueMust(PrimaryValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PrimaryType) ValueType(ctx context.Context) attr.Value {
	return PrimaryValue{}
}

var _ basetypes.ObjectValuable = PrimaryValue{}

type PrimaryValue struct {
	Hosts       basetypes.ListValue `tfsdk:"hosts"`
	InternalIps basetypes.ListValue `tfsdk:"internal_ips"`
	ProbeIps    basetypes.ListValue `tfsdk:"probe_ips"`
	RemoteIds   basetypes.ListValue `tfsdk:"remote_ids"`
	WanNames    basetypes.ListValue `tfsdk:"wan_names"`
	state       attr.ValueState
}

func (v PrimaryValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["hosts"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["internal_ips"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["probe_ips"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["remote_ids"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["wan_names"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.Hosts.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["hosts"] = val

		val, err = v.InternalIps.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["internal_ips"] = val

		val, err = v.ProbeIps.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["probe_ips"] = val

		val, err = v.RemoteIds.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["remote_ids"] = val

		val, err = v.WanNames.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["wan_names"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PrimaryValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PrimaryValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PrimaryValue) String() string {
	return "PrimaryValue"
}

func (v PrimaryValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var hostsVal basetypes.ListValue
	switch {
	case v.Hosts.IsUnknown():
		hostsVal = types.ListUnknown(types.StringType)
	case v.Hosts.IsNull():
		hostsVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		hostsVal, d = types.ListValue(types.StringType, v.Hosts.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"hosts": basetypes.ListType{
				ElemType: types.StringType,
			},
			"internal_ips": basetypes.ListType{
				ElemType: types.StringType,
			},
			"probe_ips": basetypes.ListType{
				ElemType: types.StringType,
			},
			"remote_ids": basetypes.ListType{
				ElemType: types.StringType,
			},
			"wan_names": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	var internalIpsVal basetypes.ListValue
	switch {
	case v.InternalIps.IsUnknown():
		internalIpsVal = types.ListUnknown(types.StringType)
	case v.InternalIps.IsNull():
		internalIpsVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		internalIpsVal, d = types.ListValue(types.StringType, v.InternalIps.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"hosts": basetypes.ListType{
				ElemType: types.StringType,
			},
			"internal_ips": basetypes.ListType{
				ElemType: types.StringType,
			},
			"probe_ips": basetypes.ListType{
				ElemType: types.StringType,
			},
			"remote_ids": basetypes.ListType{
				ElemType: types.StringType,
			},
			"wan_names": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	var probeIpsVal basetypes.ListValue
	switch {
	case v.ProbeIps.IsUnknown():
		probeIpsVal = types.ListUnknown(types.StringType)
	case v.ProbeIps.IsNull():
		probeIpsVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		probeIpsVal, d = types.ListValue(types.StringType, v.ProbeIps.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"hosts": basetypes.ListType{
				ElemType: types.StringType,
			},
			"internal_ips": basetypes.ListType{
				ElemType: types.StringType,
			},
			"probe_ips": basetypes.ListType{
				ElemType: types.StringType,
			},
			"remote_ids": basetypes.ListType{
				ElemType: types.StringType,
			},
			"wan_names": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	var remoteIdsVal basetypes.ListValue
	switch {
	case v.RemoteIds.IsUnknown():
		remoteIdsVal = types.ListUnknown(types.StringType)
	case v.RemoteIds.IsNull():
		remoteIdsVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		remoteIdsVal, d = types.ListValue(types.StringType, v.RemoteIds.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"hosts": basetypes.ListType{
				ElemType: types.StringType,
			},
			"internal_ips": basetypes.ListType{
				ElemType: types.StringType,
			},
			"probe_ips": basetypes.ListType{
				ElemType: types.StringType,
			},
			"remote_ids": basetypes.ListType{
				ElemType: types.StringType,
			},
			"wan_names": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	var wanNamesVal basetypes.ListValue
	switch {
	case v.WanNames.IsUnknown():
		wanNamesVal = types.ListUnknown(types.StringType)
	case v.WanNames.IsNull():
		wanNamesVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		wanNamesVal, d = types.ListValue(types.StringType, v.WanNames.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"hosts": basetypes.ListType{
				ElemType: types.StringType,
			},
			"internal_ips": basetypes.ListType{
				ElemType: types.StringType,
			},
			"probe_ips": basetypes.ListType{
				ElemType: types.StringType,
			},
			"remote_ids": basetypes.ListType{
				ElemType: types.StringType,
			},
			"wan_names": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"hosts": basetypes.ListType{
			ElemType: types.StringType,
		},
		"internal_ips": basetypes.ListType{
			ElemType: types.StringType,
		},
		"probe_ips": basetypes.ListType{
			ElemType: types.StringType,
		},
		"remote_ids": basetypes.ListType{
			ElemType: types.StringType,
		},
		"wan_names": basetypes.ListType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"hosts":        hostsVal,
			"internal_ips": internalIpsVal,
			"probe_ips":    probeIpsVal,
			"remote_ids":   remoteIdsVal,
			"wan_names":    wanNamesVal,
		})

	return objVal, diags
}

func (v PrimaryValue) Equal(o attr.Value) bool {
	other, ok := o.(PrimaryValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Hosts.Equal(other.Hosts) {
		return false
	}

	if !v.InternalIps.Equal(other.InternalIps) {
		return false
	}

	if !v.ProbeIps.Equal(other.ProbeIps) {
		return false
	}

	if !v.RemoteIds.Equal(other.RemoteIds) {
		return false
	}

	if !v.WanNames.Equal(other.WanNames) {
		return false
	}

	return true
}

func (v PrimaryValue) Type(ctx context.Context) attr.Type {
	return PrimaryType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PrimaryValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"hosts": basetypes.ListType{
			ElemType: types.StringType,
		},
		"internal_ips": basetypes.ListType{
			ElemType: types.StringType,
		},
		"probe_ips": basetypes.ListType{
			ElemType: types.StringType,
		},
		"remote_ids": basetypes.ListType{
			ElemType: types.StringType,
		},
		"wan_names": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = ProbeType{}

type ProbeType struct {
	basetypes.ObjectType
}

func (t ProbeType) Equal(o attr.Type) bool {
	other, ok := o.(ProbeType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ProbeType) String() string {
	return "ProbeType"
}

func (t ProbeType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	intervalAttribute, ok := attributes["interval"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interval is missing from object`)

		return nil, diags
	}

	intervalVal, ok := intervalAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interval expected to be basetypes.Int64Value, was: %T`, intervalAttribute))
	}

	thresholdAttribute, ok := attributes["threshold"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`threshold is missing from object`)

		return nil, diags
	}

	thresholdVal, ok := thresholdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`threshold expected to be basetypes.Int64Value, was: %T`, thresholdAttribute))
	}

	timeoutAttribute, ok := attributes["timeout"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`timeout is missing from object`)

		return nil, diags
	}

	timeoutVal, ok := timeoutAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`timeout expected to be basetypes.Int64Value, was: %T`, timeoutAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ProbeValue{
		Interval:  intervalVal,
		Threshold: thresholdVal,
		Timeout:   timeoutVal,
		ProbeType: typeVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewProbeValueNull() ProbeValue {
	return ProbeValue{
		state: attr.ValueStateNull,
	}
}

func NewProbeValueUnknown() ProbeValue {
	return ProbeValue{
		state: attr.ValueStateUnknown,
	}
}

func NewProbeValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ProbeValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ProbeValue Attribute Value",
				"While creating a ProbeValue value, a missing attribute value was detected. "+
					"A ProbeValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ProbeValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ProbeValue Attribute Type",
				"While creating a ProbeValue value, an invalid attribute value was detected. "+
					"A ProbeValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ProbeValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ProbeValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ProbeValue Attribute Value",
				"While creating a ProbeValue value, an extra attribute value was detected. "+
					"A ProbeValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ProbeValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewProbeValueUnknown(), diags
	}

	intervalAttribute, ok := attributes["interval"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interval is missing from object`)

		return NewProbeValueUnknown(), diags
	}

	intervalVal, ok := intervalAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interval expected to be basetypes.Int64Value, was: %T`, intervalAttribute))
	}

	thresholdAttribute, ok := attributes["threshold"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`threshold is missing from object`)

		return NewProbeValueUnknown(), diags
	}

	thresholdVal, ok := thresholdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`threshold expected to be basetypes.Int64Value, was: %T`, thresholdAttribute))
	}

	timeoutAttribute, ok := attributes["timeout"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`timeout is missing from object`)

		return NewProbeValueUnknown(), diags
	}

	timeoutVal, ok := timeoutAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`timeout expected to be basetypes.Int64Value, was: %T`, timeoutAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewProbeValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return NewProbeValueUnknown(), diags
	}

	return ProbeValue{
		Interval:  intervalVal,
		Threshold: thresholdVal,
		Timeout:   timeoutVal,
		ProbeType: typeVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewProbeValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ProbeValue {
	object, diags := NewProbeValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewProbeValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ProbeType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewProbeValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewProbeValueUnknown(), nil
	}

	if in.IsNull() {
		return NewProbeValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewProbeValueMust(ProbeValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ProbeType) ValueType(ctx context.Context) attr.Value {
	return ProbeValue{}
}

var _ basetypes.ObjectValuable = ProbeValue{}

type ProbeValue struct {
	Interval  basetypes.Int64Value  `tfsdk:"interval"`
	Threshold basetypes.Int64Value  `tfsdk:"threshold"`
	Timeout   basetypes.Int64Value  `tfsdk:"timeout"`
	ProbeType basetypes.StringValue `tfsdk:"type"`
	state     attr.ValueState
}

func (v ProbeValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["interval"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["threshold"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["timeout"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Interval.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["interval"] = val

		val, err = v.Threshold.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["threshold"] = val

		val, err = v.Timeout.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["timeout"] = val

		val, err = v.ProbeType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ProbeValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ProbeValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ProbeValue) String() string {
	return "ProbeValue"
}

func (v ProbeValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"interval":  basetypes.Int64Type{},
		"threshold": basetypes.Int64Type{},
		"timeout":   basetypes.Int64Type{},
		"type":      basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"interval":  v.Interval,
			"threshold": v.Threshold,
			"timeout":   v.Timeout,
			"type":      v.ProbeType,
		})

	return objVal, diags
}

func (v ProbeValue) Equal(o attr.Value) bool {
	other, ok := o.(ProbeValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Interval.Equal(other.Interval) {
		return false
	}

	if !v.Threshold.Equal(other.Threshold) {
		return false
	}

	if !v.Timeout.Equal(other.Timeout) {
		return false
	}

	if !v.ProbeType.Equal(other.ProbeType) {
		return false
	}

	return true
}

func (v ProbeValue) Type(ctx context.Context) attr.Type {
	return ProbeType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ProbeValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"interval":  basetypes.Int64Type{},
		"threshold": basetypes.Int64Type{},
		"timeout":   basetypes.Int64Type{},
		"type":      basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = SecondaryType{}

type SecondaryType struct {
	basetypes.ObjectType
}

func (t SecondaryType) Equal(o attr.Type) bool {
	other, ok := o.(SecondaryType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SecondaryType) String() string {
	return "SecondaryType"
}

func (t SecondaryType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	hostsAttribute, ok := attributes["hosts"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`hosts is missing from object`)

		return nil, diags
	}

	hostsVal, ok := hostsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`hosts expected to be basetypes.ListValue, was: %T`, hostsAttribute))
	}

	internalIpsAttribute, ok := attributes["internal_ips"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`internal_ips is missing from object`)

		return nil, diags
	}

	internalIpsVal, ok := internalIpsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`internal_ips expected to be basetypes.ListValue, was: %T`, internalIpsAttribute))
	}

	probeIpsAttribute, ok := attributes["probe_ips"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`probe_ips is missing from object`)

		return nil, diags
	}

	probeIpsVal, ok := probeIpsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`probe_ips expected to be basetypes.ListValue, was: %T`, probeIpsAttribute))
	}

	remoteIdsAttribute, ok := attributes["remote_ids"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remote_ids is missing from object`)

		return nil, diags
	}

	remoteIdsVal, ok := remoteIdsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remote_ids expected to be basetypes.ListValue, was: %T`, remoteIdsAttribute))
	}

	wanNamesAttribute, ok := attributes["wan_names"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wan_names is missing from object`)

		return nil, diags
	}

	wanNamesVal, ok := wanNamesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wan_names expected to be basetypes.ListValue, was: %T`, wanNamesAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SecondaryValue{
		Hosts:       hostsVal,
		InternalIps: internalIpsVal,
		ProbeIps:    probeIpsVal,
		RemoteIds:   remoteIdsVal,
		WanNames:    wanNamesVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewSecondaryValueNull() SecondaryValue {
	return SecondaryValue{
		state: attr.ValueStateNull,
	}
}

func NewSecondaryValueUnknown() SecondaryValue {
	return SecondaryValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSecondaryValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SecondaryValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SecondaryValue Attribute Value",
				"While creating a SecondaryValue value, a missing attribute value was detected. "+
					"A SecondaryValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SecondaryValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SecondaryValue Attribute Type",
				"While creating a SecondaryValue value, an invalid attribute value was detected. "+
					"A SecondaryValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SecondaryValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SecondaryValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SecondaryValue Attribute Value",
				"While creating a SecondaryValue value, an extra attribute value was detected. "+
					"A SecondaryValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SecondaryValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSecondaryValueUnknown(), diags
	}

	hostsAttribute, ok := attributes["hosts"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`hosts is missing from object`)

		return NewSecondaryValueUnknown(), diags
	}

	hostsVal, ok := hostsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`hosts expected to be basetypes.ListValue, was: %T`, hostsAttribute))
	}

	internalIpsAttribute, ok := attributes["internal_ips"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`internal_ips is missing from object`)

		return NewSecondaryValueUnknown(), diags
	}

	internalIpsVal, ok := internalIpsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`internal_ips expected to be basetypes.ListValue, was: %T`, internalIpsAttribute))
	}

	probeIpsAttribute, ok := attributes["probe_ips"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`probe_ips is missing from object`)

		return NewSecondaryValueUnknown(), diags
	}

	probeIpsVal, ok := probeIpsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`probe_ips expected to be basetypes.ListValue, was: %T`, probeIpsAttribute))
	}

	remoteIdsAttribute, ok := attributes["remote_ids"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remote_ids is missing from object`)

		return NewSecondaryValueUnknown(), diags
	}

	remoteIdsVal, ok := remoteIdsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remote_ids expected to be basetypes.ListValue, was: %T`, remoteIdsAttribute))
	}

	wanNamesAttribute, ok := attributes["wan_names"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wan_names is missing from object`)

		return NewSecondaryValueUnknown(), diags
	}

	wanNamesVal, ok := wanNamesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wan_names expected to be basetypes.ListValue, was: %T`, wanNamesAttribute))
	}

	if diags.HasError() {
		return NewSecondaryValueUnknown(), diags
	}

	return SecondaryValue{
		Hosts:       hostsVal,
		InternalIps: internalIpsVal,
		ProbeIps:    probeIpsVal,
		RemoteIds:   remoteIdsVal,
		WanNames:    wanNamesVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewSecondaryValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SecondaryValue {
	object, diags := NewSecondaryValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSecondaryValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SecondaryType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSecondaryValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSecondaryValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSecondaryValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSecondaryValueMust(SecondaryValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SecondaryType) ValueType(ctx context.Context) attr.Value {
	return SecondaryValue{}
}

var _ basetypes.ObjectValuable = SecondaryValue{}

type SecondaryValue struct {
	Hosts       basetypes.ListValue `tfsdk:"hosts"`
	InternalIps basetypes.ListValue `tfsdk:"internal_ips"`
	ProbeIps    basetypes.ListValue `tfsdk:"probe_ips"`
	RemoteIds   basetypes.ListValue `tfsdk:"remote_ids"`
	WanNames    basetypes.ListValue `tfsdk:"wan_names"`
	state       attr.ValueState
}

func (v SecondaryValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["hosts"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["internal_ips"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["probe_ips"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["remote_ids"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["wan_names"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.Hosts.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["hosts"] = val

		val, err = v.InternalIps.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["internal_ips"] = val

		val, err = v.ProbeIps.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["probe_ips"] = val

		val, err = v.RemoteIds.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["remote_ids"] = val

		val, err = v.WanNames.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["wan_names"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SecondaryValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SecondaryValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SecondaryValue) String() string {
	return "SecondaryValue"
}

func (v SecondaryValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var hostsVal basetypes.ListValue
	switch {
	case v.Hosts.IsUnknown():
		hostsVal = types.ListUnknown(types.StringType)
	case v.Hosts.IsNull():
		hostsVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		hostsVal, d = types.ListValue(types.StringType, v.Hosts.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"hosts": basetypes.ListType{
				ElemType: types.StringType,
			},
			"internal_ips": basetypes.ListType{
				ElemType: types.StringType,
			},
			"probe_ips": basetypes.ListType{
				ElemType: types.StringType,
			},
			"remote_ids": basetypes.ListType{
				ElemType: types.StringType,
			},
			"wan_names": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	var internalIpsVal basetypes.ListValue
	switch {
	case v.InternalIps.IsUnknown():
		internalIpsVal = types.ListUnknown(types.StringType)
	case v.InternalIps.IsNull():
		internalIpsVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		internalIpsVal, d = types.ListValue(types.StringType, v.InternalIps.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"hosts": basetypes.ListType{
				ElemType: types.StringType,
			},
			"internal_ips": basetypes.ListType{
				ElemType: types.StringType,
			},
			"probe_ips": basetypes.ListType{
				ElemType: types.StringType,
			},
			"remote_ids": basetypes.ListType{
				ElemType: types.StringType,
			},
			"wan_names": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	var probeIpsVal basetypes.ListValue
	switch {
	case v.ProbeIps.IsUnknown():
		probeIpsVal = types.ListUnknown(types.StringType)
	case v.ProbeIps.IsNull():
		probeIpsVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		probeIpsVal, d = types.ListValue(types.StringType, v.ProbeIps.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"hosts": basetypes.ListType{
				ElemType: types.StringType,
			},
			"internal_ips": basetypes.ListType{
				ElemType: types.StringType,
			},
			"probe_ips": basetypes.ListType{
				ElemType: types.StringType,
			},
			"remote_ids": basetypes.ListType{
				ElemType: types.StringType,
			},
			"wan_names": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	var remoteIdsVal basetypes.ListValue
	switch {
	case v.RemoteIds.IsUnknown():
		remoteIdsVal = types.ListUnknown(types.StringType)
	case v.RemoteIds.IsNull():
		remoteIdsVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		remoteIdsVal, d = types.ListValue(types.StringType, v.RemoteIds.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"hosts": basetypes.ListType{
				ElemType: types.StringType,
			},
			"internal_ips": basetypes.ListType{
				ElemType: types.StringType,
			},
			"probe_ips": basetypes.ListType{
				ElemType: types.StringType,
			},
			"remote_ids": basetypes.ListType{
				ElemType: types.StringType,
			},
			"wan_names": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	var wanNamesVal basetypes.ListValue
	switch {
	case v.WanNames.IsUnknown():
		wanNamesVal = types.ListUnknown(types.StringType)
	case v.WanNames.IsNull():
		wanNamesVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		wanNamesVal, d = types.ListValue(types.StringType, v.WanNames.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"hosts": basetypes.ListType{
				ElemType: types.StringType,
			},
			"internal_ips": basetypes.ListType{
				ElemType: types.StringType,
			},
			"probe_ips": basetypes.ListType{
				ElemType: types.StringType,
			},
			"remote_ids": basetypes.ListType{
				ElemType: types.StringType,
			},
			"wan_names": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"hosts": basetypes.ListType{
			ElemType: types.StringType,
		},
		"internal_ips": basetypes.ListType{
			ElemType: types.StringType,
		},
		"probe_ips": basetypes.ListType{
			ElemType: types.StringType,
		},
		"remote_ids": basetypes.ListType{
			ElemType: types.StringType,
		},
		"wan_names": basetypes.ListType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"hosts":        hostsVal,
			"internal_ips": internalIpsVal,
			"probe_ips":    probeIpsVal,
			"remote_ids":   remoteIdsVal,
			"wan_names":    wanNamesVal,
		})

	return objVal, diags
}

func (v SecondaryValue) Equal(o attr.Value) bool {
	other, ok := o.(SecondaryValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Hosts.Equal(other.Hosts) {
		return false
	}

	if !v.InternalIps.Equal(other.InternalIps) {
		return false
	}

	if !v.ProbeIps.Equal(other.ProbeIps) {
		return false
	}

	if !v.RemoteIds.Equal(other.RemoteIds) {
		return false
	}

	if !v.WanNames.Equal(other.WanNames) {
		return false
	}

	return true
}

func (v SecondaryValue) Type(ctx context.Context) attr.Type {
	return SecondaryType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SecondaryValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"hosts": basetypes.ListType{
			ElemType: types.StringType,
		},
		"internal_ips": basetypes.ListType{
			ElemType: types.StringType,
		},
		"probe_ips": basetypes.ListType{
			ElemType: types.StringType,
		},
		"remote_ids": basetypes.ListType{
			ElemType: types.StringType,
		},
		"wan_names": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = TunnelProviderOptionsType{}

type TunnelProviderOptionsType struct {
	basetypes.ObjectType
}

func (t TunnelProviderOptionsType) Equal(o attr.Type) bool {
	other, ok := o.(TunnelProviderOptionsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t TunnelProviderOptionsType) String() string {
	return "TunnelProviderOptionsType"
}

func (t TunnelProviderOptionsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	jseAttribute, ok := attributes["jse"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`jse is missing from object`)

		return nil, diags
	}

	jseVal, ok := jseAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`jse expected to be basetypes.ObjectValue, was: %T`, jseAttribute))
	}

	zscalerAttribute, ok := attributes["zscaler"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`zscaler is missing from object`)

		return nil, diags
	}

	zscalerVal, ok := zscalerAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`zscaler expected to be basetypes.ObjectValue, was: %T`, zscalerAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return TunnelProviderOptionsValue{
		Jse:     jseVal,
		Zscaler: zscalerVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewTunnelProviderOptionsValueNull() TunnelProviderOptionsValue {
	return TunnelProviderOptionsValue{
		state: attr.ValueStateNull,
	}
}

func NewTunnelProviderOptionsValueUnknown() TunnelProviderOptionsValue {
	return TunnelProviderOptionsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewTunnelProviderOptionsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (TunnelProviderOptionsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing TunnelProviderOptionsValue Attribute Value",
				"While creating a TunnelProviderOptionsValue value, a missing attribute value was detected. "+
					"A TunnelProviderOptionsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TunnelProviderOptionsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid TunnelProviderOptionsValue Attribute Type",
				"While creating a TunnelProviderOptionsValue value, an invalid attribute value was detected. "+
					"A TunnelProviderOptionsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TunnelProviderOptionsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("TunnelProviderOptionsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra TunnelProviderOptionsValue Attribute Value",
				"While creating a TunnelProviderOptionsValue value, an extra attribute value was detected. "+
					"A TunnelProviderOptionsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra TunnelProviderOptionsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewTunnelProviderOptionsValueUnknown(), diags
	}

	jseAttribute, ok := attributes["jse"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`jse is missing from object`)

		return NewTunnelProviderOptionsValueUnknown(), diags
	}

	jseVal, ok := jseAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`jse expected to be basetypes.ObjectValue, was: %T`, jseAttribute))
	}

	zscalerAttribute, ok := attributes["zscaler"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`zscaler is missing from object`)

		return NewTunnelProviderOptionsValueUnknown(), diags
	}

	zscalerVal, ok := zscalerAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`zscaler expected to be basetypes.ObjectValue, was: %T`, zscalerAttribute))
	}

	if diags.HasError() {
		return NewTunnelProviderOptionsValueUnknown(), diags
	}

	return TunnelProviderOptionsValue{
		Jse:     jseVal,
		Zscaler: zscalerVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewTunnelProviderOptionsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) TunnelProviderOptionsValue {
	object, diags := NewTunnelProviderOptionsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewTunnelProviderOptionsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t TunnelProviderOptionsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewTunnelProviderOptionsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewTunnelProviderOptionsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewTunnelProviderOptionsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewTunnelProviderOptionsValueMust(TunnelProviderOptionsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t TunnelProviderOptionsType) ValueType(ctx context.Context) attr.Value {
	return TunnelProviderOptionsValue{}
}

var _ basetypes.ObjectValuable = TunnelProviderOptionsValue{}

type TunnelProviderOptionsValue struct {
	Jse     basetypes.ObjectValue `tfsdk:"jse"`
	Zscaler basetypes.ObjectValue `tfsdk:"zscaler"`
	state   attr.ValueState
}

func (v TunnelProviderOptionsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["jse"] = basetypes.ObjectType{
		AttrTypes: JseValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["zscaler"] = basetypes.ObjectType{
		AttrTypes: ZscalerValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Jse.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["jse"] = val

		val, err = v.Zscaler.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["zscaler"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v TunnelProviderOptionsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v TunnelProviderOptionsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v TunnelProviderOptionsValue) String() string {
	return "TunnelProviderOptionsValue"
}

func (v TunnelProviderOptionsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var jse basetypes.ObjectValue

	if v.Jse.IsNull() {
		jse = types.ObjectNull(
			JseValue{}.AttributeTypes(ctx),
		)
	}

	if v.Jse.IsUnknown() {
		jse = types.ObjectUnknown(
			JseValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Jse.IsNull() && !v.Jse.IsUnknown() {
		jse = types.ObjectValueMust(
			JseValue{}.AttributeTypes(ctx),
			v.Jse.Attributes(),
		)
	}

	var zscaler basetypes.ObjectValue

	if v.Zscaler.IsNull() {
		zscaler = types.ObjectNull(
			ZscalerValue{}.AttributeTypes(ctx),
		)
	}

	if v.Zscaler.IsUnknown() {
		zscaler = types.ObjectUnknown(
			ZscalerValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Zscaler.IsNull() && !v.Zscaler.IsUnknown() {
		zscaler = types.ObjectValueMust(
			ZscalerValue{}.AttributeTypes(ctx),
			v.Zscaler.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"jse": basetypes.ObjectType{
			AttrTypes: JseValue{}.AttributeTypes(ctx),
		},
		"zscaler": basetypes.ObjectType{
			AttrTypes: ZscalerValue{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"jse":     jse,
			"zscaler": zscaler,
		})

	return objVal, diags
}

func (v TunnelProviderOptionsValue) Equal(o attr.Value) bool {
	other, ok := o.(TunnelProviderOptionsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Jse.Equal(other.Jse) {
		return false
	}

	if !v.Zscaler.Equal(other.Zscaler) {
		return false
	}

	return true
}

func (v TunnelProviderOptionsValue) Type(ctx context.Context) attr.Type {
	return TunnelProviderOptionsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v TunnelProviderOptionsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"jse": basetypes.ObjectType{
			AttrTypes: JseValue{}.AttributeTypes(ctx),
		},
		"zscaler": basetypes.ObjectType{
			AttrTypes: ZscalerValue{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = JseType{}

type JseType struct {
	basetypes.ObjectType
}

func (t JseType) Equal(o attr.Type) bool {
	other, ok := o.(JseType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t JseType) String() string {
	return "JseType"
}

func (t JseType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	numUsersAttribute, ok := attributes["num_users"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`num_users is missing from object`)

		return nil, diags
	}

	numUsersVal, ok := numUsersAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`num_users expected to be basetypes.Int64Value, was: %T`, numUsersAttribute))
	}

	orgNameAttribute, ok := attributes["org_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`org_name is missing from object`)

		return nil, diags
	}

	orgNameVal, ok := orgNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`org_name expected to be basetypes.StringValue, was: %T`, orgNameAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return JseValue{
		NumUsers: numUsersVal,
		OrgName:  orgNameVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewJseValueNull() JseValue {
	return JseValue{
		state: attr.ValueStateNull,
	}
}

func NewJseValueUnknown() JseValue {
	return JseValue{
		state: attr.ValueStateUnknown,
	}
}

func NewJseValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (JseValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing JseValue Attribute Value",
				"While creating a JseValue value, a missing attribute value was detected. "+
					"A JseValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("JseValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid JseValue Attribute Type",
				"While creating a JseValue value, an invalid attribute value was detected. "+
					"A JseValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("JseValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("JseValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra JseValue Attribute Value",
				"While creating a JseValue value, an extra attribute value was detected. "+
					"A JseValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra JseValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewJseValueUnknown(), diags
	}

	numUsersAttribute, ok := attributes["num_users"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`num_users is missing from object`)

		return NewJseValueUnknown(), diags
	}

	numUsersVal, ok := numUsersAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`num_users expected to be basetypes.Int64Value, was: %T`, numUsersAttribute))
	}

	orgNameAttribute, ok := attributes["org_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`org_name is missing from object`)

		return NewJseValueUnknown(), diags
	}

	orgNameVal, ok := orgNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`org_name expected to be basetypes.StringValue, was: %T`, orgNameAttribute))
	}

	if diags.HasError() {
		return NewJseValueUnknown(), diags
	}

	return JseValue{
		NumUsers: numUsersVal,
		OrgName:  orgNameVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewJseValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) JseValue {
	object, diags := NewJseValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewJseValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t JseType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewJseValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewJseValueUnknown(), nil
	}

	if in.IsNull() {
		return NewJseValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewJseValueMust(JseValue{}.AttributeTypes(ctx), attributes), nil
}

func (t JseType) ValueType(ctx context.Context) attr.Value {
	return JseValue{}
}

var _ basetypes.ObjectValuable = JseValue{}

type JseValue struct {
	NumUsers basetypes.Int64Value  `tfsdk:"num_users"`
	OrgName  basetypes.StringValue `tfsdk:"org_name"`
	state    attr.ValueState
}

func (v JseValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["num_users"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["org_name"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.NumUsers.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["num_users"] = val

		val, err = v.OrgName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["org_name"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v JseValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v JseValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v JseValue) String() string {
	return "JseValue"
}

func (v JseValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"num_users": basetypes.Int64Type{},
		"org_name":  basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"num_users": v.NumUsers,
			"org_name":  v.OrgName,
		})

	return objVal, diags
}

func (v JseValue) Equal(o attr.Value) bool {
	other, ok := o.(JseValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.NumUsers.Equal(other.NumUsers) {
		return false
	}

	if !v.OrgName.Equal(other.OrgName) {
		return false
	}

	return true
}

func (v JseValue) Type(ctx context.Context) attr.Type {
	return JseType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v JseValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"num_users": basetypes.Int64Type{},
		"org_name":  basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = ZscalerType{}

type ZscalerType struct {
	basetypes.ObjectType
}

func (t ZscalerType) Equal(o attr.Type) bool {
	other, ok := o.(ZscalerType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ZscalerType) String() string {
	return "ZscalerType"
}

func (t ZscalerType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	aupBlockInternetUntilAcceptedAttribute, ok := attributes["aup_block_internet_until_accepted"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`aup_block_internet_until_accepted is missing from object`)

		return nil, diags
	}

	aupBlockInternetUntilAcceptedVal, ok := aupBlockInternetUntilAcceptedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`aup_block_internet_until_accepted expected to be basetypes.BoolValue, was: %T`, aupBlockInternetUntilAcceptedAttribute))
	}

	aupEnabledAttribute, ok := attributes["aup_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`aup_enabled is missing from object`)

		return nil, diags
	}

	aupEnabledVal, ok := aupEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`aup_enabled expected to be basetypes.BoolValue, was: %T`, aupEnabledAttribute))
	}

	aupForceSslInspectionAttribute, ok := attributes["aup_force_ssl_inspection"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`aup_force_ssl_inspection is missing from object`)

		return nil, diags
	}

	aupForceSslInspectionVal, ok := aupForceSslInspectionAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`aup_force_ssl_inspection expected to be basetypes.BoolValue, was: %T`, aupForceSslInspectionAttribute))
	}

	aupTimeoutInDaysAttribute, ok := attributes["aup_timeout_in_days"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`aup_timeout_in_days is missing from object`)

		return nil, diags
	}

	aupTimeoutInDaysVal, ok := aupTimeoutInDaysAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`aup_timeout_in_days expected to be basetypes.Int64Value, was: %T`, aupTimeoutInDaysAttribute))
	}

	authRequiredAttribute, ok := attributes["auth_required"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auth_required is missing from object`)

		return nil, diags
	}

	authRequiredVal, ok := authRequiredAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auth_required expected to be basetypes.BoolValue, was: %T`, authRequiredAttribute))
	}

	cautionEnabledAttribute, ok := attributes["caution_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`caution_enabled is missing from object`)

		return nil, diags
	}

	cautionEnabledVal, ok := cautionEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`caution_enabled expected to be basetypes.BoolValue, was: %T`, cautionEnabledAttribute))
	}

	dnBandwidthAttribute, ok := attributes["dn_bandwidth"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dn_bandwidth is missing from object`)

		return nil, diags
	}

	dnBandwidthVal, ok := dnBandwidthAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dn_bandwidth expected to be basetypes.Float64Value, was: %T`, dnBandwidthAttribute))
	}

	idleTimeInMinutesAttribute, ok := attributes["idle_time_in_minutes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`idle_time_in_minutes is missing from object`)

		return nil, diags
	}

	idleTimeInMinutesVal, ok := idleTimeInMinutesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`idle_time_in_minutes expected to be basetypes.Int64Value, was: %T`, idleTimeInMinutesAttribute))
	}

	ofwEnabledAttribute, ok := attributes["ofw_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ofw_enabled is missing from object`)

		return nil, diags
	}

	ofwEnabledVal, ok := ofwEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ofw_enabled expected to be basetypes.BoolValue, was: %T`, ofwEnabledAttribute))
	}

	subLocationsAttribute, ok := attributes["sub_locations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sub_locations is missing from object`)

		return nil, diags
	}

	subLocationsVal, ok := subLocationsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sub_locations expected to be basetypes.ListValue, was: %T`, subLocationsAttribute))
	}

	surrogateIpAttribute, ok := attributes["surrogate_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`surrogate_ip is missing from object`)

		return nil, diags
	}

	surrogateIpVal, ok := surrogateIpAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`surrogate_ip expected to be basetypes.BoolValue, was: %T`, surrogateIpAttribute))
	}

	surrogateIpEnforcedForKnownBrowsersAttribute, ok := attributes["surrogate_ip_enforced_for_known_browsers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`surrogate_ip_enforced_for_known_browsers is missing from object`)

		return nil, diags
	}

	surrogateIpEnforcedForKnownBrowsersVal, ok := surrogateIpEnforcedForKnownBrowsersAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`surrogate_ip_enforced_for_known_browsers expected to be basetypes.BoolValue, was: %T`, surrogateIpEnforcedForKnownBrowsersAttribute))
	}

	surrogateRefreshTimeInMinutesAttribute, ok := attributes["surrogate_refresh_time_in_minutes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`surrogate_refresh_time_in_minutes is missing from object`)

		return nil, diags
	}

	surrogateRefreshTimeInMinutesVal, ok := surrogateRefreshTimeInMinutesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`surrogate_refresh_time_in_minutes expected to be basetypes.Int64Value, was: %T`, surrogateRefreshTimeInMinutesAttribute))
	}

	upBandwidthAttribute, ok := attributes["up_bandwidth"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`up_bandwidth is missing from object`)

		return nil, diags
	}

	upBandwidthVal, ok := upBandwidthAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`up_bandwidth expected to be basetypes.Float64Value, was: %T`, upBandwidthAttribute))
	}

	xffForwardEnabledAttribute, ok := attributes["xff_forward_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`xff_forward_enabled is missing from object`)

		return nil, diags
	}

	xffForwardEnabledVal, ok := xffForwardEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`xff_forward_enabled expected to be basetypes.BoolValue, was: %T`, xffForwardEnabledAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ZscalerValue{
		AupBlockInternetUntilAccepted:       aupBlockInternetUntilAcceptedVal,
		AupEnabled:                          aupEnabledVal,
		AupForceSslInspection:               aupForceSslInspectionVal,
		AupTimeoutInDays:                    aupTimeoutInDaysVal,
		AuthRequired:                        authRequiredVal,
		CautionEnabled:                      cautionEnabledVal,
		DnBandwidth:                         dnBandwidthVal,
		IdleTimeInMinutes:                   idleTimeInMinutesVal,
		OfwEnabled:                          ofwEnabledVal,
		SubLocations:                        subLocationsVal,
		SurrogateIp:                         surrogateIpVal,
		SurrogateIpEnforcedForKnownBrowsers: surrogateIpEnforcedForKnownBrowsersVal,
		SurrogateRefreshTimeInMinutes:       surrogateRefreshTimeInMinutesVal,
		UpBandwidth:                         upBandwidthVal,
		XffForwardEnabled:                   xffForwardEnabledVal,
		state:                               attr.ValueStateKnown,
	}, diags
}

func NewZscalerValueNull() ZscalerValue {
	return ZscalerValue{
		state: attr.ValueStateNull,
	}
}

func NewZscalerValueUnknown() ZscalerValue {
	return ZscalerValue{
		state: attr.ValueStateUnknown,
	}
}

func NewZscalerValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ZscalerValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ZscalerValue Attribute Value",
				"While creating a ZscalerValue value, a missing attribute value was detected. "+
					"A ZscalerValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ZscalerValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ZscalerValue Attribute Type",
				"While creating a ZscalerValue value, an invalid attribute value was detected. "+
					"A ZscalerValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ZscalerValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ZscalerValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ZscalerValue Attribute Value",
				"While creating a ZscalerValue value, an extra attribute value was detected. "+
					"A ZscalerValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ZscalerValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewZscalerValueUnknown(), diags
	}

	aupBlockInternetUntilAcceptedAttribute, ok := attributes["aup_block_internet_until_accepted"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`aup_block_internet_until_accepted is missing from object`)

		return NewZscalerValueUnknown(), diags
	}

	aupBlockInternetUntilAcceptedVal, ok := aupBlockInternetUntilAcceptedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`aup_block_internet_until_accepted expected to be basetypes.BoolValue, was: %T`, aupBlockInternetUntilAcceptedAttribute))
	}

	aupEnabledAttribute, ok := attributes["aup_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`aup_enabled is missing from object`)

		return NewZscalerValueUnknown(), diags
	}

	aupEnabledVal, ok := aupEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`aup_enabled expected to be basetypes.BoolValue, was: %T`, aupEnabledAttribute))
	}

	aupForceSslInspectionAttribute, ok := attributes["aup_force_ssl_inspection"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`aup_force_ssl_inspection is missing from object`)

		return NewZscalerValueUnknown(), diags
	}

	aupForceSslInspectionVal, ok := aupForceSslInspectionAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`aup_force_ssl_inspection expected to be basetypes.BoolValue, was: %T`, aupForceSslInspectionAttribute))
	}

	aupTimeoutInDaysAttribute, ok := attributes["aup_timeout_in_days"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`aup_timeout_in_days is missing from object`)

		return NewZscalerValueUnknown(), diags
	}

	aupTimeoutInDaysVal, ok := aupTimeoutInDaysAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`aup_timeout_in_days expected to be basetypes.Int64Value, was: %T`, aupTimeoutInDaysAttribute))
	}

	authRequiredAttribute, ok := attributes["auth_required"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auth_required is missing from object`)

		return NewZscalerValueUnknown(), diags
	}

	authRequiredVal, ok := authRequiredAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auth_required expected to be basetypes.BoolValue, was: %T`, authRequiredAttribute))
	}

	cautionEnabledAttribute, ok := attributes["caution_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`caution_enabled is missing from object`)

		return NewZscalerValueUnknown(), diags
	}

	cautionEnabledVal, ok := cautionEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`caution_enabled expected to be basetypes.BoolValue, was: %T`, cautionEnabledAttribute))
	}

	dnBandwidthAttribute, ok := attributes["dn_bandwidth"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dn_bandwidth is missing from object`)

		return NewZscalerValueUnknown(), diags
	}

	dnBandwidthVal, ok := dnBandwidthAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dn_bandwidth expected to be basetypes.Float64Value, was: %T`, dnBandwidthAttribute))
	}

	idleTimeInMinutesAttribute, ok := attributes["idle_time_in_minutes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`idle_time_in_minutes is missing from object`)

		return NewZscalerValueUnknown(), diags
	}

	idleTimeInMinutesVal, ok := idleTimeInMinutesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`idle_time_in_minutes expected to be basetypes.Int64Value, was: %T`, idleTimeInMinutesAttribute))
	}

	ofwEnabledAttribute, ok := attributes["ofw_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ofw_enabled is missing from object`)

		return NewZscalerValueUnknown(), diags
	}

	ofwEnabledVal, ok := ofwEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ofw_enabled expected to be basetypes.BoolValue, was: %T`, ofwEnabledAttribute))
	}

	subLocationsAttribute, ok := attributes["sub_locations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sub_locations is missing from object`)

		return NewZscalerValueUnknown(), diags
	}

	subLocationsVal, ok := subLocationsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sub_locations expected to be basetypes.ListValue, was: %T`, subLocationsAttribute))
	}

	surrogateIpAttribute, ok := attributes["surrogate_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`surrogate_ip is missing from object`)

		return NewZscalerValueUnknown(), diags
	}

	surrogateIpVal, ok := surrogateIpAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`surrogate_ip expected to be basetypes.BoolValue, was: %T`, surrogateIpAttribute))
	}

	surrogateIpEnforcedForKnownBrowsersAttribute, ok := attributes["surrogate_ip_enforced_for_known_browsers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`surrogate_ip_enforced_for_known_browsers is missing from object`)

		return NewZscalerValueUnknown(), diags
	}

	surrogateIpEnforcedForKnownBrowsersVal, ok := surrogateIpEnforcedForKnownBrowsersAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`surrogate_ip_enforced_for_known_browsers expected to be basetypes.BoolValue, was: %T`, surrogateIpEnforcedForKnownBrowsersAttribute))
	}

	surrogateRefreshTimeInMinutesAttribute, ok := attributes["surrogate_refresh_time_in_minutes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`surrogate_refresh_time_in_minutes is missing from object`)

		return NewZscalerValueUnknown(), diags
	}

	surrogateRefreshTimeInMinutesVal, ok := surrogateRefreshTimeInMinutesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`surrogate_refresh_time_in_minutes expected to be basetypes.Int64Value, was: %T`, surrogateRefreshTimeInMinutesAttribute))
	}

	upBandwidthAttribute, ok := attributes["up_bandwidth"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`up_bandwidth is missing from object`)

		return NewZscalerValueUnknown(), diags
	}

	upBandwidthVal, ok := upBandwidthAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`up_bandwidth expected to be basetypes.Float64Value, was: %T`, upBandwidthAttribute))
	}

	xffForwardEnabledAttribute, ok := attributes["xff_forward_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`xff_forward_enabled is missing from object`)

		return NewZscalerValueUnknown(), diags
	}

	xffForwardEnabledVal, ok := xffForwardEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`xff_forward_enabled expected to be basetypes.BoolValue, was: %T`, xffForwardEnabledAttribute))
	}

	if diags.HasError() {
		return NewZscalerValueUnknown(), diags
	}

	return ZscalerValue{
		AupBlockInternetUntilAccepted:       aupBlockInternetUntilAcceptedVal,
		AupEnabled:                          aupEnabledVal,
		AupForceSslInspection:               aupForceSslInspectionVal,
		AupTimeoutInDays:                    aupTimeoutInDaysVal,
		AuthRequired:                        authRequiredVal,
		CautionEnabled:                      cautionEnabledVal,
		DnBandwidth:                         dnBandwidthVal,
		IdleTimeInMinutes:                   idleTimeInMinutesVal,
		OfwEnabled:                          ofwEnabledVal,
		SubLocations:                        subLocationsVal,
		SurrogateIp:                         surrogateIpVal,
		SurrogateIpEnforcedForKnownBrowsers: surrogateIpEnforcedForKnownBrowsersVal,
		SurrogateRefreshTimeInMinutes:       surrogateRefreshTimeInMinutesVal,
		UpBandwidth:                         upBandwidthVal,
		XffForwardEnabled:                   xffForwardEnabledVal,
		state:                               attr.ValueStateKnown,
	}, diags
}

func NewZscalerValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ZscalerValue {
	object, diags := NewZscalerValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewZscalerValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ZscalerType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewZscalerValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewZscalerValueUnknown(), nil
	}

	if in.IsNull() {
		return NewZscalerValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewZscalerValueMust(ZscalerValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ZscalerType) ValueType(ctx context.Context) attr.Value {
	return ZscalerValue{}
}

var _ basetypes.ObjectValuable = ZscalerValue{}

type ZscalerValue struct {
	AupBlockInternetUntilAccepted       basetypes.BoolValue    `tfsdk:"aup_block_internet_until_accepted"`
	AupEnabled                          basetypes.BoolValue    `tfsdk:"aup_enabled"`
	AupForceSslInspection               basetypes.BoolValue    `tfsdk:"aup_force_ssl_inspection"`
	AupTimeoutInDays                    basetypes.Int64Value   `tfsdk:"aup_timeout_in_days"`
	AuthRequired                        basetypes.BoolValue    `tfsdk:"auth_required"`
	CautionEnabled                      basetypes.BoolValue    `tfsdk:"caution_enabled"`
	DnBandwidth                         basetypes.Float64Value `tfsdk:"dn_bandwidth"`
	IdleTimeInMinutes                   basetypes.Int64Value   `tfsdk:"idle_time_in_minutes"`
	OfwEnabled                          basetypes.BoolValue    `tfsdk:"ofw_enabled"`
	SubLocations                        basetypes.ListValue    `tfsdk:"sub_locations"`
	SurrogateIp                         basetypes.BoolValue    `tfsdk:"surrogate_ip"`
	SurrogateIpEnforcedForKnownBrowsers basetypes.BoolValue    `tfsdk:"surrogate_ip_enforced_for_known_browsers"`
	SurrogateRefreshTimeInMinutes       basetypes.Int64Value   `tfsdk:"surrogate_refresh_time_in_minutes"`
	UpBandwidth                         basetypes.Float64Value `tfsdk:"up_bandwidth"`
	XffForwardEnabled                   basetypes.BoolValue    `tfsdk:"xff_forward_enabled"`
	state                               attr.ValueState
}

func (v ZscalerValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 15)

	var val tftypes.Value
	var err error

	attrTypes["aup_block_internet_until_accepted"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["aup_enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["aup_force_ssl_inspection"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["aup_timeout_in_days"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["auth_required"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["caution_enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["dn_bandwidth"] = basetypes.Float64Type{}.TerraformType(ctx)
	attrTypes["idle_time_in_minutes"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["ofw_enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["sub_locations"] = basetypes.ListType{
		ElemType: SubLocationsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["surrogate_ip"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["surrogate_ip_enforced_for_known_browsers"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["surrogate_refresh_time_in_minutes"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["up_bandwidth"] = basetypes.Float64Type{}.TerraformType(ctx)
	attrTypes["xff_forward_enabled"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 15)

		val, err = v.AupBlockInternetUntilAccepted.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["aup_block_internet_until_accepted"] = val

		val, err = v.AupEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["aup_enabled"] = val

		val, err = v.AupForceSslInspection.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["aup_force_ssl_inspection"] = val

		val, err = v.AupTimeoutInDays.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["aup_timeout_in_days"] = val

		val, err = v.AuthRequired.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["auth_required"] = val

		val, err = v.CautionEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["caution_enabled"] = val

		val, err = v.DnBandwidth.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dn_bandwidth"] = val

		val, err = v.IdleTimeInMinutes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["idle_time_in_minutes"] = val

		val, err = v.OfwEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ofw_enabled"] = val

		val, err = v.SubLocations.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["sub_locations"] = val

		val, err = v.SurrogateIp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["surrogate_ip"] = val

		val, err = v.SurrogateIpEnforcedForKnownBrowsers.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["surrogate_ip_enforced_for_known_browsers"] = val

		val, err = v.SurrogateRefreshTimeInMinutes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["surrogate_refresh_time_in_minutes"] = val

		val, err = v.UpBandwidth.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["up_bandwidth"] = val

		val, err = v.XffForwardEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["xff_forward_enabled"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ZscalerValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ZscalerValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ZscalerValue) String() string {
	return "ZscalerValue"
}

func (v ZscalerValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	subLocations := types.ListValueMust(
		SubLocationsType{
			basetypes.ObjectType{
				AttrTypes: SubLocationsValue{}.AttributeTypes(ctx),
			},
		},
		v.SubLocations.Elements(),
	)

	if v.SubLocations.IsNull() {
		subLocations = types.ListNull(
			SubLocationsType{
				basetypes.ObjectType{
					AttrTypes: SubLocationsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.SubLocations.IsUnknown() {
		subLocations = types.ListUnknown(
			SubLocationsType{
				basetypes.ObjectType{
					AttrTypes: SubLocationsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"aup_block_internet_until_accepted": basetypes.BoolType{},
		"aup_enabled":                       basetypes.BoolType{},
		"aup_force_ssl_inspection":          basetypes.BoolType{},
		"aup_timeout_in_days":               basetypes.Int64Type{},
		"auth_required":                     basetypes.BoolType{},
		"caution_enabled":                   basetypes.BoolType{},
		"dn_bandwidth":                      basetypes.Float64Type{},
		"idle_time_in_minutes":              basetypes.Int64Type{},
		"ofw_enabled":                       basetypes.BoolType{},
		"sub_locations": basetypes.ListType{
			ElemType: SubLocationsValue{}.Type(ctx),
		},
		"surrogate_ip": basetypes.BoolType{},
		"surrogate_ip_enforced_for_known_browsers": basetypes.BoolType{},
		"surrogate_refresh_time_in_minutes":        basetypes.Int64Type{},
		"up_bandwidth":                             basetypes.Float64Type{},
		"xff_forward_enabled":                      basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"aup_block_internet_until_accepted":        v.AupBlockInternetUntilAccepted,
			"aup_enabled":                              v.AupEnabled,
			"aup_force_ssl_inspection":                 v.AupForceSslInspection,
			"aup_timeout_in_days":                      v.AupTimeoutInDays,
			"auth_required":                            v.AuthRequired,
			"caution_enabled":                          v.CautionEnabled,
			"dn_bandwidth":                             v.DnBandwidth,
			"idle_time_in_minutes":                     v.IdleTimeInMinutes,
			"ofw_enabled":                              v.OfwEnabled,
			"sub_locations":                            subLocations,
			"surrogate_ip":                             v.SurrogateIp,
			"surrogate_ip_enforced_for_known_browsers": v.SurrogateIpEnforcedForKnownBrowsers,
			"surrogate_refresh_time_in_minutes":        v.SurrogateRefreshTimeInMinutes,
			"up_bandwidth":                             v.UpBandwidth,
			"xff_forward_enabled":                      v.XffForwardEnabled,
		})

	return objVal, diags
}

func (v ZscalerValue) Equal(o attr.Value) bool {
	other, ok := o.(ZscalerValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AupBlockInternetUntilAccepted.Equal(other.AupBlockInternetUntilAccepted) {
		return false
	}

	if !v.AupEnabled.Equal(other.AupEnabled) {
		return false
	}

	if !v.AupForceSslInspection.Equal(other.AupForceSslInspection) {
		return false
	}

	if !v.AupTimeoutInDays.Equal(other.AupTimeoutInDays) {
		return false
	}

	if !v.AuthRequired.Equal(other.AuthRequired) {
		return false
	}

	if !v.CautionEnabled.Equal(other.CautionEnabled) {
		return false
	}

	if !v.DnBandwidth.Equal(other.DnBandwidth) {
		return false
	}

	if !v.IdleTimeInMinutes.Equal(other.IdleTimeInMinutes) {
		return false
	}

	if !v.OfwEnabled.Equal(other.OfwEnabled) {
		return false
	}

	if !v.SubLocations.Equal(other.SubLocations) {
		return false
	}

	if !v.SurrogateIp.Equal(other.SurrogateIp) {
		return false
	}

	if !v.SurrogateIpEnforcedForKnownBrowsers.Equal(other.SurrogateIpEnforcedForKnownBrowsers) {
		return false
	}

	if !v.SurrogateRefreshTimeInMinutes.Equal(other.SurrogateRefreshTimeInMinutes) {
		return false
	}

	if !v.UpBandwidth.Equal(other.UpBandwidth) {
		return false
	}

	if !v.XffForwardEnabled.Equal(other.XffForwardEnabled) {
		return false
	}

	return true
}

func (v ZscalerValue) Type(ctx context.Context) attr.Type {
	return ZscalerType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ZscalerValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"aup_block_internet_until_accepted": basetypes.BoolType{},
		"aup_enabled":                       basetypes.BoolType{},
		"aup_force_ssl_inspection":          basetypes.BoolType{},
		"aup_timeout_in_days":               basetypes.Int64Type{},
		"auth_required":                     basetypes.BoolType{},
		"caution_enabled":                   basetypes.BoolType{},
		"dn_bandwidth":                      basetypes.Float64Type{},
		"idle_time_in_minutes":              basetypes.Int64Type{},
		"ofw_enabled":                       basetypes.BoolType{},
		"sub_locations": basetypes.ListType{
			ElemType: SubLocationsValue{}.Type(ctx),
		},
		"surrogate_ip": basetypes.BoolType{},
		"surrogate_ip_enforced_for_known_browsers": basetypes.BoolType{},
		"surrogate_refresh_time_in_minutes":        basetypes.Int64Type{},
		"up_bandwidth":                             basetypes.Float64Type{},
		"xff_forward_enabled":                      basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = SubLocationsType{}

type SubLocationsType struct {
	basetypes.ObjectType
}

func (t SubLocationsType) Equal(o attr.Type) bool {
	other, ok := o.(SubLocationsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SubLocationsType) String() string {
	return "SubLocationsType"
}

func (t SubLocationsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	aupBlockInternetUntilAcceptedAttribute, ok := attributes["aup_block_internet_until_accepted"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`aup_block_internet_until_accepted is missing from object`)

		return nil, diags
	}

	aupBlockInternetUntilAcceptedVal, ok := aupBlockInternetUntilAcceptedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`aup_block_internet_until_accepted expected to be basetypes.BoolValue, was: %T`, aupBlockInternetUntilAcceptedAttribute))
	}

	aupEnabledAttribute, ok := attributes["aup_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`aup_enabled is missing from object`)

		return nil, diags
	}

	aupEnabledVal, ok := aupEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`aup_enabled expected to be basetypes.BoolValue, was: %T`, aupEnabledAttribute))
	}

	aupForceSslInspectionAttribute, ok := attributes["aup_force_ssl_inspection"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`aup_force_ssl_inspection is missing from object`)

		return nil, diags
	}

	aupForceSslInspectionVal, ok := aupForceSslInspectionAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`aup_force_ssl_inspection expected to be basetypes.BoolValue, was: %T`, aupForceSslInspectionAttribute))
	}

	aupTimeoutInDaysAttribute, ok := attributes["aup_timeout_in_days"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`aup_timeout_in_days is missing from object`)

		return nil, diags
	}

	aupTimeoutInDaysVal, ok := aupTimeoutInDaysAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`aup_timeout_in_days expected to be basetypes.Int64Value, was: %T`, aupTimeoutInDaysAttribute))
	}

	authRequiredAttribute, ok := attributes["auth_required"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auth_required is missing from object`)

		return nil, diags
	}

	authRequiredVal, ok := authRequiredAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auth_required expected to be basetypes.BoolValue, was: %T`, authRequiredAttribute))
	}

	cautionEnabledAttribute, ok := attributes["caution_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`caution_enabled is missing from object`)

		return nil, diags
	}

	cautionEnabledVal, ok := cautionEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`caution_enabled expected to be basetypes.BoolValue, was: %T`, cautionEnabledAttribute))
	}

	dnBandwidthAttribute, ok := attributes["dn_bandwidth"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dn_bandwidth is missing from object`)

		return nil, diags
	}

	dnBandwidthVal, ok := dnBandwidthAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dn_bandwidth expected to be basetypes.Float64Value, was: %T`, dnBandwidthAttribute))
	}

	idleTimeInMinutesAttribute, ok := attributes["idle_time_in_minutes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`idle_time_in_minutes is missing from object`)

		return nil, diags
	}

	idleTimeInMinutesVal, ok := idleTimeInMinutesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`idle_time_in_minutes expected to be basetypes.Int64Value, was: %T`, idleTimeInMinutesAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	ofwEnabledAttribute, ok := attributes["ofw_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ofw_enabled is missing from object`)

		return nil, diags
	}

	ofwEnabledVal, ok := ofwEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ofw_enabled expected to be basetypes.BoolValue, was: %T`, ofwEnabledAttribute))
	}

	surrogateIpAttribute, ok := attributes["surrogate_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`surrogate_ip is missing from object`)

		return nil, diags
	}

	surrogateIpVal, ok := surrogateIpAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`surrogate_ip expected to be basetypes.BoolValue, was: %T`, surrogateIpAttribute))
	}

	surrogateIpEnforcedForKnownBrowsersAttribute, ok := attributes["surrogate_ip_enforced_for_known_browsers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`surrogate_ip_enforced_for_known_browsers is missing from object`)

		return nil, diags
	}

	surrogateIpEnforcedForKnownBrowsersVal, ok := surrogateIpEnforcedForKnownBrowsersAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`surrogate_ip_enforced_for_known_browsers expected to be basetypes.BoolValue, was: %T`, surrogateIpEnforcedForKnownBrowsersAttribute))
	}

	surrogateRefreshTimeInMinutesAttribute, ok := attributes["surrogate_refresh_time_in_minutes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`surrogate_refresh_time_in_minutes is missing from object`)

		return nil, diags
	}

	surrogateRefreshTimeInMinutesVal, ok := surrogateRefreshTimeInMinutesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`surrogate_refresh_time_in_minutes expected to be basetypes.Int64Value, was: %T`, surrogateRefreshTimeInMinutesAttribute))
	}

	upBandwidthAttribute, ok := attributes["up_bandwidth"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`up_bandwidth is missing from object`)

		return nil, diags
	}

	upBandwidthVal, ok := upBandwidthAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`up_bandwidth expected to be basetypes.Float64Value, was: %T`, upBandwidthAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SubLocationsValue{
		AupBlockInternetUntilAccepted:       aupBlockInternetUntilAcceptedVal,
		AupEnabled:                          aupEnabledVal,
		AupForceSslInspection:               aupForceSslInspectionVal,
		AupTimeoutInDays:                    aupTimeoutInDaysVal,
		AuthRequired:                        authRequiredVal,
		CautionEnabled:                      cautionEnabledVal,
		DnBandwidth:                         dnBandwidthVal,
		IdleTimeInMinutes:                   idleTimeInMinutesVal,
		Name:                                nameVal,
		OfwEnabled:                          ofwEnabledVal,
		SurrogateIp:                         surrogateIpVal,
		SurrogateIpEnforcedForKnownBrowsers: surrogateIpEnforcedForKnownBrowsersVal,
		SurrogateRefreshTimeInMinutes:       surrogateRefreshTimeInMinutesVal,
		UpBandwidth:                         upBandwidthVal,
		state:                               attr.ValueStateKnown,
	}, diags
}

func NewSubLocationsValueNull() SubLocationsValue {
	return SubLocationsValue{
		state: attr.ValueStateNull,
	}
}

func NewSubLocationsValueUnknown() SubLocationsValue {
	return SubLocationsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSubLocationsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SubLocationsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SubLocationsValue Attribute Value",
				"While creating a SubLocationsValue value, a missing attribute value was detected. "+
					"A SubLocationsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SubLocationsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SubLocationsValue Attribute Type",
				"While creating a SubLocationsValue value, an invalid attribute value was detected. "+
					"A SubLocationsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SubLocationsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SubLocationsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SubLocationsValue Attribute Value",
				"While creating a SubLocationsValue value, an extra attribute value was detected. "+
					"A SubLocationsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SubLocationsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSubLocationsValueUnknown(), diags
	}

	aupBlockInternetUntilAcceptedAttribute, ok := attributes["aup_block_internet_until_accepted"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`aup_block_internet_until_accepted is missing from object`)

		return NewSubLocationsValueUnknown(), diags
	}

	aupBlockInternetUntilAcceptedVal, ok := aupBlockInternetUntilAcceptedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`aup_block_internet_until_accepted expected to be basetypes.BoolValue, was: %T`, aupBlockInternetUntilAcceptedAttribute))
	}

	aupEnabledAttribute, ok := attributes["aup_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`aup_enabled is missing from object`)

		return NewSubLocationsValueUnknown(), diags
	}

	aupEnabledVal, ok := aupEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`aup_enabled expected to be basetypes.BoolValue, was: %T`, aupEnabledAttribute))
	}

	aupForceSslInspectionAttribute, ok := attributes["aup_force_ssl_inspection"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`aup_force_ssl_inspection is missing from object`)

		return NewSubLocationsValueUnknown(), diags
	}

	aupForceSslInspectionVal, ok := aupForceSslInspectionAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`aup_force_ssl_inspection expected to be basetypes.BoolValue, was: %T`, aupForceSslInspectionAttribute))
	}

	aupTimeoutInDaysAttribute, ok := attributes["aup_timeout_in_days"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`aup_timeout_in_days is missing from object`)

		return NewSubLocationsValueUnknown(), diags
	}

	aupTimeoutInDaysVal, ok := aupTimeoutInDaysAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`aup_timeout_in_days expected to be basetypes.Int64Value, was: %T`, aupTimeoutInDaysAttribute))
	}

	authRequiredAttribute, ok := attributes["auth_required"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auth_required is missing from object`)

		return NewSubLocationsValueUnknown(), diags
	}

	authRequiredVal, ok := authRequiredAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auth_required expected to be basetypes.BoolValue, was: %T`, authRequiredAttribute))
	}

	cautionEnabledAttribute, ok := attributes["caution_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`caution_enabled is missing from object`)

		return NewSubLocationsValueUnknown(), diags
	}

	cautionEnabledVal, ok := cautionEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`caution_enabled expected to be basetypes.BoolValue, was: %T`, cautionEnabledAttribute))
	}

	dnBandwidthAttribute, ok := attributes["dn_bandwidth"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dn_bandwidth is missing from object`)

		return NewSubLocationsValueUnknown(), diags
	}

	dnBandwidthVal, ok := dnBandwidthAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dn_bandwidth expected to be basetypes.Float64Value, was: %T`, dnBandwidthAttribute))
	}

	idleTimeInMinutesAttribute, ok := attributes["idle_time_in_minutes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`idle_time_in_minutes is missing from object`)

		return NewSubLocationsValueUnknown(), diags
	}

	idleTimeInMinutesVal, ok := idleTimeInMinutesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`idle_time_in_minutes expected to be basetypes.Int64Value, was: %T`, idleTimeInMinutesAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewSubLocationsValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	ofwEnabledAttribute, ok := attributes["ofw_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ofw_enabled is missing from object`)

		return NewSubLocationsValueUnknown(), diags
	}

	ofwEnabledVal, ok := ofwEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ofw_enabled expected to be basetypes.BoolValue, was: %T`, ofwEnabledAttribute))
	}

	surrogateIpAttribute, ok := attributes["surrogate_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`surrogate_ip is missing from object`)

		return NewSubLocationsValueUnknown(), diags
	}

	surrogateIpVal, ok := surrogateIpAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`surrogate_ip expected to be basetypes.BoolValue, was: %T`, surrogateIpAttribute))
	}

	surrogateIpEnforcedForKnownBrowsersAttribute, ok := attributes["surrogate_ip_enforced_for_known_browsers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`surrogate_ip_enforced_for_known_browsers is missing from object`)

		return NewSubLocationsValueUnknown(), diags
	}

	surrogateIpEnforcedForKnownBrowsersVal, ok := surrogateIpEnforcedForKnownBrowsersAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`surrogate_ip_enforced_for_known_browsers expected to be basetypes.BoolValue, was: %T`, surrogateIpEnforcedForKnownBrowsersAttribute))
	}

	surrogateRefreshTimeInMinutesAttribute, ok := attributes["surrogate_refresh_time_in_minutes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`surrogate_refresh_time_in_minutes is missing from object`)

		return NewSubLocationsValueUnknown(), diags
	}

	surrogateRefreshTimeInMinutesVal, ok := surrogateRefreshTimeInMinutesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`surrogate_refresh_time_in_minutes expected to be basetypes.Int64Value, was: %T`, surrogateRefreshTimeInMinutesAttribute))
	}

	upBandwidthAttribute, ok := attributes["up_bandwidth"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`up_bandwidth is missing from object`)

		return NewSubLocationsValueUnknown(), diags
	}

	upBandwidthVal, ok := upBandwidthAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`up_bandwidth expected to be basetypes.Float64Value, was: %T`, upBandwidthAttribute))
	}

	if diags.HasError() {
		return NewSubLocationsValueUnknown(), diags
	}

	return SubLocationsValue{
		AupBlockInternetUntilAccepted:       aupBlockInternetUntilAcceptedVal,
		AupEnabled:                          aupEnabledVal,
		AupForceSslInspection:               aupForceSslInspectionVal,
		AupTimeoutInDays:                    aupTimeoutInDaysVal,
		AuthRequired:                        authRequiredVal,
		CautionEnabled:                      cautionEnabledVal,
		DnBandwidth:                         dnBandwidthVal,
		IdleTimeInMinutes:                   idleTimeInMinutesVal,
		Name:                                nameVal,
		OfwEnabled:                          ofwEnabledVal,
		SurrogateIp:                         surrogateIpVal,
		SurrogateIpEnforcedForKnownBrowsers: surrogateIpEnforcedForKnownBrowsersVal,
		SurrogateRefreshTimeInMinutes:       surrogateRefreshTimeInMinutesVal,
		UpBandwidth:                         upBandwidthVal,
		state:                               attr.ValueStateKnown,
	}, diags
}

func NewSubLocationsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SubLocationsValue {
	object, diags := NewSubLocationsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSubLocationsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SubLocationsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSubLocationsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSubLocationsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSubLocationsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSubLocationsValueMust(SubLocationsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SubLocationsType) ValueType(ctx context.Context) attr.Value {
	return SubLocationsValue{}
}

var _ basetypes.ObjectValuable = SubLocationsValue{}

type SubLocationsValue struct {
	AupBlockInternetUntilAccepted       basetypes.BoolValue    `tfsdk:"aup_block_internet_until_accepted"`
	AupEnabled                          basetypes.BoolValue    `tfsdk:"aup_enabled"`
	AupForceSslInspection               basetypes.BoolValue    `tfsdk:"aup_force_ssl_inspection"`
	AupTimeoutInDays                    basetypes.Int64Value   `tfsdk:"aup_timeout_in_days"`
	AuthRequired                        basetypes.BoolValue    `tfsdk:"auth_required"`
	CautionEnabled                      basetypes.BoolValue    `tfsdk:"caution_enabled"`
	DnBandwidth                         basetypes.Float64Value `tfsdk:"dn_bandwidth"`
	IdleTimeInMinutes                   basetypes.Int64Value   `tfsdk:"idle_time_in_minutes"`
	Name                                basetypes.StringValue  `tfsdk:"name"`
	OfwEnabled                          basetypes.BoolValue    `tfsdk:"ofw_enabled"`
	SurrogateIp                         basetypes.BoolValue    `tfsdk:"surrogate_ip"`
	SurrogateIpEnforcedForKnownBrowsers basetypes.BoolValue    `tfsdk:"surrogate_ip_enforced_for_known_browsers"`
	SurrogateRefreshTimeInMinutes       basetypes.Int64Value   `tfsdk:"surrogate_refresh_time_in_minutes"`
	UpBandwidth                         basetypes.Float64Value `tfsdk:"up_bandwidth"`
	state                               attr.ValueState
}

func (v SubLocationsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 14)

	var val tftypes.Value
	var err error

	attrTypes["aup_block_internet_until_accepted"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["aup_enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["aup_force_ssl_inspection"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["aup_timeout_in_days"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["auth_required"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["caution_enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["dn_bandwidth"] = basetypes.Float64Type{}.TerraformType(ctx)
	attrTypes["idle_time_in_minutes"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ofw_enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["surrogate_ip"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["surrogate_ip_enforced_for_known_browsers"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["surrogate_refresh_time_in_minutes"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["up_bandwidth"] = basetypes.Float64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 14)

		val, err = v.AupBlockInternetUntilAccepted.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["aup_block_internet_until_accepted"] = val

		val, err = v.AupEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["aup_enabled"] = val

		val, err = v.AupForceSslInspection.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["aup_force_ssl_inspection"] = val

		val, err = v.AupTimeoutInDays.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["aup_timeout_in_days"] = val

		val, err = v.AuthRequired.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["auth_required"] = val

		val, err = v.CautionEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["caution_enabled"] = val

		val, err = v.DnBandwidth.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dn_bandwidth"] = val

		val, err = v.IdleTimeInMinutes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["idle_time_in_minutes"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.OfwEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ofw_enabled"] = val

		val, err = v.SurrogateIp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["surrogate_ip"] = val

		val, err = v.SurrogateIpEnforcedForKnownBrowsers.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["surrogate_ip_enforced_for_known_browsers"] = val

		val, err = v.SurrogateRefreshTimeInMinutes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["surrogate_refresh_time_in_minutes"] = val

		val, err = v.UpBandwidth.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["up_bandwidth"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SubLocationsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SubLocationsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SubLocationsValue) String() string {
	return "SubLocationsValue"
}

func (v SubLocationsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"aup_block_internet_until_accepted": basetypes.BoolType{},
		"aup_enabled":                       basetypes.BoolType{},
		"aup_force_ssl_inspection":          basetypes.BoolType{},
		"aup_timeout_in_days":               basetypes.Int64Type{},
		"auth_required":                     basetypes.BoolType{},
		"caution_enabled":                   basetypes.BoolType{},
		"dn_bandwidth":                      basetypes.Float64Type{},
		"idle_time_in_minutes":              basetypes.Int64Type{},
		"name":                              basetypes.StringType{},
		"ofw_enabled":                       basetypes.BoolType{},
		"surrogate_ip":                      basetypes.BoolType{},
		"surrogate_ip_enforced_for_known_browsers": basetypes.BoolType{},
		"surrogate_refresh_time_in_minutes":        basetypes.Int64Type{},
		"up_bandwidth":                             basetypes.Float64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"aup_block_internet_until_accepted": v.AupBlockInternetUntilAccepted,
			"aup_enabled":                       v.AupEnabled,
			"aup_force_ssl_inspection":          v.AupForceSslInspection,
			"aup_timeout_in_days":               v.AupTimeoutInDays,
			"auth_required":                     v.AuthRequired,
			"caution_enabled":                   v.CautionEnabled,
			"dn_bandwidth":                      v.DnBandwidth,
			"idle_time_in_minutes":              v.IdleTimeInMinutes,
			"name":                              v.Name,
			"ofw_enabled":                       v.OfwEnabled,
			"surrogate_ip":                      v.SurrogateIp,
			"surrogate_ip_enforced_for_known_browsers": v.SurrogateIpEnforcedForKnownBrowsers,
			"surrogate_refresh_time_in_minutes":        v.SurrogateRefreshTimeInMinutes,
			"up_bandwidth":                             v.UpBandwidth,
		})

	return objVal, diags
}

func (v SubLocationsValue) Equal(o attr.Value) bool {
	other, ok := o.(SubLocationsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AupBlockInternetUntilAccepted.Equal(other.AupBlockInternetUntilAccepted) {
		return false
	}

	if !v.AupEnabled.Equal(other.AupEnabled) {
		return false
	}

	if !v.AupForceSslInspection.Equal(other.AupForceSslInspection) {
		return false
	}

	if !v.AupTimeoutInDays.Equal(other.AupTimeoutInDays) {
		return false
	}

	if !v.AuthRequired.Equal(other.AuthRequired) {
		return false
	}

	if !v.CautionEnabled.Equal(other.CautionEnabled) {
		return false
	}

	if !v.DnBandwidth.Equal(other.DnBandwidth) {
		return false
	}

	if !v.IdleTimeInMinutes.Equal(other.IdleTimeInMinutes) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.OfwEnabled.Equal(other.OfwEnabled) {
		return false
	}

	if !v.SurrogateIp.Equal(other.SurrogateIp) {
		return false
	}

	if !v.SurrogateIpEnforcedForKnownBrowsers.Equal(other.SurrogateIpEnforcedForKnownBrowsers) {
		return false
	}

	if !v.SurrogateRefreshTimeInMinutes.Equal(other.SurrogateRefreshTimeInMinutes) {
		return false
	}

	if !v.UpBandwidth.Equal(other.UpBandwidth) {
		return false
	}

	return true
}

func (v SubLocationsValue) Type(ctx context.Context) attr.Type {
	return SubLocationsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SubLocationsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"aup_block_internet_until_accepted": basetypes.BoolType{},
		"aup_enabled":                       basetypes.BoolType{},
		"aup_force_ssl_inspection":          basetypes.BoolType{},
		"aup_timeout_in_days":               basetypes.Int64Type{},
		"auth_required":                     basetypes.BoolType{},
		"caution_enabled":                   basetypes.BoolType{},
		"dn_bandwidth":                      basetypes.Float64Type{},
		"idle_time_in_minutes":              basetypes.Int64Type{},
		"name":                              basetypes.StringType{},
		"ofw_enabled":                       basetypes.BoolType{},
		"surrogate_ip":                      basetypes.BoolType{},
		"surrogate_ip_enforced_for_known_browsers": basetypes.BoolType{},
		"surrogate_refresh_time_in_minutes":        basetypes.Int64Type{},
		"up_bandwidth":                             basetypes.Float64Type{},
	}
}

var _ basetypes.ObjectTypable = VrfConfigType{}

type VrfConfigType struct {
	basetypes.ObjectType
}

func (t VrfConfigType) Equal(o attr.Type) bool {
	other, ok := o.(VrfConfigType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t VrfConfigType) String() string {
	return "VrfConfigType"
}

func (t VrfConfigType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return VrfConfigValue{
		Enabled: enabledVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewVrfConfigValueNull() VrfConfigValue {
	return VrfConfigValue{
		state: attr.ValueStateNull,
	}
}

func NewVrfConfigValueUnknown() VrfConfigValue {
	return VrfConfigValue{
		state: attr.ValueStateUnknown,
	}
}

func NewVrfConfigValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (VrfConfigValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing VrfConfigValue Attribute Value",
				"While creating a VrfConfigValue value, a missing attribute value was detected. "+
					"A VrfConfigValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VrfConfigValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid VrfConfigValue Attribute Type",
				"While creating a VrfConfigValue value, an invalid attribute value was detected. "+
					"A VrfConfigValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VrfConfigValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("VrfConfigValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra VrfConfigValue Attribute Value",
				"While creating a VrfConfigValue value, an extra attribute value was detected. "+
					"A VrfConfigValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra VrfConfigValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewVrfConfigValueUnknown(), diags
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewVrfConfigValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	if diags.HasError() {
		return NewVrfConfigValueUnknown(), diags
	}

	return VrfConfigValue{
		Enabled: enabledVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewVrfConfigValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) VrfConfigValue {
	object, diags := NewVrfConfigValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewVrfConfigValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t VrfConfigType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewVrfConfigValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewVrfConfigValueUnknown(), nil
	}

	if in.IsNull() {
		return NewVrfConfigValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewVrfConfigValueMust(VrfConfigValue{}.AttributeTypes(ctx), attributes), nil
}

func (t VrfConfigType) ValueType(ctx context.Context) attr.Value {
	return VrfConfigValue{}
}

var _ basetypes.ObjectValuable = VrfConfigValue{}

type VrfConfigValue struct {
	Enabled basetypes.BoolValue `tfsdk:"enabled"`
	state   attr.ValueState
}

func (v VrfConfigValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v VrfConfigValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v VrfConfigValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v VrfConfigValue) String() string {
	return "VrfConfigValue"
}

func (v VrfConfigValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"enabled": basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"enabled": v.Enabled,
		})

	return objVal, diags
}

func (v VrfConfigValue) Equal(o attr.Value) bool {
	other, ok := o.(VrfConfigValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	return true
}

func (v VrfConfigValue) Type(ctx context.Context) attr.Type {
	return VrfConfigType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v VrfConfigValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"enabled": basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = VrfInstancesType{}

type VrfInstancesType struct {
	basetypes.ObjectType
}

func (t VrfInstancesType) Equal(o attr.Type) bool {
	other, ok := o.(VrfInstancesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t VrfInstancesType) String() string {
	return "VrfInstancesType"
}

func (t VrfInstancesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	networksAttribute, ok := attributes["networks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`networks is missing from object`)

		return nil, diags
	}

	networksVal, ok := networksAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`networks expected to be basetypes.ListValue, was: %T`, networksAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return VrfInstancesValue{
		Networks: networksVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewVrfInstancesValueNull() VrfInstancesValue {
	return VrfInstancesValue{
		state: attr.ValueStateNull,
	}
}

func NewVrfInstancesValueUnknown() VrfInstancesValue {
	return VrfInstancesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewVrfInstancesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (VrfInstancesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing VrfInstancesValue Attribute Value",
				"While creating a VrfInstancesValue value, a missing attribute value was detected. "+
					"A VrfInstancesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VrfInstancesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid VrfInstancesValue Attribute Type",
				"While creating a VrfInstancesValue value, an invalid attribute value was detected. "+
					"A VrfInstancesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VrfInstancesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("VrfInstancesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra VrfInstancesValue Attribute Value",
				"While creating a VrfInstancesValue value, an extra attribute value was detected. "+
					"A VrfInstancesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra VrfInstancesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewVrfInstancesValueUnknown(), diags
	}

	networksAttribute, ok := attributes["networks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`networks is missing from object`)

		return NewVrfInstancesValueUnknown(), diags
	}

	networksVal, ok := networksAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`networks expected to be basetypes.ListValue, was: %T`, networksAttribute))
	}

	if diags.HasError() {
		return NewVrfInstancesValueUnknown(), diags
	}

	return VrfInstancesValue{
		Networks: networksVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewVrfInstancesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) VrfInstancesValue {
	object, diags := NewVrfInstancesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewVrfInstancesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t VrfInstancesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewVrfInstancesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewVrfInstancesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewVrfInstancesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewVrfInstancesValueMust(VrfInstancesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t VrfInstancesType) ValueType(ctx context.Context) attr.Value {
	return VrfInstancesValue{}
}

var _ basetypes.ObjectValuable = VrfInstancesValue{}

type VrfInstancesValue struct {
	Networks basetypes.ListValue `tfsdk:"networks"`
	state    attr.ValueState
}

func (v VrfInstancesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["networks"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Networks.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["networks"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v VrfInstancesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v VrfInstancesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v VrfInstancesValue) String() string {
	return "VrfInstancesValue"
}

func (v VrfInstancesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var networksVal basetypes.ListValue
	switch {
	case v.Networks.IsUnknown():
		networksVal = types.ListUnknown(types.StringType)
	case v.Networks.IsNull():
		networksVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		networksVal, d = types.ListValue(types.StringType, v.Networks.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"networks": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"networks": basetypes.ListType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"networks": networksVal,
		})

	return objVal, diags
}

func (v VrfInstancesValue) Equal(o attr.Value) bool {
	other, ok := o.(VrfInstancesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Networks.Equal(other.Networks) {
		return false
	}

	return true
}

func (v VrfInstancesValue) Type(ctx context.Context) attr.Type {
	return VrfInstancesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v VrfInstancesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"networks": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}
