// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package resource_org_apitoken

import (
	"context"
	"fmt"
	"github.com/Juniper/terraform-provider-mist/internal/validators"
	"github.com/hashicorp/terraform-plugin-framework-validators/listvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
)

func OrgApitokenResourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"created_by": schema.StringAttribute{
				Computed:            true,
				Description:         "email of the token creator / null if creator is deleted",
				MarkdownDescription: "email of the token creator / null if creator is deleted",
			},
			"id": schema.StringAttribute{
				Computed:            true,
				Description:         "Unique ID of the object instance in the Mist Organization",
				MarkdownDescription: "Unique ID of the object instance in the Mist Organization",
			},
			"key": schema.StringAttribute{
				Computed:  true,
				Sensitive: true,
			},
			"name": schema.StringAttribute{
				Required:            true,
				Description:         "Name of the token",
				MarkdownDescription: "Name of the token",
			},
			"org_id": schema.StringAttribute{
				Required: true,
			},
			"privileges": schema.ListNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"role": schema.StringAttribute{
							Required:            true,
							Description:         "access permissions. enum: `admin`, `helpdesk`, `installer`, `read`, `write`",
							MarkdownDescription: "access permissions. enum: `admin`, `helpdesk`, `installer`, `read`, `write`",
							Validators: []validator.String{
								stringvalidator.OneOf(
									"",
									"admin",
									"helpdesk",
									"installer",
									"read",
									"write",
								),
							},
						},
						"scope": schema.StringAttribute{
							Required:            true,
							Description:         "enum: `org`, `site`, `sitegroup`",
							MarkdownDescription: "enum: `org`, `site`, `sitegroup`",
							Validators: []validator.String{
								stringvalidator.OneOf(
									"",
									"org",
									"site",
									"sitegroup",
								),
							},
						},
						"site_id": schema.StringAttribute{
							Optional:            true,
							Description:         "Required if `scope`==`site`",
							MarkdownDescription: "Required if `scope`==`site`",
							Validators: []validator.String{
								mistvalidator.RequiredWhenValueIs(path.MatchRelative().AtParent().AtName("scope"), types.StringValue("site")),
								mistvalidator.AllowedWhenValueIs(path.MatchRelative().AtParent().AtName("scope"), types.StringValue("site")),
							},
						},
						"sitegroup_id": schema.StringAttribute{
							Optional:            true,
							Description:         "Required if `scope`==`sitegroup`",
							MarkdownDescription: "Required if `scope`==`sitegroup`",
							Validators: []validator.String{
								mistvalidator.RequiredWhenValueIs(path.MatchRelative().AtParent().AtName("scope"), types.StringValue("sitegroup")),
								mistvalidator.AllowedWhenValueIs(path.MatchRelative().AtParent().AtName("scope"), types.StringValue("sitegroup")),
							},
						},
						"views": schema.ListAttribute{
							ElementType:         types.StringType,
							Optional:            true,
							Description:         "Custom roles restrict Org users to specific UI views. This is useful for limiting UI access of Org users. Custom roles restrict Org users to specific UI views. This is useful for limiting UI access of Org users.  \nYou can define custom roles by adding the `views` attribute along with `role` when assigning privileges.  \nBelow are the list of supported UI views. Note that this is UI only feature.  \n\n  | UI View | Required Role | Description |\n  | --- | --- | --- |\n  | `reporting` | `read` | full access to all analytics tools |\n  | `marketing` | `read` | can view analytics and location maps |\n  | `super_observer` | `read` | can view all the organization except the subscription page |\n  | `location` | `write` | can view and manage location maps, can view analytics |\n  | `security` | `write` | can view and manage site labels, policies and security |\n  | `switch_admin` | `helpdesk` | can view and manage Switch ports, can view wired clients |\n  | `mxedge_admin` | `admin` | can view and manage Mist edges and Mist tunnels |\n  | `lobby_admin` | `admin` | full access to Org and Site Pre-shared keys |",
							MarkdownDescription: "Custom roles restrict Org users to specific UI views. This is useful for limiting UI access of Org users. Custom roles restrict Org users to specific UI views. This is useful for limiting UI access of Org users.  \nYou can define custom roles by adding the `views` attribute along with `role` when assigning privileges.  \nBelow are the list of supported UI views. Note that this is UI only feature.  \n\n  | UI View | Required Role | Description |\n  | --- | --- | --- |\n  | `reporting` | `read` | full access to all analytics tools |\n  | `marketing` | `read` | can view analytics and location maps |\n  | `super_observer` | `read` | can view all the organization except the subscription page |\n  | `location` | `write` | can view and manage location maps, can view analytics |\n  | `security` | `write` | can view and manage site labels, policies and security |\n  | `switch_admin` | `helpdesk` | can view and manage Switch ports, can view wired clients |\n  | `mxedge_admin` | `admin` | can view and manage Mist edges and Mist tunnels |\n  | `lobby_admin` | `admin` | full access to Org and Site Pre-shared keys |",
						},
					},
					CustomType: PrivilegesType{
						ObjectType: types.ObjectType{
							AttrTypes: PrivilegesValue{}.AttributeTypes(ctx),
						},
					},
				},
				Required:            true,
				Description:         "List of privileges the token has on the orgs/sites",
				MarkdownDescription: "List of privileges the token has on the orgs/sites",
				Validators: []validator.List{
					listvalidator.SizeAtLeast(1),
				},
			},
			"src_ips": schema.ListAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Description:         "List of allowed IP addresses from where the token can be used from. At most 10 IP addresses can be specified, cannot be changed once the API Token is created.",
				MarkdownDescription: "List of allowed IP addresses from where the token can be used from. At most 10 IP addresses can be specified, cannot be changed once the API Token is created.",
				Validators: []validator.List{
					listvalidator.SizeAtLeast(1),
					listvalidator.SizeAtMost(10),
					listvalidator.ValueStringsAre(
						stringvalidator.Any(
							mistvalidator.ParseIp(false, false),
							mistvalidator.ParseCidr(false, false),
						),
					),
				},
			},
		},
	}
}

type OrgApitokenModel struct {
	CreatedBy  types.String `tfsdk:"created_by"`
	Id         types.String `tfsdk:"id"`
	Key        types.String `tfsdk:"key"`
	Name       types.String `tfsdk:"name"`
	OrgId      types.String `tfsdk:"org_id"`
	Privileges types.List   `tfsdk:"privileges"`
	SrcIps     types.List   `tfsdk:"src_ips"`
}

var _ basetypes.ObjectTypable = PrivilegesType{}

type PrivilegesType struct {
	basetypes.ObjectType
}

func (t PrivilegesType) Equal(o attr.Type) bool {
	other, ok := o.(PrivilegesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PrivilegesType) String() string {
	return "PrivilegesType"
}

func (t PrivilegesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	roleAttribute, ok := attributes["role"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`role is missing from object`)

		return nil, diags
	}

	roleVal, ok := roleAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`role expected to be basetypes.StringValue, was: %T`, roleAttribute))
	}

	scopeAttribute, ok := attributes["scope"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`scope is missing from object`)

		return nil, diags
	}

	scopeVal, ok := scopeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`scope expected to be basetypes.StringValue, was: %T`, scopeAttribute))
	}

	siteIdAttribute, ok := attributes["site_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`site_id is missing from object`)

		return nil, diags
	}

	siteIdVal, ok := siteIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`site_id expected to be basetypes.StringValue, was: %T`, siteIdAttribute))
	}

	sitegroupIdAttribute, ok := attributes["sitegroup_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sitegroup_id is missing from object`)

		return nil, diags
	}

	sitegroupIdVal, ok := sitegroupIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sitegroup_id expected to be basetypes.StringValue, was: %T`, sitegroupIdAttribute))
	}

	viewsAttribute, ok := attributes["views"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`views is missing from object`)

		return nil, diags
	}

	viewsVal, ok := viewsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`views expected to be basetypes.ListValue, was: %T`, viewsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PrivilegesValue{
		Role:        roleVal,
		Scope:       scopeVal,
		SiteId:      siteIdVal,
		SitegroupId: sitegroupIdVal,
		Views:       viewsVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewPrivilegesValueNull() PrivilegesValue {
	return PrivilegesValue{
		state: attr.ValueStateNull,
	}
}

func NewPrivilegesValueUnknown() PrivilegesValue {
	return PrivilegesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPrivilegesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PrivilegesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PrivilegesValue Attribute Value",
				"While creating a PrivilegesValue value, a missing attribute value was detected. "+
					"A PrivilegesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PrivilegesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PrivilegesValue Attribute Type",
				"While creating a PrivilegesValue value, an invalid attribute value was detected. "+
					"A PrivilegesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PrivilegesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PrivilegesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PrivilegesValue Attribute Value",
				"While creating a PrivilegesValue value, an extra attribute value was detected. "+
					"A PrivilegesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PrivilegesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPrivilegesValueUnknown(), diags
	}

	roleAttribute, ok := attributes["role"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`role is missing from object`)

		return NewPrivilegesValueUnknown(), diags
	}

	roleVal, ok := roleAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`role expected to be basetypes.StringValue, was: %T`, roleAttribute))
	}

	scopeAttribute, ok := attributes["scope"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`scope is missing from object`)

		return NewPrivilegesValueUnknown(), diags
	}

	scopeVal, ok := scopeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`scope expected to be basetypes.StringValue, was: %T`, scopeAttribute))
	}

	siteIdAttribute, ok := attributes["site_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`site_id is missing from object`)

		return NewPrivilegesValueUnknown(), diags
	}

	siteIdVal, ok := siteIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`site_id expected to be basetypes.StringValue, was: %T`, siteIdAttribute))
	}

	sitegroupIdAttribute, ok := attributes["sitegroup_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sitegroup_id is missing from object`)

		return NewPrivilegesValueUnknown(), diags
	}

	sitegroupIdVal, ok := sitegroupIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sitegroup_id expected to be basetypes.StringValue, was: %T`, sitegroupIdAttribute))
	}

	viewsAttribute, ok := attributes["views"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`views is missing from object`)

		return NewPrivilegesValueUnknown(), diags
	}

	viewsVal, ok := viewsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`views expected to be basetypes.ListValue, was: %T`, viewsAttribute))
	}

	if diags.HasError() {
		return NewPrivilegesValueUnknown(), diags
	}

	return PrivilegesValue{
		Role:        roleVal,
		Scope:       scopeVal,
		SiteId:      siteIdVal,
		SitegroupId: sitegroupIdVal,
		Views:       viewsVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewPrivilegesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PrivilegesValue {
	object, diags := NewPrivilegesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPrivilegesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PrivilegesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPrivilegesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPrivilegesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPrivilegesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPrivilegesValueMust(PrivilegesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PrivilegesType) ValueType(ctx context.Context) attr.Value {
	return PrivilegesValue{}
}

var _ basetypes.ObjectValuable = PrivilegesValue{}

type PrivilegesValue struct {
	Role        basetypes.StringValue `tfsdk:"role"`
	Scope       basetypes.StringValue `tfsdk:"scope"`
	SiteId      basetypes.StringValue `tfsdk:"site_id"`
	SitegroupId basetypes.StringValue `tfsdk:"sitegroup_id"`
	Views       basetypes.ListValue   `tfsdk:"views"`
	state       attr.ValueState
}

func (v PrivilegesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["role"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["scope"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["site_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["sitegroup_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["views"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.Role.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["role"] = val

		val, err = v.Scope.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["scope"] = val

		val, err = v.SiteId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["site_id"] = val

		val, err = v.SitegroupId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["sitegroup_id"] = val

		val, err = v.Views.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["views"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PrivilegesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PrivilegesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PrivilegesValue) String() string {
	return "PrivilegesValue"
}

func (v PrivilegesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	viewsVal, d := types.ListValue(types.StringType, v.Views.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"role":         basetypes.StringType{},
			"scope":        basetypes.StringType{},
			"site_id":      basetypes.StringType{},
			"sitegroup_id": basetypes.StringType{},
			"views": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"role":         basetypes.StringType{},
		"scope":        basetypes.StringType{},
		"site_id":      basetypes.StringType{},
		"sitegroup_id": basetypes.StringType{},
		"views": basetypes.ListType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"role":         v.Role,
			"scope":        v.Scope,
			"site_id":      v.SiteId,
			"sitegroup_id": v.SitegroupId,
			"views":        viewsVal,
		})

	return objVal, diags
}

func (v PrivilegesValue) Equal(o attr.Value) bool {
	other, ok := o.(PrivilegesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Role.Equal(other.Role) {
		return false
	}

	if !v.Scope.Equal(other.Scope) {
		return false
	}

	if !v.SiteId.Equal(other.SiteId) {
		return false
	}

	if !v.SitegroupId.Equal(other.SitegroupId) {
		return false
	}

	if !v.Views.Equal(other.Views) {
		return false
	}

	return true
}

func (v PrivilegesValue) Type(ctx context.Context) attr.Type {
	return PrivilegesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PrivilegesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"role":         basetypes.StringType{},
		"scope":        basetypes.StringType{},
		"site_id":      basetypes.StringType{},
		"sitegroup_id": basetypes.StringType{},
		"views": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}
