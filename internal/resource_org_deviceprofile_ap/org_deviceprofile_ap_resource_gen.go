// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package resource_org_deviceprofile_ap

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework-validators/int64validator"
	"github.com/hashicorp/terraform-plugin-framework-validators/listvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/booldefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/int64default"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
)

func OrgDeviceprofileApResourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"aeroscout": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"enabled": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "whether to enable aeroscout config",
						MarkdownDescription: "whether to enable aeroscout config",
						Default:             booldefault.StaticBool(false),
					},
					"host": schema.StringAttribute{
						Optional:            true,
						Description:         "required if enabled, aeroscout server host",
						MarkdownDescription: "required if enabled, aeroscout server host",
					},
					"locate_connected": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "whether to enable the feature to allow wireless clients data received and sent to AES server for location calculation",
						MarkdownDescription: "whether to enable the feature to allow wireless clients data received and sent to AES server for location calculation",
						Default:             booldefault.StaticBool(true),
					},
				},
				CustomType: AeroscoutType{
					ObjectType: types.ObjectType{
						AttrTypes: AeroscoutValue{}.AttributeTypes(ctx),
					},
				},
				Optional:            true,
				Description:         "Aeroscout AP settings",
				MarkdownDescription: "Aeroscout AP settings",
			},
			"ble_config": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"beacon_enabled": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "whether Mist beacons is enabled",
						MarkdownDescription: "whether Mist beacons is enabled",
						Default:             booldefault.StaticBool(false),
					},
					"beacon_rate": schema.Int64Attribute{
						Optional:            true,
						Computed:            true,
						Description:         "required if `beacon_rate_mode`==`custom`, 1-10, in number-beacons-per-second",
						MarkdownDescription: "required if `beacon_rate_mode`==`custom`, 1-10, in number-beacons-per-second",
						Default:             int64default.StaticInt64(0),
					},
					"beacon_rate_mode": schema.StringAttribute{
						Optional: true,
						Computed: true,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"",
								"default",
								"custom",
							),
						},
						Default: stringdefault.StaticString("default"),
					},
					"beam_disabled": schema.ListAttribute{
						ElementType:         types.Int64Type,
						Optional:            true,
						Description:         "list of AP BLE location beam numbers (1-8) which should be disabled at the AP and not transmit location information (where beam 1 is oriented at the top the AP, growing counter-clock-wise, with 9 being the omni BLE beam)",
						MarkdownDescription: "list of AP BLE location beam numbers (1-8) which should be disabled at the AP and not transmit location information (where beam 1 is oriented at the top the AP, growing counter-clock-wise, with 9 being the omni BLE beam)",
					},
					"custom_ble_packet_enabled": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "can be enabled if `beacon_enabled`==`true`, whether to send custom packet",
						MarkdownDescription: "can be enabled if `beacon_enabled`==`true`, whether to send custom packet",
						Default:             booldefault.StaticBool(false),
					},
					"custom_ble_packet_frame": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "The custom frame to be sent out in this beacon. The frame must be a hexstring",
						MarkdownDescription: "The custom frame to be sent out in this beacon. The frame must be a hexstring",
						Default:             stringdefault.StaticString(""),
					},
					"custom_ble_packet_freq_msec": schema.Int64Attribute{
						Optional:            true,
						Computed:            true,
						Description:         "Frequency (msec) of data emitted by custom ble beacon",
						MarkdownDescription: "Frequency (msec) of data emitted by custom ble beacon",
						Validators: []validator.Int64{
							int64validator.AtLeast(0),
						},
						Default: int64default.StaticInt64(0),
					},
					"eddystone_uid_adv_power": schema.Int64Attribute{
						Optional:            true,
						Computed:            true,
						Description:         "advertised TX Power, -100 to 20 (dBm), omit this attribute to use default",
						MarkdownDescription: "advertised TX Power, -100 to 20 (dBm), omit this attribute to use default",
						Validators: []validator.Int64{
							int64validator.Between(-100, 20),
						},
						Default: int64default.StaticInt64(0),
					},
					"eddystone_uid_beams": schema.StringAttribute{
						Optional: true,
						Computed: true,
						Default:  stringdefault.StaticString(""),
					},
					"eddystone_uid_enabled": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "only if `beacon_enabled`==`false`, Whether Eddystone-UID beacon is enabled",
						MarkdownDescription: "only if `beacon_enabled`==`false`, Whether Eddystone-UID beacon is enabled",
						Default:             booldefault.StaticBool(false),
					},
					"eddystone_uid_freq_msec": schema.Int64Attribute{
						Optional:            true,
						Computed:            true,
						Description:         "Frequency (msec) of data emmit by Eddystone-UID beacon",
						MarkdownDescription: "Frequency (msec) of data emmit by Eddystone-UID beacon",
						Default:             int64default.StaticInt64(0),
					},
					"eddystone_uid_instance": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "Eddystone-UID instance for the device",
						MarkdownDescription: "Eddystone-UID instance for the device",
						Default:             stringdefault.StaticString(""),
					},
					"eddystone_uid_namespace": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "Eddystone-UID namespace",
						MarkdownDescription: "Eddystone-UID namespace",
						Default:             stringdefault.StaticString(""),
					},
					"eddystone_url_adv_power": schema.Int64Attribute{
						Optional:            true,
						Computed:            true,
						Description:         "advertised TX Power, -100 to 20 (dBm), omit this attribute to use default",
						MarkdownDescription: "advertised TX Power, -100 to 20 (dBm), omit this attribute to use default",
						Validators: []validator.Int64{
							int64validator.Between(-100, 20),
						},
						Default: int64default.StaticInt64(0),
					},
					"eddystone_url_beams": schema.StringAttribute{
						Optional: true,
						Computed: true,
						Default:  stringdefault.StaticString(""),
					},
					"eddystone_url_enabled": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "only if `beacon_enabled`==`false`, Whether Eddystone-URL beacon is enabled",
						MarkdownDescription: "only if `beacon_enabled`==`false`, Whether Eddystone-URL beacon is enabled",
						Default:             booldefault.StaticBool(false),
					},
					"eddystone_url_freq_msec": schema.Int64Attribute{
						Optional:            true,
						Computed:            true,
						Description:         "Frequency (msec) of data emit by Eddystone-UID beacon",
						MarkdownDescription: "Frequency (msec) of data emit by Eddystone-UID beacon",
						Default:             int64default.StaticInt64(0),
					},
					"eddystone_url_url": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "URL pointed by Eddystone-URL beacon",
						MarkdownDescription: "URL pointed by Eddystone-URL beacon",
						Default:             stringdefault.StaticString(""),
					},
					"ibeacon_adv_power": schema.Int64Attribute{
						Optional:            true,
						Computed:            true,
						Description:         "advertised TX Power, -100 to 20 (dBm), omit this attribute to use default",
						MarkdownDescription: "advertised TX Power, -100 to 20 (dBm), omit this attribute to use default",
						Validators: []validator.Int64{
							int64validator.Between(-100, 20),
						},
						Default: int64default.StaticInt64(0),
					},
					"ibeacon_beams": schema.StringAttribute{
						Optional: true,
						Computed: true,
						Default:  stringdefault.StaticString(""),
					},
					"ibeacon_enabled": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "can be enabled if `beacon_enabled`==`true`, whether to send iBeacon",
						MarkdownDescription: "can be enabled if `beacon_enabled`==`true`, whether to send iBeacon",
						Default:             booldefault.StaticBool(false),
					},
					"ibeacon_freq_msec": schema.Int64Attribute{
						Optional:            true,
						Computed:            true,
						Description:         "Frequency (msec) of data emmit for iBeacon",
						MarkdownDescription: "Frequency (msec) of data emmit for iBeacon",
						Default:             int64default.StaticInt64(0),
					},
					"ibeacon_major": schema.Int64Attribute{
						Optional:            true,
						Computed:            true,
						Description:         "Major number for iBeacon",
						MarkdownDescription: "Major number for iBeacon",
						Validators: []validator.Int64{
							int64validator.Between(1, 65535),
						},
						Default: int64default.StaticInt64(0),
					},
					"ibeacon_minor": schema.Int64Attribute{
						Optional:            true,
						Computed:            true,
						Description:         "Minor number for iBeacon",
						MarkdownDescription: "Minor number for iBeacon",
						Validators: []validator.Int64{
							int64validator.Between(1, 65535),
						},
						Default: int64default.StaticInt64(0),
					},
					"ibeacon_uuid": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "optional, if not specified, the same UUID as the beacon will be used",
						MarkdownDescription: "optional, if not specified, the same UUID as the beacon will be used",
						Default:             stringdefault.StaticString(""),
					},
					"power": schema.Int64Attribute{
						Optional:            true,
						Computed:            true,
						Description:         "required if `power_mode`==`custom`",
						MarkdownDescription: "required if `power_mode`==`custom`",
						Validators: []validator.Int64{
							int64validator.Between(1, 10),
						},
						Default: int64default.StaticInt64(9),
					},
					"power_mode": schema.StringAttribute{
						Optional: true,
						Computed: true,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"",
								"default",
								"custom",
							),
						},
						Default: stringdefault.StaticString("default"),
					},
				},
				CustomType: BleConfigType{
					ObjectType: types.ObjectType{
						AttrTypes: BleConfigValue{}.AttributeTypes(ctx),
					},
				},
				Optional:            true,
				Description:         "BLE AP settings",
				MarkdownDescription: "BLE AP settings",
			},
			"disable_eth1": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "whether to disable eth1 port",
				MarkdownDescription: "whether to disable eth1 port",
				Default:             booldefault.StaticBool(false),
			},
			"disable_eth2": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "whether to disable eth2 port",
				MarkdownDescription: "whether to disable eth2 port",
				Default:             booldefault.StaticBool(false),
			},
			"disable_eth3": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "whether to disable eth3 port",
				MarkdownDescription: "whether to disable eth3 port",
				Default:             booldefault.StaticBool(false),
			},
			"disable_module": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "whether to disable module port",
				MarkdownDescription: "whether to disable module port",
				Default:             booldefault.StaticBool(false),
			},
			"esl_config": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"cacert": schema.StringAttribute{
						Optional:            true,
						Description:         "Only if `type`==`imagotag` or `type`==`native`",
						MarkdownDescription: "Only if `type`==`imagotag` or `type`==`native`",
					},
					"channel": schema.Int64Attribute{
						Optional:            true,
						Description:         "Only if `type`==`imagotag` or `type`==`native`",
						MarkdownDescription: "Only if `type`==`imagotag` or `type`==`native`",
					},
					"enabled": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "usb_config is ignored if esl_config enabled",
						MarkdownDescription: "usb_config is ignored if esl_config enabled",
						Default:             booldefault.StaticBool(false),
					},
					"host": schema.StringAttribute{
						Optional:            true,
						Description:         "Only if `type`==`imagotag` or `type`==`native`",
						MarkdownDescription: "Only if `type`==`imagotag` or `type`==`native`",
					},
					"port": schema.Int64Attribute{
						Optional:            true,
						Description:         "Only if `type`==`imagotag` or `type`==`native`",
						MarkdownDescription: "Only if `type`==`imagotag` or `type`==`native`",
					},
					"type": schema.StringAttribute{
						Optional:            true,
						Description:         "note: ble_config will be ingored if esl_config is enabled and with native mode.",
						MarkdownDescription: "note: ble_config will be ingored if esl_config is enabled and with native mode.",
						Validators: []validator.String{
							stringvalidator.OneOf(
								"",
								"imagotag",
								"hanshow",
								"solum",
								"native",
							),
						},
					},
					"verify_cert": schema.BoolAttribute{
						Optional:            true,
						Description:         "Only if `type`==`imagotag` or `type`==`native`",
						MarkdownDescription: "Only if `type`==`imagotag` or `type`==`native`",
					},
					"vlan_id": schema.Int64Attribute{
						Optional:            true,
						Computed:            true,
						Description:         "Only if `type`==`solum` or `type`==`hansho`",
						MarkdownDescription: "Only if `type`==`solum` or `type`==`hansho`",
						Default:             int64default.StaticInt64(1),
					},
				},
				CustomType: EslConfigType{
					ObjectType: types.ObjectType{
						AttrTypes: EslConfigValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
			},
			"id": schema.StringAttribute{
				Computed: true,
			},
			"ip_config": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"dns": schema.ListAttribute{
						ElementType:         types.StringType,
						Optional:            true,
						Description:         "if `type`==`static`",
						MarkdownDescription: "if `type`==`static`",
					},
					"dns_suffix": schema.ListAttribute{
						ElementType:         types.StringType,
						Optional:            true,
						Description:         "required if `type`==`static`",
						MarkdownDescription: "required if `type`==`static`",
					},
					"gateway": schema.StringAttribute{
						Optional:            true,
						Description:         "required if `type`==`static`",
						MarkdownDescription: "required if `type`==`static`",
					},
					"gateway6": schema.StringAttribute{
						Optional: true,
					},
					"ip": schema.StringAttribute{
						Optional:            true,
						Description:         "required if `type`==`static`",
						MarkdownDescription: "required if `type`==`static`",
					},
					"ip6": schema.StringAttribute{
						Optional: true,
					},
					"mtu": schema.Int64Attribute{
						Optional: true,
					},
					"netmask": schema.StringAttribute{
						Optional:            true,
						Description:         "required if `type`==`static`",
						MarkdownDescription: "required if `type`==`static`",
					},
					"netmask6": schema.StringAttribute{
						Optional: true,
					},
					"type": schema.StringAttribute{
						Optional: true,
						Computed: true,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"",
								"static",
								"dhcp",
							),
						},
						Default: stringdefault.StaticString("dhcp"),
					},
					"type6": schema.StringAttribute{
						Optional: true,
						Computed: true,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"",
								"disabled",
								"static",
								"dhcp",
								"autoconf",
							),
						},
						Default: stringdefault.StaticString("disabled"),
					},
					"vlan_id": schema.Int64Attribute{
						Optional:            true,
						Computed:            true,
						Description:         "management vlan id, default is 1 (untagged)",
						MarkdownDescription: "management vlan id, default is 1 (untagged)",
						Default:             int64default.StaticInt64(1),
					},
				},
				CustomType: IpConfigType{
					ObjectType: types.ObjectType{
						AttrTypes: IpConfigValue{}.AttributeTypes(ctx),
					},
				},
				Optional:            true,
				Description:         "IP AP settings",
				MarkdownDescription: "IP AP settings",
			},
			"led": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"brightness": schema.Int64Attribute{
						Optional: true,
						Computed: true,
						Default:  int64default.StaticInt64(255),
					},
					"enabled": schema.BoolAttribute{
						Optional: true,
						Computed: true,
						Default:  booldefault.StaticBool(true),
					},
				},
				CustomType: LedType{
					ObjectType: types.ObjectType{
						AttrTypes: LedValue{}.AttributeTypes(ctx),
					},
				},
				Optional:            true,
				Description:         "LED AP settings",
				MarkdownDescription: "LED AP settings",
			},
			"mesh": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"enabled": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "whether mesh is enabled on this AP",
						MarkdownDescription: "whether mesh is enabled on this AP",
						Default:             booldefault.StaticBool(false),
					},
					"group": schema.Int64Attribute{
						Optional:            true,
						Description:         "mesh group, base AP(s) will only allow remote AP(s) in the same mesh group to join, 1-9, optional",
						MarkdownDescription: "mesh group, base AP(s) will only allow remote AP(s) in the same mesh group to join, 1-9, optional",
						Validators: []validator.Int64{
							int64validator.Between(1, 9),
						},
					},
					"role": schema.StringAttribute{
						Optional: true,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"",
								"base",
								"remote",
							),
						},
					},
				},
				CustomType: MeshType{
					ObjectType: types.ObjectType{
						AttrTypes: MeshValue{}.AttributeTypes(ctx),
					},
				},
				Optional:            true,
				Description:         "Mesh AP settings",
				MarkdownDescription: "Mesh AP settings",
			},
			"name": schema.StringAttribute{
				Required: true,
			},
			"ntp_servers": schema.ListAttribute{
				ElementType: types.StringType,
				Optional:    true,
				Validators: []validator.List{
					listvalidator.UniqueValues(),
				},
			},
			"org_id": schema.StringAttribute{
				Required: true,
			},
			"poe_passthrough": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "whether to enable power out through module port (for APH) or eth1 (for APL/BT11)",
				MarkdownDescription: "whether to enable power out through module port (for APH) or eth1 (for APL/BT11)",
				Default:             booldefault.StaticBool(false),
			},
			"pwr_config": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"base": schema.Int64Attribute{
						Optional:            true,
						Computed:            true,
						Description:         "additional power to request during negotiating with PSE over PoE, in mW",
						MarkdownDescription: "additional power to request during negotiating with PSE over PoE, in mW",
						Default:             int64default.StaticInt64(0),
					},
					"prefer_usb_over_wifi": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "whether to enable power out to peripheral, meanwhile will reduce power to wifi (only for AP45 at power mode)",
						MarkdownDescription: "whether to enable power out to peripheral, meanwhile will reduce power to wifi (only for AP45 at power mode)",
						Default:             booldefault.StaticBool(false),
					},
				},
				CustomType: PwrConfigType{
					ObjectType: types.ObjectType{
						AttrTypes: PwrConfigValue{}.AttributeTypes(ctx),
					},
				},
				Optional:            true,
				Description:         "power related configs",
				MarkdownDescription: "power related configs",
			},
			"radio_config": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"allow_rrm_disable": schema.BoolAttribute{
						Optional: true,
						Computed: true,
						Default:  booldefault.StaticBool(false),
					},
					"ant_gain_24": schema.Int64Attribute{
						Optional:            true,
						Description:         "antenna gain for 2.4G - for models with external antenna only",
						MarkdownDescription: "antenna gain for 2.4G - for models with external antenna only",
						Validators: []validator.Int64{
							int64validator.AtLeast(0),
						},
					},
					"ant_gain_5": schema.Int64Attribute{
						Optional:            true,
						Description:         "antenna gain for 5G - for models with external antenna only",
						MarkdownDescription: "antenna gain for 5G - for models with external antenna only",
						Validators: []validator.Int64{
							int64validator.AtLeast(0),
						},
					},
					"ant_gain_6": schema.Int64Attribute{
						Optional:            true,
						Description:         "antenna gain for 6G - for models with external antenna only",
						MarkdownDescription: "antenna gain for 6G - for models with external antenna only",
						Validators: []validator.Int64{
							int64validator.AtLeast(0),
						},
					},
					"antenna_mode": schema.StringAttribute{
						Optional: true,
						Computed: true,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"",
								"default",
								"1x1",
								"2x2",
								"3x3",
								"4x4",
							),
						},
						Default: stringdefault.StaticString("default"),
					},
					"band_24": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"allow_rrm_disable": schema.BoolAttribute{
								Optional: true,
								Computed: true,
								Default:  booldefault.StaticBool(false),
							},
							"ant_gain": schema.Int64Attribute{
								Optional: true,
								Computed: true,
								Validators: []validator.Int64{
									int64validator.Between(0, 10),
								},
								Default: int64default.StaticInt64(0),
							},
							"antenna_mode": schema.StringAttribute{
								Optional: true,
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"",
										"default",
										"1x1",
										"2x2",
										"3x3",
										"4x4",
									),
								},
								Default: stringdefault.StaticString("default"),
							},
							"bandwidth": schema.Int64Attribute{
								Optional:            true,
								Computed:            true,
								Description:         "channel width for the 2.4GHz band",
								MarkdownDescription: "channel width for the 2.4GHz band",
								Validators: []validator.Int64{
									int64validator.OneOf(
										20,
										40,
									),
								},
								Default: int64default.StaticInt64(20),
							},
							"channel": schema.Int64Attribute{
								Optional:            true,
								Computed:            true,
								Description:         "For Device. (primary) channel for the band, 0 means using the Site Setting",
								MarkdownDescription: "For Device. (primary) channel for the band, 0 means using the Site Setting",
								Validators: []validator.Int64{
									int64validator.Between(1, 13),
								},
								Default: int64default.StaticInt64(0),
							},
							"channels": schema.ListAttribute{
								ElementType:         types.Int64Type,
								Optional:            true,
								Description:         "For RFTemplates. List of channels, null or empty array means auto",
								MarkdownDescription: "For RFTemplates. List of channels, null or empty array means auto",
							},
							"disabled": schema.BoolAttribute{
								Optional:            true,
								Computed:            true,
								Description:         "whether to disable the radio",
								MarkdownDescription: "whether to disable the radio",
								Default:             booldefault.StaticBool(false),
							},
							"power": schema.Int64Attribute{
								Optional:            true,
								Computed:            true,
								Description:         "TX power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / …: treated as 0 / -1 / -2 / …",
								MarkdownDescription: "TX power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / …: treated as 0 / -1 / -2 / …",
								Validators: []validator.Int64{
									int64validator.Between(3, 25),
								},
								Default: int64default.StaticInt64(0),
							},
							"power_max": schema.Int64Attribute{
								Optional:            true,
								Computed:            true,
								Description:         "when power=0, max tx power to use, HW-specific values will be used if not set",
								MarkdownDescription: "when power=0, max tx power to use, HW-specific values will be used if not set",
								Validators: []validator.Int64{
									int64validator.Between(3, 18),
								},
								Default: int64default.StaticInt64(17),
							},
							"power_min": schema.Int64Attribute{
								Optional:            true,
								Computed:            true,
								Description:         "when power=0, min tx power to use, HW-specific values will be used if not set",
								MarkdownDescription: "when power=0, min tx power to use, HW-specific values will be used if not set",
								Validators: []validator.Int64{
									int64validator.Between(3, 18),
								},
								Default: int64default.StaticInt64(8),
							},
							"preamble": schema.StringAttribute{
								Optional: true,
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"",
										"short",
										"long",
										"auto",
									),
								},
								Default: stringdefault.StaticString("short"),
							},
						},
						CustomType: Band24Type{
							ObjectType: types.ObjectType{
								AttrTypes: Band24Value{}.AttributeTypes(ctx),
							},
						},
						Optional:            true,
						Description:         "Radio Band AP settings",
						MarkdownDescription: "Radio Band AP settings",
					},
					"band_24_usage": schema.StringAttribute{
						Optional: true,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"",
								"24",
								"5",
								"6",
								"auto",
							),
						},
					},
					"band_5": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"allow_rrm_disable": schema.BoolAttribute{
								Optional: true,
								Computed: true,
								Default:  booldefault.StaticBool(false),
							},
							"ant_gain": schema.Int64Attribute{
								Optional: true,
								Computed: true,
								Validators: []validator.Int64{
									int64validator.Between(0, 10),
								},
								Default: int64default.StaticInt64(0),
							},
							"antenna_mode": schema.StringAttribute{
								Optional: true,
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"",
										"default",
										"1x1",
										"2x2",
										"3x3",
										"4x4",
									),
								},
								Default: stringdefault.StaticString("default"),
							},
							"bandwidth": schema.Int64Attribute{
								Optional:            true,
								Description:         "channel width for the 5GHz band",
								MarkdownDescription: "channel width for the 5GHz band",
								Validators: []validator.Int64{
									int64validator.OneOf(
										20,
										40,
										80,
									),
								},
							},
							"channel": schema.Int64Attribute{
								Optional:            true,
								Computed:            true,
								Description:         "For Device. (primary) channel for the band, 0 means using the Site Setting",
								MarkdownDescription: "For Device. (primary) channel for the band, 0 means using the Site Setting",
								Default:             int64default.StaticInt64(0),
							},
							"channels": schema.ListAttribute{
								ElementType:         types.Int64Type,
								Optional:            true,
								Description:         "For RFTemplates. List of channels, null or empty array means auto",
								MarkdownDescription: "For RFTemplates. List of channels, null or empty array means auto",
							},
							"disabled": schema.BoolAttribute{
								Optional:            true,
								Computed:            true,
								Description:         "whether to disable the radio",
								MarkdownDescription: "whether to disable the radio",
								Default:             booldefault.StaticBool(false),
							},
							"power": schema.Int64Attribute{
								Optional:            true,
								Computed:            true,
								Description:         "TX power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / …: treated as 0 / -1 / -2 / …",
								MarkdownDescription: "TX power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / …: treated as 0 / -1 / -2 / …",
								Validators: []validator.Int64{
									int64validator.Between(5, 25),
								},
								Default: int64default.StaticInt64(0),
							},
							"power_max": schema.Int64Attribute{
								Optional:            true,
								Computed:            true,
								Description:         "when power=0, max tx power to use, HW-specific values will be used if not set",
								MarkdownDescription: "when power=0, max tx power to use, HW-specific values will be used if not set",
								Validators: []validator.Int64{
									int64validator.Between(5, 17),
								},
								Default: int64default.StaticInt64(17),
							},
							"power_min": schema.Int64Attribute{
								Optional:            true,
								Computed:            true,
								Description:         "when power=0, min tx power to use, HW-specific values will be used if not set",
								MarkdownDescription: "when power=0, min tx power to use, HW-specific values will be used if not set",
								Validators: []validator.Int64{
									int64validator.Between(5, 17),
								},
								Default: int64default.StaticInt64(8),
							},
							"preamble": schema.StringAttribute{
								Optional: true,
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"",
										"short",
										"long",
										"auto",
									),
								},
								Default: stringdefault.StaticString("short"),
							},
						},
						CustomType: Band5Type{
							ObjectType: types.ObjectType{
								AttrTypes: Band5Value{}.AttributeTypes(ctx),
							},
						},
						Optional:            true,
						Description:         "Radio Band AP settings",
						MarkdownDescription: "Radio Band AP settings",
					},
					"band_5_on_24_radio": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"allow_rrm_disable": schema.BoolAttribute{
								Optional: true,
								Computed: true,
								Default:  booldefault.StaticBool(false),
							},
							"ant_gain": schema.Int64Attribute{
								Optional: true,
								Computed: true,
								Validators: []validator.Int64{
									int64validator.Between(0, 10),
								},
								Default: int64default.StaticInt64(0),
							},
							"antenna_mode": schema.StringAttribute{
								Optional: true,
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"",
										"default",
										"1x1",
										"2x2",
										"3x3",
										"4x4",
									),
								},
								Default: stringdefault.StaticString("default"),
							},
							"bandwidth": schema.Int64Attribute{
								Optional:            true,
								Description:         "channel width for the 5GHz band",
								MarkdownDescription: "channel width for the 5GHz band",
								Validators: []validator.Int64{
									int64validator.OneOf(
										20,
										40,
										80,
									),
								},
							},
							"channel": schema.Int64Attribute{
								Optional:            true,
								Computed:            true,
								Description:         "For Device. (primary) channel for the band, 0 means using the Site Setting",
								MarkdownDescription: "For Device. (primary) channel for the band, 0 means using the Site Setting",
								Default:             int64default.StaticInt64(0),
							},
							"channels": schema.ListAttribute{
								ElementType:         types.Int64Type,
								Optional:            true,
								Description:         "For RFTemplates. List of channels, null or empty array means auto",
								MarkdownDescription: "For RFTemplates. List of channels, null or empty array means auto",
							},
							"disabled": schema.BoolAttribute{
								Optional:            true,
								Computed:            true,
								Description:         "whether to disable the radio",
								MarkdownDescription: "whether to disable the radio",
								Default:             booldefault.StaticBool(false),
							},
							"power": schema.Int64Attribute{
								Optional:            true,
								Computed:            true,
								Description:         "TX power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / …: treated as 0 / -1 / -2 / …",
								MarkdownDescription: "TX power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / …: treated as 0 / -1 / -2 / …",
								Validators: []validator.Int64{
									int64validator.Between(5, 25),
								},
								Default: int64default.StaticInt64(0),
							},
							"power_max": schema.Int64Attribute{
								Optional:            true,
								Computed:            true,
								Description:         "when power=0, max tx power to use, HW-specific values will be used if not set",
								MarkdownDescription: "when power=0, max tx power to use, HW-specific values will be used if not set",
								Validators: []validator.Int64{
									int64validator.Between(5, 17),
								},
								Default: int64default.StaticInt64(17),
							},
							"power_min": schema.Int64Attribute{
								Optional:            true,
								Computed:            true,
								Description:         "when power=0, min tx power to use, HW-specific values will be used if not set",
								MarkdownDescription: "when power=0, min tx power to use, HW-specific values will be used if not set",
								Validators: []validator.Int64{
									int64validator.Between(5, 17),
								},
								Default: int64default.StaticInt64(8),
							},
							"preamble": schema.StringAttribute{
								Optional: true,
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"",
										"short",
										"long",
										"auto",
									),
								},
								Default: stringdefault.StaticString("short"),
							},
						},
						CustomType: Band5On24RadioType{
							ObjectType: types.ObjectType{
								AttrTypes: Band5On24RadioValue{}.AttributeTypes(ctx),
							},
						},
						Optional:            true,
						Description:         "Radio Band AP settings",
						MarkdownDescription: "Radio Band AP settings",
					},
					"band_6": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"allow_rrm_disable": schema.BoolAttribute{
								Optional: true,
								Computed: true,
								Default:  booldefault.StaticBool(false),
							},
							"ant_gain": schema.Int64Attribute{
								Optional: true,
								Computed: true,
								Validators: []validator.Int64{
									int64validator.Between(0, 10),
								},
								Default: int64default.StaticInt64(0),
							},
							"antenna_mode": schema.StringAttribute{
								Optional: true,
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"",
										"default",
										"1x1",
										"2x2",
										"3x3",
										"4x4",
									),
								},
								Default: stringdefault.StaticString("default"),
							},
							"bandwidth": schema.Int64Attribute{
								Optional:            true,
								Computed:            true,
								Description:         "channel width for the 6GHz band",
								MarkdownDescription: "channel width for the 6GHz band",
								Validators: []validator.Int64{
									int64validator.OneOf(
										20,
										40,
										80,
										160,
									),
								},
								Default: int64default.StaticInt64(80),
							},
							"channel": schema.Int64Attribute{
								Optional:            true,
								Computed:            true,
								Description:         "For Device. (primary) channel for the band, 0 means using the Site Setting",
								MarkdownDescription: "For Device. (primary) channel for the band, 0 means using the Site Setting",
								Default:             int64default.StaticInt64(0),
							},
							"channels": schema.ListAttribute{
								ElementType:         types.Int64Type,
								Optional:            true,
								Description:         "For RFTemplates. List of channels, null or empty array means auto",
								MarkdownDescription: "For RFTemplates. List of channels, null or empty array means auto",
							},
							"disabled": schema.BoolAttribute{
								Optional:            true,
								Computed:            true,
								Description:         "whether to disable the radio",
								MarkdownDescription: "whether to disable the radio",
								Default:             booldefault.StaticBool(false),
							},
							"power": schema.Int64Attribute{
								Optional:            true,
								Computed:            true,
								Description:         "TX power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / …: treated as 0 / -1 / -2 / …",
								MarkdownDescription: "TX power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / …: treated as 0 / -1 / -2 / …",
								Validators: []validator.Int64{
									int64validator.Between(5, 25),
								},
								Default: int64default.StaticInt64(0),
							},
							"power_max": schema.Int64Attribute{
								Optional:            true,
								Computed:            true,
								Description:         "when power=0, max tx power to use, HW-specific values will be used if not set",
								MarkdownDescription: "when power=0, max tx power to use, HW-specific values will be used if not set",
								Validators: []validator.Int64{
									int64validator.Between(5, 18),
								},
								Default: int64default.StaticInt64(18),
							},
							"power_min": schema.Int64Attribute{
								Optional:            true,
								Computed:            true,
								Description:         "when power=0, min tx power to use, HW-specific values will be used if not set",
								MarkdownDescription: "when power=0, min tx power to use, HW-specific values will be used if not set",
								Validators: []validator.Int64{
									int64validator.Between(5, 18),
								},
								Default: int64default.StaticInt64(8),
							},
							"preamble": schema.StringAttribute{
								Optional: true,
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"",
										"short",
										"long",
										"auto",
									),
								},
								Default: stringdefault.StaticString("short"),
							},
							"standard_power": schema.BoolAttribute{
								Optional:            true,
								Computed:            true,
								Description:         "for 6GHz Only, standard-power operation, AFC (Automatic Frequency Coordination) will be performed and we'll fallback to Low Power Indoor if AFC failed",
								MarkdownDescription: "for 6GHz Only, standard-power operation, AFC (Automatic Frequency Coordination) will be performed and we'll fallback to Low Power Indoor if AFC failed",
								Default:             booldefault.StaticBool(false),
							},
						},
						CustomType: Band6Type{
							ObjectType: types.ObjectType{
								AttrTypes: Band6Value{}.AttributeTypes(ctx),
							},
						},
						Optional:            true,
						Description:         "Radio Band AP settings",
						MarkdownDescription: "Radio Band AP settings",
					},
					"indoor_use": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "to make an outdoor operate indoor.\nfor an outdoor-ap, some channels are disallowed by default, this allows the user to use it as an indoor-ap",
						MarkdownDescription: "to make an outdoor operate indoor.\nfor an outdoor-ap, some channels are disallowed by default, this allows the user to use it as an indoor-ap",
						Default:             booldefault.StaticBool(false),
					},
					"scanning_enabled": schema.BoolAttribute{
						Optional:            true,
						Description:         "whether scanning radio is enabled",
						MarkdownDescription: "whether scanning radio is enabled",
					},
				},
				CustomType: RadioConfigType{
					ObjectType: types.ObjectType{
						AttrTypes: RadioConfigValue{}.AttributeTypes(ctx),
					},
				},
				Optional:            true,
				Description:         "Radio AP settings",
				MarkdownDescription: "Radio AP settings",
			},
			"site_id": schema.StringAttribute{
				Optional: true,
			},
			"type": schema.StringAttribute{
				Computed:            true,
				Description:         "Device Type",
				MarkdownDescription: "Device Type",
				Validators: []validator.String{
					stringvalidator.OneOf(
						"",
						"ap",
					),
				},
			},
			"uplink_port_config": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"dot1x": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "Whether to do 802.1x against uplink switch. When enaled, AP cert will be used to do EAP-TLS and the Org's CA Cert has to be provisioned at the switch",
						MarkdownDescription: "Whether to do 802.1x against uplink switch. When enaled, AP cert will be used to do EAP-TLS and the Org's CA Cert has to be provisioned at the switch",
						Default:             booldefault.StaticBool(false),
					},
					"keep_wlans_up_if_down": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "by default, WLANs are disabled when uplink is down. In some scenario, like SiteSurvey, one would want the AP to keep sending beacons.",
						MarkdownDescription: "by default, WLANs are disabled when uplink is down. In some scenario, like SiteSurvey, one would want the AP to keep sending beacons.",
						Default:             booldefault.StaticBool(false),
					},
				},
				CustomType: UplinkPortConfigType{
					ObjectType: types.ObjectType{
						AttrTypes: UplinkPortConfigValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
			},
			"usb_config": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"cacert": schema.StringAttribute{
						Optional:            true,
						Description:         "only if `type`==`imagotag`",
						MarkdownDescription: "only if `type`==`imagotag`",
					},
					"channel": schema.Int64Attribute{
						Optional:            true,
						Description:         "only if `type`==`imagotag`\nchannel selection, not needed by default, required for manual channel override only",
						MarkdownDescription: "only if `type`==`imagotag`\nchannel selection, not needed by default, required for manual channel override only",
					},
					"enabled": schema.BoolAttribute{
						Optional:            true,
						Description:         "whether to enable any usb config",
						MarkdownDescription: "whether to enable any usb config",
					},
					"host": schema.StringAttribute{
						Optional:            true,
						Description:         "only if `type`==`imagotag`",
						MarkdownDescription: "only if `type`==`imagotag`",
					},
					"port": schema.Int64Attribute{
						Optional:            true,
						Computed:            true,
						Description:         "only if `type`==`imagotag`",
						MarkdownDescription: "only if `type`==`imagotag`",
						Default:             int64default.StaticInt64(0),
					},
					"type": schema.StringAttribute{
						Optional:            true,
						Description:         "usb config type",
						MarkdownDescription: "usb config type",
						Validators: []validator.String{
							stringvalidator.OneOf(
								"",
								"imagotag",
								"solum",
								"hanshow",
							),
						},
					},
					"verify_cert": schema.BoolAttribute{
						Optional:            true,
						Description:         "only if `type`==`imagotag`, whether to turn on SSL verification",
						MarkdownDescription: "only if `type`==`imagotag`, whether to turn on SSL verification",
					},
					"vlan_id": schema.Int64Attribute{
						Optional:            true,
						Computed:            true,
						Description:         "only if `type`==`solum` or `type`==`hanshow`",
						MarkdownDescription: "only if `type`==`solum` or `type`==`hanshow`",
						Default:             int64default.StaticInt64(1),
					},
				},
				CustomType: UsbConfigType{
					ObjectType: types.ObjectType{
						AttrTypes: UsbConfigValue{}.AttributeTypes(ctx),
					},
				},
				Optional:            true,
				Description:         "USB AP settings\nNote: if native imagotag is enabled, BLE will be disabled automatically\nNote: legacy, new config moved to ESL Config.",
				MarkdownDescription: "USB AP settings\nNote: if native imagotag is enabled, BLE will be disabled automatically\nNote: legacy, new config moved to ESL Config.",
			},
			"vars": schema.MapAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Description:         "a dictionary of name->value, the vars can then be used in Wlans. This can overwrite those from Site Vars",
				MarkdownDescription: "a dictionary of name->value, the vars can then be used in Wlans. This can overwrite those from Site Vars",
			},
		},
	}
}

type OrgDeviceprofileApModel struct {
	Aeroscout        AeroscoutValue        `tfsdk:"aeroscout"`
	BleConfig        BleConfigValue        `tfsdk:"ble_config"`
	DisableEth1      types.Bool            `tfsdk:"disable_eth1"`
	DisableEth2      types.Bool            `tfsdk:"disable_eth2"`
	DisableEth3      types.Bool            `tfsdk:"disable_eth3"`
	DisableModule    types.Bool            `tfsdk:"disable_module"`
	EslConfig        EslConfigValue        `tfsdk:"esl_config"`
	Id               types.String          `tfsdk:"id"`
	IpConfig         IpConfigValue         `tfsdk:"ip_config"`
	Led              LedValue              `tfsdk:"led"`
	Mesh             MeshValue             `tfsdk:"mesh"`
	Name             types.String          `tfsdk:"name"`
	NtpServers       types.List            `tfsdk:"ntp_servers"`
	OrgId            types.String          `tfsdk:"org_id"`
	PoePassthrough   types.Bool            `tfsdk:"poe_passthrough"`
	PwrConfig        PwrConfigValue        `tfsdk:"pwr_config"`
	RadioConfig      RadioConfigValue      `tfsdk:"radio_config"`
	SiteId           types.String          `tfsdk:"site_id"`
	Type             types.String          `tfsdk:"type"`
	UplinkPortConfig UplinkPortConfigValue `tfsdk:"uplink_port_config"`
	UsbConfig        UsbConfigValue        `tfsdk:"usb_config"`
	Vars             types.Map             `tfsdk:"vars"`
}

var _ basetypes.ObjectTypable = AeroscoutType{}

type AeroscoutType struct {
	basetypes.ObjectType
}

func (t AeroscoutType) Equal(o attr.Type) bool {
	other, ok := o.(AeroscoutType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AeroscoutType) String() string {
	return "AeroscoutType"
}

func (t AeroscoutType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	hostAttribute, ok := attributes["host"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`host is missing from object`)

		return nil, diags
	}

	hostVal, ok := hostAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`host expected to be basetypes.StringValue, was: %T`, hostAttribute))
	}

	locateConnectedAttribute, ok := attributes["locate_connected"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`locate_connected is missing from object`)

		return nil, diags
	}

	locateConnectedVal, ok := locateConnectedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`locate_connected expected to be basetypes.BoolValue, was: %T`, locateConnectedAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AeroscoutValue{
		Enabled:         enabledVal,
		Host:            hostVal,
		LocateConnected: locateConnectedVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewAeroscoutValueNull() AeroscoutValue {
	return AeroscoutValue{
		state: attr.ValueStateNull,
	}
}

func NewAeroscoutValueUnknown() AeroscoutValue {
	return AeroscoutValue{
		state: attr.ValueStateUnknown,
	}
}

func NewAeroscoutValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AeroscoutValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AeroscoutValue Attribute Value",
				"While creating a AeroscoutValue value, a missing attribute value was detected. "+
					"A AeroscoutValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AeroscoutValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AeroscoutValue Attribute Type",
				"While creating a AeroscoutValue value, an invalid attribute value was detected. "+
					"A AeroscoutValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AeroscoutValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AeroscoutValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AeroscoutValue Attribute Value",
				"While creating a AeroscoutValue value, an extra attribute value was detected. "+
					"A AeroscoutValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AeroscoutValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAeroscoutValueUnknown(), diags
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewAeroscoutValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	hostAttribute, ok := attributes["host"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`host is missing from object`)

		return NewAeroscoutValueUnknown(), diags
	}

	hostVal, ok := hostAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`host expected to be basetypes.StringValue, was: %T`, hostAttribute))
	}

	locateConnectedAttribute, ok := attributes["locate_connected"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`locate_connected is missing from object`)

		return NewAeroscoutValueUnknown(), diags
	}

	locateConnectedVal, ok := locateConnectedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`locate_connected expected to be basetypes.BoolValue, was: %T`, locateConnectedAttribute))
	}

	if diags.HasError() {
		return NewAeroscoutValueUnknown(), diags
	}

	return AeroscoutValue{
		Enabled:         enabledVal,
		Host:            hostVal,
		LocateConnected: locateConnectedVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewAeroscoutValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AeroscoutValue {
	object, diags := NewAeroscoutValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAeroscoutValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AeroscoutType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAeroscoutValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAeroscoutValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAeroscoutValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAeroscoutValueMust(AeroscoutValue{}.AttributeTypes(ctx), attributes), nil
}

func (t AeroscoutType) ValueType(ctx context.Context) attr.Value {
	return AeroscoutValue{}
}

var _ basetypes.ObjectValuable = AeroscoutValue{}

type AeroscoutValue struct {
	Enabled         basetypes.BoolValue   `tfsdk:"enabled"`
	Host            basetypes.StringValue `tfsdk:"host"`
	LocateConnected basetypes.BoolValue   `tfsdk:"locate_connected"`
	state           attr.ValueState
}

func (v AeroscoutValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["host"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["locate_connected"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.Host.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["host"] = val

		val, err = v.LocateConnected.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["locate_connected"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AeroscoutValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AeroscoutValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AeroscoutValue) String() string {
	return "AeroscoutValue"
}

func (v AeroscoutValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"enabled":          basetypes.BoolType{},
		"host":             basetypes.StringType{},
		"locate_connected": basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"enabled":          v.Enabled,
			"host":             v.Host,
			"locate_connected": v.LocateConnected,
		})

	return objVal, diags
}

func (v AeroscoutValue) Equal(o attr.Value) bool {
	other, ok := o.(AeroscoutValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.Host.Equal(other.Host) {
		return false
	}

	if !v.LocateConnected.Equal(other.LocateConnected) {
		return false
	}

	return true
}

func (v AeroscoutValue) Type(ctx context.Context) attr.Type {
	return AeroscoutType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AeroscoutValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"enabled":          basetypes.BoolType{},
		"host":             basetypes.StringType{},
		"locate_connected": basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = BleConfigType{}

type BleConfigType struct {
	basetypes.ObjectType
}

func (t BleConfigType) Equal(o attr.Type) bool {
	other, ok := o.(BleConfigType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t BleConfigType) String() string {
	return "BleConfigType"
}

func (t BleConfigType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	beaconEnabledAttribute, ok := attributes["beacon_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`beacon_enabled is missing from object`)

		return nil, diags
	}

	beaconEnabledVal, ok := beaconEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`beacon_enabled expected to be basetypes.BoolValue, was: %T`, beaconEnabledAttribute))
	}

	beaconRateAttribute, ok := attributes["beacon_rate"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`beacon_rate is missing from object`)

		return nil, diags
	}

	beaconRateVal, ok := beaconRateAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`beacon_rate expected to be basetypes.Int64Value, was: %T`, beaconRateAttribute))
	}

	beaconRateModeAttribute, ok := attributes["beacon_rate_mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`beacon_rate_mode is missing from object`)

		return nil, diags
	}

	beaconRateModeVal, ok := beaconRateModeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`beacon_rate_mode expected to be basetypes.StringValue, was: %T`, beaconRateModeAttribute))
	}

	beamDisabledAttribute, ok := attributes["beam_disabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`beam_disabled is missing from object`)

		return nil, diags
	}

	beamDisabledVal, ok := beamDisabledAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`beam_disabled expected to be basetypes.ListValue, was: %T`, beamDisabledAttribute))
	}

	customBlePacketEnabledAttribute, ok := attributes["custom_ble_packet_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`custom_ble_packet_enabled is missing from object`)

		return nil, diags
	}

	customBlePacketEnabledVal, ok := customBlePacketEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`custom_ble_packet_enabled expected to be basetypes.BoolValue, was: %T`, customBlePacketEnabledAttribute))
	}

	customBlePacketFrameAttribute, ok := attributes["custom_ble_packet_frame"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`custom_ble_packet_frame is missing from object`)

		return nil, diags
	}

	customBlePacketFrameVal, ok := customBlePacketFrameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`custom_ble_packet_frame expected to be basetypes.StringValue, was: %T`, customBlePacketFrameAttribute))
	}

	customBlePacketFreqMsecAttribute, ok := attributes["custom_ble_packet_freq_msec"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`custom_ble_packet_freq_msec is missing from object`)

		return nil, diags
	}

	customBlePacketFreqMsecVal, ok := customBlePacketFreqMsecAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`custom_ble_packet_freq_msec expected to be basetypes.Int64Value, was: %T`, customBlePacketFreqMsecAttribute))
	}

	eddystoneUidAdvPowerAttribute, ok := attributes["eddystone_uid_adv_power"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`eddystone_uid_adv_power is missing from object`)

		return nil, diags
	}

	eddystoneUidAdvPowerVal, ok := eddystoneUidAdvPowerAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`eddystone_uid_adv_power expected to be basetypes.Int64Value, was: %T`, eddystoneUidAdvPowerAttribute))
	}

	eddystoneUidBeamsAttribute, ok := attributes["eddystone_uid_beams"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`eddystone_uid_beams is missing from object`)

		return nil, diags
	}

	eddystoneUidBeamsVal, ok := eddystoneUidBeamsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`eddystone_uid_beams expected to be basetypes.StringValue, was: %T`, eddystoneUidBeamsAttribute))
	}

	eddystoneUidEnabledAttribute, ok := attributes["eddystone_uid_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`eddystone_uid_enabled is missing from object`)

		return nil, diags
	}

	eddystoneUidEnabledVal, ok := eddystoneUidEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`eddystone_uid_enabled expected to be basetypes.BoolValue, was: %T`, eddystoneUidEnabledAttribute))
	}

	eddystoneUidFreqMsecAttribute, ok := attributes["eddystone_uid_freq_msec"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`eddystone_uid_freq_msec is missing from object`)

		return nil, diags
	}

	eddystoneUidFreqMsecVal, ok := eddystoneUidFreqMsecAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`eddystone_uid_freq_msec expected to be basetypes.Int64Value, was: %T`, eddystoneUidFreqMsecAttribute))
	}

	eddystoneUidInstanceAttribute, ok := attributes["eddystone_uid_instance"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`eddystone_uid_instance is missing from object`)

		return nil, diags
	}

	eddystoneUidInstanceVal, ok := eddystoneUidInstanceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`eddystone_uid_instance expected to be basetypes.StringValue, was: %T`, eddystoneUidInstanceAttribute))
	}

	eddystoneUidNamespaceAttribute, ok := attributes["eddystone_uid_namespace"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`eddystone_uid_namespace is missing from object`)

		return nil, diags
	}

	eddystoneUidNamespaceVal, ok := eddystoneUidNamespaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`eddystone_uid_namespace expected to be basetypes.StringValue, was: %T`, eddystoneUidNamespaceAttribute))
	}

	eddystoneUrlAdvPowerAttribute, ok := attributes["eddystone_url_adv_power"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`eddystone_url_adv_power is missing from object`)

		return nil, diags
	}

	eddystoneUrlAdvPowerVal, ok := eddystoneUrlAdvPowerAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`eddystone_url_adv_power expected to be basetypes.Int64Value, was: %T`, eddystoneUrlAdvPowerAttribute))
	}

	eddystoneUrlBeamsAttribute, ok := attributes["eddystone_url_beams"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`eddystone_url_beams is missing from object`)

		return nil, diags
	}

	eddystoneUrlBeamsVal, ok := eddystoneUrlBeamsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`eddystone_url_beams expected to be basetypes.StringValue, was: %T`, eddystoneUrlBeamsAttribute))
	}

	eddystoneUrlEnabledAttribute, ok := attributes["eddystone_url_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`eddystone_url_enabled is missing from object`)

		return nil, diags
	}

	eddystoneUrlEnabledVal, ok := eddystoneUrlEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`eddystone_url_enabled expected to be basetypes.BoolValue, was: %T`, eddystoneUrlEnabledAttribute))
	}

	eddystoneUrlFreqMsecAttribute, ok := attributes["eddystone_url_freq_msec"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`eddystone_url_freq_msec is missing from object`)

		return nil, diags
	}

	eddystoneUrlFreqMsecVal, ok := eddystoneUrlFreqMsecAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`eddystone_url_freq_msec expected to be basetypes.Int64Value, was: %T`, eddystoneUrlFreqMsecAttribute))
	}

	eddystoneUrlUrlAttribute, ok := attributes["eddystone_url_url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`eddystone_url_url is missing from object`)

		return nil, diags
	}

	eddystoneUrlUrlVal, ok := eddystoneUrlUrlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`eddystone_url_url expected to be basetypes.StringValue, was: %T`, eddystoneUrlUrlAttribute))
	}

	ibeaconAdvPowerAttribute, ok := attributes["ibeacon_adv_power"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ibeacon_adv_power is missing from object`)

		return nil, diags
	}

	ibeaconAdvPowerVal, ok := ibeaconAdvPowerAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ibeacon_adv_power expected to be basetypes.Int64Value, was: %T`, ibeaconAdvPowerAttribute))
	}

	ibeaconBeamsAttribute, ok := attributes["ibeacon_beams"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ibeacon_beams is missing from object`)

		return nil, diags
	}

	ibeaconBeamsVal, ok := ibeaconBeamsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ibeacon_beams expected to be basetypes.StringValue, was: %T`, ibeaconBeamsAttribute))
	}

	ibeaconEnabledAttribute, ok := attributes["ibeacon_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ibeacon_enabled is missing from object`)

		return nil, diags
	}

	ibeaconEnabledVal, ok := ibeaconEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ibeacon_enabled expected to be basetypes.BoolValue, was: %T`, ibeaconEnabledAttribute))
	}

	ibeaconFreqMsecAttribute, ok := attributes["ibeacon_freq_msec"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ibeacon_freq_msec is missing from object`)

		return nil, diags
	}

	ibeaconFreqMsecVal, ok := ibeaconFreqMsecAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ibeacon_freq_msec expected to be basetypes.Int64Value, was: %T`, ibeaconFreqMsecAttribute))
	}

	ibeaconMajorAttribute, ok := attributes["ibeacon_major"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ibeacon_major is missing from object`)

		return nil, diags
	}

	ibeaconMajorVal, ok := ibeaconMajorAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ibeacon_major expected to be basetypes.Int64Value, was: %T`, ibeaconMajorAttribute))
	}

	ibeaconMinorAttribute, ok := attributes["ibeacon_minor"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ibeacon_minor is missing from object`)

		return nil, diags
	}

	ibeaconMinorVal, ok := ibeaconMinorAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ibeacon_minor expected to be basetypes.Int64Value, was: %T`, ibeaconMinorAttribute))
	}

	ibeaconUuidAttribute, ok := attributes["ibeacon_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ibeacon_uuid is missing from object`)

		return nil, diags
	}

	ibeaconUuidVal, ok := ibeaconUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ibeacon_uuid expected to be basetypes.StringValue, was: %T`, ibeaconUuidAttribute))
	}

	powerAttribute, ok := attributes["power"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`power is missing from object`)

		return nil, diags
	}

	powerVal, ok := powerAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`power expected to be basetypes.Int64Value, was: %T`, powerAttribute))
	}

	powerModeAttribute, ok := attributes["power_mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`power_mode is missing from object`)

		return nil, diags
	}

	powerModeVal, ok := powerModeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`power_mode expected to be basetypes.StringValue, was: %T`, powerModeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return BleConfigValue{
		BeaconEnabled:           beaconEnabledVal,
		BeaconRate:              beaconRateVal,
		BeaconRateMode:          beaconRateModeVal,
		BeamDisabled:            beamDisabledVal,
		CustomBlePacketEnabled:  customBlePacketEnabledVal,
		CustomBlePacketFrame:    customBlePacketFrameVal,
		CustomBlePacketFreqMsec: customBlePacketFreqMsecVal,
		EddystoneUidAdvPower:    eddystoneUidAdvPowerVal,
		EddystoneUidBeams:       eddystoneUidBeamsVal,
		EddystoneUidEnabled:     eddystoneUidEnabledVal,
		EddystoneUidFreqMsec:    eddystoneUidFreqMsecVal,
		EddystoneUidInstance:    eddystoneUidInstanceVal,
		EddystoneUidNamespace:   eddystoneUidNamespaceVal,
		EddystoneUrlAdvPower:    eddystoneUrlAdvPowerVal,
		EddystoneUrlBeams:       eddystoneUrlBeamsVal,
		EddystoneUrlEnabled:     eddystoneUrlEnabledVal,
		EddystoneUrlFreqMsec:    eddystoneUrlFreqMsecVal,
		EddystoneUrlUrl:         eddystoneUrlUrlVal,
		IbeaconAdvPower:         ibeaconAdvPowerVal,
		IbeaconBeams:            ibeaconBeamsVal,
		IbeaconEnabled:          ibeaconEnabledVal,
		IbeaconFreqMsec:         ibeaconFreqMsecVal,
		IbeaconMajor:            ibeaconMajorVal,
		IbeaconMinor:            ibeaconMinorVal,
		IbeaconUuid:             ibeaconUuidVal,
		Power:                   powerVal,
		PowerMode:               powerModeVal,
		state:                   attr.ValueStateKnown,
	}, diags
}

func NewBleConfigValueNull() BleConfigValue {
	return BleConfigValue{
		state: attr.ValueStateNull,
	}
}

func NewBleConfigValueUnknown() BleConfigValue {
	return BleConfigValue{
		state: attr.ValueStateUnknown,
	}
}

func NewBleConfigValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (BleConfigValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing BleConfigValue Attribute Value",
				"While creating a BleConfigValue value, a missing attribute value was detected. "+
					"A BleConfigValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("BleConfigValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid BleConfigValue Attribute Type",
				"While creating a BleConfigValue value, an invalid attribute value was detected. "+
					"A BleConfigValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("BleConfigValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("BleConfigValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra BleConfigValue Attribute Value",
				"While creating a BleConfigValue value, an extra attribute value was detected. "+
					"A BleConfigValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra BleConfigValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewBleConfigValueUnknown(), diags
	}

	beaconEnabledAttribute, ok := attributes["beacon_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`beacon_enabled is missing from object`)

		return NewBleConfigValueUnknown(), diags
	}

	beaconEnabledVal, ok := beaconEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`beacon_enabled expected to be basetypes.BoolValue, was: %T`, beaconEnabledAttribute))
	}

	beaconRateAttribute, ok := attributes["beacon_rate"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`beacon_rate is missing from object`)

		return NewBleConfigValueUnknown(), diags
	}

	beaconRateVal, ok := beaconRateAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`beacon_rate expected to be basetypes.Int64Value, was: %T`, beaconRateAttribute))
	}

	beaconRateModeAttribute, ok := attributes["beacon_rate_mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`beacon_rate_mode is missing from object`)

		return NewBleConfigValueUnknown(), diags
	}

	beaconRateModeVal, ok := beaconRateModeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`beacon_rate_mode expected to be basetypes.StringValue, was: %T`, beaconRateModeAttribute))
	}

	beamDisabledAttribute, ok := attributes["beam_disabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`beam_disabled is missing from object`)

		return NewBleConfigValueUnknown(), diags
	}

	beamDisabledVal, ok := beamDisabledAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`beam_disabled expected to be basetypes.ListValue, was: %T`, beamDisabledAttribute))
	}

	customBlePacketEnabledAttribute, ok := attributes["custom_ble_packet_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`custom_ble_packet_enabled is missing from object`)

		return NewBleConfigValueUnknown(), diags
	}

	customBlePacketEnabledVal, ok := customBlePacketEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`custom_ble_packet_enabled expected to be basetypes.BoolValue, was: %T`, customBlePacketEnabledAttribute))
	}

	customBlePacketFrameAttribute, ok := attributes["custom_ble_packet_frame"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`custom_ble_packet_frame is missing from object`)

		return NewBleConfigValueUnknown(), diags
	}

	customBlePacketFrameVal, ok := customBlePacketFrameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`custom_ble_packet_frame expected to be basetypes.StringValue, was: %T`, customBlePacketFrameAttribute))
	}

	customBlePacketFreqMsecAttribute, ok := attributes["custom_ble_packet_freq_msec"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`custom_ble_packet_freq_msec is missing from object`)

		return NewBleConfigValueUnknown(), diags
	}

	customBlePacketFreqMsecVal, ok := customBlePacketFreqMsecAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`custom_ble_packet_freq_msec expected to be basetypes.Int64Value, was: %T`, customBlePacketFreqMsecAttribute))
	}

	eddystoneUidAdvPowerAttribute, ok := attributes["eddystone_uid_adv_power"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`eddystone_uid_adv_power is missing from object`)

		return NewBleConfigValueUnknown(), diags
	}

	eddystoneUidAdvPowerVal, ok := eddystoneUidAdvPowerAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`eddystone_uid_adv_power expected to be basetypes.Int64Value, was: %T`, eddystoneUidAdvPowerAttribute))
	}

	eddystoneUidBeamsAttribute, ok := attributes["eddystone_uid_beams"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`eddystone_uid_beams is missing from object`)

		return NewBleConfigValueUnknown(), diags
	}

	eddystoneUidBeamsVal, ok := eddystoneUidBeamsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`eddystone_uid_beams expected to be basetypes.StringValue, was: %T`, eddystoneUidBeamsAttribute))
	}

	eddystoneUidEnabledAttribute, ok := attributes["eddystone_uid_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`eddystone_uid_enabled is missing from object`)

		return NewBleConfigValueUnknown(), diags
	}

	eddystoneUidEnabledVal, ok := eddystoneUidEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`eddystone_uid_enabled expected to be basetypes.BoolValue, was: %T`, eddystoneUidEnabledAttribute))
	}

	eddystoneUidFreqMsecAttribute, ok := attributes["eddystone_uid_freq_msec"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`eddystone_uid_freq_msec is missing from object`)

		return NewBleConfigValueUnknown(), diags
	}

	eddystoneUidFreqMsecVal, ok := eddystoneUidFreqMsecAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`eddystone_uid_freq_msec expected to be basetypes.Int64Value, was: %T`, eddystoneUidFreqMsecAttribute))
	}

	eddystoneUidInstanceAttribute, ok := attributes["eddystone_uid_instance"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`eddystone_uid_instance is missing from object`)

		return NewBleConfigValueUnknown(), diags
	}

	eddystoneUidInstanceVal, ok := eddystoneUidInstanceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`eddystone_uid_instance expected to be basetypes.StringValue, was: %T`, eddystoneUidInstanceAttribute))
	}

	eddystoneUidNamespaceAttribute, ok := attributes["eddystone_uid_namespace"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`eddystone_uid_namespace is missing from object`)

		return NewBleConfigValueUnknown(), diags
	}

	eddystoneUidNamespaceVal, ok := eddystoneUidNamespaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`eddystone_uid_namespace expected to be basetypes.StringValue, was: %T`, eddystoneUidNamespaceAttribute))
	}

	eddystoneUrlAdvPowerAttribute, ok := attributes["eddystone_url_adv_power"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`eddystone_url_adv_power is missing from object`)

		return NewBleConfigValueUnknown(), diags
	}

	eddystoneUrlAdvPowerVal, ok := eddystoneUrlAdvPowerAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`eddystone_url_adv_power expected to be basetypes.Int64Value, was: %T`, eddystoneUrlAdvPowerAttribute))
	}

	eddystoneUrlBeamsAttribute, ok := attributes["eddystone_url_beams"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`eddystone_url_beams is missing from object`)

		return NewBleConfigValueUnknown(), diags
	}

	eddystoneUrlBeamsVal, ok := eddystoneUrlBeamsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`eddystone_url_beams expected to be basetypes.StringValue, was: %T`, eddystoneUrlBeamsAttribute))
	}

	eddystoneUrlEnabledAttribute, ok := attributes["eddystone_url_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`eddystone_url_enabled is missing from object`)

		return NewBleConfigValueUnknown(), diags
	}

	eddystoneUrlEnabledVal, ok := eddystoneUrlEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`eddystone_url_enabled expected to be basetypes.BoolValue, was: %T`, eddystoneUrlEnabledAttribute))
	}

	eddystoneUrlFreqMsecAttribute, ok := attributes["eddystone_url_freq_msec"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`eddystone_url_freq_msec is missing from object`)

		return NewBleConfigValueUnknown(), diags
	}

	eddystoneUrlFreqMsecVal, ok := eddystoneUrlFreqMsecAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`eddystone_url_freq_msec expected to be basetypes.Int64Value, was: %T`, eddystoneUrlFreqMsecAttribute))
	}

	eddystoneUrlUrlAttribute, ok := attributes["eddystone_url_url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`eddystone_url_url is missing from object`)

		return NewBleConfigValueUnknown(), diags
	}

	eddystoneUrlUrlVal, ok := eddystoneUrlUrlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`eddystone_url_url expected to be basetypes.StringValue, was: %T`, eddystoneUrlUrlAttribute))
	}

	ibeaconAdvPowerAttribute, ok := attributes["ibeacon_adv_power"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ibeacon_adv_power is missing from object`)

		return NewBleConfigValueUnknown(), diags
	}

	ibeaconAdvPowerVal, ok := ibeaconAdvPowerAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ibeacon_adv_power expected to be basetypes.Int64Value, was: %T`, ibeaconAdvPowerAttribute))
	}

	ibeaconBeamsAttribute, ok := attributes["ibeacon_beams"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ibeacon_beams is missing from object`)

		return NewBleConfigValueUnknown(), diags
	}

	ibeaconBeamsVal, ok := ibeaconBeamsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ibeacon_beams expected to be basetypes.StringValue, was: %T`, ibeaconBeamsAttribute))
	}

	ibeaconEnabledAttribute, ok := attributes["ibeacon_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ibeacon_enabled is missing from object`)

		return NewBleConfigValueUnknown(), diags
	}

	ibeaconEnabledVal, ok := ibeaconEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ibeacon_enabled expected to be basetypes.BoolValue, was: %T`, ibeaconEnabledAttribute))
	}

	ibeaconFreqMsecAttribute, ok := attributes["ibeacon_freq_msec"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ibeacon_freq_msec is missing from object`)

		return NewBleConfigValueUnknown(), diags
	}

	ibeaconFreqMsecVal, ok := ibeaconFreqMsecAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ibeacon_freq_msec expected to be basetypes.Int64Value, was: %T`, ibeaconFreqMsecAttribute))
	}

	ibeaconMajorAttribute, ok := attributes["ibeacon_major"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ibeacon_major is missing from object`)

		return NewBleConfigValueUnknown(), diags
	}

	ibeaconMajorVal, ok := ibeaconMajorAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ibeacon_major expected to be basetypes.Int64Value, was: %T`, ibeaconMajorAttribute))
	}

	ibeaconMinorAttribute, ok := attributes["ibeacon_minor"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ibeacon_minor is missing from object`)

		return NewBleConfigValueUnknown(), diags
	}

	ibeaconMinorVal, ok := ibeaconMinorAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ibeacon_minor expected to be basetypes.Int64Value, was: %T`, ibeaconMinorAttribute))
	}

	ibeaconUuidAttribute, ok := attributes["ibeacon_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ibeacon_uuid is missing from object`)

		return NewBleConfigValueUnknown(), diags
	}

	ibeaconUuidVal, ok := ibeaconUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ibeacon_uuid expected to be basetypes.StringValue, was: %T`, ibeaconUuidAttribute))
	}

	powerAttribute, ok := attributes["power"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`power is missing from object`)

		return NewBleConfigValueUnknown(), diags
	}

	powerVal, ok := powerAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`power expected to be basetypes.Int64Value, was: %T`, powerAttribute))
	}

	powerModeAttribute, ok := attributes["power_mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`power_mode is missing from object`)

		return NewBleConfigValueUnknown(), diags
	}

	powerModeVal, ok := powerModeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`power_mode expected to be basetypes.StringValue, was: %T`, powerModeAttribute))
	}

	if diags.HasError() {
		return NewBleConfigValueUnknown(), diags
	}

	return BleConfigValue{
		BeaconEnabled:           beaconEnabledVal,
		BeaconRate:              beaconRateVal,
		BeaconRateMode:          beaconRateModeVal,
		BeamDisabled:            beamDisabledVal,
		CustomBlePacketEnabled:  customBlePacketEnabledVal,
		CustomBlePacketFrame:    customBlePacketFrameVal,
		CustomBlePacketFreqMsec: customBlePacketFreqMsecVal,
		EddystoneUidAdvPower:    eddystoneUidAdvPowerVal,
		EddystoneUidBeams:       eddystoneUidBeamsVal,
		EddystoneUidEnabled:     eddystoneUidEnabledVal,
		EddystoneUidFreqMsec:    eddystoneUidFreqMsecVal,
		EddystoneUidInstance:    eddystoneUidInstanceVal,
		EddystoneUidNamespace:   eddystoneUidNamespaceVal,
		EddystoneUrlAdvPower:    eddystoneUrlAdvPowerVal,
		EddystoneUrlBeams:       eddystoneUrlBeamsVal,
		EddystoneUrlEnabled:     eddystoneUrlEnabledVal,
		EddystoneUrlFreqMsec:    eddystoneUrlFreqMsecVal,
		EddystoneUrlUrl:         eddystoneUrlUrlVal,
		IbeaconAdvPower:         ibeaconAdvPowerVal,
		IbeaconBeams:            ibeaconBeamsVal,
		IbeaconEnabled:          ibeaconEnabledVal,
		IbeaconFreqMsec:         ibeaconFreqMsecVal,
		IbeaconMajor:            ibeaconMajorVal,
		IbeaconMinor:            ibeaconMinorVal,
		IbeaconUuid:             ibeaconUuidVal,
		Power:                   powerVal,
		PowerMode:               powerModeVal,
		state:                   attr.ValueStateKnown,
	}, diags
}

func NewBleConfigValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) BleConfigValue {
	object, diags := NewBleConfigValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewBleConfigValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t BleConfigType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewBleConfigValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewBleConfigValueUnknown(), nil
	}

	if in.IsNull() {
		return NewBleConfigValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewBleConfigValueMust(BleConfigValue{}.AttributeTypes(ctx), attributes), nil
}

func (t BleConfigType) ValueType(ctx context.Context) attr.Value {
	return BleConfigValue{}
}

var _ basetypes.ObjectValuable = BleConfigValue{}

type BleConfigValue struct {
	BeaconEnabled           basetypes.BoolValue   `tfsdk:"beacon_enabled"`
	BeaconRate              basetypes.Int64Value  `tfsdk:"beacon_rate"`
	BeaconRateMode          basetypes.StringValue `tfsdk:"beacon_rate_mode"`
	BeamDisabled            basetypes.ListValue   `tfsdk:"beam_disabled"`
	CustomBlePacketEnabled  basetypes.BoolValue   `tfsdk:"custom_ble_packet_enabled"`
	CustomBlePacketFrame    basetypes.StringValue `tfsdk:"custom_ble_packet_frame"`
	CustomBlePacketFreqMsec basetypes.Int64Value  `tfsdk:"custom_ble_packet_freq_msec"`
	EddystoneUidAdvPower    basetypes.Int64Value  `tfsdk:"eddystone_uid_adv_power"`
	EddystoneUidBeams       basetypes.StringValue `tfsdk:"eddystone_uid_beams"`
	EddystoneUidEnabled     basetypes.BoolValue   `tfsdk:"eddystone_uid_enabled"`
	EddystoneUidFreqMsec    basetypes.Int64Value  `tfsdk:"eddystone_uid_freq_msec"`
	EddystoneUidInstance    basetypes.StringValue `tfsdk:"eddystone_uid_instance"`
	EddystoneUidNamespace   basetypes.StringValue `tfsdk:"eddystone_uid_namespace"`
	EddystoneUrlAdvPower    basetypes.Int64Value  `tfsdk:"eddystone_url_adv_power"`
	EddystoneUrlBeams       basetypes.StringValue `tfsdk:"eddystone_url_beams"`
	EddystoneUrlEnabled     basetypes.BoolValue   `tfsdk:"eddystone_url_enabled"`
	EddystoneUrlFreqMsec    basetypes.Int64Value  `tfsdk:"eddystone_url_freq_msec"`
	EddystoneUrlUrl         basetypes.StringValue `tfsdk:"eddystone_url_url"`
	IbeaconAdvPower         basetypes.Int64Value  `tfsdk:"ibeacon_adv_power"`
	IbeaconBeams            basetypes.StringValue `tfsdk:"ibeacon_beams"`
	IbeaconEnabled          basetypes.BoolValue   `tfsdk:"ibeacon_enabled"`
	IbeaconFreqMsec         basetypes.Int64Value  `tfsdk:"ibeacon_freq_msec"`
	IbeaconMajor            basetypes.Int64Value  `tfsdk:"ibeacon_major"`
	IbeaconMinor            basetypes.Int64Value  `tfsdk:"ibeacon_minor"`
	IbeaconUuid             basetypes.StringValue `tfsdk:"ibeacon_uuid"`
	Power                   basetypes.Int64Value  `tfsdk:"power"`
	PowerMode               basetypes.StringValue `tfsdk:"power_mode"`
	state                   attr.ValueState
}

func (v BleConfigValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 27)

	var val tftypes.Value
	var err error

	attrTypes["beacon_enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["beacon_rate"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["beacon_rate_mode"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["beam_disabled"] = basetypes.ListType{
		ElemType: types.Int64Type,
	}.TerraformType(ctx)
	attrTypes["custom_ble_packet_enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["custom_ble_packet_frame"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["custom_ble_packet_freq_msec"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["eddystone_uid_adv_power"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["eddystone_uid_beams"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["eddystone_uid_enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["eddystone_uid_freq_msec"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["eddystone_uid_instance"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["eddystone_uid_namespace"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["eddystone_url_adv_power"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["eddystone_url_beams"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["eddystone_url_enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["eddystone_url_freq_msec"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["eddystone_url_url"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ibeacon_adv_power"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["ibeacon_beams"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ibeacon_enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["ibeacon_freq_msec"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["ibeacon_major"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["ibeacon_minor"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["ibeacon_uuid"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["power"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["power_mode"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 27)

		val, err = v.BeaconEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["beacon_enabled"] = val

		val, err = v.BeaconRate.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["beacon_rate"] = val

		val, err = v.BeaconRateMode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["beacon_rate_mode"] = val

		val, err = v.BeamDisabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["beam_disabled"] = val

		val, err = v.CustomBlePacketEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["custom_ble_packet_enabled"] = val

		val, err = v.CustomBlePacketFrame.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["custom_ble_packet_frame"] = val

		val, err = v.CustomBlePacketFreqMsec.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["custom_ble_packet_freq_msec"] = val

		val, err = v.EddystoneUidAdvPower.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["eddystone_uid_adv_power"] = val

		val, err = v.EddystoneUidBeams.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["eddystone_uid_beams"] = val

		val, err = v.EddystoneUidEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["eddystone_uid_enabled"] = val

		val, err = v.EddystoneUidFreqMsec.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["eddystone_uid_freq_msec"] = val

		val, err = v.EddystoneUidInstance.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["eddystone_uid_instance"] = val

		val, err = v.EddystoneUidNamespace.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["eddystone_uid_namespace"] = val

		val, err = v.EddystoneUrlAdvPower.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["eddystone_url_adv_power"] = val

		val, err = v.EddystoneUrlBeams.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["eddystone_url_beams"] = val

		val, err = v.EddystoneUrlEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["eddystone_url_enabled"] = val

		val, err = v.EddystoneUrlFreqMsec.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["eddystone_url_freq_msec"] = val

		val, err = v.EddystoneUrlUrl.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["eddystone_url_url"] = val

		val, err = v.IbeaconAdvPower.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ibeacon_adv_power"] = val

		val, err = v.IbeaconBeams.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ibeacon_beams"] = val

		val, err = v.IbeaconEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ibeacon_enabled"] = val

		val, err = v.IbeaconFreqMsec.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ibeacon_freq_msec"] = val

		val, err = v.IbeaconMajor.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ibeacon_major"] = val

		val, err = v.IbeaconMinor.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ibeacon_minor"] = val

		val, err = v.IbeaconUuid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ibeacon_uuid"] = val

		val, err = v.Power.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["power"] = val

		val, err = v.PowerMode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["power_mode"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v BleConfigValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v BleConfigValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v BleConfigValue) String() string {
	return "BleConfigValue"
}

func (v BleConfigValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	beamDisabledVal, d := types.ListValue(types.Int64Type, v.BeamDisabled.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"beacon_enabled":   basetypes.BoolType{},
			"beacon_rate":      basetypes.Int64Type{},
			"beacon_rate_mode": basetypes.StringType{},
			"beam_disabled": basetypes.ListType{
				ElemType: types.Int64Type,
			},
			"custom_ble_packet_enabled":   basetypes.BoolType{},
			"custom_ble_packet_frame":     basetypes.StringType{},
			"custom_ble_packet_freq_msec": basetypes.Int64Type{},
			"eddystone_uid_adv_power":     basetypes.Int64Type{},
			"eddystone_uid_beams":         basetypes.StringType{},
			"eddystone_uid_enabled":       basetypes.BoolType{},
			"eddystone_uid_freq_msec":     basetypes.Int64Type{},
			"eddystone_uid_instance":      basetypes.StringType{},
			"eddystone_uid_namespace":     basetypes.StringType{},
			"eddystone_url_adv_power":     basetypes.Int64Type{},
			"eddystone_url_beams":         basetypes.StringType{},
			"eddystone_url_enabled":       basetypes.BoolType{},
			"eddystone_url_freq_msec":     basetypes.Int64Type{},
			"eddystone_url_url":           basetypes.StringType{},
			"ibeacon_adv_power":           basetypes.Int64Type{},
			"ibeacon_beams":               basetypes.StringType{},
			"ibeacon_enabled":             basetypes.BoolType{},
			"ibeacon_freq_msec":           basetypes.Int64Type{},
			"ibeacon_major":               basetypes.Int64Type{},
			"ibeacon_minor":               basetypes.Int64Type{},
			"ibeacon_uuid":                basetypes.StringType{},
			"power":                       basetypes.Int64Type{},
			"power_mode":                  basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"beacon_enabled":   basetypes.BoolType{},
		"beacon_rate":      basetypes.Int64Type{},
		"beacon_rate_mode": basetypes.StringType{},
		"beam_disabled": basetypes.ListType{
			ElemType: types.Int64Type,
		},
		"custom_ble_packet_enabled":   basetypes.BoolType{},
		"custom_ble_packet_frame":     basetypes.StringType{},
		"custom_ble_packet_freq_msec": basetypes.Int64Type{},
		"eddystone_uid_adv_power":     basetypes.Int64Type{},
		"eddystone_uid_beams":         basetypes.StringType{},
		"eddystone_uid_enabled":       basetypes.BoolType{},
		"eddystone_uid_freq_msec":     basetypes.Int64Type{},
		"eddystone_uid_instance":      basetypes.StringType{},
		"eddystone_uid_namespace":     basetypes.StringType{},
		"eddystone_url_adv_power":     basetypes.Int64Type{},
		"eddystone_url_beams":         basetypes.StringType{},
		"eddystone_url_enabled":       basetypes.BoolType{},
		"eddystone_url_freq_msec":     basetypes.Int64Type{},
		"eddystone_url_url":           basetypes.StringType{},
		"ibeacon_adv_power":           basetypes.Int64Type{},
		"ibeacon_beams":               basetypes.StringType{},
		"ibeacon_enabled":             basetypes.BoolType{},
		"ibeacon_freq_msec":           basetypes.Int64Type{},
		"ibeacon_major":               basetypes.Int64Type{},
		"ibeacon_minor":               basetypes.Int64Type{},
		"ibeacon_uuid":                basetypes.StringType{},
		"power":                       basetypes.Int64Type{},
		"power_mode":                  basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"beacon_enabled":              v.BeaconEnabled,
			"beacon_rate":                 v.BeaconRate,
			"beacon_rate_mode":            v.BeaconRateMode,
			"beam_disabled":               beamDisabledVal,
			"custom_ble_packet_enabled":   v.CustomBlePacketEnabled,
			"custom_ble_packet_frame":     v.CustomBlePacketFrame,
			"custom_ble_packet_freq_msec": v.CustomBlePacketFreqMsec,
			"eddystone_uid_adv_power":     v.EddystoneUidAdvPower,
			"eddystone_uid_beams":         v.EddystoneUidBeams,
			"eddystone_uid_enabled":       v.EddystoneUidEnabled,
			"eddystone_uid_freq_msec":     v.EddystoneUidFreqMsec,
			"eddystone_uid_instance":      v.EddystoneUidInstance,
			"eddystone_uid_namespace":     v.EddystoneUidNamespace,
			"eddystone_url_adv_power":     v.EddystoneUrlAdvPower,
			"eddystone_url_beams":         v.EddystoneUrlBeams,
			"eddystone_url_enabled":       v.EddystoneUrlEnabled,
			"eddystone_url_freq_msec":     v.EddystoneUrlFreqMsec,
			"eddystone_url_url":           v.EddystoneUrlUrl,
			"ibeacon_adv_power":           v.IbeaconAdvPower,
			"ibeacon_beams":               v.IbeaconBeams,
			"ibeacon_enabled":             v.IbeaconEnabled,
			"ibeacon_freq_msec":           v.IbeaconFreqMsec,
			"ibeacon_major":               v.IbeaconMajor,
			"ibeacon_minor":               v.IbeaconMinor,
			"ibeacon_uuid":                v.IbeaconUuid,
			"power":                       v.Power,
			"power_mode":                  v.PowerMode,
		})

	return objVal, diags
}

func (v BleConfigValue) Equal(o attr.Value) bool {
	other, ok := o.(BleConfigValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.BeaconEnabled.Equal(other.BeaconEnabled) {
		return false
	}

	if !v.BeaconRate.Equal(other.BeaconRate) {
		return false
	}

	if !v.BeaconRateMode.Equal(other.BeaconRateMode) {
		return false
	}

	if !v.BeamDisabled.Equal(other.BeamDisabled) {
		return false
	}

	if !v.CustomBlePacketEnabled.Equal(other.CustomBlePacketEnabled) {
		return false
	}

	if !v.CustomBlePacketFrame.Equal(other.CustomBlePacketFrame) {
		return false
	}

	if !v.CustomBlePacketFreqMsec.Equal(other.CustomBlePacketFreqMsec) {
		return false
	}

	if !v.EddystoneUidAdvPower.Equal(other.EddystoneUidAdvPower) {
		return false
	}

	if !v.EddystoneUidBeams.Equal(other.EddystoneUidBeams) {
		return false
	}

	if !v.EddystoneUidEnabled.Equal(other.EddystoneUidEnabled) {
		return false
	}

	if !v.EddystoneUidFreqMsec.Equal(other.EddystoneUidFreqMsec) {
		return false
	}

	if !v.EddystoneUidInstance.Equal(other.EddystoneUidInstance) {
		return false
	}

	if !v.EddystoneUidNamespace.Equal(other.EddystoneUidNamespace) {
		return false
	}

	if !v.EddystoneUrlAdvPower.Equal(other.EddystoneUrlAdvPower) {
		return false
	}

	if !v.EddystoneUrlBeams.Equal(other.EddystoneUrlBeams) {
		return false
	}

	if !v.EddystoneUrlEnabled.Equal(other.EddystoneUrlEnabled) {
		return false
	}

	if !v.EddystoneUrlFreqMsec.Equal(other.EddystoneUrlFreqMsec) {
		return false
	}

	if !v.EddystoneUrlUrl.Equal(other.EddystoneUrlUrl) {
		return false
	}

	if !v.IbeaconAdvPower.Equal(other.IbeaconAdvPower) {
		return false
	}

	if !v.IbeaconBeams.Equal(other.IbeaconBeams) {
		return false
	}

	if !v.IbeaconEnabled.Equal(other.IbeaconEnabled) {
		return false
	}

	if !v.IbeaconFreqMsec.Equal(other.IbeaconFreqMsec) {
		return false
	}

	if !v.IbeaconMajor.Equal(other.IbeaconMajor) {
		return false
	}

	if !v.IbeaconMinor.Equal(other.IbeaconMinor) {
		return false
	}

	if !v.IbeaconUuid.Equal(other.IbeaconUuid) {
		return false
	}

	if !v.Power.Equal(other.Power) {
		return false
	}

	if !v.PowerMode.Equal(other.PowerMode) {
		return false
	}

	return true
}

func (v BleConfigValue) Type(ctx context.Context) attr.Type {
	return BleConfigType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v BleConfigValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"beacon_enabled":   basetypes.BoolType{},
		"beacon_rate":      basetypes.Int64Type{},
		"beacon_rate_mode": basetypes.StringType{},
		"beam_disabled": basetypes.ListType{
			ElemType: types.Int64Type,
		},
		"custom_ble_packet_enabled":   basetypes.BoolType{},
		"custom_ble_packet_frame":     basetypes.StringType{},
		"custom_ble_packet_freq_msec": basetypes.Int64Type{},
		"eddystone_uid_adv_power":     basetypes.Int64Type{},
		"eddystone_uid_beams":         basetypes.StringType{},
		"eddystone_uid_enabled":       basetypes.BoolType{},
		"eddystone_uid_freq_msec":     basetypes.Int64Type{},
		"eddystone_uid_instance":      basetypes.StringType{},
		"eddystone_uid_namespace":     basetypes.StringType{},
		"eddystone_url_adv_power":     basetypes.Int64Type{},
		"eddystone_url_beams":         basetypes.StringType{},
		"eddystone_url_enabled":       basetypes.BoolType{},
		"eddystone_url_freq_msec":     basetypes.Int64Type{},
		"eddystone_url_url":           basetypes.StringType{},
		"ibeacon_adv_power":           basetypes.Int64Type{},
		"ibeacon_beams":               basetypes.StringType{},
		"ibeacon_enabled":             basetypes.BoolType{},
		"ibeacon_freq_msec":           basetypes.Int64Type{},
		"ibeacon_major":               basetypes.Int64Type{},
		"ibeacon_minor":               basetypes.Int64Type{},
		"ibeacon_uuid":                basetypes.StringType{},
		"power":                       basetypes.Int64Type{},
		"power_mode":                  basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = EslConfigType{}

type EslConfigType struct {
	basetypes.ObjectType
}

func (t EslConfigType) Equal(o attr.Type) bool {
	other, ok := o.(EslConfigType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t EslConfigType) String() string {
	return "EslConfigType"
}

func (t EslConfigType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	cacertAttribute, ok := attributes["cacert"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cacert is missing from object`)

		return nil, diags
	}

	cacertVal, ok := cacertAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cacert expected to be basetypes.StringValue, was: %T`, cacertAttribute))
	}

	channelAttribute, ok := attributes["channel"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`channel is missing from object`)

		return nil, diags
	}

	channelVal, ok := channelAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`channel expected to be basetypes.Int64Value, was: %T`, channelAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	hostAttribute, ok := attributes["host"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`host is missing from object`)

		return nil, diags
	}

	hostVal, ok := hostAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`host expected to be basetypes.StringValue, was: %T`, hostAttribute))
	}

	portAttribute, ok := attributes["port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port is missing from object`)

		return nil, diags
	}

	portVal, ok := portAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port expected to be basetypes.Int64Value, was: %T`, portAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	verifyCertAttribute, ok := attributes["verify_cert"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`verify_cert is missing from object`)

		return nil, diags
	}

	verifyCertVal, ok := verifyCertAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`verify_cert expected to be basetypes.BoolValue, was: %T`, verifyCertAttribute))
	}

	vlanIdAttribute, ok := attributes["vlan_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan_id is missing from object`)

		return nil, diags
	}

	vlanIdVal, ok := vlanIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan_id expected to be basetypes.Int64Value, was: %T`, vlanIdAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return EslConfigValue{
		Cacert:        cacertVal,
		Channel:       channelVal,
		Enabled:       enabledVal,
		Host:          hostVal,
		Port:          portVal,
		EslConfigType: typeVal,
		VerifyCert:    verifyCertVal,
		VlanId:        vlanIdVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewEslConfigValueNull() EslConfigValue {
	return EslConfigValue{
		state: attr.ValueStateNull,
	}
}

func NewEslConfigValueUnknown() EslConfigValue {
	return EslConfigValue{
		state: attr.ValueStateUnknown,
	}
}

func NewEslConfigValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (EslConfigValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing EslConfigValue Attribute Value",
				"While creating a EslConfigValue value, a missing attribute value was detected. "+
					"A EslConfigValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("EslConfigValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid EslConfigValue Attribute Type",
				"While creating a EslConfigValue value, an invalid attribute value was detected. "+
					"A EslConfigValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("EslConfigValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("EslConfigValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra EslConfigValue Attribute Value",
				"While creating a EslConfigValue value, an extra attribute value was detected. "+
					"A EslConfigValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra EslConfigValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewEslConfigValueUnknown(), diags
	}

	cacertAttribute, ok := attributes["cacert"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cacert is missing from object`)

		return NewEslConfigValueUnknown(), diags
	}

	cacertVal, ok := cacertAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cacert expected to be basetypes.StringValue, was: %T`, cacertAttribute))
	}

	channelAttribute, ok := attributes["channel"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`channel is missing from object`)

		return NewEslConfigValueUnknown(), diags
	}

	channelVal, ok := channelAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`channel expected to be basetypes.Int64Value, was: %T`, channelAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewEslConfigValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	hostAttribute, ok := attributes["host"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`host is missing from object`)

		return NewEslConfigValueUnknown(), diags
	}

	hostVal, ok := hostAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`host expected to be basetypes.StringValue, was: %T`, hostAttribute))
	}

	portAttribute, ok := attributes["port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port is missing from object`)

		return NewEslConfigValueUnknown(), diags
	}

	portVal, ok := portAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port expected to be basetypes.Int64Value, was: %T`, portAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewEslConfigValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	verifyCertAttribute, ok := attributes["verify_cert"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`verify_cert is missing from object`)

		return NewEslConfigValueUnknown(), diags
	}

	verifyCertVal, ok := verifyCertAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`verify_cert expected to be basetypes.BoolValue, was: %T`, verifyCertAttribute))
	}

	vlanIdAttribute, ok := attributes["vlan_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan_id is missing from object`)

		return NewEslConfigValueUnknown(), diags
	}

	vlanIdVal, ok := vlanIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan_id expected to be basetypes.Int64Value, was: %T`, vlanIdAttribute))
	}

	if diags.HasError() {
		return NewEslConfigValueUnknown(), diags
	}

	return EslConfigValue{
		Cacert:        cacertVal,
		Channel:       channelVal,
		Enabled:       enabledVal,
		Host:          hostVal,
		Port:          portVal,
		EslConfigType: typeVal,
		VerifyCert:    verifyCertVal,
		VlanId:        vlanIdVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewEslConfigValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) EslConfigValue {
	object, diags := NewEslConfigValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewEslConfigValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t EslConfigType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewEslConfigValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewEslConfigValueUnknown(), nil
	}

	if in.IsNull() {
		return NewEslConfigValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewEslConfigValueMust(EslConfigValue{}.AttributeTypes(ctx), attributes), nil
}

func (t EslConfigType) ValueType(ctx context.Context) attr.Value {
	return EslConfigValue{}
}

var _ basetypes.ObjectValuable = EslConfigValue{}

type EslConfigValue struct {
	Cacert        basetypes.StringValue `tfsdk:"cacert"`
	Channel       basetypes.Int64Value  `tfsdk:"channel"`
	Enabled       basetypes.BoolValue   `tfsdk:"enabled"`
	Host          basetypes.StringValue `tfsdk:"host"`
	Port          basetypes.Int64Value  `tfsdk:"port"`
	EslConfigType basetypes.StringValue `tfsdk:"type"`
	VerifyCert    basetypes.BoolValue   `tfsdk:"verify_cert"`
	VlanId        basetypes.Int64Value  `tfsdk:"vlan_id"`
	state         attr.ValueState
}

func (v EslConfigValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 8)

	var val tftypes.Value
	var err error

	attrTypes["cacert"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["channel"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["host"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["port"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["verify_cert"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["vlan_id"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 8)

		val, err = v.Cacert.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cacert"] = val

		val, err = v.Channel.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["channel"] = val

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.Host.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["host"] = val

		val, err = v.Port.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port"] = val

		val, err = v.EslConfigType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		val, err = v.VerifyCert.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["verify_cert"] = val

		val, err = v.VlanId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vlan_id"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v EslConfigValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v EslConfigValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v EslConfigValue) String() string {
	return "EslConfigValue"
}

func (v EslConfigValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"cacert":      basetypes.StringType{},
		"channel":     basetypes.Int64Type{},
		"enabled":     basetypes.BoolType{},
		"host":        basetypes.StringType{},
		"port":        basetypes.Int64Type{},
		"type":        basetypes.StringType{},
		"verify_cert": basetypes.BoolType{},
		"vlan_id":     basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"cacert":      v.Cacert,
			"channel":     v.Channel,
			"enabled":     v.Enabled,
			"host":        v.Host,
			"port":        v.Port,
			"type":        v.EslConfigType,
			"verify_cert": v.VerifyCert,
			"vlan_id":     v.VlanId,
		})

	return objVal, diags
}

func (v EslConfigValue) Equal(o attr.Value) bool {
	other, ok := o.(EslConfigValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Cacert.Equal(other.Cacert) {
		return false
	}

	if !v.Channel.Equal(other.Channel) {
		return false
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.Host.Equal(other.Host) {
		return false
	}

	if !v.Port.Equal(other.Port) {
		return false
	}

	if !v.EslConfigType.Equal(other.EslConfigType) {
		return false
	}

	if !v.VerifyCert.Equal(other.VerifyCert) {
		return false
	}

	if !v.VlanId.Equal(other.VlanId) {
		return false
	}

	return true
}

func (v EslConfigValue) Type(ctx context.Context) attr.Type {
	return EslConfigType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v EslConfigValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"cacert":      basetypes.StringType{},
		"channel":     basetypes.Int64Type{},
		"enabled":     basetypes.BoolType{},
		"host":        basetypes.StringType{},
		"port":        basetypes.Int64Type{},
		"type":        basetypes.StringType{},
		"verify_cert": basetypes.BoolType{},
		"vlan_id":     basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = IpConfigType{}

type IpConfigType struct {
	basetypes.ObjectType
}

func (t IpConfigType) Equal(o attr.Type) bool {
	other, ok := o.(IpConfigType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t IpConfigType) String() string {
	return "IpConfigType"
}

func (t IpConfigType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	dnsAttribute, ok := attributes["dns"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dns is missing from object`)

		return nil, diags
	}

	dnsVal, ok := dnsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dns expected to be basetypes.ListValue, was: %T`, dnsAttribute))
	}

	dnsSuffixAttribute, ok := attributes["dns_suffix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dns_suffix is missing from object`)

		return nil, diags
	}

	dnsSuffixVal, ok := dnsSuffixAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dns_suffix expected to be basetypes.ListValue, was: %T`, dnsSuffixAttribute))
	}

	gatewayAttribute, ok := attributes["gateway"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gateway is missing from object`)

		return nil, diags
	}

	gatewayVal, ok := gatewayAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gateway expected to be basetypes.StringValue, was: %T`, gatewayAttribute))
	}

	gateway6Attribute, ok := attributes["gateway6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gateway6 is missing from object`)

		return nil, diags
	}

	gateway6Val, ok := gateway6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gateway6 expected to be basetypes.StringValue, was: %T`, gateway6Attribute))
	}

	ipAttribute, ok := attributes["ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip is missing from object`)

		return nil, diags
	}

	ipVal, ok := ipAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip expected to be basetypes.StringValue, was: %T`, ipAttribute))
	}

	ip6Attribute, ok := attributes["ip6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip6 is missing from object`)

		return nil, diags
	}

	ip6Val, ok := ip6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip6 expected to be basetypes.StringValue, was: %T`, ip6Attribute))
	}

	mtuAttribute, ok := attributes["mtu"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mtu is missing from object`)

		return nil, diags
	}

	mtuVal, ok := mtuAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mtu expected to be basetypes.Int64Value, was: %T`, mtuAttribute))
	}

	netmaskAttribute, ok := attributes["netmask"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`netmask is missing from object`)

		return nil, diags
	}

	netmaskVal, ok := netmaskAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`netmask expected to be basetypes.StringValue, was: %T`, netmaskAttribute))
	}

	netmask6Attribute, ok := attributes["netmask6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`netmask6 is missing from object`)

		return nil, diags
	}

	netmask6Val, ok := netmask6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`netmask6 expected to be basetypes.StringValue, was: %T`, netmask6Attribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	type6Attribute, ok := attributes["type6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type6 is missing from object`)

		return nil, diags
	}

	type6Val, ok := type6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type6 expected to be basetypes.StringValue, was: %T`, type6Attribute))
	}

	vlanIdAttribute, ok := attributes["vlan_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan_id is missing from object`)

		return nil, diags
	}

	vlanIdVal, ok := vlanIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan_id expected to be basetypes.Int64Value, was: %T`, vlanIdAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return IpConfigValue{
		Dns:          dnsVal,
		DnsSuffix:    dnsSuffixVal,
		Gateway:      gatewayVal,
		Gateway6:     gateway6Val,
		Ip:           ipVal,
		Ip6:          ip6Val,
		Mtu:          mtuVal,
		Netmask:      netmaskVal,
		Netmask6:     netmask6Val,
		IpConfigType: typeVal,
		Type6:        type6Val,
		VlanId:       vlanIdVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewIpConfigValueNull() IpConfigValue {
	return IpConfigValue{
		state: attr.ValueStateNull,
	}
}

func NewIpConfigValueUnknown() IpConfigValue {
	return IpConfigValue{
		state: attr.ValueStateUnknown,
	}
}

func NewIpConfigValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (IpConfigValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing IpConfigValue Attribute Value",
				"While creating a IpConfigValue value, a missing attribute value was detected. "+
					"A IpConfigValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("IpConfigValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid IpConfigValue Attribute Type",
				"While creating a IpConfigValue value, an invalid attribute value was detected. "+
					"A IpConfigValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("IpConfigValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("IpConfigValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra IpConfigValue Attribute Value",
				"While creating a IpConfigValue value, an extra attribute value was detected. "+
					"A IpConfigValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra IpConfigValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewIpConfigValueUnknown(), diags
	}

	dnsAttribute, ok := attributes["dns"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dns is missing from object`)

		return NewIpConfigValueUnknown(), diags
	}

	dnsVal, ok := dnsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dns expected to be basetypes.ListValue, was: %T`, dnsAttribute))
	}

	dnsSuffixAttribute, ok := attributes["dns_suffix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dns_suffix is missing from object`)

		return NewIpConfigValueUnknown(), diags
	}

	dnsSuffixVal, ok := dnsSuffixAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dns_suffix expected to be basetypes.ListValue, was: %T`, dnsSuffixAttribute))
	}

	gatewayAttribute, ok := attributes["gateway"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gateway is missing from object`)

		return NewIpConfigValueUnknown(), diags
	}

	gatewayVal, ok := gatewayAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gateway expected to be basetypes.StringValue, was: %T`, gatewayAttribute))
	}

	gateway6Attribute, ok := attributes["gateway6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gateway6 is missing from object`)

		return NewIpConfigValueUnknown(), diags
	}

	gateway6Val, ok := gateway6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gateway6 expected to be basetypes.StringValue, was: %T`, gateway6Attribute))
	}

	ipAttribute, ok := attributes["ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip is missing from object`)

		return NewIpConfigValueUnknown(), diags
	}

	ipVal, ok := ipAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip expected to be basetypes.StringValue, was: %T`, ipAttribute))
	}

	ip6Attribute, ok := attributes["ip6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip6 is missing from object`)

		return NewIpConfigValueUnknown(), diags
	}

	ip6Val, ok := ip6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip6 expected to be basetypes.StringValue, was: %T`, ip6Attribute))
	}

	mtuAttribute, ok := attributes["mtu"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mtu is missing from object`)

		return NewIpConfigValueUnknown(), diags
	}

	mtuVal, ok := mtuAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mtu expected to be basetypes.Int64Value, was: %T`, mtuAttribute))
	}

	netmaskAttribute, ok := attributes["netmask"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`netmask is missing from object`)

		return NewIpConfigValueUnknown(), diags
	}

	netmaskVal, ok := netmaskAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`netmask expected to be basetypes.StringValue, was: %T`, netmaskAttribute))
	}

	netmask6Attribute, ok := attributes["netmask6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`netmask6 is missing from object`)

		return NewIpConfigValueUnknown(), diags
	}

	netmask6Val, ok := netmask6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`netmask6 expected to be basetypes.StringValue, was: %T`, netmask6Attribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewIpConfigValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	type6Attribute, ok := attributes["type6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type6 is missing from object`)

		return NewIpConfigValueUnknown(), diags
	}

	type6Val, ok := type6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type6 expected to be basetypes.StringValue, was: %T`, type6Attribute))
	}

	vlanIdAttribute, ok := attributes["vlan_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan_id is missing from object`)

		return NewIpConfigValueUnknown(), diags
	}

	vlanIdVal, ok := vlanIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan_id expected to be basetypes.Int64Value, was: %T`, vlanIdAttribute))
	}

	if diags.HasError() {
		return NewIpConfigValueUnknown(), diags
	}

	return IpConfigValue{
		Dns:          dnsVal,
		DnsSuffix:    dnsSuffixVal,
		Gateway:      gatewayVal,
		Gateway6:     gateway6Val,
		Ip:           ipVal,
		Ip6:          ip6Val,
		Mtu:          mtuVal,
		Netmask:      netmaskVal,
		Netmask6:     netmask6Val,
		IpConfigType: typeVal,
		Type6:        type6Val,
		VlanId:       vlanIdVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewIpConfigValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) IpConfigValue {
	object, diags := NewIpConfigValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewIpConfigValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t IpConfigType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewIpConfigValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewIpConfigValueUnknown(), nil
	}

	if in.IsNull() {
		return NewIpConfigValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewIpConfigValueMust(IpConfigValue{}.AttributeTypes(ctx), attributes), nil
}

func (t IpConfigType) ValueType(ctx context.Context) attr.Value {
	return IpConfigValue{}
}

var _ basetypes.ObjectValuable = IpConfigValue{}

type IpConfigValue struct {
	Dns          basetypes.ListValue   `tfsdk:"dns"`
	DnsSuffix    basetypes.ListValue   `tfsdk:"dns_suffix"`
	Gateway      basetypes.StringValue `tfsdk:"gateway"`
	Gateway6     basetypes.StringValue `tfsdk:"gateway6"`
	Ip           basetypes.StringValue `tfsdk:"ip"`
	Ip6          basetypes.StringValue `tfsdk:"ip6"`
	Mtu          basetypes.Int64Value  `tfsdk:"mtu"`
	Netmask      basetypes.StringValue `tfsdk:"netmask"`
	Netmask6     basetypes.StringValue `tfsdk:"netmask6"`
	IpConfigType basetypes.StringValue `tfsdk:"type"`
	Type6        basetypes.StringValue `tfsdk:"type6"`
	VlanId       basetypes.Int64Value  `tfsdk:"vlan_id"`
	state        attr.ValueState
}

func (v IpConfigValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 12)

	var val tftypes.Value
	var err error

	attrTypes["dns"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["dns_suffix"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["gateway"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["gateway6"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ip"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ip6"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["mtu"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["netmask"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["netmask6"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["type6"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["vlan_id"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 12)

		val, err = v.Dns.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dns"] = val

		val, err = v.DnsSuffix.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dns_suffix"] = val

		val, err = v.Gateway.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["gateway"] = val

		val, err = v.Gateway6.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["gateway6"] = val

		val, err = v.Ip.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip"] = val

		val, err = v.Ip6.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip6"] = val

		val, err = v.Mtu.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mtu"] = val

		val, err = v.Netmask.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["netmask"] = val

		val, err = v.Netmask6.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["netmask6"] = val

		val, err = v.IpConfigType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		val, err = v.Type6.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type6"] = val

		val, err = v.VlanId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vlan_id"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v IpConfigValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v IpConfigValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v IpConfigValue) String() string {
	return "IpConfigValue"
}

func (v IpConfigValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	dnsVal, d := types.ListValue(types.StringType, v.Dns.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"dns": basetypes.ListType{
				ElemType: types.StringType,
			},
			"dns_suffix": basetypes.ListType{
				ElemType: types.StringType,
			},
			"gateway":  basetypes.StringType{},
			"gateway6": basetypes.StringType{},
			"ip":       basetypes.StringType{},
			"ip6":      basetypes.StringType{},
			"mtu":      basetypes.Int64Type{},
			"netmask":  basetypes.StringType{},
			"netmask6": basetypes.StringType{},
			"type":     basetypes.StringType{},
			"type6":    basetypes.StringType{},
			"vlan_id":  basetypes.Int64Type{},
		}), diags
	}

	dnsSuffixVal, d := types.ListValue(types.StringType, v.DnsSuffix.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"dns": basetypes.ListType{
				ElemType: types.StringType,
			},
			"dns_suffix": basetypes.ListType{
				ElemType: types.StringType,
			},
			"gateway":  basetypes.StringType{},
			"gateway6": basetypes.StringType{},
			"ip":       basetypes.StringType{},
			"ip6":      basetypes.StringType{},
			"mtu":      basetypes.Int64Type{},
			"netmask":  basetypes.StringType{},
			"netmask6": basetypes.StringType{},
			"type":     basetypes.StringType{},
			"type6":    basetypes.StringType{},
			"vlan_id":  basetypes.Int64Type{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"dns": basetypes.ListType{
			ElemType: types.StringType,
		},
		"dns_suffix": basetypes.ListType{
			ElemType: types.StringType,
		},
		"gateway":  basetypes.StringType{},
		"gateway6": basetypes.StringType{},
		"ip":       basetypes.StringType{},
		"ip6":      basetypes.StringType{},
		"mtu":      basetypes.Int64Type{},
		"netmask":  basetypes.StringType{},
		"netmask6": basetypes.StringType{},
		"type":     basetypes.StringType{},
		"type6":    basetypes.StringType{},
		"vlan_id":  basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"dns":        dnsVal,
			"dns_suffix": dnsSuffixVal,
			"gateway":    v.Gateway,
			"gateway6":   v.Gateway6,
			"ip":         v.Ip,
			"ip6":        v.Ip6,
			"mtu":        v.Mtu,
			"netmask":    v.Netmask,
			"netmask6":   v.Netmask6,
			"type":       v.IpConfigType,
			"type6":      v.Type6,
			"vlan_id":    v.VlanId,
		})

	return objVal, diags
}

func (v IpConfigValue) Equal(o attr.Value) bool {
	other, ok := o.(IpConfigValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Dns.Equal(other.Dns) {
		return false
	}

	if !v.DnsSuffix.Equal(other.DnsSuffix) {
		return false
	}

	if !v.Gateway.Equal(other.Gateway) {
		return false
	}

	if !v.Gateway6.Equal(other.Gateway6) {
		return false
	}

	if !v.Ip.Equal(other.Ip) {
		return false
	}

	if !v.Ip6.Equal(other.Ip6) {
		return false
	}

	if !v.Mtu.Equal(other.Mtu) {
		return false
	}

	if !v.Netmask.Equal(other.Netmask) {
		return false
	}

	if !v.Netmask6.Equal(other.Netmask6) {
		return false
	}

	if !v.IpConfigType.Equal(other.IpConfigType) {
		return false
	}

	if !v.Type6.Equal(other.Type6) {
		return false
	}

	if !v.VlanId.Equal(other.VlanId) {
		return false
	}

	return true
}

func (v IpConfigValue) Type(ctx context.Context) attr.Type {
	return IpConfigType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v IpConfigValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"dns": basetypes.ListType{
			ElemType: types.StringType,
		},
		"dns_suffix": basetypes.ListType{
			ElemType: types.StringType,
		},
		"gateway":  basetypes.StringType{},
		"gateway6": basetypes.StringType{},
		"ip":       basetypes.StringType{},
		"ip6":      basetypes.StringType{},
		"mtu":      basetypes.Int64Type{},
		"netmask":  basetypes.StringType{},
		"netmask6": basetypes.StringType{},
		"type":     basetypes.StringType{},
		"type6":    basetypes.StringType{},
		"vlan_id":  basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = LedType{}

type LedType struct {
	basetypes.ObjectType
}

func (t LedType) Equal(o attr.Type) bool {
	other, ok := o.(LedType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t LedType) String() string {
	return "LedType"
}

func (t LedType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	brightnessAttribute, ok := attributes["brightness"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`brightness is missing from object`)

		return nil, diags
	}

	brightnessVal, ok := brightnessAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`brightness expected to be basetypes.Int64Value, was: %T`, brightnessAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return LedValue{
		Brightness: brightnessVal,
		Enabled:    enabledVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewLedValueNull() LedValue {
	return LedValue{
		state: attr.ValueStateNull,
	}
}

func NewLedValueUnknown() LedValue {
	return LedValue{
		state: attr.ValueStateUnknown,
	}
}

func NewLedValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (LedValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing LedValue Attribute Value",
				"While creating a LedValue value, a missing attribute value was detected. "+
					"A LedValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("LedValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid LedValue Attribute Type",
				"While creating a LedValue value, an invalid attribute value was detected. "+
					"A LedValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("LedValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("LedValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra LedValue Attribute Value",
				"While creating a LedValue value, an extra attribute value was detected. "+
					"A LedValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra LedValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewLedValueUnknown(), diags
	}

	brightnessAttribute, ok := attributes["brightness"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`brightness is missing from object`)

		return NewLedValueUnknown(), diags
	}

	brightnessVal, ok := brightnessAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`brightness expected to be basetypes.Int64Value, was: %T`, brightnessAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewLedValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	if diags.HasError() {
		return NewLedValueUnknown(), diags
	}

	return LedValue{
		Brightness: brightnessVal,
		Enabled:    enabledVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewLedValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) LedValue {
	object, diags := NewLedValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewLedValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t LedType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewLedValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewLedValueUnknown(), nil
	}

	if in.IsNull() {
		return NewLedValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewLedValueMust(LedValue{}.AttributeTypes(ctx), attributes), nil
}

func (t LedType) ValueType(ctx context.Context) attr.Value {
	return LedValue{}
}

var _ basetypes.ObjectValuable = LedValue{}

type LedValue struct {
	Brightness basetypes.Int64Value `tfsdk:"brightness"`
	Enabled    basetypes.BoolValue  `tfsdk:"enabled"`
	state      attr.ValueState
}

func (v LedValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["brightness"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Brightness.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["brightness"] = val

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v LedValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v LedValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v LedValue) String() string {
	return "LedValue"
}

func (v LedValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"brightness": basetypes.Int64Type{},
		"enabled":    basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"brightness": v.Brightness,
			"enabled":    v.Enabled,
		})

	return objVal, diags
}

func (v LedValue) Equal(o attr.Value) bool {
	other, ok := o.(LedValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Brightness.Equal(other.Brightness) {
		return false
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	return true
}

func (v LedValue) Type(ctx context.Context) attr.Type {
	return LedType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v LedValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"brightness": basetypes.Int64Type{},
		"enabled":    basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = MeshType{}

type MeshType struct {
	basetypes.ObjectType
}

func (t MeshType) Equal(o attr.Type) bool {
	other, ok := o.(MeshType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t MeshType) String() string {
	return "MeshType"
}

func (t MeshType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	groupAttribute, ok := attributes["group"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`group is missing from object`)

		return nil, diags
	}

	groupVal, ok := groupAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`group expected to be basetypes.Int64Value, was: %T`, groupAttribute))
	}

	roleAttribute, ok := attributes["role"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`role is missing from object`)

		return nil, diags
	}

	roleVal, ok := roleAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`role expected to be basetypes.StringValue, was: %T`, roleAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return MeshValue{
		Enabled: enabledVal,
		Group:   groupVal,
		Role:    roleVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewMeshValueNull() MeshValue {
	return MeshValue{
		state: attr.ValueStateNull,
	}
}

func NewMeshValueUnknown() MeshValue {
	return MeshValue{
		state: attr.ValueStateUnknown,
	}
}

func NewMeshValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (MeshValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing MeshValue Attribute Value",
				"While creating a MeshValue value, a missing attribute value was detected. "+
					"A MeshValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MeshValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid MeshValue Attribute Type",
				"While creating a MeshValue value, an invalid attribute value was detected. "+
					"A MeshValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MeshValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("MeshValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra MeshValue Attribute Value",
				"While creating a MeshValue value, an extra attribute value was detected. "+
					"A MeshValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra MeshValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewMeshValueUnknown(), diags
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewMeshValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	groupAttribute, ok := attributes["group"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`group is missing from object`)

		return NewMeshValueUnknown(), diags
	}

	groupVal, ok := groupAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`group expected to be basetypes.Int64Value, was: %T`, groupAttribute))
	}

	roleAttribute, ok := attributes["role"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`role is missing from object`)

		return NewMeshValueUnknown(), diags
	}

	roleVal, ok := roleAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`role expected to be basetypes.StringValue, was: %T`, roleAttribute))
	}

	if diags.HasError() {
		return NewMeshValueUnknown(), diags
	}

	return MeshValue{
		Enabled: enabledVal,
		Group:   groupVal,
		Role:    roleVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewMeshValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) MeshValue {
	object, diags := NewMeshValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewMeshValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t MeshType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewMeshValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewMeshValueUnknown(), nil
	}

	if in.IsNull() {
		return NewMeshValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewMeshValueMust(MeshValue{}.AttributeTypes(ctx), attributes), nil
}

func (t MeshType) ValueType(ctx context.Context) attr.Value {
	return MeshValue{}
}

var _ basetypes.ObjectValuable = MeshValue{}

type MeshValue struct {
	Enabled basetypes.BoolValue   `tfsdk:"enabled"`
	Group   basetypes.Int64Value  `tfsdk:"group"`
	Role    basetypes.StringValue `tfsdk:"role"`
	state   attr.ValueState
}

func (v MeshValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["group"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["role"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.Group.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["group"] = val

		val, err = v.Role.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["role"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v MeshValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v MeshValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v MeshValue) String() string {
	return "MeshValue"
}

func (v MeshValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"enabled": basetypes.BoolType{},
		"group":   basetypes.Int64Type{},
		"role":    basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"enabled": v.Enabled,
			"group":   v.Group,
			"role":    v.Role,
		})

	return objVal, diags
}

func (v MeshValue) Equal(o attr.Value) bool {
	other, ok := o.(MeshValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.Group.Equal(other.Group) {
		return false
	}

	if !v.Role.Equal(other.Role) {
		return false
	}

	return true
}

func (v MeshValue) Type(ctx context.Context) attr.Type {
	return MeshType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v MeshValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"enabled": basetypes.BoolType{},
		"group":   basetypes.Int64Type{},
		"role":    basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = PwrConfigType{}

type PwrConfigType struct {
	basetypes.ObjectType
}

func (t PwrConfigType) Equal(o attr.Type) bool {
	other, ok := o.(PwrConfigType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PwrConfigType) String() string {
	return "PwrConfigType"
}

func (t PwrConfigType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	baseAttribute, ok := attributes["base"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`base is missing from object`)

		return nil, diags
	}

	baseVal, ok := baseAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`base expected to be basetypes.Int64Value, was: %T`, baseAttribute))
	}

	preferUsbOverWifiAttribute, ok := attributes["prefer_usb_over_wifi"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefer_usb_over_wifi is missing from object`)

		return nil, diags
	}

	preferUsbOverWifiVal, ok := preferUsbOverWifiAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefer_usb_over_wifi expected to be basetypes.BoolValue, was: %T`, preferUsbOverWifiAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PwrConfigValue{
		Base:              baseVal,
		PreferUsbOverWifi: preferUsbOverWifiVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewPwrConfigValueNull() PwrConfigValue {
	return PwrConfigValue{
		state: attr.ValueStateNull,
	}
}

func NewPwrConfigValueUnknown() PwrConfigValue {
	return PwrConfigValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPwrConfigValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PwrConfigValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PwrConfigValue Attribute Value",
				"While creating a PwrConfigValue value, a missing attribute value was detected. "+
					"A PwrConfigValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PwrConfigValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PwrConfigValue Attribute Type",
				"While creating a PwrConfigValue value, an invalid attribute value was detected. "+
					"A PwrConfigValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PwrConfigValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PwrConfigValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PwrConfigValue Attribute Value",
				"While creating a PwrConfigValue value, an extra attribute value was detected. "+
					"A PwrConfigValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PwrConfigValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPwrConfigValueUnknown(), diags
	}

	baseAttribute, ok := attributes["base"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`base is missing from object`)

		return NewPwrConfigValueUnknown(), diags
	}

	baseVal, ok := baseAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`base expected to be basetypes.Int64Value, was: %T`, baseAttribute))
	}

	preferUsbOverWifiAttribute, ok := attributes["prefer_usb_over_wifi"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefer_usb_over_wifi is missing from object`)

		return NewPwrConfigValueUnknown(), diags
	}

	preferUsbOverWifiVal, ok := preferUsbOverWifiAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefer_usb_over_wifi expected to be basetypes.BoolValue, was: %T`, preferUsbOverWifiAttribute))
	}

	if diags.HasError() {
		return NewPwrConfigValueUnknown(), diags
	}

	return PwrConfigValue{
		Base:              baseVal,
		PreferUsbOverWifi: preferUsbOverWifiVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewPwrConfigValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PwrConfigValue {
	object, diags := NewPwrConfigValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPwrConfigValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PwrConfigType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPwrConfigValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPwrConfigValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPwrConfigValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPwrConfigValueMust(PwrConfigValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PwrConfigType) ValueType(ctx context.Context) attr.Value {
	return PwrConfigValue{}
}

var _ basetypes.ObjectValuable = PwrConfigValue{}

type PwrConfigValue struct {
	Base              basetypes.Int64Value `tfsdk:"base"`
	PreferUsbOverWifi basetypes.BoolValue  `tfsdk:"prefer_usb_over_wifi"`
	state             attr.ValueState
}

func (v PwrConfigValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["base"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["prefer_usb_over_wifi"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Base.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["base"] = val

		val, err = v.PreferUsbOverWifi.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["prefer_usb_over_wifi"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PwrConfigValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PwrConfigValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PwrConfigValue) String() string {
	return "PwrConfigValue"
}

func (v PwrConfigValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"base":                 basetypes.Int64Type{},
		"prefer_usb_over_wifi": basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"base":                 v.Base,
			"prefer_usb_over_wifi": v.PreferUsbOverWifi,
		})

	return objVal, diags
}

func (v PwrConfigValue) Equal(o attr.Value) bool {
	other, ok := o.(PwrConfigValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Base.Equal(other.Base) {
		return false
	}

	if !v.PreferUsbOverWifi.Equal(other.PreferUsbOverWifi) {
		return false
	}

	return true
}

func (v PwrConfigValue) Type(ctx context.Context) attr.Type {
	return PwrConfigType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PwrConfigValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"base":                 basetypes.Int64Type{},
		"prefer_usb_over_wifi": basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = RadioConfigType{}

type RadioConfigType struct {
	basetypes.ObjectType
}

func (t RadioConfigType) Equal(o attr.Type) bool {
	other, ok := o.(RadioConfigType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t RadioConfigType) String() string {
	return "RadioConfigType"
}

func (t RadioConfigType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	allowRrmDisableAttribute, ok := attributes["allow_rrm_disable"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allow_rrm_disable is missing from object`)

		return nil, diags
	}

	allowRrmDisableVal, ok := allowRrmDisableAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allow_rrm_disable expected to be basetypes.BoolValue, was: %T`, allowRrmDisableAttribute))
	}

	antGain24Attribute, ok := attributes["ant_gain_24"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ant_gain_24 is missing from object`)

		return nil, diags
	}

	antGain24Val, ok := antGain24Attribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ant_gain_24 expected to be basetypes.Int64Value, was: %T`, antGain24Attribute))
	}

	antGain5Attribute, ok := attributes["ant_gain_5"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ant_gain_5 is missing from object`)

		return nil, diags
	}

	antGain5Val, ok := antGain5Attribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ant_gain_5 expected to be basetypes.Int64Value, was: %T`, antGain5Attribute))
	}

	antGain6Attribute, ok := attributes["ant_gain_6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ant_gain_6 is missing from object`)

		return nil, diags
	}

	antGain6Val, ok := antGain6Attribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ant_gain_6 expected to be basetypes.Int64Value, was: %T`, antGain6Attribute))
	}

	antennaModeAttribute, ok := attributes["antenna_mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`antenna_mode is missing from object`)

		return nil, diags
	}

	antennaModeVal, ok := antennaModeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`antenna_mode expected to be basetypes.StringValue, was: %T`, antennaModeAttribute))
	}

	band24Attribute, ok := attributes["band_24"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`band_24 is missing from object`)

		return nil, diags
	}

	band24Val, ok := band24Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`band_24 expected to be basetypes.ObjectValue, was: %T`, band24Attribute))
	}

	band24UsageAttribute, ok := attributes["band_24_usage"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`band_24_usage is missing from object`)

		return nil, diags
	}

	band24UsageVal, ok := band24UsageAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`band_24_usage expected to be basetypes.StringValue, was: %T`, band24UsageAttribute))
	}

	band5Attribute, ok := attributes["band_5"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`band_5 is missing from object`)

		return nil, diags
	}

	band5Val, ok := band5Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`band_5 expected to be basetypes.ObjectValue, was: %T`, band5Attribute))
	}

	band5On24RadioAttribute, ok := attributes["band_5_on_24_radio"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`band_5_on_24_radio is missing from object`)

		return nil, diags
	}

	band5On24RadioVal, ok := band5On24RadioAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`band_5_on_24_radio expected to be basetypes.ObjectValue, was: %T`, band5On24RadioAttribute))
	}

	band6Attribute, ok := attributes["band_6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`band_6 is missing from object`)

		return nil, diags
	}

	band6Val, ok := band6Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`band_6 expected to be basetypes.ObjectValue, was: %T`, band6Attribute))
	}

	indoorUseAttribute, ok := attributes["indoor_use"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`indoor_use is missing from object`)

		return nil, diags
	}

	indoorUseVal, ok := indoorUseAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`indoor_use expected to be basetypes.BoolValue, was: %T`, indoorUseAttribute))
	}

	scanningEnabledAttribute, ok := attributes["scanning_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`scanning_enabled is missing from object`)

		return nil, diags
	}

	scanningEnabledVal, ok := scanningEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`scanning_enabled expected to be basetypes.BoolValue, was: %T`, scanningEnabledAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return RadioConfigValue{
		AllowRrmDisable: allowRrmDisableVal,
		AntGain24:       antGain24Val,
		AntGain5:        antGain5Val,
		AntGain6:        antGain6Val,
		AntennaMode:     antennaModeVal,
		Band24:          band24Val,
		Band24Usage:     band24UsageVal,
		Band5:           band5Val,
		Band5On24Radio:  band5On24RadioVal,
		Band6:           band6Val,
		IndoorUse:       indoorUseVal,
		ScanningEnabled: scanningEnabledVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewRadioConfigValueNull() RadioConfigValue {
	return RadioConfigValue{
		state: attr.ValueStateNull,
	}
}

func NewRadioConfigValueUnknown() RadioConfigValue {
	return RadioConfigValue{
		state: attr.ValueStateUnknown,
	}
}

func NewRadioConfigValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (RadioConfigValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing RadioConfigValue Attribute Value",
				"While creating a RadioConfigValue value, a missing attribute value was detected. "+
					"A RadioConfigValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RadioConfigValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid RadioConfigValue Attribute Type",
				"While creating a RadioConfigValue value, an invalid attribute value was detected. "+
					"A RadioConfigValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RadioConfigValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("RadioConfigValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra RadioConfigValue Attribute Value",
				"While creating a RadioConfigValue value, an extra attribute value was detected. "+
					"A RadioConfigValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra RadioConfigValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewRadioConfigValueUnknown(), diags
	}

	allowRrmDisableAttribute, ok := attributes["allow_rrm_disable"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allow_rrm_disable is missing from object`)

		return NewRadioConfigValueUnknown(), diags
	}

	allowRrmDisableVal, ok := allowRrmDisableAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allow_rrm_disable expected to be basetypes.BoolValue, was: %T`, allowRrmDisableAttribute))
	}

	antGain24Attribute, ok := attributes["ant_gain_24"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ant_gain_24 is missing from object`)

		return NewRadioConfigValueUnknown(), diags
	}

	antGain24Val, ok := antGain24Attribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ant_gain_24 expected to be basetypes.Int64Value, was: %T`, antGain24Attribute))
	}

	antGain5Attribute, ok := attributes["ant_gain_5"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ant_gain_5 is missing from object`)

		return NewRadioConfigValueUnknown(), diags
	}

	antGain5Val, ok := antGain5Attribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ant_gain_5 expected to be basetypes.Int64Value, was: %T`, antGain5Attribute))
	}

	antGain6Attribute, ok := attributes["ant_gain_6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ant_gain_6 is missing from object`)

		return NewRadioConfigValueUnknown(), diags
	}

	antGain6Val, ok := antGain6Attribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ant_gain_6 expected to be basetypes.Int64Value, was: %T`, antGain6Attribute))
	}

	antennaModeAttribute, ok := attributes["antenna_mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`antenna_mode is missing from object`)

		return NewRadioConfigValueUnknown(), diags
	}

	antennaModeVal, ok := antennaModeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`antenna_mode expected to be basetypes.StringValue, was: %T`, antennaModeAttribute))
	}

	band24Attribute, ok := attributes["band_24"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`band_24 is missing from object`)

		return NewRadioConfigValueUnknown(), diags
	}

	band24Val, ok := band24Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`band_24 expected to be basetypes.ObjectValue, was: %T`, band24Attribute))
	}

	band24UsageAttribute, ok := attributes["band_24_usage"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`band_24_usage is missing from object`)

		return NewRadioConfigValueUnknown(), diags
	}

	band24UsageVal, ok := band24UsageAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`band_24_usage expected to be basetypes.StringValue, was: %T`, band24UsageAttribute))
	}

	band5Attribute, ok := attributes["band_5"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`band_5 is missing from object`)

		return NewRadioConfigValueUnknown(), diags
	}

	band5Val, ok := band5Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`band_5 expected to be basetypes.ObjectValue, was: %T`, band5Attribute))
	}

	band5On24RadioAttribute, ok := attributes["band_5_on_24_radio"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`band_5_on_24_radio is missing from object`)

		return NewRadioConfigValueUnknown(), diags
	}

	band5On24RadioVal, ok := band5On24RadioAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`band_5_on_24_radio expected to be basetypes.ObjectValue, was: %T`, band5On24RadioAttribute))
	}

	band6Attribute, ok := attributes["band_6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`band_6 is missing from object`)

		return NewRadioConfigValueUnknown(), diags
	}

	band6Val, ok := band6Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`band_6 expected to be basetypes.ObjectValue, was: %T`, band6Attribute))
	}

	indoorUseAttribute, ok := attributes["indoor_use"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`indoor_use is missing from object`)

		return NewRadioConfigValueUnknown(), diags
	}

	indoorUseVal, ok := indoorUseAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`indoor_use expected to be basetypes.BoolValue, was: %T`, indoorUseAttribute))
	}

	scanningEnabledAttribute, ok := attributes["scanning_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`scanning_enabled is missing from object`)

		return NewRadioConfigValueUnknown(), diags
	}

	scanningEnabledVal, ok := scanningEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`scanning_enabled expected to be basetypes.BoolValue, was: %T`, scanningEnabledAttribute))
	}

	if diags.HasError() {
		return NewRadioConfigValueUnknown(), diags
	}

	return RadioConfigValue{
		AllowRrmDisable: allowRrmDisableVal,
		AntGain24:       antGain24Val,
		AntGain5:        antGain5Val,
		AntGain6:        antGain6Val,
		AntennaMode:     antennaModeVal,
		Band24:          band24Val,
		Band24Usage:     band24UsageVal,
		Band5:           band5Val,
		Band5On24Radio:  band5On24RadioVal,
		Band6:           band6Val,
		IndoorUse:       indoorUseVal,
		ScanningEnabled: scanningEnabledVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewRadioConfigValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) RadioConfigValue {
	object, diags := NewRadioConfigValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewRadioConfigValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t RadioConfigType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewRadioConfigValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewRadioConfigValueUnknown(), nil
	}

	if in.IsNull() {
		return NewRadioConfigValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewRadioConfigValueMust(RadioConfigValue{}.AttributeTypes(ctx), attributes), nil
}

func (t RadioConfigType) ValueType(ctx context.Context) attr.Value {
	return RadioConfigValue{}
}

var _ basetypes.ObjectValuable = RadioConfigValue{}

type RadioConfigValue struct {
	AllowRrmDisable basetypes.BoolValue   `tfsdk:"allow_rrm_disable"`
	AntGain24       basetypes.Int64Value  `tfsdk:"ant_gain_24"`
	AntGain5        basetypes.Int64Value  `tfsdk:"ant_gain_5"`
	AntGain6        basetypes.Int64Value  `tfsdk:"ant_gain_6"`
	AntennaMode     basetypes.StringValue `tfsdk:"antenna_mode"`
	Band24          basetypes.ObjectValue `tfsdk:"band_24"`
	Band24Usage     basetypes.StringValue `tfsdk:"band_24_usage"`
	Band5           basetypes.ObjectValue `tfsdk:"band_5"`
	Band5On24Radio  basetypes.ObjectValue `tfsdk:"band_5_on_24_radio"`
	Band6           basetypes.ObjectValue `tfsdk:"band_6"`
	IndoorUse       basetypes.BoolValue   `tfsdk:"indoor_use"`
	ScanningEnabled basetypes.BoolValue   `tfsdk:"scanning_enabled"`
	state           attr.ValueState
}

func (v RadioConfigValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 12)

	var val tftypes.Value
	var err error

	attrTypes["allow_rrm_disable"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["ant_gain_24"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["ant_gain_5"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["ant_gain_6"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["antenna_mode"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["band_24"] = basetypes.ObjectType{
		AttrTypes: Band24Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["band_24_usage"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["band_5"] = basetypes.ObjectType{
		AttrTypes: Band5Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["band_5_on_24_radio"] = basetypes.ObjectType{
		AttrTypes: Band5On24RadioValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["band_6"] = basetypes.ObjectType{
		AttrTypes: Band6Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["indoor_use"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["scanning_enabled"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 12)

		val, err = v.AllowRrmDisable.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["allow_rrm_disable"] = val

		val, err = v.AntGain24.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ant_gain_24"] = val

		val, err = v.AntGain5.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ant_gain_5"] = val

		val, err = v.AntGain6.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ant_gain_6"] = val

		val, err = v.AntennaMode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["antenna_mode"] = val

		val, err = v.Band24.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["band_24"] = val

		val, err = v.Band24Usage.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["band_24_usage"] = val

		val, err = v.Band5.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["band_5"] = val

		val, err = v.Band5On24Radio.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["band_5_on_24_radio"] = val

		val, err = v.Band6.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["band_6"] = val

		val, err = v.IndoorUse.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["indoor_use"] = val

		val, err = v.ScanningEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["scanning_enabled"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v RadioConfigValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v RadioConfigValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v RadioConfigValue) String() string {
	return "RadioConfigValue"
}

func (v RadioConfigValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var band24 basetypes.ObjectValue

	if v.Band24.IsNull() {
		band24 = types.ObjectNull(
			Band24Value{}.AttributeTypes(ctx),
		)
	}

	if v.Band24.IsUnknown() {
		band24 = types.ObjectUnknown(
			Band24Value{}.AttributeTypes(ctx),
		)
	}

	if !v.Band24.IsNull() && !v.Band24.IsUnknown() {
		band24 = types.ObjectValueMust(
			Band24Value{}.AttributeTypes(ctx),
			v.Band24.Attributes(),
		)
	}

	var band5 basetypes.ObjectValue

	if v.Band5.IsNull() {
		band5 = types.ObjectNull(
			Band5Value{}.AttributeTypes(ctx),
		)
	}

	if v.Band5.IsUnknown() {
		band5 = types.ObjectUnknown(
			Band5Value{}.AttributeTypes(ctx),
		)
	}

	if !v.Band5.IsNull() && !v.Band5.IsUnknown() {
		band5 = types.ObjectValueMust(
			Band5Value{}.AttributeTypes(ctx),
			v.Band5.Attributes(),
		)
	}

	var band5On24Radio basetypes.ObjectValue

	if v.Band5On24Radio.IsNull() {
		band5On24Radio = types.ObjectNull(
			Band5On24RadioValue{}.AttributeTypes(ctx),
		)
	}

	if v.Band5On24Radio.IsUnknown() {
		band5On24Radio = types.ObjectUnknown(
			Band5On24RadioValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Band5On24Radio.IsNull() && !v.Band5On24Radio.IsUnknown() {
		band5On24Radio = types.ObjectValueMust(
			Band5On24RadioValue{}.AttributeTypes(ctx),
			v.Band5On24Radio.Attributes(),
		)
	}

	var band6 basetypes.ObjectValue

	if v.Band6.IsNull() {
		band6 = types.ObjectNull(
			Band6Value{}.AttributeTypes(ctx),
		)
	}

	if v.Band6.IsUnknown() {
		band6 = types.ObjectUnknown(
			Band6Value{}.AttributeTypes(ctx),
		)
	}

	if !v.Band6.IsNull() && !v.Band6.IsUnknown() {
		band6 = types.ObjectValueMust(
			Band6Value{}.AttributeTypes(ctx),
			v.Band6.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"allow_rrm_disable": basetypes.BoolType{},
		"ant_gain_24":       basetypes.Int64Type{},
		"ant_gain_5":        basetypes.Int64Type{},
		"ant_gain_6":        basetypes.Int64Type{},
		"antenna_mode":      basetypes.StringType{},
		"band_24": basetypes.ObjectType{
			AttrTypes: Band24Value{}.AttributeTypes(ctx),
		},
		"band_24_usage": basetypes.StringType{},
		"band_5": basetypes.ObjectType{
			AttrTypes: Band5Value{}.AttributeTypes(ctx),
		},
		"band_5_on_24_radio": basetypes.ObjectType{
			AttrTypes: Band5On24RadioValue{}.AttributeTypes(ctx),
		},
		"band_6": basetypes.ObjectType{
			AttrTypes: Band6Value{}.AttributeTypes(ctx),
		},
		"indoor_use":       basetypes.BoolType{},
		"scanning_enabled": basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"allow_rrm_disable":  v.AllowRrmDisable,
			"ant_gain_24":        v.AntGain24,
			"ant_gain_5":         v.AntGain5,
			"ant_gain_6":         v.AntGain6,
			"antenna_mode":       v.AntennaMode,
			"band_24":            band24,
			"band_24_usage":      v.Band24Usage,
			"band_5":             band5,
			"band_5_on_24_radio": band5On24Radio,
			"band_6":             band6,
			"indoor_use":         v.IndoorUse,
			"scanning_enabled":   v.ScanningEnabled,
		})

	return objVal, diags
}

func (v RadioConfigValue) Equal(o attr.Value) bool {
	other, ok := o.(RadioConfigValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AllowRrmDisable.Equal(other.AllowRrmDisable) {
		return false
	}

	if !v.AntGain24.Equal(other.AntGain24) {
		return false
	}

	if !v.AntGain5.Equal(other.AntGain5) {
		return false
	}

	if !v.AntGain6.Equal(other.AntGain6) {
		return false
	}

	if !v.AntennaMode.Equal(other.AntennaMode) {
		return false
	}

	if !v.Band24.Equal(other.Band24) {
		return false
	}

	if !v.Band24Usage.Equal(other.Band24Usage) {
		return false
	}

	if !v.Band5.Equal(other.Band5) {
		return false
	}

	if !v.Band5On24Radio.Equal(other.Band5On24Radio) {
		return false
	}

	if !v.Band6.Equal(other.Band6) {
		return false
	}

	if !v.IndoorUse.Equal(other.IndoorUse) {
		return false
	}

	if !v.ScanningEnabled.Equal(other.ScanningEnabled) {
		return false
	}

	return true
}

func (v RadioConfigValue) Type(ctx context.Context) attr.Type {
	return RadioConfigType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v RadioConfigValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"allow_rrm_disable": basetypes.BoolType{},
		"ant_gain_24":       basetypes.Int64Type{},
		"ant_gain_5":        basetypes.Int64Type{},
		"ant_gain_6":        basetypes.Int64Type{},
		"antenna_mode":      basetypes.StringType{},
		"band_24": basetypes.ObjectType{
			AttrTypes: Band24Value{}.AttributeTypes(ctx),
		},
		"band_24_usage": basetypes.StringType{},
		"band_5": basetypes.ObjectType{
			AttrTypes: Band5Value{}.AttributeTypes(ctx),
		},
		"band_5_on_24_radio": basetypes.ObjectType{
			AttrTypes: Band5On24RadioValue{}.AttributeTypes(ctx),
		},
		"band_6": basetypes.ObjectType{
			AttrTypes: Band6Value{}.AttributeTypes(ctx),
		},
		"indoor_use":       basetypes.BoolType{},
		"scanning_enabled": basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = Band24Type{}

type Band24Type struct {
	basetypes.ObjectType
}

func (t Band24Type) Equal(o attr.Type) bool {
	other, ok := o.(Band24Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Band24Type) String() string {
	return "Band24Type"
}

func (t Band24Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	allowRrmDisableAttribute, ok := attributes["allow_rrm_disable"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allow_rrm_disable is missing from object`)

		return nil, diags
	}

	allowRrmDisableVal, ok := allowRrmDisableAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allow_rrm_disable expected to be basetypes.BoolValue, was: %T`, allowRrmDisableAttribute))
	}

	antGainAttribute, ok := attributes["ant_gain"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ant_gain is missing from object`)

		return nil, diags
	}

	antGainVal, ok := antGainAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ant_gain expected to be basetypes.Int64Value, was: %T`, antGainAttribute))
	}

	antennaModeAttribute, ok := attributes["antenna_mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`antenna_mode is missing from object`)

		return nil, diags
	}

	antennaModeVal, ok := antennaModeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`antenna_mode expected to be basetypes.StringValue, was: %T`, antennaModeAttribute))
	}

	bandwidthAttribute, ok := attributes["bandwidth"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bandwidth is missing from object`)

		return nil, diags
	}

	bandwidthVal, ok := bandwidthAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bandwidth expected to be basetypes.Int64Value, was: %T`, bandwidthAttribute))
	}

	channelAttribute, ok := attributes["channel"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`channel is missing from object`)

		return nil, diags
	}

	channelVal, ok := channelAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`channel expected to be basetypes.Int64Value, was: %T`, channelAttribute))
	}

	channelsAttribute, ok := attributes["channels"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`channels is missing from object`)

		return nil, diags
	}

	channelsVal, ok := channelsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`channels expected to be basetypes.ListValue, was: %T`, channelsAttribute))
	}

	disabledAttribute, ok := attributes["disabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disabled is missing from object`)

		return nil, diags
	}

	disabledVal, ok := disabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disabled expected to be basetypes.BoolValue, was: %T`, disabledAttribute))
	}

	powerAttribute, ok := attributes["power"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`power is missing from object`)

		return nil, diags
	}

	powerVal, ok := powerAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`power expected to be basetypes.Int64Value, was: %T`, powerAttribute))
	}

	powerMaxAttribute, ok := attributes["power_max"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`power_max is missing from object`)

		return nil, diags
	}

	powerMaxVal, ok := powerMaxAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`power_max expected to be basetypes.Int64Value, was: %T`, powerMaxAttribute))
	}

	powerMinAttribute, ok := attributes["power_min"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`power_min is missing from object`)

		return nil, diags
	}

	powerMinVal, ok := powerMinAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`power_min expected to be basetypes.Int64Value, was: %T`, powerMinAttribute))
	}

	preambleAttribute, ok := attributes["preamble"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`preamble is missing from object`)

		return nil, diags
	}

	preambleVal, ok := preambleAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`preamble expected to be basetypes.StringValue, was: %T`, preambleAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Band24Value{
		AllowRrmDisable: allowRrmDisableVal,
		AntGain:         antGainVal,
		AntennaMode:     antennaModeVal,
		Bandwidth:       bandwidthVal,
		Channel:         channelVal,
		Channels:        channelsVal,
		Disabled:        disabledVal,
		Power:           powerVal,
		PowerMax:        powerMaxVal,
		PowerMin:        powerMinVal,
		Preamble:        preambleVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewBand24ValueNull() Band24Value {
	return Band24Value{
		state: attr.ValueStateNull,
	}
}

func NewBand24ValueUnknown() Band24Value {
	return Band24Value{
		state: attr.ValueStateUnknown,
	}
}

func NewBand24Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Band24Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Band24Value Attribute Value",
				"While creating a Band24Value value, a missing attribute value was detected. "+
					"A Band24Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Band24Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Band24Value Attribute Type",
				"While creating a Band24Value value, an invalid attribute value was detected. "+
					"A Band24Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Band24Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Band24Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Band24Value Attribute Value",
				"While creating a Band24Value value, an extra attribute value was detected. "+
					"A Band24Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Band24Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewBand24ValueUnknown(), diags
	}

	allowRrmDisableAttribute, ok := attributes["allow_rrm_disable"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allow_rrm_disable is missing from object`)

		return NewBand24ValueUnknown(), diags
	}

	allowRrmDisableVal, ok := allowRrmDisableAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allow_rrm_disable expected to be basetypes.BoolValue, was: %T`, allowRrmDisableAttribute))
	}

	antGainAttribute, ok := attributes["ant_gain"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ant_gain is missing from object`)

		return NewBand24ValueUnknown(), diags
	}

	antGainVal, ok := antGainAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ant_gain expected to be basetypes.Int64Value, was: %T`, antGainAttribute))
	}

	antennaModeAttribute, ok := attributes["antenna_mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`antenna_mode is missing from object`)

		return NewBand24ValueUnknown(), diags
	}

	antennaModeVal, ok := antennaModeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`antenna_mode expected to be basetypes.StringValue, was: %T`, antennaModeAttribute))
	}

	bandwidthAttribute, ok := attributes["bandwidth"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bandwidth is missing from object`)

		return NewBand24ValueUnknown(), diags
	}

	bandwidthVal, ok := bandwidthAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bandwidth expected to be basetypes.Int64Value, was: %T`, bandwidthAttribute))
	}

	channelAttribute, ok := attributes["channel"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`channel is missing from object`)

		return NewBand24ValueUnknown(), diags
	}

	channelVal, ok := channelAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`channel expected to be basetypes.Int64Value, was: %T`, channelAttribute))
	}

	channelsAttribute, ok := attributes["channels"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`channels is missing from object`)

		return NewBand24ValueUnknown(), diags
	}

	channelsVal, ok := channelsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`channels expected to be basetypes.ListValue, was: %T`, channelsAttribute))
	}

	disabledAttribute, ok := attributes["disabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disabled is missing from object`)

		return NewBand24ValueUnknown(), diags
	}

	disabledVal, ok := disabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disabled expected to be basetypes.BoolValue, was: %T`, disabledAttribute))
	}

	powerAttribute, ok := attributes["power"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`power is missing from object`)

		return NewBand24ValueUnknown(), diags
	}

	powerVal, ok := powerAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`power expected to be basetypes.Int64Value, was: %T`, powerAttribute))
	}

	powerMaxAttribute, ok := attributes["power_max"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`power_max is missing from object`)

		return NewBand24ValueUnknown(), diags
	}

	powerMaxVal, ok := powerMaxAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`power_max expected to be basetypes.Int64Value, was: %T`, powerMaxAttribute))
	}

	powerMinAttribute, ok := attributes["power_min"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`power_min is missing from object`)

		return NewBand24ValueUnknown(), diags
	}

	powerMinVal, ok := powerMinAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`power_min expected to be basetypes.Int64Value, was: %T`, powerMinAttribute))
	}

	preambleAttribute, ok := attributes["preamble"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`preamble is missing from object`)

		return NewBand24ValueUnknown(), diags
	}

	preambleVal, ok := preambleAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`preamble expected to be basetypes.StringValue, was: %T`, preambleAttribute))
	}

	if diags.HasError() {
		return NewBand24ValueUnknown(), diags
	}

	return Band24Value{
		AllowRrmDisable: allowRrmDisableVal,
		AntGain:         antGainVal,
		AntennaMode:     antennaModeVal,
		Bandwidth:       bandwidthVal,
		Channel:         channelVal,
		Channels:        channelsVal,
		Disabled:        disabledVal,
		Power:           powerVal,
		PowerMax:        powerMaxVal,
		PowerMin:        powerMinVal,
		Preamble:        preambleVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewBand24ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Band24Value {
	object, diags := NewBand24Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewBand24ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Band24Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewBand24ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewBand24ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewBand24ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewBand24ValueMust(Band24Value{}.AttributeTypes(ctx), attributes), nil
}

func (t Band24Type) ValueType(ctx context.Context) attr.Value {
	return Band24Value{}
}

var _ basetypes.ObjectValuable = Band24Value{}

type Band24Value struct {
	AllowRrmDisable basetypes.BoolValue   `tfsdk:"allow_rrm_disable"`
	AntGain         basetypes.Int64Value  `tfsdk:"ant_gain"`
	AntennaMode     basetypes.StringValue `tfsdk:"antenna_mode"`
	Bandwidth       basetypes.Int64Value  `tfsdk:"bandwidth"`
	Channel         basetypes.Int64Value  `tfsdk:"channel"`
	Channels        basetypes.ListValue   `tfsdk:"channels"`
	Disabled        basetypes.BoolValue   `tfsdk:"disabled"`
	Power           basetypes.Int64Value  `tfsdk:"power"`
	PowerMax        basetypes.Int64Value  `tfsdk:"power_max"`
	PowerMin        basetypes.Int64Value  `tfsdk:"power_min"`
	Preamble        basetypes.StringValue `tfsdk:"preamble"`
	state           attr.ValueState
}

func (v Band24Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 11)

	var val tftypes.Value
	var err error

	attrTypes["allow_rrm_disable"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["ant_gain"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["antenna_mode"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["bandwidth"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["channel"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["channels"] = basetypes.ListType{
		ElemType: types.Int64Type,
	}.TerraformType(ctx)
	attrTypes["disabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["power"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["power_max"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["power_min"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["preamble"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 11)

		val, err = v.AllowRrmDisable.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["allow_rrm_disable"] = val

		val, err = v.AntGain.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ant_gain"] = val

		val, err = v.AntennaMode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["antenna_mode"] = val

		val, err = v.Bandwidth.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bandwidth"] = val

		val, err = v.Channel.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["channel"] = val

		val, err = v.Channels.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["channels"] = val

		val, err = v.Disabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["disabled"] = val

		val, err = v.Power.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["power"] = val

		val, err = v.PowerMax.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["power_max"] = val

		val, err = v.PowerMin.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["power_min"] = val

		val, err = v.Preamble.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["preamble"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Band24Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Band24Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Band24Value) String() string {
	return "Band24Value"
}

func (v Band24Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	channelsVal, d := types.ListValue(types.Int64Type, v.Channels.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"allow_rrm_disable": basetypes.BoolType{},
			"ant_gain":          basetypes.Int64Type{},
			"antenna_mode":      basetypes.StringType{},
			"bandwidth":         basetypes.Int64Type{},
			"channel":           basetypes.Int64Type{},
			"channels": basetypes.ListType{
				ElemType: types.Int64Type,
			},
			"disabled":  basetypes.BoolType{},
			"power":     basetypes.Int64Type{},
			"power_max": basetypes.Int64Type{},
			"power_min": basetypes.Int64Type{},
			"preamble":  basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"allow_rrm_disable": basetypes.BoolType{},
		"ant_gain":          basetypes.Int64Type{},
		"antenna_mode":      basetypes.StringType{},
		"bandwidth":         basetypes.Int64Type{},
		"channel":           basetypes.Int64Type{},
		"channels": basetypes.ListType{
			ElemType: types.Int64Type,
		},
		"disabled":  basetypes.BoolType{},
		"power":     basetypes.Int64Type{},
		"power_max": basetypes.Int64Type{},
		"power_min": basetypes.Int64Type{},
		"preamble":  basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"allow_rrm_disable": v.AllowRrmDisable,
			"ant_gain":          v.AntGain,
			"antenna_mode":      v.AntennaMode,
			"bandwidth":         v.Bandwidth,
			"channel":           v.Channel,
			"channels":          channelsVal,
			"disabled":          v.Disabled,
			"power":             v.Power,
			"power_max":         v.PowerMax,
			"power_min":         v.PowerMin,
			"preamble":          v.Preamble,
		})

	return objVal, diags
}

func (v Band24Value) Equal(o attr.Value) bool {
	other, ok := o.(Band24Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AllowRrmDisable.Equal(other.AllowRrmDisable) {
		return false
	}

	if !v.AntGain.Equal(other.AntGain) {
		return false
	}

	if !v.AntennaMode.Equal(other.AntennaMode) {
		return false
	}

	if !v.Bandwidth.Equal(other.Bandwidth) {
		return false
	}

	if !v.Channel.Equal(other.Channel) {
		return false
	}

	if !v.Channels.Equal(other.Channels) {
		return false
	}

	if !v.Disabled.Equal(other.Disabled) {
		return false
	}

	if !v.Power.Equal(other.Power) {
		return false
	}

	if !v.PowerMax.Equal(other.PowerMax) {
		return false
	}

	if !v.PowerMin.Equal(other.PowerMin) {
		return false
	}

	if !v.Preamble.Equal(other.Preamble) {
		return false
	}

	return true
}

func (v Band24Value) Type(ctx context.Context) attr.Type {
	return Band24Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Band24Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"allow_rrm_disable": basetypes.BoolType{},
		"ant_gain":          basetypes.Int64Type{},
		"antenna_mode":      basetypes.StringType{},
		"bandwidth":         basetypes.Int64Type{},
		"channel":           basetypes.Int64Type{},
		"channels": basetypes.ListType{
			ElemType: types.Int64Type,
		},
		"disabled":  basetypes.BoolType{},
		"power":     basetypes.Int64Type{},
		"power_max": basetypes.Int64Type{},
		"power_min": basetypes.Int64Type{},
		"preamble":  basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = Band5Type{}

type Band5Type struct {
	basetypes.ObjectType
}

func (t Band5Type) Equal(o attr.Type) bool {
	other, ok := o.(Band5Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Band5Type) String() string {
	return "Band5Type"
}

func (t Band5Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	allowRrmDisableAttribute, ok := attributes["allow_rrm_disable"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allow_rrm_disable is missing from object`)

		return nil, diags
	}

	allowRrmDisableVal, ok := allowRrmDisableAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allow_rrm_disable expected to be basetypes.BoolValue, was: %T`, allowRrmDisableAttribute))
	}

	antGainAttribute, ok := attributes["ant_gain"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ant_gain is missing from object`)

		return nil, diags
	}

	antGainVal, ok := antGainAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ant_gain expected to be basetypes.Int64Value, was: %T`, antGainAttribute))
	}

	antennaModeAttribute, ok := attributes["antenna_mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`antenna_mode is missing from object`)

		return nil, diags
	}

	antennaModeVal, ok := antennaModeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`antenna_mode expected to be basetypes.StringValue, was: %T`, antennaModeAttribute))
	}

	bandwidthAttribute, ok := attributes["bandwidth"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bandwidth is missing from object`)

		return nil, diags
	}

	bandwidthVal, ok := bandwidthAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bandwidth expected to be basetypes.Int64Value, was: %T`, bandwidthAttribute))
	}

	channelAttribute, ok := attributes["channel"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`channel is missing from object`)

		return nil, diags
	}

	channelVal, ok := channelAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`channel expected to be basetypes.Int64Value, was: %T`, channelAttribute))
	}

	channelsAttribute, ok := attributes["channels"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`channels is missing from object`)

		return nil, diags
	}

	channelsVal, ok := channelsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`channels expected to be basetypes.ListValue, was: %T`, channelsAttribute))
	}

	disabledAttribute, ok := attributes["disabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disabled is missing from object`)

		return nil, diags
	}

	disabledVal, ok := disabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disabled expected to be basetypes.BoolValue, was: %T`, disabledAttribute))
	}

	powerAttribute, ok := attributes["power"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`power is missing from object`)

		return nil, diags
	}

	powerVal, ok := powerAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`power expected to be basetypes.Int64Value, was: %T`, powerAttribute))
	}

	powerMaxAttribute, ok := attributes["power_max"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`power_max is missing from object`)

		return nil, diags
	}

	powerMaxVal, ok := powerMaxAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`power_max expected to be basetypes.Int64Value, was: %T`, powerMaxAttribute))
	}

	powerMinAttribute, ok := attributes["power_min"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`power_min is missing from object`)

		return nil, diags
	}

	powerMinVal, ok := powerMinAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`power_min expected to be basetypes.Int64Value, was: %T`, powerMinAttribute))
	}

	preambleAttribute, ok := attributes["preamble"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`preamble is missing from object`)

		return nil, diags
	}

	preambleVal, ok := preambleAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`preamble expected to be basetypes.StringValue, was: %T`, preambleAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Band5Value{
		AllowRrmDisable: allowRrmDisableVal,
		AntGain:         antGainVal,
		AntennaMode:     antennaModeVal,
		Bandwidth:       bandwidthVal,
		Channel:         channelVal,
		Channels:        channelsVal,
		Disabled:        disabledVal,
		Power:           powerVal,
		PowerMax:        powerMaxVal,
		PowerMin:        powerMinVal,
		Preamble:        preambleVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewBand5ValueNull() Band5Value {
	return Band5Value{
		state: attr.ValueStateNull,
	}
}

func NewBand5ValueUnknown() Band5Value {
	return Band5Value{
		state: attr.ValueStateUnknown,
	}
}

func NewBand5Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Band5Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Band5Value Attribute Value",
				"While creating a Band5Value value, a missing attribute value was detected. "+
					"A Band5Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Band5Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Band5Value Attribute Type",
				"While creating a Band5Value value, an invalid attribute value was detected. "+
					"A Band5Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Band5Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Band5Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Band5Value Attribute Value",
				"While creating a Band5Value value, an extra attribute value was detected. "+
					"A Band5Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Band5Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewBand5ValueUnknown(), diags
	}

	allowRrmDisableAttribute, ok := attributes["allow_rrm_disable"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allow_rrm_disable is missing from object`)

		return NewBand5ValueUnknown(), diags
	}

	allowRrmDisableVal, ok := allowRrmDisableAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allow_rrm_disable expected to be basetypes.BoolValue, was: %T`, allowRrmDisableAttribute))
	}

	antGainAttribute, ok := attributes["ant_gain"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ant_gain is missing from object`)

		return NewBand5ValueUnknown(), diags
	}

	antGainVal, ok := antGainAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ant_gain expected to be basetypes.Int64Value, was: %T`, antGainAttribute))
	}

	antennaModeAttribute, ok := attributes["antenna_mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`antenna_mode is missing from object`)

		return NewBand5ValueUnknown(), diags
	}

	antennaModeVal, ok := antennaModeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`antenna_mode expected to be basetypes.StringValue, was: %T`, antennaModeAttribute))
	}

	bandwidthAttribute, ok := attributes["bandwidth"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bandwidth is missing from object`)

		return NewBand5ValueUnknown(), diags
	}

	bandwidthVal, ok := bandwidthAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bandwidth expected to be basetypes.Int64Value, was: %T`, bandwidthAttribute))
	}

	channelAttribute, ok := attributes["channel"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`channel is missing from object`)

		return NewBand5ValueUnknown(), diags
	}

	channelVal, ok := channelAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`channel expected to be basetypes.Int64Value, was: %T`, channelAttribute))
	}

	channelsAttribute, ok := attributes["channels"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`channels is missing from object`)

		return NewBand5ValueUnknown(), diags
	}

	channelsVal, ok := channelsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`channels expected to be basetypes.ListValue, was: %T`, channelsAttribute))
	}

	disabledAttribute, ok := attributes["disabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disabled is missing from object`)

		return NewBand5ValueUnknown(), diags
	}

	disabledVal, ok := disabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disabled expected to be basetypes.BoolValue, was: %T`, disabledAttribute))
	}

	powerAttribute, ok := attributes["power"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`power is missing from object`)

		return NewBand5ValueUnknown(), diags
	}

	powerVal, ok := powerAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`power expected to be basetypes.Int64Value, was: %T`, powerAttribute))
	}

	powerMaxAttribute, ok := attributes["power_max"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`power_max is missing from object`)

		return NewBand5ValueUnknown(), diags
	}

	powerMaxVal, ok := powerMaxAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`power_max expected to be basetypes.Int64Value, was: %T`, powerMaxAttribute))
	}

	powerMinAttribute, ok := attributes["power_min"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`power_min is missing from object`)

		return NewBand5ValueUnknown(), diags
	}

	powerMinVal, ok := powerMinAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`power_min expected to be basetypes.Int64Value, was: %T`, powerMinAttribute))
	}

	preambleAttribute, ok := attributes["preamble"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`preamble is missing from object`)

		return NewBand5ValueUnknown(), diags
	}

	preambleVal, ok := preambleAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`preamble expected to be basetypes.StringValue, was: %T`, preambleAttribute))
	}

	if diags.HasError() {
		return NewBand5ValueUnknown(), diags
	}

	return Band5Value{
		AllowRrmDisable: allowRrmDisableVal,
		AntGain:         antGainVal,
		AntennaMode:     antennaModeVal,
		Bandwidth:       bandwidthVal,
		Channel:         channelVal,
		Channels:        channelsVal,
		Disabled:        disabledVal,
		Power:           powerVal,
		PowerMax:        powerMaxVal,
		PowerMin:        powerMinVal,
		Preamble:        preambleVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewBand5ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Band5Value {
	object, diags := NewBand5Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewBand5ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Band5Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewBand5ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewBand5ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewBand5ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewBand5ValueMust(Band5Value{}.AttributeTypes(ctx), attributes), nil
}

func (t Band5Type) ValueType(ctx context.Context) attr.Value {
	return Band5Value{}
}

var _ basetypes.ObjectValuable = Band5Value{}

type Band5Value struct {
	AllowRrmDisable basetypes.BoolValue   `tfsdk:"allow_rrm_disable"`
	AntGain         basetypes.Int64Value  `tfsdk:"ant_gain"`
	AntennaMode     basetypes.StringValue `tfsdk:"antenna_mode"`
	Bandwidth       basetypes.Int64Value  `tfsdk:"bandwidth"`
	Channel         basetypes.Int64Value  `tfsdk:"channel"`
	Channels        basetypes.ListValue   `tfsdk:"channels"`
	Disabled        basetypes.BoolValue   `tfsdk:"disabled"`
	Power           basetypes.Int64Value  `tfsdk:"power"`
	PowerMax        basetypes.Int64Value  `tfsdk:"power_max"`
	PowerMin        basetypes.Int64Value  `tfsdk:"power_min"`
	Preamble        basetypes.StringValue `tfsdk:"preamble"`
	state           attr.ValueState
}

func (v Band5Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 11)

	var val tftypes.Value
	var err error

	attrTypes["allow_rrm_disable"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["ant_gain"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["antenna_mode"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["bandwidth"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["channel"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["channels"] = basetypes.ListType{
		ElemType: types.Int64Type,
	}.TerraformType(ctx)
	attrTypes["disabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["power"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["power_max"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["power_min"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["preamble"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 11)

		val, err = v.AllowRrmDisable.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["allow_rrm_disable"] = val

		val, err = v.AntGain.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ant_gain"] = val

		val, err = v.AntennaMode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["antenna_mode"] = val

		val, err = v.Bandwidth.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bandwidth"] = val

		val, err = v.Channel.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["channel"] = val

		val, err = v.Channels.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["channels"] = val

		val, err = v.Disabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["disabled"] = val

		val, err = v.Power.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["power"] = val

		val, err = v.PowerMax.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["power_max"] = val

		val, err = v.PowerMin.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["power_min"] = val

		val, err = v.Preamble.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["preamble"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Band5Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Band5Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Band5Value) String() string {
	return "Band5Value"
}

func (v Band5Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	channelsVal, d := types.ListValue(types.Int64Type, v.Channels.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"allow_rrm_disable": basetypes.BoolType{},
			"ant_gain":          basetypes.Int64Type{},
			"antenna_mode":      basetypes.StringType{},
			"bandwidth":         basetypes.Int64Type{},
			"channel":           basetypes.Int64Type{},
			"channels": basetypes.ListType{
				ElemType: types.Int64Type,
			},
			"disabled":  basetypes.BoolType{},
			"power":     basetypes.Int64Type{},
			"power_max": basetypes.Int64Type{},
			"power_min": basetypes.Int64Type{},
			"preamble":  basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"allow_rrm_disable": basetypes.BoolType{},
		"ant_gain":          basetypes.Int64Type{},
		"antenna_mode":      basetypes.StringType{},
		"bandwidth":         basetypes.Int64Type{},
		"channel":           basetypes.Int64Type{},
		"channels": basetypes.ListType{
			ElemType: types.Int64Type,
		},
		"disabled":  basetypes.BoolType{},
		"power":     basetypes.Int64Type{},
		"power_max": basetypes.Int64Type{},
		"power_min": basetypes.Int64Type{},
		"preamble":  basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"allow_rrm_disable": v.AllowRrmDisable,
			"ant_gain":          v.AntGain,
			"antenna_mode":      v.AntennaMode,
			"bandwidth":         v.Bandwidth,
			"channel":           v.Channel,
			"channels":          channelsVal,
			"disabled":          v.Disabled,
			"power":             v.Power,
			"power_max":         v.PowerMax,
			"power_min":         v.PowerMin,
			"preamble":          v.Preamble,
		})

	return objVal, diags
}

func (v Band5Value) Equal(o attr.Value) bool {
	other, ok := o.(Band5Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AllowRrmDisable.Equal(other.AllowRrmDisable) {
		return false
	}

	if !v.AntGain.Equal(other.AntGain) {
		return false
	}

	if !v.AntennaMode.Equal(other.AntennaMode) {
		return false
	}

	if !v.Bandwidth.Equal(other.Bandwidth) {
		return false
	}

	if !v.Channel.Equal(other.Channel) {
		return false
	}

	if !v.Channels.Equal(other.Channels) {
		return false
	}

	if !v.Disabled.Equal(other.Disabled) {
		return false
	}

	if !v.Power.Equal(other.Power) {
		return false
	}

	if !v.PowerMax.Equal(other.PowerMax) {
		return false
	}

	if !v.PowerMin.Equal(other.PowerMin) {
		return false
	}

	if !v.Preamble.Equal(other.Preamble) {
		return false
	}

	return true
}

func (v Band5Value) Type(ctx context.Context) attr.Type {
	return Band5Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Band5Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"allow_rrm_disable": basetypes.BoolType{},
		"ant_gain":          basetypes.Int64Type{},
		"antenna_mode":      basetypes.StringType{},
		"bandwidth":         basetypes.Int64Type{},
		"channel":           basetypes.Int64Type{},
		"channels": basetypes.ListType{
			ElemType: types.Int64Type,
		},
		"disabled":  basetypes.BoolType{},
		"power":     basetypes.Int64Type{},
		"power_max": basetypes.Int64Type{},
		"power_min": basetypes.Int64Type{},
		"preamble":  basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = Band5On24RadioType{}

type Band5On24RadioType struct {
	basetypes.ObjectType
}

func (t Band5On24RadioType) Equal(o attr.Type) bool {
	other, ok := o.(Band5On24RadioType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Band5On24RadioType) String() string {
	return "Band5On24RadioType"
}

func (t Band5On24RadioType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	allowRrmDisableAttribute, ok := attributes["allow_rrm_disable"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allow_rrm_disable is missing from object`)

		return nil, diags
	}

	allowRrmDisableVal, ok := allowRrmDisableAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allow_rrm_disable expected to be basetypes.BoolValue, was: %T`, allowRrmDisableAttribute))
	}

	antGainAttribute, ok := attributes["ant_gain"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ant_gain is missing from object`)

		return nil, diags
	}

	antGainVal, ok := antGainAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ant_gain expected to be basetypes.Int64Value, was: %T`, antGainAttribute))
	}

	antennaModeAttribute, ok := attributes["antenna_mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`antenna_mode is missing from object`)

		return nil, diags
	}

	antennaModeVal, ok := antennaModeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`antenna_mode expected to be basetypes.StringValue, was: %T`, antennaModeAttribute))
	}

	bandwidthAttribute, ok := attributes["bandwidth"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bandwidth is missing from object`)

		return nil, diags
	}

	bandwidthVal, ok := bandwidthAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bandwidth expected to be basetypes.Int64Value, was: %T`, bandwidthAttribute))
	}

	channelAttribute, ok := attributes["channel"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`channel is missing from object`)

		return nil, diags
	}

	channelVal, ok := channelAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`channel expected to be basetypes.Int64Value, was: %T`, channelAttribute))
	}

	channelsAttribute, ok := attributes["channels"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`channels is missing from object`)

		return nil, diags
	}

	channelsVal, ok := channelsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`channels expected to be basetypes.ListValue, was: %T`, channelsAttribute))
	}

	disabledAttribute, ok := attributes["disabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disabled is missing from object`)

		return nil, diags
	}

	disabledVal, ok := disabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disabled expected to be basetypes.BoolValue, was: %T`, disabledAttribute))
	}

	powerAttribute, ok := attributes["power"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`power is missing from object`)

		return nil, diags
	}

	powerVal, ok := powerAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`power expected to be basetypes.Int64Value, was: %T`, powerAttribute))
	}

	powerMaxAttribute, ok := attributes["power_max"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`power_max is missing from object`)

		return nil, diags
	}

	powerMaxVal, ok := powerMaxAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`power_max expected to be basetypes.Int64Value, was: %T`, powerMaxAttribute))
	}

	powerMinAttribute, ok := attributes["power_min"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`power_min is missing from object`)

		return nil, diags
	}

	powerMinVal, ok := powerMinAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`power_min expected to be basetypes.Int64Value, was: %T`, powerMinAttribute))
	}

	preambleAttribute, ok := attributes["preamble"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`preamble is missing from object`)

		return nil, diags
	}

	preambleVal, ok := preambleAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`preamble expected to be basetypes.StringValue, was: %T`, preambleAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Band5On24RadioValue{
		AllowRrmDisable: allowRrmDisableVal,
		AntGain:         antGainVal,
		AntennaMode:     antennaModeVal,
		Bandwidth:       bandwidthVal,
		Channel:         channelVal,
		Channels:        channelsVal,
		Disabled:        disabledVal,
		Power:           powerVal,
		PowerMax:        powerMaxVal,
		PowerMin:        powerMinVal,
		Preamble:        preambleVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewBand5On24RadioValueNull() Band5On24RadioValue {
	return Band5On24RadioValue{
		state: attr.ValueStateNull,
	}
}

func NewBand5On24RadioValueUnknown() Band5On24RadioValue {
	return Band5On24RadioValue{
		state: attr.ValueStateUnknown,
	}
}

func NewBand5On24RadioValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Band5On24RadioValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Band5On24RadioValue Attribute Value",
				"While creating a Band5On24RadioValue value, a missing attribute value was detected. "+
					"A Band5On24RadioValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Band5On24RadioValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Band5On24RadioValue Attribute Type",
				"While creating a Band5On24RadioValue value, an invalid attribute value was detected. "+
					"A Band5On24RadioValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Band5On24RadioValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Band5On24RadioValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Band5On24RadioValue Attribute Value",
				"While creating a Band5On24RadioValue value, an extra attribute value was detected. "+
					"A Band5On24RadioValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Band5On24RadioValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewBand5On24RadioValueUnknown(), diags
	}

	allowRrmDisableAttribute, ok := attributes["allow_rrm_disable"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allow_rrm_disable is missing from object`)

		return NewBand5On24RadioValueUnknown(), diags
	}

	allowRrmDisableVal, ok := allowRrmDisableAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allow_rrm_disable expected to be basetypes.BoolValue, was: %T`, allowRrmDisableAttribute))
	}

	antGainAttribute, ok := attributes["ant_gain"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ant_gain is missing from object`)

		return NewBand5On24RadioValueUnknown(), diags
	}

	antGainVal, ok := antGainAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ant_gain expected to be basetypes.Int64Value, was: %T`, antGainAttribute))
	}

	antennaModeAttribute, ok := attributes["antenna_mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`antenna_mode is missing from object`)

		return NewBand5On24RadioValueUnknown(), diags
	}

	antennaModeVal, ok := antennaModeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`antenna_mode expected to be basetypes.StringValue, was: %T`, antennaModeAttribute))
	}

	bandwidthAttribute, ok := attributes["bandwidth"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bandwidth is missing from object`)

		return NewBand5On24RadioValueUnknown(), diags
	}

	bandwidthVal, ok := bandwidthAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bandwidth expected to be basetypes.Int64Value, was: %T`, bandwidthAttribute))
	}

	channelAttribute, ok := attributes["channel"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`channel is missing from object`)

		return NewBand5On24RadioValueUnknown(), diags
	}

	channelVal, ok := channelAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`channel expected to be basetypes.Int64Value, was: %T`, channelAttribute))
	}

	channelsAttribute, ok := attributes["channels"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`channels is missing from object`)

		return NewBand5On24RadioValueUnknown(), diags
	}

	channelsVal, ok := channelsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`channels expected to be basetypes.ListValue, was: %T`, channelsAttribute))
	}

	disabledAttribute, ok := attributes["disabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disabled is missing from object`)

		return NewBand5On24RadioValueUnknown(), diags
	}

	disabledVal, ok := disabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disabled expected to be basetypes.BoolValue, was: %T`, disabledAttribute))
	}

	powerAttribute, ok := attributes["power"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`power is missing from object`)

		return NewBand5On24RadioValueUnknown(), diags
	}

	powerVal, ok := powerAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`power expected to be basetypes.Int64Value, was: %T`, powerAttribute))
	}

	powerMaxAttribute, ok := attributes["power_max"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`power_max is missing from object`)

		return NewBand5On24RadioValueUnknown(), diags
	}

	powerMaxVal, ok := powerMaxAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`power_max expected to be basetypes.Int64Value, was: %T`, powerMaxAttribute))
	}

	powerMinAttribute, ok := attributes["power_min"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`power_min is missing from object`)

		return NewBand5On24RadioValueUnknown(), diags
	}

	powerMinVal, ok := powerMinAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`power_min expected to be basetypes.Int64Value, was: %T`, powerMinAttribute))
	}

	preambleAttribute, ok := attributes["preamble"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`preamble is missing from object`)

		return NewBand5On24RadioValueUnknown(), diags
	}

	preambleVal, ok := preambleAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`preamble expected to be basetypes.StringValue, was: %T`, preambleAttribute))
	}

	if diags.HasError() {
		return NewBand5On24RadioValueUnknown(), diags
	}

	return Band5On24RadioValue{
		AllowRrmDisable: allowRrmDisableVal,
		AntGain:         antGainVal,
		AntennaMode:     antennaModeVal,
		Bandwidth:       bandwidthVal,
		Channel:         channelVal,
		Channels:        channelsVal,
		Disabled:        disabledVal,
		Power:           powerVal,
		PowerMax:        powerMaxVal,
		PowerMin:        powerMinVal,
		Preamble:        preambleVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewBand5On24RadioValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Band5On24RadioValue {
	object, diags := NewBand5On24RadioValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewBand5On24RadioValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Band5On24RadioType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewBand5On24RadioValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewBand5On24RadioValueUnknown(), nil
	}

	if in.IsNull() {
		return NewBand5On24RadioValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewBand5On24RadioValueMust(Band5On24RadioValue{}.AttributeTypes(ctx), attributes), nil
}

func (t Band5On24RadioType) ValueType(ctx context.Context) attr.Value {
	return Band5On24RadioValue{}
}

var _ basetypes.ObjectValuable = Band5On24RadioValue{}

type Band5On24RadioValue struct {
	AllowRrmDisable basetypes.BoolValue   `tfsdk:"allow_rrm_disable"`
	AntGain         basetypes.Int64Value  `tfsdk:"ant_gain"`
	AntennaMode     basetypes.StringValue `tfsdk:"antenna_mode"`
	Bandwidth       basetypes.Int64Value  `tfsdk:"bandwidth"`
	Channel         basetypes.Int64Value  `tfsdk:"channel"`
	Channels        basetypes.ListValue   `tfsdk:"channels"`
	Disabled        basetypes.BoolValue   `tfsdk:"disabled"`
	Power           basetypes.Int64Value  `tfsdk:"power"`
	PowerMax        basetypes.Int64Value  `tfsdk:"power_max"`
	PowerMin        basetypes.Int64Value  `tfsdk:"power_min"`
	Preamble        basetypes.StringValue `tfsdk:"preamble"`
	state           attr.ValueState
}

func (v Band5On24RadioValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 11)

	var val tftypes.Value
	var err error

	attrTypes["allow_rrm_disable"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["ant_gain"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["antenna_mode"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["bandwidth"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["channel"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["channels"] = basetypes.ListType{
		ElemType: types.Int64Type,
	}.TerraformType(ctx)
	attrTypes["disabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["power"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["power_max"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["power_min"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["preamble"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 11)

		val, err = v.AllowRrmDisable.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["allow_rrm_disable"] = val

		val, err = v.AntGain.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ant_gain"] = val

		val, err = v.AntennaMode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["antenna_mode"] = val

		val, err = v.Bandwidth.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bandwidth"] = val

		val, err = v.Channel.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["channel"] = val

		val, err = v.Channels.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["channels"] = val

		val, err = v.Disabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["disabled"] = val

		val, err = v.Power.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["power"] = val

		val, err = v.PowerMax.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["power_max"] = val

		val, err = v.PowerMin.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["power_min"] = val

		val, err = v.Preamble.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["preamble"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Band5On24RadioValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Band5On24RadioValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Band5On24RadioValue) String() string {
	return "Band5On24RadioValue"
}

func (v Band5On24RadioValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	channelsVal, d := types.ListValue(types.Int64Type, v.Channels.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"allow_rrm_disable": basetypes.BoolType{},
			"ant_gain":          basetypes.Int64Type{},
			"antenna_mode":      basetypes.StringType{},
			"bandwidth":         basetypes.Int64Type{},
			"channel":           basetypes.Int64Type{},
			"channels": basetypes.ListType{
				ElemType: types.Int64Type,
			},
			"disabled":  basetypes.BoolType{},
			"power":     basetypes.Int64Type{},
			"power_max": basetypes.Int64Type{},
			"power_min": basetypes.Int64Type{},
			"preamble":  basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"allow_rrm_disable": basetypes.BoolType{},
		"ant_gain":          basetypes.Int64Type{},
		"antenna_mode":      basetypes.StringType{},
		"bandwidth":         basetypes.Int64Type{},
		"channel":           basetypes.Int64Type{},
		"channels": basetypes.ListType{
			ElemType: types.Int64Type,
		},
		"disabled":  basetypes.BoolType{},
		"power":     basetypes.Int64Type{},
		"power_max": basetypes.Int64Type{},
		"power_min": basetypes.Int64Type{},
		"preamble":  basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"allow_rrm_disable": v.AllowRrmDisable,
			"ant_gain":          v.AntGain,
			"antenna_mode":      v.AntennaMode,
			"bandwidth":         v.Bandwidth,
			"channel":           v.Channel,
			"channels":          channelsVal,
			"disabled":          v.Disabled,
			"power":             v.Power,
			"power_max":         v.PowerMax,
			"power_min":         v.PowerMin,
			"preamble":          v.Preamble,
		})

	return objVal, diags
}

func (v Band5On24RadioValue) Equal(o attr.Value) bool {
	other, ok := o.(Band5On24RadioValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AllowRrmDisable.Equal(other.AllowRrmDisable) {
		return false
	}

	if !v.AntGain.Equal(other.AntGain) {
		return false
	}

	if !v.AntennaMode.Equal(other.AntennaMode) {
		return false
	}

	if !v.Bandwidth.Equal(other.Bandwidth) {
		return false
	}

	if !v.Channel.Equal(other.Channel) {
		return false
	}

	if !v.Channels.Equal(other.Channels) {
		return false
	}

	if !v.Disabled.Equal(other.Disabled) {
		return false
	}

	if !v.Power.Equal(other.Power) {
		return false
	}

	if !v.PowerMax.Equal(other.PowerMax) {
		return false
	}

	if !v.PowerMin.Equal(other.PowerMin) {
		return false
	}

	if !v.Preamble.Equal(other.Preamble) {
		return false
	}

	return true
}

func (v Band5On24RadioValue) Type(ctx context.Context) attr.Type {
	return Band5On24RadioType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Band5On24RadioValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"allow_rrm_disable": basetypes.BoolType{},
		"ant_gain":          basetypes.Int64Type{},
		"antenna_mode":      basetypes.StringType{},
		"bandwidth":         basetypes.Int64Type{},
		"channel":           basetypes.Int64Type{},
		"channels": basetypes.ListType{
			ElemType: types.Int64Type,
		},
		"disabled":  basetypes.BoolType{},
		"power":     basetypes.Int64Type{},
		"power_max": basetypes.Int64Type{},
		"power_min": basetypes.Int64Type{},
		"preamble":  basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = Band6Type{}

type Band6Type struct {
	basetypes.ObjectType
}

func (t Band6Type) Equal(o attr.Type) bool {
	other, ok := o.(Band6Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Band6Type) String() string {
	return "Band6Type"
}

func (t Band6Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	allowRrmDisableAttribute, ok := attributes["allow_rrm_disable"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allow_rrm_disable is missing from object`)

		return nil, diags
	}

	allowRrmDisableVal, ok := allowRrmDisableAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allow_rrm_disable expected to be basetypes.BoolValue, was: %T`, allowRrmDisableAttribute))
	}

	antGainAttribute, ok := attributes["ant_gain"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ant_gain is missing from object`)

		return nil, diags
	}

	antGainVal, ok := antGainAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ant_gain expected to be basetypes.Int64Value, was: %T`, antGainAttribute))
	}

	antennaModeAttribute, ok := attributes["antenna_mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`antenna_mode is missing from object`)

		return nil, diags
	}

	antennaModeVal, ok := antennaModeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`antenna_mode expected to be basetypes.StringValue, was: %T`, antennaModeAttribute))
	}

	bandwidthAttribute, ok := attributes["bandwidth"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bandwidth is missing from object`)

		return nil, diags
	}

	bandwidthVal, ok := bandwidthAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bandwidth expected to be basetypes.Int64Value, was: %T`, bandwidthAttribute))
	}

	channelAttribute, ok := attributes["channel"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`channel is missing from object`)

		return nil, diags
	}

	channelVal, ok := channelAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`channel expected to be basetypes.Int64Value, was: %T`, channelAttribute))
	}

	channelsAttribute, ok := attributes["channels"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`channels is missing from object`)

		return nil, diags
	}

	channelsVal, ok := channelsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`channels expected to be basetypes.ListValue, was: %T`, channelsAttribute))
	}

	disabledAttribute, ok := attributes["disabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disabled is missing from object`)

		return nil, diags
	}

	disabledVal, ok := disabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disabled expected to be basetypes.BoolValue, was: %T`, disabledAttribute))
	}

	powerAttribute, ok := attributes["power"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`power is missing from object`)

		return nil, diags
	}

	powerVal, ok := powerAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`power expected to be basetypes.Int64Value, was: %T`, powerAttribute))
	}

	powerMaxAttribute, ok := attributes["power_max"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`power_max is missing from object`)

		return nil, diags
	}

	powerMaxVal, ok := powerMaxAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`power_max expected to be basetypes.Int64Value, was: %T`, powerMaxAttribute))
	}

	powerMinAttribute, ok := attributes["power_min"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`power_min is missing from object`)

		return nil, diags
	}

	powerMinVal, ok := powerMinAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`power_min expected to be basetypes.Int64Value, was: %T`, powerMinAttribute))
	}

	preambleAttribute, ok := attributes["preamble"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`preamble is missing from object`)

		return nil, diags
	}

	preambleVal, ok := preambleAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`preamble expected to be basetypes.StringValue, was: %T`, preambleAttribute))
	}

	standardPowerAttribute, ok := attributes["standard_power"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`standard_power is missing from object`)

		return nil, diags
	}

	standardPowerVal, ok := standardPowerAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`standard_power expected to be basetypes.BoolValue, was: %T`, standardPowerAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Band6Value{
		AllowRrmDisable: allowRrmDisableVal,
		AntGain:         antGainVal,
		AntennaMode:     antennaModeVal,
		Bandwidth:       bandwidthVal,
		Channel:         channelVal,
		Channels:        channelsVal,
		Disabled:        disabledVal,
		Power:           powerVal,
		PowerMax:        powerMaxVal,
		PowerMin:        powerMinVal,
		Preamble:        preambleVal,
		StandardPower:   standardPowerVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewBand6ValueNull() Band6Value {
	return Band6Value{
		state: attr.ValueStateNull,
	}
}

func NewBand6ValueUnknown() Band6Value {
	return Band6Value{
		state: attr.ValueStateUnknown,
	}
}

func NewBand6Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Band6Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Band6Value Attribute Value",
				"While creating a Band6Value value, a missing attribute value was detected. "+
					"A Band6Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Band6Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Band6Value Attribute Type",
				"While creating a Band6Value value, an invalid attribute value was detected. "+
					"A Band6Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Band6Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Band6Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Band6Value Attribute Value",
				"While creating a Band6Value value, an extra attribute value was detected. "+
					"A Band6Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Band6Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewBand6ValueUnknown(), diags
	}

	allowRrmDisableAttribute, ok := attributes["allow_rrm_disable"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allow_rrm_disable is missing from object`)

		return NewBand6ValueUnknown(), diags
	}

	allowRrmDisableVal, ok := allowRrmDisableAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allow_rrm_disable expected to be basetypes.BoolValue, was: %T`, allowRrmDisableAttribute))
	}

	antGainAttribute, ok := attributes["ant_gain"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ant_gain is missing from object`)

		return NewBand6ValueUnknown(), diags
	}

	antGainVal, ok := antGainAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ant_gain expected to be basetypes.Int64Value, was: %T`, antGainAttribute))
	}

	antennaModeAttribute, ok := attributes["antenna_mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`antenna_mode is missing from object`)

		return NewBand6ValueUnknown(), diags
	}

	antennaModeVal, ok := antennaModeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`antenna_mode expected to be basetypes.StringValue, was: %T`, antennaModeAttribute))
	}

	bandwidthAttribute, ok := attributes["bandwidth"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bandwidth is missing from object`)

		return NewBand6ValueUnknown(), diags
	}

	bandwidthVal, ok := bandwidthAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bandwidth expected to be basetypes.Int64Value, was: %T`, bandwidthAttribute))
	}

	channelAttribute, ok := attributes["channel"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`channel is missing from object`)

		return NewBand6ValueUnknown(), diags
	}

	channelVal, ok := channelAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`channel expected to be basetypes.Int64Value, was: %T`, channelAttribute))
	}

	channelsAttribute, ok := attributes["channels"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`channels is missing from object`)

		return NewBand6ValueUnknown(), diags
	}

	channelsVal, ok := channelsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`channels expected to be basetypes.ListValue, was: %T`, channelsAttribute))
	}

	disabledAttribute, ok := attributes["disabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disabled is missing from object`)

		return NewBand6ValueUnknown(), diags
	}

	disabledVal, ok := disabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disabled expected to be basetypes.BoolValue, was: %T`, disabledAttribute))
	}

	powerAttribute, ok := attributes["power"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`power is missing from object`)

		return NewBand6ValueUnknown(), diags
	}

	powerVal, ok := powerAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`power expected to be basetypes.Int64Value, was: %T`, powerAttribute))
	}

	powerMaxAttribute, ok := attributes["power_max"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`power_max is missing from object`)

		return NewBand6ValueUnknown(), diags
	}

	powerMaxVal, ok := powerMaxAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`power_max expected to be basetypes.Int64Value, was: %T`, powerMaxAttribute))
	}

	powerMinAttribute, ok := attributes["power_min"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`power_min is missing from object`)

		return NewBand6ValueUnknown(), diags
	}

	powerMinVal, ok := powerMinAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`power_min expected to be basetypes.Int64Value, was: %T`, powerMinAttribute))
	}

	preambleAttribute, ok := attributes["preamble"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`preamble is missing from object`)

		return NewBand6ValueUnknown(), diags
	}

	preambleVal, ok := preambleAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`preamble expected to be basetypes.StringValue, was: %T`, preambleAttribute))
	}

	standardPowerAttribute, ok := attributes["standard_power"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`standard_power is missing from object`)

		return NewBand6ValueUnknown(), diags
	}

	standardPowerVal, ok := standardPowerAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`standard_power expected to be basetypes.BoolValue, was: %T`, standardPowerAttribute))
	}

	if diags.HasError() {
		return NewBand6ValueUnknown(), diags
	}

	return Band6Value{
		AllowRrmDisable: allowRrmDisableVal,
		AntGain:         antGainVal,
		AntennaMode:     antennaModeVal,
		Bandwidth:       bandwidthVal,
		Channel:         channelVal,
		Channels:        channelsVal,
		Disabled:        disabledVal,
		Power:           powerVal,
		PowerMax:        powerMaxVal,
		PowerMin:        powerMinVal,
		Preamble:        preambleVal,
		StandardPower:   standardPowerVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewBand6ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Band6Value {
	object, diags := NewBand6Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewBand6ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Band6Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewBand6ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewBand6ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewBand6ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewBand6ValueMust(Band6Value{}.AttributeTypes(ctx), attributes), nil
}

func (t Band6Type) ValueType(ctx context.Context) attr.Value {
	return Band6Value{}
}

var _ basetypes.ObjectValuable = Band6Value{}

type Band6Value struct {
	AllowRrmDisable basetypes.BoolValue   `tfsdk:"allow_rrm_disable"`
	AntGain         basetypes.Int64Value  `tfsdk:"ant_gain"`
	AntennaMode     basetypes.StringValue `tfsdk:"antenna_mode"`
	Bandwidth       basetypes.Int64Value  `tfsdk:"bandwidth"`
	Channel         basetypes.Int64Value  `tfsdk:"channel"`
	Channels        basetypes.ListValue   `tfsdk:"channels"`
	Disabled        basetypes.BoolValue   `tfsdk:"disabled"`
	Power           basetypes.Int64Value  `tfsdk:"power"`
	PowerMax        basetypes.Int64Value  `tfsdk:"power_max"`
	PowerMin        basetypes.Int64Value  `tfsdk:"power_min"`
	Preamble        basetypes.StringValue `tfsdk:"preamble"`
	StandardPower   basetypes.BoolValue   `tfsdk:"standard_power"`
	state           attr.ValueState
}

func (v Band6Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 12)

	var val tftypes.Value
	var err error

	attrTypes["allow_rrm_disable"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["ant_gain"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["antenna_mode"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["bandwidth"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["channel"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["channels"] = basetypes.ListType{
		ElemType: types.Int64Type,
	}.TerraformType(ctx)
	attrTypes["disabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["power"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["power_max"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["power_min"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["preamble"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["standard_power"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 12)

		val, err = v.AllowRrmDisable.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["allow_rrm_disable"] = val

		val, err = v.AntGain.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ant_gain"] = val

		val, err = v.AntennaMode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["antenna_mode"] = val

		val, err = v.Bandwidth.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bandwidth"] = val

		val, err = v.Channel.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["channel"] = val

		val, err = v.Channels.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["channels"] = val

		val, err = v.Disabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["disabled"] = val

		val, err = v.Power.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["power"] = val

		val, err = v.PowerMax.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["power_max"] = val

		val, err = v.PowerMin.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["power_min"] = val

		val, err = v.Preamble.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["preamble"] = val

		val, err = v.StandardPower.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["standard_power"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Band6Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Band6Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Band6Value) String() string {
	return "Band6Value"
}

func (v Band6Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	channelsVal, d := types.ListValue(types.Int64Type, v.Channels.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"allow_rrm_disable": basetypes.BoolType{},
			"ant_gain":          basetypes.Int64Type{},
			"antenna_mode":      basetypes.StringType{},
			"bandwidth":         basetypes.Int64Type{},
			"channel":           basetypes.Int64Type{},
			"channels": basetypes.ListType{
				ElemType: types.Int64Type,
			},
			"disabled":       basetypes.BoolType{},
			"power":          basetypes.Int64Type{},
			"power_max":      basetypes.Int64Type{},
			"power_min":      basetypes.Int64Type{},
			"preamble":       basetypes.StringType{},
			"standard_power": basetypes.BoolType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"allow_rrm_disable": basetypes.BoolType{},
		"ant_gain":          basetypes.Int64Type{},
		"antenna_mode":      basetypes.StringType{},
		"bandwidth":         basetypes.Int64Type{},
		"channel":           basetypes.Int64Type{},
		"channels": basetypes.ListType{
			ElemType: types.Int64Type,
		},
		"disabled":       basetypes.BoolType{},
		"power":          basetypes.Int64Type{},
		"power_max":      basetypes.Int64Type{},
		"power_min":      basetypes.Int64Type{},
		"preamble":       basetypes.StringType{},
		"standard_power": basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"allow_rrm_disable": v.AllowRrmDisable,
			"ant_gain":          v.AntGain,
			"antenna_mode":      v.AntennaMode,
			"bandwidth":         v.Bandwidth,
			"channel":           v.Channel,
			"channels":          channelsVal,
			"disabled":          v.Disabled,
			"power":             v.Power,
			"power_max":         v.PowerMax,
			"power_min":         v.PowerMin,
			"preamble":          v.Preamble,
			"standard_power":    v.StandardPower,
		})

	return objVal, diags
}

func (v Band6Value) Equal(o attr.Value) bool {
	other, ok := o.(Band6Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AllowRrmDisable.Equal(other.AllowRrmDisable) {
		return false
	}

	if !v.AntGain.Equal(other.AntGain) {
		return false
	}

	if !v.AntennaMode.Equal(other.AntennaMode) {
		return false
	}

	if !v.Bandwidth.Equal(other.Bandwidth) {
		return false
	}

	if !v.Channel.Equal(other.Channel) {
		return false
	}

	if !v.Channels.Equal(other.Channels) {
		return false
	}

	if !v.Disabled.Equal(other.Disabled) {
		return false
	}

	if !v.Power.Equal(other.Power) {
		return false
	}

	if !v.PowerMax.Equal(other.PowerMax) {
		return false
	}

	if !v.PowerMin.Equal(other.PowerMin) {
		return false
	}

	if !v.Preamble.Equal(other.Preamble) {
		return false
	}

	if !v.StandardPower.Equal(other.StandardPower) {
		return false
	}

	return true
}

func (v Band6Value) Type(ctx context.Context) attr.Type {
	return Band6Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Band6Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"allow_rrm_disable": basetypes.BoolType{},
		"ant_gain":          basetypes.Int64Type{},
		"antenna_mode":      basetypes.StringType{},
		"bandwidth":         basetypes.Int64Type{},
		"channel":           basetypes.Int64Type{},
		"channels": basetypes.ListType{
			ElemType: types.Int64Type,
		},
		"disabled":       basetypes.BoolType{},
		"power":          basetypes.Int64Type{},
		"power_max":      basetypes.Int64Type{},
		"power_min":      basetypes.Int64Type{},
		"preamble":       basetypes.StringType{},
		"standard_power": basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = SwitchConfigType{}

type SwitchConfigType struct {
	basetypes.ObjectType
}

func (t SwitchConfigType) Equal(o attr.Type) bool {
	other, ok := o.(SwitchConfigType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SwitchConfigType) String() string {
	return "SwitchConfigType"
}

func (t SwitchConfigType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	eth0Attribute, ok := attributes["eth0"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`eth0 is missing from object`)

		return nil, diags
	}

	eth0Val, ok := eth0Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`eth0 expected to be basetypes.ObjectValue, was: %T`, eth0Attribute))
	}

	eth1Attribute, ok := attributes["eth1"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`eth1 is missing from object`)

		return nil, diags
	}

	eth1Val, ok := eth1Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`eth1 expected to be basetypes.ObjectValue, was: %T`, eth1Attribute))
	}

	eth2Attribute, ok := attributes["eth2"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`eth2 is missing from object`)

		return nil, diags
	}

	eth2Val, ok := eth2Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`eth2 expected to be basetypes.ObjectValue, was: %T`, eth2Attribute))
	}

	eth3Attribute, ok := attributes["eth3"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`eth3 is missing from object`)

		return nil, diags
	}

	eth3Val, ok := eth3Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`eth3 expected to be basetypes.ObjectValue, was: %T`, eth3Attribute))
	}

	moduleAttribute, ok := attributes["module"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`module is missing from object`)

		return nil, diags
	}

	moduleVal, ok := moduleAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`module expected to be basetypes.ObjectValue, was: %T`, moduleAttribute))
	}

	wdsAttribute, ok := attributes["wds"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wds is missing from object`)

		return nil, diags
	}

	wdsVal, ok := wdsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wds expected to be basetypes.ObjectValue, was: %T`, wdsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SwitchConfigValue{
		Enabled: enabledVal,
		Eth0:    eth0Val,
		Eth1:    eth1Val,
		Eth2:    eth2Val,
		Eth3:    eth3Val,
		Module:  moduleVal,
		Wds:     wdsVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewSwitchConfigValueNull() SwitchConfigValue {
	return SwitchConfigValue{
		state: attr.ValueStateNull,
	}
}

func NewSwitchConfigValueUnknown() SwitchConfigValue {
	return SwitchConfigValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSwitchConfigValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SwitchConfigValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SwitchConfigValue Attribute Value",
				"While creating a SwitchConfigValue value, a missing attribute value was detected. "+
					"A SwitchConfigValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SwitchConfigValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SwitchConfigValue Attribute Type",
				"While creating a SwitchConfigValue value, an invalid attribute value was detected. "+
					"A SwitchConfigValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SwitchConfigValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SwitchConfigValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SwitchConfigValue Attribute Value",
				"While creating a SwitchConfigValue value, an extra attribute value was detected. "+
					"A SwitchConfigValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SwitchConfigValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSwitchConfigValueUnknown(), diags
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewSwitchConfigValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	eth0Attribute, ok := attributes["eth0"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`eth0 is missing from object`)

		return NewSwitchConfigValueUnknown(), diags
	}

	eth0Val, ok := eth0Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`eth0 expected to be basetypes.ObjectValue, was: %T`, eth0Attribute))
	}

	eth1Attribute, ok := attributes["eth1"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`eth1 is missing from object`)

		return NewSwitchConfigValueUnknown(), diags
	}

	eth1Val, ok := eth1Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`eth1 expected to be basetypes.ObjectValue, was: %T`, eth1Attribute))
	}

	eth2Attribute, ok := attributes["eth2"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`eth2 is missing from object`)

		return NewSwitchConfigValueUnknown(), diags
	}

	eth2Val, ok := eth2Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`eth2 expected to be basetypes.ObjectValue, was: %T`, eth2Attribute))
	}

	eth3Attribute, ok := attributes["eth3"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`eth3 is missing from object`)

		return NewSwitchConfigValueUnknown(), diags
	}

	eth3Val, ok := eth3Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`eth3 expected to be basetypes.ObjectValue, was: %T`, eth3Attribute))
	}

	moduleAttribute, ok := attributes["module"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`module is missing from object`)

		return NewSwitchConfigValueUnknown(), diags
	}

	moduleVal, ok := moduleAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`module expected to be basetypes.ObjectValue, was: %T`, moduleAttribute))
	}

	wdsAttribute, ok := attributes["wds"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wds is missing from object`)

		return NewSwitchConfigValueUnknown(), diags
	}

	wdsVal, ok := wdsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wds expected to be basetypes.ObjectValue, was: %T`, wdsAttribute))
	}

	if diags.HasError() {
		return NewSwitchConfigValueUnknown(), diags
	}

	return SwitchConfigValue{
		Enabled: enabledVal,
		Eth0:    eth0Val,
		Eth1:    eth1Val,
		Eth2:    eth2Val,
		Eth3:    eth3Val,
		Module:  moduleVal,
		Wds:     wdsVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewSwitchConfigValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SwitchConfigValue {
	object, diags := NewSwitchConfigValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSwitchConfigValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SwitchConfigType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSwitchConfigValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSwitchConfigValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSwitchConfigValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSwitchConfigValueMust(SwitchConfigValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SwitchConfigType) ValueType(ctx context.Context) attr.Value {
	return SwitchConfigValue{}
}

var _ basetypes.ObjectValuable = SwitchConfigValue{}

type SwitchConfigValue struct {
	Enabled basetypes.BoolValue   `tfsdk:"enabled"`
	Eth0    basetypes.ObjectValue `tfsdk:"eth0"`
	Eth1    basetypes.ObjectValue `tfsdk:"eth1"`
	Eth2    basetypes.ObjectValue `tfsdk:"eth2"`
	Eth3    basetypes.ObjectValue `tfsdk:"eth3"`
	Module  basetypes.ObjectValue `tfsdk:"module"`
	Wds     basetypes.ObjectValue `tfsdk:"wds"`
	state   attr.ValueState
}

func (v SwitchConfigValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 7)

	var val tftypes.Value
	var err error

	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["eth0"] = basetypes.ObjectType{
		AttrTypes: Eth0Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["eth1"] = basetypes.ObjectType{
		AttrTypes: Eth1Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["eth2"] = basetypes.ObjectType{
		AttrTypes: Eth2Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["eth3"] = basetypes.ObjectType{
		AttrTypes: Eth3Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["module"] = basetypes.ObjectType{
		AttrTypes: ModuleValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["wds"] = basetypes.ObjectType{
		AttrTypes: WdsValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 7)

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.Eth0.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["eth0"] = val

		val, err = v.Eth1.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["eth1"] = val

		val, err = v.Eth2.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["eth2"] = val

		val, err = v.Eth3.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["eth3"] = val

		val, err = v.Module.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["module"] = val

		val, err = v.Wds.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["wds"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SwitchConfigValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SwitchConfigValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SwitchConfigValue) String() string {
	return "SwitchConfigValue"
}

func (v SwitchConfigValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var eth0 basetypes.ObjectValue

	if v.Eth0.IsNull() {
		eth0 = types.ObjectNull(
			Eth0Value{}.AttributeTypes(ctx),
		)
	}

	if v.Eth0.IsUnknown() {
		eth0 = types.ObjectUnknown(
			Eth0Value{}.AttributeTypes(ctx),
		)
	}

	if !v.Eth0.IsNull() && !v.Eth0.IsUnknown() {
		eth0 = types.ObjectValueMust(
			Eth0Value{}.AttributeTypes(ctx),
			v.Eth0.Attributes(),
		)
	}

	var eth1 basetypes.ObjectValue

	if v.Eth1.IsNull() {
		eth1 = types.ObjectNull(
			Eth1Value{}.AttributeTypes(ctx),
		)
	}

	if v.Eth1.IsUnknown() {
		eth1 = types.ObjectUnknown(
			Eth1Value{}.AttributeTypes(ctx),
		)
	}

	if !v.Eth1.IsNull() && !v.Eth1.IsUnknown() {
		eth1 = types.ObjectValueMust(
			Eth1Value{}.AttributeTypes(ctx),
			v.Eth1.Attributes(),
		)
	}

	var eth2 basetypes.ObjectValue

	if v.Eth2.IsNull() {
		eth2 = types.ObjectNull(
			Eth2Value{}.AttributeTypes(ctx),
		)
	}

	if v.Eth2.IsUnknown() {
		eth2 = types.ObjectUnknown(
			Eth2Value{}.AttributeTypes(ctx),
		)
	}

	if !v.Eth2.IsNull() && !v.Eth2.IsUnknown() {
		eth2 = types.ObjectValueMust(
			Eth2Value{}.AttributeTypes(ctx),
			v.Eth2.Attributes(),
		)
	}

	var eth3 basetypes.ObjectValue

	if v.Eth3.IsNull() {
		eth3 = types.ObjectNull(
			Eth3Value{}.AttributeTypes(ctx),
		)
	}

	if v.Eth3.IsUnknown() {
		eth3 = types.ObjectUnknown(
			Eth3Value{}.AttributeTypes(ctx),
		)
	}

	if !v.Eth3.IsNull() && !v.Eth3.IsUnknown() {
		eth3 = types.ObjectValueMust(
			Eth3Value{}.AttributeTypes(ctx),
			v.Eth3.Attributes(),
		)
	}

	var module basetypes.ObjectValue

	if v.Module.IsNull() {
		module = types.ObjectNull(
			ModuleValue{}.AttributeTypes(ctx),
		)
	}

	if v.Module.IsUnknown() {
		module = types.ObjectUnknown(
			ModuleValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Module.IsNull() && !v.Module.IsUnknown() {
		module = types.ObjectValueMust(
			ModuleValue{}.AttributeTypes(ctx),
			v.Module.Attributes(),
		)
	}

	var wds basetypes.ObjectValue

	if v.Wds.IsNull() {
		wds = types.ObjectNull(
			WdsValue{}.AttributeTypes(ctx),
		)
	}

	if v.Wds.IsUnknown() {
		wds = types.ObjectUnknown(
			WdsValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Wds.IsNull() && !v.Wds.IsUnknown() {
		wds = types.ObjectValueMust(
			WdsValue{}.AttributeTypes(ctx),
			v.Wds.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"enabled": basetypes.BoolType{},
		"eth0": basetypes.ObjectType{
			AttrTypes: Eth0Value{}.AttributeTypes(ctx),
		},
		"eth1": basetypes.ObjectType{
			AttrTypes: Eth1Value{}.AttributeTypes(ctx),
		},
		"eth2": basetypes.ObjectType{
			AttrTypes: Eth2Value{}.AttributeTypes(ctx),
		},
		"eth3": basetypes.ObjectType{
			AttrTypes: Eth3Value{}.AttributeTypes(ctx),
		},
		"module": basetypes.ObjectType{
			AttrTypes: ModuleValue{}.AttributeTypes(ctx),
		},
		"wds": basetypes.ObjectType{
			AttrTypes: WdsValue{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"enabled": v.Enabled,
			"eth0":    eth0,
			"eth1":    eth1,
			"eth2":    eth2,
			"eth3":    eth3,
			"module":  module,
			"wds":     wds,
		})

	return objVal, diags
}

func (v SwitchConfigValue) Equal(o attr.Value) bool {
	other, ok := o.(SwitchConfigValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.Eth0.Equal(other.Eth0) {
		return false
	}

	if !v.Eth1.Equal(other.Eth1) {
		return false
	}

	if !v.Eth2.Equal(other.Eth2) {
		return false
	}

	if !v.Eth3.Equal(other.Eth3) {
		return false
	}

	if !v.Module.Equal(other.Module) {
		return false
	}

	if !v.Wds.Equal(other.Wds) {
		return false
	}

	return true
}

func (v SwitchConfigValue) Type(ctx context.Context) attr.Type {
	return SwitchConfigType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SwitchConfigValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"enabled": basetypes.BoolType{},
		"eth0": basetypes.ObjectType{
			AttrTypes: Eth0Value{}.AttributeTypes(ctx),
		},
		"eth1": basetypes.ObjectType{
			AttrTypes: Eth1Value{}.AttributeTypes(ctx),
		},
		"eth2": basetypes.ObjectType{
			AttrTypes: Eth2Value{}.AttributeTypes(ctx),
		},
		"eth3": basetypes.ObjectType{
			AttrTypes: Eth3Value{}.AttributeTypes(ctx),
		},
		"module": basetypes.ObjectType{
			AttrTypes: ModuleValue{}.AttributeTypes(ctx),
		},
		"wds": basetypes.ObjectType{
			AttrTypes: WdsValue{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = Eth0Type{}

type Eth0Type struct {
	basetypes.ObjectType
}

func (t Eth0Type) Equal(o attr.Type) bool {
	other, ok := o.(Eth0Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Eth0Type) String() string {
	return "Eth0Type"
}

func (t Eth0Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	additionalVlanIdsAttribute, ok := attributes["additional_vlan_ids"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`additional_vlan_ids is missing from object`)

		return nil, diags
	}

	additionalVlanIdsVal, ok := additionalVlanIdsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`additional_vlan_ids expected to be basetypes.ListValue, was: %T`, additionalVlanIdsAttribute))
	}

	enableVlanAttribute, ok := attributes["enable_vlan"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable_vlan is missing from object`)

		return nil, diags
	}

	enableVlanVal, ok := enableVlanAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable_vlan expected to be basetypes.BoolValue, was: %T`, enableVlanAttribute))
	}

	portVlanIdAttribute, ok := attributes["port_vlan_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_vlan_id is missing from object`)

		return nil, diags
	}

	portVlanIdVal, ok := portVlanIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_vlan_id expected to be basetypes.StringValue, was: %T`, portVlanIdAttribute))
	}

	vlanIdsAttribute, ok := attributes["vlan_ids"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan_ids is missing from object`)

		return nil, diags
	}

	vlanIdsVal, ok := vlanIdsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan_ids expected to be basetypes.ListValue, was: %T`, vlanIdsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Eth0Value{
		AdditionalVlanIds: additionalVlanIdsVal,
		EnableVlan:        enableVlanVal,
		PortVlanId:        portVlanIdVal,
		VlanIds:           vlanIdsVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewEth0ValueNull() Eth0Value {
	return Eth0Value{
		state: attr.ValueStateNull,
	}
}

func NewEth0ValueUnknown() Eth0Value {
	return Eth0Value{
		state: attr.ValueStateUnknown,
	}
}

func NewEth0Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Eth0Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Eth0Value Attribute Value",
				"While creating a Eth0Value value, a missing attribute value was detected. "+
					"A Eth0Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Eth0Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Eth0Value Attribute Type",
				"While creating a Eth0Value value, an invalid attribute value was detected. "+
					"A Eth0Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Eth0Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Eth0Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Eth0Value Attribute Value",
				"While creating a Eth0Value value, an extra attribute value was detected. "+
					"A Eth0Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Eth0Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewEth0ValueUnknown(), diags
	}

	additionalVlanIdsAttribute, ok := attributes["additional_vlan_ids"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`additional_vlan_ids is missing from object`)

		return NewEth0ValueUnknown(), diags
	}

	additionalVlanIdsVal, ok := additionalVlanIdsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`additional_vlan_ids expected to be basetypes.ListValue, was: %T`, additionalVlanIdsAttribute))
	}

	enableVlanAttribute, ok := attributes["enable_vlan"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable_vlan is missing from object`)

		return NewEth0ValueUnknown(), diags
	}

	enableVlanVal, ok := enableVlanAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable_vlan expected to be basetypes.BoolValue, was: %T`, enableVlanAttribute))
	}

	portVlanIdAttribute, ok := attributes["port_vlan_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_vlan_id is missing from object`)

		return NewEth0ValueUnknown(), diags
	}

	portVlanIdVal, ok := portVlanIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_vlan_id expected to be basetypes.StringValue, was: %T`, portVlanIdAttribute))
	}

	vlanIdsAttribute, ok := attributes["vlan_ids"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan_ids is missing from object`)

		return NewEth0ValueUnknown(), diags
	}

	vlanIdsVal, ok := vlanIdsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan_ids expected to be basetypes.ListValue, was: %T`, vlanIdsAttribute))
	}

	if diags.HasError() {
		return NewEth0ValueUnknown(), diags
	}

	return Eth0Value{
		AdditionalVlanIds: additionalVlanIdsVal,
		EnableVlan:        enableVlanVal,
		PortVlanId:        portVlanIdVal,
		VlanIds:           vlanIdsVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewEth0ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Eth0Value {
	object, diags := NewEth0Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewEth0ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Eth0Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewEth0ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewEth0ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewEth0ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewEth0ValueMust(Eth0Value{}.AttributeTypes(ctx), attributes), nil
}

func (t Eth0Type) ValueType(ctx context.Context) attr.Value {
	return Eth0Value{}
}

var _ basetypes.ObjectValuable = Eth0Value{}

type Eth0Value struct {
	AdditionalVlanIds basetypes.ListValue   `tfsdk:"additional_vlan_ids"`
	EnableVlan        basetypes.BoolValue   `tfsdk:"enable_vlan"`
	PortVlanId        basetypes.StringValue `tfsdk:"port_vlan_id"`
	VlanIds           basetypes.ListValue   `tfsdk:"vlan_ids"`
	state             attr.ValueState
}

func (v Eth0Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["additional_vlan_ids"] = basetypes.ListType{
		ElemType: types.Int64Type,
	}.TerraformType(ctx)
	attrTypes["enable_vlan"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["port_vlan_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["vlan_ids"] = basetypes.ListType{
		ElemType: types.Int64Type,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.AdditionalVlanIds.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["additional_vlan_ids"] = val

		val, err = v.EnableVlan.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enable_vlan"] = val

		val, err = v.PortVlanId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port_vlan_id"] = val

		val, err = v.VlanIds.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vlan_ids"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Eth0Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Eth0Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Eth0Value) String() string {
	return "Eth0Value"
}

func (v Eth0Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	additionalVlanIdsVal, d := types.ListValue(types.Int64Type, v.AdditionalVlanIds.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"additional_vlan_ids": basetypes.ListType{
				ElemType: types.Int64Type,
			},
			"enable_vlan":  basetypes.BoolType{},
			"port_vlan_id": basetypes.StringType{},
			"vlan_ids": basetypes.ListType{
				ElemType: types.Int64Type,
			},
		}), diags
	}

	vlanIdsVal, d := types.ListValue(types.Int64Type, v.VlanIds.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"additional_vlan_ids": basetypes.ListType{
				ElemType: types.Int64Type,
			},
			"enable_vlan":  basetypes.BoolType{},
			"port_vlan_id": basetypes.StringType{},
			"vlan_ids": basetypes.ListType{
				ElemType: types.Int64Type,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"additional_vlan_ids": basetypes.ListType{
			ElemType: types.Int64Type,
		},
		"enable_vlan":  basetypes.BoolType{},
		"port_vlan_id": basetypes.StringType{},
		"vlan_ids": basetypes.ListType{
			ElemType: types.Int64Type,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"additional_vlan_ids": additionalVlanIdsVal,
			"enable_vlan":         v.EnableVlan,
			"port_vlan_id":        v.PortVlanId,
			"vlan_ids":            vlanIdsVal,
		})

	return objVal, diags
}

func (v Eth0Value) Equal(o attr.Value) bool {
	other, ok := o.(Eth0Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AdditionalVlanIds.Equal(other.AdditionalVlanIds) {
		return false
	}

	if !v.EnableVlan.Equal(other.EnableVlan) {
		return false
	}

	if !v.PortVlanId.Equal(other.PortVlanId) {
		return false
	}

	if !v.VlanIds.Equal(other.VlanIds) {
		return false
	}

	return true
}

func (v Eth0Value) Type(ctx context.Context) attr.Type {
	return Eth0Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Eth0Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"additional_vlan_ids": basetypes.ListType{
			ElemType: types.Int64Type,
		},
		"enable_vlan":  basetypes.BoolType{},
		"port_vlan_id": basetypes.StringType{},
		"vlan_ids": basetypes.ListType{
			ElemType: types.Int64Type,
		},
	}
}

var _ basetypes.ObjectTypable = Eth1Type{}

type Eth1Type struct {
	basetypes.ObjectType
}

func (t Eth1Type) Equal(o attr.Type) bool {
	other, ok := o.(Eth1Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Eth1Type) String() string {
	return "Eth1Type"
}

func (t Eth1Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	additionalVlanIdsAttribute, ok := attributes["additional_vlan_ids"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`additional_vlan_ids is missing from object`)

		return nil, diags
	}

	additionalVlanIdsVal, ok := additionalVlanIdsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`additional_vlan_ids expected to be basetypes.ListValue, was: %T`, additionalVlanIdsAttribute))
	}

	enableVlanAttribute, ok := attributes["enable_vlan"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable_vlan is missing from object`)

		return nil, diags
	}

	enableVlanVal, ok := enableVlanAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable_vlan expected to be basetypes.BoolValue, was: %T`, enableVlanAttribute))
	}

	portVlanIdAttribute, ok := attributes["port_vlan_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_vlan_id is missing from object`)

		return nil, diags
	}

	portVlanIdVal, ok := portVlanIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_vlan_id expected to be basetypes.StringValue, was: %T`, portVlanIdAttribute))
	}

	vlanIdsAttribute, ok := attributes["vlan_ids"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan_ids is missing from object`)

		return nil, diags
	}

	vlanIdsVal, ok := vlanIdsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan_ids expected to be basetypes.ListValue, was: %T`, vlanIdsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Eth1Value{
		AdditionalVlanIds: additionalVlanIdsVal,
		EnableVlan:        enableVlanVal,
		PortVlanId:        portVlanIdVal,
		VlanIds:           vlanIdsVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewEth1ValueNull() Eth1Value {
	return Eth1Value{
		state: attr.ValueStateNull,
	}
}

func NewEth1ValueUnknown() Eth1Value {
	return Eth1Value{
		state: attr.ValueStateUnknown,
	}
}

func NewEth1Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Eth1Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Eth1Value Attribute Value",
				"While creating a Eth1Value value, a missing attribute value was detected. "+
					"A Eth1Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Eth1Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Eth1Value Attribute Type",
				"While creating a Eth1Value value, an invalid attribute value was detected. "+
					"A Eth1Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Eth1Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Eth1Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Eth1Value Attribute Value",
				"While creating a Eth1Value value, an extra attribute value was detected. "+
					"A Eth1Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Eth1Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewEth1ValueUnknown(), diags
	}

	additionalVlanIdsAttribute, ok := attributes["additional_vlan_ids"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`additional_vlan_ids is missing from object`)

		return NewEth1ValueUnknown(), diags
	}

	additionalVlanIdsVal, ok := additionalVlanIdsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`additional_vlan_ids expected to be basetypes.ListValue, was: %T`, additionalVlanIdsAttribute))
	}

	enableVlanAttribute, ok := attributes["enable_vlan"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable_vlan is missing from object`)

		return NewEth1ValueUnknown(), diags
	}

	enableVlanVal, ok := enableVlanAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable_vlan expected to be basetypes.BoolValue, was: %T`, enableVlanAttribute))
	}

	portVlanIdAttribute, ok := attributes["port_vlan_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_vlan_id is missing from object`)

		return NewEth1ValueUnknown(), diags
	}

	portVlanIdVal, ok := portVlanIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_vlan_id expected to be basetypes.StringValue, was: %T`, portVlanIdAttribute))
	}

	vlanIdsAttribute, ok := attributes["vlan_ids"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan_ids is missing from object`)

		return NewEth1ValueUnknown(), diags
	}

	vlanIdsVal, ok := vlanIdsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan_ids expected to be basetypes.ListValue, was: %T`, vlanIdsAttribute))
	}

	if diags.HasError() {
		return NewEth1ValueUnknown(), diags
	}

	return Eth1Value{
		AdditionalVlanIds: additionalVlanIdsVal,
		EnableVlan:        enableVlanVal,
		PortVlanId:        portVlanIdVal,
		VlanIds:           vlanIdsVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewEth1ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Eth1Value {
	object, diags := NewEth1Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewEth1ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Eth1Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewEth1ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewEth1ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewEth1ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewEth1ValueMust(Eth1Value{}.AttributeTypes(ctx), attributes), nil
}

func (t Eth1Type) ValueType(ctx context.Context) attr.Value {
	return Eth1Value{}
}

var _ basetypes.ObjectValuable = Eth1Value{}

type Eth1Value struct {
	AdditionalVlanIds basetypes.ListValue   `tfsdk:"additional_vlan_ids"`
	EnableVlan        basetypes.BoolValue   `tfsdk:"enable_vlan"`
	PortVlanId        basetypes.StringValue `tfsdk:"port_vlan_id"`
	VlanIds           basetypes.ListValue   `tfsdk:"vlan_ids"`
	state             attr.ValueState
}

func (v Eth1Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["additional_vlan_ids"] = basetypes.ListType{
		ElemType: types.Int64Type,
	}.TerraformType(ctx)
	attrTypes["enable_vlan"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["port_vlan_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["vlan_ids"] = basetypes.ListType{
		ElemType: types.Int64Type,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.AdditionalVlanIds.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["additional_vlan_ids"] = val

		val, err = v.EnableVlan.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enable_vlan"] = val

		val, err = v.PortVlanId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port_vlan_id"] = val

		val, err = v.VlanIds.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vlan_ids"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Eth1Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Eth1Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Eth1Value) String() string {
	return "Eth1Value"
}

func (v Eth1Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	additionalVlanIdsVal, d := types.ListValue(types.Int64Type, v.AdditionalVlanIds.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"additional_vlan_ids": basetypes.ListType{
				ElemType: types.Int64Type,
			},
			"enable_vlan":  basetypes.BoolType{},
			"port_vlan_id": basetypes.StringType{},
			"vlan_ids": basetypes.ListType{
				ElemType: types.Int64Type,
			},
		}), diags
	}

	vlanIdsVal, d := types.ListValue(types.Int64Type, v.VlanIds.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"additional_vlan_ids": basetypes.ListType{
				ElemType: types.Int64Type,
			},
			"enable_vlan":  basetypes.BoolType{},
			"port_vlan_id": basetypes.StringType{},
			"vlan_ids": basetypes.ListType{
				ElemType: types.Int64Type,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"additional_vlan_ids": basetypes.ListType{
			ElemType: types.Int64Type,
		},
		"enable_vlan":  basetypes.BoolType{},
		"port_vlan_id": basetypes.StringType{},
		"vlan_ids": basetypes.ListType{
			ElemType: types.Int64Type,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"additional_vlan_ids": additionalVlanIdsVal,
			"enable_vlan":         v.EnableVlan,
			"port_vlan_id":        v.PortVlanId,
			"vlan_ids":            vlanIdsVal,
		})

	return objVal, diags
}

func (v Eth1Value) Equal(o attr.Value) bool {
	other, ok := o.(Eth1Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AdditionalVlanIds.Equal(other.AdditionalVlanIds) {
		return false
	}

	if !v.EnableVlan.Equal(other.EnableVlan) {
		return false
	}

	if !v.PortVlanId.Equal(other.PortVlanId) {
		return false
	}

	if !v.VlanIds.Equal(other.VlanIds) {
		return false
	}

	return true
}

func (v Eth1Value) Type(ctx context.Context) attr.Type {
	return Eth1Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Eth1Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"additional_vlan_ids": basetypes.ListType{
			ElemType: types.Int64Type,
		},
		"enable_vlan":  basetypes.BoolType{},
		"port_vlan_id": basetypes.StringType{},
		"vlan_ids": basetypes.ListType{
			ElemType: types.Int64Type,
		},
	}
}

var _ basetypes.ObjectTypable = Eth2Type{}

type Eth2Type struct {
	basetypes.ObjectType
}

func (t Eth2Type) Equal(o attr.Type) bool {
	other, ok := o.(Eth2Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Eth2Type) String() string {
	return "Eth2Type"
}

func (t Eth2Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	additionalVlanIdsAttribute, ok := attributes["additional_vlan_ids"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`additional_vlan_ids is missing from object`)

		return nil, diags
	}

	additionalVlanIdsVal, ok := additionalVlanIdsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`additional_vlan_ids expected to be basetypes.ListValue, was: %T`, additionalVlanIdsAttribute))
	}

	enableVlanAttribute, ok := attributes["enable_vlan"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable_vlan is missing from object`)

		return nil, diags
	}

	enableVlanVal, ok := enableVlanAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable_vlan expected to be basetypes.BoolValue, was: %T`, enableVlanAttribute))
	}

	portVlanIdAttribute, ok := attributes["port_vlan_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_vlan_id is missing from object`)

		return nil, diags
	}

	portVlanIdVal, ok := portVlanIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_vlan_id expected to be basetypes.StringValue, was: %T`, portVlanIdAttribute))
	}

	vlanIdsAttribute, ok := attributes["vlan_ids"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan_ids is missing from object`)

		return nil, diags
	}

	vlanIdsVal, ok := vlanIdsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan_ids expected to be basetypes.ListValue, was: %T`, vlanIdsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Eth2Value{
		AdditionalVlanIds: additionalVlanIdsVal,
		EnableVlan:        enableVlanVal,
		PortVlanId:        portVlanIdVal,
		VlanIds:           vlanIdsVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewEth2ValueNull() Eth2Value {
	return Eth2Value{
		state: attr.ValueStateNull,
	}
}

func NewEth2ValueUnknown() Eth2Value {
	return Eth2Value{
		state: attr.ValueStateUnknown,
	}
}

func NewEth2Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Eth2Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Eth2Value Attribute Value",
				"While creating a Eth2Value value, a missing attribute value was detected. "+
					"A Eth2Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Eth2Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Eth2Value Attribute Type",
				"While creating a Eth2Value value, an invalid attribute value was detected. "+
					"A Eth2Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Eth2Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Eth2Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Eth2Value Attribute Value",
				"While creating a Eth2Value value, an extra attribute value was detected. "+
					"A Eth2Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Eth2Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewEth2ValueUnknown(), diags
	}

	additionalVlanIdsAttribute, ok := attributes["additional_vlan_ids"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`additional_vlan_ids is missing from object`)

		return NewEth2ValueUnknown(), diags
	}

	additionalVlanIdsVal, ok := additionalVlanIdsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`additional_vlan_ids expected to be basetypes.ListValue, was: %T`, additionalVlanIdsAttribute))
	}

	enableVlanAttribute, ok := attributes["enable_vlan"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable_vlan is missing from object`)

		return NewEth2ValueUnknown(), diags
	}

	enableVlanVal, ok := enableVlanAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable_vlan expected to be basetypes.BoolValue, was: %T`, enableVlanAttribute))
	}

	portVlanIdAttribute, ok := attributes["port_vlan_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_vlan_id is missing from object`)

		return NewEth2ValueUnknown(), diags
	}

	portVlanIdVal, ok := portVlanIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_vlan_id expected to be basetypes.StringValue, was: %T`, portVlanIdAttribute))
	}

	vlanIdsAttribute, ok := attributes["vlan_ids"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan_ids is missing from object`)

		return NewEth2ValueUnknown(), diags
	}

	vlanIdsVal, ok := vlanIdsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan_ids expected to be basetypes.ListValue, was: %T`, vlanIdsAttribute))
	}

	if diags.HasError() {
		return NewEth2ValueUnknown(), diags
	}

	return Eth2Value{
		AdditionalVlanIds: additionalVlanIdsVal,
		EnableVlan:        enableVlanVal,
		PortVlanId:        portVlanIdVal,
		VlanIds:           vlanIdsVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewEth2ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Eth2Value {
	object, diags := NewEth2Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewEth2ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Eth2Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewEth2ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewEth2ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewEth2ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewEth2ValueMust(Eth2Value{}.AttributeTypes(ctx), attributes), nil
}

func (t Eth2Type) ValueType(ctx context.Context) attr.Value {
	return Eth2Value{}
}

var _ basetypes.ObjectValuable = Eth2Value{}

type Eth2Value struct {
	AdditionalVlanIds basetypes.ListValue   `tfsdk:"additional_vlan_ids"`
	EnableVlan        basetypes.BoolValue   `tfsdk:"enable_vlan"`
	PortVlanId        basetypes.StringValue `tfsdk:"port_vlan_id"`
	VlanIds           basetypes.ListValue   `tfsdk:"vlan_ids"`
	state             attr.ValueState
}

func (v Eth2Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["additional_vlan_ids"] = basetypes.ListType{
		ElemType: types.Int64Type,
	}.TerraformType(ctx)
	attrTypes["enable_vlan"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["port_vlan_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["vlan_ids"] = basetypes.ListType{
		ElemType: types.Int64Type,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.AdditionalVlanIds.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["additional_vlan_ids"] = val

		val, err = v.EnableVlan.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enable_vlan"] = val

		val, err = v.PortVlanId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port_vlan_id"] = val

		val, err = v.VlanIds.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vlan_ids"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Eth2Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Eth2Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Eth2Value) String() string {
	return "Eth2Value"
}

func (v Eth2Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	additionalVlanIdsVal, d := types.ListValue(types.Int64Type, v.AdditionalVlanIds.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"additional_vlan_ids": basetypes.ListType{
				ElemType: types.Int64Type,
			},
			"enable_vlan":  basetypes.BoolType{},
			"port_vlan_id": basetypes.StringType{},
			"vlan_ids": basetypes.ListType{
				ElemType: types.Int64Type,
			},
		}), diags
	}

	vlanIdsVal, d := types.ListValue(types.Int64Type, v.VlanIds.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"additional_vlan_ids": basetypes.ListType{
				ElemType: types.Int64Type,
			},
			"enable_vlan":  basetypes.BoolType{},
			"port_vlan_id": basetypes.StringType{},
			"vlan_ids": basetypes.ListType{
				ElemType: types.Int64Type,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"additional_vlan_ids": basetypes.ListType{
			ElemType: types.Int64Type,
		},
		"enable_vlan":  basetypes.BoolType{},
		"port_vlan_id": basetypes.StringType{},
		"vlan_ids": basetypes.ListType{
			ElemType: types.Int64Type,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"additional_vlan_ids": additionalVlanIdsVal,
			"enable_vlan":         v.EnableVlan,
			"port_vlan_id":        v.PortVlanId,
			"vlan_ids":            vlanIdsVal,
		})

	return objVal, diags
}

func (v Eth2Value) Equal(o attr.Value) bool {
	other, ok := o.(Eth2Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AdditionalVlanIds.Equal(other.AdditionalVlanIds) {
		return false
	}

	if !v.EnableVlan.Equal(other.EnableVlan) {
		return false
	}

	if !v.PortVlanId.Equal(other.PortVlanId) {
		return false
	}

	if !v.VlanIds.Equal(other.VlanIds) {
		return false
	}

	return true
}

func (v Eth2Value) Type(ctx context.Context) attr.Type {
	return Eth2Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Eth2Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"additional_vlan_ids": basetypes.ListType{
			ElemType: types.Int64Type,
		},
		"enable_vlan":  basetypes.BoolType{},
		"port_vlan_id": basetypes.StringType{},
		"vlan_ids": basetypes.ListType{
			ElemType: types.Int64Type,
		},
	}
}

var _ basetypes.ObjectTypable = Eth3Type{}

type Eth3Type struct {
	basetypes.ObjectType
}

func (t Eth3Type) Equal(o attr.Type) bool {
	other, ok := o.(Eth3Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Eth3Type) String() string {
	return "Eth3Type"
}

func (t Eth3Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	additionalVlanIdsAttribute, ok := attributes["additional_vlan_ids"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`additional_vlan_ids is missing from object`)

		return nil, diags
	}

	additionalVlanIdsVal, ok := additionalVlanIdsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`additional_vlan_ids expected to be basetypes.ListValue, was: %T`, additionalVlanIdsAttribute))
	}

	enableVlanAttribute, ok := attributes["enable_vlan"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable_vlan is missing from object`)

		return nil, diags
	}

	enableVlanVal, ok := enableVlanAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable_vlan expected to be basetypes.BoolValue, was: %T`, enableVlanAttribute))
	}

	portVlanIdAttribute, ok := attributes["port_vlan_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_vlan_id is missing from object`)

		return nil, diags
	}

	portVlanIdVal, ok := portVlanIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_vlan_id expected to be basetypes.StringValue, was: %T`, portVlanIdAttribute))
	}

	vlanIdsAttribute, ok := attributes["vlan_ids"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan_ids is missing from object`)

		return nil, diags
	}

	vlanIdsVal, ok := vlanIdsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan_ids expected to be basetypes.ListValue, was: %T`, vlanIdsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Eth3Value{
		AdditionalVlanIds: additionalVlanIdsVal,
		EnableVlan:        enableVlanVal,
		PortVlanId:        portVlanIdVal,
		VlanIds:           vlanIdsVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewEth3ValueNull() Eth3Value {
	return Eth3Value{
		state: attr.ValueStateNull,
	}
}

func NewEth3ValueUnknown() Eth3Value {
	return Eth3Value{
		state: attr.ValueStateUnknown,
	}
}

func NewEth3Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Eth3Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Eth3Value Attribute Value",
				"While creating a Eth3Value value, a missing attribute value was detected. "+
					"A Eth3Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Eth3Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Eth3Value Attribute Type",
				"While creating a Eth3Value value, an invalid attribute value was detected. "+
					"A Eth3Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Eth3Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Eth3Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Eth3Value Attribute Value",
				"While creating a Eth3Value value, an extra attribute value was detected. "+
					"A Eth3Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Eth3Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewEth3ValueUnknown(), diags
	}

	additionalVlanIdsAttribute, ok := attributes["additional_vlan_ids"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`additional_vlan_ids is missing from object`)

		return NewEth3ValueUnknown(), diags
	}

	additionalVlanIdsVal, ok := additionalVlanIdsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`additional_vlan_ids expected to be basetypes.ListValue, was: %T`, additionalVlanIdsAttribute))
	}

	enableVlanAttribute, ok := attributes["enable_vlan"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable_vlan is missing from object`)

		return NewEth3ValueUnknown(), diags
	}

	enableVlanVal, ok := enableVlanAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable_vlan expected to be basetypes.BoolValue, was: %T`, enableVlanAttribute))
	}

	portVlanIdAttribute, ok := attributes["port_vlan_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_vlan_id is missing from object`)

		return NewEth3ValueUnknown(), diags
	}

	portVlanIdVal, ok := portVlanIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_vlan_id expected to be basetypes.StringValue, was: %T`, portVlanIdAttribute))
	}

	vlanIdsAttribute, ok := attributes["vlan_ids"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan_ids is missing from object`)

		return NewEth3ValueUnknown(), diags
	}

	vlanIdsVal, ok := vlanIdsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan_ids expected to be basetypes.ListValue, was: %T`, vlanIdsAttribute))
	}

	if diags.HasError() {
		return NewEth3ValueUnknown(), diags
	}

	return Eth3Value{
		AdditionalVlanIds: additionalVlanIdsVal,
		EnableVlan:        enableVlanVal,
		PortVlanId:        portVlanIdVal,
		VlanIds:           vlanIdsVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewEth3ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Eth3Value {
	object, diags := NewEth3Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewEth3ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Eth3Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewEth3ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewEth3ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewEth3ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewEth3ValueMust(Eth3Value{}.AttributeTypes(ctx), attributes), nil
}

func (t Eth3Type) ValueType(ctx context.Context) attr.Value {
	return Eth3Value{}
}

var _ basetypes.ObjectValuable = Eth3Value{}

type Eth3Value struct {
	AdditionalVlanIds basetypes.ListValue   `tfsdk:"additional_vlan_ids"`
	EnableVlan        basetypes.BoolValue   `tfsdk:"enable_vlan"`
	PortVlanId        basetypes.StringValue `tfsdk:"port_vlan_id"`
	VlanIds           basetypes.ListValue   `tfsdk:"vlan_ids"`
	state             attr.ValueState
}

func (v Eth3Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["additional_vlan_ids"] = basetypes.ListType{
		ElemType: types.Int64Type,
	}.TerraformType(ctx)
	attrTypes["enable_vlan"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["port_vlan_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["vlan_ids"] = basetypes.ListType{
		ElemType: types.Int64Type,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.AdditionalVlanIds.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["additional_vlan_ids"] = val

		val, err = v.EnableVlan.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enable_vlan"] = val

		val, err = v.PortVlanId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port_vlan_id"] = val

		val, err = v.VlanIds.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vlan_ids"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Eth3Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Eth3Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Eth3Value) String() string {
	return "Eth3Value"
}

func (v Eth3Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	additionalVlanIdsVal, d := types.ListValue(types.Int64Type, v.AdditionalVlanIds.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"additional_vlan_ids": basetypes.ListType{
				ElemType: types.Int64Type,
			},
			"enable_vlan":  basetypes.BoolType{},
			"port_vlan_id": basetypes.StringType{},
			"vlan_ids": basetypes.ListType{
				ElemType: types.Int64Type,
			},
		}), diags
	}

	vlanIdsVal, d := types.ListValue(types.Int64Type, v.VlanIds.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"additional_vlan_ids": basetypes.ListType{
				ElemType: types.Int64Type,
			},
			"enable_vlan":  basetypes.BoolType{},
			"port_vlan_id": basetypes.StringType{},
			"vlan_ids": basetypes.ListType{
				ElemType: types.Int64Type,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"additional_vlan_ids": basetypes.ListType{
			ElemType: types.Int64Type,
		},
		"enable_vlan":  basetypes.BoolType{},
		"port_vlan_id": basetypes.StringType{},
		"vlan_ids": basetypes.ListType{
			ElemType: types.Int64Type,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"additional_vlan_ids": additionalVlanIdsVal,
			"enable_vlan":         v.EnableVlan,
			"port_vlan_id":        v.PortVlanId,
			"vlan_ids":            vlanIdsVal,
		})

	return objVal, diags
}

func (v Eth3Value) Equal(o attr.Value) bool {
	other, ok := o.(Eth3Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AdditionalVlanIds.Equal(other.AdditionalVlanIds) {
		return false
	}

	if !v.EnableVlan.Equal(other.EnableVlan) {
		return false
	}

	if !v.PortVlanId.Equal(other.PortVlanId) {
		return false
	}

	if !v.VlanIds.Equal(other.VlanIds) {
		return false
	}

	return true
}

func (v Eth3Value) Type(ctx context.Context) attr.Type {
	return Eth3Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Eth3Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"additional_vlan_ids": basetypes.ListType{
			ElemType: types.Int64Type,
		},
		"enable_vlan":  basetypes.BoolType{},
		"port_vlan_id": basetypes.StringType{},
		"vlan_ids": basetypes.ListType{
			ElemType: types.Int64Type,
		},
	}
}

var _ basetypes.ObjectTypable = ModuleType{}

type ModuleType struct {
	basetypes.ObjectType
}

func (t ModuleType) Equal(o attr.Type) bool {
	other, ok := o.(ModuleType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ModuleType) String() string {
	return "ModuleType"
}

func (t ModuleType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	additionalVlanIdsAttribute, ok := attributes["additional_vlan_ids"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`additional_vlan_ids is missing from object`)

		return nil, diags
	}

	additionalVlanIdsVal, ok := additionalVlanIdsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`additional_vlan_ids expected to be basetypes.ListValue, was: %T`, additionalVlanIdsAttribute))
	}

	enableVlanAttribute, ok := attributes["enable_vlan"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable_vlan is missing from object`)

		return nil, diags
	}

	enableVlanVal, ok := enableVlanAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable_vlan expected to be basetypes.BoolValue, was: %T`, enableVlanAttribute))
	}

	portVlanIdAttribute, ok := attributes["port_vlan_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_vlan_id is missing from object`)

		return nil, diags
	}

	portVlanIdVal, ok := portVlanIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_vlan_id expected to be basetypes.StringValue, was: %T`, portVlanIdAttribute))
	}

	vlanIdsAttribute, ok := attributes["vlan_ids"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan_ids is missing from object`)

		return nil, diags
	}

	vlanIdsVal, ok := vlanIdsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan_ids expected to be basetypes.ListValue, was: %T`, vlanIdsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ModuleValue{
		AdditionalVlanIds: additionalVlanIdsVal,
		EnableVlan:        enableVlanVal,
		PortVlanId:        portVlanIdVal,
		VlanIds:           vlanIdsVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewModuleValueNull() ModuleValue {
	return ModuleValue{
		state: attr.ValueStateNull,
	}
}

func NewModuleValueUnknown() ModuleValue {
	return ModuleValue{
		state: attr.ValueStateUnknown,
	}
}

func NewModuleValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ModuleValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ModuleValue Attribute Value",
				"While creating a ModuleValue value, a missing attribute value was detected. "+
					"A ModuleValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ModuleValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ModuleValue Attribute Type",
				"While creating a ModuleValue value, an invalid attribute value was detected. "+
					"A ModuleValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ModuleValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ModuleValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ModuleValue Attribute Value",
				"While creating a ModuleValue value, an extra attribute value was detected. "+
					"A ModuleValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ModuleValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewModuleValueUnknown(), diags
	}

	additionalVlanIdsAttribute, ok := attributes["additional_vlan_ids"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`additional_vlan_ids is missing from object`)

		return NewModuleValueUnknown(), diags
	}

	additionalVlanIdsVal, ok := additionalVlanIdsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`additional_vlan_ids expected to be basetypes.ListValue, was: %T`, additionalVlanIdsAttribute))
	}

	enableVlanAttribute, ok := attributes["enable_vlan"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable_vlan is missing from object`)

		return NewModuleValueUnknown(), diags
	}

	enableVlanVal, ok := enableVlanAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable_vlan expected to be basetypes.BoolValue, was: %T`, enableVlanAttribute))
	}

	portVlanIdAttribute, ok := attributes["port_vlan_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_vlan_id is missing from object`)

		return NewModuleValueUnknown(), diags
	}

	portVlanIdVal, ok := portVlanIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_vlan_id expected to be basetypes.StringValue, was: %T`, portVlanIdAttribute))
	}

	vlanIdsAttribute, ok := attributes["vlan_ids"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan_ids is missing from object`)

		return NewModuleValueUnknown(), diags
	}

	vlanIdsVal, ok := vlanIdsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan_ids expected to be basetypes.ListValue, was: %T`, vlanIdsAttribute))
	}

	if diags.HasError() {
		return NewModuleValueUnknown(), diags
	}

	return ModuleValue{
		AdditionalVlanIds: additionalVlanIdsVal,
		EnableVlan:        enableVlanVal,
		PortVlanId:        portVlanIdVal,
		VlanIds:           vlanIdsVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewModuleValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ModuleValue {
	object, diags := NewModuleValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewModuleValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ModuleType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewModuleValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewModuleValueUnknown(), nil
	}

	if in.IsNull() {
		return NewModuleValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewModuleValueMust(ModuleValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ModuleType) ValueType(ctx context.Context) attr.Value {
	return ModuleValue{}
}

var _ basetypes.ObjectValuable = ModuleValue{}

type ModuleValue struct {
	AdditionalVlanIds basetypes.ListValue   `tfsdk:"additional_vlan_ids"`
	EnableVlan        basetypes.BoolValue   `tfsdk:"enable_vlan"`
	PortVlanId        basetypes.StringValue `tfsdk:"port_vlan_id"`
	VlanIds           basetypes.ListValue   `tfsdk:"vlan_ids"`
	state             attr.ValueState
}

func (v ModuleValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["additional_vlan_ids"] = basetypes.ListType{
		ElemType: types.Int64Type,
	}.TerraformType(ctx)
	attrTypes["enable_vlan"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["port_vlan_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["vlan_ids"] = basetypes.ListType{
		ElemType: types.Int64Type,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.AdditionalVlanIds.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["additional_vlan_ids"] = val

		val, err = v.EnableVlan.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enable_vlan"] = val

		val, err = v.PortVlanId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port_vlan_id"] = val

		val, err = v.VlanIds.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vlan_ids"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ModuleValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ModuleValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ModuleValue) String() string {
	return "ModuleValue"
}

func (v ModuleValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	additionalVlanIdsVal, d := types.ListValue(types.Int64Type, v.AdditionalVlanIds.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"additional_vlan_ids": basetypes.ListType{
				ElemType: types.Int64Type,
			},
			"enable_vlan":  basetypes.BoolType{},
			"port_vlan_id": basetypes.StringType{},
			"vlan_ids": basetypes.ListType{
				ElemType: types.Int64Type,
			},
		}), diags
	}

	vlanIdsVal, d := types.ListValue(types.Int64Type, v.VlanIds.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"additional_vlan_ids": basetypes.ListType{
				ElemType: types.Int64Type,
			},
			"enable_vlan":  basetypes.BoolType{},
			"port_vlan_id": basetypes.StringType{},
			"vlan_ids": basetypes.ListType{
				ElemType: types.Int64Type,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"additional_vlan_ids": basetypes.ListType{
			ElemType: types.Int64Type,
		},
		"enable_vlan":  basetypes.BoolType{},
		"port_vlan_id": basetypes.StringType{},
		"vlan_ids": basetypes.ListType{
			ElemType: types.Int64Type,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"additional_vlan_ids": additionalVlanIdsVal,
			"enable_vlan":         v.EnableVlan,
			"port_vlan_id":        v.PortVlanId,
			"vlan_ids":            vlanIdsVal,
		})

	return objVal, diags
}

func (v ModuleValue) Equal(o attr.Value) bool {
	other, ok := o.(ModuleValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AdditionalVlanIds.Equal(other.AdditionalVlanIds) {
		return false
	}

	if !v.EnableVlan.Equal(other.EnableVlan) {
		return false
	}

	if !v.PortVlanId.Equal(other.PortVlanId) {
		return false
	}

	if !v.VlanIds.Equal(other.VlanIds) {
		return false
	}

	return true
}

func (v ModuleValue) Type(ctx context.Context) attr.Type {
	return ModuleType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ModuleValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"additional_vlan_ids": basetypes.ListType{
			ElemType: types.Int64Type,
		},
		"enable_vlan":  basetypes.BoolType{},
		"port_vlan_id": basetypes.StringType{},
		"vlan_ids": basetypes.ListType{
			ElemType: types.Int64Type,
		},
	}
}

var _ basetypes.ObjectTypable = WdsType{}

type WdsType struct {
	basetypes.ObjectType
}

func (t WdsType) Equal(o attr.Type) bool {
	other, ok := o.(WdsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t WdsType) String() string {
	return "WdsType"
}

func (t WdsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	additionalVlanIdsAttribute, ok := attributes["additional_vlan_ids"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`additional_vlan_ids is missing from object`)

		return nil, diags
	}

	additionalVlanIdsVal, ok := additionalVlanIdsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`additional_vlan_ids expected to be basetypes.ListValue, was: %T`, additionalVlanIdsAttribute))
	}

	enableVlanAttribute, ok := attributes["enable_vlan"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable_vlan is missing from object`)

		return nil, diags
	}

	enableVlanVal, ok := enableVlanAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable_vlan expected to be basetypes.BoolValue, was: %T`, enableVlanAttribute))
	}

	portVlanIdAttribute, ok := attributes["port_vlan_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_vlan_id is missing from object`)

		return nil, diags
	}

	portVlanIdVal, ok := portVlanIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_vlan_id expected to be basetypes.StringValue, was: %T`, portVlanIdAttribute))
	}

	vlanIdsAttribute, ok := attributes["vlan_ids"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan_ids is missing from object`)

		return nil, diags
	}

	vlanIdsVal, ok := vlanIdsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan_ids expected to be basetypes.ListValue, was: %T`, vlanIdsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return WdsValue{
		AdditionalVlanIds: additionalVlanIdsVal,
		EnableVlan:        enableVlanVal,
		PortVlanId:        portVlanIdVal,
		VlanIds:           vlanIdsVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewWdsValueNull() WdsValue {
	return WdsValue{
		state: attr.ValueStateNull,
	}
}

func NewWdsValueUnknown() WdsValue {
	return WdsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewWdsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (WdsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing WdsValue Attribute Value",
				"While creating a WdsValue value, a missing attribute value was detected. "+
					"A WdsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("WdsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid WdsValue Attribute Type",
				"While creating a WdsValue value, an invalid attribute value was detected. "+
					"A WdsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("WdsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("WdsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra WdsValue Attribute Value",
				"While creating a WdsValue value, an extra attribute value was detected. "+
					"A WdsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra WdsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewWdsValueUnknown(), diags
	}

	additionalVlanIdsAttribute, ok := attributes["additional_vlan_ids"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`additional_vlan_ids is missing from object`)

		return NewWdsValueUnknown(), diags
	}

	additionalVlanIdsVal, ok := additionalVlanIdsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`additional_vlan_ids expected to be basetypes.ListValue, was: %T`, additionalVlanIdsAttribute))
	}

	enableVlanAttribute, ok := attributes["enable_vlan"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable_vlan is missing from object`)

		return NewWdsValueUnknown(), diags
	}

	enableVlanVal, ok := enableVlanAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable_vlan expected to be basetypes.BoolValue, was: %T`, enableVlanAttribute))
	}

	portVlanIdAttribute, ok := attributes["port_vlan_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_vlan_id is missing from object`)

		return NewWdsValueUnknown(), diags
	}

	portVlanIdVal, ok := portVlanIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_vlan_id expected to be basetypes.StringValue, was: %T`, portVlanIdAttribute))
	}

	vlanIdsAttribute, ok := attributes["vlan_ids"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan_ids is missing from object`)

		return NewWdsValueUnknown(), diags
	}

	vlanIdsVal, ok := vlanIdsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan_ids expected to be basetypes.ListValue, was: %T`, vlanIdsAttribute))
	}

	if diags.HasError() {
		return NewWdsValueUnknown(), diags
	}

	return WdsValue{
		AdditionalVlanIds: additionalVlanIdsVal,
		EnableVlan:        enableVlanVal,
		PortVlanId:        portVlanIdVal,
		VlanIds:           vlanIdsVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewWdsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) WdsValue {
	object, diags := NewWdsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewWdsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t WdsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewWdsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewWdsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewWdsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewWdsValueMust(WdsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t WdsType) ValueType(ctx context.Context) attr.Value {
	return WdsValue{}
}

var _ basetypes.ObjectValuable = WdsValue{}

type WdsValue struct {
	AdditionalVlanIds basetypes.ListValue   `tfsdk:"additional_vlan_ids"`
	EnableVlan        basetypes.BoolValue   `tfsdk:"enable_vlan"`
	PortVlanId        basetypes.StringValue `tfsdk:"port_vlan_id"`
	VlanIds           basetypes.ListValue   `tfsdk:"vlan_ids"`
	state             attr.ValueState
}

func (v WdsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["additional_vlan_ids"] = basetypes.ListType{
		ElemType: types.Int64Type,
	}.TerraformType(ctx)
	attrTypes["enable_vlan"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["port_vlan_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["vlan_ids"] = basetypes.ListType{
		ElemType: types.Int64Type,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.AdditionalVlanIds.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["additional_vlan_ids"] = val

		val, err = v.EnableVlan.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enable_vlan"] = val

		val, err = v.PortVlanId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port_vlan_id"] = val

		val, err = v.VlanIds.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vlan_ids"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v WdsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v WdsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v WdsValue) String() string {
	return "WdsValue"
}

func (v WdsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	additionalVlanIdsVal, d := types.ListValue(types.Int64Type, v.AdditionalVlanIds.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"additional_vlan_ids": basetypes.ListType{
				ElemType: types.Int64Type,
			},
			"enable_vlan":  basetypes.BoolType{},
			"port_vlan_id": basetypes.StringType{},
			"vlan_ids": basetypes.ListType{
				ElemType: types.Int64Type,
			},
		}), diags
	}

	vlanIdsVal, d := types.ListValue(types.Int64Type, v.VlanIds.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"additional_vlan_ids": basetypes.ListType{
				ElemType: types.Int64Type,
			},
			"enable_vlan":  basetypes.BoolType{},
			"port_vlan_id": basetypes.StringType{},
			"vlan_ids": basetypes.ListType{
				ElemType: types.Int64Type,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"additional_vlan_ids": basetypes.ListType{
			ElemType: types.Int64Type,
		},
		"enable_vlan":  basetypes.BoolType{},
		"port_vlan_id": basetypes.StringType{},
		"vlan_ids": basetypes.ListType{
			ElemType: types.Int64Type,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"additional_vlan_ids": additionalVlanIdsVal,
			"enable_vlan":         v.EnableVlan,
			"port_vlan_id":        v.PortVlanId,
			"vlan_ids":            vlanIdsVal,
		})

	return objVal, diags
}

func (v WdsValue) Equal(o attr.Value) bool {
	other, ok := o.(WdsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AdditionalVlanIds.Equal(other.AdditionalVlanIds) {
		return false
	}

	if !v.EnableVlan.Equal(other.EnableVlan) {
		return false
	}

	if !v.PortVlanId.Equal(other.PortVlanId) {
		return false
	}

	if !v.VlanIds.Equal(other.VlanIds) {
		return false
	}

	return true
}

func (v WdsValue) Type(ctx context.Context) attr.Type {
	return WdsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v WdsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"additional_vlan_ids": basetypes.ListType{
			ElemType: types.Int64Type,
		},
		"enable_vlan":  basetypes.BoolType{},
		"port_vlan_id": basetypes.StringType{},
		"vlan_ids": basetypes.ListType{
			ElemType: types.Int64Type,
		},
	}
}

var _ basetypes.ObjectTypable = UplinkPortConfigType{}

type UplinkPortConfigType struct {
	basetypes.ObjectType
}

func (t UplinkPortConfigType) Equal(o attr.Type) bool {
	other, ok := o.(UplinkPortConfigType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t UplinkPortConfigType) String() string {
	return "UplinkPortConfigType"
}

func (t UplinkPortConfigType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	dot1xAttribute, ok := attributes["dot1x"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dot1x is missing from object`)

		return nil, diags
	}

	dot1xVal, ok := dot1xAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dot1x expected to be basetypes.BoolValue, was: %T`, dot1xAttribute))
	}

	keepWlansUpIfDownAttribute, ok := attributes["keep_wlans_up_if_down"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keep_wlans_up_if_down is missing from object`)

		return nil, diags
	}

	keepWlansUpIfDownVal, ok := keepWlansUpIfDownAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keep_wlans_up_if_down expected to be basetypes.BoolValue, was: %T`, keepWlansUpIfDownAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return UplinkPortConfigValue{
		Dot1x:             dot1xVal,
		KeepWlansUpIfDown: keepWlansUpIfDownVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewUplinkPortConfigValueNull() UplinkPortConfigValue {
	return UplinkPortConfigValue{
		state: attr.ValueStateNull,
	}
}

func NewUplinkPortConfigValueUnknown() UplinkPortConfigValue {
	return UplinkPortConfigValue{
		state: attr.ValueStateUnknown,
	}
}

func NewUplinkPortConfigValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (UplinkPortConfigValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing UplinkPortConfigValue Attribute Value",
				"While creating a UplinkPortConfigValue value, a missing attribute value was detected. "+
					"A UplinkPortConfigValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("UplinkPortConfigValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid UplinkPortConfigValue Attribute Type",
				"While creating a UplinkPortConfigValue value, an invalid attribute value was detected. "+
					"A UplinkPortConfigValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("UplinkPortConfigValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("UplinkPortConfigValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra UplinkPortConfigValue Attribute Value",
				"While creating a UplinkPortConfigValue value, an extra attribute value was detected. "+
					"A UplinkPortConfigValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra UplinkPortConfigValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewUplinkPortConfigValueUnknown(), diags
	}

	dot1xAttribute, ok := attributes["dot1x"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dot1x is missing from object`)

		return NewUplinkPortConfigValueUnknown(), diags
	}

	dot1xVal, ok := dot1xAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dot1x expected to be basetypes.BoolValue, was: %T`, dot1xAttribute))
	}

	keepWlansUpIfDownAttribute, ok := attributes["keep_wlans_up_if_down"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keep_wlans_up_if_down is missing from object`)

		return NewUplinkPortConfigValueUnknown(), diags
	}

	keepWlansUpIfDownVal, ok := keepWlansUpIfDownAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keep_wlans_up_if_down expected to be basetypes.BoolValue, was: %T`, keepWlansUpIfDownAttribute))
	}

	if diags.HasError() {
		return NewUplinkPortConfigValueUnknown(), diags
	}

	return UplinkPortConfigValue{
		Dot1x:             dot1xVal,
		KeepWlansUpIfDown: keepWlansUpIfDownVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewUplinkPortConfigValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) UplinkPortConfigValue {
	object, diags := NewUplinkPortConfigValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewUplinkPortConfigValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t UplinkPortConfigType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewUplinkPortConfigValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewUplinkPortConfigValueUnknown(), nil
	}

	if in.IsNull() {
		return NewUplinkPortConfigValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewUplinkPortConfigValueMust(UplinkPortConfigValue{}.AttributeTypes(ctx), attributes), nil
}

func (t UplinkPortConfigType) ValueType(ctx context.Context) attr.Value {
	return UplinkPortConfigValue{}
}

var _ basetypes.ObjectValuable = UplinkPortConfigValue{}

type UplinkPortConfigValue struct {
	Dot1x             basetypes.BoolValue `tfsdk:"dot1x"`
	KeepWlansUpIfDown basetypes.BoolValue `tfsdk:"keep_wlans_up_if_down"`
	state             attr.ValueState
}

func (v UplinkPortConfigValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["dot1x"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["keep_wlans_up_if_down"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Dot1x.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dot1x"] = val

		val, err = v.KeepWlansUpIfDown.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["keep_wlans_up_if_down"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v UplinkPortConfigValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v UplinkPortConfigValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v UplinkPortConfigValue) String() string {
	return "UplinkPortConfigValue"
}

func (v UplinkPortConfigValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"dot1x":                 basetypes.BoolType{},
		"keep_wlans_up_if_down": basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"dot1x":                 v.Dot1x,
			"keep_wlans_up_if_down": v.KeepWlansUpIfDown,
		})

	return objVal, diags
}

func (v UplinkPortConfigValue) Equal(o attr.Value) bool {
	other, ok := o.(UplinkPortConfigValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Dot1x.Equal(other.Dot1x) {
		return false
	}

	if !v.KeepWlansUpIfDown.Equal(other.KeepWlansUpIfDown) {
		return false
	}

	return true
}

func (v UplinkPortConfigValue) Type(ctx context.Context) attr.Type {
	return UplinkPortConfigType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v UplinkPortConfigValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"dot1x":                 basetypes.BoolType{},
		"keep_wlans_up_if_down": basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = UsbConfigType{}

type UsbConfigType struct {
	basetypes.ObjectType
}

func (t UsbConfigType) Equal(o attr.Type) bool {
	other, ok := o.(UsbConfigType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t UsbConfigType) String() string {
	return "UsbConfigType"
}

func (t UsbConfigType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	cacertAttribute, ok := attributes["cacert"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cacert is missing from object`)

		return nil, diags
	}

	cacertVal, ok := cacertAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cacert expected to be basetypes.StringValue, was: %T`, cacertAttribute))
	}

	channelAttribute, ok := attributes["channel"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`channel is missing from object`)

		return nil, diags
	}

	channelVal, ok := channelAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`channel expected to be basetypes.Int64Value, was: %T`, channelAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	hostAttribute, ok := attributes["host"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`host is missing from object`)

		return nil, diags
	}

	hostVal, ok := hostAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`host expected to be basetypes.StringValue, was: %T`, hostAttribute))
	}

	portAttribute, ok := attributes["port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port is missing from object`)

		return nil, diags
	}

	portVal, ok := portAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port expected to be basetypes.Int64Value, was: %T`, portAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	verifyCertAttribute, ok := attributes["verify_cert"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`verify_cert is missing from object`)

		return nil, diags
	}

	verifyCertVal, ok := verifyCertAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`verify_cert expected to be basetypes.BoolValue, was: %T`, verifyCertAttribute))
	}

	vlanIdAttribute, ok := attributes["vlan_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan_id is missing from object`)

		return nil, diags
	}

	vlanIdVal, ok := vlanIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan_id expected to be basetypes.Int64Value, was: %T`, vlanIdAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return UsbConfigValue{
		Cacert:        cacertVal,
		Channel:       channelVal,
		Enabled:       enabledVal,
		Host:          hostVal,
		Port:          portVal,
		UsbConfigType: typeVal,
		VerifyCert:    verifyCertVal,
		VlanId:        vlanIdVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewUsbConfigValueNull() UsbConfigValue {
	return UsbConfigValue{
		state: attr.ValueStateNull,
	}
}

func NewUsbConfigValueUnknown() UsbConfigValue {
	return UsbConfigValue{
		state: attr.ValueStateUnknown,
	}
}

func NewUsbConfigValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (UsbConfigValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing UsbConfigValue Attribute Value",
				"While creating a UsbConfigValue value, a missing attribute value was detected. "+
					"A UsbConfigValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("UsbConfigValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid UsbConfigValue Attribute Type",
				"While creating a UsbConfigValue value, an invalid attribute value was detected. "+
					"A UsbConfigValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("UsbConfigValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("UsbConfigValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra UsbConfigValue Attribute Value",
				"While creating a UsbConfigValue value, an extra attribute value was detected. "+
					"A UsbConfigValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra UsbConfigValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewUsbConfigValueUnknown(), diags
	}

	cacertAttribute, ok := attributes["cacert"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cacert is missing from object`)

		return NewUsbConfigValueUnknown(), diags
	}

	cacertVal, ok := cacertAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cacert expected to be basetypes.StringValue, was: %T`, cacertAttribute))
	}

	channelAttribute, ok := attributes["channel"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`channel is missing from object`)

		return NewUsbConfigValueUnknown(), diags
	}

	channelVal, ok := channelAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`channel expected to be basetypes.Int64Value, was: %T`, channelAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewUsbConfigValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	hostAttribute, ok := attributes["host"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`host is missing from object`)

		return NewUsbConfigValueUnknown(), diags
	}

	hostVal, ok := hostAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`host expected to be basetypes.StringValue, was: %T`, hostAttribute))
	}

	portAttribute, ok := attributes["port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port is missing from object`)

		return NewUsbConfigValueUnknown(), diags
	}

	portVal, ok := portAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port expected to be basetypes.Int64Value, was: %T`, portAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewUsbConfigValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	verifyCertAttribute, ok := attributes["verify_cert"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`verify_cert is missing from object`)

		return NewUsbConfigValueUnknown(), diags
	}

	verifyCertVal, ok := verifyCertAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`verify_cert expected to be basetypes.BoolValue, was: %T`, verifyCertAttribute))
	}

	vlanIdAttribute, ok := attributes["vlan_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan_id is missing from object`)

		return NewUsbConfigValueUnknown(), diags
	}

	vlanIdVal, ok := vlanIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan_id expected to be basetypes.Int64Value, was: %T`, vlanIdAttribute))
	}

	if diags.HasError() {
		return NewUsbConfigValueUnknown(), diags
	}

	return UsbConfigValue{
		Cacert:        cacertVal,
		Channel:       channelVal,
		Enabled:       enabledVal,
		Host:          hostVal,
		Port:          portVal,
		UsbConfigType: typeVal,
		VerifyCert:    verifyCertVal,
		VlanId:        vlanIdVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewUsbConfigValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) UsbConfigValue {
	object, diags := NewUsbConfigValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewUsbConfigValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t UsbConfigType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewUsbConfigValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewUsbConfigValueUnknown(), nil
	}

	if in.IsNull() {
		return NewUsbConfigValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewUsbConfigValueMust(UsbConfigValue{}.AttributeTypes(ctx), attributes), nil
}

func (t UsbConfigType) ValueType(ctx context.Context) attr.Value {
	return UsbConfigValue{}
}

var _ basetypes.ObjectValuable = UsbConfigValue{}

type UsbConfigValue struct {
	Cacert        basetypes.StringValue `tfsdk:"cacert"`
	Channel       basetypes.Int64Value  `tfsdk:"channel"`
	Enabled       basetypes.BoolValue   `tfsdk:"enabled"`
	Host          basetypes.StringValue `tfsdk:"host"`
	Port          basetypes.Int64Value  `tfsdk:"port"`
	UsbConfigType basetypes.StringValue `tfsdk:"type"`
	VerifyCert    basetypes.BoolValue   `tfsdk:"verify_cert"`
	VlanId        basetypes.Int64Value  `tfsdk:"vlan_id"`
	state         attr.ValueState
}

func (v UsbConfigValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 8)

	var val tftypes.Value
	var err error

	attrTypes["cacert"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["channel"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["host"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["port"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["verify_cert"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["vlan_id"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 8)

		val, err = v.Cacert.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cacert"] = val

		val, err = v.Channel.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["channel"] = val

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.Host.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["host"] = val

		val, err = v.Port.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port"] = val

		val, err = v.UsbConfigType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		val, err = v.VerifyCert.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["verify_cert"] = val

		val, err = v.VlanId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vlan_id"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v UsbConfigValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v UsbConfigValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v UsbConfigValue) String() string {
	return "UsbConfigValue"
}

func (v UsbConfigValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"cacert":      basetypes.StringType{},
		"channel":     basetypes.Int64Type{},
		"enabled":     basetypes.BoolType{},
		"host":        basetypes.StringType{},
		"port":        basetypes.Int64Type{},
		"type":        basetypes.StringType{},
		"verify_cert": basetypes.BoolType{},
		"vlan_id":     basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"cacert":      v.Cacert,
			"channel":     v.Channel,
			"enabled":     v.Enabled,
			"host":        v.Host,
			"port":        v.Port,
			"type":        v.UsbConfigType,
			"verify_cert": v.VerifyCert,
			"vlan_id":     v.VlanId,
		})

	return objVal, diags
}

func (v UsbConfigValue) Equal(o attr.Value) bool {
	other, ok := o.(UsbConfigValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Cacert.Equal(other.Cacert) {
		return false
	}

	if !v.Channel.Equal(other.Channel) {
		return false
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.Host.Equal(other.Host) {
		return false
	}

	if !v.Port.Equal(other.Port) {
		return false
	}

	if !v.UsbConfigType.Equal(other.UsbConfigType) {
		return false
	}

	if !v.VerifyCert.Equal(other.VerifyCert) {
		return false
	}

	if !v.VlanId.Equal(other.VlanId) {
		return false
	}

	return true
}

func (v UsbConfigValue) Type(ctx context.Context) attr.Type {
	return UsbConfigType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v UsbConfigValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"cacert":      basetypes.StringType{},
		"channel":     basetypes.Int64Type{},
		"enabled":     basetypes.BoolType{},
		"host":        basetypes.StringType{},
		"port":        basetypes.Int64Type{},
		"type":        basetypes.StringType{},
		"verify_cert": basetypes.BoolType{},
		"vlan_id":     basetypes.Int64Type{},
	}
}
