// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package resource_org_evpn_topology

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework-validators/int64validator"
	"github.com/hashicorp/terraform-plugin-framework-validators/listvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/mapvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/booldefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/int64default"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
)

func OrgEvpnTopologyResourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"evpn_options": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"auto_loopback_subnet": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "optional, for dhcp_relay, unique loopback IPs are required for ERB or IPClos where we can set option-82 server_id-overrides",
						MarkdownDescription: "optional, for dhcp_relay, unique loopback IPs are required for ERB or IPClos where we can set option-82 server_id-overrides",
						Default:             stringdefault.StaticString("172.16.192.0/24"),
					},
					"auto_loopback_subnet6": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "optional, for dhcp_relay, unique loopback IPs are required for ERB or IPClos where we can set option-82 server_id-overrides",
						MarkdownDescription: "optional, for dhcp_relay, unique loopback IPs are required for ERB or IPClos where we can set option-82 server_id-overrides",
						Default:             stringdefault.StaticString("fd33:ab00:2::/64"),
					},
					"auto_router_id_subnet": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "optional, this generates router_id automatically, if specified, `router_id_prefix` is ignored",
						MarkdownDescription: "optional, this generates router_id automatically, if specified, `router_id_prefix` is ignored",
						Default:             stringdefault.StaticString("172.16.254.0/23"),
					},
					"auto_router_id_subnet6": schema.StringAttribute{
						Optional:            true,
						Description:         "optional, this generates router_id automatically, if specified, `router_id_prefix` is ignored",
						MarkdownDescription: "optional, this generates router_id automatically, if specified, `router_id_prefix` is ignored",
					},
					"core_as_border": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "optional, for ERB or CLOS, you can either use esilag to upstream routers or to also be the virtual-gateway\nwhen `routed_at` != `core`, whether to do virtual-gateway at core as well",
						MarkdownDescription: "optional, for ERB or CLOS, you can either use esilag to upstream routers or to also be the virtual-gateway\nwhen `routed_at` != `core`, whether to do virtual-gateway at core as well",
						Default:             booldefault.StaticBool(false),
					},
					"overlay": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"as": schema.Int64Attribute{
								Optional:            true,
								Computed:            true,
								Description:         "Overlay BGP Local AS Number",
								MarkdownDescription: "Overlay BGP Local AS Number",
								Validators: []validator.Int64{
									int64validator.Between(1, 65535),
								},
								Default: int64default.StaticInt64(65000),
							},
						},
						CustomType: OverlayType{
							ObjectType: types.ObjectType{
								AttrTypes: OverlayValue{}.AttributeTypes(ctx),
							},
						},
						Optional: true,
					},
					"per_vlan_vga_v4_mac": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "by default, JUNOS uses 00-00-5e-00-01-01 as the virtual-gateway-address's v4_mac\nif enabled, 00-00-5e-00-XX-YY will be used (where XX=vlan_id/256, YY=vlan_id%256)",
						MarkdownDescription: "by default, JUNOS uses 00-00-5e-00-01-01 as the virtual-gateway-address's v4_mac\nif enabled, 00-00-5e-00-XX-YY will be used (where XX=vlan_id/256, YY=vlan_id%256)",
						Default:             booldefault.StaticBool(false),
					},
					"routed_at": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "optional, where virtual-gateway should reside. enum: `core`, `distribution`, `edge`",
						MarkdownDescription: "optional, where virtual-gateway should reside. enum: `core`, `distribution`, `edge`",
						Validators: []validator.String{
							stringvalidator.OneOf(
								"",
								"core",
								"distribution",
								"edge",
							),
						},
						Default: stringdefault.StaticString("edge"),
					},
					"underlay": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"as_base": schema.Int64Attribute{
								Optional:            true,
								Computed:            true,
								Description:         "Underlay BGP Base AS Number",
								MarkdownDescription: "Underlay BGP Base AS Number",
								Validators: []validator.Int64{
									int64validator.Between(1, 65535),
								},
								Default: int64default.StaticInt64(65001),
							},
							"routed_id_prefix": schema.StringAttribute{
								Optional: true,
							},
							"subnet": schema.StringAttribute{
								Optional:            true,
								Description:         "underlay subnet, by default, `10.255.240.0/20`, or `fd31:5700::/64` for ipv6",
								MarkdownDescription: "underlay subnet, by default, `10.255.240.0/20`, or `fd31:5700::/64` for ipv6",
							},
							"use_ipv6": schema.BoolAttribute{
								Optional:            true,
								Computed:            true,
								Description:         "if v6 is desired for underlay",
								MarkdownDescription: "if v6 is desired for underlay",
								Default:             booldefault.StaticBool(false),
							},
						},
						CustomType: UnderlayType{
							ObjectType: types.ObjectType{
								AttrTypes: UnderlayValue{}.AttributeTypes(ctx),
							},
						},
						Optional: true,
					},
					"vs_instances": schema.MapNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"networks": schema.ListAttribute{
									ElementType: types.StringType,
									Optional:    true,
									Validators: []validator.List{
										listvalidator.UniqueValues(),
									},
								},
							},
							CustomType: VsInstancesType{
								ObjectType: types.ObjectType{
									AttrTypes: VsInstancesValue{}.AttributeTypes(ctx),
								},
							},
						},
						Optional:            true,
						Description:         "optional, for EX9200 only to seggregate virtual-switches",
						MarkdownDescription: "optional, for EX9200 only to seggregate virtual-switches",
						Validators: []validator.Map{
							mapvalidator.SizeAtLeast(1),
						},
					},
				},
				CustomType: EvpnOptionsType{
					ObjectType: types.ObjectType{
						AttrTypes: EvpnOptionsValue{}.AttributeTypes(ctx),
					},
				},
				Optional:            true,
				Description:         "EVPN Options",
				MarkdownDescription: "EVPN Options",
			},
			"id": schema.StringAttribute{
				Computed:            true,
				Description:         "Unique ID of the object instance in the Mist Organnization",
				MarkdownDescription: "Unique ID of the object instance in the Mist Organnization",
			},
			"name": schema.StringAttribute{
				Required: true,
				Validators: []validator.String{
					stringvalidator.LengthBetween(1, 64),
				},
			},
			"org_id": schema.StringAttribute{
				Required: true,
			},
			"pod_names": schema.MapAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Computed:            true,
				Description:         "Property key is the pod number",
				MarkdownDescription: "Property key is the pod number",
			},
			"switches": schema.MapNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"deviceprofile_id": schema.StringAttribute{
							Computed: true,
						},
						"evpn_id": schema.Int64Attribute{
							Computed: true,
							Validators: []validator.Int64{
								int64validator.AtLeast(1),
							},
						},
						"mac": schema.StringAttribute{
							Computed: true,
							Validators: []validator.String{
								stringvalidator.LengthAtLeast(1),
							},
						},
						"model": schema.StringAttribute{
							Computed: true,
						},
						"pod": schema.Int64Attribute{
							Optional:            true,
							Computed:            true,
							Description:         "optionally, for distribution / access / esilag-access, they can be placed into different pods. e.g. \n  * for CLOS, to group dist / access switches into pods\n  * for ERB/CRB, to group dist / esilag-access into pods",
							MarkdownDescription: "optionally, for distribution / access / esilag-access, they can be placed into different pods. e.g. \n  * for CLOS, to group dist / access switches into pods\n  * for ERB/CRB, to group dist / esilag-access into pods",
							Validators: []validator.Int64{
								int64validator.Between(1, 255),
							},
							Default: int64default.StaticInt64(1),
						},
						"pods": schema.ListAttribute{
							ElementType:         types.Int64Type,
							Optional:            true,
							Computed:            true,
							Description:         "by default, core switches are assumed to be connecting all pods. \nif you want to limit the pods, you can specify pods.",
							MarkdownDescription: "by default, core switches are assumed to be connecting all pods. \nif you want to limit the pods, you can specify pods.",
						},
						"role": schema.StringAttribute{
							Required:            true,
							Description:         "use `role`==`none` to remove a switch from the topology. enum: `access`, `collapsed-core`, `core`, `distribution`, `esilag-access`, `none`",
							MarkdownDescription: "use `role`==`none` to remove a switch from the topology. enum: `access`, `collapsed-core`, `core`, `distribution`, `esilag-access`, `none`",
							Validators: []validator.String{
								stringvalidator.OneOf(
									"",
									"access",
									"collapsed-core",
									"core",
									"distribution",
									"esilag-access",
									"none",
								),
								stringvalidator.LengthAtLeast(1),
							},
						},
						"router_id": schema.StringAttribute{
							Computed: true,
						},
						"site_id": schema.StringAttribute{
							Computed: true,
						},
					},
					CustomType: SwitchesType{
						ObjectType: types.ObjectType{
							AttrTypes: SwitchesValue{}.AttributeTypes(ctx),
						},
					},
				},
				Required:            true,
				Description:         "Property key can be the switch MAC Address",
				MarkdownDescription: "Property key can be the switch MAC Address",
				Validators: []validator.Map{
					mapvalidator.SizeAtLeast(1),
				},
			},
		},
	}
}

type OrgEvpnTopologyModel struct {
	EvpnOptions EvpnOptionsValue `tfsdk:"evpn_options"`
	Id          types.String     `tfsdk:"id"`
	Name        types.String     `tfsdk:"name"`
	OrgId       types.String     `tfsdk:"org_id"`
	PodNames    types.Map        `tfsdk:"pod_names"`
	Switches    types.Map        `tfsdk:"switches"`
}

var _ basetypes.ObjectTypable = EvpnOptionsType{}

type EvpnOptionsType struct {
	basetypes.ObjectType
}

func (t EvpnOptionsType) Equal(o attr.Type) bool {
	other, ok := o.(EvpnOptionsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t EvpnOptionsType) String() string {
	return "EvpnOptionsType"
}

func (t EvpnOptionsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	autoLoopbackSubnetAttribute, ok := attributes["auto_loopback_subnet"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auto_loopback_subnet is missing from object`)

		return nil, diags
	}

	autoLoopbackSubnetVal, ok := autoLoopbackSubnetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auto_loopback_subnet expected to be basetypes.StringValue, was: %T`, autoLoopbackSubnetAttribute))
	}

	autoLoopbackSubnet6Attribute, ok := attributes["auto_loopback_subnet6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auto_loopback_subnet6 is missing from object`)

		return nil, diags
	}

	autoLoopbackSubnet6Val, ok := autoLoopbackSubnet6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auto_loopback_subnet6 expected to be basetypes.StringValue, was: %T`, autoLoopbackSubnet6Attribute))
	}

	autoRouterIdSubnetAttribute, ok := attributes["auto_router_id_subnet"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auto_router_id_subnet is missing from object`)

		return nil, diags
	}

	autoRouterIdSubnetVal, ok := autoRouterIdSubnetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auto_router_id_subnet expected to be basetypes.StringValue, was: %T`, autoRouterIdSubnetAttribute))
	}

	autoRouterIdSubnet6Attribute, ok := attributes["auto_router_id_subnet6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auto_router_id_subnet6 is missing from object`)

		return nil, diags
	}

	autoRouterIdSubnet6Val, ok := autoRouterIdSubnet6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auto_router_id_subnet6 expected to be basetypes.StringValue, was: %T`, autoRouterIdSubnet6Attribute))
	}

	coreAsBorderAttribute, ok := attributes["core_as_border"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`core_as_border is missing from object`)

		return nil, diags
	}

	coreAsBorderVal, ok := coreAsBorderAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`core_as_border expected to be basetypes.BoolValue, was: %T`, coreAsBorderAttribute))
	}

	overlayAttribute, ok := attributes["overlay"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`overlay is missing from object`)

		return nil, diags
	}

	overlayVal, ok := overlayAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`overlay expected to be basetypes.ObjectValue, was: %T`, overlayAttribute))
	}

	perVlanVgaV4MacAttribute, ok := attributes["per_vlan_vga_v4_mac"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`per_vlan_vga_v4_mac is missing from object`)

		return nil, diags
	}

	perVlanVgaV4MacVal, ok := perVlanVgaV4MacAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`per_vlan_vga_v4_mac expected to be basetypes.BoolValue, was: %T`, perVlanVgaV4MacAttribute))
	}

	routedAtAttribute, ok := attributes["routed_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`routed_at is missing from object`)

		return nil, diags
	}

	routedAtVal, ok := routedAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`routed_at expected to be basetypes.StringValue, was: %T`, routedAtAttribute))
	}

	underlayAttribute, ok := attributes["underlay"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`underlay is missing from object`)

		return nil, diags
	}

	underlayVal, ok := underlayAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`underlay expected to be basetypes.ObjectValue, was: %T`, underlayAttribute))
	}

	vsInstancesAttribute, ok := attributes["vs_instances"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vs_instances is missing from object`)

		return nil, diags
	}

	vsInstancesVal, ok := vsInstancesAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vs_instances expected to be basetypes.MapValue, was: %T`, vsInstancesAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return EvpnOptionsValue{
		AutoLoopbackSubnet:  autoLoopbackSubnetVal,
		AutoLoopbackSubnet6: autoLoopbackSubnet6Val,
		AutoRouterIdSubnet:  autoRouterIdSubnetVal,
		AutoRouterIdSubnet6: autoRouterIdSubnet6Val,
		CoreAsBorder:        coreAsBorderVal,
		Overlay:             overlayVal,
		PerVlanVgaV4Mac:     perVlanVgaV4MacVal,
		RoutedAt:            routedAtVal,
		Underlay:            underlayVal,
		VsInstances:         vsInstancesVal,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewEvpnOptionsValueNull() EvpnOptionsValue {
	return EvpnOptionsValue{
		state: attr.ValueStateNull,
	}
}

func NewEvpnOptionsValueUnknown() EvpnOptionsValue {
	return EvpnOptionsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewEvpnOptionsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (EvpnOptionsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing EvpnOptionsValue Attribute Value",
				"While creating a EvpnOptionsValue value, a missing attribute value was detected. "+
					"A EvpnOptionsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("EvpnOptionsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid EvpnOptionsValue Attribute Type",
				"While creating a EvpnOptionsValue value, an invalid attribute value was detected. "+
					"A EvpnOptionsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("EvpnOptionsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("EvpnOptionsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra EvpnOptionsValue Attribute Value",
				"While creating a EvpnOptionsValue value, an extra attribute value was detected. "+
					"A EvpnOptionsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra EvpnOptionsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewEvpnOptionsValueUnknown(), diags
	}

	autoLoopbackSubnetAttribute, ok := attributes["auto_loopback_subnet"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auto_loopback_subnet is missing from object`)

		return NewEvpnOptionsValueUnknown(), diags
	}

	autoLoopbackSubnetVal, ok := autoLoopbackSubnetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auto_loopback_subnet expected to be basetypes.StringValue, was: %T`, autoLoopbackSubnetAttribute))
	}

	autoLoopbackSubnet6Attribute, ok := attributes["auto_loopback_subnet6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auto_loopback_subnet6 is missing from object`)

		return NewEvpnOptionsValueUnknown(), diags
	}

	autoLoopbackSubnet6Val, ok := autoLoopbackSubnet6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auto_loopback_subnet6 expected to be basetypes.StringValue, was: %T`, autoLoopbackSubnet6Attribute))
	}

	autoRouterIdSubnetAttribute, ok := attributes["auto_router_id_subnet"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auto_router_id_subnet is missing from object`)

		return NewEvpnOptionsValueUnknown(), diags
	}

	autoRouterIdSubnetVal, ok := autoRouterIdSubnetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auto_router_id_subnet expected to be basetypes.StringValue, was: %T`, autoRouterIdSubnetAttribute))
	}

	autoRouterIdSubnet6Attribute, ok := attributes["auto_router_id_subnet6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auto_router_id_subnet6 is missing from object`)

		return NewEvpnOptionsValueUnknown(), diags
	}

	autoRouterIdSubnet6Val, ok := autoRouterIdSubnet6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auto_router_id_subnet6 expected to be basetypes.StringValue, was: %T`, autoRouterIdSubnet6Attribute))
	}

	coreAsBorderAttribute, ok := attributes["core_as_border"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`core_as_border is missing from object`)

		return NewEvpnOptionsValueUnknown(), diags
	}

	coreAsBorderVal, ok := coreAsBorderAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`core_as_border expected to be basetypes.BoolValue, was: %T`, coreAsBorderAttribute))
	}

	overlayAttribute, ok := attributes["overlay"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`overlay is missing from object`)

		return NewEvpnOptionsValueUnknown(), diags
	}

	overlayVal, ok := overlayAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`overlay expected to be basetypes.ObjectValue, was: %T`, overlayAttribute))
	}

	perVlanVgaV4MacAttribute, ok := attributes["per_vlan_vga_v4_mac"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`per_vlan_vga_v4_mac is missing from object`)

		return NewEvpnOptionsValueUnknown(), diags
	}

	perVlanVgaV4MacVal, ok := perVlanVgaV4MacAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`per_vlan_vga_v4_mac expected to be basetypes.BoolValue, was: %T`, perVlanVgaV4MacAttribute))
	}

	routedAtAttribute, ok := attributes["routed_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`routed_at is missing from object`)

		return NewEvpnOptionsValueUnknown(), diags
	}

	routedAtVal, ok := routedAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`routed_at expected to be basetypes.StringValue, was: %T`, routedAtAttribute))
	}

	underlayAttribute, ok := attributes["underlay"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`underlay is missing from object`)

		return NewEvpnOptionsValueUnknown(), diags
	}

	underlayVal, ok := underlayAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`underlay expected to be basetypes.ObjectValue, was: %T`, underlayAttribute))
	}

	vsInstancesAttribute, ok := attributes["vs_instances"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vs_instances is missing from object`)

		return NewEvpnOptionsValueUnknown(), diags
	}

	vsInstancesVal, ok := vsInstancesAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vs_instances expected to be basetypes.MapValue, was: %T`, vsInstancesAttribute))
	}

	if diags.HasError() {
		return NewEvpnOptionsValueUnknown(), diags
	}

	return EvpnOptionsValue{
		AutoLoopbackSubnet:  autoLoopbackSubnetVal,
		AutoLoopbackSubnet6: autoLoopbackSubnet6Val,
		AutoRouterIdSubnet:  autoRouterIdSubnetVal,
		AutoRouterIdSubnet6: autoRouterIdSubnet6Val,
		CoreAsBorder:        coreAsBorderVal,
		Overlay:             overlayVal,
		PerVlanVgaV4Mac:     perVlanVgaV4MacVal,
		RoutedAt:            routedAtVal,
		Underlay:            underlayVal,
		VsInstances:         vsInstancesVal,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewEvpnOptionsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) EvpnOptionsValue {
	object, diags := NewEvpnOptionsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewEvpnOptionsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t EvpnOptionsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewEvpnOptionsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewEvpnOptionsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewEvpnOptionsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewEvpnOptionsValueMust(EvpnOptionsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t EvpnOptionsType) ValueType(ctx context.Context) attr.Value {
	return EvpnOptionsValue{}
}

var _ basetypes.ObjectValuable = EvpnOptionsValue{}

type EvpnOptionsValue struct {
	AutoLoopbackSubnet  basetypes.StringValue `tfsdk:"auto_loopback_subnet"`
	AutoLoopbackSubnet6 basetypes.StringValue `tfsdk:"auto_loopback_subnet6"`
	AutoRouterIdSubnet  basetypes.StringValue `tfsdk:"auto_router_id_subnet"`
	AutoRouterIdSubnet6 basetypes.StringValue `tfsdk:"auto_router_id_subnet6"`
	CoreAsBorder        basetypes.BoolValue   `tfsdk:"core_as_border"`
	Overlay             basetypes.ObjectValue `tfsdk:"overlay"`
	PerVlanVgaV4Mac     basetypes.BoolValue   `tfsdk:"per_vlan_vga_v4_mac"`
	RoutedAt            basetypes.StringValue `tfsdk:"routed_at"`
	Underlay            basetypes.ObjectValue `tfsdk:"underlay"`
	VsInstances         basetypes.MapValue    `tfsdk:"vs_instances"`
	state               attr.ValueState
}

func (v EvpnOptionsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 10)

	var val tftypes.Value
	var err error

	attrTypes["auto_loopback_subnet"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["auto_loopback_subnet6"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["auto_router_id_subnet"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["auto_router_id_subnet6"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["core_as_border"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["overlay"] = basetypes.ObjectType{
		AttrTypes: OverlayValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["per_vlan_vga_v4_mac"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["routed_at"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["underlay"] = basetypes.ObjectType{
		AttrTypes: UnderlayValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["vs_instances"] = basetypes.MapType{
		ElemType: VsInstancesValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 10)

		val, err = v.AutoLoopbackSubnet.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["auto_loopback_subnet"] = val

		val, err = v.AutoLoopbackSubnet6.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["auto_loopback_subnet6"] = val

		val, err = v.AutoRouterIdSubnet.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["auto_router_id_subnet"] = val

		val, err = v.AutoRouterIdSubnet6.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["auto_router_id_subnet6"] = val

		val, err = v.CoreAsBorder.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["core_as_border"] = val

		val, err = v.Overlay.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["overlay"] = val

		val, err = v.PerVlanVgaV4Mac.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["per_vlan_vga_v4_mac"] = val

		val, err = v.RoutedAt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["routed_at"] = val

		val, err = v.Underlay.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["underlay"] = val

		val, err = v.VsInstances.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vs_instances"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v EvpnOptionsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v EvpnOptionsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v EvpnOptionsValue) String() string {
	return "EvpnOptionsValue"
}

func (v EvpnOptionsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var overlay basetypes.ObjectValue

	if v.Overlay.IsNull() {
		overlay = types.ObjectNull(
			OverlayValue{}.AttributeTypes(ctx),
		)
	}

	if v.Overlay.IsUnknown() {
		overlay = types.ObjectUnknown(
			OverlayValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Overlay.IsNull() && !v.Overlay.IsUnknown() {
		overlay = types.ObjectValueMust(
			OverlayValue{}.AttributeTypes(ctx),
			v.Overlay.Attributes(),
		)
	}

	var underlay basetypes.ObjectValue

	if v.Underlay.IsNull() {
		underlay = types.ObjectNull(
			UnderlayValue{}.AttributeTypes(ctx),
		)
	}

	if v.Underlay.IsUnknown() {
		underlay = types.ObjectUnknown(
			UnderlayValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Underlay.IsNull() && !v.Underlay.IsUnknown() {
		underlay = types.ObjectValueMust(
			UnderlayValue{}.AttributeTypes(ctx),
			v.Underlay.Attributes(),
		)
	}

	vsInstances := types.MapValueMust(
		VsInstancesType{
			basetypes.ObjectType{
				AttrTypes: VsInstancesValue{}.AttributeTypes(ctx),
			},
		},
		v.VsInstances.Elements(),
	)

	if v.VsInstances.IsNull() {
		vsInstances = types.MapNull(
			VsInstancesType{
				basetypes.ObjectType{
					AttrTypes: VsInstancesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.VsInstances.IsUnknown() {
		vsInstances = types.MapUnknown(
			VsInstancesType{
				basetypes.ObjectType{
					AttrTypes: VsInstancesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"auto_loopback_subnet":   basetypes.StringType{},
		"auto_loopback_subnet6":  basetypes.StringType{},
		"auto_router_id_subnet":  basetypes.StringType{},
		"auto_router_id_subnet6": basetypes.StringType{},
		"core_as_border":         basetypes.BoolType{},
		"overlay": basetypes.ObjectType{
			AttrTypes: OverlayValue{}.AttributeTypes(ctx),
		},
		"per_vlan_vga_v4_mac": basetypes.BoolType{},
		"routed_at":           basetypes.StringType{},
		"underlay": basetypes.ObjectType{
			AttrTypes: UnderlayValue{}.AttributeTypes(ctx),
		},
		"vs_instances": basetypes.MapType{
			ElemType: VsInstancesValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"auto_loopback_subnet":   v.AutoLoopbackSubnet,
			"auto_loopback_subnet6":  v.AutoLoopbackSubnet6,
			"auto_router_id_subnet":  v.AutoRouterIdSubnet,
			"auto_router_id_subnet6": v.AutoRouterIdSubnet6,
			"core_as_border":         v.CoreAsBorder,
			"overlay":                overlay,
			"per_vlan_vga_v4_mac":    v.PerVlanVgaV4Mac,
			"routed_at":              v.RoutedAt,
			"underlay":               underlay,
			"vs_instances":           vsInstances,
		})

	return objVal, diags
}

func (v EvpnOptionsValue) Equal(o attr.Value) bool {
	other, ok := o.(EvpnOptionsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AutoLoopbackSubnet.Equal(other.AutoLoopbackSubnet) {
		return false
	}

	if !v.AutoLoopbackSubnet6.Equal(other.AutoLoopbackSubnet6) {
		return false
	}

	if !v.AutoRouterIdSubnet.Equal(other.AutoRouterIdSubnet) {
		return false
	}

	if !v.AutoRouterIdSubnet6.Equal(other.AutoRouterIdSubnet6) {
		return false
	}

	if !v.CoreAsBorder.Equal(other.CoreAsBorder) {
		return false
	}

	if !v.Overlay.Equal(other.Overlay) {
		return false
	}

	if !v.PerVlanVgaV4Mac.Equal(other.PerVlanVgaV4Mac) {
		return false
	}

	if !v.RoutedAt.Equal(other.RoutedAt) {
		return false
	}

	if !v.Underlay.Equal(other.Underlay) {
		return false
	}

	if !v.VsInstances.Equal(other.VsInstances) {
		return false
	}

	return true
}

func (v EvpnOptionsValue) Type(ctx context.Context) attr.Type {
	return EvpnOptionsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v EvpnOptionsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"auto_loopback_subnet":   basetypes.StringType{},
		"auto_loopback_subnet6":  basetypes.StringType{},
		"auto_router_id_subnet":  basetypes.StringType{},
		"auto_router_id_subnet6": basetypes.StringType{},
		"core_as_border":         basetypes.BoolType{},
		"overlay": basetypes.ObjectType{
			AttrTypes: OverlayValue{}.AttributeTypes(ctx),
		},
		"per_vlan_vga_v4_mac": basetypes.BoolType{},
		"routed_at":           basetypes.StringType{},
		"underlay": basetypes.ObjectType{
			AttrTypes: UnderlayValue{}.AttributeTypes(ctx),
		},
		"vs_instances": basetypes.MapType{
			ElemType: VsInstancesValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = OverlayType{}

type OverlayType struct {
	basetypes.ObjectType
}

func (t OverlayType) Equal(o attr.Type) bool {
	other, ok := o.(OverlayType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t OverlayType) String() string {
	return "OverlayType"
}

func (t OverlayType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	asAttribute, ok := attributes["as"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`as is missing from object`)

		return nil, diags
	}

	asVal, ok := asAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`as expected to be basetypes.Int64Value, was: %T`, asAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return OverlayValue{
		As:    asVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewOverlayValueNull() OverlayValue {
	return OverlayValue{
		state: attr.ValueStateNull,
	}
}

func NewOverlayValueUnknown() OverlayValue {
	return OverlayValue{
		state: attr.ValueStateUnknown,
	}
}

func NewOverlayValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (OverlayValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing OverlayValue Attribute Value",
				"While creating a OverlayValue value, a missing attribute value was detected. "+
					"A OverlayValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OverlayValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid OverlayValue Attribute Type",
				"While creating a OverlayValue value, an invalid attribute value was detected. "+
					"A OverlayValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OverlayValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("OverlayValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra OverlayValue Attribute Value",
				"While creating a OverlayValue value, an extra attribute value was detected. "+
					"A OverlayValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra OverlayValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewOverlayValueUnknown(), diags
	}

	asAttribute, ok := attributes["as"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`as is missing from object`)

		return NewOverlayValueUnknown(), diags
	}

	asVal, ok := asAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`as expected to be basetypes.Int64Value, was: %T`, asAttribute))
	}

	if diags.HasError() {
		return NewOverlayValueUnknown(), diags
	}

	return OverlayValue{
		As:    asVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewOverlayValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) OverlayValue {
	object, diags := NewOverlayValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewOverlayValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t OverlayType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewOverlayValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewOverlayValueUnknown(), nil
	}

	if in.IsNull() {
		return NewOverlayValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewOverlayValueMust(OverlayValue{}.AttributeTypes(ctx), attributes), nil
}

func (t OverlayType) ValueType(ctx context.Context) attr.Value {
	return OverlayValue{}
}

var _ basetypes.ObjectValuable = OverlayValue{}

type OverlayValue struct {
	As    basetypes.Int64Value `tfsdk:"as"`
	state attr.ValueState
}

func (v OverlayValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["as"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.As.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["as"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v OverlayValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v OverlayValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v OverlayValue) String() string {
	return "OverlayValue"
}

func (v OverlayValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"as": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"as": v.As,
		})

	return objVal, diags
}

func (v OverlayValue) Equal(o attr.Value) bool {
	other, ok := o.(OverlayValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.As.Equal(other.As) {
		return false
	}

	return true
}

func (v OverlayValue) Type(ctx context.Context) attr.Type {
	return OverlayType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v OverlayValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"as": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = UnderlayType{}

type UnderlayType struct {
	basetypes.ObjectType
}

func (t UnderlayType) Equal(o attr.Type) bool {
	other, ok := o.(UnderlayType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t UnderlayType) String() string {
	return "UnderlayType"
}

func (t UnderlayType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	asBaseAttribute, ok := attributes["as_base"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`as_base is missing from object`)

		return nil, diags
	}

	asBaseVal, ok := asBaseAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`as_base expected to be basetypes.Int64Value, was: %T`, asBaseAttribute))
	}

	routedIdPrefixAttribute, ok := attributes["routed_id_prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`routed_id_prefix is missing from object`)

		return nil, diags
	}

	routedIdPrefixVal, ok := routedIdPrefixAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`routed_id_prefix expected to be basetypes.StringValue, was: %T`, routedIdPrefixAttribute))
	}

	subnetAttribute, ok := attributes["subnet"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet is missing from object`)

		return nil, diags
	}

	subnetVal, ok := subnetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet expected to be basetypes.StringValue, was: %T`, subnetAttribute))
	}

	useIpv6Attribute, ok := attributes["use_ipv6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`use_ipv6 is missing from object`)

		return nil, diags
	}

	useIpv6Val, ok := useIpv6Attribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`use_ipv6 expected to be basetypes.BoolValue, was: %T`, useIpv6Attribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return UnderlayValue{
		AsBase:         asBaseVal,
		RoutedIdPrefix: routedIdPrefixVal,
		Subnet:         subnetVal,
		UseIpv6:        useIpv6Val,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewUnderlayValueNull() UnderlayValue {
	return UnderlayValue{
		state: attr.ValueStateNull,
	}
}

func NewUnderlayValueUnknown() UnderlayValue {
	return UnderlayValue{
		state: attr.ValueStateUnknown,
	}
}

func NewUnderlayValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (UnderlayValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing UnderlayValue Attribute Value",
				"While creating a UnderlayValue value, a missing attribute value was detected. "+
					"A UnderlayValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("UnderlayValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid UnderlayValue Attribute Type",
				"While creating a UnderlayValue value, an invalid attribute value was detected. "+
					"A UnderlayValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("UnderlayValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("UnderlayValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra UnderlayValue Attribute Value",
				"While creating a UnderlayValue value, an extra attribute value was detected. "+
					"A UnderlayValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra UnderlayValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewUnderlayValueUnknown(), diags
	}

	asBaseAttribute, ok := attributes["as_base"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`as_base is missing from object`)

		return NewUnderlayValueUnknown(), diags
	}

	asBaseVal, ok := asBaseAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`as_base expected to be basetypes.Int64Value, was: %T`, asBaseAttribute))
	}

	routedIdPrefixAttribute, ok := attributes["routed_id_prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`routed_id_prefix is missing from object`)

		return NewUnderlayValueUnknown(), diags
	}

	routedIdPrefixVal, ok := routedIdPrefixAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`routed_id_prefix expected to be basetypes.StringValue, was: %T`, routedIdPrefixAttribute))
	}

	subnetAttribute, ok := attributes["subnet"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet is missing from object`)

		return NewUnderlayValueUnknown(), diags
	}

	subnetVal, ok := subnetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet expected to be basetypes.StringValue, was: %T`, subnetAttribute))
	}

	useIpv6Attribute, ok := attributes["use_ipv6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`use_ipv6 is missing from object`)

		return NewUnderlayValueUnknown(), diags
	}

	useIpv6Val, ok := useIpv6Attribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`use_ipv6 expected to be basetypes.BoolValue, was: %T`, useIpv6Attribute))
	}

	if diags.HasError() {
		return NewUnderlayValueUnknown(), diags
	}

	return UnderlayValue{
		AsBase:         asBaseVal,
		RoutedIdPrefix: routedIdPrefixVal,
		Subnet:         subnetVal,
		UseIpv6:        useIpv6Val,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewUnderlayValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) UnderlayValue {
	object, diags := NewUnderlayValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewUnderlayValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t UnderlayType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewUnderlayValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewUnderlayValueUnknown(), nil
	}

	if in.IsNull() {
		return NewUnderlayValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewUnderlayValueMust(UnderlayValue{}.AttributeTypes(ctx), attributes), nil
}

func (t UnderlayType) ValueType(ctx context.Context) attr.Value {
	return UnderlayValue{}
}

var _ basetypes.ObjectValuable = UnderlayValue{}

type UnderlayValue struct {
	AsBase         basetypes.Int64Value  `tfsdk:"as_base"`
	RoutedIdPrefix basetypes.StringValue `tfsdk:"routed_id_prefix"`
	Subnet         basetypes.StringValue `tfsdk:"subnet"`
	UseIpv6        basetypes.BoolValue   `tfsdk:"use_ipv6"`
	state          attr.ValueState
}

func (v UnderlayValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["as_base"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["routed_id_prefix"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["subnet"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["use_ipv6"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.AsBase.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["as_base"] = val

		val, err = v.RoutedIdPrefix.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["routed_id_prefix"] = val

		val, err = v.Subnet.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["subnet"] = val

		val, err = v.UseIpv6.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["use_ipv6"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v UnderlayValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v UnderlayValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v UnderlayValue) String() string {
	return "UnderlayValue"
}

func (v UnderlayValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"as_base":          basetypes.Int64Type{},
		"routed_id_prefix": basetypes.StringType{},
		"subnet":           basetypes.StringType{},
		"use_ipv6":         basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"as_base":          v.AsBase,
			"routed_id_prefix": v.RoutedIdPrefix,
			"subnet":           v.Subnet,
			"use_ipv6":         v.UseIpv6,
		})

	return objVal, diags
}

func (v UnderlayValue) Equal(o attr.Value) bool {
	other, ok := o.(UnderlayValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AsBase.Equal(other.AsBase) {
		return false
	}

	if !v.RoutedIdPrefix.Equal(other.RoutedIdPrefix) {
		return false
	}

	if !v.Subnet.Equal(other.Subnet) {
		return false
	}

	if !v.UseIpv6.Equal(other.UseIpv6) {
		return false
	}

	return true
}

func (v UnderlayValue) Type(ctx context.Context) attr.Type {
	return UnderlayType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v UnderlayValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"as_base":          basetypes.Int64Type{},
		"routed_id_prefix": basetypes.StringType{},
		"subnet":           basetypes.StringType{},
		"use_ipv6":         basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = VsInstancesType{}

type VsInstancesType struct {
	basetypes.ObjectType
}

func (t VsInstancesType) Equal(o attr.Type) bool {
	other, ok := o.(VsInstancesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t VsInstancesType) String() string {
	return "VsInstancesType"
}

func (t VsInstancesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	networksAttribute, ok := attributes["networks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`networks is missing from object`)

		return nil, diags
	}

	networksVal, ok := networksAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`networks expected to be basetypes.ListValue, was: %T`, networksAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return VsInstancesValue{
		Networks: networksVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewVsInstancesValueNull() VsInstancesValue {
	return VsInstancesValue{
		state: attr.ValueStateNull,
	}
}

func NewVsInstancesValueUnknown() VsInstancesValue {
	return VsInstancesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewVsInstancesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (VsInstancesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing VsInstancesValue Attribute Value",
				"While creating a VsInstancesValue value, a missing attribute value was detected. "+
					"A VsInstancesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VsInstancesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid VsInstancesValue Attribute Type",
				"While creating a VsInstancesValue value, an invalid attribute value was detected. "+
					"A VsInstancesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VsInstancesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("VsInstancesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra VsInstancesValue Attribute Value",
				"While creating a VsInstancesValue value, an extra attribute value was detected. "+
					"A VsInstancesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra VsInstancesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewVsInstancesValueUnknown(), diags
	}

	networksAttribute, ok := attributes["networks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`networks is missing from object`)

		return NewVsInstancesValueUnknown(), diags
	}

	networksVal, ok := networksAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`networks expected to be basetypes.ListValue, was: %T`, networksAttribute))
	}

	if diags.HasError() {
		return NewVsInstancesValueUnknown(), diags
	}

	return VsInstancesValue{
		Networks: networksVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewVsInstancesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) VsInstancesValue {
	object, diags := NewVsInstancesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewVsInstancesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t VsInstancesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewVsInstancesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewVsInstancesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewVsInstancesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewVsInstancesValueMust(VsInstancesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t VsInstancesType) ValueType(ctx context.Context) attr.Value {
	return VsInstancesValue{}
}

var _ basetypes.ObjectValuable = VsInstancesValue{}

type VsInstancesValue struct {
	Networks basetypes.ListValue `tfsdk:"networks"`
	state    attr.ValueState
}

func (v VsInstancesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["networks"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Networks.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["networks"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v VsInstancesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v VsInstancesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v VsInstancesValue) String() string {
	return "VsInstancesValue"
}

func (v VsInstancesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	networksVal, d := types.ListValue(types.StringType, v.Networks.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"networks": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"networks": basetypes.ListType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"networks": networksVal,
		})

	return objVal, diags
}

func (v VsInstancesValue) Equal(o attr.Value) bool {
	other, ok := o.(VsInstancesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Networks.Equal(other.Networks) {
		return false
	}

	return true
}

func (v VsInstancesValue) Type(ctx context.Context) attr.Type {
	return VsInstancesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v VsInstancesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"networks": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = SwitchesType{}

type SwitchesType struct {
	basetypes.ObjectType
}

func (t SwitchesType) Equal(o attr.Type) bool {
	other, ok := o.(SwitchesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SwitchesType) String() string {
	return "SwitchesType"
}

func (t SwitchesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	deviceprofileIdAttribute, ok := attributes["deviceprofile_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`deviceprofile_id is missing from object`)

		return nil, diags
	}

	deviceprofileIdVal, ok := deviceprofileIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`deviceprofile_id expected to be basetypes.StringValue, was: %T`, deviceprofileIdAttribute))
	}

	evpnIdAttribute, ok := attributes["evpn_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`evpn_id is missing from object`)

		return nil, diags
	}

	evpnIdVal, ok := evpnIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`evpn_id expected to be basetypes.Int64Value, was: %T`, evpnIdAttribute))
	}

	macAttribute, ok := attributes["mac"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mac is missing from object`)

		return nil, diags
	}

	macVal, ok := macAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mac expected to be basetypes.StringValue, was: %T`, macAttribute))
	}

	modelAttribute, ok := attributes["model"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`model is missing from object`)

		return nil, diags
	}

	modelVal, ok := modelAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`model expected to be basetypes.StringValue, was: %T`, modelAttribute))
	}

	podAttribute, ok := attributes["pod"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pod is missing from object`)

		return nil, diags
	}

	podVal, ok := podAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pod expected to be basetypes.Int64Value, was: %T`, podAttribute))
	}

	podsAttribute, ok := attributes["pods"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pods is missing from object`)

		return nil, diags
	}

	podsVal, ok := podsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pods expected to be basetypes.ListValue, was: %T`, podsAttribute))
	}

	roleAttribute, ok := attributes["role"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`role is missing from object`)

		return nil, diags
	}

	roleVal, ok := roleAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`role expected to be basetypes.StringValue, was: %T`, roleAttribute))
	}

	routerIdAttribute, ok := attributes["router_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`router_id is missing from object`)

		return nil, diags
	}

	routerIdVal, ok := routerIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`router_id expected to be basetypes.StringValue, was: %T`, routerIdAttribute))
	}

	siteIdAttribute, ok := attributes["site_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`site_id is missing from object`)

		return nil, diags
	}

	siteIdVal, ok := siteIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`site_id expected to be basetypes.StringValue, was: %T`, siteIdAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SwitchesValue{
		DeviceprofileId: deviceprofileIdVal,
		EvpnId:          evpnIdVal,
		Mac:             macVal,
		Model:           modelVal,
		Pod:             podVal,
		Pods:            podsVal,
		Role:            roleVal,
		RouterId:        routerIdVal,
		SiteId:          siteIdVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewSwitchesValueNull() SwitchesValue {
	return SwitchesValue{
		state: attr.ValueStateNull,
	}
}

func NewSwitchesValueUnknown() SwitchesValue {
	return SwitchesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSwitchesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SwitchesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SwitchesValue Attribute Value",
				"While creating a SwitchesValue value, a missing attribute value was detected. "+
					"A SwitchesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SwitchesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SwitchesValue Attribute Type",
				"While creating a SwitchesValue value, an invalid attribute value was detected. "+
					"A SwitchesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SwitchesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SwitchesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SwitchesValue Attribute Value",
				"While creating a SwitchesValue value, an extra attribute value was detected. "+
					"A SwitchesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SwitchesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSwitchesValueUnknown(), diags
	}

	deviceprofileIdAttribute, ok := attributes["deviceprofile_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`deviceprofile_id is missing from object`)

		return NewSwitchesValueUnknown(), diags
	}

	deviceprofileIdVal, ok := deviceprofileIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`deviceprofile_id expected to be basetypes.StringValue, was: %T`, deviceprofileIdAttribute))
	}

	evpnIdAttribute, ok := attributes["evpn_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`evpn_id is missing from object`)

		return NewSwitchesValueUnknown(), diags
	}

	evpnIdVal, ok := evpnIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`evpn_id expected to be basetypes.Int64Value, was: %T`, evpnIdAttribute))
	}

	macAttribute, ok := attributes["mac"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mac is missing from object`)

		return NewSwitchesValueUnknown(), diags
	}

	macVal, ok := macAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mac expected to be basetypes.StringValue, was: %T`, macAttribute))
	}

	modelAttribute, ok := attributes["model"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`model is missing from object`)

		return NewSwitchesValueUnknown(), diags
	}

	modelVal, ok := modelAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`model expected to be basetypes.StringValue, was: %T`, modelAttribute))
	}

	podAttribute, ok := attributes["pod"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pod is missing from object`)

		return NewSwitchesValueUnknown(), diags
	}

	podVal, ok := podAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pod expected to be basetypes.Int64Value, was: %T`, podAttribute))
	}

	podsAttribute, ok := attributes["pods"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pods is missing from object`)

		return NewSwitchesValueUnknown(), diags
	}

	podsVal, ok := podsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pods expected to be basetypes.ListValue, was: %T`, podsAttribute))
	}

	roleAttribute, ok := attributes["role"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`role is missing from object`)

		return NewSwitchesValueUnknown(), diags
	}

	roleVal, ok := roleAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`role expected to be basetypes.StringValue, was: %T`, roleAttribute))
	}

	routerIdAttribute, ok := attributes["router_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`router_id is missing from object`)

		return NewSwitchesValueUnknown(), diags
	}

	routerIdVal, ok := routerIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`router_id expected to be basetypes.StringValue, was: %T`, routerIdAttribute))
	}

	siteIdAttribute, ok := attributes["site_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`site_id is missing from object`)

		return NewSwitchesValueUnknown(), diags
	}

	siteIdVal, ok := siteIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`site_id expected to be basetypes.StringValue, was: %T`, siteIdAttribute))
	}

	if diags.HasError() {
		return NewSwitchesValueUnknown(), diags
	}

	return SwitchesValue{
		DeviceprofileId: deviceprofileIdVal,
		EvpnId:          evpnIdVal,
		Mac:             macVal,
		Model:           modelVal,
		Pod:             podVal,
		Pods:            podsVal,
		Role:            roleVal,
		RouterId:        routerIdVal,
		SiteId:          siteIdVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewSwitchesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SwitchesValue {
	object, diags := NewSwitchesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSwitchesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SwitchesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSwitchesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSwitchesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSwitchesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSwitchesValueMust(SwitchesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SwitchesType) ValueType(ctx context.Context) attr.Value {
	return SwitchesValue{}
}

var _ basetypes.ObjectValuable = SwitchesValue{}

type SwitchesValue struct {
	DeviceprofileId basetypes.StringValue `tfsdk:"deviceprofile_id"`
	EvpnId          basetypes.Int64Value  `tfsdk:"evpn_id"`
	Mac             basetypes.StringValue `tfsdk:"mac"`
	Model           basetypes.StringValue `tfsdk:"model"`
	Pod             basetypes.Int64Value  `tfsdk:"pod"`
	Pods            basetypes.ListValue   `tfsdk:"pods"`
	Role            basetypes.StringValue `tfsdk:"role"`
	RouterId        basetypes.StringValue `tfsdk:"router_id"`
	SiteId          basetypes.StringValue `tfsdk:"site_id"`
	state           attr.ValueState
}

func (v SwitchesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 9)

	var val tftypes.Value
	var err error

	attrTypes["deviceprofile_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["evpn_id"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["mac"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["model"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["pod"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["pods"] = basetypes.ListType{
		ElemType: types.Int64Type,
	}.TerraformType(ctx)
	attrTypes["role"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["router_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["site_id"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 9)

		val, err = v.DeviceprofileId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["deviceprofile_id"] = val

		val, err = v.EvpnId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["evpn_id"] = val

		val, err = v.Mac.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mac"] = val

		val, err = v.Model.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["model"] = val

		val, err = v.Pod.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["pod"] = val

		val, err = v.Pods.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["pods"] = val

		val, err = v.Role.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["role"] = val

		val, err = v.RouterId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["router_id"] = val

		val, err = v.SiteId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["site_id"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SwitchesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SwitchesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SwitchesValue) String() string {
	return "SwitchesValue"
}

func (v SwitchesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	podsVal, d := types.ListValue(types.Int64Type, v.Pods.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"deviceprofile_id": basetypes.StringType{},
			"evpn_id":          basetypes.Int64Type{},
			"mac":              basetypes.StringType{},
			"model":            basetypes.StringType{},
			"pod":              basetypes.Int64Type{},
			"pods": basetypes.ListType{
				ElemType: types.Int64Type,
			},
			"role":      basetypes.StringType{},
			"router_id": basetypes.StringType{},
			"site_id":   basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"deviceprofile_id": basetypes.StringType{},
		"evpn_id":          basetypes.Int64Type{},
		"mac":              basetypes.StringType{},
		"model":            basetypes.StringType{},
		"pod":              basetypes.Int64Type{},
		"pods": basetypes.ListType{
			ElemType: types.Int64Type,
		},
		"role":      basetypes.StringType{},
		"router_id": basetypes.StringType{},
		"site_id":   basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"deviceprofile_id": v.DeviceprofileId,
			"evpn_id":          v.EvpnId,
			"mac":              v.Mac,
			"model":            v.Model,
			"pod":              v.Pod,
			"pods":             podsVal,
			"role":             v.Role,
			"router_id":        v.RouterId,
			"site_id":          v.SiteId,
		})

	return objVal, diags
}

func (v SwitchesValue) Equal(o attr.Value) bool {
	other, ok := o.(SwitchesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.DeviceprofileId.Equal(other.DeviceprofileId) {
		return false
	}

	if !v.EvpnId.Equal(other.EvpnId) {
		return false
	}

	if !v.Mac.Equal(other.Mac) {
		return false
	}

	if !v.Model.Equal(other.Model) {
		return false
	}

	if !v.Pod.Equal(other.Pod) {
		return false
	}

	if !v.Pods.Equal(other.Pods) {
		return false
	}

	if !v.Role.Equal(other.Role) {
		return false
	}

	if !v.RouterId.Equal(other.RouterId) {
		return false
	}

	if !v.SiteId.Equal(other.SiteId) {
		return false
	}

	return true
}

func (v SwitchesValue) Type(ctx context.Context) attr.Type {
	return SwitchesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SwitchesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"deviceprofile_id": basetypes.StringType{},
		"evpn_id":          basetypes.Int64Type{},
		"mac":              basetypes.StringType{},
		"model":            basetypes.StringType{},
		"pod":              basetypes.Int64Type{},
		"pods": basetypes.ListType{
			ElemType: types.Int64Type,
		},
		"role":      basetypes.StringType{},
		"router_id": basetypes.StringType{},
		"site_id":   basetypes.StringType{},
	}
}
