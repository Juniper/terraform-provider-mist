// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package resource_org_gatewaytemplate

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework-validators/int64validator"
	"github.com/hashicorp/terraform-plugin-framework-validators/listvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/booldefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/int64default"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/listdefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
)

func OrgGatewaytemplateResourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"additional_config_cmds": schema.ListAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Description:         "additional CLI commands to append to the generated Junos config\n\n**Note**: no check is done",
				MarkdownDescription: "additional CLI commands to append to the generated Junos config\n\n**Note**: no check is done",
			},
			"bgp_config": schema.MapNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"auth_key": schema.StringAttribute{
							Optional: true,
						},
						"bfd_minimum_interval": schema.Int64Attribute{
							Optional:            true,
							Computed:            true,
							Description:         "when bfd_multiplier is configured alone\ndefault:\n* 1000 if `type`==`external``\n* 350 `type`==`internal`",
							MarkdownDescription: "when bfd_multiplier is configured alone\ndefault:\n* 1000 if `type`==`external``\n* 350 `type`==`internal`",
							Validators: []validator.Int64{
								int64validator.Between(1, 255000),
							},
							Default: int64default.StaticInt64(350),
						},
						"bfd_multiplier": schema.Int64Attribute{
							Optional:            true,
							Computed:            true,
							Description:         "when bfd_minimum_interval_is_configured alone",
							MarkdownDescription: "when bfd_minimum_interval_is_configured alone",
							Validators: []validator.Int64{
								int64validator.Between(1, 255),
							},
							Default: int64default.StaticInt64(3),
						},
						"communities": schema.ListNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"id": schema.StringAttribute{
										Optional: true,
									},
									"local_preference": schema.Int64Attribute{
										Optional: true,
									},
									"vpn_name": schema.StringAttribute{
										Optional: true,
									},
								},
								CustomType: CommunitiesType{
									ObjectType: types.ObjectType{
										AttrTypes: CommunitiesValue{}.AttributeTypes(ctx),
									},
								},
							},
							Optional: true,
						},
						"disable_bfd": schema.BoolAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "BFD provides faster path failure detection and is enabled by default",
							MarkdownDescription: "BFD provides faster path failure detection and is enabled by default",
							Default:             booldefault.StaticBool(false),
						},
						"export": schema.StringAttribute{
							Optional: true,
						},
						"export_policy": schema.StringAttribute{
							Optional:            true,
							Description:         "default export policies if no per-neighbor policies defined",
							MarkdownDescription: "default export policies if no per-neighbor policies defined",
						},
						"extended_v4_nexthop": schema.BoolAttribute{
							Optional:            true,
							Description:         "by default, either inet/net6 unicast depending on neighbor IP family (v4 or v6)\nfor v6 neighbors, to exchange v4 nexthop, which allows dual-stack support, enable this",
							MarkdownDescription: "by default, either inet/net6 unicast depending on neighbor IP family (v4 or v6)\nfor v6 neighbors, to exchange v4 nexthop, which allows dual-stack support, enable this",
						},
						"graceful_restart_time": schema.Int64Attribute{
							Optional:            true,
							Computed:            true,
							Description:         "`0` means disable",
							MarkdownDescription: "`0` means disable",
							Validators: []validator.Int64{
								int64validator.Between(0, 4095),
							},
							Default: int64default.StaticInt64(0),
						},
						"hold_time": schema.Int64Attribute{
							Optional: true,
							Computed: true,
							Validators: []validator.Int64{
								int64validator.Between(0, 65535),
							},
							Default: int64default.StaticInt64(90),
						},
						"import": schema.StringAttribute{
							Optional: true,
						},
						"import_policy": schema.StringAttribute{
							Optional:            true,
							Description:         "default import policies if no per-neighbor policies defined",
							MarkdownDescription: "default import policies if no per-neighbor policies defined",
						},
						"local_as": schema.Int64Attribute{
							Optional: true,
						},
						"neighbor_as": schema.Int64Attribute{
							Optional: true,
						},
						"neighbors": schema.MapNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"disabled": schema.BoolAttribute{
										Optional:            true,
										Computed:            true,
										Description:         "If true, the BGP session to this neighbor will be administratively disabled/shutdown",
										MarkdownDescription: "If true, the BGP session to this neighbor will be administratively disabled/shutdown",
										Default:             booldefault.StaticBool(false),
									},
									"export_policy": schema.StringAttribute{
										Optional: true,
									},
									"hold_time": schema.Int64Attribute{
										Optional: true,
										Computed: true,
										Validators: []validator.Int64{
											int64validator.Between(0, 65535),
										},
										Default: int64default.StaticInt64(90),
									},
									"import_policy": schema.StringAttribute{
										Optional: true,
									},
									"multihop_ttl": schema.Int64Attribute{
										Optional:            true,
										Description:         "assuming BGP neighbor is directly connected",
										MarkdownDescription: "assuming BGP neighbor is directly connected",
										Validators: []validator.Int64{
											int64validator.Between(0, 255),
										},
									},
									"neighbor_as": schema.Int64Attribute{
										Optional: true,
									},
								},
								CustomType: NeighborsType{
									ObjectType: types.ObjectType{
										AttrTypes: NeighborsValue{}.AttributeTypes(ctx),
									},
								},
							},
							Optional:            true,
							Description:         "if per-neighbor as is desired. Property key is the neighbor address",
							MarkdownDescription: "if per-neighbor as is desired. Property key is the neighbor address",
						},
						"networks": schema.ListAttribute{
							ElementType:         types.StringType,
							Optional:            true,
							Computed:            true,
							Description:         "if `type`!=`external`or `via`==`wan`networks where we expect BGP neighbor to connect to/from",
							MarkdownDescription: "if `type`!=`external`or `via`==`wan`networks where we expect BGP neighbor to connect to/from",
							Default:             listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						},
						"no_readvertise_to_overlay": schema.BoolAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "by default, we'll re-advertise all learned BGP routers toward overlay",
							MarkdownDescription: "by default, we'll re-advertise all learned BGP routers toward overlay",
							Default:             booldefault.StaticBool(false),
						},
						"type": schema.StringAttribute{
							Optional: true,
							Validators: []validator.String{
								stringvalidator.OneOf(
									"",
									"internal",
									"external",
								),
								stringvalidator.LengthAtLeast(1),
							},
						},
						"via": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "network name",
							MarkdownDescription: "network name",
							Validators: []validator.String{
								stringvalidator.OneOf(
									"",
									"lan",
									"vpn",
									"wan",
								),
							},
							Default: stringdefault.StaticString("lan"),
						},
						"vpn_name": schema.StringAttribute{
							Optional: true,
						},
						"wan_name": schema.StringAttribute{
							Optional:            true,
							Description:         "if `via`==`wan`",
							MarkdownDescription: "if `via`==`wan`",
						},
					},
					CustomType: BgpConfigType{
						ObjectType: types.ObjectType{
							AttrTypes: BgpConfigValue{}.AttributeTypes(ctx),
						},
					},
				},
				Optional: true,
			},
			"dhcpd_config": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"config": schema.MapNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"dns_servers": schema.ListAttribute{
									ElementType:         types.StringType,
									Optional:            true,
									Description:         "if `type`==`local` - optional, if not defined, system one will be used",
									MarkdownDescription: "if `type`==`local` - optional, if not defined, system one will be used",
								},
								"dns_suffix": schema.ListAttribute{
									ElementType:         types.StringType,
									Optional:            true,
									Computed:            true,
									Description:         "if `type`==`local` - optional, if not defined, system one will be used",
									MarkdownDescription: "if `type`==`local` - optional, if not defined, system one will be used",
									Default:             listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
								},
								"fixed_bindings": schema.MapNestedAttribute{
									NestedObject: schema.NestedAttributeObject{
										Attributes: map[string]schema.Attribute{
											"ip": schema.StringAttribute{
												Optional: true,
											},
											"name": schema.StringAttribute{
												Optional: true,
											},
										},
										CustomType: FixedBindingsType{
											ObjectType: types.ObjectType{
												AttrTypes: FixedBindingsValue{}.AttributeTypes(ctx),
											},
										},
									},
									Optional:            true,
									Description:         "Property key is the MAC Address",
									MarkdownDescription: "Property key is the MAC Address",
								},
								"gateway": schema.StringAttribute{
									Optional:            true,
									Description:         "if `type`==`local` - optional, `ip` will be used if not provided",
									MarkdownDescription: "if `type`==`local` - optional, `ip` will be used if not provided",
								},
								"ip_end": schema.StringAttribute{
									Optional:            true,
									Description:         "if `type`==`local`",
									MarkdownDescription: "if `type`==`local`",
								},
								"ip_end6": schema.StringAttribute{
									Optional:            true,
									Description:         "if `type6`==`local`",
									MarkdownDescription: "if `type6`==`local`",
								},
								"ip_start": schema.StringAttribute{
									Optional:            true,
									Description:         "if `type`==`local`",
									MarkdownDescription: "if `type`==`local`",
								},
								"ip_start6": schema.StringAttribute{
									Optional:            true,
									Description:         "if `type6`==`local`",
									MarkdownDescription: "if `type6`==`local`",
								},
								"lease_time": schema.Int64Attribute{
									Optional:            true,
									Computed:            true,
									Description:         "in seconds, lease time has to be between 3600 [1hr] - 604800 [1 week], default is 86400 [1 day]",
									MarkdownDescription: "in seconds, lease time has to be between 3600 [1hr] - 604800 [1 week], default is 86400 [1 day]",
									Validators: []validator.Int64{
										int64validator.Between(3600, 604800),
									},
									Default: int64default.StaticInt64(86400),
								},
								"options": schema.MapNestedAttribute{
									NestedObject: schema.NestedAttributeObject{
										Attributes: map[string]schema.Attribute{
											"type": schema.StringAttribute{
												Optional: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"",
														"string",
														"boolean",
														"ip",
														"hex",
														"int16",
														"int32",
														"uint16",
														"uint32",
													),
												},
											},
											"value": schema.StringAttribute{
												Optional: true,
											},
										},
										CustomType: OptionsType{
											ObjectType: types.ObjectType{
												AttrTypes: OptionsValue{}.AttributeTypes(ctx),
											},
										},
									},
									Optional:            true,
									Description:         "Property key is the DHCP option number",
									MarkdownDescription: "Property key is the DHCP option number",
								},
								"server_id_override": schema.BoolAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "`server_id_override`==`true` means the device, when acts as DHCP relay and forwards DHCP responses from DHCP server to clients, \nshould overwrite the Sever Identifier option (i.e. DHCP option 54) in DHCP responses with its own IP address.",
									MarkdownDescription: "`server_id_override`==`true` means the device, when acts as DHCP relay and forwards DHCP responses from DHCP server to clients, \nshould overwrite the Sever Identifier option (i.e. DHCP option 54) in DHCP responses with its own IP address.",
									Default:             booldefault.StaticBool(false),
								},
								"servers": schema.ListAttribute{
									ElementType:         types.StringType,
									Optional:            true,
									Computed:            true,
									Description:         "if `type`==`relay`",
									MarkdownDescription: "if `type`==`relay`",
									Default:             listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
								},
								"servers6": schema.ListAttribute{
									ElementType:         types.StringType,
									Optional:            true,
									Computed:            true,
									Description:         "if `type6`==`relay`",
									MarkdownDescription: "if `type6`==`relay`",
									Default:             listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
								},
								"type": schema.StringAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "DHCP Server (local) or DHCP Relay (relay)",
									MarkdownDescription: "DHCP Server (local) or DHCP Relay (relay)",
									Validators: []validator.String{
										stringvalidator.OneOf(
											"",
											"local",
											"relay",
											"none",
										),
									},
									Default: stringdefault.StaticString("local"),
								},
								"type6": schema.StringAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "DHCP Server (local) or DHCP Relay (relay)",
									MarkdownDescription: "DHCP Server (local) or DHCP Relay (relay)",
									Validators: []validator.String{
										stringvalidator.OneOf(
											"",
											"local",
											"relay",
											"none",
										),
									},
									Default: stringdefault.StaticString("none"),
								},
								"vendor_encapulated": schema.MapNestedAttribute{
									NestedObject: schema.NestedAttributeObject{
										Attributes: map[string]schema.Attribute{
											"type": schema.StringAttribute{
												Optional: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"",
														"string",
														"boolean",
														"ip",
														"hex",
														"int16",
														"int32",
														"uint16",
														"uint32",
													),
												},
											},
											"value": schema.StringAttribute{
												Optional: true,
											},
										},
										CustomType: VendorEncapulatedType{
											ObjectType: types.ObjectType{
												AttrTypes: VendorEncapulatedValue{}.AttributeTypes(ctx),
											},
										},
									},
									Optional:            true,
									Description:         "Property key is <enterprise number>:<sub option code>, with\n* enterprise number: 1-65535 (https://www.iana.org/assignments/enterprise-numbers/enterprise-numbers)\n* sub option code: 1-255, sub-option code",
									MarkdownDescription: "Property key is <enterprise number>:<sub option code>, with\n* enterprise number: 1-65535 (https://www.iana.org/assignments/enterprise-numbers/enterprise-numbers)\n* sub option code: 1-255, sub-option code",
								},
							},
							CustomType: ConfigType{
								ObjectType: types.ObjectType{
									AttrTypes: ConfigValue{}.AttributeTypes(ctx),
								},
							},
						},
						Optional: true,
					},
					"enabled": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "if set to `true`, disable the DHCP server",
						MarkdownDescription: "if set to `true`, disable the DHCP server",
						Default:             booldefault.StaticBool(false),
					},
				},
				CustomType: DhcpdConfigType{
					ObjectType: types.ObjectType{
						AttrTypes: DhcpdConfigValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
			},
			"dns_override": schema.BoolAttribute{
				Optional: true,
				Computed: true,
				Default:  booldefault.StaticBool(false),
			},
			"dns_servers": schema.ListAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Description:         "Global dns settings. To keep compatibility, dns settings in `ip_config` and `oob_ip_config` will overwrite this setting",
				MarkdownDescription: "Global dns settings. To keep compatibility, dns settings in `ip_config` and `oob_ip_config` will overwrite this setting",
			},
			"dns_suffix": schema.ListAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Description:         "Global dns settings. To keep compatibility, dns settings in `ip_config` and `oob_ip_config` will overwrite this setting",
				MarkdownDescription: "Global dns settings. To keep compatibility, dns settings in `ip_config` and `oob_ip_config` will overwrite this setting",
			},
			"extra_routes": schema.MapNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"via": schema.StringAttribute{
							Optional: true,
						},
					},
					CustomType: ExtraRoutesType{
						ObjectType: types.ObjectType{
							AttrTypes: ExtraRoutesValue{}.AttributeTypes(ctx),
						},
					},
				},
				Optional: true,
			},
			"id": schema.StringAttribute{
				Computed: true,
			},
			"idp_profiles": schema.MapNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"base_profile": schema.StringAttribute{
							Optional: true,
							Validators: []validator.String{
								stringvalidator.OneOf(
									"",
									"strict",
									"standard",
								),
							},
						},
						"name": schema.StringAttribute{
							Optional: true,
						},
						"overwrites": schema.ListNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"action": schema.StringAttribute{
										Optional:            true,
										Computed:            true,
										Description:         "- alert (default) \n- drop: siliently dropping packets\n- close: notify client/server to close connection",
										MarkdownDescription: "- alert (default) \n- drop: siliently dropping packets\n- close: notify client/server to close connection",
										Validators: []validator.String{
											stringvalidator.OneOf(
												"",
												"alert",
												"drop",
												"close",
											),
										},
										Default: stringdefault.StaticString("alert"),
									},
									"matching": schema.SingleNestedAttribute{
										Attributes: map[string]schema.Attribute{
											"attack_name": schema.ListAttribute{
												ElementType: types.StringType,
												Optional:    true,
											},
											"dst_subnet": schema.ListAttribute{
												ElementType: types.StringType,
												Optional:    true,
											},
											"severity": schema.ListAttribute{
												ElementType: types.StringType,
												Optional:    true,
											},
										},
										CustomType: IpdProfileOverwriteMatchingType{
											ObjectType: types.ObjectType{
												AttrTypes: IpdProfileOverwriteMatchingValue{}.AttributeTypes(ctx),
											},
										},
										Optional: true,
									},
								},
								CustomType: OverwritesType{
									ObjectType: types.ObjectType{
										AttrTypes: OverwritesValue{}.AttributeTypes(ctx),
									},
								},
							},
							Optional: true,
						},
					},
					CustomType: IdpProfilesType{
						ObjectType: types.ObjectType{
							AttrTypes: IdpProfilesValue{}.AttributeTypes(ctx),
						},
					},
				},
				Optional:            true,
				Description:         "Property key is the profile name",
				MarkdownDescription: "Property key is the profile name",
			},
			"ip_configs": schema.MapNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"ip": schema.StringAttribute{
							Optional: true,
						},
						"netmask": schema.StringAttribute{
							Optional: true,
						},
						"secondary_ips": schema.ListAttribute{
							ElementType:         types.StringType,
							Optional:            true,
							Computed:            true,
							Description:         "optional list of secondary IPs in CIDR format",
							MarkdownDescription: "optional list of secondary IPs in CIDR format",
							Default:             listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						},
						"type": schema.StringAttribute{
							Optional: true,
							Computed: true,
							Validators: []validator.String{
								stringvalidator.OneOf(
									"",
									"static",
									"dhcp",
								),
							},
							Default: stringdefault.StaticString("dhcp"),
						},
					},
					CustomType: IpConfigsType{
						ObjectType: types.ObjectType{
							AttrTypes: IpConfigsValue{}.AttributeTypes(ctx),
						},
					},
				},
				Optional:            true,
				Description:         "Property key is the network name",
				MarkdownDescription: "Property key is the network name",
			},
			"name": schema.StringAttribute{
				Required: true,
			},
			"networks": schema.ListNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"disallow_mist_services": schema.BoolAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "whether to disallow Mist Devices in the network",
							MarkdownDescription: "whether to disallow Mist Devices in the network",
							Default:             booldefault.StaticBool(false),
						},
						"gateway": schema.StringAttribute{
							Optional: true,
						},
						"gateway6": schema.StringAttribute{
							Optional: true,
						},
						"internal_access": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"enabled": schema.BoolAttribute{
									Optional: true,
								},
							},
							CustomType: InternalAccessType{
								ObjectType: types.ObjectType{
									AttrTypes: InternalAccessValue{}.AttributeTypes(ctx),
								},
							},
							Optional: true,
						},
						"internet_access": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"create_simple_service_policy": schema.BoolAttribute{
									Optional: true,
									Computed: true,
									Default:  booldefault.StaticBool(false),
								},
								"destination_nat": schema.MapNestedAttribute{
									NestedObject: schema.NestedAttributeObject{
										Attributes: map[string]schema.Attribute{
											"internal_ip": schema.StringAttribute{
												Optional: true,
											},
											"name": schema.StringAttribute{
												Optional: true,
											},
											"port": schema.Int64Attribute{
												Optional: true,
											},
										},
										CustomType: DestinationNatType{
											ObjectType: types.ObjectType{
												AttrTypes: DestinationNatValue{}.AttributeTypes(ctx),
											},
										},
									},
									Optional:            true,
									Description:         "Property key may be an IP/Port (i.e. \"63.16.0.3:443\"), or a port (i.e. \":2222\")",
									MarkdownDescription: "Property key may be an IP/Port (i.e. \"63.16.0.3:443\"), or a port (i.e. \":2222\")",
								},
								"enabled": schema.BoolAttribute{
									Optional: true,
								},
								"restricted": schema.BoolAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "by default, all access is allowed, to only allow certain traffic, make `restricted`=`true` and define service_policies",
									MarkdownDescription: "by default, all access is allowed, to only allow certain traffic, make `restricted`=`true` and define service_policies",
									Default:             booldefault.StaticBool(false),
								},
								"static_nat": schema.MapNestedAttribute{
									NestedObject: schema.NestedAttributeObject{
										Attributes: map[string]schema.Attribute{
											"internal_ip": schema.StringAttribute{
												Optional: true,
											},
											"name": schema.StringAttribute{
												Optional: true,
											},
											"wan_name": schema.StringAttribute{
												Optional:            true,
												Description:         "If not set, we configure the nat policies against all WAN ports for simplicity",
												MarkdownDescription: "If not set, we configure the nat policies against all WAN ports for simplicity",
											},
										},
										CustomType: StaticNatType{
											ObjectType: types.ObjectType{
												AttrTypes: StaticNatValue{}.AttributeTypes(ctx),
											},
										},
									},
									Optional:            true,
									Description:         "Property key may be an IP Address (i.e. \"172.16.0.1\"), and IP Address and Port (i.e. \"172.16.0.1:8443\") or a CIDR (i.e. \"172.16.0.12/20\")",
									MarkdownDescription: "Property key may be an IP Address (i.e. \"172.16.0.1\"), and IP Address and Port (i.e. \"172.16.0.1:8443\") or a CIDR (i.e. \"172.16.0.12/20\")",
								},
							},
							CustomType: InternetAccessType{
								ObjectType: types.ObjectType{
									AttrTypes: InternetAccessValue{}.AttributeTypes(ctx),
								},
							},
							Optional:            true,
							Description:         "whether this network has direct internet access",
							MarkdownDescription: "whether this network has direct internet access",
						},
						"isolation": schema.BoolAttribute{
							Optional:            true,
							Description:         "whether to allow clients in the network to talk to each other",
							MarkdownDescription: "whether to allow clients in the network to talk to each other",
						},
						"name": schema.StringAttribute{
							Required: true,
						},
						"routed_for_networks": schema.ListAttribute{
							ElementType:         types.StringType,
							Optional:            true,
							Description:         "for a Network (usually LAN), it can be routable to other networks (e.g. OSPF)",
							MarkdownDescription: "for a Network (usually LAN), it can be routable to other networks (e.g. OSPF)",
						},
						"subnet": schema.StringAttribute{
							Optional: true,
						},
						"subnet6": schema.StringAttribute{
							Optional: true,
						},
						"tenants": schema.MapNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"addresses": schema.ListAttribute{
										ElementType: types.StringType,
										Optional:    true,
									},
								},
								CustomType: TenantsType{
									ObjectType: types.ObjectType{
										AttrTypes: TenantsValue{}.AttributeTypes(ctx),
									},
								},
							},
							Optional: true,
						},
						"vlan_id": schema.Int64Attribute{
							Optional: true,
						},
						"vpn_access": schema.MapNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"advertised_subnet": schema.StringAttribute{
										Optional:            true,
										Description:         "if `routed`==`true`, whether to advertise an aggregated subnet toward HUB this is useful when there are multiple networks on SPOKE's side",
										MarkdownDescription: "if `routed`==`true`, whether to advertise an aggregated subnet toward HUB this is useful when there are multiple networks on SPOKE's side",
									},
									"allow_ping": schema.BoolAttribute{
										Optional:            true,
										Description:         "whether to allow ping from vpn into this routed network",
										MarkdownDescription: "whether to allow ping from vpn into this routed network",
									},
									"destination_nat": schema.MapNestedAttribute{
										NestedObject: schema.NestedAttributeObject{
											Attributes: map[string]schema.Attribute{
												"internal_ip": schema.StringAttribute{
													Optional: true,
												},
												"name": schema.StringAttribute{
													Optional: true,
												},
												"port": schema.Int64Attribute{
													Optional: true,
												},
											},
											CustomType: DestinationNatType{
												ObjectType: types.ObjectType{
													AttrTypes: DestinationNatValue{}.AttributeTypes(ctx),
												},
											},
										},
										Optional:            true,
										Description:         "Property key may be an IP/Port (i.e. \"63.16.0.3:443\"), or a port (i.e. \":2222\")",
										MarkdownDescription: "Property key may be an IP/Port (i.e. \"63.16.0.3:443\"), or a port (i.e. \":2222\")",
									},
									"nat_pool": schema.StringAttribute{
										Optional:            true,
										Description:         "if `routed`==`false` (usually at Spoke), but some hosts needs to be reachable from Hub, a subnet is required to create and advertise the route to Hub",
										MarkdownDescription: "if `routed`==`false` (usually at Spoke), but some hosts needs to be reachable from Hub, a subnet is required to create and advertise the route to Hub",
									},
									"no_readvertise_to_lan_bgp": schema.BoolAttribute{
										Optional:            true,
										Computed:            true,
										Description:         "toward LAN-side BGP peers",
										MarkdownDescription: "toward LAN-side BGP peers",
										Default:             booldefault.StaticBool(false),
									},
									"no_readvertise_to_lan_ospf": schema.BoolAttribute{
										Optional:            true,
										Computed:            true,
										Description:         "toward LAN-side OSPF peers",
										MarkdownDescription: "toward LAN-side OSPF peers",
										Default:             booldefault.StaticBool(false),
									},
									"no_readvertise_to_overlay": schema.BoolAttribute{
										Optional:            true,
										Description:         "toward overlay\nhow HUB should deal with routes it received from Spokes",
										MarkdownDescription: "toward overlay\nhow HUB should deal with routes it received from Spokes",
									},
									"other_vrfs": schema.ListAttribute{
										ElementType:         types.StringType,
										Optional:            true,
										Description:         "by default, the routes are only readvertised toward the same vrf on spoke\nto allow it to be leaked to other vrfs",
										MarkdownDescription: "by default, the routes are only readvertised toward the same vrf on spoke\nto allow it to be leaked to other vrfs",
									},
									"routed": schema.BoolAttribute{
										Optional:            true,
										Description:         "whether this network is routable",
										MarkdownDescription: "whether this network is routable",
									},
									"source_nat": schema.SingleNestedAttribute{
										Attributes: map[string]schema.Attribute{
											"exteral_ip": schema.StringAttribute{
												Optional: true,
											},
										},
										CustomType: SourceNatType{
											ObjectType: types.ObjectType{
												AttrTypes: SourceNatValue{}.AttributeTypes(ctx),
											},
										},
										Optional:            true,
										Description:         "if `routed`==`false` (usually at Spoke), but some hosts needs to be reachable from Hub",
										MarkdownDescription: "if `routed`==`false` (usually at Spoke), but some hosts needs to be reachable from Hub",
									},
									"static_nat": schema.MapNestedAttribute{
										NestedObject: schema.NestedAttributeObject{
											Attributes: map[string]schema.Attribute{
												"internal_ip": schema.StringAttribute{
													Optional: true,
												},
												"name": schema.StringAttribute{
													Optional: true,
												},
												"wan_name": schema.StringAttribute{
													Optional:            true,
													Description:         "If not set, we configure the nat policies against all WAN ports for simplicity",
													MarkdownDescription: "If not set, we configure the nat policies against all WAN ports for simplicity",
												},
											},
											CustomType: StaticNatType{
												ObjectType: types.ObjectType{
													AttrTypes: StaticNatValue{}.AttributeTypes(ctx),
												},
											},
										},
										Optional:            true,
										Description:         "Property key may be an IP Address (i.e. \"172.16.0.1\"), and IP Address and Port (i.e. \"172.16.0.1:8443\") or a CIDR (i.e. \"172.16.0.12/20\")",
										MarkdownDescription: "Property key may be an IP Address (i.e. \"172.16.0.1\"), and IP Address and Port (i.e. \"172.16.0.1:8443\") or a CIDR (i.e. \"172.16.0.12/20\")",
									},
									"summarized_subnet": schema.StringAttribute{
										Optional:            true,
										Description:         "toward overlay\nhow HUB should deal with routes it received from Spokes",
										MarkdownDescription: "toward overlay\nhow HUB should deal with routes it received from Spokes",
									},
									"summarized_subnet_to_lan_bgp": schema.StringAttribute{
										Optional:            true,
										Description:         "toward LAN-side BGP peers",
										MarkdownDescription: "toward LAN-side BGP peers",
									},
									"summarized_subnet_to_lan_ospf": schema.StringAttribute{
										Optional:            true,
										Description:         "toward LAN-side OSPF peers",
										MarkdownDescription: "toward LAN-side OSPF peers",
									},
								},
								CustomType: VpnAccessType{
									ObjectType: types.ObjectType{
										AttrTypes: VpnAccessValue{}.AttributeTypes(ctx),
									},
								},
							},
							Optional:            true,
							Description:         "Property key is the VPN name. Whether this network can be accessed from vpn",
							MarkdownDescription: "Property key is the VPN name. Whether this network can be accessed from vpn",
						},
					},
					CustomType: NetworksType{
						ObjectType: types.ObjectType{
							AttrTypes: NetworksValue{}.AttributeTypes(ctx),
						},
					},
				},
				Optional: true,
			},
			"ntp_override": schema.BoolAttribute{
				Optional: true,
				Computed: true,
				Default:  booldefault.StaticBool(false),
			},
			"ntp_servers": schema.ListAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Description:         "list of NTP servers specific to this device. By default, those in Site Settings will be used",
				MarkdownDescription: "list of NTP servers specific to this device. By default, those in Site Settings will be used",
			},
			"oob_ip_config": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"ip": schema.StringAttribute{
						Optional: true,
					},
					"netmask": schema.StringAttribute{
						Optional:            true,
						Description:         "used only if `subnet` is not specified in `networks`",
						MarkdownDescription: "used only if `subnet` is not specified in `networks`",
					},
					"network": schema.StringAttribute{
						Optional:            true,
						Description:         "optional, the network to be used for mgmt",
						MarkdownDescription: "optional, the network to be used for mgmt",
					},
					"node1": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"ip": schema.StringAttribute{
								Optional: true,
							},
							"netmask": schema.StringAttribute{
								Optional:            true,
								Description:         "used only if `subnet` is not specified in `networks`",
								MarkdownDescription: "used only if `subnet` is not specified in `networks`",
							},
							"network": schema.StringAttribute{
								Optional:            true,
								Description:         "optional, the network to be used for mgmt",
								MarkdownDescription: "optional, the network to be used for mgmt",
							},
							"type": schema.StringAttribute{
								Optional: true,
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"",
										"static",
										"dhcp",
									),
								},
								Default: stringdefault.StaticString("dhcp"),
							},
							"use_mgmt_vrf": schema.BoolAttribute{
								Optional:            true,
								Computed:            true,
								Description:         "if supported on the platform. If enabled, DNS will be using this routing-instance, too",
								MarkdownDescription: "if supported on the platform. If enabled, DNS will be using this routing-instance, too",
								Default:             booldefault.StaticBool(false),
							},
							"use_mgmt_vrf_for_host_out": schema.BoolAttribute{
								Optional:            true,
								Computed:            true,
								Description:         "whether to use `mgmt_junos` for host-out traffic (NTP/TACPLUS/RADIUS/SYSLOG/SNMP), if alternative source network/ip is desired",
								MarkdownDescription: "whether to use `mgmt_junos` for host-out traffic (NTP/TACPLUS/RADIUS/SYSLOG/SNMP), if alternative source network/ip is desired",
								Default:             booldefault.StaticBool(false),
							},
						},
						CustomType: Node1Type{
							ObjectType: types.ObjectType{
								AttrTypes: Node1Value{}.AttributeTypes(ctx),
							},
						},
						Optional:            true,
						Description:         "for HA Cluster, node1 can have different IP Config",
						MarkdownDescription: "for HA Cluster, node1 can have different IP Config",
					},
					"type": schema.StringAttribute{
						Optional: true,
						Computed: true,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"",
								"static",
								"dhcp",
							),
						},
						Default: stringdefault.StaticString("dhcp"),
					},
					"use_mgmt_vrf": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "f supported on the platform. If enabled, DNS will be using this routing-instance, too",
						MarkdownDescription: "f supported on the platform. If enabled, DNS will be using this routing-instance, too",
						Default:             booldefault.StaticBool(false),
					},
					"use_mgmt_vrf_for_host_out": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "for host-out traffic (NTP/TACPLUS/RADIUS/SYSLOG/SNMP), if alternative source network/ip is desired,",
						MarkdownDescription: "for host-out traffic (NTP/TACPLUS/RADIUS/SYSLOG/SNMP), if alternative source network/ip is desired,",
						Default:             booldefault.StaticBool(false),
					},
				},
				CustomType: OobIpConfigType{
					ObjectType: types.ObjectType{
						AttrTypes: OobIpConfigValue{}.AttributeTypes(ctx),
					},
				},
				Optional:            true,
				Description:         "out-of-band (vme/em0/fxp0) IP config",
				MarkdownDescription: "out-of-band (vme/em0/fxp0) IP config",
			},
			"org_id": schema.StringAttribute{
				Required: true,
			},
			"path_preferences": schema.MapNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"paths": schema.ListNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"cost": schema.Int64Attribute{
										Optional: true,
									},
									"disabled": schema.BoolAttribute{
										Optional:            true,
										Description:         "For SSR Only. `true`` if this specific path is undesired",
										MarkdownDescription: "For SSR Only. `true`` if this specific path is undesired",
									},
									"gateway_ip": schema.StringAttribute{
										Optional:            true,
										Description:         "if `type`==`local`, if a different gateway is desired",
										MarkdownDescription: "if `type`==`local`, if a different gateway is desired",
									},
									"internet_access": schema.BoolAttribute{
										Optional:            true,
										Computed:            true,
										Description:         "when `type`==`vpn`, if this vpn path can be used for internet",
										MarkdownDescription: "when `type`==`vpn`, if this vpn path can be used for internet",
										Default:             booldefault.StaticBool(false),
									},
									"name": schema.StringAttribute{
										Optional: true,
									},
									"networks": schema.ListAttribute{
										ElementType:         types.StringType,
										Optional:            true,
										Computed:            true,
										Description:         "if `type`==`local`",
										MarkdownDescription: "if `type`==`local`",
										Default:             listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
									},
									"target_ips": schema.ListAttribute{
										ElementType:         types.StringType,
										Optional:            true,
										Computed:            true,
										Description:         "if `type`==`local`, if destination IP is to be replaced",
										MarkdownDescription: "if `type`==`local`, if destination IP is to be replaced",
										Default:             listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
									},
									"type": schema.StringAttribute{
										Optional: true,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"",
												"local",
												"wan",
												"vpn",
												"tunnel",
											),
										},
									},
									"wan_name": schema.StringAttribute{
										Optional:            true,
										Description:         "Spoke's outgoing wan",
										MarkdownDescription: "Spoke's outgoing wan",
									},
								},
								CustomType: PathsType{
									ObjectType: types.ObjectType{
										AttrTypes: PathsValue{}.AttributeTypes(ctx),
									},
								},
							},
							Optional: true,
						},
						"strategy": schema.StringAttribute{
							Optional: true,
							Computed: true,
							Validators: []validator.String{
								stringvalidator.OneOf(
									"",
									"ordered",
									"weighted",
									"ecmp",
								),
							},
							Default: stringdefault.StaticString("ordered"),
						},
					},
					CustomType: PathPreferencesType{
						ObjectType: types.ObjectType{
							AttrTypes: PathPreferencesValue{}.AttributeTypes(ctx),
						},
					},
				},
				Optional:            true,
				Description:         "Property key is the path name",
				MarkdownDescription: "Property key is the path name",
			},
			"port_config": schema.MapNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"description": schema.StringAttribute{
							Optional: true,
						},
						"disable_autoneg": schema.BoolAttribute{
							Optional: true,
							Computed: true,
							Default:  booldefault.StaticBool(false),
						},
						"disabled": schema.BoolAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "port admin up (true) / down (false)",
							MarkdownDescription: "port admin up (true) / down (false)",
							Default:             booldefault.StaticBool(false),
						},
						"dsl_type": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "if `wan_type`==`lte`",
							MarkdownDescription: "if `wan_type`==`lte`",
							Validators: []validator.String{
								stringvalidator.OneOf(
									"",
									"vdsl",
									"adsl",
								),
							},
							Default: stringdefault.StaticString("vdsl"),
						},
						"dsl_vci": schema.Int64Attribute{
							Optional:            true,
							Computed:            true,
							Description:         "if `wan_type`==`dsl`\n16 bit int",
							MarkdownDescription: "if `wan_type`==`dsl`\n16 bit int",
							Default:             int64default.StaticInt64(35),
						},
						"dsl_vpi": schema.Int64Attribute{
							Optional:            true,
							Computed:            true,
							Description:         "if `wan_type`==`dsl`\n8 bit int",
							MarkdownDescription: "if `wan_type`==`dsl`\n8 bit int",
							Default:             int64default.StaticInt64(0),
						},
						"duplex": schema.StringAttribute{
							Optional: true,
							Computed: true,
							Validators: []validator.String{
								stringvalidator.OneOf(
									"",
									"half",
									"full",
									"auto",
								),
							},
							Default: stringdefault.StaticString("auto"),
						},
						"lte_apn": schema.StringAttribute{
							Optional:            true,
							Description:         "if `wan_type`==`lte`",
							MarkdownDescription: "if `wan_type`==`lte`",
						},
						"lte_auth": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "if `wan_type`==`lte`",
							MarkdownDescription: "if `wan_type`==`lte`",
							Validators: []validator.String{
								stringvalidator.OneOf(
									"",
									"none",
									"chap",
									"pap",
								),
							},
							Default: stringdefault.StaticString("none"),
						},
						"lte_backup": schema.BoolAttribute{
							Optional: true,
						},
						"lte_password": schema.StringAttribute{
							Optional:            true,
							Sensitive:           true,
							Description:         "if `wan_type`==`lte`",
							MarkdownDescription: "if `wan_type`==`lte`",
						},
						"lte_username": schema.StringAttribute{
							Optional:            true,
							Description:         "if `wan_type`==`lte`",
							MarkdownDescription: "if `wan_type`==`lte`",
						},
						"mtu": schema.Int64Attribute{
							Optional: true,
						},
						"name": schema.StringAttribute{
							Optional:            true,
							Description:         "name that we'll use to derive config",
							MarkdownDescription: "name that we'll use to derive config",
						},
						"networks": schema.ListAttribute{
							ElementType:         types.StringType,
							Optional:            true,
							Computed:            true,
							Description:         "if `usage`==`lan`",
							MarkdownDescription: "if `usage`==`lan`",
							Default:             listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						},
						"outer_vlan_id": schema.Int64Attribute{
							Optional:            true,
							Description:         "for Q-in-Q",
							MarkdownDescription: "for Q-in-Q",
						},
						"poe_disabled": schema.BoolAttribute{
							Optional: true,
							Computed: true,
							Default:  booldefault.StaticBool(false),
						},
						"ip_config": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"dns": schema.ListAttribute{
									ElementType:         types.StringType,
									Optional:            true,
									Description:         "except for out-of_band interface (vme/em0/fxp0)",
									MarkdownDescription: "except for out-of_band interface (vme/em0/fxp0)",
								},
								"dns_suffix": schema.ListAttribute{
									ElementType:         types.StringType,
									Optional:            true,
									Description:         "except for out-of_band interface (vme/em0/fxp0)",
									MarkdownDescription: "except for out-of_band interface (vme/em0/fxp0)",
								},
								"gateway": schema.StringAttribute{
									Optional:            true,
									Description:         "except for out-of_band interface (vme/em0/fxp0)",
									MarkdownDescription: "except for out-of_band interface (vme/em0/fxp0)",
								},
								"ip": schema.StringAttribute{
									Optional: true,
								},
								"netmask": schema.StringAttribute{
									Optional:            true,
									Description:         "used only if `subnet` is not specified in `networks`",
									MarkdownDescription: "used only if `subnet` is not specified in `networks`",
								},
								"network": schema.StringAttribute{
									Optional:            true,
									Description:         "optional, the network to be used for mgmt",
									MarkdownDescription: "optional, the network to be used for mgmt",
								},
								"poser_password": schema.StringAttribute{
									Optional:            true,
									Sensitive:           true,
									Description:         "if `type`==`pppoe`",
									MarkdownDescription: "if `type`==`pppoe`",
								},
								"pppoe_auth": schema.StringAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "if `type`==`pppoe`",
									MarkdownDescription: "if `type`==`pppoe`",
									Validators: []validator.String{
										stringvalidator.OneOf(
											"",
											"none",
											"chap",
											"pap",
										),
									},
									Default: stringdefault.StaticString("none"),
								},
								"pppoe_username": schema.StringAttribute{
									Optional:            true,
									Description:         "if `type`==`pppoe`",
									MarkdownDescription: "if `type`==`pppoe`",
								},
								"type": schema.StringAttribute{
									Optional: true,
									Computed: true,
									Validators: []validator.String{
										stringvalidator.OneOf(
											"",
											"dhcp",
											"static",
											"pppoe",
										),
									},
									Default: stringdefault.StaticString("dhcp"),
								},
							},
							CustomType: PortIpConfigType{
								ObjectType: types.ObjectType{
									AttrTypes: PortIpConfigValue{}.AttributeTypes(ctx),
								},
							},
							Optional:            true,
							Description:         "Junos IP Config",
							MarkdownDescription: "Junos IP Config",
						},
						"port_network": schema.StringAttribute{
							Optional:            true,
							Description:         "if `usage`==`lan`",
							MarkdownDescription: "if `usage`==`lan`",
						},
						"preserve_dscp": schema.BoolAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "whether to preserve dscp when sending traffic over VPN (SSR-only)",
							MarkdownDescription: "whether to preserve dscp when sending traffic over VPN (SSR-only)",
							Default:             booldefault.StaticBool(true),
						},
						"redundant": schema.BoolAttribute{
							Optional:            true,
							Description:         "if HA mode",
							MarkdownDescription: "if HA mode",
						},
						"reth_idx": schema.Int64Attribute{
							Optional:            true,
							Description:         "if HA mode",
							MarkdownDescription: "if HA mode",
						},
						"reth_node": schema.StringAttribute{
							Optional:            true,
							Description:         "if HA mode",
							MarkdownDescription: "if HA mode",
						},
						"reth_nodes": schema.ListAttribute{
							ElementType:         types.StringType,
							Optional:            true,
							Computed:            true,
							Description:         "SSR only - supporting vlan-based redundancy (matching the size of `networks`)",
							MarkdownDescription: "SSR only - supporting vlan-based redundancy (matching the size of `networks`)",
							Default:             listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						},
						"speed": schema.StringAttribute{
							Optional: true,
							Computed: true,
							Default:  stringdefault.StaticString("auto"),
						},
						"ssr_no_virtual_mac": schema.BoolAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "when SSR is running as VM, this is required on certain hosting platforms",
							MarkdownDescription: "when SSR is running as VM, this is required on certain hosting platforms",
							Default:             booldefault.StaticBool(false),
						},
						"svr_port_range": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "for SSR only",
							MarkdownDescription: "for SSR only",
							Default:             stringdefault.StaticString("none"),
						},
						"traffic_shaping": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"class_percentages": schema.ListAttribute{
									ElementType:         types.Int64Type,
									Optional:            true,
									Description:         "percentages for differet class of traffic: high / medium / low / best-effort\nsum must be equal to 100",
									MarkdownDescription: "percentages for differet class of traffic: high / medium / low / best-effort\nsum must be equal to 100",
								},
								"enabled": schema.BoolAttribute{
									Optional: true,
									Computed: true,
									Default:  booldefault.StaticBool(false),
								},
							},
							CustomType: TrafficShapingType{
								ObjectType: types.ObjectType{
									AttrTypes: TrafficShapingValue{}.AttributeTypes(ctx),
								},
							},
							Optional: true,
						},
						"usage": schema.StringAttribute{
							Required:            true,
							Description:         "port usage name",
							MarkdownDescription: "port usage name",
							Validators: []validator.String{
								stringvalidator.OneOf(
									"",
									"lan",
									"wan",
									"ha_data",
									"ha_control",
								),
							},
						},
						"vlan_id": schema.Int64Attribute{
							Optional:            true,
							Description:         "if WAN interface is on a VLAN",
							MarkdownDescription: "if WAN interface is on a VLAN",
						},
						"vpn_paths": schema.MapNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"bfd_profile": schema.StringAttribute{
										Optional: true,
										Computed: true,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"",
												"lte",
												"broadband",
											),
										},
										Default: stringdefault.StaticString("broadband"),
									},
									"bfd_use_tunnel_mode": schema.BoolAttribute{
										Optional:            true,
										Computed:            true,
										Description:         "whether to use tunnel mode. SSR only",
										MarkdownDescription: "whether to use tunnel mode. SSR only",
										Default:             booldefault.StaticBool(false),
									},
									"preference": schema.Int64Attribute{
										Optional:            true,
										Description:         "for a given VPN, when `path_selection.strategy`==`simple`, the preference for a path (lower is preferred)",
										MarkdownDescription: "for a given VPN, when `path_selection.strategy`==`simple`, the preference for a path (lower is preferred)",
									},
									"role": schema.StringAttribute{
										Optional: true,
										Computed: true,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"",
												"spoke",
												"hub",
											),
										},
										Default: stringdefault.StaticString("spoke"),
									},
									"traffic_shaping": schema.SingleNestedAttribute{
										Attributes: map[string]schema.Attribute{
											"class_percentages": schema.ListAttribute{
												ElementType:         types.Int64Type,
												Optional:            true,
												Description:         "percentages for differet class of traffic: high / medium / low / best-effort\nsum must be equal to 100",
												MarkdownDescription: "percentages for differet class of traffic: high / medium / low / best-effort\nsum must be equal to 100",
											},
											"enabled": schema.BoolAttribute{
												Optional: true,
												Computed: true,
												Default:  booldefault.StaticBool(false),
											},
										},
										CustomType: TrafficShapingType{
											ObjectType: types.ObjectType{
												AttrTypes: TrafficShapingValue{}.AttributeTypes(ctx),
											},
										},
										Optional: true,
									},
								},
								CustomType: VpnPathsType{
									ObjectType: types.ObjectType{
										AttrTypes: VpnPathsValue{}.AttributeTypes(ctx),
									},
								},
							},
							Optional: true,
						},
						"wan_arp_policer": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "when `wan_type`==`broadband`",
							MarkdownDescription: "when `wan_type`==`broadband`",
							Validators: []validator.String{
								stringvalidator.OneOf(
									"",
									"recommended",
									"default",
									"max",
								),
							},
							Default: stringdefault.StaticString("recommended"),
						},
						"wan_ext_ip": schema.StringAttribute{
							Optional:            true,
							Description:         "optional, if spoke should reach this port by a different IP",
							MarkdownDescription: "optional, if spoke should reach this port by a different IP",
						},
						"wan_source_nat": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"disabled": schema.BoolAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "or to disable the source-nat",
									MarkdownDescription: "or to disable the source-nat",
									Default:             booldefault.StaticBool(false),
								},
								"nat_pool": schema.StringAttribute{
									Optional:            true,
									Description:         "if alternative nat_pool is desired",
									MarkdownDescription: "if alternative nat_pool is desired",
								},
							},
							CustomType: WanSourceNatType{
								ObjectType: types.ObjectType{
									AttrTypes: WanSourceNatValue{}.AttributeTypes(ctx),
								},
							},
							Optional:            true,
							Description:         "optional, by default, source-NAT is performed on all WAN Ports using the interface-ip",
							MarkdownDescription: "optional, by default, source-NAT is performed on all WAN Ports using the interface-ip",
						},
						"wan_type": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "if `usage`==`wan`",
							MarkdownDescription: "if `usage`==`wan`",
							Validators: []validator.String{
								stringvalidator.OneOf(
									"",
									"broadband",
									"dsl",
									"lte",
								),
							},
							Default: stringdefault.StaticString("broadband"),
						},
					},
					CustomType: PortConfigType{
						ObjectType: types.ObjectType{
							AttrTypes: PortConfigValue{}.AttributeTypes(ctx),
						},
					},
				},
				Optional:            true,
				Description:         "Property key is the port(s) name or range (e.g. \"ge-0/0/0-10\")",
				MarkdownDescription: "Property key is the port(s) name or range (e.g. \"ge-0/0/0-10\")",
			},
			"router_id": schema.StringAttribute{
				Optional:            true,
				Description:         "auto assigned if not set",
				MarkdownDescription: "auto assigned if not set",
			},
			"routing_policies": schema.MapNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"terms": schema.ListNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"action": schema.SingleNestedAttribute{
										Attributes: map[string]schema.Attribute{
											"accept": schema.BoolAttribute{
												Optional: true,
											},
											"add_community": schema.ListAttribute{
												ElementType: types.StringType,
												Optional:    true,
											},
											"add_target_vrfs": schema.ListAttribute{
												ElementType:         types.StringType,
												Optional:            true,
												Description:         "for SSR, hub decides how VRF routes are leaked on spoke",
												MarkdownDescription: "for SSR, hub decides how VRF routes are leaked on spoke",
											},
											"community": schema.ListAttribute{
												ElementType:         types.StringType,
												Optional:            true,
												Description:         "when used as export policy, optional",
												MarkdownDescription: "when used as export policy, optional",
											},
											"exclude_as_path": schema.ListAttribute{
												ElementType:         types.StringType,
												Optional:            true,
												Description:         "when used as export policy, optional. To exclude certain AS",
												MarkdownDescription: "when used as export policy, optional. To exclude certain AS",
											},
											"exclude_community": schema.ListAttribute{
												ElementType: types.StringType,
												Optional:    true,
											},
											"export_communitites": schema.ListAttribute{
												ElementType:         types.StringType,
												Optional:            true,
												Description:         "when used as export policy, optional",
												MarkdownDescription: "when used as export policy, optional",
											},
											"local_preference": schema.StringAttribute{
												Optional:            true,
												Description:         "optional, for an import policy, local_preference can be changed",
												MarkdownDescription: "optional, for an import policy, local_preference can be changed",
											},
											"prepend_as_path": schema.ListAttribute{
												ElementType:         types.StringType,
												Optional:            true,
												Description:         "when used as export policy, optional. By default, the local AS will be prepended, to change it",
												MarkdownDescription: "when used as export policy, optional. By default, the local AS will be prepended, to change it",
											},
										},
										CustomType: ActionType{
											ObjectType: types.ObjectType{
												AttrTypes: ActionValue{}.AttributeTypes(ctx),
											},
										},
										Optional:            true,
										Description:         "when used as import policy",
										MarkdownDescription: "when used as import policy",
									},
									"matching": schema.SingleNestedAttribute{
										Attributes: map[string]schema.Attribute{
											"as_path": schema.ListAttribute{
												ElementType:         types.StringType,
												Optional:            true,
												Description:         "takes regular expression",
												MarkdownDescription: "takes regular expression",
											},
											"community": schema.ListAttribute{
												ElementType: types.StringType,
												Optional:    true,
											},
											"network": schema.ListAttribute{
												ElementType: types.StringType,
												Optional:    true,
												Validators: []validator.List{
													listvalidator.UniqueValues(),
												},
											},
											"prefix": schema.ListAttribute{
												ElementType:         types.StringType,
												Optional:            true,
												Description:         "zero or more criteria/filter can be specified to match the term, all criteria have to be met",
												MarkdownDescription: "zero or more criteria/filter can be specified to match the term, all criteria have to be met",
											},
											"protocol": schema.ListAttribute{
												ElementType:         types.StringType,
												Optional:            true,
												Description:         "`direct`, `bgp`, `osp`, ...",
												MarkdownDescription: "`direct`, `bgp`, `osp`, ...",
											},
											"route_exists": schema.SingleNestedAttribute{
												Attributes: map[string]schema.Attribute{
													"route": schema.StringAttribute{
														Optional: true,
													},
													"vrf_name": schema.StringAttribute{
														Optional:            true,
														Computed:            true,
														Description:         "name of the vrf instance\nit can also be the name of the VPN or wan if they",
														MarkdownDescription: "name of the vrf instance\nit can also be the name of the VPN or wan if they",
														Default:             stringdefault.StaticString("default"),
													},
												},
												CustomType: RouteExistsType{
													ObjectType: types.ObjectType{
														AttrTypes: RouteExistsValue{}.AttributeTypes(ctx),
													},
												},
												Optional: true,
											},
											"vpn_neighbor_mac": schema.ListAttribute{
												ElementType:         types.StringType,
												Optional:            true,
												Description:         "overlay-facing criteria (used for bgp_config where via=vpn)",
												MarkdownDescription: "overlay-facing criteria (used for bgp_config where via=vpn)",
											},
											"vpn_path": schema.ListAttribute{
												ElementType:         types.StringType,
												Optional:            true,
												Description:         "overlay-facing criteria (used for bgp_config where via=vpn)\nordered-",
												MarkdownDescription: "overlay-facing criteria (used for bgp_config where via=vpn)\nordered-",
											},
											"vpn_path_sla": schema.SingleNestedAttribute{
												Attributes: map[string]schema.Attribute{
													"max_jitter": schema.Int64Attribute{
														Optional: true,
													},
													"max_latency": schema.Int64Attribute{
														Optional: true,
													},
													"max_loss": schema.Int64Attribute{
														Optional: true,
													},
												},
												CustomType: VpnPathSlaType{
													ObjectType: types.ObjectType{
														AttrTypes: VpnPathSlaValue{}.AttributeTypes(ctx),
													},
												},
												Optional: true,
											},
										},
										CustomType: RoutingPolicyTermMatchingType{
											ObjectType: types.ObjectType{
												AttrTypes: RoutingPolicyTermMatchingValue{}.AttributeTypes(ctx),
											},
										},
										Optional:            true,
										Description:         "zero or more criteria/filter can be specified to match the term, all criteria have to be met",
										MarkdownDescription: "zero or more criteria/filter can be specified to match the term, all criteria have to be met",
									},
								},
								CustomType: TermsType{
									ObjectType: types.ObjectType{
										AttrTypes: TermsValue{}.AttributeTypes(ctx),
									},
								},
							},
							Optional:            true,
							Description:         "zero or more criteria/filter can be specified to match the term, all criteria have to be met",
							MarkdownDescription: "zero or more criteria/filter can be specified to match the term, all criteria have to be met",
							Validators: []validator.List{
								listvalidator.UniqueValues(),
							},
						},
					},
					CustomType: RoutingPoliciesType{
						ObjectType: types.ObjectType{
							AttrTypes: RoutingPoliciesValue{}.AttributeTypes(ctx),
						},
					},
				},
				Optional:            true,
				Description:         "Property key is the routing policy name",
				MarkdownDescription: "Property key is the routing policy name",
			},
			"service_policies": schema.ListNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"action": schema.StringAttribute{
							Optional: true,
							Computed: true,
							Validators: []validator.String{
								stringvalidator.OneOf(
									"",
									"allow",
									"deny",
								),
							},
							Default: stringdefault.StaticString("allow"),
						},
						"appqoe": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"enabled": schema.BoolAttribute{
									Optional: true,
									Computed: true,
									Default:  booldefault.StaticBool(false),
								},
							},
							CustomType: AppqoeType{
								ObjectType: types.ObjectType{
									AttrTypes: AppqoeValue{}.AttributeTypes(ctx),
								},
							},
							Optional:            true,
							Description:         "For SRX Only",
							MarkdownDescription: "For SRX Only",
						},
						"ewf": schema.ListNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"alert_only": schema.BoolAttribute{
										Optional: true,
									},
									"block_message": schema.StringAttribute{
										Optional: true,
									},
									"enabled": schema.BoolAttribute{
										Optional: true,
										Computed: true,
										Default:  booldefault.StaticBool(false),
									},
									"profile": schema.StringAttribute{
										Optional: true,
										Computed: true,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"",
												"strict",
												"standard",
											),
										},
										Default: stringdefault.StaticString("strict"),
									},
								},
								CustomType: EwfType{
									ObjectType: types.ObjectType{
										AttrTypes: EwfValue{}.AttributeTypes(ctx),
									},
								},
							},
							Optional: true,
						},
						"idp": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"alert_only": schema.BoolAttribute{
									Optional: true,
								},
								"enabled": schema.BoolAttribute{
									Optional: true,
									Computed: true,
									Default:  booldefault.StaticBool(false),
								},
								"idpprofile_id": schema.StringAttribute{
									Optional:            true,
									Description:         "org_level IDP Profile can be used, this takes precedence over `profile`",
									MarkdownDescription: "org_level IDP Profile can be used, this takes precedence over `profile`",
								},
								"profile": schema.StringAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "`strict` (default) / `standard` / or keys from from idp_profiles",
									MarkdownDescription: "`strict` (default) / `standard` / or keys from from idp_profiles",
									Default:             stringdefault.StaticString("strict"),
								},
							},
							CustomType: IdpType{
								ObjectType: types.ObjectType{
									AttrTypes: IdpValue{}.AttributeTypes(ctx),
								},
							},
							Optional: true,
						},
						"local_routing": schema.BoolAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "access within the same VRF",
							MarkdownDescription: "access within the same VRF",
							Default:             booldefault.StaticBool(false),
						},
						"name": schema.StringAttribute{
							Optional: true,
						},
						"path_preferences": schema.StringAttribute{
							Optional:            true,
							Description:         "by default, we derive all paths available and use them\noptionally, you can customize by using `path_preference`",
							MarkdownDescription: "by default, we derive all paths available and use them\noptionally, you can customize by using `path_preference`",
						},
						"servicepolicy_id": schema.StringAttribute{
							Optional:            true,
							Description:         "used to link servicepolicy defined at org level and overwrite some attributes",
							MarkdownDescription: "used to link servicepolicy defined at org level and overwrite some attributes",
						},
						"services": schema.ListAttribute{
							ElementType: types.StringType,
							Optional:    true,
							Validators: []validator.List{
								listvalidator.UniqueValues(),
							},
						},
						"tenants": schema.ListAttribute{
							ElementType: types.StringType,
							Optional:    true,
							Validators: []validator.List{
								listvalidator.UniqueValues(),
							},
						},
					},
					CustomType: ServicePoliciesType{
						ObjectType: types.ObjectType{
							AttrTypes: ServicePoliciesValue{}.AttributeTypes(ctx),
						},
					},
				},
				Optional: true,
			},
			"tunnel_configs": schema.MapNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"auto_provision": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"primary": schema.SingleNestedAttribute{
									Attributes: map[string]schema.Attribute{
										"num_hosts": schema.StringAttribute{
											Optional: true,
										},
										"wan_names": schema.ListAttribute{
											ElementType:         types.StringType,
											Optional:            true,
											Description:         "optional, only needed if `vars_only`==`false`",
											MarkdownDescription: "optional, only needed if `vars_only`==`false`",
										},
									},
									CustomType: AutoProvisionPrimaryType{
										ObjectType: types.ObjectType{
											AttrTypes: AutoProvisionPrimaryValue{}.AttributeTypes(ctx),
										},
									},
									Optional: true,
								},
								"secondary": schema.SingleNestedAttribute{
									Attributes: map[string]schema.Attribute{
										"num_hosts": schema.StringAttribute{
											Optional: true,
										},
										"wan_names": schema.ListAttribute{
											ElementType:         types.StringType,
											Optional:            true,
											Description:         "optional, only needed if `vars_only`==`false`",
											MarkdownDescription: "optional, only needed if `vars_only`==`false`",
										},
									},
									CustomType: AutoProvisionSecondaryType{
										ObjectType: types.ObjectType{
											AttrTypes: AutoProvisionSecondaryValue{}.AttributeTypes(ctx),
										},
									},
									Optional: true,
								},
								"enable": schema.BoolAttribute{
									Optional: true,
								},
								"latlng": schema.SingleNestedAttribute{
									Attributes: map[string]schema.Attribute{
										"lat": schema.Float64Attribute{
											Required: true,
										},
										"lng": schema.Float64Attribute{
											Required: true,
										},
									},
									CustomType: LatlngType{
										ObjectType: types.ObjectType{
											AttrTypes: LatlngValue{}.AttributeTypes(ctx),
										},
									},
									Optional: true,
								},
								"region": schema.StringAttribute{
									Optional: true,
									Computed: true,
									Validators: []validator.String{
										stringvalidator.OneOf(
											"",
											"auto",
											"EMEA",
											"Americas",
											"APAC",
										),
									},
									Default: stringdefault.StaticString("auto"),
								},
							},
							CustomType: AutoProvisionType{
								ObjectType: types.ObjectType{
									AttrTypes: AutoProvisionValue{}.AttributeTypes(ctx),
								},
							},
							Optional: true,
						},
						"ike_lifetime": schema.Int64Attribute{
							Optional:            true,
							Description:         "Only if:\n* `provider`== `custom-ipsec`",
							MarkdownDescription: "Only if:\n* `provider`== `custom-ipsec`",
						},
						"ike_mode": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "Only if:\n* `provider`== `custom-ipsec`",
							MarkdownDescription: "Only if:\n* `provider`== `custom-ipsec`",
							Validators: []validator.String{
								stringvalidator.OneOf(
									"",
									"main",
									"aggressive",
								),
							},
							Default: stringdefault.StaticString("main"),
						},
						"ike_proposals": schema.ListNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"auth_algo": schema.StringAttribute{
										Optional: true,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"",
												"sha1",
												"sha2",
												"md5",
											),
										},
									},
									"dh_group": schema.StringAttribute{
										Optional:            true,
										Computed:            true,
										Description:         "* 1 \n* 2 (1024-bit) \n* 5\n* 14 (default, 2048-bit)\n* 15 (3072-bit) \n* 16 (4096-bit)\n* 19 (256-bit ECP)\n* 20 (384-bit ECP)\n* 21 (521-bit ECP) \n* 24 (2048-bit ECP)",
										MarkdownDescription: "* 1 \n* 2 (1024-bit) \n* 5\n* 14 (default, 2048-bit)\n* 15 (3072-bit) \n* 16 (4096-bit)\n* 19 (256-bit ECP)\n* 20 (384-bit ECP)\n* 21 (521-bit ECP) \n* 24 (2048-bit ECP)",
										Validators: []validator.String{
											stringvalidator.OneOf(
												"",
												"1",
												"2",
												"5",
												"14",
												"15",
												"16",
												"19",
												"20",
												"21",
												"24",
											),
										},
										Default: stringdefault.StaticString("14"),
									},
									"enc_algo": schema.StringAttribute{
										Optional: true,
										Computed: true,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"",
												"aes256",
												"3des",
												"aes128",
												"aes_gcm256",
												"aes_gcm128",
											),
										},
										Default: stringdefault.StaticString("aes256"),
									},
								},
								CustomType: IkeProposalsType{
									ObjectType: types.ObjectType{
										AttrTypes: IkeProposalsValue{}.AttributeTypes(ctx),
									},
								},
							},
							Optional:            true,
							Description:         "if `provider`== `custom-ipsec`",
							MarkdownDescription: "if `provider`== `custom-ipsec`",
						},
						"ipsec_lifetime": schema.Int64Attribute{
							Optional:            true,
							Description:         "if `provider`== `custom-ipsec`",
							MarkdownDescription: "if `provider`== `custom-ipsec`",
						},
						"ipsec_proposals": schema.ListNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"auth_algo": schema.StringAttribute{
										Optional: true,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"",
												"sha1",
												"sha2",
												"md5",
											),
										},
									},
									"dh_group": schema.StringAttribute{
										Optional:            true,
										Computed:            true,
										Description:         "Only if:\n* `provider`== `custom-ipsec`\nValues:\n* 1 \n* 2 (1024-bit) \n* 5\n* 14 (default, 2048-bit) \n* 15 (3072-bit) \n* 16 (4096-bit)\n* 19 (256-bit ECP)\n* 20 (384-bit ECP)\n* 21 (521-bit ECP) \n* 24 (2048-bit ECP)",
										MarkdownDescription: "Only if:\n* `provider`== `custom-ipsec`\nValues:\n* 1 \n* 2 (1024-bit) \n* 5\n* 14 (default, 2048-bit) \n* 15 (3072-bit) \n* 16 (4096-bit)\n* 19 (256-bit ECP)\n* 20 (384-bit ECP)\n* 21 (521-bit ECP) \n* 24 (2048-bit ECP)",
										Validators: []validator.String{
											stringvalidator.OneOf(
												"",
												"1",
												"2",
												"5",
												"14",
												"15",
												"16",
												"19",
												"20",
												"21",
												"24",
											),
										},
										Default: stringdefault.StaticString("14"),
									},
									"enc_algo": schema.StringAttribute{
										Optional: true,
										Computed: true,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"",
												"aes256",
												"3des",
												"aes128",
												"aes_gcm256",
												"aes_gcm128",
											),
										},
										Default: stringdefault.StaticString("aes256"),
									},
								},
								CustomType: IpsecProposalsType{
									ObjectType: types.ObjectType{
										AttrTypes: IpsecProposalsValue{}.AttributeTypes(ctx),
									},
								},
							},
							Optional:            true,
							Description:         "Only if:\n* `provider`== `custom-ipsec`",
							MarkdownDescription: "Only if:\n* `provider`== `custom-ipsec`",
						},
						"local_id": schema.StringAttribute{
							Optional:            true,
							Description:         "Only if:\n* `provider`== `zscaler-ipsec`\n* `provider`==`jse-ipsec`\n* `provider`== `custom-ipsec`",
							MarkdownDescription: "Only if:\n* `provider`== `zscaler-ipsec`\n* `provider`==`jse-ipsec`\n* `provider`== `custom-ipsec`",
						},
						"mode": schema.StringAttribute{
							Optional: true,
							Computed: true,
							Validators: []validator.String{
								stringvalidator.OneOf(
									"",
									"active-standby",
									"active-active",
								),
							},
							Default: stringdefault.StaticString("active-standby"),
						},
						"primary": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"hosts": schema.ListAttribute{
									ElementType: types.StringType,
									Optional:    true,
								},
								"internal_ips": schema.ListAttribute{
									ElementType:         types.StringType,
									Optional:            true,
									Description:         "Only if:\n* `provider`== `zscaler-gre` \n* `provider`== `custom-gre`",
									MarkdownDescription: "Only if:\n* `provider`== `zscaler-gre` \n* `provider`== `custom-gre`",
								},
								"probe_ips": schema.ListAttribute{
									ElementType: types.StringType,
									Optional:    true,
									Validators: []validator.List{
										listvalidator.UniqueValues(),
									},
								},
								"remote_ids": schema.ListAttribute{
									ElementType:         types.StringType,
									Optional:            true,
									Description:         "Only if:\n* `provider`== `custom-ipsec`",
									MarkdownDescription: "Only if:\n* `provider`== `custom-ipsec`",
								},
								"wan_names": schema.ListAttribute{
									ElementType: types.StringType,
									Optional:    true,
								},
							},
							CustomType: PrimaryType{
								ObjectType: types.ObjectType{
									AttrTypes: PrimaryValue{}.AttributeTypes(ctx),
								},
							},
							Optional: true,
						},
						"probe": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"interval": schema.Int64Attribute{
									Optional:            true,
									Description:         "how often to trigger the probe",
									MarkdownDescription: "how often to trigger the probe",
								},
								"threshold": schema.Int64Attribute{
									Optional:            true,
									Description:         "number of consecutive misses before declaring the tunnel down",
									MarkdownDescription: "number of consecutive misses before declaring the tunnel down",
								},
								"timeout": schema.Int64Attribute{
									Optional:            true,
									Description:         "time within which to complete the connectivity check",
									MarkdownDescription: "time within which to complete the connectivity check",
								},
								"type": schema.StringAttribute{
									Optional: true,
									Computed: true,
									Validators: []validator.String{
										stringvalidator.OneOf(
											"",
											"icmp",
											"http",
										),
									},
									Default: stringdefault.StaticString("icmp"),
								},
							},
							CustomType: ProbeType{
								ObjectType: types.ObjectType{
									AttrTypes: ProbeValue{}.AttributeTypes(ctx),
								},
							},
							Optional:            true,
							Description:         "Only if:\n* `provider`== `custom-ipsec`",
							MarkdownDescription: "Only if:\n* `provider`== `custom-ipsec`",
						},
						"protocol": schema.StringAttribute{
							Optional:            true,
							Description:         "Only if:\n* `provider`== `custom-ipsec`",
							MarkdownDescription: "Only if:\n* `provider`== `custom-ipsec`",
							Validators: []validator.String{
								stringvalidator.OneOf(
									"",
									"ipsec",
									"gre",
								),
							},
						},
						"provider": schema.StringAttribute{
							Optional: true,
							Validators: []validator.String{
								stringvalidator.OneOf(
									"",
									"zscaler-ipsec",
									"zscaler-gre",
									"customer-gre",
									"jse-ipsec",
									"custom-ipsec",
								),
							},
						},
						"psk": schema.StringAttribute{
							Optional:            true,
							Sensitive:           true,
							Description:         "Only if:\n* `provider`== `zscaler-ipsec`\n* `provider`==`jse-ipsec`\n* `provider`== `custom-ipsec`",
							MarkdownDescription: "Only if:\n* `provider`== `zscaler-ipsec`\n* `provider`==`jse-ipsec`\n* `provider`== `custom-ipsec`",
						},
						"secondary": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"hosts": schema.ListAttribute{
									ElementType: types.StringType,
									Optional:    true,
								},
								"internal_ips": schema.ListAttribute{
									ElementType:         types.StringType,
									Optional:            true,
									Description:         "Only if:\n* `provider`== `zscaler-gre` \n* `provider`== `custom-gre`",
									MarkdownDescription: "Only if:\n* `provider`== `zscaler-gre` \n* `provider`== `custom-gre`",
								},
								"probe_ips": schema.ListAttribute{
									ElementType: types.StringType,
									Optional:    true,
									Validators: []validator.List{
										listvalidator.UniqueValues(),
									},
								},
								"remote_ids": schema.ListAttribute{
									ElementType:         types.StringType,
									Optional:            true,
									Description:         "Only if:\n* `provider`== `custom-ipsec`",
									MarkdownDescription: "Only if:\n* `provider`== `custom-ipsec`",
								},
								"wan_names": schema.ListAttribute{
									ElementType: types.StringType,
									Optional:    true,
								},
							},
							CustomType: SecondaryType{
								ObjectType: types.ObjectType{
									AttrTypes: SecondaryValue{}.AttributeTypes(ctx),
								},
							},
							Optional: true,
						},
						"version": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "Only if:\n* `provider`== `custom-gre` \n* `provider`== `custom-ipsec`",
							MarkdownDescription: "Only if:\n* `provider`== `custom-gre` \n* `provider`== `custom-ipsec`",
							Validators: []validator.String{
								stringvalidator.OneOf(
									"",
									"1",
									"2",
								),
							},
							Default: stringdefault.StaticString("2"),
						},
					},
					CustomType: TunnelConfigsType{
						ObjectType: types.ObjectType{
							AttrTypes: TunnelConfigsValue{}.AttributeTypes(ctx),
						},
					},
				},
				Optional:            true,
				Description:         "Property key is the tunnel name",
				MarkdownDescription: "Property key is the tunnel name",
			},
			"tunnel_provider_options": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"jse": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"name": schema.StringAttribute{
								Optional: true,
							},
							"num_users": schema.Int64Attribute{
								Optional: true,
							},
						},
						CustomType: JseType{
							ObjectType: types.ObjectType{
								AttrTypes: JseValue{}.AttributeTypes(ctx),
							},
						},
						Optional:            true,
						Description:         "for jse-ipsec, this allow provisioning of adequate resource on JSE. Make sure adequate licenses are added",
						MarkdownDescription: "for jse-ipsec, this allow provisioning of adequate resource on JSE. Make sure adequate licenses are added",
					},
					"zscaler": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"aup_acceptance_required": schema.BoolAttribute{
								Optional: true,
								Computed: true,
								Default:  booldefault.StaticBool(true),
							},
							"aup_expire": schema.Int64Attribute{
								Optional:            true,
								Computed:            true,
								Description:         "days before AUP is requested again",
								MarkdownDescription: "days before AUP is requested again",
								Default:             int64default.StaticInt64(1),
							},
							"aup_ssl_proxy": schema.BoolAttribute{
								Optional:            true,
								Computed:            true,
								Description:         "proxy HTTPs traffic, requiring Zscaler cert to be installed in browser",
								MarkdownDescription: "proxy HTTPs traffic, requiring Zscaler cert to be installed in browser",
								Default:             booldefault.StaticBool(false),
							},
							"download_mbps": schema.Int64Attribute{
								Optional:            true,
								Description:         "the download bandwidth cap of the link, in Mbps",
								MarkdownDescription: "the download bandwidth cap of the link, in Mbps",
							},
							"enable_aup": schema.BoolAttribute{
								Optional:            true,
								Computed:            true,
								Description:         "if `use_xff`==`true`, display Acceptable Use Policy (AUP)",
								MarkdownDescription: "if `use_xff`==`true`, display Acceptable Use Policy (AUP)",
								Default:             booldefault.StaticBool(false),
							},
							"enable_caution": schema.BoolAttribute{
								Optional:            true,
								Computed:            true,
								Description:         "when `enforce_authentication`==`false`, display caution notification for non-authenticated users",
								MarkdownDescription: "when `enforce_authentication`==`false`, display caution notification for non-authenticated users",
								Default:             booldefault.StaticBool(false),
							},
							"enforce_authentication": schema.BoolAttribute{
								Optional: true,
								Computed: true,
								Default:  booldefault.StaticBool(false),
							},
							"name": schema.StringAttribute{
								Optional: true,
							},
							"sub_locations": schema.ListNestedAttribute{
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"aup_acceptance_required": schema.BoolAttribute{
											Optional: true,
											Computed: true,
											Default:  booldefault.StaticBool(true),
										},
										"aup_expire": schema.Int64Attribute{
											Optional:            true,
											Computed:            true,
											Description:         "days before AUP is requested again",
											MarkdownDescription: "days before AUP is requested again",
											Default:             int64default.StaticInt64(1),
										},
										"aup_ssl_proxy": schema.BoolAttribute{
											Optional:            true,
											Computed:            true,
											Description:         "proxy HTTPs traffic, requiring Zscaler cert to be installed in browser",
											MarkdownDescription: "proxy HTTPs traffic, requiring Zscaler cert to be installed in browser",
											Default:             booldefault.StaticBool(false),
										},
										"download_mbps": schema.Int64Attribute{
											Optional:            true,
											Description:         "the download bandwidth cap of the link, in Mbps",
											MarkdownDescription: "the download bandwidth cap of the link, in Mbps",
										},
										"enable_aup": schema.BoolAttribute{
											Optional:            true,
											Description:         "if `use_xff`==`true`, display Acceptable Use Policy (AUP)",
											MarkdownDescription: "if `use_xff`==`true`, display Acceptable Use Policy (AUP)",
										},
										"enable_caution": schema.BoolAttribute{
											Optional:            true,
											Computed:            true,
											Description:         "when `enforce_authentication`==`false`, display caution notification for non-authenticated users",
											MarkdownDescription: "when `enforce_authentication`==`false`, display caution notification for non-authenticated users",
											Default:             booldefault.StaticBool(false),
										},
										"enforce_authentication": schema.BoolAttribute{
											Optional: true,
											Computed: true,
											Default:  booldefault.StaticBool(false),
										},
										"subnets": schema.ListAttribute{
											ElementType: types.StringType,
											Optional:    true,
										},
										"upload_mbps": schema.Int64Attribute{
											Optional:            true,
											Description:         "the download bandwidth cap of the link, in Mbps",
											MarkdownDescription: "the download bandwidth cap of the link, in Mbps",
										},
									},
									CustomType: SubLocationsType{
										ObjectType: types.ObjectType{
											AttrTypes: SubLocationsValue{}.AttributeTypes(ctx),
										},
									},
								},
								Optional:            true,
								Description:         "if `use_xff`==`true`",
								MarkdownDescription: "if `use_xff`==`true`",
							},
							"upload_mbps": schema.Int64Attribute{
								Optional:            true,
								Description:         "the download bandwidth cap of the link, in Mbps",
								MarkdownDescription: "the download bandwidth cap of the link, in Mbps",
							},
							"use_xff": schema.BoolAttribute{
								Optional:            true,
								Description:         "location uses proxy chaining to forward traffic",
								MarkdownDescription: "location uses proxy chaining to forward traffic",
							},
						},
						CustomType: ZscalerType{
							ObjectType: types.ObjectType{
								AttrTypes: ZscalerValue{}.AttributeTypes(ctx),
							},
						},
						Optional:            true,
						Description:         "for zscaler-ipsec and zscaler-gre",
						MarkdownDescription: "for zscaler-ipsec and zscaler-gre",
					},
				},
				CustomType: TunnelProviderOptionsType{
					ObjectType: types.ObjectType{
						AttrTypes: TunnelProviderOptionsValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
			},
			"type": schema.StringAttribute{
				Optional: true,
				Computed: true,
				Validators: []validator.String{
					stringvalidator.OneOf(
						"",
						"standalone",
						"spoke",
					),
				},
				Default: stringdefault.StaticString("standalone"),
			},
		},
	}
}

type OrgGatewaytemplateModel struct {
	AdditionalConfigCmds  types.List                 `tfsdk:"additional_config_cmds"`
	BgpConfig             types.Map                  `tfsdk:"bgp_config"`
	DhcpdConfig           DhcpdConfigValue           `tfsdk:"dhcpd_config"`
	DnsOverride           types.Bool                 `tfsdk:"dns_override"`
	DnsServers            types.List                 `tfsdk:"dns_servers"`
	DnsSuffix             types.List                 `tfsdk:"dns_suffix"`
	ExtraRoutes           types.Map                  `tfsdk:"extra_routes"`
	Id                    types.String               `tfsdk:"id"`
	IdpProfiles           types.Map                  `tfsdk:"idp_profiles"`
	IpConfigs             types.Map                  `tfsdk:"ip_configs"`
	Name                  types.String               `tfsdk:"name"`
	Networks              types.List                 `tfsdk:"networks"`
	NtpOverride           types.Bool                 `tfsdk:"ntp_override"`
	NtpServers            types.List                 `tfsdk:"ntp_servers"`
	OobIpConfig           OobIpConfigValue           `tfsdk:"oob_ip_config"`
	OrgId                 types.String               `tfsdk:"org_id"`
	PathPreferences       types.Map                  `tfsdk:"path_preferences"`
	PortConfig            types.Map                  `tfsdk:"port_config"`
	RouterId              types.String               `tfsdk:"router_id"`
	RoutingPolicies       types.Map                  `tfsdk:"routing_policies"`
	ServicePolicies       types.List                 `tfsdk:"service_policies"`
	TunnelConfigs         types.Map                  `tfsdk:"tunnel_configs"`
	TunnelProviderOptions TunnelProviderOptionsValue `tfsdk:"tunnel_provider_options"`
	Type                  types.String               `tfsdk:"type"`
}

var _ basetypes.ObjectTypable = BgpConfigType{}

type BgpConfigType struct {
	basetypes.ObjectType
}

func (t BgpConfigType) Equal(o attr.Type) bool {
	other, ok := o.(BgpConfigType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t BgpConfigType) String() string {
	return "BgpConfigType"
}

func (t BgpConfigType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	authKeyAttribute, ok := attributes["auth_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auth_key is missing from object`)

		return nil, diags
	}

	authKeyVal, ok := authKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auth_key expected to be basetypes.StringValue, was: %T`, authKeyAttribute))
	}

	bfdMinimumIntervalAttribute, ok := attributes["bfd_minimum_interval"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bfd_minimum_interval is missing from object`)

		return nil, diags
	}

	bfdMinimumIntervalVal, ok := bfdMinimumIntervalAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bfd_minimum_interval expected to be basetypes.Int64Value, was: %T`, bfdMinimumIntervalAttribute))
	}

	bfdMultiplierAttribute, ok := attributes["bfd_multiplier"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bfd_multiplier is missing from object`)

		return nil, diags
	}

	bfdMultiplierVal, ok := bfdMultiplierAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bfd_multiplier expected to be basetypes.Int64Value, was: %T`, bfdMultiplierAttribute))
	}

	communitiesAttribute, ok := attributes["communities"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`communities is missing from object`)

		return nil, diags
	}

	communitiesVal, ok := communitiesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`communities expected to be basetypes.ListValue, was: %T`, communitiesAttribute))
	}

	disableBfdAttribute, ok := attributes["disable_bfd"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disable_bfd is missing from object`)

		return nil, diags
	}

	disableBfdVal, ok := disableBfdAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disable_bfd expected to be basetypes.BoolValue, was: %T`, disableBfdAttribute))
	}

	exportAttribute, ok := attributes["export"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`export is missing from object`)

		return nil, diags
	}

	exportVal, ok := exportAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`export expected to be basetypes.StringValue, was: %T`, exportAttribute))
	}

	exportPolicyAttribute, ok := attributes["export_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`export_policy is missing from object`)

		return nil, diags
	}

	exportPolicyVal, ok := exportPolicyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`export_policy expected to be basetypes.StringValue, was: %T`, exportPolicyAttribute))
	}

	extendedV4NexthopAttribute, ok := attributes["extended_v4_nexthop"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`extended_v4_nexthop is missing from object`)

		return nil, diags
	}

	extendedV4NexthopVal, ok := extendedV4NexthopAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`extended_v4_nexthop expected to be basetypes.BoolValue, was: %T`, extendedV4NexthopAttribute))
	}

	gracefulRestartTimeAttribute, ok := attributes["graceful_restart_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`graceful_restart_time is missing from object`)

		return nil, diags
	}

	gracefulRestartTimeVal, ok := gracefulRestartTimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`graceful_restart_time expected to be basetypes.Int64Value, was: %T`, gracefulRestartTimeAttribute))
	}

	holdTimeAttribute, ok := attributes["hold_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`hold_time is missing from object`)

		return nil, diags
	}

	holdTimeVal, ok := holdTimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`hold_time expected to be basetypes.Int64Value, was: %T`, holdTimeAttribute))
	}

	importAttribute, ok := attributes["import"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`import is missing from object`)

		return nil, diags
	}

	importVal, ok := importAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`import expected to be basetypes.StringValue, was: %T`, importAttribute))
	}

	importPolicyAttribute, ok := attributes["import_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`import_policy is missing from object`)

		return nil, diags
	}

	importPolicyVal, ok := importPolicyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`import_policy expected to be basetypes.StringValue, was: %T`, importPolicyAttribute))
	}

	localAsAttribute, ok := attributes["local_as"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`local_as is missing from object`)

		return nil, diags
	}

	localAsVal, ok := localAsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`local_as expected to be basetypes.Int64Value, was: %T`, localAsAttribute))
	}

	neighborAsAttribute, ok := attributes["neighbor_as"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`neighbor_as is missing from object`)

		return nil, diags
	}

	neighborAsVal, ok := neighborAsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`neighbor_as expected to be basetypes.Int64Value, was: %T`, neighborAsAttribute))
	}

	neighborsAttribute, ok := attributes["neighbors"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`neighbors is missing from object`)

		return nil, diags
	}

	neighborsVal, ok := neighborsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`neighbors expected to be basetypes.MapValue, was: %T`, neighborsAttribute))
	}

	networksAttribute, ok := attributes["networks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`networks is missing from object`)

		return nil, diags
	}

	networksVal, ok := networksAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`networks expected to be basetypes.ListValue, was: %T`, networksAttribute))
	}

	noReadvertiseToOverlayAttribute, ok := attributes["no_readvertise_to_overlay"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`no_readvertise_to_overlay is missing from object`)

		return nil, diags
	}

	noReadvertiseToOverlayVal, ok := noReadvertiseToOverlayAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`no_readvertise_to_overlay expected to be basetypes.BoolValue, was: %T`, noReadvertiseToOverlayAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	viaAttribute, ok := attributes["via"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`via is missing from object`)

		return nil, diags
	}

	viaVal, ok := viaAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`via expected to be basetypes.StringValue, was: %T`, viaAttribute))
	}

	vpnNameAttribute, ok := attributes["vpn_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vpn_name is missing from object`)

		return nil, diags
	}

	vpnNameVal, ok := vpnNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vpn_name expected to be basetypes.StringValue, was: %T`, vpnNameAttribute))
	}

	wanNameAttribute, ok := attributes["wan_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wan_name is missing from object`)

		return nil, diags
	}

	wanNameVal, ok := wanNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wan_name expected to be basetypes.StringValue, was: %T`, wanNameAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return BgpConfigValue{
		AuthKey:                authKeyVal,
		BfdMinimumInterval:     bfdMinimumIntervalVal,
		BfdMultiplier:          bfdMultiplierVal,
		Communities:            communitiesVal,
		DisableBfd:             disableBfdVal,
		Export:                 exportVal,
		ExportPolicy:           exportPolicyVal,
		ExtendedV4Nexthop:      extendedV4NexthopVal,
		GracefulRestartTime:    gracefulRestartTimeVal,
		HoldTime:               holdTimeVal,
		Import:                 importVal,
		ImportPolicy:           importPolicyVal,
		LocalAs:                localAsVal,
		NeighborAs:             neighborAsVal,
		Neighbors:              neighborsVal,
		Networks:               networksVal,
		NoReadvertiseToOverlay: noReadvertiseToOverlayVal,
		BgpConfigType:          typeVal,
		Via:                    viaVal,
		VpnName:                vpnNameVal,
		WanName:                wanNameVal,
		state:                  attr.ValueStateKnown,
	}, diags
}

func NewBgpConfigValueNull() BgpConfigValue {
	return BgpConfigValue{
		state: attr.ValueStateNull,
	}
}

func NewBgpConfigValueUnknown() BgpConfigValue {
	return BgpConfigValue{
		state: attr.ValueStateUnknown,
	}
}

func NewBgpConfigValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (BgpConfigValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing BgpConfigValue Attribute Value",
				"While creating a BgpConfigValue value, a missing attribute value was detected. "+
					"A BgpConfigValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("BgpConfigValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid BgpConfigValue Attribute Type",
				"While creating a BgpConfigValue value, an invalid attribute value was detected. "+
					"A BgpConfigValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("BgpConfigValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("BgpConfigValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra BgpConfigValue Attribute Value",
				"While creating a BgpConfigValue value, an extra attribute value was detected. "+
					"A BgpConfigValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra BgpConfigValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewBgpConfigValueUnknown(), diags
	}

	authKeyAttribute, ok := attributes["auth_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auth_key is missing from object`)

		return NewBgpConfigValueUnknown(), diags
	}

	authKeyVal, ok := authKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auth_key expected to be basetypes.StringValue, was: %T`, authKeyAttribute))
	}

	bfdMinimumIntervalAttribute, ok := attributes["bfd_minimum_interval"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bfd_minimum_interval is missing from object`)

		return NewBgpConfigValueUnknown(), diags
	}

	bfdMinimumIntervalVal, ok := bfdMinimumIntervalAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bfd_minimum_interval expected to be basetypes.Int64Value, was: %T`, bfdMinimumIntervalAttribute))
	}

	bfdMultiplierAttribute, ok := attributes["bfd_multiplier"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bfd_multiplier is missing from object`)

		return NewBgpConfigValueUnknown(), diags
	}

	bfdMultiplierVal, ok := bfdMultiplierAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bfd_multiplier expected to be basetypes.Int64Value, was: %T`, bfdMultiplierAttribute))
	}

	communitiesAttribute, ok := attributes["communities"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`communities is missing from object`)

		return NewBgpConfigValueUnknown(), diags
	}

	communitiesVal, ok := communitiesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`communities expected to be basetypes.ListValue, was: %T`, communitiesAttribute))
	}

	disableBfdAttribute, ok := attributes["disable_bfd"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disable_bfd is missing from object`)

		return NewBgpConfigValueUnknown(), diags
	}

	disableBfdVal, ok := disableBfdAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disable_bfd expected to be basetypes.BoolValue, was: %T`, disableBfdAttribute))
	}

	exportAttribute, ok := attributes["export"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`export is missing from object`)

		return NewBgpConfigValueUnknown(), diags
	}

	exportVal, ok := exportAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`export expected to be basetypes.StringValue, was: %T`, exportAttribute))
	}

	exportPolicyAttribute, ok := attributes["export_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`export_policy is missing from object`)

		return NewBgpConfigValueUnknown(), diags
	}

	exportPolicyVal, ok := exportPolicyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`export_policy expected to be basetypes.StringValue, was: %T`, exportPolicyAttribute))
	}

	extendedV4NexthopAttribute, ok := attributes["extended_v4_nexthop"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`extended_v4_nexthop is missing from object`)

		return NewBgpConfigValueUnknown(), diags
	}

	extendedV4NexthopVal, ok := extendedV4NexthopAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`extended_v4_nexthop expected to be basetypes.BoolValue, was: %T`, extendedV4NexthopAttribute))
	}

	gracefulRestartTimeAttribute, ok := attributes["graceful_restart_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`graceful_restart_time is missing from object`)

		return NewBgpConfigValueUnknown(), diags
	}

	gracefulRestartTimeVal, ok := gracefulRestartTimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`graceful_restart_time expected to be basetypes.Int64Value, was: %T`, gracefulRestartTimeAttribute))
	}

	holdTimeAttribute, ok := attributes["hold_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`hold_time is missing from object`)

		return NewBgpConfigValueUnknown(), diags
	}

	holdTimeVal, ok := holdTimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`hold_time expected to be basetypes.Int64Value, was: %T`, holdTimeAttribute))
	}

	importAttribute, ok := attributes["import"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`import is missing from object`)

		return NewBgpConfigValueUnknown(), diags
	}

	importVal, ok := importAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`import expected to be basetypes.StringValue, was: %T`, importAttribute))
	}

	importPolicyAttribute, ok := attributes["import_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`import_policy is missing from object`)

		return NewBgpConfigValueUnknown(), diags
	}

	importPolicyVal, ok := importPolicyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`import_policy expected to be basetypes.StringValue, was: %T`, importPolicyAttribute))
	}

	localAsAttribute, ok := attributes["local_as"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`local_as is missing from object`)

		return NewBgpConfigValueUnknown(), diags
	}

	localAsVal, ok := localAsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`local_as expected to be basetypes.Int64Value, was: %T`, localAsAttribute))
	}

	neighborAsAttribute, ok := attributes["neighbor_as"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`neighbor_as is missing from object`)

		return NewBgpConfigValueUnknown(), diags
	}

	neighborAsVal, ok := neighborAsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`neighbor_as expected to be basetypes.Int64Value, was: %T`, neighborAsAttribute))
	}

	neighborsAttribute, ok := attributes["neighbors"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`neighbors is missing from object`)

		return NewBgpConfigValueUnknown(), diags
	}

	neighborsVal, ok := neighborsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`neighbors expected to be basetypes.MapValue, was: %T`, neighborsAttribute))
	}

	networksAttribute, ok := attributes["networks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`networks is missing from object`)

		return NewBgpConfigValueUnknown(), diags
	}

	networksVal, ok := networksAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`networks expected to be basetypes.ListValue, was: %T`, networksAttribute))
	}

	noReadvertiseToOverlayAttribute, ok := attributes["no_readvertise_to_overlay"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`no_readvertise_to_overlay is missing from object`)

		return NewBgpConfigValueUnknown(), diags
	}

	noReadvertiseToOverlayVal, ok := noReadvertiseToOverlayAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`no_readvertise_to_overlay expected to be basetypes.BoolValue, was: %T`, noReadvertiseToOverlayAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewBgpConfigValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	viaAttribute, ok := attributes["via"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`via is missing from object`)

		return NewBgpConfigValueUnknown(), diags
	}

	viaVal, ok := viaAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`via expected to be basetypes.StringValue, was: %T`, viaAttribute))
	}

	vpnNameAttribute, ok := attributes["vpn_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vpn_name is missing from object`)

		return NewBgpConfigValueUnknown(), diags
	}

	vpnNameVal, ok := vpnNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vpn_name expected to be basetypes.StringValue, was: %T`, vpnNameAttribute))
	}

	wanNameAttribute, ok := attributes["wan_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wan_name is missing from object`)

		return NewBgpConfigValueUnknown(), diags
	}

	wanNameVal, ok := wanNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wan_name expected to be basetypes.StringValue, was: %T`, wanNameAttribute))
	}

	if diags.HasError() {
		return NewBgpConfigValueUnknown(), diags
	}

	return BgpConfigValue{
		AuthKey:                authKeyVal,
		BfdMinimumInterval:     bfdMinimumIntervalVal,
		BfdMultiplier:          bfdMultiplierVal,
		Communities:            communitiesVal,
		DisableBfd:             disableBfdVal,
		Export:                 exportVal,
		ExportPolicy:           exportPolicyVal,
		ExtendedV4Nexthop:      extendedV4NexthopVal,
		GracefulRestartTime:    gracefulRestartTimeVal,
		HoldTime:               holdTimeVal,
		Import:                 importVal,
		ImportPolicy:           importPolicyVal,
		LocalAs:                localAsVal,
		NeighborAs:             neighborAsVal,
		Neighbors:              neighborsVal,
		Networks:               networksVal,
		NoReadvertiseToOverlay: noReadvertiseToOverlayVal,
		BgpConfigType:          typeVal,
		Via:                    viaVal,
		VpnName:                vpnNameVal,
		WanName:                wanNameVal,
		state:                  attr.ValueStateKnown,
	}, diags
}

func NewBgpConfigValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) BgpConfigValue {
	object, diags := NewBgpConfigValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewBgpConfigValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t BgpConfigType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewBgpConfigValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewBgpConfigValueUnknown(), nil
	}

	if in.IsNull() {
		return NewBgpConfigValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewBgpConfigValueMust(BgpConfigValue{}.AttributeTypes(ctx), attributes), nil
}

func (t BgpConfigType) ValueType(ctx context.Context) attr.Value {
	return BgpConfigValue{}
}

var _ basetypes.ObjectValuable = BgpConfigValue{}

type BgpConfigValue struct {
	AuthKey                basetypes.StringValue `tfsdk:"auth_key"`
	BfdMinimumInterval     basetypes.Int64Value  `tfsdk:"bfd_minimum_interval"`
	BfdMultiplier          basetypes.Int64Value  `tfsdk:"bfd_multiplier"`
	Communities            basetypes.ListValue   `tfsdk:"communities"`
	DisableBfd             basetypes.BoolValue   `tfsdk:"disable_bfd"`
	Export                 basetypes.StringValue `tfsdk:"export"`
	ExportPolicy           basetypes.StringValue `tfsdk:"export_policy"`
	ExtendedV4Nexthop      basetypes.BoolValue   `tfsdk:"extended_v4_nexthop"`
	GracefulRestartTime    basetypes.Int64Value  `tfsdk:"graceful_restart_time"`
	HoldTime               basetypes.Int64Value  `tfsdk:"hold_time"`
	Import                 basetypes.StringValue `tfsdk:"import"`
	ImportPolicy           basetypes.StringValue `tfsdk:"import_policy"`
	LocalAs                basetypes.Int64Value  `tfsdk:"local_as"`
	NeighborAs             basetypes.Int64Value  `tfsdk:"neighbor_as"`
	Neighbors              basetypes.MapValue    `tfsdk:"neighbors"`
	Networks               basetypes.ListValue   `tfsdk:"networks"`
	NoReadvertiseToOverlay basetypes.BoolValue   `tfsdk:"no_readvertise_to_overlay"`
	BgpConfigType          basetypes.StringValue `tfsdk:"type"`
	Via                    basetypes.StringValue `tfsdk:"via"`
	VpnName                basetypes.StringValue `tfsdk:"vpn_name"`
	WanName                basetypes.StringValue `tfsdk:"wan_name"`
	state                  attr.ValueState
}

func (v BgpConfigValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 21)

	var val tftypes.Value
	var err error

	attrTypes["auth_key"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["bfd_minimum_interval"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["bfd_multiplier"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["communities"] = basetypes.ListType{
		ElemType: CommunitiesValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["disable_bfd"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["export"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["export_policy"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["extended_v4_nexthop"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["graceful_restart_time"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["hold_time"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["import"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["import_policy"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["local_as"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["neighbor_as"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["neighbors"] = basetypes.MapType{
		ElemType: NeighborsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["networks"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["no_readvertise_to_overlay"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["via"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["vpn_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["wan_name"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 21)

		val, err = v.AuthKey.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["auth_key"] = val

		val, err = v.BfdMinimumInterval.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bfd_minimum_interval"] = val

		val, err = v.BfdMultiplier.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bfd_multiplier"] = val

		val, err = v.Communities.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["communities"] = val

		val, err = v.DisableBfd.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["disable_bfd"] = val

		val, err = v.Export.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["export"] = val

		val, err = v.ExportPolicy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["export_policy"] = val

		val, err = v.ExtendedV4Nexthop.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["extended_v4_nexthop"] = val

		val, err = v.GracefulRestartTime.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["graceful_restart_time"] = val

		val, err = v.HoldTime.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["hold_time"] = val

		val, err = v.Import.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["import"] = val

		val, err = v.ImportPolicy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["import_policy"] = val

		val, err = v.LocalAs.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["local_as"] = val

		val, err = v.NeighborAs.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["neighbor_as"] = val

		val, err = v.Neighbors.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["neighbors"] = val

		val, err = v.Networks.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["networks"] = val

		val, err = v.NoReadvertiseToOverlay.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["no_readvertise_to_overlay"] = val

		val, err = v.BgpConfigType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		val, err = v.Via.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["via"] = val

		val, err = v.VpnName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vpn_name"] = val

		val, err = v.WanName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["wan_name"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v BgpConfigValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v BgpConfigValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v BgpConfigValue) String() string {
	return "BgpConfigValue"
}

func (v BgpConfigValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	communities := types.ListValueMust(
		CommunitiesType{
			basetypes.ObjectType{
				AttrTypes: CommunitiesValue{}.AttributeTypes(ctx),
			},
		},
		v.Communities.Elements(),
	)

	if v.Communities.IsNull() {
		communities = types.ListNull(
			CommunitiesType{
				basetypes.ObjectType{
					AttrTypes: CommunitiesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Communities.IsUnknown() {
		communities = types.ListUnknown(
			CommunitiesType{
				basetypes.ObjectType{
					AttrTypes: CommunitiesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	neighbors := types.MapValueMust(
		NeighborsType{
			basetypes.ObjectType{
				AttrTypes: NeighborsValue{}.AttributeTypes(ctx),
			},
		},
		v.Neighbors.Elements(),
	)

	if v.Neighbors.IsNull() {
		neighbors = types.MapNull(
			NeighborsType{
				basetypes.ObjectType{
					AttrTypes: NeighborsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Neighbors.IsUnknown() {
		neighbors = types.MapUnknown(
			NeighborsType{
				basetypes.ObjectType{
					AttrTypes: NeighborsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	networksVal, d := types.ListValue(types.StringType, v.Networks.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"auth_key":             basetypes.StringType{},
			"bfd_minimum_interval": basetypes.Int64Type{},
			"bfd_multiplier":       basetypes.Int64Type{},
			"communities": basetypes.ListType{
				ElemType: CommunitiesValue{}.Type(ctx),
			},
			"disable_bfd":           basetypes.BoolType{},
			"export":                basetypes.StringType{},
			"export_policy":         basetypes.StringType{},
			"extended_v4_nexthop":   basetypes.BoolType{},
			"graceful_restart_time": basetypes.Int64Type{},
			"hold_time":             basetypes.Int64Type{},
			"import":                basetypes.StringType{},
			"import_policy":         basetypes.StringType{},
			"local_as":              basetypes.Int64Type{},
			"neighbor_as":           basetypes.Int64Type{},
			"neighbors": basetypes.MapType{
				ElemType: NeighborsValue{}.Type(ctx),
			},
			"networks": basetypes.ListType{
				ElemType: types.StringType,
			},
			"no_readvertise_to_overlay": basetypes.BoolType{},
			"type":                      basetypes.StringType{},
			"via":                       basetypes.StringType{},
			"vpn_name":                  basetypes.StringType{},
			"wan_name":                  basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"auth_key":             basetypes.StringType{},
		"bfd_minimum_interval": basetypes.Int64Type{},
		"bfd_multiplier":       basetypes.Int64Type{},
		"communities": basetypes.ListType{
			ElemType: CommunitiesValue{}.Type(ctx),
		},
		"disable_bfd":           basetypes.BoolType{},
		"export":                basetypes.StringType{},
		"export_policy":         basetypes.StringType{},
		"extended_v4_nexthop":   basetypes.BoolType{},
		"graceful_restart_time": basetypes.Int64Type{},
		"hold_time":             basetypes.Int64Type{},
		"import":                basetypes.StringType{},
		"import_policy":         basetypes.StringType{},
		"local_as":              basetypes.Int64Type{},
		"neighbor_as":           basetypes.Int64Type{},
		"neighbors": basetypes.MapType{
			ElemType: NeighborsValue{}.Type(ctx),
		},
		"networks": basetypes.ListType{
			ElemType: types.StringType,
		},
		"no_readvertise_to_overlay": basetypes.BoolType{},
		"type":                      basetypes.StringType{},
		"via":                       basetypes.StringType{},
		"vpn_name":                  basetypes.StringType{},
		"wan_name":                  basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"auth_key":                  v.AuthKey,
			"bfd_minimum_interval":      v.BfdMinimumInterval,
			"bfd_multiplier":            v.BfdMultiplier,
			"communities":               communities,
			"disable_bfd":               v.DisableBfd,
			"export":                    v.Export,
			"export_policy":             v.ExportPolicy,
			"extended_v4_nexthop":       v.ExtendedV4Nexthop,
			"graceful_restart_time":     v.GracefulRestartTime,
			"hold_time":                 v.HoldTime,
			"import":                    v.Import,
			"import_policy":             v.ImportPolicy,
			"local_as":                  v.LocalAs,
			"neighbor_as":               v.NeighborAs,
			"neighbors":                 neighbors,
			"networks":                  networksVal,
			"no_readvertise_to_overlay": v.NoReadvertiseToOverlay,
			"type":                      v.BgpConfigType,
			"via":                       v.Via,
			"vpn_name":                  v.VpnName,
			"wan_name":                  v.WanName,
		})

	return objVal, diags
}

func (v BgpConfigValue) Equal(o attr.Value) bool {
	other, ok := o.(BgpConfigValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AuthKey.Equal(other.AuthKey) {
		return false
	}

	if !v.BfdMinimumInterval.Equal(other.BfdMinimumInterval) {
		return false
	}

	if !v.BfdMultiplier.Equal(other.BfdMultiplier) {
		return false
	}

	if !v.Communities.Equal(other.Communities) {
		return false
	}

	if !v.DisableBfd.Equal(other.DisableBfd) {
		return false
	}

	if !v.Export.Equal(other.Export) {
		return false
	}

	if !v.ExportPolicy.Equal(other.ExportPolicy) {
		return false
	}

	if !v.ExtendedV4Nexthop.Equal(other.ExtendedV4Nexthop) {
		return false
	}

	if !v.GracefulRestartTime.Equal(other.GracefulRestartTime) {
		return false
	}

	if !v.HoldTime.Equal(other.HoldTime) {
		return false
	}

	if !v.Import.Equal(other.Import) {
		return false
	}

	if !v.ImportPolicy.Equal(other.ImportPolicy) {
		return false
	}

	if !v.LocalAs.Equal(other.LocalAs) {
		return false
	}

	if !v.NeighborAs.Equal(other.NeighborAs) {
		return false
	}

	if !v.Neighbors.Equal(other.Neighbors) {
		return false
	}

	if !v.Networks.Equal(other.Networks) {
		return false
	}

	if !v.NoReadvertiseToOverlay.Equal(other.NoReadvertiseToOverlay) {
		return false
	}

	if !v.BgpConfigType.Equal(other.BgpConfigType) {
		return false
	}

	if !v.Via.Equal(other.Via) {
		return false
	}

	if !v.VpnName.Equal(other.VpnName) {
		return false
	}

	if !v.WanName.Equal(other.WanName) {
		return false
	}

	return true
}

func (v BgpConfigValue) Type(ctx context.Context) attr.Type {
	return BgpConfigType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v BgpConfigValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"auth_key":             basetypes.StringType{},
		"bfd_minimum_interval": basetypes.Int64Type{},
		"bfd_multiplier":       basetypes.Int64Type{},
		"communities": basetypes.ListType{
			ElemType: CommunitiesValue{}.Type(ctx),
		},
		"disable_bfd":           basetypes.BoolType{},
		"export":                basetypes.StringType{},
		"export_policy":         basetypes.StringType{},
		"extended_v4_nexthop":   basetypes.BoolType{},
		"graceful_restart_time": basetypes.Int64Type{},
		"hold_time":             basetypes.Int64Type{},
		"import":                basetypes.StringType{},
		"import_policy":         basetypes.StringType{},
		"local_as":              basetypes.Int64Type{},
		"neighbor_as":           basetypes.Int64Type{},
		"neighbors": basetypes.MapType{
			ElemType: NeighborsValue{}.Type(ctx),
		},
		"networks": basetypes.ListType{
			ElemType: types.StringType,
		},
		"no_readvertise_to_overlay": basetypes.BoolType{},
		"type":                      basetypes.StringType{},
		"via":                       basetypes.StringType{},
		"vpn_name":                  basetypes.StringType{},
		"wan_name":                  basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = CommunitiesType{}

type CommunitiesType struct {
	basetypes.ObjectType
}

func (t CommunitiesType) Equal(o attr.Type) bool {
	other, ok := o.(CommunitiesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t CommunitiesType) String() string {
	return "CommunitiesType"
}

func (t CommunitiesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	localPreferenceAttribute, ok := attributes["local_preference"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`local_preference is missing from object`)

		return nil, diags
	}

	localPreferenceVal, ok := localPreferenceAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`local_preference expected to be basetypes.Int64Value, was: %T`, localPreferenceAttribute))
	}

	vpnNameAttribute, ok := attributes["vpn_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vpn_name is missing from object`)

		return nil, diags
	}

	vpnNameVal, ok := vpnNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vpn_name expected to be basetypes.StringValue, was: %T`, vpnNameAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return CommunitiesValue{
		Id:              idVal,
		LocalPreference: localPreferenceVal,
		VpnName:         vpnNameVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewCommunitiesValueNull() CommunitiesValue {
	return CommunitiesValue{
		state: attr.ValueStateNull,
	}
}

func NewCommunitiesValueUnknown() CommunitiesValue {
	return CommunitiesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewCommunitiesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (CommunitiesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing CommunitiesValue Attribute Value",
				"While creating a CommunitiesValue value, a missing attribute value was detected. "+
					"A CommunitiesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CommunitiesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid CommunitiesValue Attribute Type",
				"While creating a CommunitiesValue value, an invalid attribute value was detected. "+
					"A CommunitiesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CommunitiesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("CommunitiesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra CommunitiesValue Attribute Value",
				"While creating a CommunitiesValue value, an extra attribute value was detected. "+
					"A CommunitiesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra CommunitiesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewCommunitiesValueUnknown(), diags
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewCommunitiesValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	localPreferenceAttribute, ok := attributes["local_preference"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`local_preference is missing from object`)

		return NewCommunitiesValueUnknown(), diags
	}

	localPreferenceVal, ok := localPreferenceAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`local_preference expected to be basetypes.Int64Value, was: %T`, localPreferenceAttribute))
	}

	vpnNameAttribute, ok := attributes["vpn_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vpn_name is missing from object`)

		return NewCommunitiesValueUnknown(), diags
	}

	vpnNameVal, ok := vpnNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vpn_name expected to be basetypes.StringValue, was: %T`, vpnNameAttribute))
	}

	if diags.HasError() {
		return NewCommunitiesValueUnknown(), diags
	}

	return CommunitiesValue{
		Id:              idVal,
		LocalPreference: localPreferenceVal,
		VpnName:         vpnNameVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewCommunitiesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) CommunitiesValue {
	object, diags := NewCommunitiesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewCommunitiesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t CommunitiesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewCommunitiesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewCommunitiesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewCommunitiesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewCommunitiesValueMust(CommunitiesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t CommunitiesType) ValueType(ctx context.Context) attr.Value {
	return CommunitiesValue{}
}

var _ basetypes.ObjectValuable = CommunitiesValue{}

type CommunitiesValue struct {
	Id              basetypes.StringValue `tfsdk:"id"`
	LocalPreference basetypes.Int64Value  `tfsdk:"local_preference"`
	VpnName         basetypes.StringValue `tfsdk:"vpn_name"`
	state           attr.ValueState
}

func (v CommunitiesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["local_preference"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["vpn_name"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.LocalPreference.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["local_preference"] = val

		val, err = v.VpnName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vpn_name"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v CommunitiesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v CommunitiesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v CommunitiesValue) String() string {
	return "CommunitiesValue"
}

func (v CommunitiesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"id":               basetypes.StringType{},
		"local_preference": basetypes.Int64Type{},
		"vpn_name":         basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"id":               v.Id,
			"local_preference": v.LocalPreference,
			"vpn_name":         v.VpnName,
		})

	return objVal, diags
}

func (v CommunitiesValue) Equal(o attr.Value) bool {
	other, ok := o.(CommunitiesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.LocalPreference.Equal(other.LocalPreference) {
		return false
	}

	if !v.VpnName.Equal(other.VpnName) {
		return false
	}

	return true
}

func (v CommunitiesValue) Type(ctx context.Context) attr.Type {
	return CommunitiesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v CommunitiesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"id":               basetypes.StringType{},
		"local_preference": basetypes.Int64Type{},
		"vpn_name":         basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = NeighborsType{}

type NeighborsType struct {
	basetypes.ObjectType
}

func (t NeighborsType) Equal(o attr.Type) bool {
	other, ok := o.(NeighborsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t NeighborsType) String() string {
	return "NeighborsType"
}

func (t NeighborsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	disabledAttribute, ok := attributes["disabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disabled is missing from object`)

		return nil, diags
	}

	disabledVal, ok := disabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disabled expected to be basetypes.BoolValue, was: %T`, disabledAttribute))
	}

	exportPolicyAttribute, ok := attributes["export_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`export_policy is missing from object`)

		return nil, diags
	}

	exportPolicyVal, ok := exportPolicyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`export_policy expected to be basetypes.StringValue, was: %T`, exportPolicyAttribute))
	}

	holdTimeAttribute, ok := attributes["hold_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`hold_time is missing from object`)

		return nil, diags
	}

	holdTimeVal, ok := holdTimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`hold_time expected to be basetypes.Int64Value, was: %T`, holdTimeAttribute))
	}

	importPolicyAttribute, ok := attributes["import_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`import_policy is missing from object`)

		return nil, diags
	}

	importPolicyVal, ok := importPolicyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`import_policy expected to be basetypes.StringValue, was: %T`, importPolicyAttribute))
	}

	multihopTtlAttribute, ok := attributes["multihop_ttl"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`multihop_ttl is missing from object`)

		return nil, diags
	}

	multihopTtlVal, ok := multihopTtlAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`multihop_ttl expected to be basetypes.Int64Value, was: %T`, multihopTtlAttribute))
	}

	neighborAsAttribute, ok := attributes["neighbor_as"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`neighbor_as is missing from object`)

		return nil, diags
	}

	neighborAsVal, ok := neighborAsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`neighbor_as expected to be basetypes.Int64Value, was: %T`, neighborAsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return NeighborsValue{
		Disabled:     disabledVal,
		ExportPolicy: exportPolicyVal,
		HoldTime:     holdTimeVal,
		ImportPolicy: importPolicyVal,
		MultihopTtl:  multihopTtlVal,
		NeighborAs:   neighborAsVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewNeighborsValueNull() NeighborsValue {
	return NeighborsValue{
		state: attr.ValueStateNull,
	}
}

func NewNeighborsValueUnknown() NeighborsValue {
	return NeighborsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewNeighborsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (NeighborsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing NeighborsValue Attribute Value",
				"While creating a NeighborsValue value, a missing attribute value was detected. "+
					"A NeighborsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NeighborsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid NeighborsValue Attribute Type",
				"While creating a NeighborsValue value, an invalid attribute value was detected. "+
					"A NeighborsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NeighborsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("NeighborsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra NeighborsValue Attribute Value",
				"While creating a NeighborsValue value, an extra attribute value was detected. "+
					"A NeighborsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra NeighborsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewNeighborsValueUnknown(), diags
	}

	disabledAttribute, ok := attributes["disabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disabled is missing from object`)

		return NewNeighborsValueUnknown(), diags
	}

	disabledVal, ok := disabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disabled expected to be basetypes.BoolValue, was: %T`, disabledAttribute))
	}

	exportPolicyAttribute, ok := attributes["export_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`export_policy is missing from object`)

		return NewNeighborsValueUnknown(), diags
	}

	exportPolicyVal, ok := exportPolicyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`export_policy expected to be basetypes.StringValue, was: %T`, exportPolicyAttribute))
	}

	holdTimeAttribute, ok := attributes["hold_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`hold_time is missing from object`)

		return NewNeighborsValueUnknown(), diags
	}

	holdTimeVal, ok := holdTimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`hold_time expected to be basetypes.Int64Value, was: %T`, holdTimeAttribute))
	}

	importPolicyAttribute, ok := attributes["import_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`import_policy is missing from object`)

		return NewNeighborsValueUnknown(), diags
	}

	importPolicyVal, ok := importPolicyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`import_policy expected to be basetypes.StringValue, was: %T`, importPolicyAttribute))
	}

	multihopTtlAttribute, ok := attributes["multihop_ttl"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`multihop_ttl is missing from object`)

		return NewNeighborsValueUnknown(), diags
	}

	multihopTtlVal, ok := multihopTtlAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`multihop_ttl expected to be basetypes.Int64Value, was: %T`, multihopTtlAttribute))
	}

	neighborAsAttribute, ok := attributes["neighbor_as"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`neighbor_as is missing from object`)

		return NewNeighborsValueUnknown(), diags
	}

	neighborAsVal, ok := neighborAsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`neighbor_as expected to be basetypes.Int64Value, was: %T`, neighborAsAttribute))
	}

	if diags.HasError() {
		return NewNeighborsValueUnknown(), diags
	}

	return NeighborsValue{
		Disabled:     disabledVal,
		ExportPolicy: exportPolicyVal,
		HoldTime:     holdTimeVal,
		ImportPolicy: importPolicyVal,
		MultihopTtl:  multihopTtlVal,
		NeighborAs:   neighborAsVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewNeighborsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) NeighborsValue {
	object, diags := NewNeighborsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewNeighborsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t NeighborsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewNeighborsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewNeighborsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewNeighborsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewNeighborsValueMust(NeighborsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t NeighborsType) ValueType(ctx context.Context) attr.Value {
	return NeighborsValue{}
}

var _ basetypes.ObjectValuable = NeighborsValue{}

type NeighborsValue struct {
	Disabled     basetypes.BoolValue   `tfsdk:"disabled"`
	ExportPolicy basetypes.StringValue `tfsdk:"export_policy"`
	HoldTime     basetypes.Int64Value  `tfsdk:"hold_time"`
	ImportPolicy basetypes.StringValue `tfsdk:"import_policy"`
	MultihopTtl  basetypes.Int64Value  `tfsdk:"multihop_ttl"`
	NeighborAs   basetypes.Int64Value  `tfsdk:"neighbor_as"`
	state        attr.ValueState
}

func (v NeighborsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 6)

	var val tftypes.Value
	var err error

	attrTypes["disabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["export_policy"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["hold_time"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["import_policy"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["multihop_ttl"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["neighbor_as"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 6)

		val, err = v.Disabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["disabled"] = val

		val, err = v.ExportPolicy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["export_policy"] = val

		val, err = v.HoldTime.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["hold_time"] = val

		val, err = v.ImportPolicy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["import_policy"] = val

		val, err = v.MultihopTtl.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["multihop_ttl"] = val

		val, err = v.NeighborAs.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["neighbor_as"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v NeighborsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v NeighborsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v NeighborsValue) String() string {
	return "NeighborsValue"
}

func (v NeighborsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"disabled":      basetypes.BoolType{},
		"export_policy": basetypes.StringType{},
		"hold_time":     basetypes.Int64Type{},
		"import_policy": basetypes.StringType{},
		"multihop_ttl":  basetypes.Int64Type{},
		"neighbor_as":   basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"disabled":      v.Disabled,
			"export_policy": v.ExportPolicy,
			"hold_time":     v.HoldTime,
			"import_policy": v.ImportPolicy,
			"multihop_ttl":  v.MultihopTtl,
			"neighbor_as":   v.NeighborAs,
		})

	return objVal, diags
}

func (v NeighborsValue) Equal(o attr.Value) bool {
	other, ok := o.(NeighborsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Disabled.Equal(other.Disabled) {
		return false
	}

	if !v.ExportPolicy.Equal(other.ExportPolicy) {
		return false
	}

	if !v.HoldTime.Equal(other.HoldTime) {
		return false
	}

	if !v.ImportPolicy.Equal(other.ImportPolicy) {
		return false
	}

	if !v.MultihopTtl.Equal(other.MultihopTtl) {
		return false
	}

	if !v.NeighborAs.Equal(other.NeighborAs) {
		return false
	}

	return true
}

func (v NeighborsValue) Type(ctx context.Context) attr.Type {
	return NeighborsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v NeighborsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"disabled":      basetypes.BoolType{},
		"export_policy": basetypes.StringType{},
		"hold_time":     basetypes.Int64Type{},
		"import_policy": basetypes.StringType{},
		"multihop_ttl":  basetypes.Int64Type{},
		"neighbor_as":   basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = DhcpdConfigType{}

type DhcpdConfigType struct {
	basetypes.ObjectType
}

func (t DhcpdConfigType) Equal(o attr.Type) bool {
	other, ok := o.(DhcpdConfigType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t DhcpdConfigType) String() string {
	return "DhcpdConfigType"
}

func (t DhcpdConfigType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	configAttribute, ok := attributes["config"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`config is missing from object`)

		return nil, diags
	}

	configVal, ok := configAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`config expected to be basetypes.MapValue, was: %T`, configAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return DhcpdConfigValue{
		Config:  configVal,
		Enabled: enabledVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewDhcpdConfigValueNull() DhcpdConfigValue {
	return DhcpdConfigValue{
		state: attr.ValueStateNull,
	}
}

func NewDhcpdConfigValueUnknown() DhcpdConfigValue {
	return DhcpdConfigValue{
		state: attr.ValueStateUnknown,
	}
}

func NewDhcpdConfigValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (DhcpdConfigValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing DhcpdConfigValue Attribute Value",
				"While creating a DhcpdConfigValue value, a missing attribute value was detected. "+
					"A DhcpdConfigValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DhcpdConfigValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid DhcpdConfigValue Attribute Type",
				"While creating a DhcpdConfigValue value, an invalid attribute value was detected. "+
					"A DhcpdConfigValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DhcpdConfigValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("DhcpdConfigValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra DhcpdConfigValue Attribute Value",
				"While creating a DhcpdConfigValue value, an extra attribute value was detected. "+
					"A DhcpdConfigValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra DhcpdConfigValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewDhcpdConfigValueUnknown(), diags
	}

	configAttribute, ok := attributes["config"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`config is missing from object`)

		return NewDhcpdConfigValueUnknown(), diags
	}

	configVal, ok := configAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`config expected to be basetypes.MapValue, was: %T`, configAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewDhcpdConfigValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	if diags.HasError() {
		return NewDhcpdConfigValueUnknown(), diags
	}

	return DhcpdConfigValue{
		Config:  configVal,
		Enabled: enabledVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewDhcpdConfigValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) DhcpdConfigValue {
	object, diags := NewDhcpdConfigValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewDhcpdConfigValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t DhcpdConfigType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewDhcpdConfigValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewDhcpdConfigValueUnknown(), nil
	}

	if in.IsNull() {
		return NewDhcpdConfigValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewDhcpdConfigValueMust(DhcpdConfigValue{}.AttributeTypes(ctx), attributes), nil
}

func (t DhcpdConfigType) ValueType(ctx context.Context) attr.Value {
	return DhcpdConfigValue{}
}

var _ basetypes.ObjectValuable = DhcpdConfigValue{}

type DhcpdConfigValue struct {
	Config  basetypes.MapValue  `tfsdk:"config"`
	Enabled basetypes.BoolValue `tfsdk:"enabled"`
	state   attr.ValueState
}

func (v DhcpdConfigValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["config"] = basetypes.MapType{
		ElemType: ConfigValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Config.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["config"] = val

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v DhcpdConfigValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v DhcpdConfigValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v DhcpdConfigValue) String() string {
	return "DhcpdConfigValue"
}

func (v DhcpdConfigValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	config := types.MapValueMust(
		ConfigType{
			basetypes.ObjectType{
				AttrTypes: ConfigValue{}.AttributeTypes(ctx),
			},
		},
		v.Config.Elements(),
	)

	if v.Config.IsNull() {
		config = types.MapNull(
			ConfigType{
				basetypes.ObjectType{
					AttrTypes: ConfigValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Config.IsUnknown() {
		config = types.MapUnknown(
			ConfigType{
				basetypes.ObjectType{
					AttrTypes: ConfigValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"config": basetypes.MapType{
			ElemType: ConfigValue{}.Type(ctx),
		},
		"enabled": basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"config":  config,
			"enabled": v.Enabled,
		})

	return objVal, diags
}

func (v DhcpdConfigValue) Equal(o attr.Value) bool {
	other, ok := o.(DhcpdConfigValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Config.Equal(other.Config) {
		return false
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	return true
}

func (v DhcpdConfigValue) Type(ctx context.Context) attr.Type {
	return DhcpdConfigType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v DhcpdConfigValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"config": basetypes.MapType{
			ElemType: ConfigValue{}.Type(ctx),
		},
		"enabled": basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = ConfigType{}

type ConfigType struct {
	basetypes.ObjectType
}

func (t ConfigType) Equal(o attr.Type) bool {
	other, ok := o.(ConfigType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ConfigType) String() string {
	return "ConfigType"
}

func (t ConfigType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	dnsServersAttribute, ok := attributes["dns_servers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dns_servers is missing from object`)

		return nil, diags
	}

	dnsServersVal, ok := dnsServersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dns_servers expected to be basetypes.ListValue, was: %T`, dnsServersAttribute))
	}

	dnsSuffixAttribute, ok := attributes["dns_suffix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dns_suffix is missing from object`)

		return nil, diags
	}

	dnsSuffixVal, ok := dnsSuffixAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dns_suffix expected to be basetypes.ListValue, was: %T`, dnsSuffixAttribute))
	}

	fixedBindingsAttribute, ok := attributes["fixed_bindings"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fixed_bindings is missing from object`)

		return nil, diags
	}

	fixedBindingsVal, ok := fixedBindingsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fixed_bindings expected to be basetypes.MapValue, was: %T`, fixedBindingsAttribute))
	}

	gatewayAttribute, ok := attributes["gateway"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gateway is missing from object`)

		return nil, diags
	}

	gatewayVal, ok := gatewayAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gateway expected to be basetypes.StringValue, was: %T`, gatewayAttribute))
	}

	ipEnd4Attribute, ok := attributes["ip_end"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_end is missing from object`)

		return nil, diags
	}

	ipEnd4Val, ok := ipEnd4Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_end expected to be basetypes.StringValue, was: %T`, ipEnd4Attribute))
	}

	ipEnd6Attribute, ok := attributes["ip_end6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_end6 is missing from object`)

		return nil, diags
	}

	ipEnd6Val, ok := ipEnd6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_end6 expected to be basetypes.StringValue, was: %T`, ipEnd6Attribute))
	}

	ipStart4Attribute, ok := attributes["ip_start"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_start is missing from object`)

		return nil, diags
	}

	ipStart4Val, ok := ipStart4Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_start expected to be basetypes.StringValue, was: %T`, ipStart4Attribute))
	}

	ipStart6Attribute, ok := attributes["ip_start6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_start6 is missing from object`)

		return nil, diags
	}

	ipStart6Val, ok := ipStart6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_start6 expected to be basetypes.StringValue, was: %T`, ipStart6Attribute))
	}

	leaseTimeAttribute, ok := attributes["lease_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lease_time is missing from object`)

		return nil, diags
	}

	leaseTimeVal, ok := leaseTimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lease_time expected to be basetypes.Int64Value, was: %T`, leaseTimeAttribute))
	}

	optionsAttribute, ok := attributes["options"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`options is missing from object`)

		return nil, diags
	}

	optionsVal, ok := optionsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`options expected to be basetypes.MapValue, was: %T`, optionsAttribute))
	}

	serverIdOverrideAttribute, ok := attributes["server_id_override"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`server_id_override is missing from object`)

		return nil, diags
	}

	serverIdOverrideVal, ok := serverIdOverrideAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`server_id_override expected to be basetypes.BoolValue, was: %T`, serverIdOverrideAttribute))
	}

	serversAttribute, ok := attributes["servers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`servers is missing from object`)

		return nil, diags
	}

	serversVal, ok := serversAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`servers expected to be basetypes.ListValue, was: %T`, serversAttribute))
	}

	servers6Attribute, ok := attributes["servers6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`servers6 is missing from object`)

		return nil, diags
	}

	servers6Val, ok := servers6Attribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`servers6 expected to be basetypes.ListValue, was: %T`, servers6Attribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	type6Attribute, ok := attributes["type6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type6 is missing from object`)

		return nil, diags
	}

	type6Val, ok := type6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type6 expected to be basetypes.StringValue, was: %T`, type6Attribute))
	}

	vendorEncapulatedAttribute, ok := attributes["vendor_encapulated"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vendor_encapulated is missing from object`)

		return nil, diags
	}

	vendorEncapulatedVal, ok := vendorEncapulatedAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vendor_encapulated expected to be basetypes.MapValue, was: %T`, vendorEncapulatedAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ConfigValue{
		DnsServers:        dnsServersVal,
		DnsSuffix:         dnsSuffixVal,
		FixedBindings:     fixedBindingsVal,
		Gateway:           gatewayVal,
		IpEnd4:            ipEnd4Val,
		IpEnd6:            ipEnd6Val,
		IpStart4:          ipStart4Val,
		IpStart6:          ipStart6Val,
		LeaseTime:         leaseTimeVal,
		Options:           optionsVal,
		ServerIdOverride:  serverIdOverrideVal,
		Servers4:          serversVal,
		Servers6:          servers6Val,
		Type4:             typeVal,
		Type6:             type6Val,
		VendorEncapulated: vendorEncapulatedVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewConfigValueNull() ConfigValue {
	return ConfigValue{
		state: attr.ValueStateNull,
	}
}

func NewConfigValueUnknown() ConfigValue {
	return ConfigValue{
		state: attr.ValueStateUnknown,
	}
}

func NewConfigValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ConfigValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ConfigValue Attribute Value",
				"While creating a ConfigValue value, a missing attribute value was detected. "+
					"A ConfigValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ConfigValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ConfigValue Attribute Type",
				"While creating a ConfigValue value, an invalid attribute value was detected. "+
					"A ConfigValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ConfigValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ConfigValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ConfigValue Attribute Value",
				"While creating a ConfigValue value, an extra attribute value was detected. "+
					"A ConfigValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ConfigValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewConfigValueUnknown(), diags
	}

	dnsServersAttribute, ok := attributes["dns_servers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dns_servers is missing from object`)

		return NewConfigValueUnknown(), diags
	}

	dnsServersVal, ok := dnsServersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dns_servers expected to be basetypes.ListValue, was: %T`, dnsServersAttribute))
	}

	dnsSuffixAttribute, ok := attributes["dns_suffix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dns_suffix is missing from object`)

		return NewConfigValueUnknown(), diags
	}

	dnsSuffixVal, ok := dnsSuffixAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dns_suffix expected to be basetypes.ListValue, was: %T`, dnsSuffixAttribute))
	}

	fixedBindingsAttribute, ok := attributes["fixed_bindings"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fixed_bindings is missing from object`)

		return NewConfigValueUnknown(), diags
	}

	fixedBindingsVal, ok := fixedBindingsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fixed_bindings expected to be basetypes.MapValue, was: %T`, fixedBindingsAttribute))
	}

	gatewayAttribute, ok := attributes["gateway"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gateway is missing from object`)

		return NewConfigValueUnknown(), diags
	}

	gatewayVal, ok := gatewayAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gateway expected to be basetypes.StringValue, was: %T`, gatewayAttribute))
	}

	ipEnd4Attribute, ok := attributes["ip_end"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_end is missing from object`)

		return NewConfigValueUnknown(), diags
	}

	ipEnd4Val, ok := ipEnd4Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_end expected to be basetypes.StringValue, was: %T`, ipEnd4Attribute))
	}

	ipEnd6Attribute, ok := attributes["ip_end6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_end6 is missing from object`)

		return NewConfigValueUnknown(), diags
	}

	ipEnd6Val, ok := ipEnd6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_end6 expected to be basetypes.StringValue, was: %T`, ipEnd6Attribute))
	}

	ipStart4Attribute, ok := attributes["ip_start"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_start is missing from object`)

		return NewConfigValueUnknown(), diags
	}

	ipStart4Val, ok := ipStart4Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_start expected to be basetypes.StringValue, was: %T`, ipStart4Attribute))
	}

	ipStart6Attribute, ok := attributes["ip_start6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_start6 is missing from object`)

		return NewConfigValueUnknown(), diags
	}

	ipStart6Val, ok := ipStart6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_start6 expected to be basetypes.StringValue, was: %T`, ipStart6Attribute))
	}

	leaseTimeAttribute, ok := attributes["lease_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lease_time is missing from object`)

		return NewConfigValueUnknown(), diags
	}

	leaseTimeVal, ok := leaseTimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lease_time expected to be basetypes.Int64Value, was: %T`, leaseTimeAttribute))
	}

	optionsAttribute, ok := attributes["options"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`options is missing from object`)

		return NewConfigValueUnknown(), diags
	}

	optionsVal, ok := optionsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`options expected to be basetypes.MapValue, was: %T`, optionsAttribute))
	}

	serverIdOverrideAttribute, ok := attributes["server_id_override"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`server_id_override is missing from object`)

		return NewConfigValueUnknown(), diags
	}

	serverIdOverrideVal, ok := serverIdOverrideAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`server_id_override expected to be basetypes.BoolValue, was: %T`, serverIdOverrideAttribute))
	}

	serversAttribute, ok := attributes["servers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`servers is missing from object`)

		return NewConfigValueUnknown(), diags
	}

	serversVal, ok := serversAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`servers expected to be basetypes.ListValue, was: %T`, serversAttribute))
	}

	servers6Attribute, ok := attributes["servers6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`servers6 is missing from object`)

		return NewConfigValueUnknown(), diags
	}

	servers6Val, ok := servers6Attribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`servers6 expected to be basetypes.ListValue, was: %T`, servers6Attribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewConfigValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	type6Attribute, ok := attributes["type6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type6 is missing from object`)

		return NewConfigValueUnknown(), diags
	}

	type6Val, ok := type6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type6 expected to be basetypes.StringValue, was: %T`, type6Attribute))
	}

	vendorEncapulatedAttribute, ok := attributes["vendor_encapulated"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vendor_encapulated is missing from object`)

		return NewConfigValueUnknown(), diags
	}

	vendorEncapulatedVal, ok := vendorEncapulatedAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vendor_encapulated expected to be basetypes.MapValue, was: %T`, vendorEncapulatedAttribute))
	}

	if diags.HasError() {
		return NewConfigValueUnknown(), diags
	}

	return ConfigValue{
		DnsServers:        dnsServersVal,
		DnsSuffix:         dnsSuffixVal,
		FixedBindings:     fixedBindingsVal,
		Gateway:           gatewayVal,
		IpEnd4:            ipEnd4Val,
		IpEnd6:            ipEnd6Val,
		IpStart4:          ipStart4Val,
		IpStart6:          ipStart6Val,
		LeaseTime:         leaseTimeVal,
		Options:           optionsVal,
		ServerIdOverride:  serverIdOverrideVal,
		Servers4:          serversVal,
		Servers6:          servers6Val,
		Type4:             typeVal,
		Type6:             type6Val,
		VendorEncapulated: vendorEncapulatedVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewConfigValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ConfigValue {
	object, diags := NewConfigValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewConfigValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ConfigType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewConfigValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewConfigValueUnknown(), nil
	}

	if in.IsNull() {
		return NewConfigValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewConfigValueMust(ConfigValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ConfigType) ValueType(ctx context.Context) attr.Value {
	return ConfigValue{}
}

var _ basetypes.ObjectValuable = ConfigValue{}

type ConfigValue struct {
	DnsServers        basetypes.ListValue   `tfsdk:"dns_servers"`
	DnsSuffix         basetypes.ListValue   `tfsdk:"dns_suffix"`
	FixedBindings     basetypes.MapValue    `tfsdk:"fixed_bindings"`
	Gateway           basetypes.StringValue `tfsdk:"gateway"`
	IpEnd4            basetypes.StringValue `tfsdk:"ip_end"`
	IpEnd6            basetypes.StringValue `tfsdk:"ip_end6"`
	IpStart4          basetypes.StringValue `tfsdk:"ip_start"`
	IpStart6          basetypes.StringValue `tfsdk:"ip_start6"`
	LeaseTime         basetypes.Int64Value  `tfsdk:"lease_time"`
	Options           basetypes.MapValue    `tfsdk:"options"`
	ServerIdOverride  basetypes.BoolValue   `tfsdk:"server_id_override"`
	Servers4          basetypes.ListValue   `tfsdk:"servers"`
	Servers6          basetypes.ListValue   `tfsdk:"servers6"`
	Type4             basetypes.StringValue `tfsdk:"type"`
	Type6             basetypes.StringValue `tfsdk:"type6"`
	VendorEncapulated basetypes.MapValue    `tfsdk:"vendor_encapulated"`
	state             attr.ValueState
}

func (v ConfigValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 16)

	var val tftypes.Value
	var err error

	attrTypes["dns_servers"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["dns_suffix"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["fixed_bindings"] = basetypes.MapType{
		ElemType: FixedBindingsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["gateway"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ip_end"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ip_end6"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ip_start"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ip_start6"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["lease_time"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["options"] = basetypes.MapType{
		ElemType: OptionsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["server_id_override"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["servers"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["servers6"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["type6"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["vendor_encapulated"] = basetypes.MapType{
		ElemType: VendorEncapulatedValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 16)

		val, err = v.DnsServers.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dns_servers"] = val

		val, err = v.DnsSuffix.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dns_suffix"] = val

		val, err = v.FixedBindings.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["fixed_bindings"] = val

		val, err = v.Gateway.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["gateway"] = val

		val, err = v.IpEnd4.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip_end"] = val

		val, err = v.IpEnd6.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip_end6"] = val

		val, err = v.IpStart4.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip_start"] = val

		val, err = v.IpStart6.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip_start6"] = val

		val, err = v.LeaseTime.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["lease_time"] = val

		val, err = v.Options.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["options"] = val

		val, err = v.ServerIdOverride.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["server_id_override"] = val

		val, err = v.Servers4.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["servers"] = val

		val, err = v.Servers6.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["servers6"] = val

		val, err = v.Type4.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		val, err = v.Type6.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type6"] = val

		val, err = v.VendorEncapulated.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vendor_encapulated"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ConfigValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ConfigValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ConfigValue) String() string {
	return "ConfigValue"
}

func (v ConfigValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	fixedBindings := types.MapValueMust(
		FixedBindingsType{
			basetypes.ObjectType{
				AttrTypes: FixedBindingsValue{}.AttributeTypes(ctx),
			},
		},
		v.FixedBindings.Elements(),
	)

	if v.FixedBindings.IsNull() {
		fixedBindings = types.MapNull(
			FixedBindingsType{
				basetypes.ObjectType{
					AttrTypes: FixedBindingsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.FixedBindings.IsUnknown() {
		fixedBindings = types.MapUnknown(
			FixedBindingsType{
				basetypes.ObjectType{
					AttrTypes: FixedBindingsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	options := types.MapValueMust(
		OptionsType{
			basetypes.ObjectType{
				AttrTypes: OptionsValue{}.AttributeTypes(ctx),
			},
		},
		v.Options.Elements(),
	)

	if v.Options.IsNull() {
		options = types.MapNull(
			OptionsType{
				basetypes.ObjectType{
					AttrTypes: OptionsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Options.IsUnknown() {
		options = types.MapUnknown(
			OptionsType{
				basetypes.ObjectType{
					AttrTypes: OptionsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	vendorEncapulated := types.MapValueMust(
		VendorEncapulatedType{
			basetypes.ObjectType{
				AttrTypes: VendorEncapulatedValue{}.AttributeTypes(ctx),
			},
		},
		v.VendorEncapulated.Elements(),
	)

	if v.VendorEncapulated.IsNull() {
		vendorEncapulated = types.MapNull(
			VendorEncapulatedType{
				basetypes.ObjectType{
					AttrTypes: VendorEncapulatedValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.VendorEncapulated.IsUnknown() {
		vendorEncapulated = types.MapUnknown(
			VendorEncapulatedType{
				basetypes.ObjectType{
					AttrTypes: VendorEncapulatedValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	dnsServersVal, d := types.ListValue(types.StringType, v.DnsServers.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"dns_servers": basetypes.ListType{
				ElemType: types.StringType,
			},
			"dns_suffix": basetypes.ListType{
				ElemType: types.StringType,
			},
			"fixed_bindings": basetypes.MapType{
				ElemType: FixedBindingsValue{}.Type(ctx),
			},
			"gateway":    basetypes.StringType{},
			"ip_end":    basetypes.StringType{},
			"ip_end6":    basetypes.StringType{},
			"ip_start":  basetypes.StringType{},
			"ip_start6":  basetypes.StringType{},
			"lease_time": basetypes.Int64Type{},
			"options": basetypes.MapType{
				ElemType: OptionsValue{}.Type(ctx),
			},
			"server_id_override": basetypes.BoolType{},
			"servers": basetypes.ListType{
				ElemType: types.StringType,
			},
			"servers6": basetypes.ListType{
				ElemType: types.StringType,
			},
			"type": basetypes.StringType{},
			"type6": basetypes.StringType{},
			"vendor_encapulated": basetypes.MapType{
				ElemType: VendorEncapulatedValue{}.Type(ctx),
			},
		}), diags
	}

	dnsSuffixVal, d := types.ListValue(types.StringType, v.DnsSuffix.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"dns_servers": basetypes.ListType{
				ElemType: types.StringType,
			},
			"dns_suffix": basetypes.ListType{
				ElemType: types.StringType,
			},
			"fixed_bindings": basetypes.MapType{
				ElemType: FixedBindingsValue{}.Type(ctx),
			},
			"gateway":    basetypes.StringType{},
			"ip_end":    basetypes.StringType{},
			"ip_end6":    basetypes.StringType{},
			"ip_start":  basetypes.StringType{},
			"ip_start6":  basetypes.StringType{},
			"lease_time": basetypes.Int64Type{},
			"options": basetypes.MapType{
				ElemType: OptionsValue{}.Type(ctx),
			},
			"server_id_override": basetypes.BoolType{},
			"servers": basetypes.ListType{
				ElemType: types.StringType,
			},
			"servers6": basetypes.ListType{
				ElemType: types.StringType,
			},
			"type": basetypes.StringType{},
			"type6": basetypes.StringType{},
			"vendor_encapulated": basetypes.MapType{
				ElemType: VendorEncapulatedValue{}.Type(ctx),
			},
		}), diags
	}

	serversVal, d := types.ListValue(types.StringType, v.Servers4.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"dns_servers": basetypes.ListType{
				ElemType: types.StringType,
			},
			"dns_suffix": basetypes.ListType{
				ElemType: types.StringType,
			},
			"fixed_bindings": basetypes.MapType{
				ElemType: FixedBindingsValue{}.Type(ctx),
			},
			"gateway":    basetypes.StringType{},
			"ip_end":    basetypes.StringType{},
			"ip_end6":    basetypes.StringType{},
			"ip_start":  basetypes.StringType{},
			"ip_start6":  basetypes.StringType{},
			"lease_time": basetypes.Int64Type{},
			"options": basetypes.MapType{
				ElemType: OptionsValue{}.Type(ctx),
			},
			"server_id_override": basetypes.BoolType{},
			"servers": basetypes.ListType{
				ElemType: types.StringType,
			},
			"servers6": basetypes.ListType{
				ElemType: types.StringType,
			},
			"type": basetypes.StringType{},
			"type6": basetypes.StringType{},
			"vendor_encapulated": basetypes.MapType{
				ElemType: VendorEncapulatedValue{}.Type(ctx),
			},
		}), diags
	}

	servers6Val, d := types.ListValue(types.StringType, v.Servers6.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"dns_servers": basetypes.ListType{
				ElemType: types.StringType,
			},
			"dns_suffix": basetypes.ListType{
				ElemType: types.StringType,
			},
			"fixed_bindings": basetypes.MapType{
				ElemType: FixedBindingsValue{}.Type(ctx),
			},
			"gateway":    basetypes.StringType{},
			"ip_end":    basetypes.StringType{},
			"ip_end6":    basetypes.StringType{},
			"ip_start":  basetypes.StringType{},
			"ip_start6":  basetypes.StringType{},
			"lease_time": basetypes.Int64Type{},
			"options": basetypes.MapType{
				ElemType: OptionsValue{}.Type(ctx),
			},
			"server_id_override": basetypes.BoolType{},
			"servers": basetypes.ListType{
				ElemType: types.StringType,
			},
			"servers6": basetypes.ListType{
				ElemType: types.StringType,
			},
			"type": basetypes.StringType{},
			"type6": basetypes.StringType{},
			"vendor_encapulated": basetypes.MapType{
				ElemType: VendorEncapulatedValue{}.Type(ctx),
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"dns_servers": basetypes.ListType{
			ElemType: types.StringType,
		},
		"dns_suffix": basetypes.ListType{
			ElemType: types.StringType,
		},
		"fixed_bindings": basetypes.MapType{
			ElemType: FixedBindingsValue{}.Type(ctx),
		},
		"gateway":    basetypes.StringType{},
		"ip_end":    basetypes.StringType{},
		"ip_end6":    basetypes.StringType{},
		"ip_start":  basetypes.StringType{},
		"ip_start6":  basetypes.StringType{},
		"lease_time": basetypes.Int64Type{},
		"options": basetypes.MapType{
			ElemType: OptionsValue{}.Type(ctx),
		},
		"server_id_override": basetypes.BoolType{},
		"servers": basetypes.ListType{
			ElemType: types.StringType,
		},
		"servers6": basetypes.ListType{
			ElemType: types.StringType,
		},
		"type": basetypes.StringType{},
		"type6": basetypes.StringType{},
		"vendor_encapulated": basetypes.MapType{
			ElemType: VendorEncapulatedValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"dns_servers":        dnsServersVal,
			"dns_suffix":         dnsSuffixVal,
			"fixed_bindings":     fixedBindings,
			"gateway":            v.Gateway,
			"ip_end":            v.IpEnd4,
			"ip_end6":            v.IpEnd6,
			"ip_start":          v.IpStart4,
			"ip_start6":          v.IpStart6,
			"lease_time":         v.LeaseTime,
			"options":            options,
			"server_id_override": v.ServerIdOverride,
			"servers":           serversVal,
			"servers6":           servers6Val,
			"type":              v.Type4,
			"type6":              v.Type6,
			"vendor_encapulated": vendorEncapulated,
		})

	return objVal, diags
}

func (v ConfigValue) Equal(o attr.Value) bool {
	other, ok := o.(ConfigValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.DnsServers.Equal(other.DnsServers) {
		return false
	}

	if !v.DnsSuffix.Equal(other.DnsSuffix) {
		return false
	}

	if !v.FixedBindings.Equal(other.FixedBindings) {
		return false
	}

	if !v.Gateway.Equal(other.Gateway) {
		return false
	}

	if !v.IpEnd4.Equal(other.IpEnd4) {
		return false
	}

	if !v.IpEnd6.Equal(other.IpEnd6) {
		return false
	}

	if !v.IpStart4.Equal(other.IpStart4) {
		return false
	}

	if !v.IpStart6.Equal(other.IpStart6) {
		return false
	}

	if !v.LeaseTime.Equal(other.LeaseTime) {
		return false
	}

	if !v.Options.Equal(other.Options) {
		return false
	}

	if !v.ServerIdOverride.Equal(other.ServerIdOverride) {
		return false
	}

	if !v.Servers4.Equal(other.Servers4) {
		return false
	}

	if !v.Servers6.Equal(other.Servers6) {
		return false
	}

	if !v.Type4.Equal(other.Type4) {
		return false
	}

	if !v.Type6.Equal(other.Type6) {
		return false
	}

	if !v.VendorEncapulated.Equal(other.VendorEncapulated) {
		return false
	}

	return true
}

func (v ConfigValue) Type(ctx context.Context) attr.Type {
	return ConfigType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ConfigValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"dns_servers": basetypes.ListType{
			ElemType: types.StringType,
		},
		"dns_suffix": basetypes.ListType{
			ElemType: types.StringType,
		},
		"fixed_bindings": basetypes.MapType{
			ElemType: FixedBindingsValue{}.Type(ctx),
		},
		"gateway":    basetypes.StringType{},
		"ip_end":    basetypes.StringType{},
		"ip_end6":    basetypes.StringType{},
		"ip_start":  basetypes.StringType{},
		"ip_start6":  basetypes.StringType{},
		"lease_time": basetypes.Int64Type{},
		"options": basetypes.MapType{
			ElemType: OptionsValue{}.Type(ctx),
		},
		"server_id_override": basetypes.BoolType{},
		"servers": basetypes.ListType{
			ElemType: types.StringType,
		},
		"servers6": basetypes.ListType{
			ElemType: types.StringType,
		},
		"type": basetypes.StringType{},
		"type6": basetypes.StringType{},
		"vendor_encapulated": basetypes.MapType{
			ElemType: VendorEncapulatedValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = FixedBindingsType{}

type FixedBindingsType struct {
	basetypes.ObjectType
}

func (t FixedBindingsType) Equal(o attr.Type) bool {
	other, ok := o.(FixedBindingsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t FixedBindingsType) String() string {
	return "FixedBindingsType"
}

func (t FixedBindingsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	ipAttribute, ok := attributes["ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip is missing from object`)

		return nil, diags
	}

	ipVal, ok := ipAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip expected to be basetypes.StringValue, was: %T`, ipAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return FixedBindingsValue{
		Ip:    ipVal,
		Name:  nameVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewFixedBindingsValueNull() FixedBindingsValue {
	return FixedBindingsValue{
		state: attr.ValueStateNull,
	}
}

func NewFixedBindingsValueUnknown() FixedBindingsValue {
	return FixedBindingsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewFixedBindingsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (FixedBindingsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing FixedBindingsValue Attribute Value",
				"While creating a FixedBindingsValue value, a missing attribute value was detected. "+
					"A FixedBindingsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("FixedBindingsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid FixedBindingsValue Attribute Type",
				"While creating a FixedBindingsValue value, an invalid attribute value was detected. "+
					"A FixedBindingsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("FixedBindingsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("FixedBindingsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra FixedBindingsValue Attribute Value",
				"While creating a FixedBindingsValue value, an extra attribute value was detected. "+
					"A FixedBindingsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra FixedBindingsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewFixedBindingsValueUnknown(), diags
	}

	ipAttribute, ok := attributes["ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip is missing from object`)

		return NewFixedBindingsValueUnknown(), diags
	}

	ipVal, ok := ipAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip expected to be basetypes.StringValue, was: %T`, ipAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewFixedBindingsValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	if diags.HasError() {
		return NewFixedBindingsValueUnknown(), diags
	}

	return FixedBindingsValue{
		Ip:    ipVal,
		Name:  nameVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewFixedBindingsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) FixedBindingsValue {
	object, diags := NewFixedBindingsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewFixedBindingsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t FixedBindingsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewFixedBindingsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewFixedBindingsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewFixedBindingsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewFixedBindingsValueMust(FixedBindingsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t FixedBindingsType) ValueType(ctx context.Context) attr.Value {
	return FixedBindingsValue{}
}

var _ basetypes.ObjectValuable = FixedBindingsValue{}

type FixedBindingsValue struct {
	Ip    basetypes.StringValue `tfsdk:"ip"`
	Name  basetypes.StringValue `tfsdk:"name"`
	state attr.ValueState
}

func (v FixedBindingsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["ip"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Ip.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v FixedBindingsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v FixedBindingsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v FixedBindingsValue) String() string {
	return "FixedBindingsValue"
}

func (v FixedBindingsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"ip":   basetypes.StringType{},
		"name": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"ip":   v.Ip,
			"name": v.Name,
		})

	return objVal, diags
}

func (v FixedBindingsValue) Equal(o attr.Value) bool {
	other, ok := o.(FixedBindingsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Ip.Equal(other.Ip) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	return true
}

func (v FixedBindingsValue) Type(ctx context.Context) attr.Type {
	return FixedBindingsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v FixedBindingsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"ip":   basetypes.StringType{},
		"name": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = OptionsType{}

type OptionsType struct {
	basetypes.ObjectType
}

func (t OptionsType) Equal(o attr.Type) bool {
	other, ok := o.(OptionsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t OptionsType) String() string {
	return "OptionsType"
}

func (t OptionsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return nil, diags
	}

	valueVal, ok := valueAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.StringValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return OptionsValue{
		OptionsType: typeVal,
		Value:       valueVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewOptionsValueNull() OptionsValue {
	return OptionsValue{
		state: attr.ValueStateNull,
	}
}

func NewOptionsValueUnknown() OptionsValue {
	return OptionsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewOptionsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (OptionsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing OptionsValue Attribute Value",
				"While creating a OptionsValue value, a missing attribute value was detected. "+
					"A OptionsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OptionsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid OptionsValue Attribute Type",
				"While creating a OptionsValue value, an invalid attribute value was detected. "+
					"A OptionsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OptionsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("OptionsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra OptionsValue Attribute Value",
				"While creating a OptionsValue value, an extra attribute value was detected. "+
					"A OptionsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra OptionsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewOptionsValueUnknown(), diags
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewOptionsValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return NewOptionsValueUnknown(), diags
	}

	valueVal, ok := valueAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.StringValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return NewOptionsValueUnknown(), diags
	}

	return OptionsValue{
		OptionsType: typeVal,
		Value:       valueVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewOptionsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) OptionsValue {
	object, diags := NewOptionsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewOptionsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t OptionsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewOptionsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewOptionsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewOptionsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewOptionsValueMust(OptionsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t OptionsType) ValueType(ctx context.Context) attr.Value {
	return OptionsValue{}
}

var _ basetypes.ObjectValuable = OptionsValue{}

type OptionsValue struct {
	OptionsType basetypes.StringValue `tfsdk:"type"`
	Value       basetypes.StringValue `tfsdk:"value"`
	state       attr.ValueState
}

func (v OptionsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["value"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.OptionsType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		val, err = v.Value.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["value"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v OptionsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v OptionsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v OptionsValue) String() string {
	return "OptionsValue"
}

func (v OptionsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"type":  basetypes.StringType{},
		"value": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"type":  v.OptionsType,
			"value": v.Value,
		})

	return objVal, diags
}

func (v OptionsValue) Equal(o attr.Value) bool {
	other, ok := o.(OptionsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.OptionsType.Equal(other.OptionsType) {
		return false
	}

	if !v.Value.Equal(other.Value) {
		return false
	}

	return true
}

func (v OptionsValue) Type(ctx context.Context) attr.Type {
	return OptionsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v OptionsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"type":  basetypes.StringType{},
		"value": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = VendorEncapulatedType{}

type VendorEncapulatedType struct {
	basetypes.ObjectType
}

func (t VendorEncapulatedType) Equal(o attr.Type) bool {
	other, ok := o.(VendorEncapulatedType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t VendorEncapulatedType) String() string {
	return "VendorEncapulatedType"
}

func (t VendorEncapulatedType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return nil, diags
	}

	valueVal, ok := valueAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.StringValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return VendorEncapulatedValue{
		VendorEncapulatedType: typeVal,
		Value:                 valueVal,
		state:                 attr.ValueStateKnown,
	}, diags
}

func NewVendorEncapulatedValueNull() VendorEncapulatedValue {
	return VendorEncapulatedValue{
		state: attr.ValueStateNull,
	}
}

func NewVendorEncapulatedValueUnknown() VendorEncapulatedValue {
	return VendorEncapulatedValue{
		state: attr.ValueStateUnknown,
	}
}

func NewVendorEncapulatedValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (VendorEncapulatedValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing VendorEncapulatedValue Attribute Value",
				"While creating a VendorEncapulatedValue value, a missing attribute value was detected. "+
					"A VendorEncapulatedValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VendorEncapulatedValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid VendorEncapulatedValue Attribute Type",
				"While creating a VendorEncapulatedValue value, an invalid attribute value was detected. "+
					"A VendorEncapulatedValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VendorEncapulatedValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("VendorEncapulatedValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra VendorEncapulatedValue Attribute Value",
				"While creating a VendorEncapulatedValue value, an extra attribute value was detected. "+
					"A VendorEncapulatedValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra VendorEncapulatedValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewVendorEncapulatedValueUnknown(), diags
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewVendorEncapulatedValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return NewVendorEncapulatedValueUnknown(), diags
	}

	valueVal, ok := valueAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.StringValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return NewVendorEncapulatedValueUnknown(), diags
	}

	return VendorEncapulatedValue{
		VendorEncapulatedType: typeVal,
		Value:                 valueVal,
		state:                 attr.ValueStateKnown,
	}, diags
}

func NewVendorEncapulatedValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) VendorEncapulatedValue {
	object, diags := NewVendorEncapulatedValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewVendorEncapulatedValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t VendorEncapulatedType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewVendorEncapulatedValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewVendorEncapulatedValueUnknown(), nil
	}

	if in.IsNull() {
		return NewVendorEncapulatedValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewVendorEncapulatedValueMust(VendorEncapulatedValue{}.AttributeTypes(ctx), attributes), nil
}

func (t VendorEncapulatedType) ValueType(ctx context.Context) attr.Value {
	return VendorEncapulatedValue{}
}

var _ basetypes.ObjectValuable = VendorEncapulatedValue{}

type VendorEncapulatedValue struct {
	VendorEncapulatedType basetypes.StringValue `tfsdk:"type"`
	Value                 basetypes.StringValue `tfsdk:"value"`
	state                 attr.ValueState
}

func (v VendorEncapulatedValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["value"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.VendorEncapulatedType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		val, err = v.Value.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["value"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v VendorEncapulatedValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v VendorEncapulatedValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v VendorEncapulatedValue) String() string {
	return "VendorEncapulatedValue"
}

func (v VendorEncapulatedValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"type":  basetypes.StringType{},
		"value": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"type":  v.VendorEncapulatedType,
			"value": v.Value,
		})

	return objVal, diags
}

func (v VendorEncapulatedValue) Equal(o attr.Value) bool {
	other, ok := o.(VendorEncapulatedValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.VendorEncapulatedType.Equal(other.VendorEncapulatedType) {
		return false
	}

	if !v.Value.Equal(other.Value) {
		return false
	}

	return true
}

func (v VendorEncapulatedValue) Type(ctx context.Context) attr.Type {
	return VendorEncapulatedType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v VendorEncapulatedValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"type":  basetypes.StringType{},
		"value": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = ExtraRoutesType{}

type ExtraRoutesType struct {
	basetypes.ObjectType
}

func (t ExtraRoutesType) Equal(o attr.Type) bool {
	other, ok := o.(ExtraRoutesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ExtraRoutesType) String() string {
	return "ExtraRoutesType"
}

func (t ExtraRoutesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	viaAttribute, ok := attributes["via"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`via is missing from object`)

		return nil, diags
	}

	viaVal, ok := viaAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`via expected to be basetypes.StringValue, was: %T`, viaAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ExtraRoutesValue{
		Via:   viaVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewExtraRoutesValueNull() ExtraRoutesValue {
	return ExtraRoutesValue{
		state: attr.ValueStateNull,
	}
}

func NewExtraRoutesValueUnknown() ExtraRoutesValue {
	return ExtraRoutesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewExtraRoutesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ExtraRoutesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ExtraRoutesValue Attribute Value",
				"While creating a ExtraRoutesValue value, a missing attribute value was detected. "+
					"A ExtraRoutesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ExtraRoutesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ExtraRoutesValue Attribute Type",
				"While creating a ExtraRoutesValue value, an invalid attribute value was detected. "+
					"A ExtraRoutesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ExtraRoutesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ExtraRoutesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ExtraRoutesValue Attribute Value",
				"While creating a ExtraRoutesValue value, an extra attribute value was detected. "+
					"A ExtraRoutesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ExtraRoutesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewExtraRoutesValueUnknown(), diags
	}

	viaAttribute, ok := attributes["via"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`via is missing from object`)

		return NewExtraRoutesValueUnknown(), diags
	}

	viaVal, ok := viaAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`via expected to be basetypes.StringValue, was: %T`, viaAttribute))
	}

	if diags.HasError() {
		return NewExtraRoutesValueUnknown(), diags
	}

	return ExtraRoutesValue{
		Via:   viaVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewExtraRoutesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ExtraRoutesValue {
	object, diags := NewExtraRoutesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewExtraRoutesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ExtraRoutesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewExtraRoutesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewExtraRoutesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewExtraRoutesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewExtraRoutesValueMust(ExtraRoutesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ExtraRoutesType) ValueType(ctx context.Context) attr.Value {
	return ExtraRoutesValue{}
}

var _ basetypes.ObjectValuable = ExtraRoutesValue{}

type ExtraRoutesValue struct {
	Via   basetypes.StringValue `tfsdk:"via"`
	state attr.ValueState
}

func (v ExtraRoutesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["via"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Via.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["via"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ExtraRoutesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ExtraRoutesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ExtraRoutesValue) String() string {
	return "ExtraRoutesValue"
}

func (v ExtraRoutesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"via": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"via": v.Via,
		})

	return objVal, diags
}

func (v ExtraRoutesValue) Equal(o attr.Value) bool {
	other, ok := o.(ExtraRoutesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Via.Equal(other.Via) {
		return false
	}

	return true
}

func (v ExtraRoutesValue) Type(ctx context.Context) attr.Type {
	return ExtraRoutesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ExtraRoutesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"via": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = IdpProfilesType{}

type IdpProfilesType struct {
	basetypes.ObjectType
}

func (t IdpProfilesType) Equal(o attr.Type) bool {
	other, ok := o.(IdpProfilesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t IdpProfilesType) String() string {
	return "IdpProfilesType"
}

func (t IdpProfilesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	baseProfileAttribute, ok := attributes["base_profile"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`base_profile is missing from object`)

		return nil, diags
	}

	baseProfileVal, ok := baseProfileAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`base_profile expected to be basetypes.StringValue, was: %T`, baseProfileAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	overwritesAttribute, ok := attributes["overwrites"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`overwrites is missing from object`)

		return nil, diags
	}

	overwritesVal, ok := overwritesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`overwrites expected to be basetypes.ListValue, was: %T`, overwritesAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return IdpProfilesValue{
		BaseProfile: baseProfileVal,
		Name:        nameVal,
		Overwrites:  overwritesVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewIdpProfilesValueNull() IdpProfilesValue {
	return IdpProfilesValue{
		state: attr.ValueStateNull,
	}
}

func NewIdpProfilesValueUnknown() IdpProfilesValue {
	return IdpProfilesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewIdpProfilesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (IdpProfilesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing IdpProfilesValue Attribute Value",
				"While creating a IdpProfilesValue value, a missing attribute value was detected. "+
					"A IdpProfilesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("IdpProfilesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid IdpProfilesValue Attribute Type",
				"While creating a IdpProfilesValue value, an invalid attribute value was detected. "+
					"A IdpProfilesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("IdpProfilesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("IdpProfilesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra IdpProfilesValue Attribute Value",
				"While creating a IdpProfilesValue value, an extra attribute value was detected. "+
					"A IdpProfilesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra IdpProfilesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewIdpProfilesValueUnknown(), diags
	}

	baseProfileAttribute, ok := attributes["base_profile"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`base_profile is missing from object`)

		return NewIdpProfilesValueUnknown(), diags
	}

	baseProfileVal, ok := baseProfileAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`base_profile expected to be basetypes.StringValue, was: %T`, baseProfileAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewIdpProfilesValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	overwritesAttribute, ok := attributes["overwrites"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`overwrites is missing from object`)

		return NewIdpProfilesValueUnknown(), diags
	}

	overwritesVal, ok := overwritesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`overwrites expected to be basetypes.ListValue, was: %T`, overwritesAttribute))
	}

	if diags.HasError() {
		return NewIdpProfilesValueUnknown(), diags
	}

	return IdpProfilesValue{
		BaseProfile: baseProfileVal,
		Name:        nameVal,
		Overwrites:  overwritesVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewIdpProfilesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) IdpProfilesValue {
	object, diags := NewIdpProfilesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewIdpProfilesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t IdpProfilesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewIdpProfilesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewIdpProfilesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewIdpProfilesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewIdpProfilesValueMust(IdpProfilesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t IdpProfilesType) ValueType(ctx context.Context) attr.Value {
	return IdpProfilesValue{}
}

var _ basetypes.ObjectValuable = IdpProfilesValue{}

type IdpProfilesValue struct {
	BaseProfile basetypes.StringValue `tfsdk:"base_profile"`
	Name        basetypes.StringValue `tfsdk:"name"`
	Overwrites  basetypes.ListValue   `tfsdk:"overwrites"`
	state       attr.ValueState
}

func (v IdpProfilesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["base_profile"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["overwrites"] = basetypes.ListType{
		ElemType: OverwritesValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.BaseProfile.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["base_profile"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Overwrites.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["overwrites"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v IdpProfilesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v IdpProfilesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v IdpProfilesValue) String() string {
	return "IdpProfilesValue"
}

func (v IdpProfilesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	overwrites := types.ListValueMust(
		OverwritesType{
			basetypes.ObjectType{
				AttrTypes: OverwritesValue{}.AttributeTypes(ctx),
			},
		},
		v.Overwrites.Elements(),
	)

	if v.Overwrites.IsNull() {
		overwrites = types.ListNull(
			OverwritesType{
				basetypes.ObjectType{
					AttrTypes: OverwritesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Overwrites.IsUnknown() {
		overwrites = types.ListUnknown(
			OverwritesType{
				basetypes.ObjectType{
					AttrTypes: OverwritesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"base_profile": basetypes.StringType{},
		"name":         basetypes.StringType{},
		"overwrites": basetypes.ListType{
			ElemType: OverwritesValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"base_profile": v.BaseProfile,
			"name":         v.Name,
			"overwrites":   overwrites,
		})

	return objVal, diags
}

func (v IdpProfilesValue) Equal(o attr.Value) bool {
	other, ok := o.(IdpProfilesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.BaseProfile.Equal(other.BaseProfile) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Overwrites.Equal(other.Overwrites) {
		return false
	}

	return true
}

func (v IdpProfilesValue) Type(ctx context.Context) attr.Type {
	return IdpProfilesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v IdpProfilesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"base_profile": basetypes.StringType{},
		"name":         basetypes.StringType{},
		"overwrites": basetypes.ListType{
			ElemType: OverwritesValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = OverwritesType{}

type OverwritesType struct {
	basetypes.ObjectType
}

func (t OverwritesType) Equal(o attr.Type) bool {
	other, ok := o.(OverwritesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t OverwritesType) String() string {
	return "OverwritesType"
}

func (t OverwritesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	actionAttribute, ok := attributes["action"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`action is missing from object`)

		return nil, diags
	}

	actionVal, ok := actionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`action expected to be basetypes.StringValue, was: %T`, actionAttribute))
	}

	ipdProfileOverwriteMatchingAttribute, ok := attributes["matching"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`matching is missing from object`)

		return nil, diags
	}

	ipdProfileOverwriteMatchingVal, ok := ipdProfileOverwriteMatchingAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`matching expected to be basetypes.ObjectValue, was: %T`, ipdProfileOverwriteMatchingAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return OverwritesValue{
		Action:                      actionVal,
		IpdProfileOverwriteMatching: ipdProfileOverwriteMatchingVal,
		state:                       attr.ValueStateKnown,
	}, diags
}

func NewOverwritesValueNull() OverwritesValue {
	return OverwritesValue{
		state: attr.ValueStateNull,
	}
}

func NewOverwritesValueUnknown() OverwritesValue {
	return OverwritesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewOverwritesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (OverwritesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing OverwritesValue Attribute Value",
				"While creating a OverwritesValue value, a missing attribute value was detected. "+
					"A OverwritesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OverwritesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid OverwritesValue Attribute Type",
				"While creating a OverwritesValue value, an invalid attribute value was detected. "+
					"A OverwritesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OverwritesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("OverwritesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra OverwritesValue Attribute Value",
				"While creating a OverwritesValue value, an extra attribute value was detected. "+
					"A OverwritesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra OverwritesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewOverwritesValueUnknown(), diags
	}

	actionAttribute, ok := attributes["action"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`action is missing from object`)

		return NewOverwritesValueUnknown(), diags
	}

	actionVal, ok := actionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`action expected to be basetypes.StringValue, was: %T`, actionAttribute))
	}

	ipdProfileOverwriteMatchingAttribute, ok := attributes["matching"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`matching is missing from object`)

		return NewOverwritesValueUnknown(), diags
	}

	ipdProfileOverwriteMatchingVal, ok := ipdProfileOverwriteMatchingAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`matching expected to be basetypes.ObjectValue, was: %T`, ipdProfileOverwriteMatchingAttribute))
	}

	if diags.HasError() {
		return NewOverwritesValueUnknown(), diags
	}

	return OverwritesValue{
		Action:                      actionVal,
		IpdProfileOverwriteMatching: ipdProfileOverwriteMatchingVal,
		state:                       attr.ValueStateKnown,
	}, diags
}

func NewOverwritesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) OverwritesValue {
	object, diags := NewOverwritesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewOverwritesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t OverwritesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewOverwritesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewOverwritesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewOverwritesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewOverwritesValueMust(OverwritesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t OverwritesType) ValueType(ctx context.Context) attr.Value {
	return OverwritesValue{}
}

var _ basetypes.ObjectValuable = OverwritesValue{}

type OverwritesValue struct {
	Action                      basetypes.StringValue `tfsdk:"action"`
	IpdProfileOverwriteMatching basetypes.ObjectValue `tfsdk:"matching"`
	state                       attr.ValueState
}

func (v OverwritesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["action"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["matching"] = basetypes.ObjectType{
		AttrTypes: IpdProfileOverwriteMatchingValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Action.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["action"] = val

		val, err = v.IpdProfileOverwriteMatching.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["matching"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v OverwritesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v OverwritesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v OverwritesValue) String() string {
	return "OverwritesValue"
}

func (v OverwritesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var ipdProfileOverwriteMatching basetypes.ObjectValue

	if v.IpdProfileOverwriteMatching.IsNull() {
		ipdProfileOverwriteMatching = types.ObjectNull(
			IpdProfileOverwriteMatchingValue{}.AttributeTypes(ctx),
		)
	}

	if v.IpdProfileOverwriteMatching.IsUnknown() {
		ipdProfileOverwriteMatching = types.ObjectUnknown(
			IpdProfileOverwriteMatchingValue{}.AttributeTypes(ctx),
		)
	}

	if !v.IpdProfileOverwriteMatching.IsNull() && !v.IpdProfileOverwriteMatching.IsUnknown() {
		ipdProfileOverwriteMatching = types.ObjectValueMust(
			IpdProfileOverwriteMatchingValue{}.AttributeTypes(ctx),
			v.IpdProfileOverwriteMatching.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"action": basetypes.StringType{},
		"matching": basetypes.ObjectType{
			AttrTypes: IpdProfileOverwriteMatchingValue{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"action":                         v.Action,
			"matching": ipdProfileOverwriteMatching,
		})

	return objVal, diags
}

func (v OverwritesValue) Equal(o attr.Value) bool {
	other, ok := o.(OverwritesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Action.Equal(other.Action) {
		return false
	}

	if !v.IpdProfileOverwriteMatching.Equal(other.IpdProfileOverwriteMatching) {
		return false
	}

	return true
}

func (v OverwritesValue) Type(ctx context.Context) attr.Type {
	return OverwritesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v OverwritesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"action": basetypes.StringType{},
		"matching": basetypes.ObjectType{
			AttrTypes: IpdProfileOverwriteMatchingValue{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = IpdProfileOverwriteMatchingType{}

type IpdProfileOverwriteMatchingType struct {
	basetypes.ObjectType
}

func (t IpdProfileOverwriteMatchingType) Equal(o attr.Type) bool {
	other, ok := o.(IpdProfileOverwriteMatchingType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t IpdProfileOverwriteMatchingType) String() string {
	return "IpdProfileOverwriteMatchingType"
}

func (t IpdProfileOverwriteMatchingType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	attackNameAttribute, ok := attributes["attack_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`attack_name is missing from object`)

		return nil, diags
	}

	attackNameVal, ok := attackNameAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`attack_name expected to be basetypes.ListValue, was: %T`, attackNameAttribute))
	}

	dstSubnetAttribute, ok := attributes["dst_subnet"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dst_subnet is missing from object`)

		return nil, diags
	}

	dstSubnetVal, ok := dstSubnetAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dst_subnet expected to be basetypes.ListValue, was: %T`, dstSubnetAttribute))
	}

	severityAttribute, ok := attributes["severity"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`severity is missing from object`)

		return nil, diags
	}

	severityVal, ok := severityAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`severity expected to be basetypes.ListValue, was: %T`, severityAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return IpdProfileOverwriteMatchingValue{
		AttackName: attackNameVal,
		DstSubnet:  dstSubnetVal,
		Severity:   severityVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewIpdProfileOverwriteMatchingValueNull() IpdProfileOverwriteMatchingValue {
	return IpdProfileOverwriteMatchingValue{
		state: attr.ValueStateNull,
	}
}

func NewIpdProfileOverwriteMatchingValueUnknown() IpdProfileOverwriteMatchingValue {
	return IpdProfileOverwriteMatchingValue{
		state: attr.ValueStateUnknown,
	}
}

func NewIpdProfileOverwriteMatchingValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (IpdProfileOverwriteMatchingValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing IpdProfileOverwriteMatchingValue Attribute Value",
				"While creating a IpdProfileOverwriteMatchingValue value, a missing attribute value was detected. "+
					"A IpdProfileOverwriteMatchingValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("IpdProfileOverwriteMatchingValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid IpdProfileOverwriteMatchingValue Attribute Type",
				"While creating a IpdProfileOverwriteMatchingValue value, an invalid attribute value was detected. "+
					"A IpdProfileOverwriteMatchingValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("IpdProfileOverwriteMatchingValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("IpdProfileOverwriteMatchingValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra IpdProfileOverwriteMatchingValue Attribute Value",
				"While creating a IpdProfileOverwriteMatchingValue value, an extra attribute value was detected. "+
					"A IpdProfileOverwriteMatchingValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra IpdProfileOverwriteMatchingValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewIpdProfileOverwriteMatchingValueUnknown(), diags
	}

	attackNameAttribute, ok := attributes["attack_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`attack_name is missing from object`)

		return NewIpdProfileOverwriteMatchingValueUnknown(), diags
	}

	attackNameVal, ok := attackNameAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`attack_name expected to be basetypes.ListValue, was: %T`, attackNameAttribute))
	}

	dstSubnetAttribute, ok := attributes["dst_subnet"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dst_subnet is missing from object`)

		return NewIpdProfileOverwriteMatchingValueUnknown(), diags
	}

	dstSubnetVal, ok := dstSubnetAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dst_subnet expected to be basetypes.ListValue, was: %T`, dstSubnetAttribute))
	}

	severityAttribute, ok := attributes["severity"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`severity is missing from object`)

		return NewIpdProfileOverwriteMatchingValueUnknown(), diags
	}

	severityVal, ok := severityAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`severity expected to be basetypes.ListValue, was: %T`, severityAttribute))
	}

	if diags.HasError() {
		return NewIpdProfileOverwriteMatchingValueUnknown(), diags
	}

	return IpdProfileOverwriteMatchingValue{
		AttackName: attackNameVal,
		DstSubnet:  dstSubnetVal,
		Severity:   severityVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewIpdProfileOverwriteMatchingValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) IpdProfileOverwriteMatchingValue {
	object, diags := NewIpdProfileOverwriteMatchingValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewIpdProfileOverwriteMatchingValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t IpdProfileOverwriteMatchingType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewIpdProfileOverwriteMatchingValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewIpdProfileOverwriteMatchingValueUnknown(), nil
	}

	if in.IsNull() {
		return NewIpdProfileOverwriteMatchingValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewIpdProfileOverwriteMatchingValueMust(IpdProfileOverwriteMatchingValue{}.AttributeTypes(ctx), attributes), nil
}

func (t IpdProfileOverwriteMatchingType) ValueType(ctx context.Context) attr.Value {
	return IpdProfileOverwriteMatchingValue{}
}

var _ basetypes.ObjectValuable = IpdProfileOverwriteMatchingValue{}

type IpdProfileOverwriteMatchingValue struct {
	AttackName basetypes.ListValue `tfsdk:"attack_name"`
	DstSubnet  basetypes.ListValue `tfsdk:"dst_subnet"`
	Severity   basetypes.ListValue `tfsdk:"severity"`
	state      attr.ValueState
}

func (v IpdProfileOverwriteMatchingValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["attack_name"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["dst_subnet"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["severity"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.AttackName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["attack_name"] = val

		val, err = v.DstSubnet.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dst_subnet"] = val

		val, err = v.Severity.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["severity"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v IpdProfileOverwriteMatchingValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v IpdProfileOverwriteMatchingValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v IpdProfileOverwriteMatchingValue) String() string {
	return "IpdProfileOverwriteMatchingValue"
}

func (v IpdProfileOverwriteMatchingValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attackNameVal, d := types.ListValue(types.StringType, v.AttackName.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"attack_name": basetypes.ListType{
				ElemType: types.StringType,
			},
			"dst_subnet": basetypes.ListType{
				ElemType: types.StringType,
			},
			"severity": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	dstSubnetVal, d := types.ListValue(types.StringType, v.DstSubnet.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"attack_name": basetypes.ListType{
				ElemType: types.StringType,
			},
			"dst_subnet": basetypes.ListType{
				ElemType: types.StringType,
			},
			"severity": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	severityVal, d := types.ListValue(types.StringType, v.Severity.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"attack_name": basetypes.ListType{
				ElemType: types.StringType,
			},
			"dst_subnet": basetypes.ListType{
				ElemType: types.StringType,
			},
			"severity": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"attack_name": basetypes.ListType{
			ElemType: types.StringType,
		},
		"dst_subnet": basetypes.ListType{
			ElemType: types.StringType,
		},
		"severity": basetypes.ListType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"attack_name": attackNameVal,
			"dst_subnet":  dstSubnetVal,
			"severity":    severityVal,
		})

	return objVal, diags
}

func (v IpdProfileOverwriteMatchingValue) Equal(o attr.Value) bool {
	other, ok := o.(IpdProfileOverwriteMatchingValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AttackName.Equal(other.AttackName) {
		return false
	}

	if !v.DstSubnet.Equal(other.DstSubnet) {
		return false
	}

	if !v.Severity.Equal(other.Severity) {
		return false
	}

	return true
}

func (v IpdProfileOverwriteMatchingValue) Type(ctx context.Context) attr.Type {
	return IpdProfileOverwriteMatchingType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v IpdProfileOverwriteMatchingValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"attack_name": basetypes.ListType{
			ElemType: types.StringType,
		},
		"dst_subnet": basetypes.ListType{
			ElemType: types.StringType,
		},
		"severity": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = IpConfigsType{}

type IpConfigsType struct {
	basetypes.ObjectType
}

func (t IpConfigsType) Equal(o attr.Type) bool {
	other, ok := o.(IpConfigsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t IpConfigsType) String() string {
	return "IpConfigsType"
}

func (t IpConfigsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	ipAttribute, ok := attributes["ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip is missing from object`)

		return nil, diags
	}

	ipVal, ok := ipAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip expected to be basetypes.StringValue, was: %T`, ipAttribute))
	}

	netmaskAttribute, ok := attributes["netmask"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`netmask is missing from object`)

		return nil, diags
	}

	netmaskVal, ok := netmaskAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`netmask expected to be basetypes.StringValue, was: %T`, netmaskAttribute))
	}

	secondaryIpsAttribute, ok := attributes["secondary_ips"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`secondary_ips is missing from object`)

		return nil, diags
	}

	secondaryIpsVal, ok := secondaryIpsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`secondary_ips expected to be basetypes.ListValue, was: %T`, secondaryIpsAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return IpConfigsValue{
		Ip:            ipVal,
		Netmask:       netmaskVal,
		SecondaryIps:  secondaryIpsVal,
		IpConfigsType: typeVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewIpConfigsValueNull() IpConfigsValue {
	return IpConfigsValue{
		state: attr.ValueStateNull,
	}
}

func NewIpConfigsValueUnknown() IpConfigsValue {
	return IpConfigsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewIpConfigsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (IpConfigsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing IpConfigsValue Attribute Value",
				"While creating a IpConfigsValue value, a missing attribute value was detected. "+
					"A IpConfigsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("IpConfigsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid IpConfigsValue Attribute Type",
				"While creating a IpConfigsValue value, an invalid attribute value was detected. "+
					"A IpConfigsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("IpConfigsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("IpConfigsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra IpConfigsValue Attribute Value",
				"While creating a IpConfigsValue value, an extra attribute value was detected. "+
					"A IpConfigsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra IpConfigsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewIpConfigsValueUnknown(), diags
	}

	ipAttribute, ok := attributes["ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip is missing from object`)

		return NewIpConfigsValueUnknown(), diags
	}

	ipVal, ok := ipAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip expected to be basetypes.StringValue, was: %T`, ipAttribute))
	}

	netmaskAttribute, ok := attributes["netmask"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`netmask is missing from object`)

		return NewIpConfigsValueUnknown(), diags
	}

	netmaskVal, ok := netmaskAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`netmask expected to be basetypes.StringValue, was: %T`, netmaskAttribute))
	}

	secondaryIpsAttribute, ok := attributes["secondary_ips"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`secondary_ips is missing from object`)

		return NewIpConfigsValueUnknown(), diags
	}

	secondaryIpsVal, ok := secondaryIpsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`secondary_ips expected to be basetypes.ListValue, was: %T`, secondaryIpsAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewIpConfigsValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return NewIpConfigsValueUnknown(), diags
	}

	return IpConfigsValue{
		Ip:            ipVal,
		Netmask:       netmaskVal,
		SecondaryIps:  secondaryIpsVal,
		IpConfigsType: typeVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewIpConfigsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) IpConfigsValue {
	object, diags := NewIpConfigsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewIpConfigsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t IpConfigsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewIpConfigsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewIpConfigsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewIpConfigsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewIpConfigsValueMust(IpConfigsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t IpConfigsType) ValueType(ctx context.Context) attr.Value {
	return IpConfigsValue{}
}

var _ basetypes.ObjectValuable = IpConfigsValue{}

type IpConfigsValue struct {
	Ip            basetypes.StringValue `tfsdk:"ip"`
	Netmask       basetypes.StringValue `tfsdk:"netmask"`
	SecondaryIps  basetypes.ListValue   `tfsdk:"secondary_ips"`
	IpConfigsType basetypes.StringValue `tfsdk:"type"`
	state         attr.ValueState
}

func (v IpConfigsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["ip"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["netmask"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["secondary_ips"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Ip.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip"] = val

		val, err = v.Netmask.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["netmask"] = val

		val, err = v.SecondaryIps.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["secondary_ips"] = val

		val, err = v.IpConfigsType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v IpConfigsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v IpConfigsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v IpConfigsValue) String() string {
	return "IpConfigsValue"
}

func (v IpConfigsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	secondaryIpsVal, d := types.ListValue(types.StringType, v.SecondaryIps.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"ip":      basetypes.StringType{},
			"netmask": basetypes.StringType{},
			"secondary_ips": basetypes.ListType{
				ElemType: types.StringType,
			},
			"type": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"ip":      basetypes.StringType{},
		"netmask": basetypes.StringType{},
		"secondary_ips": basetypes.ListType{
			ElemType: types.StringType,
		},
		"type": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"ip":            v.Ip,
			"netmask":       v.Netmask,
			"secondary_ips": secondaryIpsVal,
			"type":          v.IpConfigsType,
		})

	return objVal, diags
}

func (v IpConfigsValue) Equal(o attr.Value) bool {
	other, ok := o.(IpConfigsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Ip.Equal(other.Ip) {
		return false
	}

	if !v.Netmask.Equal(other.Netmask) {
		return false
	}

	if !v.SecondaryIps.Equal(other.SecondaryIps) {
		return false
	}

	if !v.IpConfigsType.Equal(other.IpConfigsType) {
		return false
	}

	return true
}

func (v IpConfigsValue) Type(ctx context.Context) attr.Type {
	return IpConfigsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v IpConfigsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"ip":      basetypes.StringType{},
		"netmask": basetypes.StringType{},
		"secondary_ips": basetypes.ListType{
			ElemType: types.StringType,
		},
		"type": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = NetworksType{}

type NetworksType struct {
	basetypes.ObjectType
}

func (t NetworksType) Equal(o attr.Type) bool {
	other, ok := o.(NetworksType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t NetworksType) String() string {
	return "NetworksType"
}

func (t NetworksType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	disallowMistServicesAttribute, ok := attributes["disallow_mist_services"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disallow_mist_services is missing from object`)

		return nil, diags
	}

	disallowMistServicesVal, ok := disallowMistServicesAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disallow_mist_services expected to be basetypes.BoolValue, was: %T`, disallowMistServicesAttribute))
	}

	gatewayAttribute, ok := attributes["gateway"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gateway is missing from object`)

		return nil, diags
	}

	gatewayVal, ok := gatewayAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gateway expected to be basetypes.StringValue, was: %T`, gatewayAttribute))
	}

	gateway6Attribute, ok := attributes["gateway6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gateway6 is missing from object`)

		return nil, diags
	}

	gateway6Val, ok := gateway6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gateway6 expected to be basetypes.StringValue, was: %T`, gateway6Attribute))
	}

	internalAccessAttribute, ok := attributes["internal_access"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`internal_access is missing from object`)

		return nil, diags
	}

	internalAccessVal, ok := internalAccessAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`internal_access expected to be basetypes.ObjectValue, was: %T`, internalAccessAttribute))
	}

	internetAccessAttribute, ok := attributes["internet_access"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`internet_access is missing from object`)

		return nil, diags
	}

	internetAccessVal, ok := internetAccessAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`internet_access expected to be basetypes.ObjectValue, was: %T`, internetAccessAttribute))
	}

	isolationAttribute, ok := attributes["isolation"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`isolation is missing from object`)

		return nil, diags
	}

	isolationVal, ok := isolationAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`isolation expected to be basetypes.BoolValue, was: %T`, isolationAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	routedForNetworksAttribute, ok := attributes["routed_for_networks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`routed_for_networks is missing from object`)

		return nil, diags
	}

	routedForNetworksVal, ok := routedForNetworksAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`routed_for_networks expected to be basetypes.ListValue, was: %T`, routedForNetworksAttribute))
	}

	subnetAttribute, ok := attributes["subnet"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet is missing from object`)

		return nil, diags
	}

	subnetVal, ok := subnetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet expected to be basetypes.StringValue, was: %T`, subnetAttribute))
	}

	subnet6Attribute, ok := attributes["subnet6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet6 is missing from object`)

		return nil, diags
	}

	subnet6Val, ok := subnet6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet6 expected to be basetypes.StringValue, was: %T`, subnet6Attribute))
	}

	tenantsAttribute, ok := attributes["tenants"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tenants is missing from object`)

		return nil, diags
	}

	tenantsVal, ok := tenantsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tenants expected to be basetypes.MapValue, was: %T`, tenantsAttribute))
	}

	vlanIdAttribute, ok := attributes["vlan_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan_id is missing from object`)

		return nil, diags
	}

	vlanIdVal, ok := vlanIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan_id expected to be basetypes.Int64Value, was: %T`, vlanIdAttribute))
	}

	vpnAccessAttribute, ok := attributes["vpn_access"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vpn_access is missing from object`)

		return nil, diags
	}

	vpnAccessVal, ok := vpnAccessAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vpn_access expected to be basetypes.MapValue, was: %T`, vpnAccessAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return NetworksValue{
		DisallowMistServices: disallowMistServicesVal,
		Gateway:              gatewayVal,
		Gateway6:             gateway6Val,
		InternalAccess:       internalAccessVal,
		InternetAccess:       internetAccessVal,
		Isolation:            isolationVal,
		Name:                 nameVal,
		RoutedForNetworks:    routedForNetworksVal,
		Subnet:               subnetVal,
		Subnet6:              subnet6Val,
		Tenants:              tenantsVal,
		VlanId:               vlanIdVal,
		VpnAccess:            vpnAccessVal,
		state:                attr.ValueStateKnown,
	}, diags
}

func NewNetworksValueNull() NetworksValue {
	return NetworksValue{
		state: attr.ValueStateNull,
	}
}

func NewNetworksValueUnknown() NetworksValue {
	return NetworksValue{
		state: attr.ValueStateUnknown,
	}
}

func NewNetworksValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (NetworksValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing NetworksValue Attribute Value",
				"While creating a NetworksValue value, a missing attribute value was detected. "+
					"A NetworksValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NetworksValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid NetworksValue Attribute Type",
				"While creating a NetworksValue value, an invalid attribute value was detected. "+
					"A NetworksValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NetworksValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("NetworksValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra NetworksValue Attribute Value",
				"While creating a NetworksValue value, an extra attribute value was detected. "+
					"A NetworksValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra NetworksValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewNetworksValueUnknown(), diags
	}

	disallowMistServicesAttribute, ok := attributes["disallow_mist_services"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disallow_mist_services is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	disallowMistServicesVal, ok := disallowMistServicesAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disallow_mist_services expected to be basetypes.BoolValue, was: %T`, disallowMistServicesAttribute))
	}

	gatewayAttribute, ok := attributes["gateway"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gateway is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	gatewayVal, ok := gatewayAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gateway expected to be basetypes.StringValue, was: %T`, gatewayAttribute))
	}

	gateway6Attribute, ok := attributes["gateway6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gateway6 is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	gateway6Val, ok := gateway6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gateway6 expected to be basetypes.StringValue, was: %T`, gateway6Attribute))
	}

	internalAccessAttribute, ok := attributes["internal_access"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`internal_access is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	internalAccessVal, ok := internalAccessAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`internal_access expected to be basetypes.ObjectValue, was: %T`, internalAccessAttribute))
	}

	internetAccessAttribute, ok := attributes["internet_access"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`internet_access is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	internetAccessVal, ok := internetAccessAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`internet_access expected to be basetypes.ObjectValue, was: %T`, internetAccessAttribute))
	}

	isolationAttribute, ok := attributes["isolation"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`isolation is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	isolationVal, ok := isolationAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`isolation expected to be basetypes.BoolValue, was: %T`, isolationAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	routedForNetworksAttribute, ok := attributes["routed_for_networks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`routed_for_networks is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	routedForNetworksVal, ok := routedForNetworksAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`routed_for_networks expected to be basetypes.ListValue, was: %T`, routedForNetworksAttribute))
	}

	subnetAttribute, ok := attributes["subnet"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	subnetVal, ok := subnetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet expected to be basetypes.StringValue, was: %T`, subnetAttribute))
	}

	subnet6Attribute, ok := attributes["subnet6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet6 is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	subnet6Val, ok := subnet6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet6 expected to be basetypes.StringValue, was: %T`, subnet6Attribute))
	}

	tenantsAttribute, ok := attributes["tenants"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tenants is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	tenantsVal, ok := tenantsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tenants expected to be basetypes.MapValue, was: %T`, tenantsAttribute))
	}

	vlanIdAttribute, ok := attributes["vlan_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan_id is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	vlanIdVal, ok := vlanIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan_id expected to be basetypes.Int64Value, was: %T`, vlanIdAttribute))
	}

	vpnAccessAttribute, ok := attributes["vpn_access"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vpn_access is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	vpnAccessVal, ok := vpnAccessAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vpn_access expected to be basetypes.MapValue, was: %T`, vpnAccessAttribute))
	}

	if diags.HasError() {
		return NewNetworksValueUnknown(), diags
	}

	return NetworksValue{
		DisallowMistServices: disallowMistServicesVal,
		Gateway:              gatewayVal,
		Gateway6:             gateway6Val,
		InternalAccess:       internalAccessVal,
		InternetAccess:       internetAccessVal,
		Isolation:            isolationVal,
		Name:                 nameVal,
		RoutedForNetworks:    routedForNetworksVal,
		Subnet:               subnetVal,
		Subnet6:              subnet6Val,
		Tenants:              tenantsVal,
		VlanId:               vlanIdVal,
		VpnAccess:            vpnAccessVal,
		state:                attr.ValueStateKnown,
	}, diags
}

func NewNetworksValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) NetworksValue {
	object, diags := NewNetworksValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewNetworksValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t NetworksType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewNetworksValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewNetworksValueUnknown(), nil
	}

	if in.IsNull() {
		return NewNetworksValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewNetworksValueMust(NetworksValue{}.AttributeTypes(ctx), attributes), nil
}

func (t NetworksType) ValueType(ctx context.Context) attr.Value {
	return NetworksValue{}
}

var _ basetypes.ObjectValuable = NetworksValue{}

type NetworksValue struct {
	DisallowMistServices basetypes.BoolValue   `tfsdk:"disallow_mist_services"`
	Gateway              basetypes.StringValue `tfsdk:"gateway"`
	Gateway6             basetypes.StringValue `tfsdk:"gateway6"`
	InternalAccess       basetypes.ObjectValue `tfsdk:"internal_access"`
	InternetAccess       basetypes.ObjectValue `tfsdk:"internet_access"`
	Isolation            basetypes.BoolValue   `tfsdk:"isolation"`
	Name                 basetypes.StringValue `tfsdk:"name"`
	RoutedForNetworks    basetypes.ListValue   `tfsdk:"routed_for_networks"`
	Subnet               basetypes.StringValue `tfsdk:"subnet"`
	Subnet6              basetypes.StringValue `tfsdk:"subnet6"`
	Tenants              basetypes.MapValue    `tfsdk:"tenants"`
	VlanId               basetypes.Int64Value  `tfsdk:"vlan_id"`
	VpnAccess            basetypes.MapValue    `tfsdk:"vpn_access"`
	state                attr.ValueState
}

func (v NetworksValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 13)

	var val tftypes.Value
	var err error

	attrTypes["disallow_mist_services"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["gateway"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["gateway6"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["internal_access"] = basetypes.ObjectType{
		AttrTypes: InternalAccessValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["internet_access"] = basetypes.ObjectType{
		AttrTypes: InternetAccessValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["isolation"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["routed_for_networks"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["subnet"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["subnet6"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["tenants"] = basetypes.MapType{
		ElemType: TenantsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["vlan_id"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["vpn_access"] = basetypes.MapType{
		ElemType: VpnAccessValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 13)

		val, err = v.DisallowMistServices.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["disallow_mist_services"] = val

		val, err = v.Gateway.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["gateway"] = val

		val, err = v.Gateway6.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["gateway6"] = val

		val, err = v.InternalAccess.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["internal_access"] = val

		val, err = v.InternetAccess.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["internet_access"] = val

		val, err = v.Isolation.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["isolation"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.RoutedForNetworks.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["routed_for_networks"] = val

		val, err = v.Subnet.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["subnet"] = val

		val, err = v.Subnet6.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["subnet6"] = val

		val, err = v.Tenants.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tenants"] = val

		val, err = v.VlanId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vlan_id"] = val

		val, err = v.VpnAccess.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vpn_access"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v NetworksValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v NetworksValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v NetworksValue) String() string {
	return "NetworksValue"
}

func (v NetworksValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var internalAccess basetypes.ObjectValue

	if v.InternalAccess.IsNull() {
		internalAccess = types.ObjectNull(
			InternalAccessValue{}.AttributeTypes(ctx),
		)
	}

	if v.InternalAccess.IsUnknown() {
		internalAccess = types.ObjectUnknown(
			InternalAccessValue{}.AttributeTypes(ctx),
		)
	}

	if !v.InternalAccess.IsNull() && !v.InternalAccess.IsUnknown() {
		internalAccess = types.ObjectValueMust(
			InternalAccessValue{}.AttributeTypes(ctx),
			v.InternalAccess.Attributes(),
		)
	}

	var internetAccess basetypes.ObjectValue

	if v.InternetAccess.IsNull() {
		internetAccess = types.ObjectNull(
			InternetAccessValue{}.AttributeTypes(ctx),
		)
	}

	if v.InternetAccess.IsUnknown() {
		internetAccess = types.ObjectUnknown(
			InternetAccessValue{}.AttributeTypes(ctx),
		)
	}

	if !v.InternetAccess.IsNull() && !v.InternetAccess.IsUnknown() {
		internetAccess = types.ObjectValueMust(
			InternetAccessValue{}.AttributeTypes(ctx),
			v.InternetAccess.Attributes(),
		)
	}

	tenants := types.MapValueMust(
		TenantsType{
			basetypes.ObjectType{
				AttrTypes: TenantsValue{}.AttributeTypes(ctx),
			},
		},
		v.Tenants.Elements(),
	)

	if v.Tenants.IsNull() {
		tenants = types.MapNull(
			TenantsType{
				basetypes.ObjectType{
					AttrTypes: TenantsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Tenants.IsUnknown() {
		tenants = types.MapUnknown(
			TenantsType{
				basetypes.ObjectType{
					AttrTypes: TenantsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	vpnAccess := types.MapValueMust(
		VpnAccessType{
			basetypes.ObjectType{
				AttrTypes: VpnAccessValue{}.AttributeTypes(ctx),
			},
		},
		v.VpnAccess.Elements(),
	)

	if v.VpnAccess.IsNull() {
		vpnAccess = types.MapNull(
			VpnAccessType{
				basetypes.ObjectType{
					AttrTypes: VpnAccessValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.VpnAccess.IsUnknown() {
		vpnAccess = types.MapUnknown(
			VpnAccessType{
				basetypes.ObjectType{
					AttrTypes: VpnAccessValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	routedForNetworksVal, d := types.ListValue(types.StringType, v.RoutedForNetworks.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"disallow_mist_services": basetypes.BoolType{},
			"gateway":                basetypes.StringType{},
			"gateway6":               basetypes.StringType{},
			"internal_access": basetypes.ObjectType{
				AttrTypes: InternalAccessValue{}.AttributeTypes(ctx),
			},
			"internet_access": basetypes.ObjectType{
				AttrTypes: InternetAccessValue{}.AttributeTypes(ctx),
			},
			"isolation": basetypes.BoolType{},
			"name":      basetypes.StringType{},
			"routed_for_networks": basetypes.ListType{
				ElemType: types.StringType,
			},
			"subnet":  basetypes.StringType{},
			"subnet6": basetypes.StringType{},
			"tenants": basetypes.MapType{
				ElemType: TenantsValue{}.Type(ctx),
			},
			"vlan_id": basetypes.Int64Type{},
			"vpn_access": basetypes.MapType{
				ElemType: VpnAccessValue{}.Type(ctx),
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"disallow_mist_services": basetypes.BoolType{},
		"gateway":                basetypes.StringType{},
		"gateway6":               basetypes.StringType{},
		"internal_access": basetypes.ObjectType{
			AttrTypes: InternalAccessValue{}.AttributeTypes(ctx),
		},
		"internet_access": basetypes.ObjectType{
			AttrTypes: InternetAccessValue{}.AttributeTypes(ctx),
		},
		"isolation": basetypes.BoolType{},
		"name":      basetypes.StringType{},
		"routed_for_networks": basetypes.ListType{
			ElemType: types.StringType,
		},
		"subnet":  basetypes.StringType{},
		"subnet6": basetypes.StringType{},
		"tenants": basetypes.MapType{
			ElemType: TenantsValue{}.Type(ctx),
		},
		"vlan_id": basetypes.Int64Type{},
		"vpn_access": basetypes.MapType{
			ElemType: VpnAccessValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"disallow_mist_services": v.DisallowMistServices,
			"gateway":                v.Gateway,
			"gateway6":               v.Gateway6,
			"internal_access":        internalAccess,
			"internet_access":        internetAccess,
			"isolation":              v.Isolation,
			"name":                   v.Name,
			"routed_for_networks":    routedForNetworksVal,
			"subnet":                 v.Subnet,
			"subnet6":                v.Subnet6,
			"tenants":                tenants,
			"vlan_id":                v.VlanId,
			"vpn_access":             vpnAccess,
		})

	return objVal, diags
}

func (v NetworksValue) Equal(o attr.Value) bool {
	other, ok := o.(NetworksValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.DisallowMistServices.Equal(other.DisallowMistServices) {
		return false
	}

	if !v.Gateway.Equal(other.Gateway) {
		return false
	}

	if !v.Gateway6.Equal(other.Gateway6) {
		return false
	}

	if !v.InternalAccess.Equal(other.InternalAccess) {
		return false
	}

	if !v.InternetAccess.Equal(other.InternetAccess) {
		return false
	}

	if !v.Isolation.Equal(other.Isolation) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.RoutedForNetworks.Equal(other.RoutedForNetworks) {
		return false
	}

	if !v.Subnet.Equal(other.Subnet) {
		return false
	}

	if !v.Subnet6.Equal(other.Subnet6) {
		return false
	}

	if !v.Tenants.Equal(other.Tenants) {
		return false
	}

	if !v.VlanId.Equal(other.VlanId) {
		return false
	}

	if !v.VpnAccess.Equal(other.VpnAccess) {
		return false
	}

	return true
}

func (v NetworksValue) Type(ctx context.Context) attr.Type {
	return NetworksType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v NetworksValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"disallow_mist_services": basetypes.BoolType{},
		"gateway":                basetypes.StringType{},
		"gateway6":               basetypes.StringType{},
		"internal_access": basetypes.ObjectType{
			AttrTypes: InternalAccessValue{}.AttributeTypes(ctx),
		},
		"internet_access": basetypes.ObjectType{
			AttrTypes: InternetAccessValue{}.AttributeTypes(ctx),
		},
		"isolation": basetypes.BoolType{},
		"name":      basetypes.StringType{},
		"routed_for_networks": basetypes.ListType{
			ElemType: types.StringType,
		},
		"subnet":  basetypes.StringType{},
		"subnet6": basetypes.StringType{},
		"tenants": basetypes.MapType{
			ElemType: TenantsValue{}.Type(ctx),
		},
		"vlan_id": basetypes.Int64Type{},
		"vpn_access": basetypes.MapType{
			ElemType: VpnAccessValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = InternalAccessType{}

type InternalAccessType struct {
	basetypes.ObjectType
}

func (t InternalAccessType) Equal(o attr.Type) bool {
	other, ok := o.(InternalAccessType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t InternalAccessType) String() string {
	return "InternalAccessType"
}

func (t InternalAccessType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return InternalAccessValue{
		Enabled: enabledVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewInternalAccessValueNull() InternalAccessValue {
	return InternalAccessValue{
		state: attr.ValueStateNull,
	}
}

func NewInternalAccessValueUnknown() InternalAccessValue {
	return InternalAccessValue{
		state: attr.ValueStateUnknown,
	}
}

func NewInternalAccessValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (InternalAccessValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing InternalAccessValue Attribute Value",
				"While creating a InternalAccessValue value, a missing attribute value was detected. "+
					"A InternalAccessValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("InternalAccessValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid InternalAccessValue Attribute Type",
				"While creating a InternalAccessValue value, an invalid attribute value was detected. "+
					"A InternalAccessValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("InternalAccessValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("InternalAccessValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra InternalAccessValue Attribute Value",
				"While creating a InternalAccessValue value, an extra attribute value was detected. "+
					"A InternalAccessValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra InternalAccessValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewInternalAccessValueUnknown(), diags
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewInternalAccessValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	if diags.HasError() {
		return NewInternalAccessValueUnknown(), diags
	}

	return InternalAccessValue{
		Enabled: enabledVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewInternalAccessValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) InternalAccessValue {
	object, diags := NewInternalAccessValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewInternalAccessValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t InternalAccessType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewInternalAccessValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewInternalAccessValueUnknown(), nil
	}

	if in.IsNull() {
		return NewInternalAccessValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewInternalAccessValueMust(InternalAccessValue{}.AttributeTypes(ctx), attributes), nil
}

func (t InternalAccessType) ValueType(ctx context.Context) attr.Value {
	return InternalAccessValue{}
}

var _ basetypes.ObjectValuable = InternalAccessValue{}

type InternalAccessValue struct {
	Enabled basetypes.BoolValue `tfsdk:"enabled"`
	state   attr.ValueState
}

func (v InternalAccessValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v InternalAccessValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v InternalAccessValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v InternalAccessValue) String() string {
	return "InternalAccessValue"
}

func (v InternalAccessValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"enabled": basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"enabled": v.Enabled,
		})

	return objVal, diags
}

func (v InternalAccessValue) Equal(o attr.Value) bool {
	other, ok := o.(InternalAccessValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	return true
}

func (v InternalAccessValue) Type(ctx context.Context) attr.Type {
	return InternalAccessType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v InternalAccessValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"enabled": basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = InternetAccessType{}

type InternetAccessType struct {
	basetypes.ObjectType
}

func (t InternetAccessType) Equal(o attr.Type) bool {
	other, ok := o.(InternetAccessType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t InternetAccessType) String() string {
	return "InternetAccessType"
}

func (t InternetAccessType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	createSimpleServicePolicyAttribute, ok := attributes["create_simple_service_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`create_simple_service_policy is missing from object`)

		return nil, diags
	}

	createSimpleServicePolicyVal, ok := createSimpleServicePolicyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`create_simple_service_policy expected to be basetypes.BoolValue, was: %T`, createSimpleServicePolicyAttribute))
	}

	destinationNatAttribute, ok := attributes["destination_nat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`destination_nat is missing from object`)

		return nil, diags
	}

	destinationNatVal, ok := destinationNatAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`destination_nat expected to be basetypes.MapValue, was: %T`, destinationNatAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	restrictedAttribute, ok := attributes["restricted"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`restricted is missing from object`)

		return nil, diags
	}

	restrictedVal, ok := restrictedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`restricted expected to be basetypes.BoolValue, was: %T`, restrictedAttribute))
	}

	staticNatAttribute, ok := attributes["static_nat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`static_nat is missing from object`)

		return nil, diags
	}

	staticNatVal, ok := staticNatAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`static_nat expected to be basetypes.MapValue, was: %T`, staticNatAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return InternetAccessValue{
		CreateSimpleServicePolicy: createSimpleServicePolicyVal,
		DestinationNat:            destinationNatVal,
		Enabled:                   enabledVal,
		Restricted:                restrictedVal,
		StaticNat:                 staticNatVal,
		state:                     attr.ValueStateKnown,
	}, diags
}

func NewInternetAccessValueNull() InternetAccessValue {
	return InternetAccessValue{
		state: attr.ValueStateNull,
	}
}

func NewInternetAccessValueUnknown() InternetAccessValue {
	return InternetAccessValue{
		state: attr.ValueStateUnknown,
	}
}

func NewInternetAccessValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (InternetAccessValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing InternetAccessValue Attribute Value",
				"While creating a InternetAccessValue value, a missing attribute value was detected. "+
					"A InternetAccessValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("InternetAccessValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid InternetAccessValue Attribute Type",
				"While creating a InternetAccessValue value, an invalid attribute value was detected. "+
					"A InternetAccessValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("InternetAccessValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("InternetAccessValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra InternetAccessValue Attribute Value",
				"While creating a InternetAccessValue value, an extra attribute value was detected. "+
					"A InternetAccessValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra InternetAccessValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewInternetAccessValueUnknown(), diags
	}

	createSimpleServicePolicyAttribute, ok := attributes["create_simple_service_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`create_simple_service_policy is missing from object`)

		return NewInternetAccessValueUnknown(), diags
	}

	createSimpleServicePolicyVal, ok := createSimpleServicePolicyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`create_simple_service_policy expected to be basetypes.BoolValue, was: %T`, createSimpleServicePolicyAttribute))
	}

	destinationNatAttribute, ok := attributes["destination_nat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`destination_nat is missing from object`)

		return NewInternetAccessValueUnknown(), diags
	}

	destinationNatVal, ok := destinationNatAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`destination_nat expected to be basetypes.MapValue, was: %T`, destinationNatAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewInternetAccessValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	restrictedAttribute, ok := attributes["restricted"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`restricted is missing from object`)

		return NewInternetAccessValueUnknown(), diags
	}

	restrictedVal, ok := restrictedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`restricted expected to be basetypes.BoolValue, was: %T`, restrictedAttribute))
	}

	staticNatAttribute, ok := attributes["static_nat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`static_nat is missing from object`)

		return NewInternetAccessValueUnknown(), diags
	}

	staticNatVal, ok := staticNatAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`static_nat expected to be basetypes.MapValue, was: %T`, staticNatAttribute))
	}

	if diags.HasError() {
		return NewInternetAccessValueUnknown(), diags
	}

	return InternetAccessValue{
		CreateSimpleServicePolicy: createSimpleServicePolicyVal,
		DestinationNat:            destinationNatVal,
		Enabled:                   enabledVal,
		Restricted:                restrictedVal,
		StaticNat:                 staticNatVal,
		state:                     attr.ValueStateKnown,
	}, diags
}

func NewInternetAccessValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) InternetAccessValue {
	object, diags := NewInternetAccessValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewInternetAccessValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t InternetAccessType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewInternetAccessValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewInternetAccessValueUnknown(), nil
	}

	if in.IsNull() {
		return NewInternetAccessValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewInternetAccessValueMust(InternetAccessValue{}.AttributeTypes(ctx), attributes), nil
}

func (t InternetAccessType) ValueType(ctx context.Context) attr.Value {
	return InternetAccessValue{}
}

var _ basetypes.ObjectValuable = InternetAccessValue{}

type InternetAccessValue struct {
	CreateSimpleServicePolicy basetypes.BoolValue `tfsdk:"create_simple_service_policy"`
	DestinationNat            basetypes.MapValue  `tfsdk:"destination_nat"`
	Enabled                   basetypes.BoolValue `tfsdk:"enabled"`
	Restricted                basetypes.BoolValue `tfsdk:"restricted"`
	StaticNat                 basetypes.MapValue  `tfsdk:"static_nat"`
	state                     attr.ValueState
}

func (v InternetAccessValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["create_simple_service_policy"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["destination_nat"] = basetypes.MapType{
		ElemType: DestinationNatValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["restricted"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["static_nat"] = basetypes.MapType{
		ElemType: StaticNatValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.CreateSimpleServicePolicy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["create_simple_service_policy"] = val

		val, err = v.DestinationNat.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["destination_nat"] = val

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.Restricted.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["restricted"] = val

		val, err = v.StaticNat.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["static_nat"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v InternetAccessValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v InternetAccessValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v InternetAccessValue) String() string {
	return "InternetAccessValue"
}

func (v InternetAccessValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	destinationNat := types.MapValueMust(
		DestinationNatType{
			basetypes.ObjectType{
				AttrTypes: DestinationNatValue{}.AttributeTypes(ctx),
			},
		},
		v.DestinationNat.Elements(),
	)

	if v.DestinationNat.IsNull() {
		destinationNat = types.MapNull(
			DestinationNatType{
				basetypes.ObjectType{
					AttrTypes: DestinationNatValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.DestinationNat.IsUnknown() {
		destinationNat = types.MapUnknown(
			DestinationNatType{
				basetypes.ObjectType{
					AttrTypes: DestinationNatValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	staticNat := types.MapValueMust(
		StaticNatType{
			basetypes.ObjectType{
				AttrTypes: StaticNatValue{}.AttributeTypes(ctx),
			},
		},
		v.StaticNat.Elements(),
	)

	if v.StaticNat.IsNull() {
		staticNat = types.MapNull(
			StaticNatType{
				basetypes.ObjectType{
					AttrTypes: StaticNatValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.StaticNat.IsUnknown() {
		staticNat = types.MapUnknown(
			StaticNatType{
				basetypes.ObjectType{
					AttrTypes: StaticNatValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"create_simple_service_policy": basetypes.BoolType{},
		"destination_nat": basetypes.MapType{
			ElemType: DestinationNatValue{}.Type(ctx),
		},
		"enabled":    basetypes.BoolType{},
		"restricted": basetypes.BoolType{},
		"static_nat": basetypes.MapType{
			ElemType: StaticNatValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"create_simple_service_policy": v.CreateSimpleServicePolicy,
			"destination_nat":              destinationNat,
			"enabled":                      v.Enabled,
			"restricted":                   v.Restricted,
			"static_nat":                   staticNat,
		})

	return objVal, diags
}

func (v InternetAccessValue) Equal(o attr.Value) bool {
	other, ok := o.(InternetAccessValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.CreateSimpleServicePolicy.Equal(other.CreateSimpleServicePolicy) {
		return false
	}

	if !v.DestinationNat.Equal(other.DestinationNat) {
		return false
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.Restricted.Equal(other.Restricted) {
		return false
	}

	if !v.StaticNat.Equal(other.StaticNat) {
		return false
	}

	return true
}

func (v InternetAccessValue) Type(ctx context.Context) attr.Type {
	return InternetAccessType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v InternetAccessValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"create_simple_service_policy": basetypes.BoolType{},
		"destination_nat": basetypes.MapType{
			ElemType: DestinationNatValue{}.Type(ctx),
		},
		"enabled":    basetypes.BoolType{},
		"restricted": basetypes.BoolType{},
		"static_nat": basetypes.MapType{
			ElemType: StaticNatValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = DestinationNatType{}

type DestinationNatType struct {
	basetypes.ObjectType
}

func (t DestinationNatType) Equal(o attr.Type) bool {
	other, ok := o.(DestinationNatType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t DestinationNatType) String() string {
	return "DestinationNatType"
}

func (t DestinationNatType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	internalIpAttribute, ok := attributes["internal_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`internal_ip is missing from object`)

		return nil, diags
	}

	internalIpVal, ok := internalIpAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`internal_ip expected to be basetypes.StringValue, was: %T`, internalIpAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	portAttribute, ok := attributes["port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port is missing from object`)

		return nil, diags
	}

	portVal, ok := portAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port expected to be basetypes.Int64Value, was: %T`, portAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return DestinationNatValue{
		InternalIp: internalIpVal,
		Name:       nameVal,
		Port:       portVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewDestinationNatValueNull() DestinationNatValue {
	return DestinationNatValue{
		state: attr.ValueStateNull,
	}
}

func NewDestinationNatValueUnknown() DestinationNatValue {
	return DestinationNatValue{
		state: attr.ValueStateUnknown,
	}
}

func NewDestinationNatValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (DestinationNatValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing DestinationNatValue Attribute Value",
				"While creating a DestinationNatValue value, a missing attribute value was detected. "+
					"A DestinationNatValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DestinationNatValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid DestinationNatValue Attribute Type",
				"While creating a DestinationNatValue value, an invalid attribute value was detected. "+
					"A DestinationNatValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DestinationNatValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("DestinationNatValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra DestinationNatValue Attribute Value",
				"While creating a DestinationNatValue value, an extra attribute value was detected. "+
					"A DestinationNatValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra DestinationNatValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewDestinationNatValueUnknown(), diags
	}

	internalIpAttribute, ok := attributes["internal_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`internal_ip is missing from object`)

		return NewDestinationNatValueUnknown(), diags
	}

	internalIpVal, ok := internalIpAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`internal_ip expected to be basetypes.StringValue, was: %T`, internalIpAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewDestinationNatValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	portAttribute, ok := attributes["port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port is missing from object`)

		return NewDestinationNatValueUnknown(), diags
	}

	portVal, ok := portAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port expected to be basetypes.Int64Value, was: %T`, portAttribute))
	}

	if diags.HasError() {
		return NewDestinationNatValueUnknown(), diags
	}

	return DestinationNatValue{
		InternalIp: internalIpVal,
		Name:       nameVal,
		Port:       portVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewDestinationNatValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) DestinationNatValue {
	object, diags := NewDestinationNatValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewDestinationNatValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t DestinationNatType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewDestinationNatValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewDestinationNatValueUnknown(), nil
	}

	if in.IsNull() {
		return NewDestinationNatValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewDestinationNatValueMust(DestinationNatValue{}.AttributeTypes(ctx), attributes), nil
}

func (t DestinationNatType) ValueType(ctx context.Context) attr.Value {
	return DestinationNatValue{}
}

var _ basetypes.ObjectValuable = DestinationNatValue{}

type DestinationNatValue struct {
	InternalIp basetypes.StringValue `tfsdk:"internal_ip"`
	Name       basetypes.StringValue `tfsdk:"name"`
	Port       basetypes.Int64Value  `tfsdk:"port"`
	state      attr.ValueState
}

func (v DestinationNatValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["internal_ip"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["port"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.InternalIp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["internal_ip"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Port.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v DestinationNatValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v DestinationNatValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v DestinationNatValue) String() string {
	return "DestinationNatValue"
}

func (v DestinationNatValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"internal_ip": basetypes.StringType{},
		"name":        basetypes.StringType{},
		"port":        basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"internal_ip": v.InternalIp,
			"name":        v.Name,
			"port":        v.Port,
		})

	return objVal, diags
}

func (v DestinationNatValue) Equal(o attr.Value) bool {
	other, ok := o.(DestinationNatValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.InternalIp.Equal(other.InternalIp) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Port.Equal(other.Port) {
		return false
	}

	return true
}

func (v DestinationNatValue) Type(ctx context.Context) attr.Type {
	return DestinationNatType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v DestinationNatValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"internal_ip": basetypes.StringType{},
		"name":        basetypes.StringType{},
		"port":        basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = StaticNatType{}

type StaticNatType struct {
	basetypes.ObjectType
}

func (t StaticNatType) Equal(o attr.Type) bool {
	other, ok := o.(StaticNatType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t StaticNatType) String() string {
	return "StaticNatType"
}

func (t StaticNatType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	internalIpAttribute, ok := attributes["internal_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`internal_ip is missing from object`)

		return nil, diags
	}

	internalIpVal, ok := internalIpAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`internal_ip expected to be basetypes.StringValue, was: %T`, internalIpAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	wanNameAttribute, ok := attributes["wan_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wan_name is missing from object`)

		return nil, diags
	}

	wanNameVal, ok := wanNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wan_name expected to be basetypes.StringValue, was: %T`, wanNameAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return StaticNatValue{
		InternalIp: internalIpVal,
		Name:       nameVal,
		WanName:    wanNameVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewStaticNatValueNull() StaticNatValue {
	return StaticNatValue{
		state: attr.ValueStateNull,
	}
}

func NewStaticNatValueUnknown() StaticNatValue {
	return StaticNatValue{
		state: attr.ValueStateUnknown,
	}
}

func NewStaticNatValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (StaticNatValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing StaticNatValue Attribute Value",
				"While creating a StaticNatValue value, a missing attribute value was detected. "+
					"A StaticNatValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StaticNatValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid StaticNatValue Attribute Type",
				"While creating a StaticNatValue value, an invalid attribute value was detected. "+
					"A StaticNatValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StaticNatValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("StaticNatValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra StaticNatValue Attribute Value",
				"While creating a StaticNatValue value, an extra attribute value was detected. "+
					"A StaticNatValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra StaticNatValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewStaticNatValueUnknown(), diags
	}

	internalIpAttribute, ok := attributes["internal_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`internal_ip is missing from object`)

		return NewStaticNatValueUnknown(), diags
	}

	internalIpVal, ok := internalIpAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`internal_ip expected to be basetypes.StringValue, was: %T`, internalIpAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewStaticNatValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	wanNameAttribute, ok := attributes["wan_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wan_name is missing from object`)

		return NewStaticNatValueUnknown(), diags
	}

	wanNameVal, ok := wanNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wan_name expected to be basetypes.StringValue, was: %T`, wanNameAttribute))
	}

	if diags.HasError() {
		return NewStaticNatValueUnknown(), diags
	}

	return StaticNatValue{
		InternalIp: internalIpVal,
		Name:       nameVal,
		WanName:    wanNameVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewStaticNatValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) StaticNatValue {
	object, diags := NewStaticNatValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewStaticNatValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t StaticNatType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewStaticNatValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewStaticNatValueUnknown(), nil
	}

	if in.IsNull() {
		return NewStaticNatValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewStaticNatValueMust(StaticNatValue{}.AttributeTypes(ctx), attributes), nil
}

func (t StaticNatType) ValueType(ctx context.Context) attr.Value {
	return StaticNatValue{}
}

var _ basetypes.ObjectValuable = StaticNatValue{}

type StaticNatValue struct {
	InternalIp basetypes.StringValue `tfsdk:"internal_ip"`
	Name       basetypes.StringValue `tfsdk:"name"`
	WanName    basetypes.StringValue `tfsdk:"wan_name"`
	state      attr.ValueState
}

func (v StaticNatValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["internal_ip"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["wan_name"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.InternalIp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["internal_ip"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.WanName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["wan_name"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v StaticNatValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v StaticNatValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v StaticNatValue) String() string {
	return "StaticNatValue"
}

func (v StaticNatValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"internal_ip": basetypes.StringType{},
		"name":        basetypes.StringType{},
		"wan_name":    basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"internal_ip": v.InternalIp,
			"name":        v.Name,
			"wan_name":    v.WanName,
		})

	return objVal, diags
}

func (v StaticNatValue) Equal(o attr.Value) bool {
	other, ok := o.(StaticNatValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.InternalIp.Equal(other.InternalIp) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.WanName.Equal(other.WanName) {
		return false
	}

	return true
}

func (v StaticNatValue) Type(ctx context.Context) attr.Type {
	return StaticNatType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v StaticNatValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"internal_ip": basetypes.StringType{},
		"name":        basetypes.StringType{},
		"wan_name":    basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = TenantsType{}

type TenantsType struct {
	basetypes.ObjectType
}

func (t TenantsType) Equal(o attr.Type) bool {
	other, ok := o.(TenantsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t TenantsType) String() string {
	return "TenantsType"
}

func (t TenantsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	addressesAttribute, ok := attributes["addresses"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`addresses is missing from object`)

		return nil, diags
	}

	addressesVal, ok := addressesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`addresses expected to be basetypes.ListValue, was: %T`, addressesAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return TenantsValue{
		Addresses: addressesVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewTenantsValueNull() TenantsValue {
	return TenantsValue{
		state: attr.ValueStateNull,
	}
}

func NewTenantsValueUnknown() TenantsValue {
	return TenantsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewTenantsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (TenantsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing TenantsValue Attribute Value",
				"While creating a TenantsValue value, a missing attribute value was detected. "+
					"A TenantsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TenantsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid TenantsValue Attribute Type",
				"While creating a TenantsValue value, an invalid attribute value was detected. "+
					"A TenantsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TenantsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("TenantsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra TenantsValue Attribute Value",
				"While creating a TenantsValue value, an extra attribute value was detected. "+
					"A TenantsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra TenantsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewTenantsValueUnknown(), diags
	}

	addressesAttribute, ok := attributes["addresses"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`addresses is missing from object`)

		return NewTenantsValueUnknown(), diags
	}

	addressesVal, ok := addressesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`addresses expected to be basetypes.ListValue, was: %T`, addressesAttribute))
	}

	if diags.HasError() {
		return NewTenantsValueUnknown(), diags
	}

	return TenantsValue{
		Addresses: addressesVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewTenantsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) TenantsValue {
	object, diags := NewTenantsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewTenantsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t TenantsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewTenantsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewTenantsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewTenantsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewTenantsValueMust(TenantsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t TenantsType) ValueType(ctx context.Context) attr.Value {
	return TenantsValue{}
}

var _ basetypes.ObjectValuable = TenantsValue{}

type TenantsValue struct {
	Addresses basetypes.ListValue `tfsdk:"addresses"`
	state     attr.ValueState
}

func (v TenantsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["addresses"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Addresses.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["addresses"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v TenantsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v TenantsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v TenantsValue) String() string {
	return "TenantsValue"
}

func (v TenantsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	addressesVal, d := types.ListValue(types.StringType, v.Addresses.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"addresses": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"addresses": basetypes.ListType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"addresses": addressesVal,
		})

	return objVal, diags
}

func (v TenantsValue) Equal(o attr.Value) bool {
	other, ok := o.(TenantsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Addresses.Equal(other.Addresses) {
		return false
	}

	return true
}

func (v TenantsValue) Type(ctx context.Context) attr.Type {
	return TenantsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v TenantsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"addresses": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = VpnAccessType{}

type VpnAccessType struct {
	basetypes.ObjectType
}

func (t VpnAccessType) Equal(o attr.Type) bool {
	other, ok := o.(VpnAccessType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t VpnAccessType) String() string {
	return "VpnAccessType"
}

func (t VpnAccessType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	advertisedSubnetAttribute, ok := attributes["advertised_subnet"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`advertised_subnet is missing from object`)

		return nil, diags
	}

	advertisedSubnetVal, ok := advertisedSubnetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`advertised_subnet expected to be basetypes.StringValue, was: %T`, advertisedSubnetAttribute))
	}

	allowPingAttribute, ok := attributes["allow_ping"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allow_ping is missing from object`)

		return nil, diags
	}

	allowPingVal, ok := allowPingAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allow_ping expected to be basetypes.BoolValue, was: %T`, allowPingAttribute))
	}

	destinationNatAttribute, ok := attributes["destination_nat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`destination_nat is missing from object`)

		return nil, diags
	}

	destinationNatVal, ok := destinationNatAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`destination_nat expected to be basetypes.MapValue, was: %T`, destinationNatAttribute))
	}

	natPoolAttribute, ok := attributes["nat_pool"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`nat_pool is missing from object`)

		return nil, diags
	}

	natPoolVal, ok := natPoolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`nat_pool expected to be basetypes.StringValue, was: %T`, natPoolAttribute))
	}

	noReadvertiseToLanBgpAttribute, ok := attributes["no_readvertise_to_lan_bgp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`no_readvertise_to_lan_bgp is missing from object`)

		return nil, diags
	}

	noReadvertiseToLanBgpVal, ok := noReadvertiseToLanBgpAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`no_readvertise_to_lan_bgp expected to be basetypes.BoolValue, was: %T`, noReadvertiseToLanBgpAttribute))
	}

	noReadvertiseToLanOspfAttribute, ok := attributes["no_readvertise_to_lan_ospf"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`no_readvertise_to_lan_ospf is missing from object`)

		return nil, diags
	}

	noReadvertiseToLanOspfVal, ok := noReadvertiseToLanOspfAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`no_readvertise_to_lan_ospf expected to be basetypes.BoolValue, was: %T`, noReadvertiseToLanOspfAttribute))
	}

	noReadvertiseToOverlayAttribute, ok := attributes["no_readvertise_to_overlay"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`no_readvertise_to_overlay is missing from object`)

		return nil, diags
	}

	noReadvertiseToOverlayVal, ok := noReadvertiseToOverlayAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`no_readvertise_to_overlay expected to be basetypes.BoolValue, was: %T`, noReadvertiseToOverlayAttribute))
	}

	otherVrfsAttribute, ok := attributes["other_vrfs"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`other_vrfs is missing from object`)

		return nil, diags
	}

	otherVrfsVal, ok := otherVrfsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`other_vrfs expected to be basetypes.ListValue, was: %T`, otherVrfsAttribute))
	}

	routedAttribute, ok := attributes["routed"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`routed is missing from object`)

		return nil, diags
	}

	routedVal, ok := routedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`routed expected to be basetypes.BoolValue, was: %T`, routedAttribute))
	}

	sourceNatAttribute, ok := attributes["source_nat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`source_nat is missing from object`)

		return nil, diags
	}

	sourceNatVal, ok := sourceNatAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`source_nat expected to be basetypes.ObjectValue, was: %T`, sourceNatAttribute))
	}

	staticNatAttribute, ok := attributes["static_nat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`static_nat is missing from object`)

		return nil, diags
	}

	staticNatVal, ok := staticNatAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`static_nat expected to be basetypes.MapValue, was: %T`, staticNatAttribute))
	}

	summarizedSubnetAttribute, ok := attributes["summarized_subnet"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`summarized_subnet is missing from object`)

		return nil, diags
	}

	summarizedSubnetVal, ok := summarizedSubnetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`summarized_subnet expected to be basetypes.StringValue, was: %T`, summarizedSubnetAttribute))
	}

	summarizedSubnetToLanBgpAttribute, ok := attributes["summarized_subnet_to_lan_bgp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`summarized_subnet_to_lan_bgp is missing from object`)

		return nil, diags
	}

	summarizedSubnetToLanBgpVal, ok := summarizedSubnetToLanBgpAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`summarized_subnet_to_lan_bgp expected to be basetypes.StringValue, was: %T`, summarizedSubnetToLanBgpAttribute))
	}

	summarizedSubnetToLanOspfAttribute, ok := attributes["summarized_subnet_to_lan_ospf"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`summarized_subnet_to_lan_ospf is missing from object`)

		return nil, diags
	}

	summarizedSubnetToLanOspfVal, ok := summarizedSubnetToLanOspfAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`summarized_subnet_to_lan_ospf expected to be basetypes.StringValue, was: %T`, summarizedSubnetToLanOspfAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return VpnAccessValue{
		AdvertisedSubnet:          advertisedSubnetVal,
		AllowPing:                 allowPingVal,
		DestinationNat:            destinationNatVal,
		NatPool:                   natPoolVal,
		NoReadvertiseToLanBgp:     noReadvertiseToLanBgpVal,
		NoReadvertiseToLanOspf:    noReadvertiseToLanOspfVal,
		NoReadvertiseToOverlay:    noReadvertiseToOverlayVal,
		OtherVrfs:                 otherVrfsVal,
		Routed:                    routedVal,
		SourceNat:                 sourceNatVal,
		StaticNat:                 staticNatVal,
		SummarizedSubnet:          summarizedSubnetVal,
		SummarizedSubnetToLanBgp:  summarizedSubnetToLanBgpVal,
		SummarizedSubnetToLanOspf: summarizedSubnetToLanOspfVal,
		state:                     attr.ValueStateKnown,
	}, diags
}

func NewVpnAccessValueNull() VpnAccessValue {
	return VpnAccessValue{
		state: attr.ValueStateNull,
	}
}

func NewVpnAccessValueUnknown() VpnAccessValue {
	return VpnAccessValue{
		state: attr.ValueStateUnknown,
	}
}

func NewVpnAccessValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (VpnAccessValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing VpnAccessValue Attribute Value",
				"While creating a VpnAccessValue value, a missing attribute value was detected. "+
					"A VpnAccessValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VpnAccessValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid VpnAccessValue Attribute Type",
				"While creating a VpnAccessValue value, an invalid attribute value was detected. "+
					"A VpnAccessValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VpnAccessValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("VpnAccessValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra VpnAccessValue Attribute Value",
				"While creating a VpnAccessValue value, an extra attribute value was detected. "+
					"A VpnAccessValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra VpnAccessValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewVpnAccessValueUnknown(), diags
	}

	advertisedSubnetAttribute, ok := attributes["advertised_subnet"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`advertised_subnet is missing from object`)

		return NewVpnAccessValueUnknown(), diags
	}

	advertisedSubnetVal, ok := advertisedSubnetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`advertised_subnet expected to be basetypes.StringValue, was: %T`, advertisedSubnetAttribute))
	}

	allowPingAttribute, ok := attributes["allow_ping"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allow_ping is missing from object`)

		return NewVpnAccessValueUnknown(), diags
	}

	allowPingVal, ok := allowPingAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allow_ping expected to be basetypes.BoolValue, was: %T`, allowPingAttribute))
	}

	destinationNatAttribute, ok := attributes["destination_nat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`destination_nat is missing from object`)

		return NewVpnAccessValueUnknown(), diags
	}

	destinationNatVal, ok := destinationNatAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`destination_nat expected to be basetypes.MapValue, was: %T`, destinationNatAttribute))
	}

	natPoolAttribute, ok := attributes["nat_pool"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`nat_pool is missing from object`)

		return NewVpnAccessValueUnknown(), diags
	}

	natPoolVal, ok := natPoolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`nat_pool expected to be basetypes.StringValue, was: %T`, natPoolAttribute))
	}

	noReadvertiseToLanBgpAttribute, ok := attributes["no_readvertise_to_lan_bgp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`no_readvertise_to_lan_bgp is missing from object`)

		return NewVpnAccessValueUnknown(), diags
	}

	noReadvertiseToLanBgpVal, ok := noReadvertiseToLanBgpAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`no_readvertise_to_lan_bgp expected to be basetypes.BoolValue, was: %T`, noReadvertiseToLanBgpAttribute))
	}

	noReadvertiseToLanOspfAttribute, ok := attributes["no_readvertise_to_lan_ospf"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`no_readvertise_to_lan_ospf is missing from object`)

		return NewVpnAccessValueUnknown(), diags
	}

	noReadvertiseToLanOspfVal, ok := noReadvertiseToLanOspfAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`no_readvertise_to_lan_ospf expected to be basetypes.BoolValue, was: %T`, noReadvertiseToLanOspfAttribute))
	}

	noReadvertiseToOverlayAttribute, ok := attributes["no_readvertise_to_overlay"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`no_readvertise_to_overlay is missing from object`)

		return NewVpnAccessValueUnknown(), diags
	}

	noReadvertiseToOverlayVal, ok := noReadvertiseToOverlayAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`no_readvertise_to_overlay expected to be basetypes.BoolValue, was: %T`, noReadvertiseToOverlayAttribute))
	}

	otherVrfsAttribute, ok := attributes["other_vrfs"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`other_vrfs is missing from object`)

		return NewVpnAccessValueUnknown(), diags
	}

	otherVrfsVal, ok := otherVrfsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`other_vrfs expected to be basetypes.ListValue, was: %T`, otherVrfsAttribute))
	}

	routedAttribute, ok := attributes["routed"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`routed is missing from object`)

		return NewVpnAccessValueUnknown(), diags
	}

	routedVal, ok := routedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`routed expected to be basetypes.BoolValue, was: %T`, routedAttribute))
	}

	sourceNatAttribute, ok := attributes["source_nat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`source_nat is missing from object`)

		return NewVpnAccessValueUnknown(), diags
	}

	sourceNatVal, ok := sourceNatAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`source_nat expected to be basetypes.ObjectValue, was: %T`, sourceNatAttribute))
	}

	staticNatAttribute, ok := attributes["static_nat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`static_nat is missing from object`)

		return NewVpnAccessValueUnknown(), diags
	}

	staticNatVal, ok := staticNatAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`static_nat expected to be basetypes.MapValue, was: %T`, staticNatAttribute))
	}

	summarizedSubnetAttribute, ok := attributes["summarized_subnet"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`summarized_subnet is missing from object`)

		return NewVpnAccessValueUnknown(), diags
	}

	summarizedSubnetVal, ok := summarizedSubnetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`summarized_subnet expected to be basetypes.StringValue, was: %T`, summarizedSubnetAttribute))
	}

	summarizedSubnetToLanBgpAttribute, ok := attributes["summarized_subnet_to_lan_bgp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`summarized_subnet_to_lan_bgp is missing from object`)

		return NewVpnAccessValueUnknown(), diags
	}

	summarizedSubnetToLanBgpVal, ok := summarizedSubnetToLanBgpAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`summarized_subnet_to_lan_bgp expected to be basetypes.StringValue, was: %T`, summarizedSubnetToLanBgpAttribute))
	}

	summarizedSubnetToLanOspfAttribute, ok := attributes["summarized_subnet_to_lan_ospf"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`summarized_subnet_to_lan_ospf is missing from object`)

		return NewVpnAccessValueUnknown(), diags
	}

	summarizedSubnetToLanOspfVal, ok := summarizedSubnetToLanOspfAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`summarized_subnet_to_lan_ospf expected to be basetypes.StringValue, was: %T`, summarizedSubnetToLanOspfAttribute))
	}

	if diags.HasError() {
		return NewVpnAccessValueUnknown(), diags
	}

	return VpnAccessValue{
		AdvertisedSubnet:          advertisedSubnetVal,
		AllowPing:                 allowPingVal,
		DestinationNat:            destinationNatVal,
		NatPool:                   natPoolVal,
		NoReadvertiseToLanBgp:     noReadvertiseToLanBgpVal,
		NoReadvertiseToLanOspf:    noReadvertiseToLanOspfVal,
		NoReadvertiseToOverlay:    noReadvertiseToOverlayVal,
		OtherVrfs:                 otherVrfsVal,
		Routed:                    routedVal,
		SourceNat:                 sourceNatVal,
		StaticNat:                 staticNatVal,
		SummarizedSubnet:          summarizedSubnetVal,
		SummarizedSubnetToLanBgp:  summarizedSubnetToLanBgpVal,
		SummarizedSubnetToLanOspf: summarizedSubnetToLanOspfVal,
		state:                     attr.ValueStateKnown,
	}, diags
}

func NewVpnAccessValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) VpnAccessValue {
	object, diags := NewVpnAccessValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewVpnAccessValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t VpnAccessType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewVpnAccessValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewVpnAccessValueUnknown(), nil
	}

	if in.IsNull() {
		return NewVpnAccessValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewVpnAccessValueMust(VpnAccessValue{}.AttributeTypes(ctx), attributes), nil
}

func (t VpnAccessType) ValueType(ctx context.Context) attr.Value {
	return VpnAccessValue{}
}

var _ basetypes.ObjectValuable = VpnAccessValue{}

type VpnAccessValue struct {
	AdvertisedSubnet          basetypes.StringValue `tfsdk:"advertised_subnet"`
	AllowPing                 basetypes.BoolValue   `tfsdk:"allow_ping"`
	DestinationNat            basetypes.MapValue    `tfsdk:"destination_nat"`
	NatPool                   basetypes.StringValue `tfsdk:"nat_pool"`
	NoReadvertiseToLanBgp     basetypes.BoolValue   `tfsdk:"no_readvertise_to_lan_bgp"`
	NoReadvertiseToLanOspf    basetypes.BoolValue   `tfsdk:"no_readvertise_to_lan_ospf"`
	NoReadvertiseToOverlay    basetypes.BoolValue   `tfsdk:"no_readvertise_to_overlay"`
	OtherVrfs                 basetypes.ListValue   `tfsdk:"other_vrfs"`
	Routed                    basetypes.BoolValue   `tfsdk:"routed"`
	SourceNat                 basetypes.ObjectValue `tfsdk:"source_nat"`
	StaticNat                 basetypes.MapValue    `tfsdk:"static_nat"`
	SummarizedSubnet          basetypes.StringValue `tfsdk:"summarized_subnet"`
	SummarizedSubnetToLanBgp  basetypes.StringValue `tfsdk:"summarized_subnet_to_lan_bgp"`
	SummarizedSubnetToLanOspf basetypes.StringValue `tfsdk:"summarized_subnet_to_lan_ospf"`
	state                     attr.ValueState
}

func (v VpnAccessValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 14)

	var val tftypes.Value
	var err error

	attrTypes["advertised_subnet"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["allow_ping"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["destination_nat"] = basetypes.MapType{
		ElemType: DestinationNatValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["nat_pool"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["no_readvertise_to_lan_bgp"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["no_readvertise_to_lan_ospf"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["no_readvertise_to_overlay"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["other_vrfs"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["routed"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["source_nat"] = basetypes.ObjectType{
		AttrTypes: SourceNatValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["static_nat"] = basetypes.MapType{
		ElemType: StaticNatValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["summarized_subnet"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["summarized_subnet_to_lan_bgp"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["summarized_subnet_to_lan_ospf"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 14)

		val, err = v.AdvertisedSubnet.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["advertised_subnet"] = val

		val, err = v.AllowPing.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["allow_ping"] = val

		val, err = v.DestinationNat.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["destination_nat"] = val

		val, err = v.NatPool.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["nat_pool"] = val

		val, err = v.NoReadvertiseToLanBgp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["no_readvertise_to_lan_bgp"] = val

		val, err = v.NoReadvertiseToLanOspf.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["no_readvertise_to_lan_ospf"] = val

		val, err = v.NoReadvertiseToOverlay.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["no_readvertise_to_overlay"] = val

		val, err = v.OtherVrfs.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["other_vrfs"] = val

		val, err = v.Routed.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["routed"] = val

		val, err = v.SourceNat.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["source_nat"] = val

		val, err = v.StaticNat.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["static_nat"] = val

		val, err = v.SummarizedSubnet.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["summarized_subnet"] = val

		val, err = v.SummarizedSubnetToLanBgp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["summarized_subnet_to_lan_bgp"] = val

		val, err = v.SummarizedSubnetToLanOspf.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["summarized_subnet_to_lan_ospf"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v VpnAccessValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v VpnAccessValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v VpnAccessValue) String() string {
	return "VpnAccessValue"
}

func (v VpnAccessValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	destinationNat := types.MapValueMust(
		DestinationNatType{
			basetypes.ObjectType{
				AttrTypes: DestinationNatValue{}.AttributeTypes(ctx),
			},
		},
		v.DestinationNat.Elements(),
	)

	if v.DestinationNat.IsNull() {
		destinationNat = types.MapNull(
			DestinationNatType{
				basetypes.ObjectType{
					AttrTypes: DestinationNatValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.DestinationNat.IsUnknown() {
		destinationNat = types.MapUnknown(
			DestinationNatType{
				basetypes.ObjectType{
					AttrTypes: DestinationNatValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var sourceNat basetypes.ObjectValue

	if v.SourceNat.IsNull() {
		sourceNat = types.ObjectNull(
			SourceNatValue{}.AttributeTypes(ctx),
		)
	}

	if v.SourceNat.IsUnknown() {
		sourceNat = types.ObjectUnknown(
			SourceNatValue{}.AttributeTypes(ctx),
		)
	}

	if !v.SourceNat.IsNull() && !v.SourceNat.IsUnknown() {
		sourceNat = types.ObjectValueMust(
			SourceNatValue{}.AttributeTypes(ctx),
			v.SourceNat.Attributes(),
		)
	}

	staticNat := types.MapValueMust(
		StaticNatType{
			basetypes.ObjectType{
				AttrTypes: StaticNatValue{}.AttributeTypes(ctx),
			},
		},
		v.StaticNat.Elements(),
	)

	if v.StaticNat.IsNull() {
		staticNat = types.MapNull(
			StaticNatType{
				basetypes.ObjectType{
					AttrTypes: StaticNatValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.StaticNat.IsUnknown() {
		staticNat = types.MapUnknown(
			StaticNatType{
				basetypes.ObjectType{
					AttrTypes: StaticNatValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	otherVrfsVal, d := types.ListValue(types.StringType, v.OtherVrfs.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"advertised_subnet": basetypes.StringType{},
			"allow_ping":        basetypes.BoolType{},
			"destination_nat": basetypes.MapType{
				ElemType: DestinationNatValue{}.Type(ctx),
			},
			"nat_pool":                   basetypes.StringType{},
			"no_readvertise_to_lan_bgp":  basetypes.BoolType{},
			"no_readvertise_to_lan_ospf": basetypes.BoolType{},
			"no_readvertise_to_overlay":  basetypes.BoolType{},
			"other_vrfs": basetypes.ListType{
				ElemType: types.StringType,
			},
			"routed": basetypes.BoolType{},
			"source_nat": basetypes.ObjectType{
				AttrTypes: SourceNatValue{}.AttributeTypes(ctx),
			},
			"static_nat": basetypes.MapType{
				ElemType: StaticNatValue{}.Type(ctx),
			},
			"summarized_subnet":             basetypes.StringType{},
			"summarized_subnet_to_lan_bgp":  basetypes.StringType{},
			"summarized_subnet_to_lan_ospf": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"advertised_subnet": basetypes.StringType{},
		"allow_ping":        basetypes.BoolType{},
		"destination_nat": basetypes.MapType{
			ElemType: DestinationNatValue{}.Type(ctx),
		},
		"nat_pool":                   basetypes.StringType{},
		"no_readvertise_to_lan_bgp":  basetypes.BoolType{},
		"no_readvertise_to_lan_ospf": basetypes.BoolType{},
		"no_readvertise_to_overlay":  basetypes.BoolType{},
		"other_vrfs": basetypes.ListType{
			ElemType: types.StringType,
		},
		"routed": basetypes.BoolType{},
		"source_nat": basetypes.ObjectType{
			AttrTypes: SourceNatValue{}.AttributeTypes(ctx),
		},
		"static_nat": basetypes.MapType{
			ElemType: StaticNatValue{}.Type(ctx),
		},
		"summarized_subnet":             basetypes.StringType{},
		"summarized_subnet_to_lan_bgp":  basetypes.StringType{},
		"summarized_subnet_to_lan_ospf": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"advertised_subnet":             v.AdvertisedSubnet,
			"allow_ping":                    v.AllowPing,
			"destination_nat":               destinationNat,
			"nat_pool":                      v.NatPool,
			"no_readvertise_to_lan_bgp":     v.NoReadvertiseToLanBgp,
			"no_readvertise_to_lan_ospf":    v.NoReadvertiseToLanOspf,
			"no_readvertise_to_overlay":     v.NoReadvertiseToOverlay,
			"other_vrfs":                    otherVrfsVal,
			"routed":                        v.Routed,
			"source_nat":                    sourceNat,
			"static_nat":                    staticNat,
			"summarized_subnet":             v.SummarizedSubnet,
			"summarized_subnet_to_lan_bgp":  v.SummarizedSubnetToLanBgp,
			"summarized_subnet_to_lan_ospf": v.SummarizedSubnetToLanOspf,
		})

	return objVal, diags
}

func (v VpnAccessValue) Equal(o attr.Value) bool {
	other, ok := o.(VpnAccessValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AdvertisedSubnet.Equal(other.AdvertisedSubnet) {
		return false
	}

	if !v.AllowPing.Equal(other.AllowPing) {
		return false
	}

	if !v.DestinationNat.Equal(other.DestinationNat) {
		return false
	}

	if !v.NatPool.Equal(other.NatPool) {
		return false
	}

	if !v.NoReadvertiseToLanBgp.Equal(other.NoReadvertiseToLanBgp) {
		return false
	}

	if !v.NoReadvertiseToLanOspf.Equal(other.NoReadvertiseToLanOspf) {
		return false
	}

	if !v.NoReadvertiseToOverlay.Equal(other.NoReadvertiseToOverlay) {
		return false
	}

	if !v.OtherVrfs.Equal(other.OtherVrfs) {
		return false
	}

	if !v.Routed.Equal(other.Routed) {
		return false
	}

	if !v.SourceNat.Equal(other.SourceNat) {
		return false
	}

	if !v.StaticNat.Equal(other.StaticNat) {
		return false
	}

	if !v.SummarizedSubnet.Equal(other.SummarizedSubnet) {
		return false
	}

	if !v.SummarizedSubnetToLanBgp.Equal(other.SummarizedSubnetToLanBgp) {
		return false
	}

	if !v.SummarizedSubnetToLanOspf.Equal(other.SummarizedSubnetToLanOspf) {
		return false
	}

	return true
}

func (v VpnAccessValue) Type(ctx context.Context) attr.Type {
	return VpnAccessType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v VpnAccessValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"advertised_subnet": basetypes.StringType{},
		"allow_ping":        basetypes.BoolType{},
		"destination_nat": basetypes.MapType{
			ElemType: DestinationNatValue{}.Type(ctx),
		},
		"nat_pool":                   basetypes.StringType{},
		"no_readvertise_to_lan_bgp":  basetypes.BoolType{},
		"no_readvertise_to_lan_ospf": basetypes.BoolType{},
		"no_readvertise_to_overlay":  basetypes.BoolType{},
		"other_vrfs": basetypes.ListType{
			ElemType: types.StringType,
		},
		"routed": basetypes.BoolType{},
		"source_nat": basetypes.ObjectType{
			AttrTypes: SourceNatValue{}.AttributeTypes(ctx),
		},
		"static_nat": basetypes.MapType{
			ElemType: StaticNatValue{}.Type(ctx),
		},
		"summarized_subnet":             basetypes.StringType{},
		"summarized_subnet_to_lan_bgp":  basetypes.StringType{},
		"summarized_subnet_to_lan_ospf": basetypes.StringType{},
	}
}






















var _ basetypes.ObjectTypable = SourceNatType{}

type SourceNatType struct {
	basetypes.ObjectType
}

func (t SourceNatType) Equal(o attr.Type) bool {
	other, ok := o.(SourceNatType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SourceNatType) String() string {
	return "SourceNatType"
}

func (t SourceNatType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	exteralIpAttribute, ok := attributes["exteral_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`exteral_ip is missing from object`)

		return nil, diags
	}

	exteralIpVal, ok := exteralIpAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`exteral_ip expected to be basetypes.StringValue, was: %T`, exteralIpAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SourceNatValue{
		ExteralIp: exteralIpVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewSourceNatValueNull() SourceNatValue {
	return SourceNatValue{
		state: attr.ValueStateNull,
	}
}

func NewSourceNatValueUnknown() SourceNatValue {
	return SourceNatValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSourceNatValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SourceNatValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SourceNatValue Attribute Value",
				"While creating a SourceNatValue value, a missing attribute value was detected. "+
					"A SourceNatValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SourceNatValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SourceNatValue Attribute Type",
				"While creating a SourceNatValue value, an invalid attribute value was detected. "+
					"A SourceNatValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SourceNatValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SourceNatValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SourceNatValue Attribute Value",
				"While creating a SourceNatValue value, an extra attribute value was detected. "+
					"A SourceNatValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SourceNatValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSourceNatValueUnknown(), diags
	}

	exteralIpAttribute, ok := attributes["exteral_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`exteral_ip is missing from object`)

		return NewSourceNatValueUnknown(), diags
	}

	exteralIpVal, ok := exteralIpAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`exteral_ip expected to be basetypes.StringValue, was: %T`, exteralIpAttribute))
	}

	if diags.HasError() {
		return NewSourceNatValueUnknown(), diags
	}

	return SourceNatValue{
		ExteralIp: exteralIpVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewSourceNatValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SourceNatValue {
	object, diags := NewSourceNatValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSourceNatValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SourceNatType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSourceNatValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSourceNatValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSourceNatValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSourceNatValueMust(SourceNatValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SourceNatType) ValueType(ctx context.Context) attr.Value {
	return SourceNatValue{}
}

var _ basetypes.ObjectValuable = SourceNatValue{}

type SourceNatValue struct {
	ExteralIp basetypes.StringValue `tfsdk:"exteral_ip"`
	state     attr.ValueState
}

func (v SourceNatValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["exteral_ip"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.ExteralIp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["exteral_ip"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SourceNatValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SourceNatValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SourceNatValue) String() string {
	return "SourceNatValue"
}

func (v SourceNatValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"exteral_ip": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"exteral_ip": v.ExteralIp,
		})

	return objVal, diags
}

func (v SourceNatValue) Equal(o attr.Value) bool {
	other, ok := o.(SourceNatValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.ExteralIp.Equal(other.ExteralIp) {
		return false
	}

	return true
}

func (v SourceNatValue) Type(ctx context.Context) attr.Type {
	return SourceNatType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SourceNatValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"exteral_ip": basetypes.StringType{},
	}
}






















var _ basetypes.ObjectTypable = OobIpConfigType{}

type OobIpConfigType struct {
	basetypes.ObjectType
}

func (t OobIpConfigType) Equal(o attr.Type) bool {
	other, ok := o.(OobIpConfigType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t OobIpConfigType) String() string {
	return "OobIpConfigType"
}

func (t OobIpConfigType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	ipAttribute, ok := attributes["ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip is missing from object`)

		return nil, diags
	}

	ipVal, ok := ipAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip expected to be basetypes.StringValue, was: %T`, ipAttribute))
	}

	netmaskAttribute, ok := attributes["netmask"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`netmask is missing from object`)

		return nil, diags
	}

	netmaskVal, ok := netmaskAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`netmask expected to be basetypes.StringValue, was: %T`, netmaskAttribute))
	}

	networkAttribute, ok := attributes["network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`network is missing from object`)

		return nil, diags
	}

	networkVal, ok := networkAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`network expected to be basetypes.StringValue, was: %T`, networkAttribute))
	}

	node1Attribute, ok := attributes["node1"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node1 is missing from object`)

		return nil, diags
	}

	node1Val, ok := node1Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node1 expected to be basetypes.ObjectValue, was: %T`, node1Attribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	useMgmtVrfAttribute, ok := attributes["use_mgmt_vrf"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`use_mgmt_vrf is missing from object`)

		return nil, diags
	}

	useMgmtVrfVal, ok := useMgmtVrfAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`use_mgmt_vrf expected to be basetypes.BoolValue, was: %T`, useMgmtVrfAttribute))
	}

	useMgmtVrfForHostOutAttribute, ok := attributes["use_mgmt_vrf_for_host_out"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`use_mgmt_vrf_for_host_out is missing from object`)

		return nil, diags
	}

	useMgmtVrfForHostOutVal, ok := useMgmtVrfForHostOutAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`use_mgmt_vrf_for_host_out expected to be basetypes.BoolValue, was: %T`, useMgmtVrfForHostOutAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return OobIpConfigValue{
		Ip:                   ipVal,
		Netmask:              netmaskVal,
		Network:              networkVal,
		Node1:                node1Val,
		OobIpConfigType:      typeVal,
		UseMgmtVrf:           useMgmtVrfVal,
		UseMgmtVrfForHostOut: useMgmtVrfForHostOutVal,
		state:                attr.ValueStateKnown,
	}, diags
}

func NewOobIpConfigValueNull() OobIpConfigValue {
	return OobIpConfigValue{
		state: attr.ValueStateNull,
	}
}

func NewOobIpConfigValueUnknown() OobIpConfigValue {
	return OobIpConfigValue{
		state: attr.ValueStateUnknown,
	}
}

func NewOobIpConfigValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (OobIpConfigValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing OobIpConfigValue Attribute Value",
				"While creating a OobIpConfigValue value, a missing attribute value was detected. "+
					"A OobIpConfigValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OobIpConfigValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid OobIpConfigValue Attribute Type",
				"While creating a OobIpConfigValue value, an invalid attribute value was detected. "+
					"A OobIpConfigValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OobIpConfigValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("OobIpConfigValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra OobIpConfigValue Attribute Value",
				"While creating a OobIpConfigValue value, an extra attribute value was detected. "+
					"A OobIpConfigValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra OobIpConfigValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewOobIpConfigValueUnknown(), diags
	}

	ipAttribute, ok := attributes["ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip is missing from object`)

		return NewOobIpConfigValueUnknown(), diags
	}

	ipVal, ok := ipAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip expected to be basetypes.StringValue, was: %T`, ipAttribute))
	}

	netmaskAttribute, ok := attributes["netmask"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`netmask is missing from object`)

		return NewOobIpConfigValueUnknown(), diags
	}

	netmaskVal, ok := netmaskAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`netmask expected to be basetypes.StringValue, was: %T`, netmaskAttribute))
	}

	networkAttribute, ok := attributes["network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`network is missing from object`)

		return NewOobIpConfigValueUnknown(), diags
	}

	networkVal, ok := networkAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`network expected to be basetypes.StringValue, was: %T`, networkAttribute))
	}

	node1Attribute, ok := attributes["node1"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node1 is missing from object`)

		return NewOobIpConfigValueUnknown(), diags
	}

	node1Val, ok := node1Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node1 expected to be basetypes.ObjectValue, was: %T`, node1Attribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewOobIpConfigValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	useMgmtVrfAttribute, ok := attributes["use_mgmt_vrf"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`use_mgmt_vrf is missing from object`)

		return NewOobIpConfigValueUnknown(), diags
	}

	useMgmtVrfVal, ok := useMgmtVrfAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`use_mgmt_vrf expected to be basetypes.BoolValue, was: %T`, useMgmtVrfAttribute))
	}

	useMgmtVrfForHostOutAttribute, ok := attributes["use_mgmt_vrf_for_host_out"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`use_mgmt_vrf_for_host_out is missing from object`)

		return NewOobIpConfigValueUnknown(), diags
	}

	useMgmtVrfForHostOutVal, ok := useMgmtVrfForHostOutAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`use_mgmt_vrf_for_host_out expected to be basetypes.BoolValue, was: %T`, useMgmtVrfForHostOutAttribute))
	}

	if diags.HasError() {
		return NewOobIpConfigValueUnknown(), diags
	}

	return OobIpConfigValue{
		Ip:                   ipVal,
		Netmask:              netmaskVal,
		Network:              networkVal,
		Node1:                node1Val,
		OobIpConfigType:      typeVal,
		UseMgmtVrf:           useMgmtVrfVal,
		UseMgmtVrfForHostOut: useMgmtVrfForHostOutVal,
		state:                attr.ValueStateKnown,
	}, diags
}

func NewOobIpConfigValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) OobIpConfigValue {
	object, diags := NewOobIpConfigValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewOobIpConfigValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t OobIpConfigType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewOobIpConfigValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewOobIpConfigValueUnknown(), nil
	}

	if in.IsNull() {
		return NewOobIpConfigValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewOobIpConfigValueMust(OobIpConfigValue{}.AttributeTypes(ctx), attributes), nil
}

func (t OobIpConfigType) ValueType(ctx context.Context) attr.Value {
	return OobIpConfigValue{}
}

var _ basetypes.ObjectValuable = OobIpConfigValue{}

type OobIpConfigValue struct {
	Ip                   basetypes.StringValue `tfsdk:"ip"`
	Netmask              basetypes.StringValue `tfsdk:"netmask"`
	Network              basetypes.StringValue `tfsdk:"network"`
	Node1                basetypes.ObjectValue `tfsdk:"node1"`
	OobIpConfigType      basetypes.StringValue `tfsdk:"type"`
	UseMgmtVrf           basetypes.BoolValue   `tfsdk:"use_mgmt_vrf"`
	UseMgmtVrfForHostOut basetypes.BoolValue   `tfsdk:"use_mgmt_vrf_for_host_out"`
	state                attr.ValueState
}

func (v OobIpConfigValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 7)

	var val tftypes.Value
	var err error

	attrTypes["ip"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["netmask"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["network"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["node1"] = basetypes.ObjectType{
		AttrTypes: Node1Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["use_mgmt_vrf"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["use_mgmt_vrf_for_host_out"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 7)

		val, err = v.Ip.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip"] = val

		val, err = v.Netmask.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["netmask"] = val

		val, err = v.Network.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["network"] = val

		val, err = v.Node1.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["node1"] = val

		val, err = v.OobIpConfigType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		val, err = v.UseMgmtVrf.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["use_mgmt_vrf"] = val

		val, err = v.UseMgmtVrfForHostOut.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["use_mgmt_vrf_for_host_out"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v OobIpConfigValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v OobIpConfigValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v OobIpConfigValue) String() string {
	return "OobIpConfigValue"
}

func (v OobIpConfigValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var node1 basetypes.ObjectValue

	if v.Node1.IsNull() {
		node1 = types.ObjectNull(
			Node1Value{}.AttributeTypes(ctx),
		)
	}

	if v.Node1.IsUnknown() {
		node1 = types.ObjectUnknown(
			Node1Value{}.AttributeTypes(ctx),
		)
	}

	if !v.Node1.IsNull() && !v.Node1.IsUnknown() {
		node1 = types.ObjectValueMust(
			Node1Value{}.AttributeTypes(ctx),
			v.Node1.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"ip":      basetypes.StringType{},
		"netmask": basetypes.StringType{},
		"network": basetypes.StringType{},
		"node1": basetypes.ObjectType{
			AttrTypes: Node1Value{}.AttributeTypes(ctx),
		},
		"type":                      basetypes.StringType{},
		"use_mgmt_vrf":              basetypes.BoolType{},
		"use_mgmt_vrf_for_host_out": basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"ip":                        v.Ip,
			"netmask":                   v.Netmask,
			"network":                   v.Network,
			"node1":                     node1,
			"type":                      v.OobIpConfigType,
			"use_mgmt_vrf":              v.UseMgmtVrf,
			"use_mgmt_vrf_for_host_out": v.UseMgmtVrfForHostOut,
		})

	return objVal, diags
}

func (v OobIpConfigValue) Equal(o attr.Value) bool {
	other, ok := o.(OobIpConfigValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Ip.Equal(other.Ip) {
		return false
	}

	if !v.Netmask.Equal(other.Netmask) {
		return false
	}

	if !v.Network.Equal(other.Network) {
		return false
	}

	if !v.Node1.Equal(other.Node1) {
		return false
	}

	if !v.OobIpConfigType.Equal(other.OobIpConfigType) {
		return false
	}

	if !v.UseMgmtVrf.Equal(other.UseMgmtVrf) {
		return false
	}

	if !v.UseMgmtVrfForHostOut.Equal(other.UseMgmtVrfForHostOut) {
		return false
	}

	return true
}

func (v OobIpConfigValue) Type(ctx context.Context) attr.Type {
	return OobIpConfigType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v OobIpConfigValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"ip":      basetypes.StringType{},
		"netmask": basetypes.StringType{},
		"network": basetypes.StringType{},
		"node1": basetypes.ObjectType{
			AttrTypes: Node1Value{}.AttributeTypes(ctx),
		},
		"type":                      basetypes.StringType{},
		"use_mgmt_vrf":              basetypes.BoolType{},
		"use_mgmt_vrf_for_host_out": basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = Node1Type{}

type Node1Type struct {
	basetypes.ObjectType
}

func (t Node1Type) Equal(o attr.Type) bool {
	other, ok := o.(Node1Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Node1Type) String() string {
	return "Node1Type"
}

func (t Node1Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	ipAttribute, ok := attributes["ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip is missing from object`)

		return nil, diags
	}

	ipVal, ok := ipAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip expected to be basetypes.StringValue, was: %T`, ipAttribute))
	}

	netmaskAttribute, ok := attributes["netmask"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`netmask is missing from object`)

		return nil, diags
	}

	netmaskVal, ok := netmaskAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`netmask expected to be basetypes.StringValue, was: %T`, netmaskAttribute))
	}

	networkAttribute, ok := attributes["network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`network is missing from object`)

		return nil, diags
	}

	networkVal, ok := networkAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`network expected to be basetypes.StringValue, was: %T`, networkAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	useMgmtVrfAttribute, ok := attributes["use_mgmt_vrf"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`use_mgmt_vrf is missing from object`)

		return nil, diags
	}

	useMgmtVrfVal, ok := useMgmtVrfAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`use_mgmt_vrf expected to be basetypes.BoolValue, was: %T`, useMgmtVrfAttribute))
	}

	useMgmtVrfForHostOutAttribute, ok := attributes["use_mgmt_vrf_for_host_out"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`use_mgmt_vrf_for_host_out is missing from object`)

		return nil, diags
	}

	useMgmtVrfForHostOutVal, ok := useMgmtVrfForHostOutAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`use_mgmt_vrf_for_host_out expected to be basetypes.BoolValue, was: %T`, useMgmtVrfForHostOutAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Node1Value{
		Ip:                   ipVal,
		Netmask:              netmaskVal,
		Network:              networkVal,
		Node1Type:            typeVal,
		UseMgmtVrf:           useMgmtVrfVal,
		UseMgmtVrfForHostOut: useMgmtVrfForHostOutVal,
		state:                attr.ValueStateKnown,
	}, diags
}

func NewNode1ValueNull() Node1Value {
	return Node1Value{
		state: attr.ValueStateNull,
	}
}

func NewNode1ValueUnknown() Node1Value {
	return Node1Value{
		state: attr.ValueStateUnknown,
	}
}

func NewNode1Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Node1Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Node1Value Attribute Value",
				"While creating a Node1Value value, a missing attribute value was detected. "+
					"A Node1Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Node1Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Node1Value Attribute Type",
				"While creating a Node1Value value, an invalid attribute value was detected. "+
					"A Node1Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Node1Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Node1Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Node1Value Attribute Value",
				"While creating a Node1Value value, an extra attribute value was detected. "+
					"A Node1Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Node1Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewNode1ValueUnknown(), diags
	}

	ipAttribute, ok := attributes["ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip is missing from object`)

		return NewNode1ValueUnknown(), diags
	}

	ipVal, ok := ipAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip expected to be basetypes.StringValue, was: %T`, ipAttribute))
	}

	netmaskAttribute, ok := attributes["netmask"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`netmask is missing from object`)

		return NewNode1ValueUnknown(), diags
	}

	netmaskVal, ok := netmaskAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`netmask expected to be basetypes.StringValue, was: %T`, netmaskAttribute))
	}

	networkAttribute, ok := attributes["network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`network is missing from object`)

		return NewNode1ValueUnknown(), diags
	}

	networkVal, ok := networkAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`network expected to be basetypes.StringValue, was: %T`, networkAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewNode1ValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	useMgmtVrfAttribute, ok := attributes["use_mgmt_vrf"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`use_mgmt_vrf is missing from object`)

		return NewNode1ValueUnknown(), diags
	}

	useMgmtVrfVal, ok := useMgmtVrfAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`use_mgmt_vrf expected to be basetypes.BoolValue, was: %T`, useMgmtVrfAttribute))
	}

	useMgmtVrfForHostOutAttribute, ok := attributes["use_mgmt_vrf_for_host_out"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`use_mgmt_vrf_for_host_out is missing from object`)

		return NewNode1ValueUnknown(), diags
	}

	useMgmtVrfForHostOutVal, ok := useMgmtVrfForHostOutAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`use_mgmt_vrf_for_host_out expected to be basetypes.BoolValue, was: %T`, useMgmtVrfForHostOutAttribute))
	}

	if diags.HasError() {
		return NewNode1ValueUnknown(), diags
	}

	return Node1Value{
		Ip:                   ipVal,
		Netmask:              netmaskVal,
		Network:              networkVal,
		Node1Type:            typeVal,
		UseMgmtVrf:           useMgmtVrfVal,
		UseMgmtVrfForHostOut: useMgmtVrfForHostOutVal,
		state:                attr.ValueStateKnown,
	}, diags
}

func NewNode1ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Node1Value {
	object, diags := NewNode1Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewNode1ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Node1Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewNode1ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewNode1ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewNode1ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewNode1ValueMust(Node1Value{}.AttributeTypes(ctx), attributes), nil
}

func (t Node1Type) ValueType(ctx context.Context) attr.Value {
	return Node1Value{}
}

var _ basetypes.ObjectValuable = Node1Value{}

type Node1Value struct {
	Ip                   basetypes.StringValue `tfsdk:"ip"`
	Netmask              basetypes.StringValue `tfsdk:"netmask"`
	Network              basetypes.StringValue `tfsdk:"network"`
	Node1Type            basetypes.StringValue `tfsdk:"type"`
	UseMgmtVrf           basetypes.BoolValue   `tfsdk:"use_mgmt_vrf"`
	UseMgmtVrfForHostOut basetypes.BoolValue   `tfsdk:"use_mgmt_vrf_for_host_out"`
	state                attr.ValueState
}

func (v Node1Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 6)

	var val tftypes.Value
	var err error

	attrTypes["ip"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["netmask"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["network"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["use_mgmt_vrf"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["use_mgmt_vrf_for_host_out"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 6)

		val, err = v.Ip.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip"] = val

		val, err = v.Netmask.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["netmask"] = val

		val, err = v.Network.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["network"] = val

		val, err = v.Node1Type.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		val, err = v.UseMgmtVrf.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["use_mgmt_vrf"] = val

		val, err = v.UseMgmtVrfForHostOut.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["use_mgmt_vrf_for_host_out"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Node1Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Node1Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Node1Value) String() string {
	return "Node1Value"
}

func (v Node1Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"ip":                        basetypes.StringType{},
		"netmask":                   basetypes.StringType{},
		"network":                   basetypes.StringType{},
		"type":                      basetypes.StringType{},
		"use_mgmt_vrf":              basetypes.BoolType{},
		"use_mgmt_vrf_for_host_out": basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"ip":                        v.Ip,
			"netmask":                   v.Netmask,
			"network":                   v.Network,
			"type":                      v.Node1Type,
			"use_mgmt_vrf":              v.UseMgmtVrf,
			"use_mgmt_vrf_for_host_out": v.UseMgmtVrfForHostOut,
		})

	return objVal, diags
}

func (v Node1Value) Equal(o attr.Value) bool {
	other, ok := o.(Node1Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Ip.Equal(other.Ip) {
		return false
	}

	if !v.Netmask.Equal(other.Netmask) {
		return false
	}

	if !v.Network.Equal(other.Network) {
		return false
	}

	if !v.Node1Type.Equal(other.Node1Type) {
		return false
	}

	if !v.UseMgmtVrf.Equal(other.UseMgmtVrf) {
		return false
	}

	if !v.UseMgmtVrfForHostOut.Equal(other.UseMgmtVrfForHostOut) {
		return false
	}

	return true
}

func (v Node1Value) Type(ctx context.Context) attr.Type {
	return Node1Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Node1Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"ip":                        basetypes.StringType{},
		"netmask":                   basetypes.StringType{},
		"network":                   basetypes.StringType{},
		"type":                      basetypes.StringType{},
		"use_mgmt_vrf":              basetypes.BoolType{},
		"use_mgmt_vrf_for_host_out": basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = PathPreferencesType{}

type PathPreferencesType struct {
	basetypes.ObjectType
}

func (t PathPreferencesType) Equal(o attr.Type) bool {
	other, ok := o.(PathPreferencesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PathPreferencesType) String() string {
	return "PathPreferencesType"
}

func (t PathPreferencesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	pathsAttribute, ok := attributes["paths"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`paths is missing from object`)

		return nil, diags
	}

	pathsVal, ok := pathsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`paths expected to be basetypes.ListValue, was: %T`, pathsAttribute))
	}

	strategyAttribute, ok := attributes["strategy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`strategy is missing from object`)

		return nil, diags
	}

	strategyVal, ok := strategyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`strategy expected to be basetypes.StringValue, was: %T`, strategyAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PathPreferencesValue{
		Paths:    pathsVal,
		Strategy: strategyVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewPathPreferencesValueNull() PathPreferencesValue {
	return PathPreferencesValue{
		state: attr.ValueStateNull,
	}
}

func NewPathPreferencesValueUnknown() PathPreferencesValue {
	return PathPreferencesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPathPreferencesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PathPreferencesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PathPreferencesValue Attribute Value",
				"While creating a PathPreferencesValue value, a missing attribute value was detected. "+
					"A PathPreferencesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PathPreferencesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PathPreferencesValue Attribute Type",
				"While creating a PathPreferencesValue value, an invalid attribute value was detected. "+
					"A PathPreferencesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PathPreferencesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PathPreferencesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PathPreferencesValue Attribute Value",
				"While creating a PathPreferencesValue value, an extra attribute value was detected. "+
					"A PathPreferencesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PathPreferencesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPathPreferencesValueUnknown(), diags
	}

	pathsAttribute, ok := attributes["paths"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`paths is missing from object`)

		return NewPathPreferencesValueUnknown(), diags
	}

	pathsVal, ok := pathsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`paths expected to be basetypes.ListValue, was: %T`, pathsAttribute))
	}

	strategyAttribute, ok := attributes["strategy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`strategy is missing from object`)

		return NewPathPreferencesValueUnknown(), diags
	}

	strategyVal, ok := strategyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`strategy expected to be basetypes.StringValue, was: %T`, strategyAttribute))
	}

	if diags.HasError() {
		return NewPathPreferencesValueUnknown(), diags
	}

	return PathPreferencesValue{
		Paths:    pathsVal,
		Strategy: strategyVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewPathPreferencesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PathPreferencesValue {
	object, diags := NewPathPreferencesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPathPreferencesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PathPreferencesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPathPreferencesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPathPreferencesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPathPreferencesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPathPreferencesValueMust(PathPreferencesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PathPreferencesType) ValueType(ctx context.Context) attr.Value {
	return PathPreferencesValue{}
}

var _ basetypes.ObjectValuable = PathPreferencesValue{}

type PathPreferencesValue struct {
	Paths    basetypes.ListValue   `tfsdk:"paths"`
	Strategy basetypes.StringValue `tfsdk:"strategy"`
	state    attr.ValueState
}

func (v PathPreferencesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["paths"] = basetypes.ListType{
		ElemType: PathsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["strategy"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Paths.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["paths"] = val

		val, err = v.Strategy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["strategy"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PathPreferencesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PathPreferencesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PathPreferencesValue) String() string {
	return "PathPreferencesValue"
}

func (v PathPreferencesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	paths := types.ListValueMust(
		PathsType{
			basetypes.ObjectType{
				AttrTypes: PathsValue{}.AttributeTypes(ctx),
			},
		},
		v.Paths.Elements(),
	)

	if v.Paths.IsNull() {
		paths = types.ListNull(
			PathsType{
				basetypes.ObjectType{
					AttrTypes: PathsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Paths.IsUnknown() {
		paths = types.ListUnknown(
			PathsType{
				basetypes.ObjectType{
					AttrTypes: PathsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"paths": basetypes.ListType{
			ElemType: PathsValue{}.Type(ctx),
		},
		"strategy": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"paths":    paths,
			"strategy": v.Strategy,
		})

	return objVal, diags
}

func (v PathPreferencesValue) Equal(o attr.Value) bool {
	other, ok := o.(PathPreferencesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Paths.Equal(other.Paths) {
		return false
	}

	if !v.Strategy.Equal(other.Strategy) {
		return false
	}

	return true
}

func (v PathPreferencesValue) Type(ctx context.Context) attr.Type {
	return PathPreferencesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PathPreferencesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"paths": basetypes.ListType{
			ElemType: PathsValue{}.Type(ctx),
		},
		"strategy": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = PathsType{}

type PathsType struct {
	basetypes.ObjectType
}

func (t PathsType) Equal(o attr.Type) bool {
	other, ok := o.(PathsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PathsType) String() string {
	return "PathsType"
}

func (t PathsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	costAttribute, ok := attributes["cost"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cost is missing from object`)

		return nil, diags
	}

	costVal, ok := costAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cost expected to be basetypes.Int64Value, was: %T`, costAttribute))
	}

	disabledAttribute, ok := attributes["disabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disabled is missing from object`)

		return nil, diags
	}

	disabledVal, ok := disabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disabled expected to be basetypes.BoolValue, was: %T`, disabledAttribute))
	}

	gatewayIpAttribute, ok := attributes["gateway_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gateway_ip is missing from object`)

		return nil, diags
	}

	gatewayIpVal, ok := gatewayIpAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gateway_ip expected to be basetypes.StringValue, was: %T`, gatewayIpAttribute))
	}

	internetAccessAttribute, ok := attributes["internet_access"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`internet_access is missing from object`)

		return nil, diags
	}

	internetAccessVal, ok := internetAccessAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`internet_access expected to be basetypes.BoolValue, was: %T`, internetAccessAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	networksAttribute, ok := attributes["networks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`networks is missing from object`)

		return nil, diags
	}

	networksVal, ok := networksAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`networks expected to be basetypes.ListValue, was: %T`, networksAttribute))
	}

	targetIpsAttribute, ok := attributes["target_ips"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`target_ips is missing from object`)

		return nil, diags
	}

	targetIpsVal, ok := targetIpsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`target_ips expected to be basetypes.ListValue, was: %T`, targetIpsAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	wanNameAttribute, ok := attributes["wan_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wan_name is missing from object`)

		return nil, diags
	}

	wanNameVal, ok := wanNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wan_name expected to be basetypes.StringValue, was: %T`, wanNameAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PathsValue{
		Cost:           costVal,
		Disabled:       disabledVal,
		GatewayIp:      gatewayIpVal,
		InternetAccess: internetAccessVal,
		Name:           nameVal,
		Networks:       networksVal,
		TargetIps:      targetIpsVal,
		PathsType:      typeVal,
		WanName:        wanNameVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewPathsValueNull() PathsValue {
	return PathsValue{
		state: attr.ValueStateNull,
	}
}

func NewPathsValueUnknown() PathsValue {
	return PathsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPathsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PathsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PathsValue Attribute Value",
				"While creating a PathsValue value, a missing attribute value was detected. "+
					"A PathsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PathsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PathsValue Attribute Type",
				"While creating a PathsValue value, an invalid attribute value was detected. "+
					"A PathsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PathsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PathsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PathsValue Attribute Value",
				"While creating a PathsValue value, an extra attribute value was detected. "+
					"A PathsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PathsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPathsValueUnknown(), diags
	}

	costAttribute, ok := attributes["cost"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cost is missing from object`)

		return NewPathsValueUnknown(), diags
	}

	costVal, ok := costAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cost expected to be basetypes.Int64Value, was: %T`, costAttribute))
	}

	disabledAttribute, ok := attributes["disabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disabled is missing from object`)

		return NewPathsValueUnknown(), diags
	}

	disabledVal, ok := disabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disabled expected to be basetypes.BoolValue, was: %T`, disabledAttribute))
	}

	gatewayIpAttribute, ok := attributes["gateway_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gateway_ip is missing from object`)

		return NewPathsValueUnknown(), diags
	}

	gatewayIpVal, ok := gatewayIpAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gateway_ip expected to be basetypes.StringValue, was: %T`, gatewayIpAttribute))
	}

	internetAccessAttribute, ok := attributes["internet_access"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`internet_access is missing from object`)

		return NewPathsValueUnknown(), diags
	}

	internetAccessVal, ok := internetAccessAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`internet_access expected to be basetypes.BoolValue, was: %T`, internetAccessAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewPathsValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	networksAttribute, ok := attributes["networks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`networks is missing from object`)

		return NewPathsValueUnknown(), diags
	}

	networksVal, ok := networksAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`networks expected to be basetypes.ListValue, was: %T`, networksAttribute))
	}

	targetIpsAttribute, ok := attributes["target_ips"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`target_ips is missing from object`)

		return NewPathsValueUnknown(), diags
	}

	targetIpsVal, ok := targetIpsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`target_ips expected to be basetypes.ListValue, was: %T`, targetIpsAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewPathsValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	wanNameAttribute, ok := attributes["wan_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wan_name is missing from object`)

		return NewPathsValueUnknown(), diags
	}

	wanNameVal, ok := wanNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wan_name expected to be basetypes.StringValue, was: %T`, wanNameAttribute))
	}

	if diags.HasError() {
		return NewPathsValueUnknown(), diags
	}

	return PathsValue{
		Cost:           costVal,
		Disabled:       disabledVal,
		GatewayIp:      gatewayIpVal,
		InternetAccess: internetAccessVal,
		Name:           nameVal,
		Networks:       networksVal,
		TargetIps:      targetIpsVal,
		PathsType:      typeVal,
		WanName:        wanNameVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewPathsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PathsValue {
	object, diags := NewPathsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPathsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PathsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPathsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPathsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPathsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPathsValueMust(PathsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PathsType) ValueType(ctx context.Context) attr.Value {
	return PathsValue{}
}

var _ basetypes.ObjectValuable = PathsValue{}

type PathsValue struct {
	Cost           basetypes.Int64Value  `tfsdk:"cost"`
	Disabled       basetypes.BoolValue   `tfsdk:"disabled"`
	GatewayIp      basetypes.StringValue `tfsdk:"gateway_ip"`
	InternetAccess basetypes.BoolValue   `tfsdk:"internet_access"`
	Name           basetypes.StringValue `tfsdk:"name"`
	Networks       basetypes.ListValue   `tfsdk:"networks"`
	TargetIps      basetypes.ListValue   `tfsdk:"target_ips"`
	PathsType      basetypes.StringValue `tfsdk:"type"`
	WanName        basetypes.StringValue `tfsdk:"wan_name"`
	state          attr.ValueState
}

func (v PathsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 9)

	var val tftypes.Value
	var err error

	attrTypes["cost"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["disabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["gateway_ip"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["internet_access"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["networks"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["target_ips"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["wan_name"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 9)

		val, err = v.Cost.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cost"] = val

		val, err = v.Disabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["disabled"] = val

		val, err = v.GatewayIp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["gateway_ip"] = val

		val, err = v.InternetAccess.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["internet_access"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Networks.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["networks"] = val

		val, err = v.TargetIps.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["target_ips"] = val

		val, err = v.PathsType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		val, err = v.WanName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["wan_name"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PathsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PathsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PathsValue) String() string {
	return "PathsValue"
}

func (v PathsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	networksVal, d := types.ListValue(types.StringType, v.Networks.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"cost":            basetypes.Int64Type{},
			"disabled":        basetypes.BoolType{},
			"gateway_ip":      basetypes.StringType{},
			"internet_access": basetypes.BoolType{},
			"name":            basetypes.StringType{},
			"networks": basetypes.ListType{
				ElemType: types.StringType,
			},
			"target_ips": basetypes.ListType{
				ElemType: types.StringType,
			},
			"type":     basetypes.StringType{},
			"wan_name": basetypes.StringType{},
		}), diags
	}

	targetIpsVal, d := types.ListValue(types.StringType, v.TargetIps.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"cost":            basetypes.Int64Type{},
			"disabled":        basetypes.BoolType{},
			"gateway_ip":      basetypes.StringType{},
			"internet_access": basetypes.BoolType{},
			"name":            basetypes.StringType{},
			"networks": basetypes.ListType{
				ElemType: types.StringType,
			},
			"target_ips": basetypes.ListType{
				ElemType: types.StringType,
			},
			"type":     basetypes.StringType{},
			"wan_name": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"cost":            basetypes.Int64Type{},
		"disabled":        basetypes.BoolType{},
		"gateway_ip":      basetypes.StringType{},
		"internet_access": basetypes.BoolType{},
		"name":            basetypes.StringType{},
		"networks": basetypes.ListType{
			ElemType: types.StringType,
		},
		"target_ips": basetypes.ListType{
			ElemType: types.StringType,
		},
		"type":     basetypes.StringType{},
		"wan_name": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"cost":            v.Cost,
			"disabled":        v.Disabled,
			"gateway_ip":      v.GatewayIp,
			"internet_access": v.InternetAccess,
			"name":            v.Name,
			"networks":        networksVal,
			"target_ips":      targetIpsVal,
			"type":            v.PathsType,
			"wan_name":        v.WanName,
		})

	return objVal, diags
}

func (v PathsValue) Equal(o attr.Value) bool {
	other, ok := o.(PathsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Cost.Equal(other.Cost) {
		return false
	}

	if !v.Disabled.Equal(other.Disabled) {
		return false
	}

	if !v.GatewayIp.Equal(other.GatewayIp) {
		return false
	}

	if !v.InternetAccess.Equal(other.InternetAccess) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Networks.Equal(other.Networks) {
		return false
	}

	if !v.TargetIps.Equal(other.TargetIps) {
		return false
	}

	if !v.PathsType.Equal(other.PathsType) {
		return false
	}

	if !v.WanName.Equal(other.WanName) {
		return false
	}

	return true
}

func (v PathsValue) Type(ctx context.Context) attr.Type {
	return PathsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PathsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"cost":            basetypes.Int64Type{},
		"disabled":        basetypes.BoolType{},
		"gateway_ip":      basetypes.StringType{},
		"internet_access": basetypes.BoolType{},
		"name":            basetypes.StringType{},
		"networks": basetypes.ListType{
			ElemType: types.StringType,
		},
		"target_ips": basetypes.ListType{
			ElemType: types.StringType,
		},
		"type":     basetypes.StringType{},
		"wan_name": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = PortConfigType{}

type PortConfigType struct {
	basetypes.ObjectType
}

func (t PortConfigType) Equal(o attr.Type) bool {
	other, ok := o.(PortConfigType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PortConfigType) String() string {
	return "PortConfigType"
}

func (t PortConfigType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return nil, diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	disableAutonegAttribute, ok := attributes["disable_autoneg"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disable_autoneg is missing from object`)

		return nil, diags
	}

	disableAutonegVal, ok := disableAutonegAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disable_autoneg expected to be basetypes.BoolValue, was: %T`, disableAutonegAttribute))
	}

	disabledAttribute, ok := attributes["disabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disabled is missing from object`)

		return nil, diags
	}

	disabledVal, ok := disabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disabled expected to be basetypes.BoolValue, was: %T`, disabledAttribute))
	}

	dslTypeAttribute, ok := attributes["dsl_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dsl_type is missing from object`)

		return nil, diags
	}

	dslTypeVal, ok := dslTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dsl_type expected to be basetypes.StringValue, was: %T`, dslTypeAttribute))
	}

	dslVciAttribute, ok := attributes["dsl_vci"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dsl_vci is missing from object`)

		return nil, diags
	}

	dslVciVal, ok := dslVciAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dsl_vci expected to be basetypes.Int64Value, was: %T`, dslVciAttribute))
	}

	dslVpiAttribute, ok := attributes["dsl_vpi"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dsl_vpi is missing from object`)

		return nil, diags
	}

	dslVpiVal, ok := dslVpiAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dsl_vpi expected to be basetypes.Int64Value, was: %T`, dslVpiAttribute))
	}

	duplexAttribute, ok := attributes["duplex"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`duplex is missing from object`)

		return nil, diags
	}

	duplexVal, ok := duplexAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`duplex expected to be basetypes.StringValue, was: %T`, duplexAttribute))
	}

	lteApnAttribute, ok := attributes["lte_apn"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lte_apn is missing from object`)

		return nil, diags
	}

	lteApnVal, ok := lteApnAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lte_apn expected to be basetypes.StringValue, was: %T`, lteApnAttribute))
	}

	lteAuthAttribute, ok := attributes["lte_auth"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lte_auth is missing from object`)

		return nil, diags
	}

	lteAuthVal, ok := lteAuthAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lte_auth expected to be basetypes.StringValue, was: %T`, lteAuthAttribute))
	}

	lteBackupAttribute, ok := attributes["lte_backup"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lte_backup is missing from object`)

		return nil, diags
	}

	lteBackupVal, ok := lteBackupAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lte_backup expected to be basetypes.BoolValue, was: %T`, lteBackupAttribute))
	}

	ltePasswordAttribute, ok := attributes["lte_password"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lte_password is missing from object`)

		return nil, diags
	}

	ltePasswordVal, ok := ltePasswordAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lte_password expected to be basetypes.StringValue, was: %T`, ltePasswordAttribute))
	}

	lteUsernameAttribute, ok := attributes["lte_username"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lte_username is missing from object`)

		return nil, diags
	}

	lteUsernameVal, ok := lteUsernameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lte_username expected to be basetypes.StringValue, was: %T`, lteUsernameAttribute))
	}

	mtuAttribute, ok := attributes["mtu"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mtu is missing from object`)

		return nil, diags
	}

	mtuVal, ok := mtuAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mtu expected to be basetypes.Int64Value, was: %T`, mtuAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	networksAttribute, ok := attributes["networks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`networks is missing from object`)

		return nil, diags
	}

	networksVal, ok := networksAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`networks expected to be basetypes.ListValue, was: %T`, networksAttribute))
	}

	outerVlanIdAttribute, ok := attributes["outer_vlan_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`outer_vlan_id is missing from object`)

		return nil, diags
	}

	outerVlanIdVal, ok := outerVlanIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`outer_vlan_id expected to be basetypes.Int64Value, was: %T`, outerVlanIdAttribute))
	}

	poeDisabledAttribute, ok := attributes["poe_disabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`poe_disabled is missing from object`)

		return nil, diags
	}

	poeDisabledVal, ok := poeDisabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`poe_disabled expected to be basetypes.BoolValue, was: %T`, poeDisabledAttribute))
	}

	portIpConfigAttribute, ok := attributes["ip_config"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_config is missing from object`)

		return nil, diags
	}

	portIpConfigVal, ok := portIpConfigAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_config expected to be basetypes.ObjectValue, was: %T`, portIpConfigAttribute))
	}

	portNetworkAttribute, ok := attributes["port_network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_network is missing from object`)

		return nil, diags
	}

	portNetworkVal, ok := portNetworkAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_network expected to be basetypes.StringValue, was: %T`, portNetworkAttribute))
	}

	preserveDscpAttribute, ok := attributes["preserve_dscp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`preserve_dscp is missing from object`)

		return nil, diags
	}

	preserveDscpVal, ok := preserveDscpAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`preserve_dscp expected to be basetypes.BoolValue, was: %T`, preserveDscpAttribute))
	}

	redundantAttribute, ok := attributes["redundant"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`redundant is missing from object`)

		return nil, diags
	}

	redundantVal, ok := redundantAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`redundant expected to be basetypes.BoolValue, was: %T`, redundantAttribute))
	}

	rethIdxAttribute, ok := attributes["reth_idx"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`reth_idx is missing from object`)

		return nil, diags
	}

	rethIdxVal, ok := rethIdxAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`reth_idx expected to be basetypes.Int64Value, was: %T`, rethIdxAttribute))
	}

	rethNodeAttribute, ok := attributes["reth_node"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`reth_node is missing from object`)

		return nil, diags
	}

	rethNodeVal, ok := rethNodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`reth_node expected to be basetypes.StringValue, was: %T`, rethNodeAttribute))
	}

	rethNodesAttribute, ok := attributes["reth_nodes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`reth_nodes is missing from object`)

		return nil, diags
	}

	rethNodesVal, ok := rethNodesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`reth_nodes expected to be basetypes.ListValue, was: %T`, rethNodesAttribute))
	}

	speedAttribute, ok := attributes["speed"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`speed is missing from object`)

		return nil, diags
	}

	speedVal, ok := speedAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`speed expected to be basetypes.StringValue, was: %T`, speedAttribute))
	}

	ssrNoVirtualMacAttribute, ok := attributes["ssr_no_virtual_mac"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ssr_no_virtual_mac is missing from object`)

		return nil, diags
	}

	ssrNoVirtualMacVal, ok := ssrNoVirtualMacAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ssr_no_virtual_mac expected to be basetypes.BoolValue, was: %T`, ssrNoVirtualMacAttribute))
	}

	svrPortRangeAttribute, ok := attributes["svr_port_range"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`svr_port_range is missing from object`)

		return nil, diags
	}

	svrPortRangeVal, ok := svrPortRangeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`svr_port_range expected to be basetypes.StringValue, was: %T`, svrPortRangeAttribute))
	}

	trafficShapingAttribute, ok := attributes["traffic_shaping"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`traffic_shaping is missing from object`)

		return nil, diags
	}

	trafficShapingVal, ok := trafficShapingAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`traffic_shaping expected to be basetypes.ObjectValue, was: %T`, trafficShapingAttribute))
	}

	usageAttribute, ok := attributes["usage"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`usage is missing from object`)

		return nil, diags
	}

	usageVal, ok := usageAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`usage expected to be basetypes.StringValue, was: %T`, usageAttribute))
	}

	vlanIdAttribute, ok := attributes["vlan_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan_id is missing from object`)

		return nil, diags
	}

	vlanIdVal, ok := vlanIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan_id expected to be basetypes.Int64Value, was: %T`, vlanIdAttribute))
	}

	vpnPathsAttribute, ok := attributes["vpn_paths"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vpn_paths is missing from object`)

		return nil, diags
	}

	vpnPathsVal, ok := vpnPathsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vpn_paths expected to be basetypes.MapValue, was: %T`, vpnPathsAttribute))
	}

	wanArpPolicerAttribute, ok := attributes["wan_arp_policer"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wan_arp_policer is missing from object`)

		return nil, diags
	}

	wanArpPolicerVal, ok := wanArpPolicerAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wan_arp_policer expected to be basetypes.StringValue, was: %T`, wanArpPolicerAttribute))
	}

	wanExtIpAttribute, ok := attributes["wan_ext_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wan_ext_ip is missing from object`)

		return nil, diags
	}

	wanExtIpVal, ok := wanExtIpAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wan_ext_ip expected to be basetypes.StringValue, was: %T`, wanExtIpAttribute))
	}

	wanSourceNatAttribute, ok := attributes["wan_source_nat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wan_source_nat is missing from object`)

		return nil, diags
	}

	wanSourceNatVal, ok := wanSourceNatAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wan_source_nat expected to be basetypes.ObjectValue, was: %T`, wanSourceNatAttribute))
	}

	wanTypeAttribute, ok := attributes["wan_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wan_type is missing from object`)

		return nil, diags
	}

	wanTypeVal, ok := wanTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wan_type expected to be basetypes.StringValue, was: %T`, wanTypeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PortConfigValue{
		Description:     descriptionVal,
		DisableAutoneg:  disableAutonegVal,
		Disabled:        disabledVal,
		DslType:         dslTypeVal,
		DslVci:          dslVciVal,
		DslVpi:          dslVpiVal,
		Duplex:          duplexVal,
		LteApn:          lteApnVal,
		LteAuth:         lteAuthVal,
		LteBackup:       lteBackupVal,
		LtePassword:     ltePasswordVal,
		LteUsername:     lteUsernameVal,
		Mtu:             mtuVal,
		Name:            nameVal,
		Networks:        networksVal,
		OuterVlanId:     outerVlanIdVal,
		PoeDisabled:     poeDisabledVal,
		PortIpConfig:    portIpConfigVal,
		PortNetwork:     portNetworkVal,
		PreserveDscp:    preserveDscpVal,
		Redundant:       redundantVal,
		RethIdx:         rethIdxVal,
		RethNode:        rethNodeVal,
		RethNodes:       rethNodesVal,
		Speed:           speedVal,
		SsrNoVirtualMac: ssrNoVirtualMacVal,
		SvrPortRange:    svrPortRangeVal,
		TrafficShaping:  trafficShapingVal,
		Usage:           usageVal,
		VlanId:          vlanIdVal,
		VpnPaths:        vpnPathsVal,
		WanArpPolicer:   wanArpPolicerVal,
		WanExtIp:        wanExtIpVal,
		WanSourceNat:    wanSourceNatVal,
		WanType:         wanTypeVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewPortConfigValueNull() PortConfigValue {
	return PortConfigValue{
		state: attr.ValueStateNull,
	}
}

func NewPortConfigValueUnknown() PortConfigValue {
	return PortConfigValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPortConfigValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PortConfigValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PortConfigValue Attribute Value",
				"While creating a PortConfigValue value, a missing attribute value was detected. "+
					"A PortConfigValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PortConfigValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PortConfigValue Attribute Type",
				"While creating a PortConfigValue value, an invalid attribute value was detected. "+
					"A PortConfigValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PortConfigValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PortConfigValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PortConfigValue Attribute Value",
				"While creating a PortConfigValue value, an extra attribute value was detected. "+
					"A PortConfigValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PortConfigValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPortConfigValueUnknown(), diags
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	disableAutonegAttribute, ok := attributes["disable_autoneg"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disable_autoneg is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	disableAutonegVal, ok := disableAutonegAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disable_autoneg expected to be basetypes.BoolValue, was: %T`, disableAutonegAttribute))
	}

	disabledAttribute, ok := attributes["disabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disabled is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	disabledVal, ok := disabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disabled expected to be basetypes.BoolValue, was: %T`, disabledAttribute))
	}

	dslTypeAttribute, ok := attributes["dsl_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dsl_type is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	dslTypeVal, ok := dslTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dsl_type expected to be basetypes.StringValue, was: %T`, dslTypeAttribute))
	}

	dslVciAttribute, ok := attributes["dsl_vci"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dsl_vci is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	dslVciVal, ok := dslVciAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dsl_vci expected to be basetypes.Int64Value, was: %T`, dslVciAttribute))
	}

	dslVpiAttribute, ok := attributes["dsl_vpi"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dsl_vpi is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	dslVpiVal, ok := dslVpiAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dsl_vpi expected to be basetypes.Int64Value, was: %T`, dslVpiAttribute))
	}

	duplexAttribute, ok := attributes["duplex"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`duplex is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	duplexVal, ok := duplexAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`duplex expected to be basetypes.StringValue, was: %T`, duplexAttribute))
	}

	lteApnAttribute, ok := attributes["lte_apn"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lte_apn is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	lteApnVal, ok := lteApnAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lte_apn expected to be basetypes.StringValue, was: %T`, lteApnAttribute))
	}

	lteAuthAttribute, ok := attributes["lte_auth"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lte_auth is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	lteAuthVal, ok := lteAuthAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lte_auth expected to be basetypes.StringValue, was: %T`, lteAuthAttribute))
	}

	lteBackupAttribute, ok := attributes["lte_backup"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lte_backup is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	lteBackupVal, ok := lteBackupAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lte_backup expected to be basetypes.BoolValue, was: %T`, lteBackupAttribute))
	}

	ltePasswordAttribute, ok := attributes["lte_password"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lte_password is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	ltePasswordVal, ok := ltePasswordAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lte_password expected to be basetypes.StringValue, was: %T`, ltePasswordAttribute))
	}

	lteUsernameAttribute, ok := attributes["lte_username"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lte_username is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	lteUsernameVal, ok := lteUsernameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lte_username expected to be basetypes.StringValue, was: %T`, lteUsernameAttribute))
	}

	mtuAttribute, ok := attributes["mtu"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mtu is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	mtuVal, ok := mtuAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mtu expected to be basetypes.Int64Value, was: %T`, mtuAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	networksAttribute, ok := attributes["networks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`networks is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	networksVal, ok := networksAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`networks expected to be basetypes.ListValue, was: %T`, networksAttribute))
	}

	outerVlanIdAttribute, ok := attributes["outer_vlan_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`outer_vlan_id is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	outerVlanIdVal, ok := outerVlanIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`outer_vlan_id expected to be basetypes.Int64Value, was: %T`, outerVlanIdAttribute))
	}

	poeDisabledAttribute, ok := attributes["poe_disabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`poe_disabled is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	poeDisabledVal, ok := poeDisabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`poe_disabled expected to be basetypes.BoolValue, was: %T`, poeDisabledAttribute))
	}

	portIpConfigAttribute, ok := attributes["ip_config"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_config is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	portIpConfigVal, ok := portIpConfigAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_config expected to be basetypes.ObjectValue, was: %T`, portIpConfigAttribute))
	}

	portNetworkAttribute, ok := attributes["port_network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_network is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	portNetworkVal, ok := portNetworkAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_network expected to be basetypes.StringValue, was: %T`, portNetworkAttribute))
	}

	preserveDscpAttribute, ok := attributes["preserve_dscp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`preserve_dscp is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	preserveDscpVal, ok := preserveDscpAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`preserve_dscp expected to be basetypes.BoolValue, was: %T`, preserveDscpAttribute))
	}

	redundantAttribute, ok := attributes["redundant"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`redundant is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	redundantVal, ok := redundantAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`redundant expected to be basetypes.BoolValue, was: %T`, redundantAttribute))
	}

	rethIdxAttribute, ok := attributes["reth_idx"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`reth_idx is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	rethIdxVal, ok := rethIdxAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`reth_idx expected to be basetypes.Int64Value, was: %T`, rethIdxAttribute))
	}

	rethNodeAttribute, ok := attributes["reth_node"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`reth_node is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	rethNodeVal, ok := rethNodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`reth_node expected to be basetypes.StringValue, was: %T`, rethNodeAttribute))
	}

	rethNodesAttribute, ok := attributes["reth_nodes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`reth_nodes is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	rethNodesVal, ok := rethNodesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`reth_nodes expected to be basetypes.ListValue, was: %T`, rethNodesAttribute))
	}

	speedAttribute, ok := attributes["speed"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`speed is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	speedVal, ok := speedAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`speed expected to be basetypes.StringValue, was: %T`, speedAttribute))
	}

	ssrNoVirtualMacAttribute, ok := attributes["ssr_no_virtual_mac"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ssr_no_virtual_mac is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	ssrNoVirtualMacVal, ok := ssrNoVirtualMacAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ssr_no_virtual_mac expected to be basetypes.BoolValue, was: %T`, ssrNoVirtualMacAttribute))
	}

	svrPortRangeAttribute, ok := attributes["svr_port_range"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`svr_port_range is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	svrPortRangeVal, ok := svrPortRangeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`svr_port_range expected to be basetypes.StringValue, was: %T`, svrPortRangeAttribute))
	}

	trafficShapingAttribute, ok := attributes["traffic_shaping"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`traffic_shaping is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	trafficShapingVal, ok := trafficShapingAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`traffic_shaping expected to be basetypes.ObjectValue, was: %T`, trafficShapingAttribute))
	}

	usageAttribute, ok := attributes["usage"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`usage is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	usageVal, ok := usageAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`usage expected to be basetypes.StringValue, was: %T`, usageAttribute))
	}

	vlanIdAttribute, ok := attributes["vlan_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan_id is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	vlanIdVal, ok := vlanIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan_id expected to be basetypes.Int64Value, was: %T`, vlanIdAttribute))
	}

	vpnPathsAttribute, ok := attributes["vpn_paths"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vpn_paths is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	vpnPathsVal, ok := vpnPathsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vpn_paths expected to be basetypes.MapValue, was: %T`, vpnPathsAttribute))
	}

	wanArpPolicerAttribute, ok := attributes["wan_arp_policer"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wan_arp_policer is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	wanArpPolicerVal, ok := wanArpPolicerAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wan_arp_policer expected to be basetypes.StringValue, was: %T`, wanArpPolicerAttribute))
	}

	wanExtIpAttribute, ok := attributes["wan_ext_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wan_ext_ip is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	wanExtIpVal, ok := wanExtIpAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wan_ext_ip expected to be basetypes.StringValue, was: %T`, wanExtIpAttribute))
	}

	wanSourceNatAttribute, ok := attributes["wan_source_nat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wan_source_nat is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	wanSourceNatVal, ok := wanSourceNatAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wan_source_nat expected to be basetypes.ObjectValue, was: %T`, wanSourceNatAttribute))
	}

	wanTypeAttribute, ok := attributes["wan_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wan_type is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	wanTypeVal, ok := wanTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wan_type expected to be basetypes.StringValue, was: %T`, wanTypeAttribute))
	}

	if diags.HasError() {
		return NewPortConfigValueUnknown(), diags
	}

	return PortConfigValue{
		Description:     descriptionVal,
		DisableAutoneg:  disableAutonegVal,
		Disabled:        disabledVal,
		DslType:         dslTypeVal,
		DslVci:          dslVciVal,
		DslVpi:          dslVpiVal,
		Duplex:          duplexVal,
		LteApn:          lteApnVal,
		LteAuth:         lteAuthVal,
		LteBackup:       lteBackupVal,
		LtePassword:     ltePasswordVal,
		LteUsername:     lteUsernameVal,
		Mtu:             mtuVal,
		Name:            nameVal,
		Networks:        networksVal,
		OuterVlanId:     outerVlanIdVal,
		PoeDisabled:     poeDisabledVal,
		PortIpConfig:    portIpConfigVal,
		PortNetwork:     portNetworkVal,
		PreserveDscp:    preserveDscpVal,
		Redundant:       redundantVal,
		RethIdx:         rethIdxVal,
		RethNode:        rethNodeVal,
		RethNodes:       rethNodesVal,
		Speed:           speedVal,
		SsrNoVirtualMac: ssrNoVirtualMacVal,
		SvrPortRange:    svrPortRangeVal,
		TrafficShaping:  trafficShapingVal,
		Usage:           usageVal,
		VlanId:          vlanIdVal,
		VpnPaths:        vpnPathsVal,
		WanArpPolicer:   wanArpPolicerVal,
		WanExtIp:        wanExtIpVal,
		WanSourceNat:    wanSourceNatVal,
		WanType:         wanTypeVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewPortConfigValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PortConfigValue {
	object, diags := NewPortConfigValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPortConfigValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PortConfigType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPortConfigValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPortConfigValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPortConfigValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPortConfigValueMust(PortConfigValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PortConfigType) ValueType(ctx context.Context) attr.Value {
	return PortConfigValue{}
}

var _ basetypes.ObjectValuable = PortConfigValue{}

type PortConfigValue struct {
	Description     basetypes.StringValue `tfsdk:"description"`
	DisableAutoneg  basetypes.BoolValue   `tfsdk:"disable_autoneg"`
	Disabled        basetypes.BoolValue   `tfsdk:"disabled"`
	DslType         basetypes.StringValue `tfsdk:"dsl_type"`
	DslVci          basetypes.Int64Value  `tfsdk:"dsl_vci"`
	DslVpi          basetypes.Int64Value  `tfsdk:"dsl_vpi"`
	Duplex          basetypes.StringValue `tfsdk:"duplex"`
	LteApn          basetypes.StringValue `tfsdk:"lte_apn"`
	LteAuth         basetypes.StringValue `tfsdk:"lte_auth"`
	LteBackup       basetypes.BoolValue   `tfsdk:"lte_backup"`
	LtePassword     basetypes.StringValue `tfsdk:"lte_password"`
	LteUsername     basetypes.StringValue `tfsdk:"lte_username"`
	Mtu             basetypes.Int64Value  `tfsdk:"mtu"`
	Name            basetypes.StringValue `tfsdk:"name"`
	Networks        basetypes.ListValue   `tfsdk:"networks"`
	OuterVlanId     basetypes.Int64Value  `tfsdk:"outer_vlan_id"`
	PoeDisabled     basetypes.BoolValue   `tfsdk:"poe_disabled"`
	PortIpConfig    basetypes.ObjectValue `tfsdk:"ip_config"`
	PortNetwork     basetypes.StringValue `tfsdk:"port_network"`
	PreserveDscp    basetypes.BoolValue   `tfsdk:"preserve_dscp"`
	Redundant       basetypes.BoolValue   `tfsdk:"redundant"`
	RethIdx         basetypes.Int64Value  `tfsdk:"reth_idx"`
	RethNode        basetypes.StringValue `tfsdk:"reth_node"`
	RethNodes       basetypes.ListValue   `tfsdk:"reth_nodes"`
	Speed           basetypes.StringValue `tfsdk:"speed"`
	SsrNoVirtualMac basetypes.BoolValue   `tfsdk:"ssr_no_virtual_mac"`
	SvrPortRange    basetypes.StringValue `tfsdk:"svr_port_range"`
	TrafficShaping  basetypes.ObjectValue `tfsdk:"traffic_shaping"`
	Usage           basetypes.StringValue `tfsdk:"usage"`
	VlanId          basetypes.Int64Value  `tfsdk:"vlan_id"`
	VpnPaths        basetypes.MapValue    `tfsdk:"vpn_paths"`
	WanArpPolicer   basetypes.StringValue `tfsdk:"wan_arp_policer"`
	WanExtIp        basetypes.StringValue `tfsdk:"wan_ext_ip"`
	WanSourceNat    basetypes.ObjectValue `tfsdk:"wan_source_nat"`
	WanType         basetypes.StringValue `tfsdk:"wan_type"`
	state           attr.ValueState
}

func (v PortConfigValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 35)

	var val tftypes.Value
	var err error

	attrTypes["description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["disable_autoneg"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["disabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["dsl_type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["dsl_vci"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["dsl_vpi"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["duplex"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["lte_apn"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["lte_auth"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["lte_backup"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["lte_password"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["lte_username"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["mtu"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["networks"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["outer_vlan_id"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["poe_disabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["ip_config"] = basetypes.ObjectType{
		AttrTypes: PortIpConfigValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["port_network"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["preserve_dscp"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["redundant"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["reth_idx"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["reth_node"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["reth_nodes"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["speed"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ssr_no_virtual_mac"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["svr_port_range"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["traffic_shaping"] = basetypes.ObjectType{
		AttrTypes: TrafficShapingValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["usage"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["vlan_id"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["vpn_paths"] = basetypes.MapType{
		ElemType: VpnPathsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["wan_arp_policer"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["wan_ext_ip"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["wan_source_nat"] = basetypes.ObjectType{
		AttrTypes: WanSourceNatValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["wan_type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 35)

		val, err = v.Description.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["description"] = val

		val, err = v.DisableAutoneg.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["disable_autoneg"] = val

		val, err = v.Disabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["disabled"] = val

		val, err = v.DslType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dsl_type"] = val

		val, err = v.DslVci.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dsl_vci"] = val

		val, err = v.DslVpi.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dsl_vpi"] = val

		val, err = v.Duplex.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["duplex"] = val

		val, err = v.LteApn.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["lte_apn"] = val

		val, err = v.LteAuth.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["lte_auth"] = val

		val, err = v.LteBackup.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["lte_backup"] = val

		val, err = v.LtePassword.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["lte_password"] = val

		val, err = v.LteUsername.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["lte_username"] = val

		val, err = v.Mtu.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mtu"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Networks.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["networks"] = val

		val, err = v.OuterVlanId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["outer_vlan_id"] = val

		val, err = v.PoeDisabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["poe_disabled"] = val

		val, err = v.PortIpConfig.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip_config"] = val

		val, err = v.PortNetwork.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port_network"] = val

		val, err = v.PreserveDscp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["preserve_dscp"] = val

		val, err = v.Redundant.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["redundant"] = val

		val, err = v.RethIdx.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["reth_idx"] = val

		val, err = v.RethNode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["reth_node"] = val

		val, err = v.RethNodes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["reth_nodes"] = val

		val, err = v.Speed.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["speed"] = val

		val, err = v.SsrNoVirtualMac.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ssr_no_virtual_mac"] = val

		val, err = v.SvrPortRange.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["svr_port_range"] = val

		val, err = v.TrafficShaping.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["traffic_shaping"] = val

		val, err = v.Usage.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["usage"] = val

		val, err = v.VlanId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vlan_id"] = val

		val, err = v.VpnPaths.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vpn_paths"] = val

		val, err = v.WanArpPolicer.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["wan_arp_policer"] = val

		val, err = v.WanExtIp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["wan_ext_ip"] = val

		val, err = v.WanSourceNat.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["wan_source_nat"] = val

		val, err = v.WanType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["wan_type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PortConfigValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PortConfigValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PortConfigValue) String() string {
	return "PortConfigValue"
}

func (v PortConfigValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var portIpConfig basetypes.ObjectValue

	if v.PortIpConfig.IsNull() {
		portIpConfig = types.ObjectNull(
			PortIpConfigValue{}.AttributeTypes(ctx),
		)
	}

	if v.PortIpConfig.IsUnknown() {
		portIpConfig = types.ObjectUnknown(
			PortIpConfigValue{}.AttributeTypes(ctx),
		)
	}

	if !v.PortIpConfig.IsNull() && !v.PortIpConfig.IsUnknown() {
		portIpConfig = types.ObjectValueMust(
			PortIpConfigValue{}.AttributeTypes(ctx),
			v.PortIpConfig.Attributes(),
		)
	}

	var trafficShaping basetypes.ObjectValue

	if v.TrafficShaping.IsNull() {
		trafficShaping = types.ObjectNull(
			TrafficShapingValue{}.AttributeTypes(ctx),
		)
	}

	if v.TrafficShaping.IsUnknown() {
		trafficShaping = types.ObjectUnknown(
			TrafficShapingValue{}.AttributeTypes(ctx),
		)
	}

	if !v.TrafficShaping.IsNull() && !v.TrafficShaping.IsUnknown() {
		trafficShaping = types.ObjectValueMust(
			TrafficShapingValue{}.AttributeTypes(ctx),
			v.TrafficShaping.Attributes(),
		)
	}

	vpnPaths := types.MapValueMust(
		VpnPathsType{
			basetypes.ObjectType{
				AttrTypes: VpnPathsValue{}.AttributeTypes(ctx),
			},
		},
		v.VpnPaths.Elements(),
	)

	if v.VpnPaths.IsNull() {
		vpnPaths = types.MapNull(
			VpnPathsType{
				basetypes.ObjectType{
					AttrTypes: VpnPathsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.VpnPaths.IsUnknown() {
		vpnPaths = types.MapUnknown(
			VpnPathsType{
				basetypes.ObjectType{
					AttrTypes: VpnPathsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var wanSourceNat basetypes.ObjectValue

	if v.WanSourceNat.IsNull() {
		wanSourceNat = types.ObjectNull(
			WanSourceNatValue{}.AttributeTypes(ctx),
		)
	}

	if v.WanSourceNat.IsUnknown() {
		wanSourceNat = types.ObjectUnknown(
			WanSourceNatValue{}.AttributeTypes(ctx),
		)
	}

	if !v.WanSourceNat.IsNull() && !v.WanSourceNat.IsUnknown() {
		wanSourceNat = types.ObjectValueMust(
			WanSourceNatValue{}.AttributeTypes(ctx),
			v.WanSourceNat.Attributes(),
		)
	}

	networksVal, d := types.ListValue(types.StringType, v.Networks.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"description":     basetypes.StringType{},
			"disable_autoneg": basetypes.BoolType{},
			"disabled":        basetypes.BoolType{},
			"dsl_type":        basetypes.StringType{},
			"dsl_vci":         basetypes.Int64Type{},
			"dsl_vpi":         basetypes.Int64Type{},
			"duplex":          basetypes.StringType{},
			"lte_apn":         basetypes.StringType{},
			"lte_auth":        basetypes.StringType{},
			"lte_backup":      basetypes.BoolType{},
			"lte_password":    basetypes.StringType{},
			"lte_username":    basetypes.StringType{},
			"mtu":             basetypes.Int64Type{},
			"name":            basetypes.StringType{},
			"networks": basetypes.ListType{
				ElemType: types.StringType,
			},
			"outer_vlan_id": basetypes.Int64Type{},
			"poe_disabled":  basetypes.BoolType{},
			"ip_config": basetypes.ObjectType{
				AttrTypes: PortIpConfigValue{}.AttributeTypes(ctx),
			},
			"port_network":  basetypes.StringType{},
			"preserve_dscp": basetypes.BoolType{},
			"redundant":     basetypes.BoolType{},
			"reth_idx":      basetypes.Int64Type{},
			"reth_node":     basetypes.StringType{},
			"reth_nodes": basetypes.ListType{
				ElemType: types.StringType,
			},
			"speed":              basetypes.StringType{},
			"ssr_no_virtual_mac": basetypes.BoolType{},
			"svr_port_range":     basetypes.StringType{},
			"traffic_shaping": basetypes.ObjectType{
				AttrTypes: TrafficShapingValue{}.AttributeTypes(ctx),
			},
			"usage":   basetypes.StringType{},
			"vlan_id": basetypes.Int64Type{},
			"vpn_paths": basetypes.MapType{
				ElemType: VpnPathsValue{}.Type(ctx),
			},
			"wan_arp_policer": basetypes.StringType{},
			"wan_ext_ip":      basetypes.StringType{},
			"wan_source_nat": basetypes.ObjectType{
				AttrTypes: WanSourceNatValue{}.AttributeTypes(ctx),
			},
			"wan_type": basetypes.StringType{},
		}), diags
	}

	rethNodesVal, d := types.ListValue(types.StringType, v.RethNodes.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"description":     basetypes.StringType{},
			"disable_autoneg": basetypes.BoolType{},
			"disabled":        basetypes.BoolType{},
			"dsl_type":        basetypes.StringType{},
			"dsl_vci":         basetypes.Int64Type{},
			"dsl_vpi":         basetypes.Int64Type{},
			"duplex":          basetypes.StringType{},
			"lte_apn":         basetypes.StringType{},
			"lte_auth":        basetypes.StringType{},
			"lte_backup":      basetypes.BoolType{},
			"lte_password":    basetypes.StringType{},
			"lte_username":    basetypes.StringType{},
			"mtu":             basetypes.Int64Type{},
			"name":            basetypes.StringType{},
			"networks": basetypes.ListType{
				ElemType: types.StringType,
			},
			"outer_vlan_id": basetypes.Int64Type{},
			"poe_disabled":  basetypes.BoolType{},
			"ip_config": basetypes.ObjectType{
				AttrTypes: PortIpConfigValue{}.AttributeTypes(ctx),
			},
			"port_network":  basetypes.StringType{},
			"preserve_dscp": basetypes.BoolType{},
			"redundant":     basetypes.BoolType{},
			"reth_idx":      basetypes.Int64Type{},
			"reth_node":     basetypes.StringType{},
			"reth_nodes": basetypes.ListType{
				ElemType: types.StringType,
			},
			"speed":              basetypes.StringType{},
			"ssr_no_virtual_mac": basetypes.BoolType{},
			"svr_port_range":     basetypes.StringType{},
			"traffic_shaping": basetypes.ObjectType{
				AttrTypes: TrafficShapingValue{}.AttributeTypes(ctx),
			},
			"usage":   basetypes.StringType{},
			"vlan_id": basetypes.Int64Type{},
			"vpn_paths": basetypes.MapType{
				ElemType: VpnPathsValue{}.Type(ctx),
			},
			"wan_arp_policer": basetypes.StringType{},
			"wan_ext_ip":      basetypes.StringType{},
			"wan_source_nat": basetypes.ObjectType{
				AttrTypes: WanSourceNatValue{}.AttributeTypes(ctx),
			},
			"wan_type": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"description":     basetypes.StringType{},
		"disable_autoneg": basetypes.BoolType{},
		"disabled":        basetypes.BoolType{},
		"dsl_type":        basetypes.StringType{},
		"dsl_vci":         basetypes.Int64Type{},
		"dsl_vpi":         basetypes.Int64Type{},
		"duplex":          basetypes.StringType{},
		"lte_apn":         basetypes.StringType{},
		"lte_auth":        basetypes.StringType{},
		"lte_backup":      basetypes.BoolType{},
		"lte_password":    basetypes.StringType{},
		"lte_username":    basetypes.StringType{},
		"mtu":             basetypes.Int64Type{},
		"name":            basetypes.StringType{},
		"networks": basetypes.ListType{
			ElemType: types.StringType,
		},
		"outer_vlan_id": basetypes.Int64Type{},
		"poe_disabled":  basetypes.BoolType{},
		"ip_config": basetypes.ObjectType{
			AttrTypes: PortIpConfigValue{}.AttributeTypes(ctx),
		},
		"port_network":  basetypes.StringType{},
		"preserve_dscp": basetypes.BoolType{},
		"redundant":     basetypes.BoolType{},
		"reth_idx":      basetypes.Int64Type{},
		"reth_node":     basetypes.StringType{},
		"reth_nodes": basetypes.ListType{
			ElemType: types.StringType,
		},
		"speed":              basetypes.StringType{},
		"ssr_no_virtual_mac": basetypes.BoolType{},
		"svr_port_range":     basetypes.StringType{},
		"traffic_shaping": basetypes.ObjectType{
			AttrTypes: TrafficShapingValue{}.AttributeTypes(ctx),
		},
		"usage":   basetypes.StringType{},
		"vlan_id": basetypes.Int64Type{},
		"vpn_paths": basetypes.MapType{
			ElemType: VpnPathsValue{}.Type(ctx),
		},
		"wan_arp_policer": basetypes.StringType{},
		"wan_ext_ip":      basetypes.StringType{},
		"wan_source_nat": basetypes.ObjectType{
			AttrTypes: WanSourceNatValue{}.AttributeTypes(ctx),
		},
		"wan_type": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"description":        v.Description,
			"disable_autoneg":    v.DisableAutoneg,
			"disabled":           v.Disabled,
			"dsl_type":           v.DslType,
			"dsl_vci":            v.DslVci,
			"dsl_vpi":            v.DslVpi,
			"duplex":             v.Duplex,
			"lte_apn":            v.LteApn,
			"lte_auth":           v.LteAuth,
			"lte_backup":         v.LteBackup,
			"lte_password":       v.LtePassword,
			"lte_username":       v.LteUsername,
			"mtu":                v.Mtu,
			"name":               v.Name,
			"networks":           networksVal,
			"outer_vlan_id":      v.OuterVlanId,
			"poe_disabled":       v.PoeDisabled,
			"ip_config":     portIpConfig,
			"port_network":       v.PortNetwork,
			"preserve_dscp":      v.PreserveDscp,
			"redundant":          v.Redundant,
			"reth_idx":           v.RethIdx,
			"reth_node":          v.RethNode,
			"reth_nodes":         rethNodesVal,
			"speed":              v.Speed,
			"ssr_no_virtual_mac": v.SsrNoVirtualMac,
			"svr_port_range":     v.SvrPortRange,
			"traffic_shaping":    trafficShaping,
			"usage":              v.Usage,
			"vlan_id":            v.VlanId,
			"vpn_paths":          vpnPaths,
			"wan_arp_policer":    v.WanArpPolicer,
			"wan_ext_ip":         v.WanExtIp,
			"wan_source_nat":     wanSourceNat,
			"wan_type":           v.WanType,
		})

	return objVal, diags
}

func (v PortConfigValue) Equal(o attr.Value) bool {
	other, ok := o.(PortConfigValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Description.Equal(other.Description) {
		return false
	}

	if !v.DisableAutoneg.Equal(other.DisableAutoneg) {
		return false
	}

	if !v.Disabled.Equal(other.Disabled) {
		return false
	}

	if !v.DslType.Equal(other.DslType) {
		return false
	}

	if !v.DslVci.Equal(other.DslVci) {
		return false
	}

	if !v.DslVpi.Equal(other.DslVpi) {
		return false
	}

	if !v.Duplex.Equal(other.Duplex) {
		return false
	}

	if !v.LteApn.Equal(other.LteApn) {
		return false
	}

	if !v.LteAuth.Equal(other.LteAuth) {
		return false
	}

	if !v.LteBackup.Equal(other.LteBackup) {
		return false
	}

	if !v.LtePassword.Equal(other.LtePassword) {
		return false
	}

	if !v.LteUsername.Equal(other.LteUsername) {
		return false
	}

	if !v.Mtu.Equal(other.Mtu) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Networks.Equal(other.Networks) {
		return false
	}

	if !v.OuterVlanId.Equal(other.OuterVlanId) {
		return false
	}

	if !v.PoeDisabled.Equal(other.PoeDisabled) {
		return false
	}

	if !v.PortIpConfig.Equal(other.PortIpConfig) {
		return false
	}

	if !v.PortNetwork.Equal(other.PortNetwork) {
		return false
	}

	if !v.PreserveDscp.Equal(other.PreserveDscp) {
		return false
	}

	if !v.Redundant.Equal(other.Redundant) {
		return false
	}

	if !v.RethIdx.Equal(other.RethIdx) {
		return false
	}

	if !v.RethNode.Equal(other.RethNode) {
		return false
	}

	if !v.RethNodes.Equal(other.RethNodes) {
		return false
	}

	if !v.Speed.Equal(other.Speed) {
		return false
	}

	if !v.SsrNoVirtualMac.Equal(other.SsrNoVirtualMac) {
		return false
	}

	if !v.SvrPortRange.Equal(other.SvrPortRange) {
		return false
	}

	if !v.TrafficShaping.Equal(other.TrafficShaping) {
		return false
	}

	if !v.Usage.Equal(other.Usage) {
		return false
	}

	if !v.VlanId.Equal(other.VlanId) {
		return false
	}

	if !v.VpnPaths.Equal(other.VpnPaths) {
		return false
	}

	if !v.WanArpPolicer.Equal(other.WanArpPolicer) {
		return false
	}

	if !v.WanExtIp.Equal(other.WanExtIp) {
		return false
	}

	if !v.WanSourceNat.Equal(other.WanSourceNat) {
		return false
	}

	if !v.WanType.Equal(other.WanType) {
		return false
	}

	return true
}

func (v PortConfigValue) Type(ctx context.Context) attr.Type {
	return PortConfigType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PortConfigValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"description":     basetypes.StringType{},
		"disable_autoneg": basetypes.BoolType{},
		"disabled":        basetypes.BoolType{},
		"dsl_type":        basetypes.StringType{},
		"dsl_vci":         basetypes.Int64Type{},
		"dsl_vpi":         basetypes.Int64Type{},
		"duplex":          basetypes.StringType{},
		"lte_apn":         basetypes.StringType{},
		"lte_auth":        basetypes.StringType{},
		"lte_backup":      basetypes.BoolType{},
		"lte_password":    basetypes.StringType{},
		"lte_username":    basetypes.StringType{},
		"mtu":             basetypes.Int64Type{},
		"name":            basetypes.StringType{},
		"networks": basetypes.ListType{
			ElemType: types.StringType,
		},
		"outer_vlan_id": basetypes.Int64Type{},
		"poe_disabled":  basetypes.BoolType{},
		"ip_config": basetypes.ObjectType{
			AttrTypes: PortIpConfigValue{}.AttributeTypes(ctx),
		},
		"port_network":  basetypes.StringType{},
		"preserve_dscp": basetypes.BoolType{},
		"redundant":     basetypes.BoolType{},
		"reth_idx":      basetypes.Int64Type{},
		"reth_node":     basetypes.StringType{},
		"reth_nodes": basetypes.ListType{
			ElemType: types.StringType,
		},
		"speed":              basetypes.StringType{},
		"ssr_no_virtual_mac": basetypes.BoolType{},
		"svr_port_range":     basetypes.StringType{},
		"traffic_shaping": basetypes.ObjectType{
			AttrTypes: TrafficShapingValue{}.AttributeTypes(ctx),
		},
		"usage":   basetypes.StringType{},
		"vlan_id": basetypes.Int64Type{},
		"vpn_paths": basetypes.MapType{
			ElemType: VpnPathsValue{}.Type(ctx),
		},
		"wan_arp_policer": basetypes.StringType{},
		"wan_ext_ip":      basetypes.StringType{},
		"wan_source_nat": basetypes.ObjectType{
			AttrTypes: WanSourceNatValue{}.AttributeTypes(ctx),
		},
		"wan_type": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = PortIpConfigType{}

type PortIpConfigType struct {
	basetypes.ObjectType
}

func (t PortIpConfigType) Equal(o attr.Type) bool {
	other, ok := o.(PortIpConfigType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PortIpConfigType) String() string {
	return "PortIpConfigType"
}

func (t PortIpConfigType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	dnsAttribute, ok := attributes["dns"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dns is missing from object`)

		return nil, diags
	}

	dnsVal, ok := dnsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dns expected to be basetypes.ListValue, was: %T`, dnsAttribute))
	}

	dnsSuffixAttribute, ok := attributes["dns_suffix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dns_suffix is missing from object`)

		return nil, diags
	}

	dnsSuffixVal, ok := dnsSuffixAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dns_suffix expected to be basetypes.ListValue, was: %T`, dnsSuffixAttribute))
	}

	gatewayAttribute, ok := attributes["gateway"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gateway is missing from object`)

		return nil, diags
	}

	gatewayVal, ok := gatewayAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gateway expected to be basetypes.StringValue, was: %T`, gatewayAttribute))
	}

	ipAttribute, ok := attributes["ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip is missing from object`)

		return nil, diags
	}

	ipVal, ok := ipAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip expected to be basetypes.StringValue, was: %T`, ipAttribute))
	}

	netmaskAttribute, ok := attributes["netmask"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`netmask is missing from object`)

		return nil, diags
	}

	netmaskVal, ok := netmaskAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`netmask expected to be basetypes.StringValue, was: %T`, netmaskAttribute))
	}

	networkAttribute, ok := attributes["network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`network is missing from object`)

		return nil, diags
	}

	networkVal, ok := networkAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`network expected to be basetypes.StringValue, was: %T`, networkAttribute))
	}

	poserPasswordAttribute, ok := attributes["poser_password"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`poser_password is missing from object`)

		return nil, diags
	}

	poserPasswordVal, ok := poserPasswordAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`poser_password expected to be basetypes.StringValue, was: %T`, poserPasswordAttribute))
	}

	pppoeAuthAttribute, ok := attributes["pppoe_auth"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pppoe_auth is missing from object`)

		return nil, diags
	}

	pppoeAuthVal, ok := pppoeAuthAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pppoe_auth expected to be basetypes.StringValue, was: %T`, pppoeAuthAttribute))
	}

	pppoeUsernameAttribute, ok := attributes["pppoe_username"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pppoe_username is missing from object`)

		return nil, diags
	}

	pppoeUsernameVal, ok := pppoeUsernameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pppoe_username expected to be basetypes.StringValue, was: %T`, pppoeUsernameAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PortIpConfigValue{
		Dns:              dnsVal,
		DnsSuffix:        dnsSuffixVal,
		Gateway:          gatewayVal,
		Ip:               ipVal,
		Netmask:          netmaskVal,
		Network:          networkVal,
		PoserPassword:    poserPasswordVal,
		PppoeAuth:        pppoeAuthVal,
		PppoeUsername:    pppoeUsernameVal,
		PortIpConfigType: typeVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewPortIpConfigValueNull() PortIpConfigValue {
	return PortIpConfigValue{
		state: attr.ValueStateNull,
	}
}

func NewPortIpConfigValueUnknown() PortIpConfigValue {
	return PortIpConfigValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPortIpConfigValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PortIpConfigValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PortIpConfigValue Attribute Value",
				"While creating a PortIpConfigValue value, a missing attribute value was detected. "+
					"A PortIpConfigValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PortIpConfigValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PortIpConfigValue Attribute Type",
				"While creating a PortIpConfigValue value, an invalid attribute value was detected. "+
					"A PortIpConfigValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PortIpConfigValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PortIpConfigValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PortIpConfigValue Attribute Value",
				"While creating a PortIpConfigValue value, an extra attribute value was detected. "+
					"A PortIpConfigValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PortIpConfigValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPortIpConfigValueUnknown(), diags
	}

	dnsAttribute, ok := attributes["dns"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dns is missing from object`)

		return NewPortIpConfigValueUnknown(), diags
	}

	dnsVal, ok := dnsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dns expected to be basetypes.ListValue, was: %T`, dnsAttribute))
	}

	dnsSuffixAttribute, ok := attributes["dns_suffix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dns_suffix is missing from object`)

		return NewPortIpConfigValueUnknown(), diags
	}

	dnsSuffixVal, ok := dnsSuffixAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dns_suffix expected to be basetypes.ListValue, was: %T`, dnsSuffixAttribute))
	}

	gatewayAttribute, ok := attributes["gateway"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gateway is missing from object`)

		return NewPortIpConfigValueUnknown(), diags
	}

	gatewayVal, ok := gatewayAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gateway expected to be basetypes.StringValue, was: %T`, gatewayAttribute))
	}

	ipAttribute, ok := attributes["ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip is missing from object`)

		return NewPortIpConfigValueUnknown(), diags
	}

	ipVal, ok := ipAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip expected to be basetypes.StringValue, was: %T`, ipAttribute))
	}

	netmaskAttribute, ok := attributes["netmask"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`netmask is missing from object`)

		return NewPortIpConfigValueUnknown(), diags
	}

	netmaskVal, ok := netmaskAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`netmask expected to be basetypes.StringValue, was: %T`, netmaskAttribute))
	}

	networkAttribute, ok := attributes["network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`network is missing from object`)

		return NewPortIpConfigValueUnknown(), diags
	}

	networkVal, ok := networkAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`network expected to be basetypes.StringValue, was: %T`, networkAttribute))
	}

	poserPasswordAttribute, ok := attributes["poser_password"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`poser_password is missing from object`)

		return NewPortIpConfigValueUnknown(), diags
	}

	poserPasswordVal, ok := poserPasswordAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`poser_password expected to be basetypes.StringValue, was: %T`, poserPasswordAttribute))
	}

	pppoeAuthAttribute, ok := attributes["pppoe_auth"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pppoe_auth is missing from object`)

		return NewPortIpConfigValueUnknown(), diags
	}

	pppoeAuthVal, ok := pppoeAuthAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pppoe_auth expected to be basetypes.StringValue, was: %T`, pppoeAuthAttribute))
	}

	pppoeUsernameAttribute, ok := attributes["pppoe_username"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pppoe_username is missing from object`)

		return NewPortIpConfigValueUnknown(), diags
	}

	pppoeUsernameVal, ok := pppoeUsernameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pppoe_username expected to be basetypes.StringValue, was: %T`, pppoeUsernameAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewPortIpConfigValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return NewPortIpConfigValueUnknown(), diags
	}

	return PortIpConfigValue{
		Dns:              dnsVal,
		DnsSuffix:        dnsSuffixVal,
		Gateway:          gatewayVal,
		Ip:               ipVal,
		Netmask:          netmaskVal,
		Network:          networkVal,
		PoserPassword:    poserPasswordVal,
		PppoeAuth:        pppoeAuthVal,
		PppoeUsername:    pppoeUsernameVal,
		PortIpConfigType: typeVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewPortIpConfigValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PortIpConfigValue {
	object, diags := NewPortIpConfigValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPortIpConfigValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PortIpConfigType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPortIpConfigValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPortIpConfigValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPortIpConfigValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPortIpConfigValueMust(PortIpConfigValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PortIpConfigType) ValueType(ctx context.Context) attr.Value {
	return PortIpConfigValue{}
}

var _ basetypes.ObjectValuable = PortIpConfigValue{}

type PortIpConfigValue struct {
	Dns              basetypes.ListValue   `tfsdk:"dns"`
	DnsSuffix        basetypes.ListValue   `tfsdk:"dns_suffix"`
	Gateway          basetypes.StringValue `tfsdk:"gateway"`
	Ip               basetypes.StringValue `tfsdk:"ip"`
	Netmask          basetypes.StringValue `tfsdk:"netmask"`
	Network          basetypes.StringValue `tfsdk:"network"`
	PoserPassword    basetypes.StringValue `tfsdk:"poser_password"`
	PppoeAuth        basetypes.StringValue `tfsdk:"pppoe_auth"`
	PppoeUsername    basetypes.StringValue `tfsdk:"pppoe_username"`
	PortIpConfigType basetypes.StringValue `tfsdk:"type"`
	state            attr.ValueState
}

func (v PortIpConfigValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 10)

	var val tftypes.Value
	var err error

	attrTypes["dns"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["dns_suffix"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["gateway"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ip"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["netmask"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["network"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["poser_password"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["pppoe_auth"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["pppoe_username"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 10)

		val, err = v.Dns.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dns"] = val

		val, err = v.DnsSuffix.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dns_suffix"] = val

		val, err = v.Gateway.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["gateway"] = val

		val, err = v.Ip.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip"] = val

		val, err = v.Netmask.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["netmask"] = val

		val, err = v.Network.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["network"] = val

		val, err = v.PoserPassword.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["poser_password"] = val

		val, err = v.PppoeAuth.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["pppoe_auth"] = val

		val, err = v.PppoeUsername.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["pppoe_username"] = val

		val, err = v.PortIpConfigType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PortIpConfigValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PortIpConfigValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PortIpConfigValue) String() string {
	return "PortIpConfigValue"
}

func (v PortIpConfigValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	dnsVal, d := types.ListValue(types.StringType, v.Dns.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"dns": basetypes.ListType{
				ElemType: types.StringType,
			},
			"dns_suffix": basetypes.ListType{
				ElemType: types.StringType,
			},
			"gateway":        basetypes.StringType{},
			"ip":             basetypes.StringType{},
			"netmask":        basetypes.StringType{},
			"network":        basetypes.StringType{},
			"poser_password": basetypes.StringType{},
			"pppoe_auth":     basetypes.StringType{},
			"pppoe_username": basetypes.StringType{},
			"type":           basetypes.StringType{},
		}), diags
	}

	dnsSuffixVal, d := types.ListValue(types.StringType, v.DnsSuffix.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"dns": basetypes.ListType{
				ElemType: types.StringType,
			},
			"dns_suffix": basetypes.ListType{
				ElemType: types.StringType,
			},
			"gateway":        basetypes.StringType{},
			"ip":             basetypes.StringType{},
			"netmask":        basetypes.StringType{},
			"network":        basetypes.StringType{},
			"poser_password": basetypes.StringType{},
			"pppoe_auth":     basetypes.StringType{},
			"pppoe_username": basetypes.StringType{},
			"type":           basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"dns": basetypes.ListType{
			ElemType: types.StringType,
		},
		"dns_suffix": basetypes.ListType{
			ElemType: types.StringType,
		},
		"gateway":        basetypes.StringType{},
		"ip":             basetypes.StringType{},
		"netmask":        basetypes.StringType{},
		"network":        basetypes.StringType{},
		"poser_password": basetypes.StringType{},
		"pppoe_auth":     basetypes.StringType{},
		"pppoe_username": basetypes.StringType{},
		"type":           basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"dns":            dnsVal,
			"dns_suffix":     dnsSuffixVal,
			"gateway":        v.Gateway,
			"ip":             v.Ip,
			"netmask":        v.Netmask,
			"network":        v.Network,
			"poser_password": v.PoserPassword,
			"pppoe_auth":     v.PppoeAuth,
			"pppoe_username": v.PppoeUsername,
			"type":           v.PortIpConfigType,
		})

	return objVal, diags
}

func (v PortIpConfigValue) Equal(o attr.Value) bool {
	other, ok := o.(PortIpConfigValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Dns.Equal(other.Dns) {
		return false
	}

	if !v.DnsSuffix.Equal(other.DnsSuffix) {
		return false
	}

	if !v.Gateway.Equal(other.Gateway) {
		return false
	}

	if !v.Ip.Equal(other.Ip) {
		return false
	}

	if !v.Netmask.Equal(other.Netmask) {
		return false
	}

	if !v.Network.Equal(other.Network) {
		return false
	}

	if !v.PoserPassword.Equal(other.PoserPassword) {
		return false
	}

	if !v.PppoeAuth.Equal(other.PppoeAuth) {
		return false
	}

	if !v.PppoeUsername.Equal(other.PppoeUsername) {
		return false
	}

	if !v.PortIpConfigType.Equal(other.PortIpConfigType) {
		return false
	}

	return true
}

func (v PortIpConfigValue) Type(ctx context.Context) attr.Type {
	return PortIpConfigType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PortIpConfigValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"dns": basetypes.ListType{
			ElemType: types.StringType,
		},
		"dns_suffix": basetypes.ListType{
			ElemType: types.StringType,
		},
		"gateway":        basetypes.StringType{},
		"ip":             basetypes.StringType{},
		"netmask":        basetypes.StringType{},
		"network":        basetypes.StringType{},
		"poser_password": basetypes.StringType{},
		"pppoe_auth":     basetypes.StringType{},
		"pppoe_username": basetypes.StringType{},
		"type":           basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = TrafficShapingType{}

type TrafficShapingType struct {
	basetypes.ObjectType
}

func (t TrafficShapingType) Equal(o attr.Type) bool {
	other, ok := o.(TrafficShapingType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t TrafficShapingType) String() string {
	return "TrafficShapingType"
}

func (t TrafficShapingType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	classPercentagesAttribute, ok := attributes["class_percentages"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`class_percentages is missing from object`)

		return nil, diags
	}

	classPercentagesVal, ok := classPercentagesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`class_percentages expected to be basetypes.ListValue, was: %T`, classPercentagesAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return TrafficShapingValue{
		ClassPercentages: classPercentagesVal,
		Enabled:          enabledVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewTrafficShapingValueNull() TrafficShapingValue {
	return TrafficShapingValue{
		state: attr.ValueStateNull,
	}
}

func NewTrafficShapingValueUnknown() TrafficShapingValue {
	return TrafficShapingValue{
		state: attr.ValueStateUnknown,
	}
}

func NewTrafficShapingValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (TrafficShapingValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing TrafficShapingValue Attribute Value",
				"While creating a TrafficShapingValue value, a missing attribute value was detected. "+
					"A TrafficShapingValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TrafficShapingValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid TrafficShapingValue Attribute Type",
				"While creating a TrafficShapingValue value, an invalid attribute value was detected. "+
					"A TrafficShapingValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TrafficShapingValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("TrafficShapingValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra TrafficShapingValue Attribute Value",
				"While creating a TrafficShapingValue value, an extra attribute value was detected. "+
					"A TrafficShapingValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra TrafficShapingValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewTrafficShapingValueUnknown(), diags
	}

	classPercentagesAttribute, ok := attributes["class_percentages"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`class_percentages is missing from object`)

		return NewTrafficShapingValueUnknown(), diags
	}

	classPercentagesVal, ok := classPercentagesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`class_percentages expected to be basetypes.ListValue, was: %T`, classPercentagesAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewTrafficShapingValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	if diags.HasError() {
		return NewTrafficShapingValueUnknown(), diags
	}

	return TrafficShapingValue{
		ClassPercentages: classPercentagesVal,
		Enabled:          enabledVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewTrafficShapingValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) TrafficShapingValue {
	object, diags := NewTrafficShapingValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewTrafficShapingValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t TrafficShapingType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewTrafficShapingValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewTrafficShapingValueUnknown(), nil
	}

	if in.IsNull() {
		return NewTrafficShapingValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewTrafficShapingValueMust(TrafficShapingValue{}.AttributeTypes(ctx), attributes), nil
}

func (t TrafficShapingType) ValueType(ctx context.Context) attr.Value {
	return TrafficShapingValue{}
}

var _ basetypes.ObjectValuable = TrafficShapingValue{}

type TrafficShapingValue struct {
	ClassPercentages basetypes.ListValue `tfsdk:"class_percentages"`
	Enabled          basetypes.BoolValue `tfsdk:"enabled"`
	state            attr.ValueState
}

func (v TrafficShapingValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["class_percentages"] = basetypes.ListType{
		ElemType: types.Int64Type,
	}.TerraformType(ctx)
	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.ClassPercentages.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["class_percentages"] = val

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v TrafficShapingValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v TrafficShapingValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v TrafficShapingValue) String() string {
	return "TrafficShapingValue"
}

func (v TrafficShapingValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	classPercentagesVal, d := types.ListValue(types.Int64Type, v.ClassPercentages.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"class_percentages": basetypes.ListType{
				ElemType: types.Int64Type,
			},
			"enabled": basetypes.BoolType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"class_percentages": basetypes.ListType{
			ElemType: types.Int64Type,
		},
		"enabled": basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"class_percentages": classPercentagesVal,
			"enabled":           v.Enabled,
		})

	return objVal, diags
}

func (v TrafficShapingValue) Equal(o attr.Value) bool {
	other, ok := o.(TrafficShapingValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.ClassPercentages.Equal(other.ClassPercentages) {
		return false
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	return true
}

func (v TrafficShapingValue) Type(ctx context.Context) attr.Type {
	return TrafficShapingType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v TrafficShapingValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"class_percentages": basetypes.ListType{
			ElemType: types.Int64Type,
		},
		"enabled": basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = VpnPathsType{}

type VpnPathsType struct {
	basetypes.ObjectType
}

func (t VpnPathsType) Equal(o attr.Type) bool {
	other, ok := o.(VpnPathsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t VpnPathsType) String() string {
	return "VpnPathsType"
}

func (t VpnPathsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	bfdProfileAttribute, ok := attributes["bfd_profile"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bfd_profile is missing from object`)

		return nil, diags
	}

	bfdProfileVal, ok := bfdProfileAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bfd_profile expected to be basetypes.StringValue, was: %T`, bfdProfileAttribute))
	}

	bfdUseTunnelModeAttribute, ok := attributes["bfd_use_tunnel_mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bfd_use_tunnel_mode is missing from object`)

		return nil, diags
	}

	bfdUseTunnelModeVal, ok := bfdUseTunnelModeAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bfd_use_tunnel_mode expected to be basetypes.BoolValue, was: %T`, bfdUseTunnelModeAttribute))
	}

	preferenceAttribute, ok := attributes["preference"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`preference is missing from object`)

		return nil, diags
	}

	preferenceVal, ok := preferenceAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`preference expected to be basetypes.Int64Value, was: %T`, preferenceAttribute))
	}

	roleAttribute, ok := attributes["role"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`role is missing from object`)

		return nil, diags
	}

	roleVal, ok := roleAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`role expected to be basetypes.StringValue, was: %T`, roleAttribute))
	}

	trafficShapingAttribute, ok := attributes["traffic_shaping"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`traffic_shaping is missing from object`)

		return nil, diags
	}

	trafficShapingVal, ok := trafficShapingAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`traffic_shaping expected to be basetypes.ObjectValue, was: %T`, trafficShapingAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return VpnPathsValue{
		BfdProfile:       bfdProfileVal,
		BfdUseTunnelMode: bfdUseTunnelModeVal,
		Preference:       preferenceVal,
		Role:             roleVal,
		TrafficShaping:   trafficShapingVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewVpnPathsValueNull() VpnPathsValue {
	return VpnPathsValue{
		state: attr.ValueStateNull,
	}
}

func NewVpnPathsValueUnknown() VpnPathsValue {
	return VpnPathsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewVpnPathsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (VpnPathsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing VpnPathsValue Attribute Value",
				"While creating a VpnPathsValue value, a missing attribute value was detected. "+
					"A VpnPathsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VpnPathsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid VpnPathsValue Attribute Type",
				"While creating a VpnPathsValue value, an invalid attribute value was detected. "+
					"A VpnPathsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VpnPathsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("VpnPathsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra VpnPathsValue Attribute Value",
				"While creating a VpnPathsValue value, an extra attribute value was detected. "+
					"A VpnPathsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra VpnPathsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewVpnPathsValueUnknown(), diags
	}

	bfdProfileAttribute, ok := attributes["bfd_profile"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bfd_profile is missing from object`)

		return NewVpnPathsValueUnknown(), diags
	}

	bfdProfileVal, ok := bfdProfileAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bfd_profile expected to be basetypes.StringValue, was: %T`, bfdProfileAttribute))
	}

	bfdUseTunnelModeAttribute, ok := attributes["bfd_use_tunnel_mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bfd_use_tunnel_mode is missing from object`)

		return NewVpnPathsValueUnknown(), diags
	}

	bfdUseTunnelModeVal, ok := bfdUseTunnelModeAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bfd_use_tunnel_mode expected to be basetypes.BoolValue, was: %T`, bfdUseTunnelModeAttribute))
	}

	preferenceAttribute, ok := attributes["preference"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`preference is missing from object`)

		return NewVpnPathsValueUnknown(), diags
	}

	preferenceVal, ok := preferenceAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`preference expected to be basetypes.Int64Value, was: %T`, preferenceAttribute))
	}

	roleAttribute, ok := attributes["role"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`role is missing from object`)

		return NewVpnPathsValueUnknown(), diags
	}

	roleVal, ok := roleAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`role expected to be basetypes.StringValue, was: %T`, roleAttribute))
	}

	trafficShapingAttribute, ok := attributes["traffic_shaping"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`traffic_shaping is missing from object`)

		return NewVpnPathsValueUnknown(), diags
	}

	trafficShapingVal, ok := trafficShapingAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`traffic_shaping expected to be basetypes.ObjectValue, was: %T`, trafficShapingAttribute))
	}

	if diags.HasError() {
		return NewVpnPathsValueUnknown(), diags
	}

	return VpnPathsValue{
		BfdProfile:       bfdProfileVal,
		BfdUseTunnelMode: bfdUseTunnelModeVal,
		Preference:       preferenceVal,
		Role:             roleVal,
		TrafficShaping:   trafficShapingVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewVpnPathsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) VpnPathsValue {
	object, diags := NewVpnPathsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewVpnPathsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t VpnPathsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewVpnPathsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewVpnPathsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewVpnPathsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewVpnPathsValueMust(VpnPathsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t VpnPathsType) ValueType(ctx context.Context) attr.Value {
	return VpnPathsValue{}
}

var _ basetypes.ObjectValuable = VpnPathsValue{}

type VpnPathsValue struct {
	BfdProfile       basetypes.StringValue `tfsdk:"bfd_profile"`
	BfdUseTunnelMode basetypes.BoolValue   `tfsdk:"bfd_use_tunnel_mode"`
	Preference       basetypes.Int64Value  `tfsdk:"preference"`
	Role             basetypes.StringValue `tfsdk:"role"`
	TrafficShaping   basetypes.ObjectValue `tfsdk:"traffic_shaping"`
	state            attr.ValueState
}

func (v VpnPathsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["bfd_profile"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["bfd_use_tunnel_mode"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["preference"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["role"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["traffic_shaping"] = basetypes.ObjectType{
		AttrTypes: TrafficShapingValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.BfdProfile.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bfd_profile"] = val

		val, err = v.BfdUseTunnelMode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bfd_use_tunnel_mode"] = val

		val, err = v.Preference.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["preference"] = val

		val, err = v.Role.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["role"] = val

		val, err = v.TrafficShaping.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["traffic_shaping"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v VpnPathsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v VpnPathsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v VpnPathsValue) String() string {
	return "VpnPathsValue"
}

func (v VpnPathsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var trafficShaping basetypes.ObjectValue

	if v.TrafficShaping.IsNull() {
		trafficShaping = types.ObjectNull(
			TrafficShapingValue{}.AttributeTypes(ctx),
		)
	}

	if v.TrafficShaping.IsUnknown() {
		trafficShaping = types.ObjectUnknown(
			TrafficShapingValue{}.AttributeTypes(ctx),
		)
	}

	if !v.TrafficShaping.IsNull() && !v.TrafficShaping.IsUnknown() {
		trafficShaping = types.ObjectValueMust(
			TrafficShapingValue{}.AttributeTypes(ctx),
			v.TrafficShaping.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"bfd_profile":         basetypes.StringType{},
		"bfd_use_tunnel_mode": basetypes.BoolType{},
		"preference":          basetypes.Int64Type{},
		"role":                basetypes.StringType{},
		"traffic_shaping": basetypes.ObjectType{
			AttrTypes: TrafficShapingValue{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"bfd_profile":         v.BfdProfile,
			"bfd_use_tunnel_mode": v.BfdUseTunnelMode,
			"preference":          v.Preference,
			"role":                v.Role,
			"traffic_shaping":     trafficShaping,
		})

	return objVal, diags
}

func (v VpnPathsValue) Equal(o attr.Value) bool {
	other, ok := o.(VpnPathsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.BfdProfile.Equal(other.BfdProfile) {
		return false
	}

	if !v.BfdUseTunnelMode.Equal(other.BfdUseTunnelMode) {
		return false
	}

	if !v.Preference.Equal(other.Preference) {
		return false
	}

	if !v.Role.Equal(other.Role) {
		return false
	}

	if !v.TrafficShaping.Equal(other.TrafficShaping) {
		return false
	}

	return true
}

func (v VpnPathsValue) Type(ctx context.Context) attr.Type {
	return VpnPathsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v VpnPathsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"bfd_profile":         basetypes.StringType{},
		"bfd_use_tunnel_mode": basetypes.BoolType{},
		"preference":          basetypes.Int64Type{},
		"role":                basetypes.StringType{},
		"traffic_shaping": basetypes.ObjectType{
			AttrTypes: TrafficShapingValue{}.AttributeTypes(ctx),
		},
	}
}






















var _ basetypes.ObjectTypable = WanSourceNatType{}

type WanSourceNatType struct {
	basetypes.ObjectType
}

func (t WanSourceNatType) Equal(o attr.Type) bool {
	other, ok := o.(WanSourceNatType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t WanSourceNatType) String() string {
	return "WanSourceNatType"
}

func (t WanSourceNatType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	disabledAttribute, ok := attributes["disabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disabled is missing from object`)

		return nil, diags
	}

	disabledVal, ok := disabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disabled expected to be basetypes.BoolValue, was: %T`, disabledAttribute))
	}

	natPoolAttribute, ok := attributes["nat_pool"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`nat_pool is missing from object`)

		return nil, diags
	}

	natPoolVal, ok := natPoolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`nat_pool expected to be basetypes.StringValue, was: %T`, natPoolAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return WanSourceNatValue{
		Disabled: disabledVal,
		NatPool:  natPoolVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewWanSourceNatValueNull() WanSourceNatValue {
	return WanSourceNatValue{
		state: attr.ValueStateNull,
	}
}

func NewWanSourceNatValueUnknown() WanSourceNatValue {
	return WanSourceNatValue{
		state: attr.ValueStateUnknown,
	}
}

func NewWanSourceNatValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (WanSourceNatValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing WanSourceNatValue Attribute Value",
				"While creating a WanSourceNatValue value, a missing attribute value was detected. "+
					"A WanSourceNatValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("WanSourceNatValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid WanSourceNatValue Attribute Type",
				"While creating a WanSourceNatValue value, an invalid attribute value was detected. "+
					"A WanSourceNatValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("WanSourceNatValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("WanSourceNatValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra WanSourceNatValue Attribute Value",
				"While creating a WanSourceNatValue value, an extra attribute value was detected. "+
					"A WanSourceNatValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra WanSourceNatValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewWanSourceNatValueUnknown(), diags
	}

	disabledAttribute, ok := attributes["disabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disabled is missing from object`)

		return NewWanSourceNatValueUnknown(), diags
	}

	disabledVal, ok := disabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disabled expected to be basetypes.BoolValue, was: %T`, disabledAttribute))
	}

	natPoolAttribute, ok := attributes["nat_pool"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`nat_pool is missing from object`)

		return NewWanSourceNatValueUnknown(), diags
	}

	natPoolVal, ok := natPoolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`nat_pool expected to be basetypes.StringValue, was: %T`, natPoolAttribute))
	}

	if diags.HasError() {
		return NewWanSourceNatValueUnknown(), diags
	}

	return WanSourceNatValue{
		Disabled: disabledVal,
		NatPool:  natPoolVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewWanSourceNatValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) WanSourceNatValue {
	object, diags := NewWanSourceNatValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewWanSourceNatValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t WanSourceNatType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewWanSourceNatValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewWanSourceNatValueUnknown(), nil
	}

	if in.IsNull() {
		return NewWanSourceNatValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewWanSourceNatValueMust(WanSourceNatValue{}.AttributeTypes(ctx), attributes), nil
}

func (t WanSourceNatType) ValueType(ctx context.Context) attr.Value {
	return WanSourceNatValue{}
}

var _ basetypes.ObjectValuable = WanSourceNatValue{}

type WanSourceNatValue struct {
	Disabled basetypes.BoolValue   `tfsdk:"disabled"`
	NatPool  basetypes.StringValue `tfsdk:"nat_pool"`
	state    attr.ValueState
}

func (v WanSourceNatValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["disabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["nat_pool"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Disabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["disabled"] = val

		val, err = v.NatPool.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["nat_pool"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v WanSourceNatValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v WanSourceNatValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v WanSourceNatValue) String() string {
	return "WanSourceNatValue"
}

func (v WanSourceNatValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"disabled": basetypes.BoolType{},
		"nat_pool": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"disabled": v.Disabled,
			"nat_pool": v.NatPool,
		})

	return objVal, diags
}

func (v WanSourceNatValue) Equal(o attr.Value) bool {
	other, ok := o.(WanSourceNatValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Disabled.Equal(other.Disabled) {
		return false
	}

	if !v.NatPool.Equal(other.NatPool) {
		return false
	}

	return true
}

func (v WanSourceNatValue) Type(ctx context.Context) attr.Type {
	return WanSourceNatType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v WanSourceNatValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"disabled": basetypes.BoolType{},
		"nat_pool": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = RoutingPoliciesType{}

type RoutingPoliciesType struct {
	basetypes.ObjectType
}

func (t RoutingPoliciesType) Equal(o attr.Type) bool {
	other, ok := o.(RoutingPoliciesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t RoutingPoliciesType) String() string {
	return "RoutingPoliciesType"
}

func (t RoutingPoliciesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	termsAttribute, ok := attributes["terms"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`terms is missing from object`)

		return nil, diags
	}

	termsVal, ok := termsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`terms expected to be basetypes.ListValue, was: %T`, termsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return RoutingPoliciesValue{
		Terms: termsVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewRoutingPoliciesValueNull() RoutingPoliciesValue {
	return RoutingPoliciesValue{
		state: attr.ValueStateNull,
	}
}

func NewRoutingPoliciesValueUnknown() RoutingPoliciesValue {
	return RoutingPoliciesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewRoutingPoliciesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (RoutingPoliciesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing RoutingPoliciesValue Attribute Value",
				"While creating a RoutingPoliciesValue value, a missing attribute value was detected. "+
					"A RoutingPoliciesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RoutingPoliciesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid RoutingPoliciesValue Attribute Type",
				"While creating a RoutingPoliciesValue value, an invalid attribute value was detected. "+
					"A RoutingPoliciesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RoutingPoliciesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("RoutingPoliciesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra RoutingPoliciesValue Attribute Value",
				"While creating a RoutingPoliciesValue value, an extra attribute value was detected. "+
					"A RoutingPoliciesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra RoutingPoliciesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewRoutingPoliciesValueUnknown(), diags
	}

	termsAttribute, ok := attributes["terms"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`terms is missing from object`)

		return NewRoutingPoliciesValueUnknown(), diags
	}

	termsVal, ok := termsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`terms expected to be basetypes.ListValue, was: %T`, termsAttribute))
	}

	if diags.HasError() {
		return NewRoutingPoliciesValueUnknown(), diags
	}

	return RoutingPoliciesValue{
		Terms: termsVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewRoutingPoliciesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) RoutingPoliciesValue {
	object, diags := NewRoutingPoliciesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewRoutingPoliciesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t RoutingPoliciesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewRoutingPoliciesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewRoutingPoliciesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewRoutingPoliciesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewRoutingPoliciesValueMust(RoutingPoliciesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t RoutingPoliciesType) ValueType(ctx context.Context) attr.Value {
	return RoutingPoliciesValue{}
}

var _ basetypes.ObjectValuable = RoutingPoliciesValue{}

type RoutingPoliciesValue struct {
	Terms basetypes.ListValue `tfsdk:"terms"`
	state attr.ValueState
}

func (v RoutingPoliciesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["terms"] = basetypes.ListType{
		ElemType: TermsValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Terms.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["terms"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v RoutingPoliciesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v RoutingPoliciesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v RoutingPoliciesValue) String() string {
	return "RoutingPoliciesValue"
}

func (v RoutingPoliciesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	terms := types.ListValueMust(
		TermsType{
			basetypes.ObjectType{
				AttrTypes: TermsValue{}.AttributeTypes(ctx),
			},
		},
		v.Terms.Elements(),
	)

	if v.Terms.IsNull() {
		terms = types.ListNull(
			TermsType{
				basetypes.ObjectType{
					AttrTypes: TermsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Terms.IsUnknown() {
		terms = types.ListUnknown(
			TermsType{
				basetypes.ObjectType{
					AttrTypes: TermsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"terms": basetypes.ListType{
			ElemType: TermsValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"terms": terms,
		})

	return objVal, diags
}

func (v RoutingPoliciesValue) Equal(o attr.Value) bool {
	other, ok := o.(RoutingPoliciesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Terms.Equal(other.Terms) {
		return false
	}

	return true
}

func (v RoutingPoliciesValue) Type(ctx context.Context) attr.Type {
	return RoutingPoliciesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v RoutingPoliciesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"terms": basetypes.ListType{
			ElemType: TermsValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = TermsType{}

type TermsType struct {
	basetypes.ObjectType
}

func (t TermsType) Equal(o attr.Type) bool {
	other, ok := o.(TermsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t TermsType) String() string {
	return "TermsType"
}

func (t TermsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	actionAttribute, ok := attributes["action"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`action is missing from object`)

		return nil, diags
	}

	actionVal, ok := actionAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`action expected to be basetypes.ObjectValue, was: %T`, actionAttribute))
	}

	routingPolicyTermMatchingAttribute, ok := attributes["matching"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`matching is missing from object`)

		return nil, diags
	}

	routingPolicyTermMatchingVal, ok := routingPolicyTermMatchingAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`matching expected to be basetypes.ObjectValue, was: %T`, routingPolicyTermMatchingAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return TermsValue{
		Action:                    actionVal,
		RoutingPolicyTermMatching: routingPolicyTermMatchingVal,
		state:                     attr.ValueStateKnown,
	}, diags
}

func NewTermsValueNull() TermsValue {
	return TermsValue{
		state: attr.ValueStateNull,
	}
}

func NewTermsValueUnknown() TermsValue {
	return TermsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewTermsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (TermsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing TermsValue Attribute Value",
				"While creating a TermsValue value, a missing attribute value was detected. "+
					"A TermsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TermsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid TermsValue Attribute Type",
				"While creating a TermsValue value, an invalid attribute value was detected. "+
					"A TermsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TermsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("TermsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra TermsValue Attribute Value",
				"While creating a TermsValue value, an extra attribute value was detected. "+
					"A TermsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra TermsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewTermsValueUnknown(), diags
	}

	actionAttribute, ok := attributes["action"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`action is missing from object`)

		return NewTermsValueUnknown(), diags
	}

	actionVal, ok := actionAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`action expected to be basetypes.ObjectValue, was: %T`, actionAttribute))
	}

	routingPolicyTermMatchingAttribute, ok := attributes["matching"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`matching is missing from object`)

		return NewTermsValueUnknown(), diags
	}

	routingPolicyTermMatchingVal, ok := routingPolicyTermMatchingAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`matching expected to be basetypes.ObjectValue, was: %T`, routingPolicyTermMatchingAttribute))
	}

	if diags.HasError() {
		return NewTermsValueUnknown(), diags
	}

	return TermsValue{
		Action:                    actionVal,
		RoutingPolicyTermMatching: routingPolicyTermMatchingVal,
		state:                     attr.ValueStateKnown,
	}, diags
}

func NewTermsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) TermsValue {
	object, diags := NewTermsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewTermsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t TermsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewTermsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewTermsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewTermsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewTermsValueMust(TermsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t TermsType) ValueType(ctx context.Context) attr.Value {
	return TermsValue{}
}

var _ basetypes.ObjectValuable = TermsValue{}

type TermsValue struct {
	Action                    basetypes.ObjectValue `tfsdk:"action"`
	RoutingPolicyTermMatching basetypes.ObjectValue `tfsdk:"matching"`
	state                     attr.ValueState
}

func (v TermsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["action"] = basetypes.ObjectType{
		AttrTypes: ActionValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["matching"] = basetypes.ObjectType{
		AttrTypes: RoutingPolicyTermMatchingValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Action.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["action"] = val

		val, err = v.RoutingPolicyTermMatching.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["matching"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v TermsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v TermsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v TermsValue) String() string {
	return "TermsValue"
}

func (v TermsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var action basetypes.ObjectValue

	if v.Action.IsNull() {
		action = types.ObjectNull(
			ActionValue{}.AttributeTypes(ctx),
		)
	}

	if v.Action.IsUnknown() {
		action = types.ObjectUnknown(
			ActionValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Action.IsNull() && !v.Action.IsUnknown() {
		action = types.ObjectValueMust(
			ActionValue{}.AttributeTypes(ctx),
			v.Action.Attributes(),
		)
	}

	var routingPolicyTermMatching basetypes.ObjectValue

	if v.RoutingPolicyTermMatching.IsNull() {
		routingPolicyTermMatching = types.ObjectNull(
			RoutingPolicyTermMatchingValue{}.AttributeTypes(ctx),
		)
	}

	if v.RoutingPolicyTermMatching.IsUnknown() {
		routingPolicyTermMatching = types.ObjectUnknown(
			RoutingPolicyTermMatchingValue{}.AttributeTypes(ctx),
		)
	}

	if !v.RoutingPolicyTermMatching.IsNull() && !v.RoutingPolicyTermMatching.IsUnknown() {
		routingPolicyTermMatching = types.ObjectValueMust(
			RoutingPolicyTermMatchingValue{}.AttributeTypes(ctx),
			v.RoutingPolicyTermMatching.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"action": basetypes.ObjectType{
			AttrTypes: ActionValue{}.AttributeTypes(ctx),
		},
		"matching": basetypes.ObjectType{
			AttrTypes: RoutingPolicyTermMatchingValue{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"action":                       action,
			"matching": routingPolicyTermMatching,
		})

	return objVal, diags
}

func (v TermsValue) Equal(o attr.Value) bool {
	other, ok := o.(TermsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Action.Equal(other.Action) {
		return false
	}

	if !v.RoutingPolicyTermMatching.Equal(other.RoutingPolicyTermMatching) {
		return false
	}

	return true
}

func (v TermsValue) Type(ctx context.Context) attr.Type {
	return TermsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v TermsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"action": basetypes.ObjectType{
			AttrTypes: ActionValue{}.AttributeTypes(ctx),
		},
		"matching": basetypes.ObjectType{
			AttrTypes: RoutingPolicyTermMatchingValue{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = ActionType{}

type ActionType struct {
	basetypes.ObjectType
}

func (t ActionType) Equal(o attr.Type) bool {
	other, ok := o.(ActionType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ActionType) String() string {
	return "ActionType"
}

func (t ActionType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	acceptAttribute, ok := attributes["accept"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`accept is missing from object`)

		return nil, diags
	}

	acceptVal, ok := acceptAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`accept expected to be basetypes.BoolValue, was: %T`, acceptAttribute))
	}

	addCommunityAttribute, ok := attributes["add_community"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`add_community is missing from object`)

		return nil, diags
	}

	addCommunityVal, ok := addCommunityAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`add_community expected to be basetypes.ListValue, was: %T`, addCommunityAttribute))
	}

	addTargetVrfsAttribute, ok := attributes["add_target_vrfs"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`add_target_vrfs is missing from object`)

		return nil, diags
	}

	addTargetVrfsVal, ok := addTargetVrfsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`add_target_vrfs expected to be basetypes.ListValue, was: %T`, addTargetVrfsAttribute))
	}

	communityAttribute, ok := attributes["community"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`community is missing from object`)

		return nil, diags
	}

	communityVal, ok := communityAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`community expected to be basetypes.ListValue, was: %T`, communityAttribute))
	}

	excludeAsPathAttribute, ok := attributes["exclude_as_path"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`exclude_as_path is missing from object`)

		return nil, diags
	}

	excludeAsPathVal, ok := excludeAsPathAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`exclude_as_path expected to be basetypes.ListValue, was: %T`, excludeAsPathAttribute))
	}

	excludeCommunityAttribute, ok := attributes["exclude_community"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`exclude_community is missing from object`)

		return nil, diags
	}

	excludeCommunityVal, ok := excludeCommunityAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`exclude_community expected to be basetypes.ListValue, was: %T`, excludeCommunityAttribute))
	}

	exportCommunititesAttribute, ok := attributes["export_communitites"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`export_communitites is missing from object`)

		return nil, diags
	}

	exportCommunititesVal, ok := exportCommunititesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`export_communitites expected to be basetypes.ListValue, was: %T`, exportCommunititesAttribute))
	}

	localPreferenceAttribute, ok := attributes["local_preference"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`local_preference is missing from object`)

		return nil, diags
	}

	localPreferenceVal, ok := localPreferenceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`local_preference expected to be basetypes.StringValue, was: %T`, localPreferenceAttribute))
	}

	prependAsPathAttribute, ok := attributes["prepend_as_path"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prepend_as_path is missing from object`)

		return nil, diags
	}

	prependAsPathVal, ok := prependAsPathAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prepend_as_path expected to be basetypes.ListValue, was: %T`, prependAsPathAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ActionValue{
		Accept:             acceptVal,
		AddCommunity:       addCommunityVal,
		AddTargetVrfs:      addTargetVrfsVal,
		Community:          communityVal,
		ExcludeAsPath:      excludeAsPathVal,
		ExcludeCommunity:   excludeCommunityVal,
		ExportCommunitites: exportCommunititesVal,
		LocalPreference:    localPreferenceVal,
		PrependAsPath:      prependAsPathVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewActionValueNull() ActionValue {
	return ActionValue{
		state: attr.ValueStateNull,
	}
}

func NewActionValueUnknown() ActionValue {
	return ActionValue{
		state: attr.ValueStateUnknown,
	}
}

func NewActionValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ActionValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ActionValue Attribute Value",
				"While creating a ActionValue value, a missing attribute value was detected. "+
					"A ActionValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ActionValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ActionValue Attribute Type",
				"While creating a ActionValue value, an invalid attribute value was detected. "+
					"A ActionValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ActionValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ActionValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ActionValue Attribute Value",
				"While creating a ActionValue value, an extra attribute value was detected. "+
					"A ActionValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ActionValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewActionValueUnknown(), diags
	}

	acceptAttribute, ok := attributes["accept"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`accept is missing from object`)

		return NewActionValueUnknown(), diags
	}

	acceptVal, ok := acceptAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`accept expected to be basetypes.BoolValue, was: %T`, acceptAttribute))
	}

	addCommunityAttribute, ok := attributes["add_community"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`add_community is missing from object`)

		return NewActionValueUnknown(), diags
	}

	addCommunityVal, ok := addCommunityAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`add_community expected to be basetypes.ListValue, was: %T`, addCommunityAttribute))
	}

	addTargetVrfsAttribute, ok := attributes["add_target_vrfs"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`add_target_vrfs is missing from object`)

		return NewActionValueUnknown(), diags
	}

	addTargetVrfsVal, ok := addTargetVrfsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`add_target_vrfs expected to be basetypes.ListValue, was: %T`, addTargetVrfsAttribute))
	}

	communityAttribute, ok := attributes["community"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`community is missing from object`)

		return NewActionValueUnknown(), diags
	}

	communityVal, ok := communityAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`community expected to be basetypes.ListValue, was: %T`, communityAttribute))
	}

	excludeAsPathAttribute, ok := attributes["exclude_as_path"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`exclude_as_path is missing from object`)

		return NewActionValueUnknown(), diags
	}

	excludeAsPathVal, ok := excludeAsPathAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`exclude_as_path expected to be basetypes.ListValue, was: %T`, excludeAsPathAttribute))
	}

	excludeCommunityAttribute, ok := attributes["exclude_community"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`exclude_community is missing from object`)

		return NewActionValueUnknown(), diags
	}

	excludeCommunityVal, ok := excludeCommunityAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`exclude_community expected to be basetypes.ListValue, was: %T`, excludeCommunityAttribute))
	}

	exportCommunititesAttribute, ok := attributes["export_communitites"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`export_communitites is missing from object`)

		return NewActionValueUnknown(), diags
	}

	exportCommunititesVal, ok := exportCommunititesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`export_communitites expected to be basetypes.ListValue, was: %T`, exportCommunititesAttribute))
	}

	localPreferenceAttribute, ok := attributes["local_preference"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`local_preference is missing from object`)

		return NewActionValueUnknown(), diags
	}

	localPreferenceVal, ok := localPreferenceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`local_preference expected to be basetypes.StringValue, was: %T`, localPreferenceAttribute))
	}

	prependAsPathAttribute, ok := attributes["prepend_as_path"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prepend_as_path is missing from object`)

		return NewActionValueUnknown(), diags
	}

	prependAsPathVal, ok := prependAsPathAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prepend_as_path expected to be basetypes.ListValue, was: %T`, prependAsPathAttribute))
	}

	if diags.HasError() {
		return NewActionValueUnknown(), diags
	}

	return ActionValue{
		Accept:             acceptVal,
		AddCommunity:       addCommunityVal,
		AddTargetVrfs:      addTargetVrfsVal,
		Community:          communityVal,
		ExcludeAsPath:      excludeAsPathVal,
		ExcludeCommunity:   excludeCommunityVal,
		ExportCommunitites: exportCommunititesVal,
		LocalPreference:    localPreferenceVal,
		PrependAsPath:      prependAsPathVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewActionValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ActionValue {
	object, diags := NewActionValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewActionValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ActionType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewActionValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewActionValueUnknown(), nil
	}

	if in.IsNull() {
		return NewActionValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewActionValueMust(ActionValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ActionType) ValueType(ctx context.Context) attr.Value {
	return ActionValue{}
}

var _ basetypes.ObjectValuable = ActionValue{}

type ActionValue struct {
	Accept             basetypes.BoolValue   `tfsdk:"accept"`
	AddCommunity       basetypes.ListValue   `tfsdk:"add_community"`
	AddTargetVrfs      basetypes.ListValue   `tfsdk:"add_target_vrfs"`
	Community          basetypes.ListValue   `tfsdk:"community"`
	ExcludeAsPath      basetypes.ListValue   `tfsdk:"exclude_as_path"`
	ExcludeCommunity   basetypes.ListValue   `tfsdk:"exclude_community"`
	ExportCommunitites basetypes.ListValue   `tfsdk:"export_communitites"`
	LocalPreference    basetypes.StringValue `tfsdk:"local_preference"`
	PrependAsPath      basetypes.ListValue   `tfsdk:"prepend_as_path"`
	state              attr.ValueState
}

func (v ActionValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 9)

	var val tftypes.Value
	var err error

	attrTypes["accept"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["add_community"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["add_target_vrfs"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["community"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["exclude_as_path"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["exclude_community"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["export_communitites"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["local_preference"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["prepend_as_path"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 9)

		val, err = v.Accept.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["accept"] = val

		val, err = v.AddCommunity.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["add_community"] = val

		val, err = v.AddTargetVrfs.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["add_target_vrfs"] = val

		val, err = v.Community.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["community"] = val

		val, err = v.ExcludeAsPath.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["exclude_as_path"] = val

		val, err = v.ExcludeCommunity.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["exclude_community"] = val

		val, err = v.ExportCommunitites.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["export_communitites"] = val

		val, err = v.LocalPreference.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["local_preference"] = val

		val, err = v.PrependAsPath.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["prepend_as_path"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ActionValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ActionValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ActionValue) String() string {
	return "ActionValue"
}

func (v ActionValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	addCommunityVal, d := types.ListValue(types.StringType, v.AddCommunity.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"accept": basetypes.BoolType{},
			"add_community": basetypes.ListType{
				ElemType: types.StringType,
			},
			"add_target_vrfs": basetypes.ListType{
				ElemType: types.StringType,
			},
			"community": basetypes.ListType{
				ElemType: types.StringType,
			},
			"exclude_as_path": basetypes.ListType{
				ElemType: types.StringType,
			},
			"exclude_community": basetypes.ListType{
				ElemType: types.StringType,
			},
			"export_communitites": basetypes.ListType{
				ElemType: types.StringType,
			},
			"local_preference": basetypes.StringType{},
			"prepend_as_path": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	addTargetVrfsVal, d := types.ListValue(types.StringType, v.AddTargetVrfs.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"accept": basetypes.BoolType{},
			"add_community": basetypes.ListType{
				ElemType: types.StringType,
			},
			"add_target_vrfs": basetypes.ListType{
				ElemType: types.StringType,
			},
			"community": basetypes.ListType{
				ElemType: types.StringType,
			},
			"exclude_as_path": basetypes.ListType{
				ElemType: types.StringType,
			},
			"exclude_community": basetypes.ListType{
				ElemType: types.StringType,
			},
			"export_communitites": basetypes.ListType{
				ElemType: types.StringType,
			},
			"local_preference": basetypes.StringType{},
			"prepend_as_path": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	communityVal, d := types.ListValue(types.StringType, v.Community.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"accept": basetypes.BoolType{},
			"add_community": basetypes.ListType{
				ElemType: types.StringType,
			},
			"add_target_vrfs": basetypes.ListType{
				ElemType: types.StringType,
			},
			"community": basetypes.ListType{
				ElemType: types.StringType,
			},
			"exclude_as_path": basetypes.ListType{
				ElemType: types.StringType,
			},
			"exclude_community": basetypes.ListType{
				ElemType: types.StringType,
			},
			"export_communitites": basetypes.ListType{
				ElemType: types.StringType,
			},
			"local_preference": basetypes.StringType{},
			"prepend_as_path": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	excludeAsPathVal, d := types.ListValue(types.StringType, v.ExcludeAsPath.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"accept": basetypes.BoolType{},
			"add_community": basetypes.ListType{
				ElemType: types.StringType,
			},
			"add_target_vrfs": basetypes.ListType{
				ElemType: types.StringType,
			},
			"community": basetypes.ListType{
				ElemType: types.StringType,
			},
			"exclude_as_path": basetypes.ListType{
				ElemType: types.StringType,
			},
			"exclude_community": basetypes.ListType{
				ElemType: types.StringType,
			},
			"export_communitites": basetypes.ListType{
				ElemType: types.StringType,
			},
			"local_preference": basetypes.StringType{},
			"prepend_as_path": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	excludeCommunityVal, d := types.ListValue(types.StringType, v.ExcludeCommunity.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"accept": basetypes.BoolType{},
			"add_community": basetypes.ListType{
				ElemType: types.StringType,
			},
			"add_target_vrfs": basetypes.ListType{
				ElemType: types.StringType,
			},
			"community": basetypes.ListType{
				ElemType: types.StringType,
			},
			"exclude_as_path": basetypes.ListType{
				ElemType: types.StringType,
			},
			"exclude_community": basetypes.ListType{
				ElemType: types.StringType,
			},
			"export_communitites": basetypes.ListType{
				ElemType: types.StringType,
			},
			"local_preference": basetypes.StringType{},
			"prepend_as_path": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	exportCommunititesVal, d := types.ListValue(types.StringType, v.ExportCommunitites.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"accept": basetypes.BoolType{},
			"add_community": basetypes.ListType{
				ElemType: types.StringType,
			},
			"add_target_vrfs": basetypes.ListType{
				ElemType: types.StringType,
			},
			"community": basetypes.ListType{
				ElemType: types.StringType,
			},
			"exclude_as_path": basetypes.ListType{
				ElemType: types.StringType,
			},
			"exclude_community": basetypes.ListType{
				ElemType: types.StringType,
			},
			"export_communitites": basetypes.ListType{
				ElemType: types.StringType,
			},
			"local_preference": basetypes.StringType{},
			"prepend_as_path": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	prependAsPathVal, d := types.ListValue(types.StringType, v.PrependAsPath.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"accept": basetypes.BoolType{},
			"add_community": basetypes.ListType{
				ElemType: types.StringType,
			},
			"add_target_vrfs": basetypes.ListType{
				ElemType: types.StringType,
			},
			"community": basetypes.ListType{
				ElemType: types.StringType,
			},
			"exclude_as_path": basetypes.ListType{
				ElemType: types.StringType,
			},
			"exclude_community": basetypes.ListType{
				ElemType: types.StringType,
			},
			"export_communitites": basetypes.ListType{
				ElemType: types.StringType,
			},
			"local_preference": basetypes.StringType{},
			"prepend_as_path": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"accept": basetypes.BoolType{},
		"add_community": basetypes.ListType{
			ElemType: types.StringType,
		},
		"add_target_vrfs": basetypes.ListType{
			ElemType: types.StringType,
		},
		"community": basetypes.ListType{
			ElemType: types.StringType,
		},
		"exclude_as_path": basetypes.ListType{
			ElemType: types.StringType,
		},
		"exclude_community": basetypes.ListType{
			ElemType: types.StringType,
		},
		"export_communitites": basetypes.ListType{
			ElemType: types.StringType,
		},
		"local_preference": basetypes.StringType{},
		"prepend_as_path": basetypes.ListType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"accept":              v.Accept,
			"add_community":       addCommunityVal,
			"add_target_vrfs":     addTargetVrfsVal,
			"community":           communityVal,
			"exclude_as_path":     excludeAsPathVal,
			"exclude_community":   excludeCommunityVal,
			"export_communitites": exportCommunititesVal,
			"local_preference":    v.LocalPreference,
			"prepend_as_path":     prependAsPathVal,
		})

	return objVal, diags
}

func (v ActionValue) Equal(o attr.Value) bool {
	other, ok := o.(ActionValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Accept.Equal(other.Accept) {
		return false
	}

	if !v.AddCommunity.Equal(other.AddCommunity) {
		return false
	}

	if !v.AddTargetVrfs.Equal(other.AddTargetVrfs) {
		return false
	}

	if !v.Community.Equal(other.Community) {
		return false
	}

	if !v.ExcludeAsPath.Equal(other.ExcludeAsPath) {
		return false
	}

	if !v.ExcludeCommunity.Equal(other.ExcludeCommunity) {
		return false
	}

	if !v.ExportCommunitites.Equal(other.ExportCommunitites) {
		return false
	}

	if !v.LocalPreference.Equal(other.LocalPreference) {
		return false
	}

	if !v.PrependAsPath.Equal(other.PrependAsPath) {
		return false
	}

	return true
}

func (v ActionValue) Type(ctx context.Context) attr.Type {
	return ActionType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ActionValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"accept": basetypes.BoolType{},
		"add_community": basetypes.ListType{
			ElemType: types.StringType,
		},
		"add_target_vrfs": basetypes.ListType{
			ElemType: types.StringType,
		},
		"community": basetypes.ListType{
			ElemType: types.StringType,
		},
		"exclude_as_path": basetypes.ListType{
			ElemType: types.StringType,
		},
		"exclude_community": basetypes.ListType{
			ElemType: types.StringType,
		},
		"export_communitites": basetypes.ListType{
			ElemType: types.StringType,
		},
		"local_preference": basetypes.StringType{},
		"prepend_as_path": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = RoutingPolicyTermMatchingType{}

type RoutingPolicyTermMatchingType struct {
	basetypes.ObjectType
}

func (t RoutingPolicyTermMatchingType) Equal(o attr.Type) bool {
	other, ok := o.(RoutingPolicyTermMatchingType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t RoutingPolicyTermMatchingType) String() string {
	return "RoutingPolicyTermMatchingType"
}

func (t RoutingPolicyTermMatchingType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	asPathAttribute, ok := attributes["as_path"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`as_path is missing from object`)

		return nil, diags
	}

	asPathVal, ok := asPathAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`as_path expected to be basetypes.ListValue, was: %T`, asPathAttribute))
	}

	communityAttribute, ok := attributes["community"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`community is missing from object`)

		return nil, diags
	}

	communityVal, ok := communityAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`community expected to be basetypes.ListValue, was: %T`, communityAttribute))
	}

	networkAttribute, ok := attributes["network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`network is missing from object`)

		return nil, diags
	}

	networkVal, ok := networkAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`network expected to be basetypes.ListValue, was: %T`, networkAttribute))
	}

	prefixAttribute, ok := attributes["prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix is missing from object`)

		return nil, diags
	}

	prefixVal, ok := prefixAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix expected to be basetypes.ListValue, was: %T`, prefixAttribute))
	}

	protocolAttribute, ok := attributes["protocol"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`protocol is missing from object`)

		return nil, diags
	}

	protocolVal, ok := protocolAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`protocol expected to be basetypes.ListValue, was: %T`, protocolAttribute))
	}

	routeExistsAttribute, ok := attributes["route_exists"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`route_exists is missing from object`)

		return nil, diags
	}

	routeExistsVal, ok := routeExistsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`route_exists expected to be basetypes.ObjectValue, was: %T`, routeExistsAttribute))
	}

	vpnNeighborMacAttribute, ok := attributes["vpn_neighbor_mac"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vpn_neighbor_mac is missing from object`)

		return nil, diags
	}

	vpnNeighborMacVal, ok := vpnNeighborMacAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vpn_neighbor_mac expected to be basetypes.ListValue, was: %T`, vpnNeighborMacAttribute))
	}

	vpnPathAttribute, ok := attributes["vpn_path"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vpn_path is missing from object`)

		return nil, diags
	}

	vpnPathVal, ok := vpnPathAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vpn_path expected to be basetypes.ListValue, was: %T`, vpnPathAttribute))
	}

	vpnPathSlaAttribute, ok := attributes["vpn_path_sla"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vpn_path_sla is missing from object`)

		return nil, diags
	}

	vpnPathSlaVal, ok := vpnPathSlaAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vpn_path_sla expected to be basetypes.ObjectValue, was: %T`, vpnPathSlaAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return RoutingPolicyTermMatchingValue{
		AsPath:         asPathVal,
		Community:      communityVal,
		Network:        networkVal,
		Prefix:         prefixVal,
		Protocol:       protocolVal,
		RouteExists:    routeExistsVal,
		VpnNeighborMac: vpnNeighborMacVal,
		VpnPath:        vpnPathVal,
		VpnPathSla:     vpnPathSlaVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewRoutingPolicyTermMatchingValueNull() RoutingPolicyTermMatchingValue {
	return RoutingPolicyTermMatchingValue{
		state: attr.ValueStateNull,
	}
}

func NewRoutingPolicyTermMatchingValueUnknown() RoutingPolicyTermMatchingValue {
	return RoutingPolicyTermMatchingValue{
		state: attr.ValueStateUnknown,
	}
}

func NewRoutingPolicyTermMatchingValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (RoutingPolicyTermMatchingValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing RoutingPolicyTermMatchingValue Attribute Value",
				"While creating a RoutingPolicyTermMatchingValue value, a missing attribute value was detected. "+
					"A RoutingPolicyTermMatchingValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RoutingPolicyTermMatchingValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid RoutingPolicyTermMatchingValue Attribute Type",
				"While creating a RoutingPolicyTermMatchingValue value, an invalid attribute value was detected. "+
					"A RoutingPolicyTermMatchingValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RoutingPolicyTermMatchingValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("RoutingPolicyTermMatchingValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra RoutingPolicyTermMatchingValue Attribute Value",
				"While creating a RoutingPolicyTermMatchingValue value, an extra attribute value was detected. "+
					"A RoutingPolicyTermMatchingValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra RoutingPolicyTermMatchingValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewRoutingPolicyTermMatchingValueUnknown(), diags
	}

	asPathAttribute, ok := attributes["as_path"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`as_path is missing from object`)

		return NewRoutingPolicyTermMatchingValueUnknown(), diags
	}

	asPathVal, ok := asPathAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`as_path expected to be basetypes.ListValue, was: %T`, asPathAttribute))
	}

	communityAttribute, ok := attributes["community"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`community is missing from object`)

		return NewRoutingPolicyTermMatchingValueUnknown(), diags
	}

	communityVal, ok := communityAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`community expected to be basetypes.ListValue, was: %T`, communityAttribute))
	}

	networkAttribute, ok := attributes["network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`network is missing from object`)

		return NewRoutingPolicyTermMatchingValueUnknown(), diags
	}

	networkVal, ok := networkAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`network expected to be basetypes.ListValue, was: %T`, networkAttribute))
	}

	prefixAttribute, ok := attributes["prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix is missing from object`)

		return NewRoutingPolicyTermMatchingValueUnknown(), diags
	}

	prefixVal, ok := prefixAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix expected to be basetypes.ListValue, was: %T`, prefixAttribute))
	}

	protocolAttribute, ok := attributes["protocol"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`protocol is missing from object`)

		return NewRoutingPolicyTermMatchingValueUnknown(), diags
	}

	protocolVal, ok := protocolAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`protocol expected to be basetypes.ListValue, was: %T`, protocolAttribute))
	}

	routeExistsAttribute, ok := attributes["route_exists"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`route_exists is missing from object`)

		return NewRoutingPolicyTermMatchingValueUnknown(), diags
	}

	routeExistsVal, ok := routeExistsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`route_exists expected to be basetypes.ObjectValue, was: %T`, routeExistsAttribute))
	}

	vpnNeighborMacAttribute, ok := attributes["vpn_neighbor_mac"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vpn_neighbor_mac is missing from object`)

		return NewRoutingPolicyTermMatchingValueUnknown(), diags
	}

	vpnNeighborMacVal, ok := vpnNeighborMacAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vpn_neighbor_mac expected to be basetypes.ListValue, was: %T`, vpnNeighborMacAttribute))
	}

	vpnPathAttribute, ok := attributes["vpn_path"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vpn_path is missing from object`)

		return NewRoutingPolicyTermMatchingValueUnknown(), diags
	}

	vpnPathVal, ok := vpnPathAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vpn_path expected to be basetypes.ListValue, was: %T`, vpnPathAttribute))
	}

	vpnPathSlaAttribute, ok := attributes["vpn_path_sla"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vpn_path_sla is missing from object`)

		return NewRoutingPolicyTermMatchingValueUnknown(), diags
	}

	vpnPathSlaVal, ok := vpnPathSlaAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vpn_path_sla expected to be basetypes.ObjectValue, was: %T`, vpnPathSlaAttribute))
	}

	if diags.HasError() {
		return NewRoutingPolicyTermMatchingValueUnknown(), diags
	}

	return RoutingPolicyTermMatchingValue{
		AsPath:         asPathVal,
		Community:      communityVal,
		Network:        networkVal,
		Prefix:         prefixVal,
		Protocol:       protocolVal,
		RouteExists:    routeExistsVal,
		VpnNeighborMac: vpnNeighborMacVal,
		VpnPath:        vpnPathVal,
		VpnPathSla:     vpnPathSlaVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewRoutingPolicyTermMatchingValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) RoutingPolicyTermMatchingValue {
	object, diags := NewRoutingPolicyTermMatchingValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewRoutingPolicyTermMatchingValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t RoutingPolicyTermMatchingType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewRoutingPolicyTermMatchingValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewRoutingPolicyTermMatchingValueUnknown(), nil
	}

	if in.IsNull() {
		return NewRoutingPolicyTermMatchingValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewRoutingPolicyTermMatchingValueMust(RoutingPolicyTermMatchingValue{}.AttributeTypes(ctx), attributes), nil
}

func (t RoutingPolicyTermMatchingType) ValueType(ctx context.Context) attr.Value {
	return RoutingPolicyTermMatchingValue{}
}

var _ basetypes.ObjectValuable = RoutingPolicyTermMatchingValue{}

type RoutingPolicyTermMatchingValue struct {
	AsPath         basetypes.ListValue   `tfsdk:"as_path"`
	Community      basetypes.ListValue   `tfsdk:"community"`
	Network        basetypes.ListValue   `tfsdk:"network"`
	Prefix         basetypes.ListValue   `tfsdk:"prefix"`
	Protocol       basetypes.ListValue   `tfsdk:"protocol"`
	RouteExists    basetypes.ObjectValue `tfsdk:"route_exists"`
	VpnNeighborMac basetypes.ListValue   `tfsdk:"vpn_neighbor_mac"`
	VpnPath        basetypes.ListValue   `tfsdk:"vpn_path"`
	VpnPathSla     basetypes.ObjectValue `tfsdk:"vpn_path_sla"`
	state          attr.ValueState
}

func (v RoutingPolicyTermMatchingValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 9)

	var val tftypes.Value
	var err error

	attrTypes["as_path"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["community"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["network"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["prefix"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["protocol"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["route_exists"] = basetypes.ObjectType{
		AttrTypes: RouteExistsValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["vpn_neighbor_mac"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["vpn_path"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["vpn_path_sla"] = basetypes.ObjectType{
		AttrTypes: VpnPathSlaValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 9)

		val, err = v.AsPath.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["as_path"] = val

		val, err = v.Community.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["community"] = val

		val, err = v.Network.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["network"] = val

		val, err = v.Prefix.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["prefix"] = val

		val, err = v.Protocol.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["protocol"] = val

		val, err = v.RouteExists.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["route_exists"] = val

		val, err = v.VpnNeighborMac.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vpn_neighbor_mac"] = val

		val, err = v.VpnPath.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vpn_path"] = val

		val, err = v.VpnPathSla.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vpn_path_sla"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v RoutingPolicyTermMatchingValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v RoutingPolicyTermMatchingValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v RoutingPolicyTermMatchingValue) String() string {
	return "RoutingPolicyTermMatchingValue"
}

func (v RoutingPolicyTermMatchingValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var routeExists basetypes.ObjectValue

	if v.RouteExists.IsNull() {
		routeExists = types.ObjectNull(
			RouteExistsValue{}.AttributeTypes(ctx),
		)
	}

	if v.RouteExists.IsUnknown() {
		routeExists = types.ObjectUnknown(
			RouteExistsValue{}.AttributeTypes(ctx),
		)
	}

	if !v.RouteExists.IsNull() && !v.RouteExists.IsUnknown() {
		routeExists = types.ObjectValueMust(
			RouteExistsValue{}.AttributeTypes(ctx),
			v.RouteExists.Attributes(),
		)
	}

	var vpnPathSla basetypes.ObjectValue

	if v.VpnPathSla.IsNull() {
		vpnPathSla = types.ObjectNull(
			VpnPathSlaValue{}.AttributeTypes(ctx),
		)
	}

	if v.VpnPathSla.IsUnknown() {
		vpnPathSla = types.ObjectUnknown(
			VpnPathSlaValue{}.AttributeTypes(ctx),
		)
	}

	if !v.VpnPathSla.IsNull() && !v.VpnPathSla.IsUnknown() {
		vpnPathSla = types.ObjectValueMust(
			VpnPathSlaValue{}.AttributeTypes(ctx),
			v.VpnPathSla.Attributes(),
		)
	}

	asPathVal, d := types.ListValue(types.StringType, v.AsPath.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"as_path": basetypes.ListType{
				ElemType: types.StringType,
			},
			"community": basetypes.ListType{
				ElemType: types.StringType,
			},
			"network": basetypes.ListType{
				ElemType: types.StringType,
			},
			"prefix": basetypes.ListType{
				ElemType: types.StringType,
			},
			"protocol": basetypes.ListType{
				ElemType: types.StringType,
			},
			"route_exists": basetypes.ObjectType{
				AttrTypes: RouteExistsValue{}.AttributeTypes(ctx),
			},
			"vpn_neighbor_mac": basetypes.ListType{
				ElemType: types.StringType,
			},
			"vpn_path": basetypes.ListType{
				ElemType: types.StringType,
			},
			"vpn_path_sla": basetypes.ObjectType{
				AttrTypes: VpnPathSlaValue{}.AttributeTypes(ctx),
			},
		}), diags
	}

	communityVal, d := types.ListValue(types.StringType, v.Community.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"as_path": basetypes.ListType{
				ElemType: types.StringType,
			},
			"community": basetypes.ListType{
				ElemType: types.StringType,
			},
			"network": basetypes.ListType{
				ElemType: types.StringType,
			},
			"prefix": basetypes.ListType{
				ElemType: types.StringType,
			},
			"protocol": basetypes.ListType{
				ElemType: types.StringType,
			},
			"route_exists": basetypes.ObjectType{
				AttrTypes: RouteExistsValue{}.AttributeTypes(ctx),
			},
			"vpn_neighbor_mac": basetypes.ListType{
				ElemType: types.StringType,
			},
			"vpn_path": basetypes.ListType{
				ElemType: types.StringType,
			},
			"vpn_path_sla": basetypes.ObjectType{
				AttrTypes: VpnPathSlaValue{}.AttributeTypes(ctx),
			},
		}), diags
	}

	networkVal, d := types.ListValue(types.StringType, v.Network.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"as_path": basetypes.ListType{
				ElemType: types.StringType,
			},
			"community": basetypes.ListType{
				ElemType: types.StringType,
			},
			"network": basetypes.ListType{
				ElemType: types.StringType,
			},
			"prefix": basetypes.ListType{
				ElemType: types.StringType,
			},
			"protocol": basetypes.ListType{
				ElemType: types.StringType,
			},
			"route_exists": basetypes.ObjectType{
				AttrTypes: RouteExistsValue{}.AttributeTypes(ctx),
			},
			"vpn_neighbor_mac": basetypes.ListType{
				ElemType: types.StringType,
			},
			"vpn_path": basetypes.ListType{
				ElemType: types.StringType,
			},
			"vpn_path_sla": basetypes.ObjectType{
				AttrTypes: VpnPathSlaValue{}.AttributeTypes(ctx),
			},
		}), diags
	}

	prefixVal, d := types.ListValue(types.StringType, v.Prefix.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"as_path": basetypes.ListType{
				ElemType: types.StringType,
			},
			"community": basetypes.ListType{
				ElemType: types.StringType,
			},
			"network": basetypes.ListType{
				ElemType: types.StringType,
			},
			"prefix": basetypes.ListType{
				ElemType: types.StringType,
			},
			"protocol": basetypes.ListType{
				ElemType: types.StringType,
			},
			"route_exists": basetypes.ObjectType{
				AttrTypes: RouteExistsValue{}.AttributeTypes(ctx),
			},
			"vpn_neighbor_mac": basetypes.ListType{
				ElemType: types.StringType,
			},
			"vpn_path": basetypes.ListType{
				ElemType: types.StringType,
			},
			"vpn_path_sla": basetypes.ObjectType{
				AttrTypes: VpnPathSlaValue{}.AttributeTypes(ctx),
			},
		}), diags
	}

	protocolVal, d := types.ListValue(types.StringType, v.Protocol.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"as_path": basetypes.ListType{
				ElemType: types.StringType,
			},
			"community": basetypes.ListType{
				ElemType: types.StringType,
			},
			"network": basetypes.ListType{
				ElemType: types.StringType,
			},
			"prefix": basetypes.ListType{
				ElemType: types.StringType,
			},
			"protocol": basetypes.ListType{
				ElemType: types.StringType,
			},
			"route_exists": basetypes.ObjectType{
				AttrTypes: RouteExistsValue{}.AttributeTypes(ctx),
			},
			"vpn_neighbor_mac": basetypes.ListType{
				ElemType: types.StringType,
			},
			"vpn_path": basetypes.ListType{
				ElemType: types.StringType,
			},
			"vpn_path_sla": basetypes.ObjectType{
				AttrTypes: VpnPathSlaValue{}.AttributeTypes(ctx),
			},
		}), diags
	}

	vpnNeighborMacVal, d := types.ListValue(types.StringType, v.VpnNeighborMac.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"as_path": basetypes.ListType{
				ElemType: types.StringType,
			},
			"community": basetypes.ListType{
				ElemType: types.StringType,
			},
			"network": basetypes.ListType{
				ElemType: types.StringType,
			},
			"prefix": basetypes.ListType{
				ElemType: types.StringType,
			},
			"protocol": basetypes.ListType{
				ElemType: types.StringType,
			},
			"route_exists": basetypes.ObjectType{
				AttrTypes: RouteExistsValue{}.AttributeTypes(ctx),
			},
			"vpn_neighbor_mac": basetypes.ListType{
				ElemType: types.StringType,
			},
			"vpn_path": basetypes.ListType{
				ElemType: types.StringType,
			},
			"vpn_path_sla": basetypes.ObjectType{
				AttrTypes: VpnPathSlaValue{}.AttributeTypes(ctx),
			},
		}), diags
	}

	vpnPathVal, d := types.ListValue(types.StringType, v.VpnPath.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"as_path": basetypes.ListType{
				ElemType: types.StringType,
			},
			"community": basetypes.ListType{
				ElemType: types.StringType,
			},
			"network": basetypes.ListType{
				ElemType: types.StringType,
			},
			"prefix": basetypes.ListType{
				ElemType: types.StringType,
			},
			"protocol": basetypes.ListType{
				ElemType: types.StringType,
			},
			"route_exists": basetypes.ObjectType{
				AttrTypes: RouteExistsValue{}.AttributeTypes(ctx),
			},
			"vpn_neighbor_mac": basetypes.ListType{
				ElemType: types.StringType,
			},
			"vpn_path": basetypes.ListType{
				ElemType: types.StringType,
			},
			"vpn_path_sla": basetypes.ObjectType{
				AttrTypes: VpnPathSlaValue{}.AttributeTypes(ctx),
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"as_path": basetypes.ListType{
			ElemType: types.StringType,
		},
		"community": basetypes.ListType{
			ElemType: types.StringType,
		},
		"network": basetypes.ListType{
			ElemType: types.StringType,
		},
		"prefix": basetypes.ListType{
			ElemType: types.StringType,
		},
		"protocol": basetypes.ListType{
			ElemType: types.StringType,
		},
		"route_exists": basetypes.ObjectType{
			AttrTypes: RouteExistsValue{}.AttributeTypes(ctx),
		},
		"vpn_neighbor_mac": basetypes.ListType{
			ElemType: types.StringType,
		},
		"vpn_path": basetypes.ListType{
			ElemType: types.StringType,
		},
		"vpn_path_sla": basetypes.ObjectType{
			AttrTypes: VpnPathSlaValue{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"as_path":          asPathVal,
			"community":        communityVal,
			"network":          networkVal,
			"prefix":           prefixVal,
			"protocol":         protocolVal,
			"route_exists":     routeExists,
			"vpn_neighbor_mac": vpnNeighborMacVal,
			"vpn_path":         vpnPathVal,
			"vpn_path_sla":     vpnPathSla,
		})

	return objVal, diags
}

func (v RoutingPolicyTermMatchingValue) Equal(o attr.Value) bool {
	other, ok := o.(RoutingPolicyTermMatchingValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AsPath.Equal(other.AsPath) {
		return false
	}

	if !v.Community.Equal(other.Community) {
		return false
	}

	if !v.Network.Equal(other.Network) {
		return false
	}

	if !v.Prefix.Equal(other.Prefix) {
		return false
	}

	if !v.Protocol.Equal(other.Protocol) {
		return false
	}

	if !v.RouteExists.Equal(other.RouteExists) {
		return false
	}

	if !v.VpnNeighborMac.Equal(other.VpnNeighborMac) {
		return false
	}

	if !v.VpnPath.Equal(other.VpnPath) {
		return false
	}

	if !v.VpnPathSla.Equal(other.VpnPathSla) {
		return false
	}

	return true
}

func (v RoutingPolicyTermMatchingValue) Type(ctx context.Context) attr.Type {
	return RoutingPolicyTermMatchingType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v RoutingPolicyTermMatchingValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"as_path": basetypes.ListType{
			ElemType: types.StringType,
		},
		"community": basetypes.ListType{
			ElemType: types.StringType,
		},
		"network": basetypes.ListType{
			ElemType: types.StringType,
		},
		"prefix": basetypes.ListType{
			ElemType: types.StringType,
		},
		"protocol": basetypes.ListType{
			ElemType: types.StringType,
		},
		"route_exists": basetypes.ObjectType{
			AttrTypes: RouteExistsValue{}.AttributeTypes(ctx),
		},
		"vpn_neighbor_mac": basetypes.ListType{
			ElemType: types.StringType,
		},
		"vpn_path": basetypes.ListType{
			ElemType: types.StringType,
		},
		"vpn_path_sla": basetypes.ObjectType{
			AttrTypes: VpnPathSlaValue{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = RouteExistsType{}

type RouteExistsType struct {
	basetypes.ObjectType
}

func (t RouteExistsType) Equal(o attr.Type) bool {
	other, ok := o.(RouteExistsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t RouteExistsType) String() string {
	return "RouteExistsType"
}

func (t RouteExistsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	routeAttribute, ok := attributes["route"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`route is missing from object`)

		return nil, diags
	}

	routeVal, ok := routeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`route expected to be basetypes.StringValue, was: %T`, routeAttribute))
	}

	vrfNameAttribute, ok := attributes["vrf_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vrf_name is missing from object`)

		return nil, diags
	}

	vrfNameVal, ok := vrfNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vrf_name expected to be basetypes.StringValue, was: %T`, vrfNameAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return RouteExistsValue{
		Route:   routeVal,
		VrfName: vrfNameVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewRouteExistsValueNull() RouteExistsValue {
	return RouteExistsValue{
		state: attr.ValueStateNull,
	}
}

func NewRouteExistsValueUnknown() RouteExistsValue {
	return RouteExistsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewRouteExistsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (RouteExistsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing RouteExistsValue Attribute Value",
				"While creating a RouteExistsValue value, a missing attribute value was detected. "+
					"A RouteExistsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RouteExistsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid RouteExistsValue Attribute Type",
				"While creating a RouteExistsValue value, an invalid attribute value was detected. "+
					"A RouteExistsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RouteExistsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("RouteExistsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra RouteExistsValue Attribute Value",
				"While creating a RouteExistsValue value, an extra attribute value was detected. "+
					"A RouteExistsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra RouteExistsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewRouteExistsValueUnknown(), diags
	}

	routeAttribute, ok := attributes["route"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`route is missing from object`)

		return NewRouteExistsValueUnknown(), diags
	}

	routeVal, ok := routeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`route expected to be basetypes.StringValue, was: %T`, routeAttribute))
	}

	vrfNameAttribute, ok := attributes["vrf_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vrf_name is missing from object`)

		return NewRouteExistsValueUnknown(), diags
	}

	vrfNameVal, ok := vrfNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vrf_name expected to be basetypes.StringValue, was: %T`, vrfNameAttribute))
	}

	if diags.HasError() {
		return NewRouteExistsValueUnknown(), diags
	}

	return RouteExistsValue{
		Route:   routeVal,
		VrfName: vrfNameVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewRouteExistsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) RouteExistsValue {
	object, diags := NewRouteExistsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewRouteExistsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t RouteExistsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewRouteExistsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewRouteExistsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewRouteExistsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewRouteExistsValueMust(RouteExistsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t RouteExistsType) ValueType(ctx context.Context) attr.Value {
	return RouteExistsValue{}
}

var _ basetypes.ObjectValuable = RouteExistsValue{}

type RouteExistsValue struct {
	Route   basetypes.StringValue `tfsdk:"route"`
	VrfName basetypes.StringValue `tfsdk:"vrf_name"`
	state   attr.ValueState
}

func (v RouteExistsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["route"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["vrf_name"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Route.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["route"] = val

		val, err = v.VrfName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vrf_name"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v RouteExistsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v RouteExistsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v RouteExistsValue) String() string {
	return "RouteExistsValue"
}

func (v RouteExistsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"route":    basetypes.StringType{},
		"vrf_name": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"route":    v.Route,
			"vrf_name": v.VrfName,
		})

	return objVal, diags
}

func (v RouteExistsValue) Equal(o attr.Value) bool {
	other, ok := o.(RouteExistsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Route.Equal(other.Route) {
		return false
	}

	if !v.VrfName.Equal(other.VrfName) {
		return false
	}

	return true
}

func (v RouteExistsValue) Type(ctx context.Context) attr.Type {
	return RouteExistsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v RouteExistsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"route":    basetypes.StringType{},
		"vrf_name": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = VpnPathSlaType{}

type VpnPathSlaType struct {
	basetypes.ObjectType
}

func (t VpnPathSlaType) Equal(o attr.Type) bool {
	other, ok := o.(VpnPathSlaType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t VpnPathSlaType) String() string {
	return "VpnPathSlaType"
}

func (t VpnPathSlaType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	maxJitterAttribute, ok := attributes["max_jitter"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_jitter is missing from object`)

		return nil, diags
	}

	maxJitterVal, ok := maxJitterAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_jitter expected to be basetypes.Int64Value, was: %T`, maxJitterAttribute))
	}

	maxLatencyAttribute, ok := attributes["max_latency"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_latency is missing from object`)

		return nil, diags
	}

	maxLatencyVal, ok := maxLatencyAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_latency expected to be basetypes.Int64Value, was: %T`, maxLatencyAttribute))
	}

	maxLossAttribute, ok := attributes["max_loss"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_loss is missing from object`)

		return nil, diags
	}

	maxLossVal, ok := maxLossAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_loss expected to be basetypes.Int64Value, was: %T`, maxLossAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return VpnPathSlaValue{
		MaxJitter:  maxJitterVal,
		MaxLatency: maxLatencyVal,
		MaxLoss:    maxLossVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewVpnPathSlaValueNull() VpnPathSlaValue {
	return VpnPathSlaValue{
		state: attr.ValueStateNull,
	}
}

func NewVpnPathSlaValueUnknown() VpnPathSlaValue {
	return VpnPathSlaValue{
		state: attr.ValueStateUnknown,
	}
}

func NewVpnPathSlaValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (VpnPathSlaValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing VpnPathSlaValue Attribute Value",
				"While creating a VpnPathSlaValue value, a missing attribute value was detected. "+
					"A VpnPathSlaValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VpnPathSlaValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid VpnPathSlaValue Attribute Type",
				"While creating a VpnPathSlaValue value, an invalid attribute value was detected. "+
					"A VpnPathSlaValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VpnPathSlaValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("VpnPathSlaValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra VpnPathSlaValue Attribute Value",
				"While creating a VpnPathSlaValue value, an extra attribute value was detected. "+
					"A VpnPathSlaValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra VpnPathSlaValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewVpnPathSlaValueUnknown(), diags
	}

	maxJitterAttribute, ok := attributes["max_jitter"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_jitter is missing from object`)

		return NewVpnPathSlaValueUnknown(), diags
	}

	maxJitterVal, ok := maxJitterAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_jitter expected to be basetypes.Int64Value, was: %T`, maxJitterAttribute))
	}

	maxLatencyAttribute, ok := attributes["max_latency"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_latency is missing from object`)

		return NewVpnPathSlaValueUnknown(), diags
	}

	maxLatencyVal, ok := maxLatencyAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_latency expected to be basetypes.Int64Value, was: %T`, maxLatencyAttribute))
	}

	maxLossAttribute, ok := attributes["max_loss"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_loss is missing from object`)

		return NewVpnPathSlaValueUnknown(), diags
	}

	maxLossVal, ok := maxLossAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_loss expected to be basetypes.Int64Value, was: %T`, maxLossAttribute))
	}

	if diags.HasError() {
		return NewVpnPathSlaValueUnknown(), diags
	}

	return VpnPathSlaValue{
		MaxJitter:  maxJitterVal,
		MaxLatency: maxLatencyVal,
		MaxLoss:    maxLossVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewVpnPathSlaValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) VpnPathSlaValue {
	object, diags := NewVpnPathSlaValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewVpnPathSlaValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t VpnPathSlaType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewVpnPathSlaValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewVpnPathSlaValueUnknown(), nil
	}

	if in.IsNull() {
		return NewVpnPathSlaValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewVpnPathSlaValueMust(VpnPathSlaValue{}.AttributeTypes(ctx), attributes), nil
}

func (t VpnPathSlaType) ValueType(ctx context.Context) attr.Value {
	return VpnPathSlaValue{}
}

var _ basetypes.ObjectValuable = VpnPathSlaValue{}

type VpnPathSlaValue struct {
	MaxJitter  basetypes.Int64Value `tfsdk:"max_jitter"`
	MaxLatency basetypes.Int64Value `tfsdk:"max_latency"`
	MaxLoss    basetypes.Int64Value `tfsdk:"max_loss"`
	state      attr.ValueState
}

func (v VpnPathSlaValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["max_jitter"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["max_latency"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["max_loss"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.MaxJitter.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_jitter"] = val

		val, err = v.MaxLatency.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_latency"] = val

		val, err = v.MaxLoss.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_loss"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v VpnPathSlaValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v VpnPathSlaValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v VpnPathSlaValue) String() string {
	return "VpnPathSlaValue"
}

func (v VpnPathSlaValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"max_jitter":  basetypes.Int64Type{},
		"max_latency": basetypes.Int64Type{},
		"max_loss":    basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"max_jitter":  v.MaxJitter,
			"max_latency": v.MaxLatency,
			"max_loss":    v.MaxLoss,
		})

	return objVal, diags
}

func (v VpnPathSlaValue) Equal(o attr.Value) bool {
	other, ok := o.(VpnPathSlaValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.MaxJitter.Equal(other.MaxJitter) {
		return false
	}

	if !v.MaxLatency.Equal(other.MaxLatency) {
		return false
	}

	if !v.MaxLoss.Equal(other.MaxLoss) {
		return false
	}

	return true
}

func (v VpnPathSlaValue) Type(ctx context.Context) attr.Type {
	return VpnPathSlaType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v VpnPathSlaValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"max_jitter":  basetypes.Int64Type{},
		"max_latency": basetypes.Int64Type{},
		"max_loss":    basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = ServicePoliciesType{}

type ServicePoliciesType struct {
	basetypes.ObjectType
}

func (t ServicePoliciesType) Equal(o attr.Type) bool {
	other, ok := o.(ServicePoliciesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ServicePoliciesType) String() string {
	return "ServicePoliciesType"
}

func (t ServicePoliciesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	actionAttribute, ok := attributes["action"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`action is missing from object`)

		return nil, diags
	}

	actionVal, ok := actionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`action expected to be basetypes.StringValue, was: %T`, actionAttribute))
	}

	appqoeAttribute, ok := attributes["appqoe"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`appqoe is missing from object`)

		return nil, diags
	}

	appqoeVal, ok := appqoeAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`appqoe expected to be basetypes.ObjectValue, was: %T`, appqoeAttribute))
	}

	ewfAttribute, ok := attributes["ewf"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ewf is missing from object`)

		return nil, diags
	}

	ewfVal, ok := ewfAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ewf expected to be basetypes.ListValue, was: %T`, ewfAttribute))
	}

	idpAttribute, ok := attributes["idp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`idp is missing from object`)

		return nil, diags
	}

	idpVal, ok := idpAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`idp expected to be basetypes.ObjectValue, was: %T`, idpAttribute))
	}

	localRoutingAttribute, ok := attributes["local_routing"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`local_routing is missing from object`)

		return nil, diags
	}

	localRoutingVal, ok := localRoutingAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`local_routing expected to be basetypes.BoolValue, was: %T`, localRoutingAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	pathPreferencesAttribute, ok := attributes["path_preferences"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`path_preferences is missing from object`)

		return nil, diags
	}

	pathPreferencesVal, ok := pathPreferencesAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`path_preferences expected to be basetypes.StringValue, was: %T`, pathPreferencesAttribute))
	}

	servicepolicyIdAttribute, ok := attributes["servicepolicy_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`servicepolicy_id is missing from object`)

		return nil, diags
	}

	servicepolicyIdVal, ok := servicepolicyIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`servicepolicy_id expected to be basetypes.StringValue, was: %T`, servicepolicyIdAttribute))
	}

	servicesAttribute, ok := attributes["services"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`services is missing from object`)

		return nil, diags
	}

	servicesVal, ok := servicesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`services expected to be basetypes.ListValue, was: %T`, servicesAttribute))
	}

	tenantsAttribute, ok := attributes["tenants"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tenants is missing from object`)

		return nil, diags
	}

	tenantsVal, ok := tenantsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tenants expected to be basetypes.ListValue, was: %T`, tenantsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ServicePoliciesValue{
		Action:          actionVal,
		Appqoe:          appqoeVal,
		Ewf:             ewfVal,
		Idp:             idpVal,
		LocalRouting:    localRoutingVal,
		Name:            nameVal,
		PathPreferences: pathPreferencesVal,
		ServicepolicyId: servicepolicyIdVal,
		Services:        servicesVal,
		Tenants:         tenantsVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewServicePoliciesValueNull() ServicePoliciesValue {
	return ServicePoliciesValue{
		state: attr.ValueStateNull,
	}
}

func NewServicePoliciesValueUnknown() ServicePoliciesValue {
	return ServicePoliciesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewServicePoliciesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ServicePoliciesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ServicePoliciesValue Attribute Value",
				"While creating a ServicePoliciesValue value, a missing attribute value was detected. "+
					"A ServicePoliciesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ServicePoliciesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ServicePoliciesValue Attribute Type",
				"While creating a ServicePoliciesValue value, an invalid attribute value was detected. "+
					"A ServicePoliciesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ServicePoliciesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ServicePoliciesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ServicePoliciesValue Attribute Value",
				"While creating a ServicePoliciesValue value, an extra attribute value was detected. "+
					"A ServicePoliciesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ServicePoliciesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewServicePoliciesValueUnknown(), diags
	}

	actionAttribute, ok := attributes["action"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`action is missing from object`)

		return NewServicePoliciesValueUnknown(), diags
	}

	actionVal, ok := actionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`action expected to be basetypes.StringValue, was: %T`, actionAttribute))
	}

	appqoeAttribute, ok := attributes["appqoe"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`appqoe is missing from object`)

		return NewServicePoliciesValueUnknown(), diags
	}

	appqoeVal, ok := appqoeAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`appqoe expected to be basetypes.ObjectValue, was: %T`, appqoeAttribute))
	}

	ewfAttribute, ok := attributes["ewf"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ewf is missing from object`)

		return NewServicePoliciesValueUnknown(), diags
	}

	ewfVal, ok := ewfAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ewf expected to be basetypes.ListValue, was: %T`, ewfAttribute))
	}

	idpAttribute, ok := attributes["idp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`idp is missing from object`)

		return NewServicePoliciesValueUnknown(), diags
	}

	idpVal, ok := idpAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`idp expected to be basetypes.ObjectValue, was: %T`, idpAttribute))
	}

	localRoutingAttribute, ok := attributes["local_routing"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`local_routing is missing from object`)

		return NewServicePoliciesValueUnknown(), diags
	}

	localRoutingVal, ok := localRoutingAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`local_routing expected to be basetypes.BoolValue, was: %T`, localRoutingAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewServicePoliciesValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	pathPreferencesAttribute, ok := attributes["path_preferences"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`path_preferences is missing from object`)

		return NewServicePoliciesValueUnknown(), diags
	}

	pathPreferencesVal, ok := pathPreferencesAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`path_preferences expected to be basetypes.StringValue, was: %T`, pathPreferencesAttribute))
	}

	servicepolicyIdAttribute, ok := attributes["servicepolicy_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`servicepolicy_id is missing from object`)

		return NewServicePoliciesValueUnknown(), diags
	}

	servicepolicyIdVal, ok := servicepolicyIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`servicepolicy_id expected to be basetypes.StringValue, was: %T`, servicepolicyIdAttribute))
	}

	servicesAttribute, ok := attributes["services"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`services is missing from object`)

		return NewServicePoliciesValueUnknown(), diags
	}

	servicesVal, ok := servicesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`services expected to be basetypes.ListValue, was: %T`, servicesAttribute))
	}

	tenantsAttribute, ok := attributes["tenants"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tenants is missing from object`)

		return NewServicePoliciesValueUnknown(), diags
	}

	tenantsVal, ok := tenantsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tenants expected to be basetypes.ListValue, was: %T`, tenantsAttribute))
	}

	if diags.HasError() {
		return NewServicePoliciesValueUnknown(), diags
	}

	return ServicePoliciesValue{
		Action:          actionVal,
		Appqoe:          appqoeVal,
		Ewf:             ewfVal,
		Idp:             idpVal,
		LocalRouting:    localRoutingVal,
		Name:            nameVal,
		PathPreferences: pathPreferencesVal,
		ServicepolicyId: servicepolicyIdVal,
		Services:        servicesVal,
		Tenants:         tenantsVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewServicePoliciesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ServicePoliciesValue {
	object, diags := NewServicePoliciesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewServicePoliciesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ServicePoliciesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewServicePoliciesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewServicePoliciesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewServicePoliciesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewServicePoliciesValueMust(ServicePoliciesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ServicePoliciesType) ValueType(ctx context.Context) attr.Value {
	return ServicePoliciesValue{}
}

var _ basetypes.ObjectValuable = ServicePoliciesValue{}

type ServicePoliciesValue struct {
	Action          basetypes.StringValue `tfsdk:"action"`
	Appqoe          basetypes.ObjectValue `tfsdk:"appqoe"`
	Ewf             basetypes.ListValue   `tfsdk:"ewf"`
	Idp             basetypes.ObjectValue `tfsdk:"idp"`
	LocalRouting    basetypes.BoolValue   `tfsdk:"local_routing"`
	Name            basetypes.StringValue `tfsdk:"name"`
	PathPreferences basetypes.StringValue `tfsdk:"path_preferences"`
	ServicepolicyId basetypes.StringValue `tfsdk:"servicepolicy_id"`
	Services        basetypes.ListValue   `tfsdk:"services"`
	Tenants         basetypes.ListValue   `tfsdk:"tenants"`
	state           attr.ValueState
}

func (v ServicePoliciesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 10)

	var val tftypes.Value
	var err error

	attrTypes["action"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["appqoe"] = basetypes.ObjectType{
		AttrTypes: AppqoeValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["ewf"] = basetypes.ListType{
		ElemType: EwfValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["idp"] = basetypes.ObjectType{
		AttrTypes: IdpValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["local_routing"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["path_preferences"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["servicepolicy_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["services"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["tenants"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 10)

		val, err = v.Action.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["action"] = val

		val, err = v.Appqoe.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["appqoe"] = val

		val, err = v.Ewf.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ewf"] = val

		val, err = v.Idp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["idp"] = val

		val, err = v.LocalRouting.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["local_routing"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.PathPreferences.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["path_preferences"] = val

		val, err = v.ServicepolicyId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["servicepolicy_id"] = val

		val, err = v.Services.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["services"] = val

		val, err = v.Tenants.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tenants"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ServicePoliciesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ServicePoliciesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ServicePoliciesValue) String() string {
	return "ServicePoliciesValue"
}

func (v ServicePoliciesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var appqoe basetypes.ObjectValue

	if v.Appqoe.IsNull() {
		appqoe = types.ObjectNull(
			AppqoeValue{}.AttributeTypes(ctx),
		)
	}

	if v.Appqoe.IsUnknown() {
		appqoe = types.ObjectUnknown(
			AppqoeValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Appqoe.IsNull() && !v.Appqoe.IsUnknown() {
		appqoe = types.ObjectValueMust(
			AppqoeValue{}.AttributeTypes(ctx),
			v.Appqoe.Attributes(),
		)
	}

	ewf := types.ListValueMust(
		EwfType{
			basetypes.ObjectType{
				AttrTypes: EwfValue{}.AttributeTypes(ctx),
			},
		},
		v.Ewf.Elements(),
	)

	if v.Ewf.IsNull() {
		ewf = types.ListNull(
			EwfType{
				basetypes.ObjectType{
					AttrTypes: EwfValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Ewf.IsUnknown() {
		ewf = types.ListUnknown(
			EwfType{
				basetypes.ObjectType{
					AttrTypes: EwfValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var idp basetypes.ObjectValue

	if v.Idp.IsNull() {
		idp = types.ObjectNull(
			IdpValue{}.AttributeTypes(ctx),
		)
	}

	if v.Idp.IsUnknown() {
		idp = types.ObjectUnknown(
			IdpValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Idp.IsNull() && !v.Idp.IsUnknown() {
		idp = types.ObjectValueMust(
			IdpValue{}.AttributeTypes(ctx),
			v.Idp.Attributes(),
		)
	}

	servicesVal, d := types.ListValue(types.StringType, v.Services.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"action": basetypes.StringType{},
			"appqoe": basetypes.ObjectType{
				AttrTypes: AppqoeValue{}.AttributeTypes(ctx),
			},
			"ewf": basetypes.ListType{
				ElemType: EwfValue{}.Type(ctx),
			},
			"idp": basetypes.ObjectType{
				AttrTypes: IdpValue{}.AttributeTypes(ctx),
			},
			"local_routing":    basetypes.BoolType{},
			"name":             basetypes.StringType{},
			"path_preferences": basetypes.StringType{},
			"servicepolicy_id": basetypes.StringType{},
			"services": basetypes.ListType{
				ElemType: types.StringType,
			},
			"tenants": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	tenantsVal, d := types.ListValue(types.StringType, v.Tenants.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"action": basetypes.StringType{},
			"appqoe": basetypes.ObjectType{
				AttrTypes: AppqoeValue{}.AttributeTypes(ctx),
			},
			"ewf": basetypes.ListType{
				ElemType: EwfValue{}.Type(ctx),
			},
			"idp": basetypes.ObjectType{
				AttrTypes: IdpValue{}.AttributeTypes(ctx),
			},
			"local_routing":    basetypes.BoolType{},
			"name":             basetypes.StringType{},
			"path_preferences": basetypes.StringType{},
			"servicepolicy_id": basetypes.StringType{},
			"services": basetypes.ListType{
				ElemType: types.StringType,
			},
			"tenants": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"action": basetypes.StringType{},
		"appqoe": basetypes.ObjectType{
			AttrTypes: AppqoeValue{}.AttributeTypes(ctx),
		},
		"ewf": basetypes.ListType{
			ElemType: EwfValue{}.Type(ctx),
		},
		"idp": basetypes.ObjectType{
			AttrTypes: IdpValue{}.AttributeTypes(ctx),
		},
		"local_routing":    basetypes.BoolType{},
		"name":             basetypes.StringType{},
		"path_preferences": basetypes.StringType{},
		"servicepolicy_id": basetypes.StringType{},
		"services": basetypes.ListType{
			ElemType: types.StringType,
		},
		"tenants": basetypes.ListType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"action":           v.Action,
			"appqoe":           appqoe,
			"ewf":              ewf,
			"idp":              idp,
			"local_routing":    v.LocalRouting,
			"name":             v.Name,
			"path_preferences": v.PathPreferences,
			"servicepolicy_id": v.ServicepolicyId,
			"services":         servicesVal,
			"tenants":          tenantsVal,
		})

	return objVal, diags
}

func (v ServicePoliciesValue) Equal(o attr.Value) bool {
	other, ok := o.(ServicePoliciesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Action.Equal(other.Action) {
		return false
	}

	if !v.Appqoe.Equal(other.Appqoe) {
		return false
	}

	if !v.Ewf.Equal(other.Ewf) {
		return false
	}

	if !v.Idp.Equal(other.Idp) {
		return false
	}

	if !v.LocalRouting.Equal(other.LocalRouting) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.PathPreferences.Equal(other.PathPreferences) {
		return false
	}

	if !v.ServicepolicyId.Equal(other.ServicepolicyId) {
		return false
	}

	if !v.Services.Equal(other.Services) {
		return false
	}

	if !v.Tenants.Equal(other.Tenants) {
		return false
	}

	return true
}

func (v ServicePoliciesValue) Type(ctx context.Context) attr.Type {
	return ServicePoliciesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ServicePoliciesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"action": basetypes.StringType{},
		"appqoe": basetypes.ObjectType{
			AttrTypes: AppqoeValue{}.AttributeTypes(ctx),
		},
		"ewf": basetypes.ListType{
			ElemType: EwfValue{}.Type(ctx),
		},
		"idp": basetypes.ObjectType{
			AttrTypes: IdpValue{}.AttributeTypes(ctx),
		},
		"local_routing":    basetypes.BoolType{},
		"name":             basetypes.StringType{},
		"path_preferences": basetypes.StringType{},
		"servicepolicy_id": basetypes.StringType{},
		"services": basetypes.ListType{
			ElemType: types.StringType,
		},
		"tenants": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = AppqoeType{}

type AppqoeType struct {
	basetypes.ObjectType
}

func (t AppqoeType) Equal(o attr.Type) bool {
	other, ok := o.(AppqoeType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AppqoeType) String() string {
	return "AppqoeType"
}

func (t AppqoeType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AppqoeValue{
		Enabled: enabledVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewAppqoeValueNull() AppqoeValue {
	return AppqoeValue{
		state: attr.ValueStateNull,
	}
}

func NewAppqoeValueUnknown() AppqoeValue {
	return AppqoeValue{
		state: attr.ValueStateUnknown,
	}
}

func NewAppqoeValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AppqoeValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AppqoeValue Attribute Value",
				"While creating a AppqoeValue value, a missing attribute value was detected. "+
					"A AppqoeValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AppqoeValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AppqoeValue Attribute Type",
				"While creating a AppqoeValue value, an invalid attribute value was detected. "+
					"A AppqoeValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AppqoeValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AppqoeValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AppqoeValue Attribute Value",
				"While creating a AppqoeValue value, an extra attribute value was detected. "+
					"A AppqoeValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AppqoeValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAppqoeValueUnknown(), diags
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewAppqoeValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	if diags.HasError() {
		return NewAppqoeValueUnknown(), diags
	}

	return AppqoeValue{
		Enabled: enabledVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewAppqoeValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AppqoeValue {
	object, diags := NewAppqoeValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAppqoeValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AppqoeType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAppqoeValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAppqoeValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAppqoeValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAppqoeValueMust(AppqoeValue{}.AttributeTypes(ctx), attributes), nil
}

func (t AppqoeType) ValueType(ctx context.Context) attr.Value {
	return AppqoeValue{}
}

var _ basetypes.ObjectValuable = AppqoeValue{}

type AppqoeValue struct {
	Enabled basetypes.BoolValue `tfsdk:"enabled"`
	state   attr.ValueState
}

func (v AppqoeValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AppqoeValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AppqoeValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AppqoeValue) String() string {
	return "AppqoeValue"
}

func (v AppqoeValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"enabled": basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"enabled": v.Enabled,
		})

	return objVal, diags
}

func (v AppqoeValue) Equal(o attr.Value) bool {
	other, ok := o.(AppqoeValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	return true
}

func (v AppqoeValue) Type(ctx context.Context) attr.Type {
	return AppqoeType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AppqoeValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"enabled": basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = EwfType{}

type EwfType struct {
	basetypes.ObjectType
}

func (t EwfType) Equal(o attr.Type) bool {
	other, ok := o.(EwfType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t EwfType) String() string {
	return "EwfType"
}

func (t EwfType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	alertOnlyAttribute, ok := attributes["alert_only"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`alert_only is missing from object`)

		return nil, diags
	}

	alertOnlyVal, ok := alertOnlyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`alert_only expected to be basetypes.BoolValue, was: %T`, alertOnlyAttribute))
	}

	blockMessageAttribute, ok := attributes["block_message"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`block_message is missing from object`)

		return nil, diags
	}

	blockMessageVal, ok := blockMessageAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`block_message expected to be basetypes.StringValue, was: %T`, blockMessageAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	profileAttribute, ok := attributes["profile"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`profile is missing from object`)

		return nil, diags
	}

	profileVal, ok := profileAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`profile expected to be basetypes.StringValue, was: %T`, profileAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return EwfValue{
		AlertOnly:    alertOnlyVal,
		BlockMessage: blockMessageVal,
		Enabled:      enabledVal,
		Profile:      profileVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewEwfValueNull() EwfValue {
	return EwfValue{
		state: attr.ValueStateNull,
	}
}

func NewEwfValueUnknown() EwfValue {
	return EwfValue{
		state: attr.ValueStateUnknown,
	}
}

func NewEwfValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (EwfValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing EwfValue Attribute Value",
				"While creating a EwfValue value, a missing attribute value was detected. "+
					"A EwfValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("EwfValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid EwfValue Attribute Type",
				"While creating a EwfValue value, an invalid attribute value was detected. "+
					"A EwfValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("EwfValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("EwfValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra EwfValue Attribute Value",
				"While creating a EwfValue value, an extra attribute value was detected. "+
					"A EwfValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra EwfValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewEwfValueUnknown(), diags
	}

	alertOnlyAttribute, ok := attributes["alert_only"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`alert_only is missing from object`)

		return NewEwfValueUnknown(), diags
	}

	alertOnlyVal, ok := alertOnlyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`alert_only expected to be basetypes.BoolValue, was: %T`, alertOnlyAttribute))
	}

	blockMessageAttribute, ok := attributes["block_message"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`block_message is missing from object`)

		return NewEwfValueUnknown(), diags
	}

	blockMessageVal, ok := blockMessageAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`block_message expected to be basetypes.StringValue, was: %T`, blockMessageAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewEwfValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	profileAttribute, ok := attributes["profile"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`profile is missing from object`)

		return NewEwfValueUnknown(), diags
	}

	profileVal, ok := profileAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`profile expected to be basetypes.StringValue, was: %T`, profileAttribute))
	}

	if diags.HasError() {
		return NewEwfValueUnknown(), diags
	}

	return EwfValue{
		AlertOnly:    alertOnlyVal,
		BlockMessage: blockMessageVal,
		Enabled:      enabledVal,
		Profile:      profileVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewEwfValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) EwfValue {
	object, diags := NewEwfValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewEwfValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t EwfType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewEwfValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewEwfValueUnknown(), nil
	}

	if in.IsNull() {
		return NewEwfValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewEwfValueMust(EwfValue{}.AttributeTypes(ctx), attributes), nil
}

func (t EwfType) ValueType(ctx context.Context) attr.Value {
	return EwfValue{}
}

var _ basetypes.ObjectValuable = EwfValue{}

type EwfValue struct {
	AlertOnly    basetypes.BoolValue   `tfsdk:"alert_only"`
	BlockMessage basetypes.StringValue `tfsdk:"block_message"`
	Enabled      basetypes.BoolValue   `tfsdk:"enabled"`
	Profile      basetypes.StringValue `tfsdk:"profile"`
	state        attr.ValueState
}

func (v EwfValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["alert_only"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["block_message"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["profile"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.AlertOnly.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["alert_only"] = val

		val, err = v.BlockMessage.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["block_message"] = val

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.Profile.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["profile"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v EwfValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v EwfValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v EwfValue) String() string {
	return "EwfValue"
}

func (v EwfValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"alert_only":    basetypes.BoolType{},
		"block_message": basetypes.StringType{},
		"enabled":       basetypes.BoolType{},
		"profile":       basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"alert_only":    v.AlertOnly,
			"block_message": v.BlockMessage,
			"enabled":       v.Enabled,
			"profile":       v.Profile,
		})

	return objVal, diags
}

func (v EwfValue) Equal(o attr.Value) bool {
	other, ok := o.(EwfValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AlertOnly.Equal(other.AlertOnly) {
		return false
	}

	if !v.BlockMessage.Equal(other.BlockMessage) {
		return false
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.Profile.Equal(other.Profile) {
		return false
	}

	return true
}

func (v EwfValue) Type(ctx context.Context) attr.Type {
	return EwfType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v EwfValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"alert_only":    basetypes.BoolType{},
		"block_message": basetypes.StringType{},
		"enabled":       basetypes.BoolType{},
		"profile":       basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = IdpType{}

type IdpType struct {
	basetypes.ObjectType
}

func (t IdpType) Equal(o attr.Type) bool {
	other, ok := o.(IdpType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t IdpType) String() string {
	return "IdpType"
}

func (t IdpType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	alertOnlyAttribute, ok := attributes["alert_only"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`alert_only is missing from object`)

		return nil, diags
	}

	alertOnlyVal, ok := alertOnlyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`alert_only expected to be basetypes.BoolValue, was: %T`, alertOnlyAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	idpprofileIdAttribute, ok := attributes["idpprofile_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`idpprofile_id is missing from object`)

		return nil, diags
	}

	idpprofileIdVal, ok := idpprofileIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`idpprofile_id expected to be basetypes.StringValue, was: %T`, idpprofileIdAttribute))
	}

	profileAttribute, ok := attributes["profile"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`profile is missing from object`)

		return nil, diags
	}

	profileVal, ok := profileAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`profile expected to be basetypes.StringValue, was: %T`, profileAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return IdpValue{
		AlertOnly:    alertOnlyVal,
		Enabled:      enabledVal,
		IdpprofileId: idpprofileIdVal,
		Profile:      profileVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewIdpValueNull() IdpValue {
	return IdpValue{
		state: attr.ValueStateNull,
	}
}

func NewIdpValueUnknown() IdpValue {
	return IdpValue{
		state: attr.ValueStateUnknown,
	}
}

func NewIdpValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (IdpValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing IdpValue Attribute Value",
				"While creating a IdpValue value, a missing attribute value was detected. "+
					"A IdpValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("IdpValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid IdpValue Attribute Type",
				"While creating a IdpValue value, an invalid attribute value was detected. "+
					"A IdpValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("IdpValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("IdpValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra IdpValue Attribute Value",
				"While creating a IdpValue value, an extra attribute value was detected. "+
					"A IdpValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra IdpValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewIdpValueUnknown(), diags
	}

	alertOnlyAttribute, ok := attributes["alert_only"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`alert_only is missing from object`)

		return NewIdpValueUnknown(), diags
	}

	alertOnlyVal, ok := alertOnlyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`alert_only expected to be basetypes.BoolValue, was: %T`, alertOnlyAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewIdpValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	idpprofileIdAttribute, ok := attributes["idpprofile_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`idpprofile_id is missing from object`)

		return NewIdpValueUnknown(), diags
	}

	idpprofileIdVal, ok := idpprofileIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`idpprofile_id expected to be basetypes.StringValue, was: %T`, idpprofileIdAttribute))
	}

	profileAttribute, ok := attributes["profile"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`profile is missing from object`)

		return NewIdpValueUnknown(), diags
	}

	profileVal, ok := profileAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`profile expected to be basetypes.StringValue, was: %T`, profileAttribute))
	}

	if diags.HasError() {
		return NewIdpValueUnknown(), diags
	}

	return IdpValue{
		AlertOnly:    alertOnlyVal,
		Enabled:      enabledVal,
		IdpprofileId: idpprofileIdVal,
		Profile:      profileVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewIdpValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) IdpValue {
	object, diags := NewIdpValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewIdpValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t IdpType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewIdpValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewIdpValueUnknown(), nil
	}

	if in.IsNull() {
		return NewIdpValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewIdpValueMust(IdpValue{}.AttributeTypes(ctx), attributes), nil
}

func (t IdpType) ValueType(ctx context.Context) attr.Value {
	return IdpValue{}
}

var _ basetypes.ObjectValuable = IdpValue{}

type IdpValue struct {
	AlertOnly    basetypes.BoolValue   `tfsdk:"alert_only"`
	Enabled      basetypes.BoolValue   `tfsdk:"enabled"`
	IdpprofileId basetypes.StringValue `tfsdk:"idpprofile_id"`
	Profile      basetypes.StringValue `tfsdk:"profile"`
	state        attr.ValueState
}

func (v IdpValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["alert_only"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["idpprofile_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["profile"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.AlertOnly.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["alert_only"] = val

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.IdpprofileId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["idpprofile_id"] = val

		val, err = v.Profile.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["profile"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v IdpValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v IdpValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v IdpValue) String() string {
	return "IdpValue"
}

func (v IdpValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"alert_only":    basetypes.BoolType{},
		"enabled":       basetypes.BoolType{},
		"idpprofile_id": basetypes.StringType{},
		"profile":       basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"alert_only":    v.AlertOnly,
			"enabled":       v.Enabled,
			"idpprofile_id": v.IdpprofileId,
			"profile":       v.Profile,
		})

	return objVal, diags
}

func (v IdpValue) Equal(o attr.Value) bool {
	other, ok := o.(IdpValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AlertOnly.Equal(other.AlertOnly) {
		return false
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.IdpprofileId.Equal(other.IdpprofileId) {
		return false
	}

	if !v.Profile.Equal(other.Profile) {
		return false
	}

	return true
}

func (v IdpValue) Type(ctx context.Context) attr.Type {
	return IdpType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v IdpValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"alert_only":    basetypes.BoolType{},
		"enabled":       basetypes.BoolType{},
		"idpprofile_id": basetypes.StringType{},
		"profile":       basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = TunnelConfigsType{}

type TunnelConfigsType struct {
	basetypes.ObjectType
}

func (t TunnelConfigsType) Equal(o attr.Type) bool {
	other, ok := o.(TunnelConfigsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t TunnelConfigsType) String() string {
	return "TunnelConfigsType"
}

func (t TunnelConfigsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	autoProvisionAttribute, ok := attributes["auto_provision"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auto_provision is missing from object`)

		return nil, diags
	}

	autoProvisionVal, ok := autoProvisionAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auto_provision expected to be basetypes.ObjectValue, was: %T`, autoProvisionAttribute))
	}

	ikeLifetimeAttribute, ok := attributes["ike_lifetime"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ike_lifetime is missing from object`)

		return nil, diags
	}

	ikeLifetimeVal, ok := ikeLifetimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ike_lifetime expected to be basetypes.Int64Value, was: %T`, ikeLifetimeAttribute))
	}

	ikeModeAttribute, ok := attributes["ike_mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ike_mode is missing from object`)

		return nil, diags
	}

	ikeModeVal, ok := ikeModeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ike_mode expected to be basetypes.StringValue, was: %T`, ikeModeAttribute))
	}

	ikeProposalsAttribute, ok := attributes["ike_proposals"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ike_proposals is missing from object`)

		return nil, diags
	}

	ikeProposalsVal, ok := ikeProposalsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ike_proposals expected to be basetypes.ListValue, was: %T`, ikeProposalsAttribute))
	}

	ipsecLifetimeAttribute, ok := attributes["ipsec_lifetime"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipsec_lifetime is missing from object`)

		return nil, diags
	}

	ipsecLifetimeVal, ok := ipsecLifetimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipsec_lifetime expected to be basetypes.Int64Value, was: %T`, ipsecLifetimeAttribute))
	}

	ipsecProposalsAttribute, ok := attributes["ipsec_proposals"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipsec_proposals is missing from object`)

		return nil, diags
	}

	ipsecProposalsVal, ok := ipsecProposalsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipsec_proposals expected to be basetypes.ListValue, was: %T`, ipsecProposalsAttribute))
	}

	localIdAttribute, ok := attributes["local_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`local_id is missing from object`)

		return nil, diags
	}

	localIdVal, ok := localIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`local_id expected to be basetypes.StringValue, was: %T`, localIdAttribute))
	}

	modeAttribute, ok := attributes["mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mode is missing from object`)

		return nil, diags
	}

	modeVal, ok := modeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mode expected to be basetypes.StringValue, was: %T`, modeAttribute))
	}

	primaryAttribute, ok := attributes["primary"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`primary is missing from object`)

		return nil, diags
	}

	primaryVal, ok := primaryAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`primary expected to be basetypes.ObjectValue, was: %T`, primaryAttribute))
	}

	probeAttribute, ok := attributes["probe"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`probe is missing from object`)

		return nil, diags
	}

	probeVal, ok := probeAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`probe expected to be basetypes.ObjectValue, was: %T`, probeAttribute))
	}

	protocolAttribute, ok := attributes["protocol"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`protocol is missing from object`)

		return nil, diags
	}

	protocolVal, ok := protocolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`protocol expected to be basetypes.StringValue, was: %T`, protocolAttribute))
	}

	providerAttribute, ok := attributes["provider"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`provider is missing from object`)

		return nil, diags
	}

	providerVal, ok := providerAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`provider expected to be basetypes.StringValue, was: %T`, providerAttribute))
	}

	pskAttribute, ok := attributes["psk"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`psk is missing from object`)

		return nil, diags
	}

	pskVal, ok := pskAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`psk expected to be basetypes.StringValue, was: %T`, pskAttribute))
	}

	secondaryAttribute, ok := attributes["secondary"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`secondary is missing from object`)

		return nil, diags
	}

	secondaryVal, ok := secondaryAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`secondary expected to be basetypes.ObjectValue, was: %T`, secondaryAttribute))
	}

	versionAttribute, ok := attributes["version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`version is missing from object`)

		return nil, diags
	}

	versionVal, ok := versionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`version expected to be basetypes.StringValue, was: %T`, versionAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return TunnelConfigsValue{
		AutoProvision:  autoProvisionVal,
		IkeLifetime:    ikeLifetimeVal,
		IkeMode:        ikeModeVal,
		IkeProposals:   ikeProposalsVal,
		IpsecLifetime:  ipsecLifetimeVal,
		IpsecProposals: ipsecProposalsVal,
		LocalId:        localIdVal,
		Mode:           modeVal,
		Primary:        primaryVal,
		Probe:          probeVal,
		Protocol:       protocolVal,
		Provider:       providerVal,
		Psk:            pskVal,
		Secondary:      secondaryVal,
		Version:        versionVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewTunnelConfigsValueNull() TunnelConfigsValue {
	return TunnelConfigsValue{
		state: attr.ValueStateNull,
	}
}

func NewTunnelConfigsValueUnknown() TunnelConfigsValue {
	return TunnelConfigsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewTunnelConfigsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (TunnelConfigsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing TunnelConfigsValue Attribute Value",
				"While creating a TunnelConfigsValue value, a missing attribute value was detected. "+
					"A TunnelConfigsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TunnelConfigsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid TunnelConfigsValue Attribute Type",
				"While creating a TunnelConfigsValue value, an invalid attribute value was detected. "+
					"A TunnelConfigsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TunnelConfigsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("TunnelConfigsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra TunnelConfigsValue Attribute Value",
				"While creating a TunnelConfigsValue value, an extra attribute value was detected. "+
					"A TunnelConfigsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra TunnelConfigsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewTunnelConfigsValueUnknown(), diags
	}

	autoProvisionAttribute, ok := attributes["auto_provision"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auto_provision is missing from object`)

		return NewTunnelConfigsValueUnknown(), diags
	}

	autoProvisionVal, ok := autoProvisionAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auto_provision expected to be basetypes.ObjectValue, was: %T`, autoProvisionAttribute))
	}

	ikeLifetimeAttribute, ok := attributes["ike_lifetime"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ike_lifetime is missing from object`)

		return NewTunnelConfigsValueUnknown(), diags
	}

	ikeLifetimeVal, ok := ikeLifetimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ike_lifetime expected to be basetypes.Int64Value, was: %T`, ikeLifetimeAttribute))
	}

	ikeModeAttribute, ok := attributes["ike_mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ike_mode is missing from object`)

		return NewTunnelConfigsValueUnknown(), diags
	}

	ikeModeVal, ok := ikeModeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ike_mode expected to be basetypes.StringValue, was: %T`, ikeModeAttribute))
	}

	ikeProposalsAttribute, ok := attributes["ike_proposals"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ike_proposals is missing from object`)

		return NewTunnelConfigsValueUnknown(), diags
	}

	ikeProposalsVal, ok := ikeProposalsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ike_proposals expected to be basetypes.ListValue, was: %T`, ikeProposalsAttribute))
	}

	ipsecLifetimeAttribute, ok := attributes["ipsec_lifetime"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipsec_lifetime is missing from object`)

		return NewTunnelConfigsValueUnknown(), diags
	}

	ipsecLifetimeVal, ok := ipsecLifetimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipsec_lifetime expected to be basetypes.Int64Value, was: %T`, ipsecLifetimeAttribute))
	}

	ipsecProposalsAttribute, ok := attributes["ipsec_proposals"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipsec_proposals is missing from object`)

		return NewTunnelConfigsValueUnknown(), diags
	}

	ipsecProposalsVal, ok := ipsecProposalsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipsec_proposals expected to be basetypes.ListValue, was: %T`, ipsecProposalsAttribute))
	}

	localIdAttribute, ok := attributes["local_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`local_id is missing from object`)

		return NewTunnelConfigsValueUnknown(), diags
	}

	localIdVal, ok := localIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`local_id expected to be basetypes.StringValue, was: %T`, localIdAttribute))
	}

	modeAttribute, ok := attributes["mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mode is missing from object`)

		return NewTunnelConfigsValueUnknown(), diags
	}

	modeVal, ok := modeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mode expected to be basetypes.StringValue, was: %T`, modeAttribute))
	}

	primaryAttribute, ok := attributes["primary"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`primary is missing from object`)

		return NewTunnelConfigsValueUnknown(), diags
	}

	primaryVal, ok := primaryAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`primary expected to be basetypes.ObjectValue, was: %T`, primaryAttribute))
	}

	probeAttribute, ok := attributes["probe"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`probe is missing from object`)

		return NewTunnelConfigsValueUnknown(), diags
	}

	probeVal, ok := probeAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`probe expected to be basetypes.ObjectValue, was: %T`, probeAttribute))
	}

	protocolAttribute, ok := attributes["protocol"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`protocol is missing from object`)

		return NewTunnelConfigsValueUnknown(), diags
	}

	protocolVal, ok := protocolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`protocol expected to be basetypes.StringValue, was: %T`, protocolAttribute))
	}

	providerAttribute, ok := attributes["provider"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`provider is missing from object`)

		return NewTunnelConfigsValueUnknown(), diags
	}

	providerVal, ok := providerAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`provider expected to be basetypes.StringValue, was: %T`, providerAttribute))
	}

	pskAttribute, ok := attributes["psk"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`psk is missing from object`)

		return NewTunnelConfigsValueUnknown(), diags
	}

	pskVal, ok := pskAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`psk expected to be basetypes.StringValue, was: %T`, pskAttribute))
	}

	secondaryAttribute, ok := attributes["secondary"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`secondary is missing from object`)

		return NewTunnelConfigsValueUnknown(), diags
	}

	secondaryVal, ok := secondaryAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`secondary expected to be basetypes.ObjectValue, was: %T`, secondaryAttribute))
	}

	versionAttribute, ok := attributes["version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`version is missing from object`)

		return NewTunnelConfigsValueUnknown(), diags
	}

	versionVal, ok := versionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`version expected to be basetypes.StringValue, was: %T`, versionAttribute))
	}

	if diags.HasError() {
		return NewTunnelConfigsValueUnknown(), diags
	}

	return TunnelConfigsValue{
		AutoProvision:  autoProvisionVal,
		IkeLifetime:    ikeLifetimeVal,
		IkeMode:        ikeModeVal,
		IkeProposals:   ikeProposalsVal,
		IpsecLifetime:  ipsecLifetimeVal,
		IpsecProposals: ipsecProposalsVal,
		LocalId:        localIdVal,
		Mode:           modeVal,
		Primary:        primaryVal,
		Probe:          probeVal,
		Protocol:       protocolVal,
		Provider:       providerVal,
		Psk:            pskVal,
		Secondary:      secondaryVal,
		Version:        versionVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewTunnelConfigsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) TunnelConfigsValue {
	object, diags := NewTunnelConfigsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewTunnelConfigsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t TunnelConfigsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewTunnelConfigsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewTunnelConfigsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewTunnelConfigsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewTunnelConfigsValueMust(TunnelConfigsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t TunnelConfigsType) ValueType(ctx context.Context) attr.Value {
	return TunnelConfigsValue{}
}

var _ basetypes.ObjectValuable = TunnelConfigsValue{}

type TunnelConfigsValue struct {
	AutoProvision  basetypes.ObjectValue `tfsdk:"auto_provision"`
	IkeLifetime    basetypes.Int64Value  `tfsdk:"ike_lifetime"`
	IkeMode        basetypes.StringValue `tfsdk:"ike_mode"`
	IkeProposals   basetypes.ListValue   `tfsdk:"ike_proposals"`
	IpsecLifetime  basetypes.Int64Value  `tfsdk:"ipsec_lifetime"`
	IpsecProposals basetypes.ListValue   `tfsdk:"ipsec_proposals"`
	LocalId        basetypes.StringValue `tfsdk:"local_id"`
	Mode           basetypes.StringValue `tfsdk:"mode"`
	Primary        basetypes.ObjectValue `tfsdk:"primary"`
	Probe          basetypes.ObjectValue `tfsdk:"probe"`
	Protocol       basetypes.StringValue `tfsdk:"protocol"`
	Provider       basetypes.StringValue `tfsdk:"provider"`
	Psk            basetypes.StringValue `tfsdk:"psk"`
	Secondary      basetypes.ObjectValue `tfsdk:"secondary"`
	Version        basetypes.StringValue `tfsdk:"version"`
	state          attr.ValueState
}

func (v TunnelConfigsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 15)

	var val tftypes.Value
	var err error

	attrTypes["auto_provision"] = basetypes.ObjectType{
		AttrTypes: AutoProvisionValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["ike_lifetime"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["ike_mode"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ike_proposals"] = basetypes.ListType{
		ElemType: IkeProposalsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["ipsec_lifetime"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["ipsec_proposals"] = basetypes.ListType{
		ElemType: IpsecProposalsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["local_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["mode"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["primary"] = basetypes.ObjectType{
		AttrTypes: PrimaryValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["probe"] = basetypes.ObjectType{
		AttrTypes: ProbeValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["protocol"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["provider"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["psk"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["secondary"] = basetypes.ObjectType{
		AttrTypes: SecondaryValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["version"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 15)

		val, err = v.AutoProvision.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["auto_provision"] = val

		val, err = v.IkeLifetime.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ike_lifetime"] = val

		val, err = v.IkeMode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ike_mode"] = val

		val, err = v.IkeProposals.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ike_proposals"] = val

		val, err = v.IpsecLifetime.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ipsec_lifetime"] = val

		val, err = v.IpsecProposals.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ipsec_proposals"] = val

		val, err = v.LocalId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["local_id"] = val

		val, err = v.Mode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mode"] = val

		val, err = v.Primary.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["primary"] = val

		val, err = v.Probe.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["probe"] = val

		val, err = v.Protocol.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["protocol"] = val

		val, err = v.Provider.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["provider"] = val

		val, err = v.Psk.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["psk"] = val

		val, err = v.Secondary.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["secondary"] = val

		val, err = v.Version.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["version"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v TunnelConfigsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v TunnelConfigsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v TunnelConfigsValue) String() string {
	return "TunnelConfigsValue"
}

func (v TunnelConfigsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var autoProvision basetypes.ObjectValue

	if v.AutoProvision.IsNull() {
		autoProvision = types.ObjectNull(
			AutoProvisionValue{}.AttributeTypes(ctx),
		)
	}

	if v.AutoProvision.IsUnknown() {
		autoProvision = types.ObjectUnknown(
			AutoProvisionValue{}.AttributeTypes(ctx),
		)
	}

	if !v.AutoProvision.IsNull() && !v.AutoProvision.IsUnknown() {
		autoProvision = types.ObjectValueMust(
			AutoProvisionValue{}.AttributeTypes(ctx),
			v.AutoProvision.Attributes(),
		)
	}

	ikeProposals := types.ListValueMust(
		IkeProposalsType{
			basetypes.ObjectType{
				AttrTypes: IkeProposalsValue{}.AttributeTypes(ctx),
			},
		},
		v.IkeProposals.Elements(),
	)

	if v.IkeProposals.IsNull() {
		ikeProposals = types.ListNull(
			IkeProposalsType{
				basetypes.ObjectType{
					AttrTypes: IkeProposalsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.IkeProposals.IsUnknown() {
		ikeProposals = types.ListUnknown(
			IkeProposalsType{
				basetypes.ObjectType{
					AttrTypes: IkeProposalsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	ipsecProposals := types.ListValueMust(
		IpsecProposalsType{
			basetypes.ObjectType{
				AttrTypes: IpsecProposalsValue{}.AttributeTypes(ctx),
			},
		},
		v.IpsecProposals.Elements(),
	)

	if v.IpsecProposals.IsNull() {
		ipsecProposals = types.ListNull(
			IpsecProposalsType{
				basetypes.ObjectType{
					AttrTypes: IpsecProposalsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.IpsecProposals.IsUnknown() {
		ipsecProposals = types.ListUnknown(
			IpsecProposalsType{
				basetypes.ObjectType{
					AttrTypes: IpsecProposalsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var primary basetypes.ObjectValue

	if v.Primary.IsNull() {
		primary = types.ObjectNull(
			PrimaryValue{}.AttributeTypes(ctx),
		)
	}

	if v.Primary.IsUnknown() {
		primary = types.ObjectUnknown(
			PrimaryValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Primary.IsNull() && !v.Primary.IsUnknown() {
		primary = types.ObjectValueMust(
			PrimaryValue{}.AttributeTypes(ctx),
			v.Primary.Attributes(),
		)
	}

	var probe basetypes.ObjectValue

	if v.Probe.IsNull() {
		probe = types.ObjectNull(
			ProbeValue{}.AttributeTypes(ctx),
		)
	}

	if v.Probe.IsUnknown() {
		probe = types.ObjectUnknown(
			ProbeValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Probe.IsNull() && !v.Probe.IsUnknown() {
		probe = types.ObjectValueMust(
			ProbeValue{}.AttributeTypes(ctx),
			v.Probe.Attributes(),
		)
	}

	var secondary basetypes.ObjectValue

	if v.Secondary.IsNull() {
		secondary = types.ObjectNull(
			SecondaryValue{}.AttributeTypes(ctx),
		)
	}

	if v.Secondary.IsUnknown() {
		secondary = types.ObjectUnknown(
			SecondaryValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Secondary.IsNull() && !v.Secondary.IsUnknown() {
		secondary = types.ObjectValueMust(
			SecondaryValue{}.AttributeTypes(ctx),
			v.Secondary.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"auto_provision": basetypes.ObjectType{
			AttrTypes: AutoProvisionValue{}.AttributeTypes(ctx),
		},
		"ike_lifetime": basetypes.Int64Type{},
		"ike_mode":     basetypes.StringType{},
		"ike_proposals": basetypes.ListType{
			ElemType: IkeProposalsValue{}.Type(ctx),
		},
		"ipsec_lifetime": basetypes.Int64Type{},
		"ipsec_proposals": basetypes.ListType{
			ElemType: IpsecProposalsValue{}.Type(ctx),
		},
		"local_id": basetypes.StringType{},
		"mode":     basetypes.StringType{},
		"primary": basetypes.ObjectType{
			AttrTypes: PrimaryValue{}.AttributeTypes(ctx),
		},
		"probe": basetypes.ObjectType{
			AttrTypes: ProbeValue{}.AttributeTypes(ctx),
		},
		"protocol": basetypes.StringType{},
		"provider": basetypes.StringType{},
		"psk":      basetypes.StringType{},
		"secondary": basetypes.ObjectType{
			AttrTypes: SecondaryValue{}.AttributeTypes(ctx),
		},
		"version": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"auto_provision":  autoProvision,
			"ike_lifetime":    v.IkeLifetime,
			"ike_mode":        v.IkeMode,
			"ike_proposals":   ikeProposals,
			"ipsec_lifetime":  v.IpsecLifetime,
			"ipsec_proposals": ipsecProposals,
			"local_id":        v.LocalId,
			"mode":            v.Mode,
			"primary":         primary,
			"probe":           probe,
			"protocol":        v.Protocol,
			"provider":        v.Provider,
			"psk":             v.Psk,
			"secondary":       secondary,
			"version":         v.Version,
		})

	return objVal, diags
}

func (v TunnelConfigsValue) Equal(o attr.Value) bool {
	other, ok := o.(TunnelConfigsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AutoProvision.Equal(other.AutoProvision) {
		return false
	}

	if !v.IkeLifetime.Equal(other.IkeLifetime) {
		return false
	}

	if !v.IkeMode.Equal(other.IkeMode) {
		return false
	}

	if !v.IkeProposals.Equal(other.IkeProposals) {
		return false
	}

	if !v.IpsecLifetime.Equal(other.IpsecLifetime) {
		return false
	}

	if !v.IpsecProposals.Equal(other.IpsecProposals) {
		return false
	}

	if !v.LocalId.Equal(other.LocalId) {
		return false
	}

	if !v.Mode.Equal(other.Mode) {
		return false
	}

	if !v.Primary.Equal(other.Primary) {
		return false
	}

	if !v.Probe.Equal(other.Probe) {
		return false
	}

	if !v.Protocol.Equal(other.Protocol) {
		return false
	}

	if !v.Provider.Equal(other.Provider) {
		return false
	}

	if !v.Psk.Equal(other.Psk) {
		return false
	}

	if !v.Secondary.Equal(other.Secondary) {
		return false
	}

	if !v.Version.Equal(other.Version) {
		return false
	}

	return true
}

func (v TunnelConfigsValue) Type(ctx context.Context) attr.Type {
	return TunnelConfigsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v TunnelConfigsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"auto_provision": basetypes.ObjectType{
			AttrTypes: AutoProvisionValue{}.AttributeTypes(ctx),
		},
		"ike_lifetime": basetypes.Int64Type{},
		"ike_mode":     basetypes.StringType{},
		"ike_proposals": basetypes.ListType{
			ElemType: IkeProposalsValue{}.Type(ctx),
		},
		"ipsec_lifetime": basetypes.Int64Type{},
		"ipsec_proposals": basetypes.ListType{
			ElemType: IpsecProposalsValue{}.Type(ctx),
		},
		"local_id": basetypes.StringType{},
		"mode":     basetypes.StringType{},
		"primary": basetypes.ObjectType{
			AttrTypes: PrimaryValue{}.AttributeTypes(ctx),
		},
		"probe": basetypes.ObjectType{
			AttrTypes: ProbeValue{}.AttributeTypes(ctx),
		},
		"protocol": basetypes.StringType{},
		"provider": basetypes.StringType{},
		"psk":      basetypes.StringType{},
		"secondary": basetypes.ObjectType{
			AttrTypes: SecondaryValue{}.AttributeTypes(ctx),
		},
		"version": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = AutoProvisionType{}

type AutoProvisionType struct {
	basetypes.ObjectType
}

func (t AutoProvisionType) Equal(o attr.Type) bool {
	other, ok := o.(AutoProvisionType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AutoProvisionType) String() string {
	return "AutoProvisionType"
}

func (t AutoProvisionType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	autoProvisionPrimaryAttribute, ok := attributes["primary"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`primary is missing from object`)

		return nil, diags
	}

	autoProvisionPrimaryVal, ok := autoProvisionPrimaryAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`primary expected to be basetypes.ObjectValue, was: %T`, autoProvisionPrimaryAttribute))
	}

	autoProvisionSecondaryAttribute, ok := attributes["secondary"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`secondary is missing from object`)

		return nil, diags
	}

	autoProvisionSecondaryVal, ok := autoProvisionSecondaryAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`secondary expected to be basetypes.ObjectValue, was: %T`, autoProvisionSecondaryAttribute))
	}

	enableAttribute, ok := attributes["enable"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable is missing from object`)

		return nil, diags
	}

	enableVal, ok := enableAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable expected to be basetypes.BoolValue, was: %T`, enableAttribute))
	}

	latlngAttribute, ok := attributes["latlng"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`latlng is missing from object`)

		return nil, diags
	}

	latlngVal, ok := latlngAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`latlng expected to be basetypes.ObjectValue, was: %T`, latlngAttribute))
	}

	regionAttribute, ok := attributes["region"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`region is missing from object`)

		return nil, diags
	}

	regionVal, ok := regionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`region expected to be basetypes.StringValue, was: %T`, regionAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AutoProvisionValue{
		AutoProvisionPrimary:   autoProvisionPrimaryVal,
		AutoProvisionSecondary: autoProvisionSecondaryVal,
		Enable:                 enableVal,
		Latlng:                 latlngVal,
		Region:                 regionVal,
		state:                  attr.ValueStateKnown,
	}, diags
}

func NewAutoProvisionValueNull() AutoProvisionValue {
	return AutoProvisionValue{
		state: attr.ValueStateNull,
	}
}

func NewAutoProvisionValueUnknown() AutoProvisionValue {
	return AutoProvisionValue{
		state: attr.ValueStateUnknown,
	}
}

func NewAutoProvisionValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AutoProvisionValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AutoProvisionValue Attribute Value",
				"While creating a AutoProvisionValue value, a missing attribute value was detected. "+
					"A AutoProvisionValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AutoProvisionValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AutoProvisionValue Attribute Type",
				"While creating a AutoProvisionValue value, an invalid attribute value was detected. "+
					"A AutoProvisionValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AutoProvisionValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AutoProvisionValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AutoProvisionValue Attribute Value",
				"While creating a AutoProvisionValue value, an extra attribute value was detected. "+
					"A AutoProvisionValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AutoProvisionValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAutoProvisionValueUnknown(), diags
	}

	autoProvisionPrimaryAttribute, ok := attributes["primary"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`primary is missing from object`)

		return NewAutoProvisionValueUnknown(), diags
	}

	autoProvisionPrimaryVal, ok := autoProvisionPrimaryAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`primary expected to be basetypes.ObjectValue, was: %T`, autoProvisionPrimaryAttribute))
	}

	autoProvisionSecondaryAttribute, ok := attributes["secondary"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`secondary is missing from object`)

		return NewAutoProvisionValueUnknown(), diags
	}

	autoProvisionSecondaryVal, ok := autoProvisionSecondaryAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`secondary expected to be basetypes.ObjectValue, was: %T`, autoProvisionSecondaryAttribute))
	}

	enableAttribute, ok := attributes["enable"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable is missing from object`)

		return NewAutoProvisionValueUnknown(), diags
	}

	enableVal, ok := enableAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable expected to be basetypes.BoolValue, was: %T`, enableAttribute))
	}

	latlngAttribute, ok := attributes["latlng"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`latlng is missing from object`)

		return NewAutoProvisionValueUnknown(), diags
	}

	latlngVal, ok := latlngAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`latlng expected to be basetypes.ObjectValue, was: %T`, latlngAttribute))
	}

	regionAttribute, ok := attributes["region"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`region is missing from object`)

		return NewAutoProvisionValueUnknown(), diags
	}

	regionVal, ok := regionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`region expected to be basetypes.StringValue, was: %T`, regionAttribute))
	}

	if diags.HasError() {
		return NewAutoProvisionValueUnknown(), diags
	}

	return AutoProvisionValue{
		AutoProvisionPrimary:   autoProvisionPrimaryVal,
		AutoProvisionSecondary: autoProvisionSecondaryVal,
		Enable:                 enableVal,
		Latlng:                 latlngVal,
		Region:                 regionVal,
		state:                  attr.ValueStateKnown,
	}, diags
}

func NewAutoProvisionValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AutoProvisionValue {
	object, diags := NewAutoProvisionValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAutoProvisionValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AutoProvisionType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAutoProvisionValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAutoProvisionValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAutoProvisionValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAutoProvisionValueMust(AutoProvisionValue{}.AttributeTypes(ctx), attributes), nil
}

func (t AutoProvisionType) ValueType(ctx context.Context) attr.Value {
	return AutoProvisionValue{}
}

var _ basetypes.ObjectValuable = AutoProvisionValue{}

type AutoProvisionValue struct {
	AutoProvisionPrimary   basetypes.ObjectValue `tfsdk:"primary"`
	AutoProvisionSecondary basetypes.ObjectValue `tfsdk:"secondary"`
	Enable                 basetypes.BoolValue   `tfsdk:"enable"`
	Latlng                 basetypes.ObjectValue `tfsdk:"latlng"`
	Region                 basetypes.StringValue `tfsdk:"region"`
	state                  attr.ValueState
}

func (v AutoProvisionValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["primary"] = basetypes.ObjectType{
		AttrTypes: AutoProvisionPrimaryValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["secondary"] = basetypes.ObjectType{
		AttrTypes: AutoProvisionSecondaryValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["enable"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["latlng"] = basetypes.ObjectType{
		AttrTypes: LatlngValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["region"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.AutoProvisionPrimary.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["primary"] = val

		val, err = v.AutoProvisionSecondary.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["secondary"] = val

		val, err = v.Enable.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enable"] = val

		val, err = v.Latlng.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["latlng"] = val

		val, err = v.Region.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["region"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AutoProvisionValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AutoProvisionValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AutoProvisionValue) String() string {
	return "AutoProvisionValue"
}

func (v AutoProvisionValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var autoProvisionPrimary basetypes.ObjectValue

	if v.AutoProvisionPrimary.IsNull() {
		autoProvisionPrimary = types.ObjectNull(
			AutoProvisionPrimaryValue{}.AttributeTypes(ctx),
		)
	}

	if v.AutoProvisionPrimary.IsUnknown() {
		autoProvisionPrimary = types.ObjectUnknown(
			AutoProvisionPrimaryValue{}.AttributeTypes(ctx),
		)
	}

	if !v.AutoProvisionPrimary.IsNull() && !v.AutoProvisionPrimary.IsUnknown() {
		autoProvisionPrimary = types.ObjectValueMust(
			AutoProvisionPrimaryValue{}.AttributeTypes(ctx),
			v.AutoProvisionPrimary.Attributes(),
		)
	}

	var autoProvisionSecondary basetypes.ObjectValue

	if v.AutoProvisionSecondary.IsNull() {
		autoProvisionSecondary = types.ObjectNull(
			AutoProvisionSecondaryValue{}.AttributeTypes(ctx),
		)
	}

	if v.AutoProvisionSecondary.IsUnknown() {
		autoProvisionSecondary = types.ObjectUnknown(
			AutoProvisionSecondaryValue{}.AttributeTypes(ctx),
		)
	}

	if !v.AutoProvisionSecondary.IsNull() && !v.AutoProvisionSecondary.IsUnknown() {
		autoProvisionSecondary = types.ObjectValueMust(
			AutoProvisionSecondaryValue{}.AttributeTypes(ctx),
			v.AutoProvisionSecondary.Attributes(),
		)
	}

	var latlng basetypes.ObjectValue

	if v.Latlng.IsNull() {
		latlng = types.ObjectNull(
			LatlngValue{}.AttributeTypes(ctx),
		)
	}

	if v.Latlng.IsUnknown() {
		latlng = types.ObjectUnknown(
			LatlngValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Latlng.IsNull() && !v.Latlng.IsUnknown() {
		latlng = types.ObjectValueMust(
			LatlngValue{}.AttributeTypes(ctx),
			v.Latlng.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"primary": basetypes.ObjectType{
			AttrTypes: AutoProvisionPrimaryValue{}.AttributeTypes(ctx),
		},
		"secondary": basetypes.ObjectType{
			AttrTypes: AutoProvisionSecondaryValue{}.AttributeTypes(ctx),
		},
		"enable": basetypes.BoolType{},
		"latlng": basetypes.ObjectType{
			AttrTypes: LatlngValue{}.AttributeTypes(ctx),
		},
		"region": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"primary":   autoProvisionPrimary,
			"secondary": autoProvisionSecondary,
			"enable":                   v.Enable,
			"latlng":                   latlng,
			"region":                   v.Region,
		})

	return objVal, diags
}

func (v AutoProvisionValue) Equal(o attr.Value) bool {
	other, ok := o.(AutoProvisionValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AutoProvisionPrimary.Equal(other.AutoProvisionPrimary) {
		return false
	}

	if !v.AutoProvisionSecondary.Equal(other.AutoProvisionSecondary) {
		return false
	}

	if !v.Enable.Equal(other.Enable) {
		return false
	}

	if !v.Latlng.Equal(other.Latlng) {
		return false
	}

	if !v.Region.Equal(other.Region) {
		return false
	}

	return true
}

func (v AutoProvisionValue) Type(ctx context.Context) attr.Type {
	return AutoProvisionType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AutoProvisionValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"primary": basetypes.ObjectType{
			AttrTypes: AutoProvisionPrimaryValue{}.AttributeTypes(ctx),
		},
		"secondary": basetypes.ObjectType{
			AttrTypes: AutoProvisionSecondaryValue{}.AttributeTypes(ctx),
		},
		"enable": basetypes.BoolType{},
		"latlng": basetypes.ObjectType{
			AttrTypes: LatlngValue{}.AttributeTypes(ctx),
		},
		"region": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = AutoProvisionPrimaryType{}

type AutoProvisionPrimaryType struct {
	basetypes.ObjectType
}

func (t AutoProvisionPrimaryType) Equal(o attr.Type) bool {
	other, ok := o.(AutoProvisionPrimaryType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AutoProvisionPrimaryType) String() string {
	return "AutoProvisionPrimaryType"
}

func (t AutoProvisionPrimaryType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	numHostsAttribute, ok := attributes["num_hosts"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`num_hosts is missing from object`)

		return nil, diags
	}

	numHostsVal, ok := numHostsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`num_hosts expected to be basetypes.StringValue, was: %T`, numHostsAttribute))
	}

	wanNamesAttribute, ok := attributes["wan_names"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wan_names is missing from object`)

		return nil, diags
	}

	wanNamesVal, ok := wanNamesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wan_names expected to be basetypes.ListValue, was: %T`, wanNamesAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AutoProvisionPrimaryValue{
		NumHosts: numHostsVal,
		WanNames: wanNamesVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewAutoProvisionPrimaryValueNull() AutoProvisionPrimaryValue {
	return AutoProvisionPrimaryValue{
		state: attr.ValueStateNull,
	}
}

func NewAutoProvisionPrimaryValueUnknown() AutoProvisionPrimaryValue {
	return AutoProvisionPrimaryValue{
		state: attr.ValueStateUnknown,
	}
}

func NewAutoProvisionPrimaryValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AutoProvisionPrimaryValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AutoProvisionPrimaryValue Attribute Value",
				"While creating a AutoProvisionPrimaryValue value, a missing attribute value was detected. "+
					"A AutoProvisionPrimaryValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AutoProvisionPrimaryValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AutoProvisionPrimaryValue Attribute Type",
				"While creating a AutoProvisionPrimaryValue value, an invalid attribute value was detected. "+
					"A AutoProvisionPrimaryValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AutoProvisionPrimaryValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AutoProvisionPrimaryValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AutoProvisionPrimaryValue Attribute Value",
				"While creating a AutoProvisionPrimaryValue value, an extra attribute value was detected. "+
					"A AutoProvisionPrimaryValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AutoProvisionPrimaryValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAutoProvisionPrimaryValueUnknown(), diags
	}

	numHostsAttribute, ok := attributes["num_hosts"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`num_hosts is missing from object`)

		return NewAutoProvisionPrimaryValueUnknown(), diags
	}

	numHostsVal, ok := numHostsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`num_hosts expected to be basetypes.StringValue, was: %T`, numHostsAttribute))
	}

	wanNamesAttribute, ok := attributes["wan_names"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wan_names is missing from object`)

		return NewAutoProvisionPrimaryValueUnknown(), diags
	}

	wanNamesVal, ok := wanNamesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wan_names expected to be basetypes.ListValue, was: %T`, wanNamesAttribute))
	}

	if diags.HasError() {
		return NewAutoProvisionPrimaryValueUnknown(), diags
	}

	return AutoProvisionPrimaryValue{
		NumHosts: numHostsVal,
		WanNames: wanNamesVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewAutoProvisionPrimaryValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AutoProvisionPrimaryValue {
	object, diags := NewAutoProvisionPrimaryValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAutoProvisionPrimaryValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AutoProvisionPrimaryType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAutoProvisionPrimaryValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAutoProvisionPrimaryValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAutoProvisionPrimaryValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAutoProvisionPrimaryValueMust(AutoProvisionPrimaryValue{}.AttributeTypes(ctx), attributes), nil
}

func (t AutoProvisionPrimaryType) ValueType(ctx context.Context) attr.Value {
	return AutoProvisionPrimaryValue{}
}

var _ basetypes.ObjectValuable = AutoProvisionPrimaryValue{}

type AutoProvisionPrimaryValue struct {
	NumHosts basetypes.StringValue `tfsdk:"num_hosts"`
	WanNames basetypes.ListValue   `tfsdk:"wan_names"`
	state    attr.ValueState
}

func (v AutoProvisionPrimaryValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["num_hosts"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["wan_names"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.NumHosts.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["num_hosts"] = val

		val, err = v.WanNames.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["wan_names"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AutoProvisionPrimaryValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AutoProvisionPrimaryValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AutoProvisionPrimaryValue) String() string {
	return "AutoProvisionPrimaryValue"
}

func (v AutoProvisionPrimaryValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	wanNamesVal, d := types.ListValue(types.StringType, v.WanNames.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"num_hosts": basetypes.StringType{},
			"wan_names": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"num_hosts": basetypes.StringType{},
		"wan_names": basetypes.ListType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"num_hosts": v.NumHosts,
			"wan_names": wanNamesVal,
		})

	return objVal, diags
}

func (v AutoProvisionPrimaryValue) Equal(o attr.Value) bool {
	other, ok := o.(AutoProvisionPrimaryValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.NumHosts.Equal(other.NumHosts) {
		return false
	}

	if !v.WanNames.Equal(other.WanNames) {
		return false
	}

	return true
}

func (v AutoProvisionPrimaryValue) Type(ctx context.Context) attr.Type {
	return AutoProvisionPrimaryType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AutoProvisionPrimaryValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"num_hosts": basetypes.StringType{},
		"wan_names": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = AutoProvisionSecondaryType{}

type AutoProvisionSecondaryType struct {
	basetypes.ObjectType
}

func (t AutoProvisionSecondaryType) Equal(o attr.Type) bool {
	other, ok := o.(AutoProvisionSecondaryType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AutoProvisionSecondaryType) String() string {
	return "AutoProvisionSecondaryType"
}

func (t AutoProvisionSecondaryType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	numHostsAttribute, ok := attributes["num_hosts"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`num_hosts is missing from object`)

		return nil, diags
	}

	numHostsVal, ok := numHostsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`num_hosts expected to be basetypes.StringValue, was: %T`, numHostsAttribute))
	}

	wanNamesAttribute, ok := attributes["wan_names"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wan_names is missing from object`)

		return nil, diags
	}

	wanNamesVal, ok := wanNamesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wan_names expected to be basetypes.ListValue, was: %T`, wanNamesAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AutoProvisionSecondaryValue{
		NumHosts: numHostsVal,
		WanNames: wanNamesVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewAutoProvisionSecondaryValueNull() AutoProvisionSecondaryValue {
	return AutoProvisionSecondaryValue{
		state: attr.ValueStateNull,
	}
}

func NewAutoProvisionSecondaryValueUnknown() AutoProvisionSecondaryValue {
	return AutoProvisionSecondaryValue{
		state: attr.ValueStateUnknown,
	}
}

func NewAutoProvisionSecondaryValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AutoProvisionSecondaryValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AutoProvisionSecondaryValue Attribute Value",
				"While creating a AutoProvisionSecondaryValue value, a missing attribute value was detected. "+
					"A AutoProvisionSecondaryValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AutoProvisionSecondaryValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AutoProvisionSecondaryValue Attribute Type",
				"While creating a AutoProvisionSecondaryValue value, an invalid attribute value was detected. "+
					"A AutoProvisionSecondaryValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AutoProvisionSecondaryValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AutoProvisionSecondaryValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AutoProvisionSecondaryValue Attribute Value",
				"While creating a AutoProvisionSecondaryValue value, an extra attribute value was detected. "+
					"A AutoProvisionSecondaryValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AutoProvisionSecondaryValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAutoProvisionSecondaryValueUnknown(), diags
	}

	numHostsAttribute, ok := attributes["num_hosts"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`num_hosts is missing from object`)

		return NewAutoProvisionSecondaryValueUnknown(), diags
	}

	numHostsVal, ok := numHostsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`num_hosts expected to be basetypes.StringValue, was: %T`, numHostsAttribute))
	}

	wanNamesAttribute, ok := attributes["wan_names"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wan_names is missing from object`)

		return NewAutoProvisionSecondaryValueUnknown(), diags
	}

	wanNamesVal, ok := wanNamesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wan_names expected to be basetypes.ListValue, was: %T`, wanNamesAttribute))
	}

	if diags.HasError() {
		return NewAutoProvisionSecondaryValueUnknown(), diags
	}

	return AutoProvisionSecondaryValue{
		NumHosts: numHostsVal,
		WanNames: wanNamesVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewAutoProvisionSecondaryValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AutoProvisionSecondaryValue {
	object, diags := NewAutoProvisionSecondaryValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAutoProvisionSecondaryValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AutoProvisionSecondaryType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAutoProvisionSecondaryValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAutoProvisionSecondaryValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAutoProvisionSecondaryValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAutoProvisionSecondaryValueMust(AutoProvisionSecondaryValue{}.AttributeTypes(ctx), attributes), nil
}

func (t AutoProvisionSecondaryType) ValueType(ctx context.Context) attr.Value {
	return AutoProvisionSecondaryValue{}
}

var _ basetypes.ObjectValuable = AutoProvisionSecondaryValue{}

type AutoProvisionSecondaryValue struct {
	NumHosts basetypes.StringValue `tfsdk:"num_hosts"`
	WanNames basetypes.ListValue   `tfsdk:"wan_names"`
	state    attr.ValueState
}

func (v AutoProvisionSecondaryValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["num_hosts"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["wan_names"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.NumHosts.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["num_hosts"] = val

		val, err = v.WanNames.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["wan_names"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AutoProvisionSecondaryValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AutoProvisionSecondaryValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AutoProvisionSecondaryValue) String() string {
	return "AutoProvisionSecondaryValue"
}

func (v AutoProvisionSecondaryValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	wanNamesVal, d := types.ListValue(types.StringType, v.WanNames.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"num_hosts": basetypes.StringType{},
			"wan_names": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"num_hosts": basetypes.StringType{},
		"wan_names": basetypes.ListType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"num_hosts": v.NumHosts,
			"wan_names": wanNamesVal,
		})

	return objVal, diags
}

func (v AutoProvisionSecondaryValue) Equal(o attr.Value) bool {
	other, ok := o.(AutoProvisionSecondaryValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.NumHosts.Equal(other.NumHosts) {
		return false
	}

	if !v.WanNames.Equal(other.WanNames) {
		return false
	}

	return true
}

func (v AutoProvisionSecondaryValue) Type(ctx context.Context) attr.Type {
	return AutoProvisionSecondaryType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AutoProvisionSecondaryValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"num_hosts": basetypes.StringType{},
		"wan_names": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = LatlngType{}

type LatlngType struct {
	basetypes.ObjectType
}

func (t LatlngType) Equal(o attr.Type) bool {
	other, ok := o.(LatlngType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t LatlngType) String() string {
	return "LatlngType"
}

func (t LatlngType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	latAttribute, ok := attributes["lat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lat is missing from object`)

		return nil, diags
	}

	latVal, ok := latAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lat expected to be basetypes.Float64Value, was: %T`, latAttribute))
	}

	lngAttribute, ok := attributes["lng"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lng is missing from object`)

		return nil, diags
	}

	lngVal, ok := lngAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lng expected to be basetypes.Float64Value, was: %T`, lngAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return LatlngValue{
		Lat:   latVal,
		Lng:   lngVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewLatlngValueNull() LatlngValue {
	return LatlngValue{
		state: attr.ValueStateNull,
	}
}

func NewLatlngValueUnknown() LatlngValue {
	return LatlngValue{
		state: attr.ValueStateUnknown,
	}
}

func NewLatlngValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (LatlngValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing LatlngValue Attribute Value",
				"While creating a LatlngValue value, a missing attribute value was detected. "+
					"A LatlngValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("LatlngValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid LatlngValue Attribute Type",
				"While creating a LatlngValue value, an invalid attribute value was detected. "+
					"A LatlngValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("LatlngValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("LatlngValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra LatlngValue Attribute Value",
				"While creating a LatlngValue value, an extra attribute value was detected. "+
					"A LatlngValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra LatlngValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewLatlngValueUnknown(), diags
	}

	latAttribute, ok := attributes["lat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lat is missing from object`)

		return NewLatlngValueUnknown(), diags
	}

	latVal, ok := latAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lat expected to be basetypes.Float64Value, was: %T`, latAttribute))
	}

	lngAttribute, ok := attributes["lng"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lng is missing from object`)

		return NewLatlngValueUnknown(), diags
	}

	lngVal, ok := lngAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lng expected to be basetypes.Float64Value, was: %T`, lngAttribute))
	}

	if diags.HasError() {
		return NewLatlngValueUnknown(), diags
	}

	return LatlngValue{
		Lat:   latVal,
		Lng:   lngVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewLatlngValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) LatlngValue {
	object, diags := NewLatlngValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewLatlngValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t LatlngType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewLatlngValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewLatlngValueUnknown(), nil
	}

	if in.IsNull() {
		return NewLatlngValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewLatlngValueMust(LatlngValue{}.AttributeTypes(ctx), attributes), nil
}

func (t LatlngType) ValueType(ctx context.Context) attr.Value {
	return LatlngValue{}
}

var _ basetypes.ObjectValuable = LatlngValue{}

type LatlngValue struct {
	Lat   basetypes.Float64Value `tfsdk:"lat"`
	Lng   basetypes.Float64Value `tfsdk:"lng"`
	state attr.ValueState
}

func (v LatlngValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["lat"] = basetypes.Float64Type{}.TerraformType(ctx)
	attrTypes["lng"] = basetypes.Float64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Lat.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["lat"] = val

		val, err = v.Lng.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["lng"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v LatlngValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v LatlngValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v LatlngValue) String() string {
	return "LatlngValue"
}

func (v LatlngValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"lat": basetypes.Float64Type{},
		"lng": basetypes.Float64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"lat": v.Lat,
			"lng": v.Lng,
		})

	return objVal, diags
}

func (v LatlngValue) Equal(o attr.Value) bool {
	other, ok := o.(LatlngValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Lat.Equal(other.Lat) {
		return false
	}

	if !v.Lng.Equal(other.Lng) {
		return false
	}

	return true
}

func (v LatlngValue) Type(ctx context.Context) attr.Type {
	return LatlngType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v LatlngValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"lat": basetypes.Float64Type{},
		"lng": basetypes.Float64Type{},
	}
}

var _ basetypes.ObjectTypable = IkeProposalsType{}

type IkeProposalsType struct {
	basetypes.ObjectType
}

func (t IkeProposalsType) Equal(o attr.Type) bool {
	other, ok := o.(IkeProposalsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t IkeProposalsType) String() string {
	return "IkeProposalsType"
}

func (t IkeProposalsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	authAlgoAttribute, ok := attributes["auth_algo"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auth_algo is missing from object`)

		return nil, diags
	}

	authAlgoVal, ok := authAlgoAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auth_algo expected to be basetypes.StringValue, was: %T`, authAlgoAttribute))
	}

	dhGroupAttribute, ok := attributes["dh_group"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dh_group is missing from object`)

		return nil, diags
	}

	dhGroupVal, ok := dhGroupAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dh_group expected to be basetypes.StringValue, was: %T`, dhGroupAttribute))
	}

	encAlgoAttribute, ok := attributes["enc_algo"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enc_algo is missing from object`)

		return nil, diags
	}

	encAlgoVal, ok := encAlgoAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enc_algo expected to be basetypes.StringValue, was: %T`, encAlgoAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return IkeProposalsValue{
		AuthAlgo: authAlgoVal,
		DhGroup:  dhGroupVal,
		EncAlgo:  encAlgoVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewIkeProposalsValueNull() IkeProposalsValue {
	return IkeProposalsValue{
		state: attr.ValueStateNull,
	}
}

func NewIkeProposalsValueUnknown() IkeProposalsValue {
	return IkeProposalsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewIkeProposalsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (IkeProposalsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing IkeProposalsValue Attribute Value",
				"While creating a IkeProposalsValue value, a missing attribute value was detected. "+
					"A IkeProposalsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("IkeProposalsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid IkeProposalsValue Attribute Type",
				"While creating a IkeProposalsValue value, an invalid attribute value was detected. "+
					"A IkeProposalsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("IkeProposalsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("IkeProposalsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra IkeProposalsValue Attribute Value",
				"While creating a IkeProposalsValue value, an extra attribute value was detected. "+
					"A IkeProposalsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra IkeProposalsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewIkeProposalsValueUnknown(), diags
	}

	authAlgoAttribute, ok := attributes["auth_algo"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auth_algo is missing from object`)

		return NewIkeProposalsValueUnknown(), diags
	}

	authAlgoVal, ok := authAlgoAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auth_algo expected to be basetypes.StringValue, was: %T`, authAlgoAttribute))
	}

	dhGroupAttribute, ok := attributes["dh_group"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dh_group is missing from object`)

		return NewIkeProposalsValueUnknown(), diags
	}

	dhGroupVal, ok := dhGroupAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dh_group expected to be basetypes.StringValue, was: %T`, dhGroupAttribute))
	}

	encAlgoAttribute, ok := attributes["enc_algo"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enc_algo is missing from object`)

		return NewIkeProposalsValueUnknown(), diags
	}

	encAlgoVal, ok := encAlgoAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enc_algo expected to be basetypes.StringValue, was: %T`, encAlgoAttribute))
	}

	if diags.HasError() {
		return NewIkeProposalsValueUnknown(), diags
	}

	return IkeProposalsValue{
		AuthAlgo: authAlgoVal,
		DhGroup:  dhGroupVal,
		EncAlgo:  encAlgoVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewIkeProposalsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) IkeProposalsValue {
	object, diags := NewIkeProposalsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewIkeProposalsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t IkeProposalsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewIkeProposalsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewIkeProposalsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewIkeProposalsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewIkeProposalsValueMust(IkeProposalsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t IkeProposalsType) ValueType(ctx context.Context) attr.Value {
	return IkeProposalsValue{}
}

var _ basetypes.ObjectValuable = IkeProposalsValue{}

type IkeProposalsValue struct {
	AuthAlgo basetypes.StringValue `tfsdk:"auth_algo"`
	DhGroup  basetypes.StringValue `tfsdk:"dh_group"`
	EncAlgo  basetypes.StringValue `tfsdk:"enc_algo"`
	state    attr.ValueState
}

func (v IkeProposalsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["auth_algo"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["dh_group"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["enc_algo"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.AuthAlgo.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["auth_algo"] = val

		val, err = v.DhGroup.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dh_group"] = val

		val, err = v.EncAlgo.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enc_algo"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v IkeProposalsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v IkeProposalsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v IkeProposalsValue) String() string {
	return "IkeProposalsValue"
}

func (v IkeProposalsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"auth_algo": basetypes.StringType{},
		"dh_group":  basetypes.StringType{},
		"enc_algo":  basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"auth_algo": v.AuthAlgo,
			"dh_group":  v.DhGroup,
			"enc_algo":  v.EncAlgo,
		})

	return objVal, diags
}

func (v IkeProposalsValue) Equal(o attr.Value) bool {
	other, ok := o.(IkeProposalsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AuthAlgo.Equal(other.AuthAlgo) {
		return false
	}

	if !v.DhGroup.Equal(other.DhGroup) {
		return false
	}

	if !v.EncAlgo.Equal(other.EncAlgo) {
		return false
	}

	return true
}

func (v IkeProposalsValue) Type(ctx context.Context) attr.Type {
	return IkeProposalsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v IkeProposalsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"auth_algo": basetypes.StringType{},
		"dh_group":  basetypes.StringType{},
		"enc_algo":  basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = IpsecProposalsType{}

type IpsecProposalsType struct {
	basetypes.ObjectType
}

func (t IpsecProposalsType) Equal(o attr.Type) bool {
	other, ok := o.(IpsecProposalsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t IpsecProposalsType) String() string {
	return "IpsecProposalsType"
}

func (t IpsecProposalsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	authAlgoAttribute, ok := attributes["auth_algo"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auth_algo is missing from object`)

		return nil, diags
	}

	authAlgoVal, ok := authAlgoAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auth_algo expected to be basetypes.StringValue, was: %T`, authAlgoAttribute))
	}

	dhGroupAttribute, ok := attributes["dh_group"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dh_group is missing from object`)

		return nil, diags
	}

	dhGroupVal, ok := dhGroupAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dh_group expected to be basetypes.StringValue, was: %T`, dhGroupAttribute))
	}

	encAlgoAttribute, ok := attributes["enc_algo"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enc_algo is missing from object`)

		return nil, diags
	}

	encAlgoVal, ok := encAlgoAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enc_algo expected to be basetypes.StringValue, was: %T`, encAlgoAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return IpsecProposalsValue{
		AuthAlgo: authAlgoVal,
		DhGroup:  dhGroupVal,
		EncAlgo:  encAlgoVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewIpsecProposalsValueNull() IpsecProposalsValue {
	return IpsecProposalsValue{
		state: attr.ValueStateNull,
	}
}

func NewIpsecProposalsValueUnknown() IpsecProposalsValue {
	return IpsecProposalsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewIpsecProposalsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (IpsecProposalsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing IpsecProposalsValue Attribute Value",
				"While creating a IpsecProposalsValue value, a missing attribute value was detected. "+
					"A IpsecProposalsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("IpsecProposalsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid IpsecProposalsValue Attribute Type",
				"While creating a IpsecProposalsValue value, an invalid attribute value was detected. "+
					"A IpsecProposalsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("IpsecProposalsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("IpsecProposalsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra IpsecProposalsValue Attribute Value",
				"While creating a IpsecProposalsValue value, an extra attribute value was detected. "+
					"A IpsecProposalsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra IpsecProposalsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewIpsecProposalsValueUnknown(), diags
	}

	authAlgoAttribute, ok := attributes["auth_algo"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auth_algo is missing from object`)

		return NewIpsecProposalsValueUnknown(), diags
	}

	authAlgoVal, ok := authAlgoAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auth_algo expected to be basetypes.StringValue, was: %T`, authAlgoAttribute))
	}

	dhGroupAttribute, ok := attributes["dh_group"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dh_group is missing from object`)

		return NewIpsecProposalsValueUnknown(), diags
	}

	dhGroupVal, ok := dhGroupAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dh_group expected to be basetypes.StringValue, was: %T`, dhGroupAttribute))
	}

	encAlgoAttribute, ok := attributes["enc_algo"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enc_algo is missing from object`)

		return NewIpsecProposalsValueUnknown(), diags
	}

	encAlgoVal, ok := encAlgoAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enc_algo expected to be basetypes.StringValue, was: %T`, encAlgoAttribute))
	}

	if diags.HasError() {
		return NewIpsecProposalsValueUnknown(), diags
	}

	return IpsecProposalsValue{
		AuthAlgo: authAlgoVal,
		DhGroup:  dhGroupVal,
		EncAlgo:  encAlgoVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewIpsecProposalsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) IpsecProposalsValue {
	object, diags := NewIpsecProposalsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewIpsecProposalsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t IpsecProposalsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewIpsecProposalsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewIpsecProposalsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewIpsecProposalsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewIpsecProposalsValueMust(IpsecProposalsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t IpsecProposalsType) ValueType(ctx context.Context) attr.Value {
	return IpsecProposalsValue{}
}

var _ basetypes.ObjectValuable = IpsecProposalsValue{}

type IpsecProposalsValue struct {
	AuthAlgo basetypes.StringValue `tfsdk:"auth_algo"`
	DhGroup  basetypes.StringValue `tfsdk:"dh_group"`
	EncAlgo  basetypes.StringValue `tfsdk:"enc_algo"`
	state    attr.ValueState
}

func (v IpsecProposalsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["auth_algo"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["dh_group"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["enc_algo"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.AuthAlgo.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["auth_algo"] = val

		val, err = v.DhGroup.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dh_group"] = val

		val, err = v.EncAlgo.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enc_algo"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v IpsecProposalsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v IpsecProposalsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v IpsecProposalsValue) String() string {
	return "IpsecProposalsValue"
}

func (v IpsecProposalsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"auth_algo": basetypes.StringType{},
		"dh_group":  basetypes.StringType{},
		"enc_algo":  basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"auth_algo": v.AuthAlgo,
			"dh_group":  v.DhGroup,
			"enc_algo":  v.EncAlgo,
		})

	return objVal, diags
}

func (v IpsecProposalsValue) Equal(o attr.Value) bool {
	other, ok := o.(IpsecProposalsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AuthAlgo.Equal(other.AuthAlgo) {
		return false
	}

	if !v.DhGroup.Equal(other.DhGroup) {
		return false
	}

	if !v.EncAlgo.Equal(other.EncAlgo) {
		return false
	}

	return true
}

func (v IpsecProposalsValue) Type(ctx context.Context) attr.Type {
	return IpsecProposalsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v IpsecProposalsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"auth_algo": basetypes.StringType{},
		"dh_group":  basetypes.StringType{},
		"enc_algo":  basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = PrimaryType{}

type PrimaryType struct {
	basetypes.ObjectType
}

func (t PrimaryType) Equal(o attr.Type) bool {
	other, ok := o.(PrimaryType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PrimaryType) String() string {
	return "PrimaryType"
}

func (t PrimaryType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	hostsAttribute, ok := attributes["hosts"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`hosts is missing from object`)

		return nil, diags
	}

	hostsVal, ok := hostsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`hosts expected to be basetypes.ListValue, was: %T`, hostsAttribute))
	}

	internalIpsAttribute, ok := attributes["internal_ips"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`internal_ips is missing from object`)

		return nil, diags
	}

	internalIpsVal, ok := internalIpsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`internal_ips expected to be basetypes.ListValue, was: %T`, internalIpsAttribute))
	}

	probeIpsAttribute, ok := attributes["probe_ips"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`probe_ips is missing from object`)

		return nil, diags
	}

	probeIpsVal, ok := probeIpsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`probe_ips expected to be basetypes.ListValue, was: %T`, probeIpsAttribute))
	}

	remoteIdsAttribute, ok := attributes["remote_ids"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remote_ids is missing from object`)

		return nil, diags
	}

	remoteIdsVal, ok := remoteIdsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remote_ids expected to be basetypes.ListValue, was: %T`, remoteIdsAttribute))
	}

	wanNamesAttribute, ok := attributes["wan_names"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wan_names is missing from object`)

		return nil, diags
	}

	wanNamesVal, ok := wanNamesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wan_names expected to be basetypes.ListValue, was: %T`, wanNamesAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PrimaryValue{
		Hosts:       hostsVal,
		InternalIps: internalIpsVal,
		ProbeIps:    probeIpsVal,
		RemoteIds:   remoteIdsVal,
		WanNames:    wanNamesVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewPrimaryValueNull() PrimaryValue {
	return PrimaryValue{
		state: attr.ValueStateNull,
	}
}

func NewPrimaryValueUnknown() PrimaryValue {
	return PrimaryValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPrimaryValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PrimaryValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PrimaryValue Attribute Value",
				"While creating a PrimaryValue value, a missing attribute value was detected. "+
					"A PrimaryValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PrimaryValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PrimaryValue Attribute Type",
				"While creating a PrimaryValue value, an invalid attribute value was detected. "+
					"A PrimaryValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PrimaryValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PrimaryValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PrimaryValue Attribute Value",
				"While creating a PrimaryValue value, an extra attribute value was detected. "+
					"A PrimaryValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PrimaryValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPrimaryValueUnknown(), diags
	}

	hostsAttribute, ok := attributes["hosts"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`hosts is missing from object`)

		return NewPrimaryValueUnknown(), diags
	}

	hostsVal, ok := hostsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`hosts expected to be basetypes.ListValue, was: %T`, hostsAttribute))
	}

	internalIpsAttribute, ok := attributes["internal_ips"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`internal_ips is missing from object`)

		return NewPrimaryValueUnknown(), diags
	}

	internalIpsVal, ok := internalIpsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`internal_ips expected to be basetypes.ListValue, was: %T`, internalIpsAttribute))
	}

	probeIpsAttribute, ok := attributes["probe_ips"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`probe_ips is missing from object`)

		return NewPrimaryValueUnknown(), diags
	}

	probeIpsVal, ok := probeIpsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`probe_ips expected to be basetypes.ListValue, was: %T`, probeIpsAttribute))
	}

	remoteIdsAttribute, ok := attributes["remote_ids"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remote_ids is missing from object`)

		return NewPrimaryValueUnknown(), diags
	}

	remoteIdsVal, ok := remoteIdsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remote_ids expected to be basetypes.ListValue, was: %T`, remoteIdsAttribute))
	}

	wanNamesAttribute, ok := attributes["wan_names"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wan_names is missing from object`)

		return NewPrimaryValueUnknown(), diags
	}

	wanNamesVal, ok := wanNamesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wan_names expected to be basetypes.ListValue, was: %T`, wanNamesAttribute))
	}

	if diags.HasError() {
		return NewPrimaryValueUnknown(), diags
	}

	return PrimaryValue{
		Hosts:       hostsVal,
		InternalIps: internalIpsVal,
		ProbeIps:    probeIpsVal,
		RemoteIds:   remoteIdsVal,
		WanNames:    wanNamesVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewPrimaryValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PrimaryValue {
	object, diags := NewPrimaryValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPrimaryValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PrimaryType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPrimaryValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPrimaryValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPrimaryValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPrimaryValueMust(PrimaryValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PrimaryType) ValueType(ctx context.Context) attr.Value {
	return PrimaryValue{}
}

var _ basetypes.ObjectValuable = PrimaryValue{}

type PrimaryValue struct {
	Hosts       basetypes.ListValue `tfsdk:"hosts"`
	InternalIps basetypes.ListValue `tfsdk:"internal_ips"`
	ProbeIps    basetypes.ListValue `tfsdk:"probe_ips"`
	RemoteIds   basetypes.ListValue `tfsdk:"remote_ids"`
	WanNames    basetypes.ListValue `tfsdk:"wan_names"`
	state       attr.ValueState
}

func (v PrimaryValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["hosts"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["internal_ips"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["probe_ips"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["remote_ids"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["wan_names"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.Hosts.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["hosts"] = val

		val, err = v.InternalIps.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["internal_ips"] = val

		val, err = v.ProbeIps.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["probe_ips"] = val

		val, err = v.RemoteIds.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["remote_ids"] = val

		val, err = v.WanNames.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["wan_names"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PrimaryValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PrimaryValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PrimaryValue) String() string {
	return "PrimaryValue"
}

func (v PrimaryValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	hostsVal, d := types.ListValue(types.StringType, v.Hosts.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"hosts": basetypes.ListType{
				ElemType: types.StringType,
			},
			"internal_ips": basetypes.ListType{
				ElemType: types.StringType,
			},
			"probe_ips": basetypes.ListType{
				ElemType: types.StringType,
			},
			"remote_ids": basetypes.ListType{
				ElemType: types.StringType,
			},
			"wan_names": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	internalIpsVal, d := types.ListValue(types.StringType, v.InternalIps.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"hosts": basetypes.ListType{
				ElemType: types.StringType,
			},
			"internal_ips": basetypes.ListType{
				ElemType: types.StringType,
			},
			"probe_ips": basetypes.ListType{
				ElemType: types.StringType,
			},
			"remote_ids": basetypes.ListType{
				ElemType: types.StringType,
			},
			"wan_names": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	probeIpsVal, d := types.ListValue(types.StringType, v.ProbeIps.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"hosts": basetypes.ListType{
				ElemType: types.StringType,
			},
			"internal_ips": basetypes.ListType{
				ElemType: types.StringType,
			},
			"probe_ips": basetypes.ListType{
				ElemType: types.StringType,
			},
			"remote_ids": basetypes.ListType{
				ElemType: types.StringType,
			},
			"wan_names": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	remoteIdsVal, d := types.ListValue(types.StringType, v.RemoteIds.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"hosts": basetypes.ListType{
				ElemType: types.StringType,
			},
			"internal_ips": basetypes.ListType{
				ElemType: types.StringType,
			},
			"probe_ips": basetypes.ListType{
				ElemType: types.StringType,
			},
			"remote_ids": basetypes.ListType{
				ElemType: types.StringType,
			},
			"wan_names": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	wanNamesVal, d := types.ListValue(types.StringType, v.WanNames.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"hosts": basetypes.ListType{
				ElemType: types.StringType,
			},
			"internal_ips": basetypes.ListType{
				ElemType: types.StringType,
			},
			"probe_ips": basetypes.ListType{
				ElemType: types.StringType,
			},
			"remote_ids": basetypes.ListType{
				ElemType: types.StringType,
			},
			"wan_names": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"hosts": basetypes.ListType{
			ElemType: types.StringType,
		},
		"internal_ips": basetypes.ListType{
			ElemType: types.StringType,
		},
		"probe_ips": basetypes.ListType{
			ElemType: types.StringType,
		},
		"remote_ids": basetypes.ListType{
			ElemType: types.StringType,
		},
		"wan_names": basetypes.ListType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"hosts":        hostsVal,
			"internal_ips": internalIpsVal,
			"probe_ips":    probeIpsVal,
			"remote_ids":   remoteIdsVal,
			"wan_names":    wanNamesVal,
		})

	return objVal, diags
}

func (v PrimaryValue) Equal(o attr.Value) bool {
	other, ok := o.(PrimaryValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Hosts.Equal(other.Hosts) {
		return false
	}

	if !v.InternalIps.Equal(other.InternalIps) {
		return false
	}

	if !v.ProbeIps.Equal(other.ProbeIps) {
		return false
	}

	if !v.RemoteIds.Equal(other.RemoteIds) {
		return false
	}

	if !v.WanNames.Equal(other.WanNames) {
		return false
	}

	return true
}

func (v PrimaryValue) Type(ctx context.Context) attr.Type {
	return PrimaryType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PrimaryValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"hosts": basetypes.ListType{
			ElemType: types.StringType,
		},
		"internal_ips": basetypes.ListType{
			ElemType: types.StringType,
		},
		"probe_ips": basetypes.ListType{
			ElemType: types.StringType,
		},
		"remote_ids": basetypes.ListType{
			ElemType: types.StringType,
		},
		"wan_names": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = ProbeType{}

type ProbeType struct {
	basetypes.ObjectType
}

func (t ProbeType) Equal(o attr.Type) bool {
	other, ok := o.(ProbeType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ProbeType) String() string {
	return "ProbeType"
}

func (t ProbeType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	intervalAttribute, ok := attributes["interval"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interval is missing from object`)

		return nil, diags
	}

	intervalVal, ok := intervalAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interval expected to be basetypes.Int64Value, was: %T`, intervalAttribute))
	}

	thresholdAttribute, ok := attributes["threshold"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`threshold is missing from object`)

		return nil, diags
	}

	thresholdVal, ok := thresholdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`threshold expected to be basetypes.Int64Value, was: %T`, thresholdAttribute))
	}

	timeoutAttribute, ok := attributes["timeout"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`timeout is missing from object`)

		return nil, diags
	}

	timeoutVal, ok := timeoutAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`timeout expected to be basetypes.Int64Value, was: %T`, timeoutAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ProbeValue{
		Interval:  intervalVal,
		Threshold: thresholdVal,
		Timeout:   timeoutVal,
		ProbeType: typeVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewProbeValueNull() ProbeValue {
	return ProbeValue{
		state: attr.ValueStateNull,
	}
}

func NewProbeValueUnknown() ProbeValue {
	return ProbeValue{
		state: attr.ValueStateUnknown,
	}
}

func NewProbeValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ProbeValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ProbeValue Attribute Value",
				"While creating a ProbeValue value, a missing attribute value was detected. "+
					"A ProbeValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ProbeValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ProbeValue Attribute Type",
				"While creating a ProbeValue value, an invalid attribute value was detected. "+
					"A ProbeValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ProbeValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ProbeValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ProbeValue Attribute Value",
				"While creating a ProbeValue value, an extra attribute value was detected. "+
					"A ProbeValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ProbeValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewProbeValueUnknown(), diags
	}

	intervalAttribute, ok := attributes["interval"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interval is missing from object`)

		return NewProbeValueUnknown(), diags
	}

	intervalVal, ok := intervalAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interval expected to be basetypes.Int64Value, was: %T`, intervalAttribute))
	}

	thresholdAttribute, ok := attributes["threshold"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`threshold is missing from object`)

		return NewProbeValueUnknown(), diags
	}

	thresholdVal, ok := thresholdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`threshold expected to be basetypes.Int64Value, was: %T`, thresholdAttribute))
	}

	timeoutAttribute, ok := attributes["timeout"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`timeout is missing from object`)

		return NewProbeValueUnknown(), diags
	}

	timeoutVal, ok := timeoutAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`timeout expected to be basetypes.Int64Value, was: %T`, timeoutAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewProbeValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return NewProbeValueUnknown(), diags
	}

	return ProbeValue{
		Interval:  intervalVal,
		Threshold: thresholdVal,
		Timeout:   timeoutVal,
		ProbeType: typeVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewProbeValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ProbeValue {
	object, diags := NewProbeValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewProbeValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ProbeType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewProbeValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewProbeValueUnknown(), nil
	}

	if in.IsNull() {
		return NewProbeValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewProbeValueMust(ProbeValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ProbeType) ValueType(ctx context.Context) attr.Value {
	return ProbeValue{}
}

var _ basetypes.ObjectValuable = ProbeValue{}

type ProbeValue struct {
	Interval  basetypes.Int64Value  `tfsdk:"interval"`
	Threshold basetypes.Int64Value  `tfsdk:"threshold"`
	Timeout   basetypes.Int64Value  `tfsdk:"timeout"`
	ProbeType basetypes.StringValue `tfsdk:"type"`
	state     attr.ValueState
}

func (v ProbeValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["interval"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["threshold"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["timeout"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Interval.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["interval"] = val

		val, err = v.Threshold.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["threshold"] = val

		val, err = v.Timeout.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["timeout"] = val

		val, err = v.ProbeType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ProbeValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ProbeValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ProbeValue) String() string {
	return "ProbeValue"
}

func (v ProbeValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"interval":  basetypes.Int64Type{},
		"threshold": basetypes.Int64Type{},
		"timeout":   basetypes.Int64Type{},
		"type":      basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"interval":  v.Interval,
			"threshold": v.Threshold,
			"timeout":   v.Timeout,
			"type":      v.ProbeType,
		})

	return objVal, diags
}

func (v ProbeValue) Equal(o attr.Value) bool {
	other, ok := o.(ProbeValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Interval.Equal(other.Interval) {
		return false
	}

	if !v.Threshold.Equal(other.Threshold) {
		return false
	}

	if !v.Timeout.Equal(other.Timeout) {
		return false
	}

	if !v.ProbeType.Equal(other.ProbeType) {
		return false
	}

	return true
}

func (v ProbeValue) Type(ctx context.Context) attr.Type {
	return ProbeType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ProbeValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"interval":  basetypes.Int64Type{},
		"threshold": basetypes.Int64Type{},
		"timeout":   basetypes.Int64Type{},
		"type":      basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = SecondaryType{}

type SecondaryType struct {
	basetypes.ObjectType
}

func (t SecondaryType) Equal(o attr.Type) bool {
	other, ok := o.(SecondaryType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SecondaryType) String() string {
	return "SecondaryType"
}

func (t SecondaryType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	hostsAttribute, ok := attributes["hosts"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`hosts is missing from object`)

		return nil, diags
	}

	hostsVal, ok := hostsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`hosts expected to be basetypes.ListValue, was: %T`, hostsAttribute))
	}

	internalIpsAttribute, ok := attributes["internal_ips"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`internal_ips is missing from object`)

		return nil, diags
	}

	internalIpsVal, ok := internalIpsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`internal_ips expected to be basetypes.ListValue, was: %T`, internalIpsAttribute))
	}

	probeIpsAttribute, ok := attributes["probe_ips"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`probe_ips is missing from object`)

		return nil, diags
	}

	probeIpsVal, ok := probeIpsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`probe_ips expected to be basetypes.ListValue, was: %T`, probeIpsAttribute))
	}

	remoteIdsAttribute, ok := attributes["remote_ids"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remote_ids is missing from object`)

		return nil, diags
	}

	remoteIdsVal, ok := remoteIdsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remote_ids expected to be basetypes.ListValue, was: %T`, remoteIdsAttribute))
	}

	wanNamesAttribute, ok := attributes["wan_names"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wan_names is missing from object`)

		return nil, diags
	}

	wanNamesVal, ok := wanNamesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wan_names expected to be basetypes.ListValue, was: %T`, wanNamesAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SecondaryValue{
		Hosts:       hostsVal,
		InternalIps: internalIpsVal,
		ProbeIps:    probeIpsVal,
		RemoteIds:   remoteIdsVal,
		WanNames:    wanNamesVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewSecondaryValueNull() SecondaryValue {
	return SecondaryValue{
		state: attr.ValueStateNull,
	}
}

func NewSecondaryValueUnknown() SecondaryValue {
	return SecondaryValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSecondaryValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SecondaryValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SecondaryValue Attribute Value",
				"While creating a SecondaryValue value, a missing attribute value was detected. "+
					"A SecondaryValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SecondaryValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SecondaryValue Attribute Type",
				"While creating a SecondaryValue value, an invalid attribute value was detected. "+
					"A SecondaryValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SecondaryValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SecondaryValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SecondaryValue Attribute Value",
				"While creating a SecondaryValue value, an extra attribute value was detected. "+
					"A SecondaryValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SecondaryValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSecondaryValueUnknown(), diags
	}

	hostsAttribute, ok := attributes["hosts"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`hosts is missing from object`)

		return NewSecondaryValueUnknown(), diags
	}

	hostsVal, ok := hostsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`hosts expected to be basetypes.ListValue, was: %T`, hostsAttribute))
	}

	internalIpsAttribute, ok := attributes["internal_ips"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`internal_ips is missing from object`)

		return NewSecondaryValueUnknown(), diags
	}

	internalIpsVal, ok := internalIpsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`internal_ips expected to be basetypes.ListValue, was: %T`, internalIpsAttribute))
	}

	probeIpsAttribute, ok := attributes["probe_ips"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`probe_ips is missing from object`)

		return NewSecondaryValueUnknown(), diags
	}

	probeIpsVal, ok := probeIpsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`probe_ips expected to be basetypes.ListValue, was: %T`, probeIpsAttribute))
	}

	remoteIdsAttribute, ok := attributes["remote_ids"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remote_ids is missing from object`)

		return NewSecondaryValueUnknown(), diags
	}

	remoteIdsVal, ok := remoteIdsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remote_ids expected to be basetypes.ListValue, was: %T`, remoteIdsAttribute))
	}

	wanNamesAttribute, ok := attributes["wan_names"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wan_names is missing from object`)

		return NewSecondaryValueUnknown(), diags
	}

	wanNamesVal, ok := wanNamesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wan_names expected to be basetypes.ListValue, was: %T`, wanNamesAttribute))
	}

	if diags.HasError() {
		return NewSecondaryValueUnknown(), diags
	}

	return SecondaryValue{
		Hosts:       hostsVal,
		InternalIps: internalIpsVal,
		ProbeIps:    probeIpsVal,
		RemoteIds:   remoteIdsVal,
		WanNames:    wanNamesVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewSecondaryValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SecondaryValue {
	object, diags := NewSecondaryValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSecondaryValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SecondaryType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSecondaryValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSecondaryValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSecondaryValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSecondaryValueMust(SecondaryValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SecondaryType) ValueType(ctx context.Context) attr.Value {
	return SecondaryValue{}
}

var _ basetypes.ObjectValuable = SecondaryValue{}

type SecondaryValue struct {
	Hosts       basetypes.ListValue `tfsdk:"hosts"`
	InternalIps basetypes.ListValue `tfsdk:"internal_ips"`
	ProbeIps    basetypes.ListValue `tfsdk:"probe_ips"`
	RemoteIds   basetypes.ListValue `tfsdk:"remote_ids"`
	WanNames    basetypes.ListValue `tfsdk:"wan_names"`
	state       attr.ValueState
}

func (v SecondaryValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["hosts"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["internal_ips"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["probe_ips"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["remote_ids"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["wan_names"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.Hosts.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["hosts"] = val

		val, err = v.InternalIps.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["internal_ips"] = val

		val, err = v.ProbeIps.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["probe_ips"] = val

		val, err = v.RemoteIds.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["remote_ids"] = val

		val, err = v.WanNames.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["wan_names"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SecondaryValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SecondaryValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SecondaryValue) String() string {
	return "SecondaryValue"
}

func (v SecondaryValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	hostsVal, d := types.ListValue(types.StringType, v.Hosts.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"hosts": basetypes.ListType{
				ElemType: types.StringType,
			},
			"internal_ips": basetypes.ListType{
				ElemType: types.StringType,
			},
			"probe_ips": basetypes.ListType{
				ElemType: types.StringType,
			},
			"remote_ids": basetypes.ListType{
				ElemType: types.StringType,
			},
			"wan_names": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	internalIpsVal, d := types.ListValue(types.StringType, v.InternalIps.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"hosts": basetypes.ListType{
				ElemType: types.StringType,
			},
			"internal_ips": basetypes.ListType{
				ElemType: types.StringType,
			},
			"probe_ips": basetypes.ListType{
				ElemType: types.StringType,
			},
			"remote_ids": basetypes.ListType{
				ElemType: types.StringType,
			},
			"wan_names": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	probeIpsVal, d := types.ListValue(types.StringType, v.ProbeIps.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"hosts": basetypes.ListType{
				ElemType: types.StringType,
			},
			"internal_ips": basetypes.ListType{
				ElemType: types.StringType,
			},
			"probe_ips": basetypes.ListType{
				ElemType: types.StringType,
			},
			"remote_ids": basetypes.ListType{
				ElemType: types.StringType,
			},
			"wan_names": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	remoteIdsVal, d := types.ListValue(types.StringType, v.RemoteIds.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"hosts": basetypes.ListType{
				ElemType: types.StringType,
			},
			"internal_ips": basetypes.ListType{
				ElemType: types.StringType,
			},
			"probe_ips": basetypes.ListType{
				ElemType: types.StringType,
			},
			"remote_ids": basetypes.ListType{
				ElemType: types.StringType,
			},
			"wan_names": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	wanNamesVal, d := types.ListValue(types.StringType, v.WanNames.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"hosts": basetypes.ListType{
				ElemType: types.StringType,
			},
			"internal_ips": basetypes.ListType{
				ElemType: types.StringType,
			},
			"probe_ips": basetypes.ListType{
				ElemType: types.StringType,
			},
			"remote_ids": basetypes.ListType{
				ElemType: types.StringType,
			},
			"wan_names": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"hosts": basetypes.ListType{
			ElemType: types.StringType,
		},
		"internal_ips": basetypes.ListType{
			ElemType: types.StringType,
		},
		"probe_ips": basetypes.ListType{
			ElemType: types.StringType,
		},
		"remote_ids": basetypes.ListType{
			ElemType: types.StringType,
		},
		"wan_names": basetypes.ListType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"hosts":        hostsVal,
			"internal_ips": internalIpsVal,
			"probe_ips":    probeIpsVal,
			"remote_ids":   remoteIdsVal,
			"wan_names":    wanNamesVal,
		})

	return objVal, diags
}

func (v SecondaryValue) Equal(o attr.Value) bool {
	other, ok := o.(SecondaryValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Hosts.Equal(other.Hosts) {
		return false
	}

	if !v.InternalIps.Equal(other.InternalIps) {
		return false
	}

	if !v.ProbeIps.Equal(other.ProbeIps) {
		return false
	}

	if !v.RemoteIds.Equal(other.RemoteIds) {
		return false
	}

	if !v.WanNames.Equal(other.WanNames) {
		return false
	}

	return true
}

func (v SecondaryValue) Type(ctx context.Context) attr.Type {
	return SecondaryType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SecondaryValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"hosts": basetypes.ListType{
			ElemType: types.StringType,
		},
		"internal_ips": basetypes.ListType{
			ElemType: types.StringType,
		},
		"probe_ips": basetypes.ListType{
			ElemType: types.StringType,
		},
		"remote_ids": basetypes.ListType{
			ElemType: types.StringType,
		},
		"wan_names": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = TunnelProviderOptionsType{}

type TunnelProviderOptionsType struct {
	basetypes.ObjectType
}

func (t TunnelProviderOptionsType) Equal(o attr.Type) bool {
	other, ok := o.(TunnelProviderOptionsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t TunnelProviderOptionsType) String() string {
	return "TunnelProviderOptionsType"
}

func (t TunnelProviderOptionsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	jseAttribute, ok := attributes["jse"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`jse is missing from object`)

		return nil, diags
	}

	jseVal, ok := jseAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`jse expected to be basetypes.ObjectValue, was: %T`, jseAttribute))
	}

	zscalerAttribute, ok := attributes["zscaler"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`zscaler is missing from object`)

		return nil, diags
	}

	zscalerVal, ok := zscalerAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`zscaler expected to be basetypes.ObjectValue, was: %T`, zscalerAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return TunnelProviderOptionsValue{
		Jse:     jseVal,
		Zscaler: zscalerVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewTunnelProviderOptionsValueNull() TunnelProviderOptionsValue {
	return TunnelProviderOptionsValue{
		state: attr.ValueStateNull,
	}
}

func NewTunnelProviderOptionsValueUnknown() TunnelProviderOptionsValue {
	return TunnelProviderOptionsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewTunnelProviderOptionsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (TunnelProviderOptionsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing TunnelProviderOptionsValue Attribute Value",
				"While creating a TunnelProviderOptionsValue value, a missing attribute value was detected. "+
					"A TunnelProviderOptionsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TunnelProviderOptionsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid TunnelProviderOptionsValue Attribute Type",
				"While creating a TunnelProviderOptionsValue value, an invalid attribute value was detected. "+
					"A TunnelProviderOptionsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TunnelProviderOptionsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("TunnelProviderOptionsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra TunnelProviderOptionsValue Attribute Value",
				"While creating a TunnelProviderOptionsValue value, an extra attribute value was detected. "+
					"A TunnelProviderOptionsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra TunnelProviderOptionsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewTunnelProviderOptionsValueUnknown(), diags
	}

	jseAttribute, ok := attributes["jse"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`jse is missing from object`)

		return NewTunnelProviderOptionsValueUnknown(), diags
	}

	jseVal, ok := jseAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`jse expected to be basetypes.ObjectValue, was: %T`, jseAttribute))
	}

	zscalerAttribute, ok := attributes["zscaler"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`zscaler is missing from object`)

		return NewTunnelProviderOptionsValueUnknown(), diags
	}

	zscalerVal, ok := zscalerAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`zscaler expected to be basetypes.ObjectValue, was: %T`, zscalerAttribute))
	}

	if diags.HasError() {
		return NewTunnelProviderOptionsValueUnknown(), diags
	}

	return TunnelProviderOptionsValue{
		Jse:     jseVal,
		Zscaler: zscalerVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewTunnelProviderOptionsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) TunnelProviderOptionsValue {
	object, diags := NewTunnelProviderOptionsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewTunnelProviderOptionsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t TunnelProviderOptionsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewTunnelProviderOptionsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewTunnelProviderOptionsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewTunnelProviderOptionsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewTunnelProviderOptionsValueMust(TunnelProviderOptionsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t TunnelProviderOptionsType) ValueType(ctx context.Context) attr.Value {
	return TunnelProviderOptionsValue{}
}

var _ basetypes.ObjectValuable = TunnelProviderOptionsValue{}

type TunnelProviderOptionsValue struct {
	Jse     basetypes.ObjectValue `tfsdk:"jse"`
	Zscaler basetypes.ObjectValue `tfsdk:"zscaler"`
	state   attr.ValueState
}

func (v TunnelProviderOptionsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["jse"] = basetypes.ObjectType{
		AttrTypes: JseValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["zscaler"] = basetypes.ObjectType{
		AttrTypes: ZscalerValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Jse.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["jse"] = val

		val, err = v.Zscaler.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["zscaler"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v TunnelProviderOptionsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v TunnelProviderOptionsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v TunnelProviderOptionsValue) String() string {
	return "TunnelProviderOptionsValue"
}

func (v TunnelProviderOptionsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var jse basetypes.ObjectValue

	if v.Jse.IsNull() {
		jse = types.ObjectNull(
			JseValue{}.AttributeTypes(ctx),
		)
	}

	if v.Jse.IsUnknown() {
		jse = types.ObjectUnknown(
			JseValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Jse.IsNull() && !v.Jse.IsUnknown() {
		jse = types.ObjectValueMust(
			JseValue{}.AttributeTypes(ctx),
			v.Jse.Attributes(),
		)
	}

	var zscaler basetypes.ObjectValue

	if v.Zscaler.IsNull() {
		zscaler = types.ObjectNull(
			ZscalerValue{}.AttributeTypes(ctx),
		)
	}

	if v.Zscaler.IsUnknown() {
		zscaler = types.ObjectUnknown(
			ZscalerValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Zscaler.IsNull() && !v.Zscaler.IsUnknown() {
		zscaler = types.ObjectValueMust(
			ZscalerValue{}.AttributeTypes(ctx),
			v.Zscaler.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"jse": basetypes.ObjectType{
			AttrTypes: JseValue{}.AttributeTypes(ctx),
		},
		"zscaler": basetypes.ObjectType{
			AttrTypes: ZscalerValue{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"jse":     jse,
			"zscaler": zscaler,
		})

	return objVal, diags
}

func (v TunnelProviderOptionsValue) Equal(o attr.Value) bool {
	other, ok := o.(TunnelProviderOptionsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Jse.Equal(other.Jse) {
		return false
	}

	if !v.Zscaler.Equal(other.Zscaler) {
		return false
	}

	return true
}

func (v TunnelProviderOptionsValue) Type(ctx context.Context) attr.Type {
	return TunnelProviderOptionsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v TunnelProviderOptionsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"jse": basetypes.ObjectType{
			AttrTypes: JseValue{}.AttributeTypes(ctx),
		},
		"zscaler": basetypes.ObjectType{
			AttrTypes: ZscalerValue{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = JseType{}

type JseType struct {
	basetypes.ObjectType
}

func (t JseType) Equal(o attr.Type) bool {
	other, ok := o.(JseType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t JseType) String() string {
	return "JseType"
}

func (t JseType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	numUsersAttribute, ok := attributes["num_users"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`num_users is missing from object`)

		return nil, diags
	}

	numUsersVal, ok := numUsersAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`num_users expected to be basetypes.Int64Value, was: %T`, numUsersAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return JseValue{
		Name:     nameVal,
		NumUsers: numUsersVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewJseValueNull() JseValue {
	return JseValue{
		state: attr.ValueStateNull,
	}
}

func NewJseValueUnknown() JseValue {
	return JseValue{
		state: attr.ValueStateUnknown,
	}
}

func NewJseValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (JseValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing JseValue Attribute Value",
				"While creating a JseValue value, a missing attribute value was detected. "+
					"A JseValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("JseValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid JseValue Attribute Type",
				"While creating a JseValue value, an invalid attribute value was detected. "+
					"A JseValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("JseValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("JseValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra JseValue Attribute Value",
				"While creating a JseValue value, an extra attribute value was detected. "+
					"A JseValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra JseValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewJseValueUnknown(), diags
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewJseValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	numUsersAttribute, ok := attributes["num_users"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`num_users is missing from object`)

		return NewJseValueUnknown(), diags
	}

	numUsersVal, ok := numUsersAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`num_users expected to be basetypes.Int64Value, was: %T`, numUsersAttribute))
	}

	if diags.HasError() {
		return NewJseValueUnknown(), diags
	}

	return JseValue{
		Name:     nameVal,
		NumUsers: numUsersVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewJseValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) JseValue {
	object, diags := NewJseValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewJseValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t JseType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewJseValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewJseValueUnknown(), nil
	}

	if in.IsNull() {
		return NewJseValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewJseValueMust(JseValue{}.AttributeTypes(ctx), attributes), nil
}

func (t JseType) ValueType(ctx context.Context) attr.Value {
	return JseValue{}
}

var _ basetypes.ObjectValuable = JseValue{}

type JseValue struct {
	Name     basetypes.StringValue `tfsdk:"name"`
	NumUsers basetypes.Int64Value  `tfsdk:"num_users"`
	state    attr.ValueState
}

func (v JseValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["num_users"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.NumUsers.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["num_users"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v JseValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v JseValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v JseValue) String() string {
	return "JseValue"
}

func (v JseValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"name":      basetypes.StringType{},
		"num_users": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"name":      v.Name,
			"num_users": v.NumUsers,
		})

	return objVal, diags
}

func (v JseValue) Equal(o attr.Value) bool {
	other, ok := o.(JseValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.NumUsers.Equal(other.NumUsers) {
		return false
	}

	return true
}

func (v JseValue) Type(ctx context.Context) attr.Type {
	return JseType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v JseValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"name":      basetypes.StringType{},
		"num_users": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = ZscalerType{}

type ZscalerType struct {
	basetypes.ObjectType
}

func (t ZscalerType) Equal(o attr.Type) bool {
	other, ok := o.(ZscalerType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ZscalerType) String() string {
	return "ZscalerType"
}

func (t ZscalerType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	aupAcceptanceRequiredAttribute, ok := attributes["aup_acceptance_required"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`aup_acceptance_required is missing from object`)

		return nil, diags
	}

	aupAcceptanceRequiredVal, ok := aupAcceptanceRequiredAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`aup_acceptance_required expected to be basetypes.BoolValue, was: %T`, aupAcceptanceRequiredAttribute))
	}

	aupExpireAttribute, ok := attributes["aup_expire"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`aup_expire is missing from object`)

		return nil, diags
	}

	aupExpireVal, ok := aupExpireAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`aup_expire expected to be basetypes.Int64Value, was: %T`, aupExpireAttribute))
	}

	aupSslProxyAttribute, ok := attributes["aup_ssl_proxy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`aup_ssl_proxy is missing from object`)

		return nil, diags
	}

	aupSslProxyVal, ok := aupSslProxyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`aup_ssl_proxy expected to be basetypes.BoolValue, was: %T`, aupSslProxyAttribute))
	}

	downloadMbpsAttribute, ok := attributes["download_mbps"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`download_mbps is missing from object`)

		return nil, diags
	}

	downloadMbpsVal, ok := downloadMbpsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`download_mbps expected to be basetypes.Int64Value, was: %T`, downloadMbpsAttribute))
	}

	enableAupAttribute, ok := attributes["enable_aup"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable_aup is missing from object`)

		return nil, diags
	}

	enableAupVal, ok := enableAupAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable_aup expected to be basetypes.BoolValue, was: %T`, enableAupAttribute))
	}

	enableCautionAttribute, ok := attributes["enable_caution"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable_caution is missing from object`)

		return nil, diags
	}

	enableCautionVal, ok := enableCautionAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable_caution expected to be basetypes.BoolValue, was: %T`, enableCautionAttribute))
	}

	enforceAuthenticationAttribute, ok := attributes["enforce_authentication"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enforce_authentication is missing from object`)

		return nil, diags
	}

	enforceAuthenticationVal, ok := enforceAuthenticationAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enforce_authentication expected to be basetypes.BoolValue, was: %T`, enforceAuthenticationAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	subLocationsAttribute, ok := attributes["sub_locations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sub_locations is missing from object`)

		return nil, diags
	}

	subLocationsVal, ok := subLocationsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sub_locations expected to be basetypes.ListValue, was: %T`, subLocationsAttribute))
	}

	uploadMbpsAttribute, ok := attributes["upload_mbps"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`upload_mbps is missing from object`)

		return nil, diags
	}

	uploadMbpsVal, ok := uploadMbpsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`upload_mbps expected to be basetypes.Int64Value, was: %T`, uploadMbpsAttribute))
	}

	useXffAttribute, ok := attributes["use_xff"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`use_xff is missing from object`)

		return nil, diags
	}

	useXffVal, ok := useXffAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`use_xff expected to be basetypes.BoolValue, was: %T`, useXffAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ZscalerValue{
		AupAcceptanceRequired: aupAcceptanceRequiredVal,
		AupExpire:             aupExpireVal,
		AupSslProxy:           aupSslProxyVal,
		DownloadMbps:          downloadMbpsVal,
		EnableAup:             enableAupVal,
		EnableCaution:         enableCautionVal,
		EnforceAuthentication: enforceAuthenticationVal,
		Name:                  nameVal,
		SubLocations:          subLocationsVal,
		UploadMbps:            uploadMbpsVal,
		UseXff:                useXffVal,
		state:                 attr.ValueStateKnown,
	}, diags
}

func NewZscalerValueNull() ZscalerValue {
	return ZscalerValue{
		state: attr.ValueStateNull,
	}
}

func NewZscalerValueUnknown() ZscalerValue {
	return ZscalerValue{
		state: attr.ValueStateUnknown,
	}
}

func NewZscalerValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ZscalerValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ZscalerValue Attribute Value",
				"While creating a ZscalerValue value, a missing attribute value was detected. "+
					"A ZscalerValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ZscalerValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ZscalerValue Attribute Type",
				"While creating a ZscalerValue value, an invalid attribute value was detected. "+
					"A ZscalerValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ZscalerValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ZscalerValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ZscalerValue Attribute Value",
				"While creating a ZscalerValue value, an extra attribute value was detected. "+
					"A ZscalerValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ZscalerValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewZscalerValueUnknown(), diags
	}

	aupAcceptanceRequiredAttribute, ok := attributes["aup_acceptance_required"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`aup_acceptance_required is missing from object`)

		return NewZscalerValueUnknown(), diags
	}

	aupAcceptanceRequiredVal, ok := aupAcceptanceRequiredAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`aup_acceptance_required expected to be basetypes.BoolValue, was: %T`, aupAcceptanceRequiredAttribute))
	}

	aupExpireAttribute, ok := attributes["aup_expire"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`aup_expire is missing from object`)

		return NewZscalerValueUnknown(), diags
	}

	aupExpireVal, ok := aupExpireAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`aup_expire expected to be basetypes.Int64Value, was: %T`, aupExpireAttribute))
	}

	aupSslProxyAttribute, ok := attributes["aup_ssl_proxy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`aup_ssl_proxy is missing from object`)

		return NewZscalerValueUnknown(), diags
	}

	aupSslProxyVal, ok := aupSslProxyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`aup_ssl_proxy expected to be basetypes.BoolValue, was: %T`, aupSslProxyAttribute))
	}

	downloadMbpsAttribute, ok := attributes["download_mbps"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`download_mbps is missing from object`)

		return NewZscalerValueUnknown(), diags
	}

	downloadMbpsVal, ok := downloadMbpsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`download_mbps expected to be basetypes.Int64Value, was: %T`, downloadMbpsAttribute))
	}

	enableAupAttribute, ok := attributes["enable_aup"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable_aup is missing from object`)

		return NewZscalerValueUnknown(), diags
	}

	enableAupVal, ok := enableAupAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable_aup expected to be basetypes.BoolValue, was: %T`, enableAupAttribute))
	}

	enableCautionAttribute, ok := attributes["enable_caution"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable_caution is missing from object`)

		return NewZscalerValueUnknown(), diags
	}

	enableCautionVal, ok := enableCautionAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable_caution expected to be basetypes.BoolValue, was: %T`, enableCautionAttribute))
	}

	enforceAuthenticationAttribute, ok := attributes["enforce_authentication"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enforce_authentication is missing from object`)

		return NewZscalerValueUnknown(), diags
	}

	enforceAuthenticationVal, ok := enforceAuthenticationAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enforce_authentication expected to be basetypes.BoolValue, was: %T`, enforceAuthenticationAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewZscalerValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	subLocationsAttribute, ok := attributes["sub_locations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sub_locations is missing from object`)

		return NewZscalerValueUnknown(), diags
	}

	subLocationsVal, ok := subLocationsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sub_locations expected to be basetypes.ListValue, was: %T`, subLocationsAttribute))
	}

	uploadMbpsAttribute, ok := attributes["upload_mbps"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`upload_mbps is missing from object`)

		return NewZscalerValueUnknown(), diags
	}

	uploadMbpsVal, ok := uploadMbpsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`upload_mbps expected to be basetypes.Int64Value, was: %T`, uploadMbpsAttribute))
	}

	useXffAttribute, ok := attributes["use_xff"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`use_xff is missing from object`)

		return NewZscalerValueUnknown(), diags
	}

	useXffVal, ok := useXffAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`use_xff expected to be basetypes.BoolValue, was: %T`, useXffAttribute))
	}

	if diags.HasError() {
		return NewZscalerValueUnknown(), diags
	}

	return ZscalerValue{
		AupAcceptanceRequired: aupAcceptanceRequiredVal,
		AupExpire:             aupExpireVal,
		AupSslProxy:           aupSslProxyVal,
		DownloadMbps:          downloadMbpsVal,
		EnableAup:             enableAupVal,
		EnableCaution:         enableCautionVal,
		EnforceAuthentication: enforceAuthenticationVal,
		Name:                  nameVal,
		SubLocations:          subLocationsVal,
		UploadMbps:            uploadMbpsVal,
		UseXff:                useXffVal,
		state:                 attr.ValueStateKnown,
	}, diags
}

func NewZscalerValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ZscalerValue {
	object, diags := NewZscalerValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewZscalerValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ZscalerType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewZscalerValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewZscalerValueUnknown(), nil
	}

	if in.IsNull() {
		return NewZscalerValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewZscalerValueMust(ZscalerValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ZscalerType) ValueType(ctx context.Context) attr.Value {
	return ZscalerValue{}
}

var _ basetypes.ObjectValuable = ZscalerValue{}

type ZscalerValue struct {
	AupAcceptanceRequired basetypes.BoolValue   `tfsdk:"aup_acceptance_required"`
	AupExpire             basetypes.Int64Value  `tfsdk:"aup_expire"`
	AupSslProxy           basetypes.BoolValue   `tfsdk:"aup_ssl_proxy"`
	DownloadMbps          basetypes.Int64Value  `tfsdk:"download_mbps"`
	EnableAup             basetypes.BoolValue   `tfsdk:"enable_aup"`
	EnableCaution         basetypes.BoolValue   `tfsdk:"enable_caution"`
	EnforceAuthentication basetypes.BoolValue   `tfsdk:"enforce_authentication"`
	Name                  basetypes.StringValue `tfsdk:"name"`
	SubLocations          basetypes.ListValue   `tfsdk:"sub_locations"`
	UploadMbps            basetypes.Int64Value  `tfsdk:"upload_mbps"`
	UseXff                basetypes.BoolValue   `tfsdk:"use_xff"`
	state                 attr.ValueState
}

func (v ZscalerValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 11)

	var val tftypes.Value
	var err error

	attrTypes["aup_acceptance_required"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["aup_expire"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["aup_ssl_proxy"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["download_mbps"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["enable_aup"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["enable_caution"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["enforce_authentication"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["sub_locations"] = basetypes.ListType{
		ElemType: SubLocationsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["upload_mbps"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["use_xff"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 11)

		val, err = v.AupAcceptanceRequired.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["aup_acceptance_required"] = val

		val, err = v.AupExpire.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["aup_expire"] = val

		val, err = v.AupSslProxy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["aup_ssl_proxy"] = val

		val, err = v.DownloadMbps.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["download_mbps"] = val

		val, err = v.EnableAup.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enable_aup"] = val

		val, err = v.EnableCaution.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enable_caution"] = val

		val, err = v.EnforceAuthentication.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enforce_authentication"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.SubLocations.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["sub_locations"] = val

		val, err = v.UploadMbps.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["upload_mbps"] = val

		val, err = v.UseXff.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["use_xff"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ZscalerValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ZscalerValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ZscalerValue) String() string {
	return "ZscalerValue"
}

func (v ZscalerValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	subLocations := types.ListValueMust(
		SubLocationsType{
			basetypes.ObjectType{
				AttrTypes: SubLocationsValue{}.AttributeTypes(ctx),
			},
		},
		v.SubLocations.Elements(),
	)

	if v.SubLocations.IsNull() {
		subLocations = types.ListNull(
			SubLocationsType{
				basetypes.ObjectType{
					AttrTypes: SubLocationsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.SubLocations.IsUnknown() {
		subLocations = types.ListUnknown(
			SubLocationsType{
				basetypes.ObjectType{
					AttrTypes: SubLocationsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"aup_acceptance_required": basetypes.BoolType{},
		"aup_expire":              basetypes.Int64Type{},
		"aup_ssl_proxy":           basetypes.BoolType{},
		"download_mbps":           basetypes.Int64Type{},
		"enable_aup":              basetypes.BoolType{},
		"enable_caution":          basetypes.BoolType{},
		"enforce_authentication":  basetypes.BoolType{},
		"name":                    basetypes.StringType{},
		"sub_locations": basetypes.ListType{
			ElemType: SubLocationsValue{}.Type(ctx),
		},
		"upload_mbps": basetypes.Int64Type{},
		"use_xff":     basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"aup_acceptance_required": v.AupAcceptanceRequired,
			"aup_expire":              v.AupExpire,
			"aup_ssl_proxy":           v.AupSslProxy,
			"download_mbps":           v.DownloadMbps,
			"enable_aup":              v.EnableAup,
			"enable_caution":          v.EnableCaution,
			"enforce_authentication":  v.EnforceAuthentication,
			"name":                    v.Name,
			"sub_locations":           subLocations,
			"upload_mbps":             v.UploadMbps,
			"use_xff":                 v.UseXff,
		})

	return objVal, diags
}

func (v ZscalerValue) Equal(o attr.Value) bool {
	other, ok := o.(ZscalerValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AupAcceptanceRequired.Equal(other.AupAcceptanceRequired) {
		return false
	}

	if !v.AupExpire.Equal(other.AupExpire) {
		return false
	}

	if !v.AupSslProxy.Equal(other.AupSslProxy) {
		return false
	}

	if !v.DownloadMbps.Equal(other.DownloadMbps) {
		return false
	}

	if !v.EnableAup.Equal(other.EnableAup) {
		return false
	}

	if !v.EnableCaution.Equal(other.EnableCaution) {
		return false
	}

	if !v.EnforceAuthentication.Equal(other.EnforceAuthentication) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.SubLocations.Equal(other.SubLocations) {
		return false
	}

	if !v.UploadMbps.Equal(other.UploadMbps) {
		return false
	}

	if !v.UseXff.Equal(other.UseXff) {
		return false
	}

	return true
}

func (v ZscalerValue) Type(ctx context.Context) attr.Type {
	return ZscalerType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ZscalerValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"aup_acceptance_required": basetypes.BoolType{},
		"aup_expire":              basetypes.Int64Type{},
		"aup_ssl_proxy":           basetypes.BoolType{},
		"download_mbps":           basetypes.Int64Type{},
		"enable_aup":              basetypes.BoolType{},
		"enable_caution":          basetypes.BoolType{},
		"enforce_authentication":  basetypes.BoolType{},
		"name":                    basetypes.StringType{},
		"sub_locations": basetypes.ListType{
			ElemType: SubLocationsValue{}.Type(ctx),
		},
		"upload_mbps": basetypes.Int64Type{},
		"use_xff":     basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = SubLocationsType{}

type SubLocationsType struct {
	basetypes.ObjectType
}

func (t SubLocationsType) Equal(o attr.Type) bool {
	other, ok := o.(SubLocationsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SubLocationsType) String() string {
	return "SubLocationsType"
}

func (t SubLocationsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	aupAcceptanceRequiredAttribute, ok := attributes["aup_acceptance_required"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`aup_acceptance_required is missing from object`)

		return nil, diags
	}

	aupAcceptanceRequiredVal, ok := aupAcceptanceRequiredAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`aup_acceptance_required expected to be basetypes.BoolValue, was: %T`, aupAcceptanceRequiredAttribute))
	}

	aupExpireAttribute, ok := attributes["aup_expire"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`aup_expire is missing from object`)

		return nil, diags
	}

	aupExpireVal, ok := aupExpireAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`aup_expire expected to be basetypes.Int64Value, was: %T`, aupExpireAttribute))
	}

	aupSslProxyAttribute, ok := attributes["aup_ssl_proxy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`aup_ssl_proxy is missing from object`)

		return nil, diags
	}

	aupSslProxyVal, ok := aupSslProxyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`aup_ssl_proxy expected to be basetypes.BoolValue, was: %T`, aupSslProxyAttribute))
	}

	downloadMbpsAttribute, ok := attributes["download_mbps"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`download_mbps is missing from object`)

		return nil, diags
	}

	downloadMbpsVal, ok := downloadMbpsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`download_mbps expected to be basetypes.Int64Value, was: %T`, downloadMbpsAttribute))
	}

	enableAupAttribute, ok := attributes["enable_aup"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable_aup is missing from object`)

		return nil, diags
	}

	enableAupVal, ok := enableAupAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable_aup expected to be basetypes.BoolValue, was: %T`, enableAupAttribute))
	}

	enableCautionAttribute, ok := attributes["enable_caution"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable_caution is missing from object`)

		return nil, diags
	}

	enableCautionVal, ok := enableCautionAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable_caution expected to be basetypes.BoolValue, was: %T`, enableCautionAttribute))
	}

	enforceAuthenticationAttribute, ok := attributes["enforce_authentication"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enforce_authentication is missing from object`)

		return nil, diags
	}

	enforceAuthenticationVal, ok := enforceAuthenticationAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enforce_authentication expected to be basetypes.BoolValue, was: %T`, enforceAuthenticationAttribute))
	}

	subnetsAttribute, ok := attributes["subnets"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnets is missing from object`)

		return nil, diags
	}

	subnetsVal, ok := subnetsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnets expected to be basetypes.ListValue, was: %T`, subnetsAttribute))
	}

	uploadMbpsAttribute, ok := attributes["upload_mbps"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`upload_mbps is missing from object`)

		return nil, diags
	}

	uploadMbpsVal, ok := uploadMbpsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`upload_mbps expected to be basetypes.Int64Value, was: %T`, uploadMbpsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SubLocationsValue{
		AupAcceptanceRequired: aupAcceptanceRequiredVal,
		AupExpire:             aupExpireVal,
		AupSslProxy:           aupSslProxyVal,
		DownloadMbps:          downloadMbpsVal,
		EnableAup:             enableAupVal,
		EnableCaution:         enableCautionVal,
		EnforceAuthentication: enforceAuthenticationVal,
		Subnets:               subnetsVal,
		UploadMbps:            uploadMbpsVal,
		state:                 attr.ValueStateKnown,
	}, diags
}

func NewSubLocationsValueNull() SubLocationsValue {
	return SubLocationsValue{
		state: attr.ValueStateNull,
	}
}

func NewSubLocationsValueUnknown() SubLocationsValue {
	return SubLocationsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSubLocationsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SubLocationsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SubLocationsValue Attribute Value",
				"While creating a SubLocationsValue value, a missing attribute value was detected. "+
					"A SubLocationsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SubLocationsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SubLocationsValue Attribute Type",
				"While creating a SubLocationsValue value, an invalid attribute value was detected. "+
					"A SubLocationsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SubLocationsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SubLocationsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SubLocationsValue Attribute Value",
				"While creating a SubLocationsValue value, an extra attribute value was detected. "+
					"A SubLocationsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SubLocationsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSubLocationsValueUnknown(), diags
	}

	aupAcceptanceRequiredAttribute, ok := attributes["aup_acceptance_required"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`aup_acceptance_required is missing from object`)

		return NewSubLocationsValueUnknown(), diags
	}

	aupAcceptanceRequiredVal, ok := aupAcceptanceRequiredAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`aup_acceptance_required expected to be basetypes.BoolValue, was: %T`, aupAcceptanceRequiredAttribute))
	}

	aupExpireAttribute, ok := attributes["aup_expire"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`aup_expire is missing from object`)

		return NewSubLocationsValueUnknown(), diags
	}

	aupExpireVal, ok := aupExpireAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`aup_expire expected to be basetypes.Int64Value, was: %T`, aupExpireAttribute))
	}

	aupSslProxyAttribute, ok := attributes["aup_ssl_proxy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`aup_ssl_proxy is missing from object`)

		return NewSubLocationsValueUnknown(), diags
	}

	aupSslProxyVal, ok := aupSslProxyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`aup_ssl_proxy expected to be basetypes.BoolValue, was: %T`, aupSslProxyAttribute))
	}

	downloadMbpsAttribute, ok := attributes["download_mbps"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`download_mbps is missing from object`)

		return NewSubLocationsValueUnknown(), diags
	}

	downloadMbpsVal, ok := downloadMbpsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`download_mbps expected to be basetypes.Int64Value, was: %T`, downloadMbpsAttribute))
	}

	enableAupAttribute, ok := attributes["enable_aup"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable_aup is missing from object`)

		return NewSubLocationsValueUnknown(), diags
	}

	enableAupVal, ok := enableAupAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable_aup expected to be basetypes.BoolValue, was: %T`, enableAupAttribute))
	}

	enableCautionAttribute, ok := attributes["enable_caution"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable_caution is missing from object`)

		return NewSubLocationsValueUnknown(), diags
	}

	enableCautionVal, ok := enableCautionAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable_caution expected to be basetypes.BoolValue, was: %T`, enableCautionAttribute))
	}

	enforceAuthenticationAttribute, ok := attributes["enforce_authentication"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enforce_authentication is missing from object`)

		return NewSubLocationsValueUnknown(), diags
	}

	enforceAuthenticationVal, ok := enforceAuthenticationAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enforce_authentication expected to be basetypes.BoolValue, was: %T`, enforceAuthenticationAttribute))
	}

	subnetsAttribute, ok := attributes["subnets"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnets is missing from object`)

		return NewSubLocationsValueUnknown(), diags
	}

	subnetsVal, ok := subnetsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnets expected to be basetypes.ListValue, was: %T`, subnetsAttribute))
	}

	uploadMbpsAttribute, ok := attributes["upload_mbps"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`upload_mbps is missing from object`)

		return NewSubLocationsValueUnknown(), diags
	}

	uploadMbpsVal, ok := uploadMbpsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`upload_mbps expected to be basetypes.Int64Value, was: %T`, uploadMbpsAttribute))
	}

	if diags.HasError() {
		return NewSubLocationsValueUnknown(), diags
	}

	return SubLocationsValue{
		AupAcceptanceRequired: aupAcceptanceRequiredVal,
		AupExpire:             aupExpireVal,
		AupSslProxy:           aupSslProxyVal,
		DownloadMbps:          downloadMbpsVal,
		EnableAup:             enableAupVal,
		EnableCaution:         enableCautionVal,
		EnforceAuthentication: enforceAuthenticationVal,
		Subnets:               subnetsVal,
		UploadMbps:            uploadMbpsVal,
		state:                 attr.ValueStateKnown,
	}, diags
}

func NewSubLocationsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SubLocationsValue {
	object, diags := NewSubLocationsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSubLocationsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SubLocationsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSubLocationsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSubLocationsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSubLocationsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSubLocationsValueMust(SubLocationsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SubLocationsType) ValueType(ctx context.Context) attr.Value {
	return SubLocationsValue{}
}

var _ basetypes.ObjectValuable = SubLocationsValue{}

type SubLocationsValue struct {
	AupAcceptanceRequired basetypes.BoolValue  `tfsdk:"aup_acceptance_required"`
	AupExpire             basetypes.Int64Value `tfsdk:"aup_expire"`
	AupSslProxy           basetypes.BoolValue  `tfsdk:"aup_ssl_proxy"`
	DownloadMbps          basetypes.Int64Value `tfsdk:"download_mbps"`
	EnableAup             basetypes.BoolValue  `tfsdk:"enable_aup"`
	EnableCaution         basetypes.BoolValue  `tfsdk:"enable_caution"`
	EnforceAuthentication basetypes.BoolValue  `tfsdk:"enforce_authentication"`
	Subnets               basetypes.ListValue  `tfsdk:"subnets"`
	UploadMbps            basetypes.Int64Value `tfsdk:"upload_mbps"`
	state                 attr.ValueState
}

func (v SubLocationsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 9)

	var val tftypes.Value
	var err error

	attrTypes["aup_acceptance_required"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["aup_expire"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["aup_ssl_proxy"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["download_mbps"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["enable_aup"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["enable_caution"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["enforce_authentication"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["subnets"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["upload_mbps"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 9)

		val, err = v.AupAcceptanceRequired.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["aup_acceptance_required"] = val

		val, err = v.AupExpire.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["aup_expire"] = val

		val, err = v.AupSslProxy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["aup_ssl_proxy"] = val

		val, err = v.DownloadMbps.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["download_mbps"] = val

		val, err = v.EnableAup.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enable_aup"] = val

		val, err = v.EnableCaution.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enable_caution"] = val

		val, err = v.EnforceAuthentication.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enforce_authentication"] = val

		val, err = v.Subnets.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["subnets"] = val

		val, err = v.UploadMbps.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["upload_mbps"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SubLocationsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SubLocationsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SubLocationsValue) String() string {
	return "SubLocationsValue"
}

func (v SubLocationsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	subnetsVal, d := types.ListValue(types.StringType, v.Subnets.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"aup_acceptance_required": basetypes.BoolType{},
			"aup_expire":              basetypes.Int64Type{},
			"aup_ssl_proxy":           basetypes.BoolType{},
			"download_mbps":           basetypes.Int64Type{},
			"enable_aup":              basetypes.BoolType{},
			"enable_caution":          basetypes.BoolType{},
			"enforce_authentication":  basetypes.BoolType{},
			"subnets": basetypes.ListType{
				ElemType: types.StringType,
			},
			"upload_mbps": basetypes.Int64Type{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"aup_acceptance_required": basetypes.BoolType{},
		"aup_expire":              basetypes.Int64Type{},
		"aup_ssl_proxy":           basetypes.BoolType{},
		"download_mbps":           basetypes.Int64Type{},
		"enable_aup":              basetypes.BoolType{},
		"enable_caution":          basetypes.BoolType{},
		"enforce_authentication":  basetypes.BoolType{},
		"subnets": basetypes.ListType{
			ElemType: types.StringType,
		},
		"upload_mbps": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"aup_acceptance_required": v.AupAcceptanceRequired,
			"aup_expire":              v.AupExpire,
			"aup_ssl_proxy":           v.AupSslProxy,
			"download_mbps":           v.DownloadMbps,
			"enable_aup":              v.EnableAup,
			"enable_caution":          v.EnableCaution,
			"enforce_authentication":  v.EnforceAuthentication,
			"subnets":                 subnetsVal,
			"upload_mbps":             v.UploadMbps,
		})

	return objVal, diags
}

func (v SubLocationsValue) Equal(o attr.Value) bool {
	other, ok := o.(SubLocationsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AupAcceptanceRequired.Equal(other.AupAcceptanceRequired) {
		return false
	}

	if !v.AupExpire.Equal(other.AupExpire) {
		return false
	}

	if !v.AupSslProxy.Equal(other.AupSslProxy) {
		return false
	}

	if !v.DownloadMbps.Equal(other.DownloadMbps) {
		return false
	}

	if !v.EnableAup.Equal(other.EnableAup) {
		return false
	}

	if !v.EnableCaution.Equal(other.EnableCaution) {
		return false
	}

	if !v.EnforceAuthentication.Equal(other.EnforceAuthentication) {
		return false
	}

	if !v.Subnets.Equal(other.Subnets) {
		return false
	}

	if !v.UploadMbps.Equal(other.UploadMbps) {
		return false
	}

	return true
}

func (v SubLocationsValue) Type(ctx context.Context) attr.Type {
	return SubLocationsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SubLocationsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"aup_acceptance_required": basetypes.BoolType{},
		"aup_expire":              basetypes.Int64Type{},
		"aup_ssl_proxy":           basetypes.BoolType{},
		"download_mbps":           basetypes.Int64Type{},
		"enable_aup":              basetypes.BoolType{},
		"enable_caution":          basetypes.BoolType{},
		"enforce_authentication":  basetypes.BoolType{},
		"subnets": basetypes.ListType{
			ElemType: types.StringType,
		},
		"upload_mbps": basetypes.Int64Type{},
	}
}
