// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package resource_org_mx_edge

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework-validators/int64validator"
	"github.com/hashicorp/terraform-plugin-framework-validators/listvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/booldefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/int64default"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
)

func OrgMxEdgeResourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"claim_code": schema.StringAttribute{
				Optional: true,
			},
			"id": schema.StringAttribute{
				Computed: true,
			},
			"model": schema.StringAttribute{
				Required: true,
			},
			"mxagent_registered": schema.BoolAttribute{
				Computed: true,
			},
			"mxcluster_id": schema.StringAttribute{
				Optional:            true,
				Description:         "MxCluster this MxEdge belongs to",
				MarkdownDescription: "MxCluster this MxEdge belongs to",
			},
			"mxedge_mgmt": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"fips_enabled": schema.BoolAttribute{
						Optional: true,
						Computed: true,
						Default:  booldefault.StaticBool(false),
					},
					"mist_password": schema.StringAttribute{
						Optional:  true,
						Sensitive: true,
					},
					"oob_ip_type": schema.StringAttribute{
						Optional: true,
						Computed: true,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"",
								"dhcp",
								"static",
								"disabled",
							),
						},
						Default: stringdefault.StaticString("dhcp"),
					},
					"oob_ip_type6": schema.StringAttribute{
						Optional: true,
						Computed: true,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"",
								"autoconf",
								"dhcp",
								"static",
								"disabled",
							),
						},
						Default: stringdefault.StaticString("autoconf"),
					},
					"root_password": schema.StringAttribute{
						Optional:  true,
						Sensitive: true,
					},
				},
				CustomType: MxedgeMgmtType{
					ObjectType: types.ObjectType{
						AttrTypes: MxedgeMgmtValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
			},
			"name": schema.StringAttribute{
				Required: true,
			},
			"note": schema.StringAttribute{
				Optional: true,
			},
			"ntp_servers": schema.ListAttribute{
				ElementType: types.StringType,
				Optional:    true,
				Validators: []validator.List{
					listvalidator.UniqueValues(),
				},
			},
			"oob_ip_config": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"autoconf6": schema.BoolAttribute{
						Optional: true,
						Computed: true,
						Default:  booldefault.StaticBool(true),
					},
					"dhcp6": schema.BoolAttribute{
						Optional: true,
						Computed: true,
						Default:  booldefault.StaticBool(true),
					},
					"dns": schema.ListAttribute{
						ElementType:         types.StringType,
						Optional:            true,
						Description:         "IPv4 ignored if `type`!=`static`\nIPv6 ignored if `type6`!=`static`",
						MarkdownDescription: "IPv4 ignored if `type`!=`static`\nIPv6 ignored if `type6`!=`static`",
					},
					"gateway": schema.StringAttribute{
						Optional:            true,
						Description:         "if `type`=`static`",
						MarkdownDescription: "if `type`=`static`",
					},
					"gateway6": schema.StringAttribute{
						Optional: true,
					},
					"ip": schema.StringAttribute{
						Optional:            true,
						Description:         "if `type`=`static`",
						MarkdownDescription: "if `type`=`static`",
					},
					"ip6": schema.StringAttribute{
						Optional: true,
					},
					"netmask": schema.StringAttribute{
						Optional:            true,
						Description:         "if `type`=`static`",
						MarkdownDescription: "if `type`=`static`",
					},
					"netmask6": schema.StringAttribute{
						Optional: true,
					},
					"type": schema.StringAttribute{
						Optional: true,
						Computed: true,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"",
								"static",
								"dhcp",
							),
						},
						Default: stringdefault.StaticString("dhcp"),
					},
					"type6": schema.StringAttribute{
						Optional: true,
						Computed: true,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"",
								"static",
								"dhcp",
							),
						},
						Default: stringdefault.StaticString("dhcp"),
					},
				},
				CustomType: OobIpConfigType{
					ObjectType: types.ObjectType{
						AttrTypes: OobIpConfigValue{}.AttributeTypes(ctx),
					},
				},
				Optional:            true,
				Description:         "ip configuration of the Mist Edge out-of_band management interface",
				MarkdownDescription: "ip configuration of the Mist Edge out-of_band management interface",
			},
			"org_id": schema.StringAttribute{
				Required: true,
			},
			"proxy": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"url": schema.StringAttribute{
						Optional: true,
					},
				},
				CustomType: ProxyType{
					ObjectType: types.ObjectType{
						AttrTypes: ProxyValue{}.AttributeTypes(ctx),
					},
				},
				Optional:            true,
				Description:         "Proxy Configuration to talk to Mist",
				MarkdownDescription: "Proxy Configuration to talk to Mist",
			},
			"services": schema.ListAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Description:         "list of services to run, tunterm only for now",
				MarkdownDescription: "list of services to run, tunterm only for now",
			},
			"site_id": schema.StringAttribute{
				Optional: true,
			},
			"tunterm_dhcpd_config": schema.MapNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"enabled": schema.BoolAttribute{
							Optional: true,
							Computed: true,
							Default:  booldefault.StaticBool(false),
						},
						"servers": schema.ListAttribute{
							ElementType:         types.StringType,
							Optional:            true,
							Description:         "list of DHCP servers; required if `type`==`relay`",
							MarkdownDescription: "list of DHCP servers; required if `type`==`relay`",
						},
						"type": schema.StringAttribute{
							Optional: true,
							Computed: true,
							Validators: []validator.String{
								stringvalidator.OneOf(
									"",
									"relay",
								),
							},
							Default: stringdefault.StaticString("relay"),
						},
					},
					CustomType: TuntermDhcpdConfigType{
						ObjectType: types.ObjectType{
							AttrTypes: TuntermDhcpdConfigValue{}.AttributeTypes(ctx),
						},
					},
				},
				Optional:            true,
				Description:         "global and per-VLAN. Property key is the VLAN ID",
				MarkdownDescription: "global and per-VLAN. Property key is the VLAN ID",
			},
			"tunterm_extra_routes": schema.MapNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"via": schema.StringAttribute{
							Optional: true,
						},
					},
					CustomType: TuntermExtraRoutesType{
						ObjectType: types.ObjectType{
							AttrTypes: TuntermExtraRoutesValue{}.AttributeTypes(ctx),
						},
					},
				},
				Optional:            true,
				Description:         "Property key is a CIDR",
				MarkdownDescription: "Property key is a CIDR",
			},
			"tunterm_igmp_snooping_config": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"enabled": schema.BoolAttribute{
						Optional: true,
						Computed: true,
						Default:  booldefault.StaticBool(false),
					},
					"querier": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"max_response_time": schema.Int64Attribute{
								Optional:            true,
								Description:         "querier’s query response interval, in tenths-of-seconds",
								MarkdownDescription: "querier’s query response interval, in tenths-of-seconds",
							},
							"mtu": schema.Int64Attribute{
								Optional:            true,
								Description:         "the MTU we use (needed when forming large IGMPv3 Reports)",
								MarkdownDescription: "the MTU we use (needed when forming large IGMPv3 Reports)",
							},
							"query_interval": schema.Int64Attribute{
								Optional:            true,
								Description:         "querier’s query interval, in seconds",
								MarkdownDescription: "querier’s query interval, in seconds",
							},
							"robustness": schema.Int64Attribute{
								Optional:            true,
								Description:         "querier’s robustness",
								MarkdownDescription: "querier’s robustness",
								Validators: []validator.Int64{
									int64validator.Between(1, 7),
								},
							},
							"version": schema.Int64Attribute{
								Optional:            true,
								Description:         "querier’s maximum protocol version",
								MarkdownDescription: "querier’s maximum protocol version",
							},
						},
						CustomType: QuerierType{
							ObjectType: types.ObjectType{
								AttrTypes: QuerierValue{}.AttributeTypes(ctx),
							},
						},
						Optional: true,
					},
					"vlan_ids": schema.ListAttribute{
						ElementType:         types.Int64Type,
						Optional:            true,
						Description:         "the list of vlans on which tunterm performs IGMP snooping",
						MarkdownDescription: "the list of vlans on which tunterm performs IGMP snooping",
					},
				},
				CustomType: TuntermIgmpSnoopingConfigType{
					ObjectType: types.ObjectType{
						AttrTypes: TuntermIgmpSnoopingConfigValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
			},
			"tunterm_ip_config": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"gateway": schema.StringAttribute{
						Required: true,
					},
					"gateway6": schema.StringAttribute{
						Optional: true,
					},
					"ip": schema.StringAttribute{
						Required:            true,
						Description:         "untagged VLAN",
						MarkdownDescription: "untagged VLAN",
					},
					"ip6": schema.StringAttribute{
						Optional: true,
					},
					"netmask": schema.StringAttribute{
						Required: true,
					},
					"netmask6": schema.StringAttribute{
						Optional: true,
					},
				},
				CustomType: TuntermIpConfigType{
					ObjectType: types.ObjectType{
						AttrTypes: TuntermIpConfigValue{}.AttributeTypes(ctx),
					},
				},
				Optional:            true,
				Description:         "ip configuration of the Mist Tunnel interface",
				MarkdownDescription: "ip configuration of the Mist Tunnel interface",
			},
			"tunterm_monitoring": schema.ListAttribute{
				ElementType: types.ListType{
					ElemType: types.ObjectType{
						AttrTypes: map[string]attr.Type{
							"host":     types.StringType,
							"port":     types.Int64Type,
							"protocol": types.StringType,
							"timeout":  types.Int64Type,
						},
					},
				},
				Optional: true,
			},
			"tunterm_multicast_config": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"mdns": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"enabled": schema.BoolAttribute{
								Optional: true,
							},
							"vlan_ids": schema.ListAttribute{
								ElementType: types.StringType,
								Optional:    true,
								Validators: []validator.List{
									listvalidator.UniqueValues(),
								},
							},
						},
						CustomType: MdnsType{
							ObjectType: types.ObjectType{
								AttrTypes: MdnsValue{}.AttributeTypes(ctx),
							},
						},
						Optional: true,
					},
					"ssdp": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"enabled": schema.BoolAttribute{
								Optional: true,
							},
							"vlan_ids": schema.ListAttribute{
								ElementType: types.StringType,
								Optional:    true,
								Validators: []validator.List{
									listvalidator.UniqueValues(),
								},
							},
						},
						CustomType: SsdpType{
							ObjectType: types.ObjectType{
								AttrTypes: SsdpValue{}.AttributeTypes(ctx),
							},
						},
						Optional: true,
					},
				},
				CustomType: TuntermMulticastConfigType{
					ObjectType: types.ObjectType{
						AttrTypes: TuntermMulticastConfigValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
			},
			"tunterm_other_ip_configs": schema.MapNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"ip": schema.StringAttribute{
							Required: true,
						},
						"netmask": schema.StringAttribute{
							Required: true,
						},
					},
					CustomType: TuntermOtherIpConfigsType{
						ObjectType: types.ObjectType{
							AttrTypes: TuntermOtherIpConfigsValue{}.AttributeTypes(ctx),
						},
					},
				},
				Optional:            true,
				Description:         "ip configs by VLAN ID. Property key is the VLAN ID",
				MarkdownDescription: "ip configs by VLAN ID. Property key is the VLAN ID",
			},
			"tunterm_port_config": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"downstream_ports": schema.ListAttribute{
						ElementType:         types.StringType,
						Optional:            true,
						Description:         "list of ports to be used for downstream (to AP) purpose",
						MarkdownDescription: "list of ports to be used for downstream (to AP) purpose",
					},
					"separate_upstream_downstream": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "weather to separate upstream / downstream ports. default is false where all ports will be used.",
						MarkdownDescription: "weather to separate upstream / downstream ports. default is false where all ports will be used.",
						Default:             booldefault.StaticBool(false),
					},
					"upstream_port_vlan_id": schema.Int64Attribute{
						Optional:            true,
						Computed:            true,
						Description:         "native VLAN id for upstream ports",
						MarkdownDescription: "native VLAN id for upstream ports",
						Default:             int64default.StaticInt64(1),
					},
					"upstream_ports": schema.ListAttribute{
						ElementType:         types.StringType,
						Optional:            true,
						Description:         "list of ports to be used for upstrea purpose (to LAN)",
						MarkdownDescription: "list of ports to be used for upstrea purpose (to LAN)",
					},
				},
				CustomType: TuntermPortConfigType{
					ObjectType: types.ObjectType{
						AttrTypes: TuntermPortConfigValue{}.AttributeTypes(ctx),
					},
				},
				Optional:            true,
				Description:         "ethernet port configurations",
				MarkdownDescription: "ethernet port configurations",
			},
			"tunterm_registered": schema.BoolAttribute{
				Computed: true,
			},
			"tunterm_switch_config": schema.MapNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"port_vlan_id": schema.Int64Attribute{
							Optional: true,
						},
						"vlan_ids": schema.ListAttribute{
							ElementType: types.StringType,
							Optional:    true,
						},
					},
					CustomType: TuntermSwitchConfigType{
						ObjectType: types.ObjectType{
							AttrTypes: TuntermSwitchConfigValue{}.AttributeTypes(ctx),
						},
					},
				},
				Optional:            true,
				Description:         "if custom vlan settings are desired",
				MarkdownDescription: "if custom vlan settings are desired",
			},
			"versions": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"mxagent": schema.StringAttribute{
						Optional: true,
					},
					"tuntnerm": schema.StringAttribute{
						Optional: true,
					},
				},
				CustomType: VersionsType{
					ObjectType: types.ObjectType{
						AttrTypes: VersionsValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
			},
		},
	}
}

type OrgMxEdgeModel struct {
	ClaimCode                 types.String                   `tfsdk:"claim_code"`
	Id                        types.String                   `tfsdk:"id"`
	Model                     types.String                   `tfsdk:"model"`
	MxagentRegistered         types.Bool                     `tfsdk:"mxagent_registered"`
	MxclusterId               types.String                   `tfsdk:"mxcluster_id"`
	MxedgeMgmt                MxedgeMgmtValue                `tfsdk:"mxedge_mgmt"`
	Name                      types.String                   `tfsdk:"name"`
	Note                      types.String                   `tfsdk:"note"`
	NtpServers                types.List                     `tfsdk:"ntp_servers"`
	OobIpConfig               OobIpConfigValue               `tfsdk:"oob_ip_config"`
	OrgId                     types.String                   `tfsdk:"org_id"`
	Proxy                     ProxyValue                     `tfsdk:"proxy"`
	Services                  types.List                     `tfsdk:"services"`
	SiteId                    types.String                   `tfsdk:"site_id"`
	TuntermDhcpdConfig        types.Map                      `tfsdk:"tunterm_dhcpd_config"`
	TuntermExtraRoutes        types.Map                      `tfsdk:"tunterm_extra_routes"`
	TuntermIgmpSnoopingConfig TuntermIgmpSnoopingConfigValue `tfsdk:"tunterm_igmp_snooping_config"`
	TuntermIpConfig           TuntermIpConfigValue           `tfsdk:"tunterm_ip_config"`
	TuntermMonitoring         types.List                     `tfsdk:"tunterm_monitoring"`
	TuntermMulticastConfig    TuntermMulticastConfigValue    `tfsdk:"tunterm_multicast_config"`
	TuntermOtherIpConfigs     types.Map                      `tfsdk:"tunterm_other_ip_configs"`
	TuntermPortConfig         TuntermPortConfigValue         `tfsdk:"tunterm_port_config"`
	TuntermRegistered         types.Bool                     `tfsdk:"tunterm_registered"`
	TuntermSwitchConfig       types.Map                      `tfsdk:"tunterm_switch_config"`
	Versions                  VersionsValue                  `tfsdk:"versions"`
}

var _ basetypes.ObjectTypable = MxedgeMgmtType{}

type MxedgeMgmtType struct {
	basetypes.ObjectType
}

func (t MxedgeMgmtType) Equal(o attr.Type) bool {
	other, ok := o.(MxedgeMgmtType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t MxedgeMgmtType) String() string {
	return "MxedgeMgmtType"
}

func (t MxedgeMgmtType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	fipsEnabledAttribute, ok := attributes["fips_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fips_enabled is missing from object`)

		return nil, diags
	}

	fipsEnabledVal, ok := fipsEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fips_enabled expected to be basetypes.BoolValue, was: %T`, fipsEnabledAttribute))
	}

	mistPasswordAttribute, ok := attributes["mist_password"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mist_password is missing from object`)

		return nil, diags
	}

	mistPasswordVal, ok := mistPasswordAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mist_password expected to be basetypes.StringValue, was: %T`, mistPasswordAttribute))
	}

	oobIpTypeAttribute, ok := attributes["oob_ip_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`oob_ip_type is missing from object`)

		return nil, diags
	}

	oobIpTypeVal, ok := oobIpTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`oob_ip_type expected to be basetypes.StringValue, was: %T`, oobIpTypeAttribute))
	}

	oobIpType6Attribute, ok := attributes["oob_ip_type6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`oob_ip_type6 is missing from object`)

		return nil, diags
	}

	oobIpType6Val, ok := oobIpType6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`oob_ip_type6 expected to be basetypes.StringValue, was: %T`, oobIpType6Attribute))
	}

	rootPasswordAttribute, ok := attributes["root_password"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`root_password is missing from object`)

		return nil, diags
	}

	rootPasswordVal, ok := rootPasswordAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`root_password expected to be basetypes.StringValue, was: %T`, rootPasswordAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return MxedgeMgmtValue{
		FipsEnabled:  fipsEnabledVal,
		MistPassword: mistPasswordVal,
		OobIpType:    oobIpTypeVal,
		OobIpType6:   oobIpType6Val,
		RootPassword: rootPasswordVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewMxedgeMgmtValueNull() MxedgeMgmtValue {
	return MxedgeMgmtValue{
		state: attr.ValueStateNull,
	}
}

func NewMxedgeMgmtValueUnknown() MxedgeMgmtValue {
	return MxedgeMgmtValue{
		state: attr.ValueStateUnknown,
	}
}

func NewMxedgeMgmtValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (MxedgeMgmtValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing MxedgeMgmtValue Attribute Value",
				"While creating a MxedgeMgmtValue value, a missing attribute value was detected. "+
					"A MxedgeMgmtValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MxedgeMgmtValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid MxedgeMgmtValue Attribute Type",
				"While creating a MxedgeMgmtValue value, an invalid attribute value was detected. "+
					"A MxedgeMgmtValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MxedgeMgmtValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("MxedgeMgmtValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra MxedgeMgmtValue Attribute Value",
				"While creating a MxedgeMgmtValue value, an extra attribute value was detected. "+
					"A MxedgeMgmtValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra MxedgeMgmtValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewMxedgeMgmtValueUnknown(), diags
	}

	fipsEnabledAttribute, ok := attributes["fips_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fips_enabled is missing from object`)

		return NewMxedgeMgmtValueUnknown(), diags
	}

	fipsEnabledVal, ok := fipsEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fips_enabled expected to be basetypes.BoolValue, was: %T`, fipsEnabledAttribute))
	}

	mistPasswordAttribute, ok := attributes["mist_password"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mist_password is missing from object`)

		return NewMxedgeMgmtValueUnknown(), diags
	}

	mistPasswordVal, ok := mistPasswordAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mist_password expected to be basetypes.StringValue, was: %T`, mistPasswordAttribute))
	}

	oobIpTypeAttribute, ok := attributes["oob_ip_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`oob_ip_type is missing from object`)

		return NewMxedgeMgmtValueUnknown(), diags
	}

	oobIpTypeVal, ok := oobIpTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`oob_ip_type expected to be basetypes.StringValue, was: %T`, oobIpTypeAttribute))
	}

	oobIpType6Attribute, ok := attributes["oob_ip_type6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`oob_ip_type6 is missing from object`)

		return NewMxedgeMgmtValueUnknown(), diags
	}

	oobIpType6Val, ok := oobIpType6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`oob_ip_type6 expected to be basetypes.StringValue, was: %T`, oobIpType6Attribute))
	}

	rootPasswordAttribute, ok := attributes["root_password"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`root_password is missing from object`)

		return NewMxedgeMgmtValueUnknown(), diags
	}

	rootPasswordVal, ok := rootPasswordAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`root_password expected to be basetypes.StringValue, was: %T`, rootPasswordAttribute))
	}

	if diags.HasError() {
		return NewMxedgeMgmtValueUnknown(), diags
	}

	return MxedgeMgmtValue{
		FipsEnabled:  fipsEnabledVal,
		MistPassword: mistPasswordVal,
		OobIpType:    oobIpTypeVal,
		OobIpType6:   oobIpType6Val,
		RootPassword: rootPasswordVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewMxedgeMgmtValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) MxedgeMgmtValue {
	object, diags := NewMxedgeMgmtValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewMxedgeMgmtValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t MxedgeMgmtType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewMxedgeMgmtValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewMxedgeMgmtValueUnknown(), nil
	}

	if in.IsNull() {
		return NewMxedgeMgmtValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewMxedgeMgmtValueMust(MxedgeMgmtValue{}.AttributeTypes(ctx), attributes), nil
}

func (t MxedgeMgmtType) ValueType(ctx context.Context) attr.Value {
	return MxedgeMgmtValue{}
}

var _ basetypes.ObjectValuable = MxedgeMgmtValue{}

type MxedgeMgmtValue struct {
	FipsEnabled  basetypes.BoolValue   `tfsdk:"fips_enabled"`
	MistPassword basetypes.StringValue `tfsdk:"mist_password"`
	OobIpType    basetypes.StringValue `tfsdk:"oob_ip_type"`
	OobIpType6   basetypes.StringValue `tfsdk:"oob_ip_type6"`
	RootPassword basetypes.StringValue `tfsdk:"root_password"`
	state        attr.ValueState
}

func (v MxedgeMgmtValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["fips_enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["mist_password"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["oob_ip_type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["oob_ip_type6"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["root_password"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.FipsEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["fips_enabled"] = val

		val, err = v.MistPassword.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mist_password"] = val

		val, err = v.OobIpType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["oob_ip_type"] = val

		val, err = v.OobIpType6.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["oob_ip_type6"] = val

		val, err = v.RootPassword.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["root_password"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v MxedgeMgmtValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v MxedgeMgmtValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v MxedgeMgmtValue) String() string {
	return "MxedgeMgmtValue"
}

func (v MxedgeMgmtValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"fips_enabled":  basetypes.BoolType{},
		"mist_password": basetypes.StringType{},
		"oob_ip_type":   basetypes.StringType{},
		"oob_ip_type6":  basetypes.StringType{},
		"root_password": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"fips_enabled":  v.FipsEnabled,
			"mist_password": v.MistPassword,
			"oob_ip_type":   v.OobIpType,
			"oob_ip_type6":  v.OobIpType6,
			"root_password": v.RootPassword,
		})

	return objVal, diags
}

func (v MxedgeMgmtValue) Equal(o attr.Value) bool {
	other, ok := o.(MxedgeMgmtValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.FipsEnabled.Equal(other.FipsEnabled) {
		return false
	}

	if !v.MistPassword.Equal(other.MistPassword) {
		return false
	}

	if !v.OobIpType.Equal(other.OobIpType) {
		return false
	}

	if !v.OobIpType6.Equal(other.OobIpType6) {
		return false
	}

	if !v.RootPassword.Equal(other.RootPassword) {
		return false
	}

	return true
}

func (v MxedgeMgmtValue) Type(ctx context.Context) attr.Type {
	return MxedgeMgmtType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v MxedgeMgmtValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"fips_enabled":  basetypes.BoolType{},
		"mist_password": basetypes.StringType{},
		"oob_ip_type":   basetypes.StringType{},
		"oob_ip_type6":  basetypes.StringType{},
		"root_password": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = OobIpConfigType{}

type OobIpConfigType struct {
	basetypes.ObjectType
}

func (t OobIpConfigType) Equal(o attr.Type) bool {
	other, ok := o.(OobIpConfigType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t OobIpConfigType) String() string {
	return "OobIpConfigType"
}

func (t OobIpConfigType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	autoconf6Attribute, ok := attributes["autoconf6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`autoconf6 is missing from object`)

		return nil, diags
	}

	autoconf6Val, ok := autoconf6Attribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`autoconf6 expected to be basetypes.BoolValue, was: %T`, autoconf6Attribute))
	}

	dhcp6Attribute, ok := attributes["dhcp6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dhcp6 is missing from object`)

		return nil, diags
	}

	dhcp6Val, ok := dhcp6Attribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dhcp6 expected to be basetypes.BoolValue, was: %T`, dhcp6Attribute))
	}

	dnsAttribute, ok := attributes["dns"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dns is missing from object`)

		return nil, diags
	}

	dnsVal, ok := dnsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dns expected to be basetypes.ListValue, was: %T`, dnsAttribute))
	}

	gatewayAttribute, ok := attributes["gateway"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gateway is missing from object`)

		return nil, diags
	}

	gatewayVal, ok := gatewayAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gateway expected to be basetypes.StringValue, was: %T`, gatewayAttribute))
	}

	gateway6Attribute, ok := attributes["gateway6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gateway6 is missing from object`)

		return nil, diags
	}

	gateway6Val, ok := gateway6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gateway6 expected to be basetypes.StringValue, was: %T`, gateway6Attribute))
	}

	ipAttribute, ok := attributes["ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip is missing from object`)

		return nil, diags
	}

	ipVal, ok := ipAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip expected to be basetypes.StringValue, was: %T`, ipAttribute))
	}

	ip6Attribute, ok := attributes["ip6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip6 is missing from object`)

		return nil, diags
	}

	ip6Val, ok := ip6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip6 expected to be basetypes.StringValue, was: %T`, ip6Attribute))
	}

	netmaskAttribute, ok := attributes["netmask"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`netmask is missing from object`)

		return nil, diags
	}

	netmaskVal, ok := netmaskAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`netmask expected to be basetypes.StringValue, was: %T`, netmaskAttribute))
	}

	netmask6Attribute, ok := attributes["netmask6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`netmask6 is missing from object`)

		return nil, diags
	}

	netmask6Val, ok := netmask6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`netmask6 expected to be basetypes.StringValue, was: %T`, netmask6Attribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	type6Attribute, ok := attributes["type6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type6 is missing from object`)

		return nil, diags
	}

	type6Val, ok := type6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type6 expected to be basetypes.StringValue, was: %T`, type6Attribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return OobIpConfigValue{
		Autoconf6:       autoconf6Val,
		Dhcp6:           dhcp6Val,
		Dns:             dnsVal,
		Gateway:         gatewayVal,
		Gateway6:        gateway6Val,
		Ip:              ipVal,
		Ip6:             ip6Val,
		Netmask:         netmaskVal,
		Netmask6:        netmask6Val,
		OobIpConfigType: typeVal,
		Type6:           type6Val,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewOobIpConfigValueNull() OobIpConfigValue {
	return OobIpConfigValue{
		state: attr.ValueStateNull,
	}
}

func NewOobIpConfigValueUnknown() OobIpConfigValue {
	return OobIpConfigValue{
		state: attr.ValueStateUnknown,
	}
}

func NewOobIpConfigValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (OobIpConfigValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing OobIpConfigValue Attribute Value",
				"While creating a OobIpConfigValue value, a missing attribute value was detected. "+
					"A OobIpConfigValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OobIpConfigValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid OobIpConfigValue Attribute Type",
				"While creating a OobIpConfigValue value, an invalid attribute value was detected. "+
					"A OobIpConfigValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OobIpConfigValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("OobIpConfigValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra OobIpConfigValue Attribute Value",
				"While creating a OobIpConfigValue value, an extra attribute value was detected. "+
					"A OobIpConfigValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra OobIpConfigValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewOobIpConfigValueUnknown(), diags
	}

	autoconf6Attribute, ok := attributes["autoconf6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`autoconf6 is missing from object`)

		return NewOobIpConfigValueUnknown(), diags
	}

	autoconf6Val, ok := autoconf6Attribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`autoconf6 expected to be basetypes.BoolValue, was: %T`, autoconf6Attribute))
	}

	dhcp6Attribute, ok := attributes["dhcp6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dhcp6 is missing from object`)

		return NewOobIpConfigValueUnknown(), diags
	}

	dhcp6Val, ok := dhcp6Attribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dhcp6 expected to be basetypes.BoolValue, was: %T`, dhcp6Attribute))
	}

	dnsAttribute, ok := attributes["dns"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dns is missing from object`)

		return NewOobIpConfigValueUnknown(), diags
	}

	dnsVal, ok := dnsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dns expected to be basetypes.ListValue, was: %T`, dnsAttribute))
	}

	gatewayAttribute, ok := attributes["gateway"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gateway is missing from object`)

		return NewOobIpConfigValueUnknown(), diags
	}

	gatewayVal, ok := gatewayAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gateway expected to be basetypes.StringValue, was: %T`, gatewayAttribute))
	}

	gateway6Attribute, ok := attributes["gateway6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gateway6 is missing from object`)

		return NewOobIpConfigValueUnknown(), diags
	}

	gateway6Val, ok := gateway6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gateway6 expected to be basetypes.StringValue, was: %T`, gateway6Attribute))
	}

	ipAttribute, ok := attributes["ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip is missing from object`)

		return NewOobIpConfigValueUnknown(), diags
	}

	ipVal, ok := ipAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip expected to be basetypes.StringValue, was: %T`, ipAttribute))
	}

	ip6Attribute, ok := attributes["ip6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip6 is missing from object`)

		return NewOobIpConfigValueUnknown(), diags
	}

	ip6Val, ok := ip6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip6 expected to be basetypes.StringValue, was: %T`, ip6Attribute))
	}

	netmaskAttribute, ok := attributes["netmask"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`netmask is missing from object`)

		return NewOobIpConfigValueUnknown(), diags
	}

	netmaskVal, ok := netmaskAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`netmask expected to be basetypes.StringValue, was: %T`, netmaskAttribute))
	}

	netmask6Attribute, ok := attributes["netmask6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`netmask6 is missing from object`)

		return NewOobIpConfigValueUnknown(), diags
	}

	netmask6Val, ok := netmask6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`netmask6 expected to be basetypes.StringValue, was: %T`, netmask6Attribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewOobIpConfigValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	type6Attribute, ok := attributes["type6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type6 is missing from object`)

		return NewOobIpConfigValueUnknown(), diags
	}

	type6Val, ok := type6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type6 expected to be basetypes.StringValue, was: %T`, type6Attribute))
	}

	if diags.HasError() {
		return NewOobIpConfigValueUnknown(), diags
	}

	return OobIpConfigValue{
		Autoconf6:       autoconf6Val,
		Dhcp6:           dhcp6Val,
		Dns:             dnsVal,
		Gateway:         gatewayVal,
		Gateway6:        gateway6Val,
		Ip:              ipVal,
		Ip6:             ip6Val,
		Netmask:         netmaskVal,
		Netmask6:        netmask6Val,
		OobIpConfigType: typeVal,
		Type6:           type6Val,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewOobIpConfigValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) OobIpConfigValue {
	object, diags := NewOobIpConfigValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewOobIpConfigValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t OobIpConfigType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewOobIpConfigValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewOobIpConfigValueUnknown(), nil
	}

	if in.IsNull() {
		return NewOobIpConfigValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewOobIpConfigValueMust(OobIpConfigValue{}.AttributeTypes(ctx), attributes), nil
}

func (t OobIpConfigType) ValueType(ctx context.Context) attr.Value {
	return OobIpConfigValue{}
}

var _ basetypes.ObjectValuable = OobIpConfigValue{}

type OobIpConfigValue struct {
	Autoconf6       basetypes.BoolValue   `tfsdk:"autoconf6"`
	Dhcp6           basetypes.BoolValue   `tfsdk:"dhcp6"`
	Dns             basetypes.ListValue   `tfsdk:"dns"`
	Gateway         basetypes.StringValue `tfsdk:"gateway"`
	Gateway6        basetypes.StringValue `tfsdk:"gateway6"`
	Ip              basetypes.StringValue `tfsdk:"ip"`
	Ip6             basetypes.StringValue `tfsdk:"ip6"`
	Netmask         basetypes.StringValue `tfsdk:"netmask"`
	Netmask6        basetypes.StringValue `tfsdk:"netmask6"`
	OobIpConfigType basetypes.StringValue `tfsdk:"type"`
	Type6           basetypes.StringValue `tfsdk:"type6"`
	state           attr.ValueState
}

func (v OobIpConfigValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 11)

	var val tftypes.Value
	var err error

	attrTypes["autoconf6"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["dhcp6"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["dns"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["gateway"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["gateway6"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ip"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ip6"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["netmask"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["netmask6"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["type6"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 11)

		val, err = v.Autoconf6.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["autoconf6"] = val

		val, err = v.Dhcp6.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dhcp6"] = val

		val, err = v.Dns.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dns"] = val

		val, err = v.Gateway.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["gateway"] = val

		val, err = v.Gateway6.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["gateway6"] = val

		val, err = v.Ip.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip"] = val

		val, err = v.Ip6.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip6"] = val

		val, err = v.Netmask.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["netmask"] = val

		val, err = v.Netmask6.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["netmask6"] = val

		val, err = v.OobIpConfigType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		val, err = v.Type6.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type6"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v OobIpConfigValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v OobIpConfigValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v OobIpConfigValue) String() string {
	return "OobIpConfigValue"
}

func (v OobIpConfigValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	dnsVal, d := types.ListValue(types.StringType, v.Dns.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"autoconf6": basetypes.BoolType{},
			"dhcp6":     basetypes.BoolType{},
			"dns": basetypes.ListType{
				ElemType: types.StringType,
			},
			"gateway":  basetypes.StringType{},
			"gateway6": basetypes.StringType{},
			"ip":       basetypes.StringType{},
			"ip6":      basetypes.StringType{},
			"netmask":  basetypes.StringType{},
			"netmask6": basetypes.StringType{},
			"type":     basetypes.StringType{},
			"type6":    basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"autoconf6": basetypes.BoolType{},
		"dhcp6":     basetypes.BoolType{},
		"dns": basetypes.ListType{
			ElemType: types.StringType,
		},
		"gateway":  basetypes.StringType{},
		"gateway6": basetypes.StringType{},
		"ip":       basetypes.StringType{},
		"ip6":      basetypes.StringType{},
		"netmask":  basetypes.StringType{},
		"netmask6": basetypes.StringType{},
		"type":     basetypes.StringType{},
		"type6":    basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"autoconf6": v.Autoconf6,
			"dhcp6":     v.Dhcp6,
			"dns":       dnsVal,
			"gateway":   v.Gateway,
			"gateway6":  v.Gateway6,
			"ip":        v.Ip,
			"ip6":       v.Ip6,
			"netmask":   v.Netmask,
			"netmask6":  v.Netmask6,
			"type":      v.OobIpConfigType,
			"type6":     v.Type6,
		})

	return objVal, diags
}

func (v OobIpConfigValue) Equal(o attr.Value) bool {
	other, ok := o.(OobIpConfigValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Autoconf6.Equal(other.Autoconf6) {
		return false
	}

	if !v.Dhcp6.Equal(other.Dhcp6) {
		return false
	}

	if !v.Dns.Equal(other.Dns) {
		return false
	}

	if !v.Gateway.Equal(other.Gateway) {
		return false
	}

	if !v.Gateway6.Equal(other.Gateway6) {
		return false
	}

	if !v.Ip.Equal(other.Ip) {
		return false
	}

	if !v.Ip6.Equal(other.Ip6) {
		return false
	}

	if !v.Netmask.Equal(other.Netmask) {
		return false
	}

	if !v.Netmask6.Equal(other.Netmask6) {
		return false
	}

	if !v.OobIpConfigType.Equal(other.OobIpConfigType) {
		return false
	}

	if !v.Type6.Equal(other.Type6) {
		return false
	}

	return true
}

func (v OobIpConfigValue) Type(ctx context.Context) attr.Type {
	return OobIpConfigType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v OobIpConfigValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"autoconf6": basetypes.BoolType{},
		"dhcp6":     basetypes.BoolType{},
		"dns": basetypes.ListType{
			ElemType: types.StringType,
		},
		"gateway":  basetypes.StringType{},
		"gateway6": basetypes.StringType{},
		"ip":       basetypes.StringType{},
		"ip6":      basetypes.StringType{},
		"netmask":  basetypes.StringType{},
		"netmask6": basetypes.StringType{},
		"type":     basetypes.StringType{},
		"type6":    basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = ProxyType{}

type ProxyType struct {
	basetypes.ObjectType
}

func (t ProxyType) Equal(o attr.Type) bool {
	other, ok := o.(ProxyType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ProxyType) String() string {
	return "ProxyType"
}

func (t ProxyType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return nil, diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ProxyValue{
		Url:   urlVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewProxyValueNull() ProxyValue {
	return ProxyValue{
		state: attr.ValueStateNull,
	}
}

func NewProxyValueUnknown() ProxyValue {
	return ProxyValue{
		state: attr.ValueStateUnknown,
	}
}

func NewProxyValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ProxyValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ProxyValue Attribute Value",
				"While creating a ProxyValue value, a missing attribute value was detected. "+
					"A ProxyValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ProxyValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ProxyValue Attribute Type",
				"While creating a ProxyValue value, an invalid attribute value was detected. "+
					"A ProxyValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ProxyValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ProxyValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ProxyValue Attribute Value",
				"While creating a ProxyValue value, an extra attribute value was detected. "+
					"A ProxyValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ProxyValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewProxyValueUnknown(), diags
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return NewProxyValueUnknown(), diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	if diags.HasError() {
		return NewProxyValueUnknown(), diags
	}

	return ProxyValue{
		Url:   urlVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewProxyValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ProxyValue {
	object, diags := NewProxyValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewProxyValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ProxyType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewProxyValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewProxyValueUnknown(), nil
	}

	if in.IsNull() {
		return NewProxyValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewProxyValueMust(ProxyValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ProxyType) ValueType(ctx context.Context) attr.Value {
	return ProxyValue{}
}

var _ basetypes.ObjectValuable = ProxyValue{}

type ProxyValue struct {
	Url   basetypes.StringValue `tfsdk:"url"`
	state attr.ValueState
}

func (v ProxyValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["url"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Url.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["url"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ProxyValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ProxyValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ProxyValue) String() string {
	return "ProxyValue"
}

func (v ProxyValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"url": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"url": v.Url,
		})

	return objVal, diags
}

func (v ProxyValue) Equal(o attr.Value) bool {
	other, ok := o.(ProxyValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Url.Equal(other.Url) {
		return false
	}

	return true
}

func (v ProxyValue) Type(ctx context.Context) attr.Type {
	return ProxyType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ProxyValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"url": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = TuntermDhcpdConfigType{}

type TuntermDhcpdConfigType struct {
	basetypes.ObjectType
}

func (t TuntermDhcpdConfigType) Equal(o attr.Type) bool {
	other, ok := o.(TuntermDhcpdConfigType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t TuntermDhcpdConfigType) String() string {
	return "TuntermDhcpdConfigType"
}

func (t TuntermDhcpdConfigType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	serversAttribute, ok := attributes["servers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`servers is missing from object`)

		return nil, diags
	}

	serversVal, ok := serversAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`servers expected to be basetypes.ListValue, was: %T`, serversAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return TuntermDhcpdConfigValue{
		Enabled:                enabledVal,
		Servers:                serversVal,
		TuntermDhcpdConfigType: typeVal,
		state:                  attr.ValueStateKnown,
	}, diags
}

func NewTuntermDhcpdConfigValueNull() TuntermDhcpdConfigValue {
	return TuntermDhcpdConfigValue{
		state: attr.ValueStateNull,
	}
}

func NewTuntermDhcpdConfigValueUnknown() TuntermDhcpdConfigValue {
	return TuntermDhcpdConfigValue{
		state: attr.ValueStateUnknown,
	}
}

func NewTuntermDhcpdConfigValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (TuntermDhcpdConfigValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing TuntermDhcpdConfigValue Attribute Value",
				"While creating a TuntermDhcpdConfigValue value, a missing attribute value was detected. "+
					"A TuntermDhcpdConfigValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TuntermDhcpdConfigValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid TuntermDhcpdConfigValue Attribute Type",
				"While creating a TuntermDhcpdConfigValue value, an invalid attribute value was detected. "+
					"A TuntermDhcpdConfigValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TuntermDhcpdConfigValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("TuntermDhcpdConfigValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra TuntermDhcpdConfigValue Attribute Value",
				"While creating a TuntermDhcpdConfigValue value, an extra attribute value was detected. "+
					"A TuntermDhcpdConfigValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra TuntermDhcpdConfigValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewTuntermDhcpdConfigValueUnknown(), diags
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewTuntermDhcpdConfigValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	serversAttribute, ok := attributes["servers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`servers is missing from object`)

		return NewTuntermDhcpdConfigValueUnknown(), diags
	}

	serversVal, ok := serversAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`servers expected to be basetypes.ListValue, was: %T`, serversAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewTuntermDhcpdConfigValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return NewTuntermDhcpdConfigValueUnknown(), diags
	}

	return TuntermDhcpdConfigValue{
		Enabled:                enabledVal,
		Servers:                serversVal,
		TuntermDhcpdConfigType: typeVal,
		state:                  attr.ValueStateKnown,
	}, diags
}

func NewTuntermDhcpdConfigValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) TuntermDhcpdConfigValue {
	object, diags := NewTuntermDhcpdConfigValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewTuntermDhcpdConfigValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t TuntermDhcpdConfigType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewTuntermDhcpdConfigValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewTuntermDhcpdConfigValueUnknown(), nil
	}

	if in.IsNull() {
		return NewTuntermDhcpdConfigValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewTuntermDhcpdConfigValueMust(TuntermDhcpdConfigValue{}.AttributeTypes(ctx), attributes), nil
}

func (t TuntermDhcpdConfigType) ValueType(ctx context.Context) attr.Value {
	return TuntermDhcpdConfigValue{}
}

var _ basetypes.ObjectValuable = TuntermDhcpdConfigValue{}

type TuntermDhcpdConfigValue struct {
	Enabled                basetypes.BoolValue   `tfsdk:"enabled"`
	Servers                basetypes.ListValue   `tfsdk:"servers"`
	TuntermDhcpdConfigType basetypes.StringValue `tfsdk:"type"`
	state                  attr.ValueState
}

func (v TuntermDhcpdConfigValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["servers"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.Servers.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["servers"] = val

		val, err = v.TuntermDhcpdConfigType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v TuntermDhcpdConfigValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v TuntermDhcpdConfigValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v TuntermDhcpdConfigValue) String() string {
	return "TuntermDhcpdConfigValue"
}

func (v TuntermDhcpdConfigValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	serversVal, d := types.ListValue(types.StringType, v.Servers.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"enabled": basetypes.BoolType{},
			"servers": basetypes.ListType{
				ElemType: types.StringType,
			},
			"type": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"enabled": basetypes.BoolType{},
		"servers": basetypes.ListType{
			ElemType: types.StringType,
		},
		"type": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"enabled": v.Enabled,
			"servers": serversVal,
			"type":    v.TuntermDhcpdConfigType,
		})

	return objVal, diags
}

func (v TuntermDhcpdConfigValue) Equal(o attr.Value) bool {
	other, ok := o.(TuntermDhcpdConfigValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.Servers.Equal(other.Servers) {
		return false
	}

	if !v.TuntermDhcpdConfigType.Equal(other.TuntermDhcpdConfigType) {
		return false
	}

	return true
}

func (v TuntermDhcpdConfigValue) Type(ctx context.Context) attr.Type {
	return TuntermDhcpdConfigType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v TuntermDhcpdConfigValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"enabled": basetypes.BoolType{},
		"servers": basetypes.ListType{
			ElemType: types.StringType,
		},
		"type": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = TuntermExtraRoutesType{}

type TuntermExtraRoutesType struct {
	basetypes.ObjectType
}

func (t TuntermExtraRoutesType) Equal(o attr.Type) bool {
	other, ok := o.(TuntermExtraRoutesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t TuntermExtraRoutesType) String() string {
	return "TuntermExtraRoutesType"
}

func (t TuntermExtraRoutesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	viaAttribute, ok := attributes["via"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`via is missing from object`)

		return nil, diags
	}

	viaVal, ok := viaAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`via expected to be basetypes.StringValue, was: %T`, viaAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return TuntermExtraRoutesValue{
		Via:   viaVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewTuntermExtraRoutesValueNull() TuntermExtraRoutesValue {
	return TuntermExtraRoutesValue{
		state: attr.ValueStateNull,
	}
}

func NewTuntermExtraRoutesValueUnknown() TuntermExtraRoutesValue {
	return TuntermExtraRoutesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewTuntermExtraRoutesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (TuntermExtraRoutesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing TuntermExtraRoutesValue Attribute Value",
				"While creating a TuntermExtraRoutesValue value, a missing attribute value was detected. "+
					"A TuntermExtraRoutesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TuntermExtraRoutesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid TuntermExtraRoutesValue Attribute Type",
				"While creating a TuntermExtraRoutesValue value, an invalid attribute value was detected. "+
					"A TuntermExtraRoutesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TuntermExtraRoutesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("TuntermExtraRoutesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra TuntermExtraRoutesValue Attribute Value",
				"While creating a TuntermExtraRoutesValue value, an extra attribute value was detected. "+
					"A TuntermExtraRoutesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra TuntermExtraRoutesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewTuntermExtraRoutesValueUnknown(), diags
	}

	viaAttribute, ok := attributes["via"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`via is missing from object`)

		return NewTuntermExtraRoutesValueUnknown(), diags
	}

	viaVal, ok := viaAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`via expected to be basetypes.StringValue, was: %T`, viaAttribute))
	}

	if diags.HasError() {
		return NewTuntermExtraRoutesValueUnknown(), diags
	}

	return TuntermExtraRoutesValue{
		Via:   viaVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewTuntermExtraRoutesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) TuntermExtraRoutesValue {
	object, diags := NewTuntermExtraRoutesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewTuntermExtraRoutesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t TuntermExtraRoutesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewTuntermExtraRoutesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewTuntermExtraRoutesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewTuntermExtraRoutesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewTuntermExtraRoutesValueMust(TuntermExtraRoutesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t TuntermExtraRoutesType) ValueType(ctx context.Context) attr.Value {
	return TuntermExtraRoutesValue{}
}

var _ basetypes.ObjectValuable = TuntermExtraRoutesValue{}

type TuntermExtraRoutesValue struct {
	Via   basetypes.StringValue `tfsdk:"via"`
	state attr.ValueState
}

func (v TuntermExtraRoutesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["via"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Via.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["via"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v TuntermExtraRoutesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v TuntermExtraRoutesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v TuntermExtraRoutesValue) String() string {
	return "TuntermExtraRoutesValue"
}

func (v TuntermExtraRoutesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"via": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"via": v.Via,
		})

	return objVal, diags
}

func (v TuntermExtraRoutesValue) Equal(o attr.Value) bool {
	other, ok := o.(TuntermExtraRoutesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Via.Equal(other.Via) {
		return false
	}

	return true
}

func (v TuntermExtraRoutesValue) Type(ctx context.Context) attr.Type {
	return TuntermExtraRoutesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v TuntermExtraRoutesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"via": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = TuntermIgmpSnoopingConfigType{}

type TuntermIgmpSnoopingConfigType struct {
	basetypes.ObjectType
}

func (t TuntermIgmpSnoopingConfigType) Equal(o attr.Type) bool {
	other, ok := o.(TuntermIgmpSnoopingConfigType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t TuntermIgmpSnoopingConfigType) String() string {
	return "TuntermIgmpSnoopingConfigType"
}

func (t TuntermIgmpSnoopingConfigType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	querierAttribute, ok := attributes["querier"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`querier is missing from object`)

		return nil, diags
	}

	querierVal, ok := querierAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`querier expected to be basetypes.ObjectValue, was: %T`, querierAttribute))
	}

	vlanIdsAttribute, ok := attributes["vlan_ids"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan_ids is missing from object`)

		return nil, diags
	}

	vlanIdsVal, ok := vlanIdsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan_ids expected to be basetypes.ListValue, was: %T`, vlanIdsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return TuntermIgmpSnoopingConfigValue{
		Enabled: enabledVal,
		Querier: querierVal,
		VlanIds: vlanIdsVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewTuntermIgmpSnoopingConfigValueNull() TuntermIgmpSnoopingConfigValue {
	return TuntermIgmpSnoopingConfigValue{
		state: attr.ValueStateNull,
	}
}

func NewTuntermIgmpSnoopingConfigValueUnknown() TuntermIgmpSnoopingConfigValue {
	return TuntermIgmpSnoopingConfigValue{
		state: attr.ValueStateUnknown,
	}
}

func NewTuntermIgmpSnoopingConfigValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (TuntermIgmpSnoopingConfigValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing TuntermIgmpSnoopingConfigValue Attribute Value",
				"While creating a TuntermIgmpSnoopingConfigValue value, a missing attribute value was detected. "+
					"A TuntermIgmpSnoopingConfigValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TuntermIgmpSnoopingConfigValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid TuntermIgmpSnoopingConfigValue Attribute Type",
				"While creating a TuntermIgmpSnoopingConfigValue value, an invalid attribute value was detected. "+
					"A TuntermIgmpSnoopingConfigValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TuntermIgmpSnoopingConfigValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("TuntermIgmpSnoopingConfigValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra TuntermIgmpSnoopingConfigValue Attribute Value",
				"While creating a TuntermIgmpSnoopingConfigValue value, an extra attribute value was detected. "+
					"A TuntermIgmpSnoopingConfigValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra TuntermIgmpSnoopingConfigValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewTuntermIgmpSnoopingConfigValueUnknown(), diags
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewTuntermIgmpSnoopingConfigValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	querierAttribute, ok := attributes["querier"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`querier is missing from object`)

		return NewTuntermIgmpSnoopingConfigValueUnknown(), diags
	}

	querierVal, ok := querierAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`querier expected to be basetypes.ObjectValue, was: %T`, querierAttribute))
	}

	vlanIdsAttribute, ok := attributes["vlan_ids"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan_ids is missing from object`)

		return NewTuntermIgmpSnoopingConfigValueUnknown(), diags
	}

	vlanIdsVal, ok := vlanIdsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan_ids expected to be basetypes.ListValue, was: %T`, vlanIdsAttribute))
	}

	if diags.HasError() {
		return NewTuntermIgmpSnoopingConfigValueUnknown(), diags
	}

	return TuntermIgmpSnoopingConfigValue{
		Enabled: enabledVal,
		Querier: querierVal,
		VlanIds: vlanIdsVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewTuntermIgmpSnoopingConfigValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) TuntermIgmpSnoopingConfigValue {
	object, diags := NewTuntermIgmpSnoopingConfigValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewTuntermIgmpSnoopingConfigValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t TuntermIgmpSnoopingConfigType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewTuntermIgmpSnoopingConfigValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewTuntermIgmpSnoopingConfigValueUnknown(), nil
	}

	if in.IsNull() {
		return NewTuntermIgmpSnoopingConfigValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewTuntermIgmpSnoopingConfigValueMust(TuntermIgmpSnoopingConfigValue{}.AttributeTypes(ctx), attributes), nil
}

func (t TuntermIgmpSnoopingConfigType) ValueType(ctx context.Context) attr.Value {
	return TuntermIgmpSnoopingConfigValue{}
}

var _ basetypes.ObjectValuable = TuntermIgmpSnoopingConfigValue{}

type TuntermIgmpSnoopingConfigValue struct {
	Enabled basetypes.BoolValue   `tfsdk:"enabled"`
	Querier basetypes.ObjectValue `tfsdk:"querier"`
	VlanIds basetypes.ListValue   `tfsdk:"vlan_ids"`
	state   attr.ValueState
}

func (v TuntermIgmpSnoopingConfigValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["querier"] = basetypes.ObjectType{
		AttrTypes: QuerierValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["vlan_ids"] = basetypes.ListType{
		ElemType: types.Int64Type,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.Querier.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["querier"] = val

		val, err = v.VlanIds.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vlan_ids"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v TuntermIgmpSnoopingConfigValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v TuntermIgmpSnoopingConfigValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v TuntermIgmpSnoopingConfigValue) String() string {
	return "TuntermIgmpSnoopingConfigValue"
}

func (v TuntermIgmpSnoopingConfigValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var querier basetypes.ObjectValue

	if v.Querier.IsNull() {
		querier = types.ObjectNull(
			QuerierValue{}.AttributeTypes(ctx),
		)
	}

	if v.Querier.IsUnknown() {
		querier = types.ObjectUnknown(
			QuerierValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Querier.IsNull() && !v.Querier.IsUnknown() {
		querier = types.ObjectValueMust(
			QuerierValue{}.AttributeTypes(ctx),
			v.Querier.Attributes(),
		)
	}

	vlanIdsVal, d := types.ListValue(types.Int64Type, v.VlanIds.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"enabled": basetypes.BoolType{},
			"querier": basetypes.ObjectType{
				AttrTypes: QuerierValue{}.AttributeTypes(ctx),
			},
			"vlan_ids": basetypes.ListType{
				ElemType: types.Int64Type,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"enabled": basetypes.BoolType{},
		"querier": basetypes.ObjectType{
			AttrTypes: QuerierValue{}.AttributeTypes(ctx),
		},
		"vlan_ids": basetypes.ListType{
			ElemType: types.Int64Type,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"enabled":  v.Enabled,
			"querier":  querier,
			"vlan_ids": vlanIdsVal,
		})

	return objVal, diags
}

func (v TuntermIgmpSnoopingConfigValue) Equal(o attr.Value) bool {
	other, ok := o.(TuntermIgmpSnoopingConfigValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.Querier.Equal(other.Querier) {
		return false
	}

	if !v.VlanIds.Equal(other.VlanIds) {
		return false
	}

	return true
}

func (v TuntermIgmpSnoopingConfigValue) Type(ctx context.Context) attr.Type {
	return TuntermIgmpSnoopingConfigType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v TuntermIgmpSnoopingConfigValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"enabled": basetypes.BoolType{},
		"querier": basetypes.ObjectType{
			AttrTypes: QuerierValue{}.AttributeTypes(ctx),
		},
		"vlan_ids": basetypes.ListType{
			ElemType: types.Int64Type,
		},
	}
}

var _ basetypes.ObjectTypable = QuerierType{}

type QuerierType struct {
	basetypes.ObjectType
}

func (t QuerierType) Equal(o attr.Type) bool {
	other, ok := o.(QuerierType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t QuerierType) String() string {
	return "QuerierType"
}

func (t QuerierType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	maxResponseTimeAttribute, ok := attributes["max_response_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_response_time is missing from object`)

		return nil, diags
	}

	maxResponseTimeVal, ok := maxResponseTimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_response_time expected to be basetypes.Int64Value, was: %T`, maxResponseTimeAttribute))
	}

	mtuAttribute, ok := attributes["mtu"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mtu is missing from object`)

		return nil, diags
	}

	mtuVal, ok := mtuAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mtu expected to be basetypes.Int64Value, was: %T`, mtuAttribute))
	}

	queryIntervalAttribute, ok := attributes["query_interval"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`query_interval is missing from object`)

		return nil, diags
	}

	queryIntervalVal, ok := queryIntervalAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`query_interval expected to be basetypes.Int64Value, was: %T`, queryIntervalAttribute))
	}

	robustnessAttribute, ok := attributes["robustness"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`robustness is missing from object`)

		return nil, diags
	}

	robustnessVal, ok := robustnessAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`robustness expected to be basetypes.Int64Value, was: %T`, robustnessAttribute))
	}

	versionAttribute, ok := attributes["version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`version is missing from object`)

		return nil, diags
	}

	versionVal, ok := versionAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`version expected to be basetypes.Int64Value, was: %T`, versionAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return QuerierValue{
		MaxResponseTime: maxResponseTimeVal,
		Mtu:             mtuVal,
		QueryInterval:   queryIntervalVal,
		Robustness:      robustnessVal,
		Version:         versionVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewQuerierValueNull() QuerierValue {
	return QuerierValue{
		state: attr.ValueStateNull,
	}
}

func NewQuerierValueUnknown() QuerierValue {
	return QuerierValue{
		state: attr.ValueStateUnknown,
	}
}

func NewQuerierValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (QuerierValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing QuerierValue Attribute Value",
				"While creating a QuerierValue value, a missing attribute value was detected. "+
					"A QuerierValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("QuerierValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid QuerierValue Attribute Type",
				"While creating a QuerierValue value, an invalid attribute value was detected. "+
					"A QuerierValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("QuerierValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("QuerierValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra QuerierValue Attribute Value",
				"While creating a QuerierValue value, an extra attribute value was detected. "+
					"A QuerierValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra QuerierValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewQuerierValueUnknown(), diags
	}

	maxResponseTimeAttribute, ok := attributes["max_response_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_response_time is missing from object`)

		return NewQuerierValueUnknown(), diags
	}

	maxResponseTimeVal, ok := maxResponseTimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_response_time expected to be basetypes.Int64Value, was: %T`, maxResponseTimeAttribute))
	}

	mtuAttribute, ok := attributes["mtu"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mtu is missing from object`)

		return NewQuerierValueUnknown(), diags
	}

	mtuVal, ok := mtuAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mtu expected to be basetypes.Int64Value, was: %T`, mtuAttribute))
	}

	queryIntervalAttribute, ok := attributes["query_interval"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`query_interval is missing from object`)

		return NewQuerierValueUnknown(), diags
	}

	queryIntervalVal, ok := queryIntervalAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`query_interval expected to be basetypes.Int64Value, was: %T`, queryIntervalAttribute))
	}

	robustnessAttribute, ok := attributes["robustness"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`robustness is missing from object`)

		return NewQuerierValueUnknown(), diags
	}

	robustnessVal, ok := robustnessAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`robustness expected to be basetypes.Int64Value, was: %T`, robustnessAttribute))
	}

	versionAttribute, ok := attributes["version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`version is missing from object`)

		return NewQuerierValueUnknown(), diags
	}

	versionVal, ok := versionAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`version expected to be basetypes.Int64Value, was: %T`, versionAttribute))
	}

	if diags.HasError() {
		return NewQuerierValueUnknown(), diags
	}

	return QuerierValue{
		MaxResponseTime: maxResponseTimeVal,
		Mtu:             mtuVal,
		QueryInterval:   queryIntervalVal,
		Robustness:      robustnessVal,
		Version:         versionVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewQuerierValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) QuerierValue {
	object, diags := NewQuerierValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewQuerierValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t QuerierType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewQuerierValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewQuerierValueUnknown(), nil
	}

	if in.IsNull() {
		return NewQuerierValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewQuerierValueMust(QuerierValue{}.AttributeTypes(ctx), attributes), nil
}

func (t QuerierType) ValueType(ctx context.Context) attr.Value {
	return QuerierValue{}
}

var _ basetypes.ObjectValuable = QuerierValue{}

type QuerierValue struct {
	MaxResponseTime basetypes.Int64Value `tfsdk:"max_response_time"`
	Mtu             basetypes.Int64Value `tfsdk:"mtu"`
	QueryInterval   basetypes.Int64Value `tfsdk:"query_interval"`
	Robustness      basetypes.Int64Value `tfsdk:"robustness"`
	Version         basetypes.Int64Value `tfsdk:"version"`
	state           attr.ValueState
}

func (v QuerierValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["max_response_time"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["mtu"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["query_interval"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["robustness"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["version"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.MaxResponseTime.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_response_time"] = val

		val, err = v.Mtu.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mtu"] = val

		val, err = v.QueryInterval.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["query_interval"] = val

		val, err = v.Robustness.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["robustness"] = val

		val, err = v.Version.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["version"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v QuerierValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v QuerierValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v QuerierValue) String() string {
	return "QuerierValue"
}

func (v QuerierValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"max_response_time": basetypes.Int64Type{},
		"mtu":               basetypes.Int64Type{},
		"query_interval":    basetypes.Int64Type{},
		"robustness":        basetypes.Int64Type{},
		"version":           basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"max_response_time": v.MaxResponseTime,
			"mtu":               v.Mtu,
			"query_interval":    v.QueryInterval,
			"robustness":        v.Robustness,
			"version":           v.Version,
		})

	return objVal, diags
}

func (v QuerierValue) Equal(o attr.Value) bool {
	other, ok := o.(QuerierValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.MaxResponseTime.Equal(other.MaxResponseTime) {
		return false
	}

	if !v.Mtu.Equal(other.Mtu) {
		return false
	}

	if !v.QueryInterval.Equal(other.QueryInterval) {
		return false
	}

	if !v.Robustness.Equal(other.Robustness) {
		return false
	}

	if !v.Version.Equal(other.Version) {
		return false
	}

	return true
}

func (v QuerierValue) Type(ctx context.Context) attr.Type {
	return QuerierType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v QuerierValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"max_response_time": basetypes.Int64Type{},
		"mtu":               basetypes.Int64Type{},
		"query_interval":    basetypes.Int64Type{},
		"robustness":        basetypes.Int64Type{},
		"version":           basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = TuntermIpConfigType{}

type TuntermIpConfigType struct {
	basetypes.ObjectType
}

func (t TuntermIpConfigType) Equal(o attr.Type) bool {
	other, ok := o.(TuntermIpConfigType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t TuntermIpConfigType) String() string {
	return "TuntermIpConfigType"
}

func (t TuntermIpConfigType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	gatewayAttribute, ok := attributes["gateway"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gateway is missing from object`)

		return nil, diags
	}

	gatewayVal, ok := gatewayAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gateway expected to be basetypes.StringValue, was: %T`, gatewayAttribute))
	}

	gateway6Attribute, ok := attributes["gateway6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gateway6 is missing from object`)

		return nil, diags
	}

	gateway6Val, ok := gateway6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gateway6 expected to be basetypes.StringValue, was: %T`, gateway6Attribute))
	}

	ipAttribute, ok := attributes["ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip is missing from object`)

		return nil, diags
	}

	ipVal, ok := ipAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip expected to be basetypes.StringValue, was: %T`, ipAttribute))
	}

	ip6Attribute, ok := attributes["ip6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip6 is missing from object`)

		return nil, diags
	}

	ip6Val, ok := ip6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip6 expected to be basetypes.StringValue, was: %T`, ip6Attribute))
	}

	netmaskAttribute, ok := attributes["netmask"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`netmask is missing from object`)

		return nil, diags
	}

	netmaskVal, ok := netmaskAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`netmask expected to be basetypes.StringValue, was: %T`, netmaskAttribute))
	}

	netmask6Attribute, ok := attributes["netmask6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`netmask6 is missing from object`)

		return nil, diags
	}

	netmask6Val, ok := netmask6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`netmask6 expected to be basetypes.StringValue, was: %T`, netmask6Attribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return TuntermIpConfigValue{
		Gateway:  gatewayVal,
		Gateway6: gateway6Val,
		Ip:       ipVal,
		Ip6:      ip6Val,
		Netmask:  netmaskVal,
		Netmask6: netmask6Val,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewTuntermIpConfigValueNull() TuntermIpConfigValue {
	return TuntermIpConfigValue{
		state: attr.ValueStateNull,
	}
}

func NewTuntermIpConfigValueUnknown() TuntermIpConfigValue {
	return TuntermIpConfigValue{
		state: attr.ValueStateUnknown,
	}
}

func NewTuntermIpConfigValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (TuntermIpConfigValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing TuntermIpConfigValue Attribute Value",
				"While creating a TuntermIpConfigValue value, a missing attribute value was detected. "+
					"A TuntermIpConfigValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TuntermIpConfigValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid TuntermIpConfigValue Attribute Type",
				"While creating a TuntermIpConfigValue value, an invalid attribute value was detected. "+
					"A TuntermIpConfigValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TuntermIpConfigValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("TuntermIpConfigValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra TuntermIpConfigValue Attribute Value",
				"While creating a TuntermIpConfigValue value, an extra attribute value was detected. "+
					"A TuntermIpConfigValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra TuntermIpConfigValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewTuntermIpConfigValueUnknown(), diags
	}

	gatewayAttribute, ok := attributes["gateway"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gateway is missing from object`)

		return NewTuntermIpConfigValueUnknown(), diags
	}

	gatewayVal, ok := gatewayAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gateway expected to be basetypes.StringValue, was: %T`, gatewayAttribute))
	}

	gateway6Attribute, ok := attributes["gateway6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gateway6 is missing from object`)

		return NewTuntermIpConfigValueUnknown(), diags
	}

	gateway6Val, ok := gateway6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gateway6 expected to be basetypes.StringValue, was: %T`, gateway6Attribute))
	}

	ipAttribute, ok := attributes["ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip is missing from object`)

		return NewTuntermIpConfigValueUnknown(), diags
	}

	ipVal, ok := ipAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip expected to be basetypes.StringValue, was: %T`, ipAttribute))
	}

	ip6Attribute, ok := attributes["ip6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip6 is missing from object`)

		return NewTuntermIpConfigValueUnknown(), diags
	}

	ip6Val, ok := ip6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip6 expected to be basetypes.StringValue, was: %T`, ip6Attribute))
	}

	netmaskAttribute, ok := attributes["netmask"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`netmask is missing from object`)

		return NewTuntermIpConfigValueUnknown(), diags
	}

	netmaskVal, ok := netmaskAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`netmask expected to be basetypes.StringValue, was: %T`, netmaskAttribute))
	}

	netmask6Attribute, ok := attributes["netmask6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`netmask6 is missing from object`)

		return NewTuntermIpConfigValueUnknown(), diags
	}

	netmask6Val, ok := netmask6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`netmask6 expected to be basetypes.StringValue, was: %T`, netmask6Attribute))
	}

	if diags.HasError() {
		return NewTuntermIpConfigValueUnknown(), diags
	}

	return TuntermIpConfigValue{
		Gateway:  gatewayVal,
		Gateway6: gateway6Val,
		Ip:       ipVal,
		Ip6:      ip6Val,
		Netmask:  netmaskVal,
		Netmask6: netmask6Val,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewTuntermIpConfigValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) TuntermIpConfigValue {
	object, diags := NewTuntermIpConfigValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewTuntermIpConfigValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t TuntermIpConfigType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewTuntermIpConfigValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewTuntermIpConfigValueUnknown(), nil
	}

	if in.IsNull() {
		return NewTuntermIpConfigValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewTuntermIpConfigValueMust(TuntermIpConfigValue{}.AttributeTypes(ctx), attributes), nil
}

func (t TuntermIpConfigType) ValueType(ctx context.Context) attr.Value {
	return TuntermIpConfigValue{}
}

var _ basetypes.ObjectValuable = TuntermIpConfigValue{}

type TuntermIpConfigValue struct {
	Gateway  basetypes.StringValue `tfsdk:"gateway"`
	Gateway6 basetypes.StringValue `tfsdk:"gateway6"`
	Ip       basetypes.StringValue `tfsdk:"ip"`
	Ip6      basetypes.StringValue `tfsdk:"ip6"`
	Netmask  basetypes.StringValue `tfsdk:"netmask"`
	Netmask6 basetypes.StringValue `tfsdk:"netmask6"`
	state    attr.ValueState
}

func (v TuntermIpConfigValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 6)

	var val tftypes.Value
	var err error

	attrTypes["gateway"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["gateway6"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ip"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ip6"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["netmask"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["netmask6"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 6)

		val, err = v.Gateway.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["gateway"] = val

		val, err = v.Gateway6.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["gateway6"] = val

		val, err = v.Ip.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip"] = val

		val, err = v.Ip6.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip6"] = val

		val, err = v.Netmask.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["netmask"] = val

		val, err = v.Netmask6.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["netmask6"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v TuntermIpConfigValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v TuntermIpConfigValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v TuntermIpConfigValue) String() string {
	return "TuntermIpConfigValue"
}

func (v TuntermIpConfigValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"gateway":  basetypes.StringType{},
		"gateway6": basetypes.StringType{},
		"ip":       basetypes.StringType{},
		"ip6":      basetypes.StringType{},
		"netmask":  basetypes.StringType{},
		"netmask6": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"gateway":  v.Gateway,
			"gateway6": v.Gateway6,
			"ip":       v.Ip,
			"ip6":      v.Ip6,
			"netmask":  v.Netmask,
			"netmask6": v.Netmask6,
		})

	return objVal, diags
}

func (v TuntermIpConfigValue) Equal(o attr.Value) bool {
	other, ok := o.(TuntermIpConfigValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Gateway.Equal(other.Gateway) {
		return false
	}

	if !v.Gateway6.Equal(other.Gateway6) {
		return false
	}

	if !v.Ip.Equal(other.Ip) {
		return false
	}

	if !v.Ip6.Equal(other.Ip6) {
		return false
	}

	if !v.Netmask.Equal(other.Netmask) {
		return false
	}

	if !v.Netmask6.Equal(other.Netmask6) {
		return false
	}

	return true
}

func (v TuntermIpConfigValue) Type(ctx context.Context) attr.Type {
	return TuntermIpConfigType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v TuntermIpConfigValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"gateway":  basetypes.StringType{},
		"gateway6": basetypes.StringType{},
		"ip":       basetypes.StringType{},
		"ip6":      basetypes.StringType{},
		"netmask":  basetypes.StringType{},
		"netmask6": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = TuntermMulticastConfigType{}

type TuntermMulticastConfigType struct {
	basetypes.ObjectType
}

func (t TuntermMulticastConfigType) Equal(o attr.Type) bool {
	other, ok := o.(TuntermMulticastConfigType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t TuntermMulticastConfigType) String() string {
	return "TuntermMulticastConfigType"
}

func (t TuntermMulticastConfigType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	mdnsAttribute, ok := attributes["mdns"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mdns is missing from object`)

		return nil, diags
	}

	mdnsVal, ok := mdnsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mdns expected to be basetypes.ObjectValue, was: %T`, mdnsAttribute))
	}

	ssdpAttribute, ok := attributes["ssdp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ssdp is missing from object`)

		return nil, diags
	}

	ssdpVal, ok := ssdpAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ssdp expected to be basetypes.ObjectValue, was: %T`, ssdpAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return TuntermMulticastConfigValue{
		Mdns:  mdnsVal,
		Ssdp:  ssdpVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewTuntermMulticastConfigValueNull() TuntermMulticastConfigValue {
	return TuntermMulticastConfigValue{
		state: attr.ValueStateNull,
	}
}

func NewTuntermMulticastConfigValueUnknown() TuntermMulticastConfigValue {
	return TuntermMulticastConfigValue{
		state: attr.ValueStateUnknown,
	}
}

func NewTuntermMulticastConfigValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (TuntermMulticastConfigValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing TuntermMulticastConfigValue Attribute Value",
				"While creating a TuntermMulticastConfigValue value, a missing attribute value was detected. "+
					"A TuntermMulticastConfigValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TuntermMulticastConfigValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid TuntermMulticastConfigValue Attribute Type",
				"While creating a TuntermMulticastConfigValue value, an invalid attribute value was detected. "+
					"A TuntermMulticastConfigValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TuntermMulticastConfigValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("TuntermMulticastConfigValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra TuntermMulticastConfigValue Attribute Value",
				"While creating a TuntermMulticastConfigValue value, an extra attribute value was detected. "+
					"A TuntermMulticastConfigValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra TuntermMulticastConfigValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewTuntermMulticastConfigValueUnknown(), diags
	}

	mdnsAttribute, ok := attributes["mdns"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mdns is missing from object`)

		return NewTuntermMulticastConfigValueUnknown(), diags
	}

	mdnsVal, ok := mdnsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mdns expected to be basetypes.ObjectValue, was: %T`, mdnsAttribute))
	}

	ssdpAttribute, ok := attributes["ssdp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ssdp is missing from object`)

		return NewTuntermMulticastConfigValueUnknown(), diags
	}

	ssdpVal, ok := ssdpAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ssdp expected to be basetypes.ObjectValue, was: %T`, ssdpAttribute))
	}

	if diags.HasError() {
		return NewTuntermMulticastConfigValueUnknown(), diags
	}

	return TuntermMulticastConfigValue{
		Mdns:  mdnsVal,
		Ssdp:  ssdpVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewTuntermMulticastConfigValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) TuntermMulticastConfigValue {
	object, diags := NewTuntermMulticastConfigValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewTuntermMulticastConfigValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t TuntermMulticastConfigType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewTuntermMulticastConfigValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewTuntermMulticastConfigValueUnknown(), nil
	}

	if in.IsNull() {
		return NewTuntermMulticastConfigValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewTuntermMulticastConfigValueMust(TuntermMulticastConfigValue{}.AttributeTypes(ctx), attributes), nil
}

func (t TuntermMulticastConfigType) ValueType(ctx context.Context) attr.Value {
	return TuntermMulticastConfigValue{}
}

var _ basetypes.ObjectValuable = TuntermMulticastConfigValue{}

type TuntermMulticastConfigValue struct {
	Mdns  basetypes.ObjectValue `tfsdk:"mdns"`
	Ssdp  basetypes.ObjectValue `tfsdk:"ssdp"`
	state attr.ValueState
}

func (v TuntermMulticastConfigValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["mdns"] = basetypes.ObjectType{
		AttrTypes: MdnsValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["ssdp"] = basetypes.ObjectType{
		AttrTypes: SsdpValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Mdns.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mdns"] = val

		val, err = v.Ssdp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ssdp"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v TuntermMulticastConfigValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v TuntermMulticastConfigValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v TuntermMulticastConfigValue) String() string {
	return "TuntermMulticastConfigValue"
}

func (v TuntermMulticastConfigValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var mdns basetypes.ObjectValue

	if v.Mdns.IsNull() {
		mdns = types.ObjectNull(
			MdnsValue{}.AttributeTypes(ctx),
		)
	}

	if v.Mdns.IsUnknown() {
		mdns = types.ObjectUnknown(
			MdnsValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Mdns.IsNull() && !v.Mdns.IsUnknown() {
		mdns = types.ObjectValueMust(
			MdnsValue{}.AttributeTypes(ctx),
			v.Mdns.Attributes(),
		)
	}

	var ssdp basetypes.ObjectValue

	if v.Ssdp.IsNull() {
		ssdp = types.ObjectNull(
			SsdpValue{}.AttributeTypes(ctx),
		)
	}

	if v.Ssdp.IsUnknown() {
		ssdp = types.ObjectUnknown(
			SsdpValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Ssdp.IsNull() && !v.Ssdp.IsUnknown() {
		ssdp = types.ObjectValueMust(
			SsdpValue{}.AttributeTypes(ctx),
			v.Ssdp.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"mdns": basetypes.ObjectType{
			AttrTypes: MdnsValue{}.AttributeTypes(ctx),
		},
		"ssdp": basetypes.ObjectType{
			AttrTypes: SsdpValue{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"mdns": mdns,
			"ssdp": ssdp,
		})

	return objVal, diags
}

func (v TuntermMulticastConfigValue) Equal(o attr.Value) bool {
	other, ok := o.(TuntermMulticastConfigValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Mdns.Equal(other.Mdns) {
		return false
	}

	if !v.Ssdp.Equal(other.Ssdp) {
		return false
	}

	return true
}

func (v TuntermMulticastConfigValue) Type(ctx context.Context) attr.Type {
	return TuntermMulticastConfigType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v TuntermMulticastConfigValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"mdns": basetypes.ObjectType{
			AttrTypes: MdnsValue{}.AttributeTypes(ctx),
		},
		"ssdp": basetypes.ObjectType{
			AttrTypes: SsdpValue{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = MdnsType{}

type MdnsType struct {
	basetypes.ObjectType
}

func (t MdnsType) Equal(o attr.Type) bool {
	other, ok := o.(MdnsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t MdnsType) String() string {
	return "MdnsType"
}

func (t MdnsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	vlanIdsAttribute, ok := attributes["vlan_ids"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan_ids is missing from object`)

		return nil, diags
	}

	vlanIdsVal, ok := vlanIdsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan_ids expected to be basetypes.ListValue, was: %T`, vlanIdsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return MdnsValue{
		Enabled: enabledVal,
		VlanIds: vlanIdsVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewMdnsValueNull() MdnsValue {
	return MdnsValue{
		state: attr.ValueStateNull,
	}
}

func NewMdnsValueUnknown() MdnsValue {
	return MdnsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewMdnsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (MdnsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing MdnsValue Attribute Value",
				"While creating a MdnsValue value, a missing attribute value was detected. "+
					"A MdnsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MdnsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid MdnsValue Attribute Type",
				"While creating a MdnsValue value, an invalid attribute value was detected. "+
					"A MdnsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MdnsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("MdnsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra MdnsValue Attribute Value",
				"While creating a MdnsValue value, an extra attribute value was detected. "+
					"A MdnsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra MdnsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewMdnsValueUnknown(), diags
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewMdnsValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	vlanIdsAttribute, ok := attributes["vlan_ids"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan_ids is missing from object`)

		return NewMdnsValueUnknown(), diags
	}

	vlanIdsVal, ok := vlanIdsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan_ids expected to be basetypes.ListValue, was: %T`, vlanIdsAttribute))
	}

	if diags.HasError() {
		return NewMdnsValueUnknown(), diags
	}

	return MdnsValue{
		Enabled: enabledVal,
		VlanIds: vlanIdsVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewMdnsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) MdnsValue {
	object, diags := NewMdnsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewMdnsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t MdnsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewMdnsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewMdnsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewMdnsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewMdnsValueMust(MdnsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t MdnsType) ValueType(ctx context.Context) attr.Value {
	return MdnsValue{}
}

var _ basetypes.ObjectValuable = MdnsValue{}

type MdnsValue struct {
	Enabled basetypes.BoolValue `tfsdk:"enabled"`
	VlanIds basetypes.ListValue `tfsdk:"vlan_ids"`
	state   attr.ValueState
}

func (v MdnsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["vlan_ids"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.VlanIds.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vlan_ids"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v MdnsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v MdnsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v MdnsValue) String() string {
	return "MdnsValue"
}

func (v MdnsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	vlanIdsVal, d := types.ListValue(types.StringType, v.VlanIds.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"enabled": basetypes.BoolType{},
			"vlan_ids": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"enabled": basetypes.BoolType{},
		"vlan_ids": basetypes.ListType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"enabled":  v.Enabled,
			"vlan_ids": vlanIdsVal,
		})

	return objVal, diags
}

func (v MdnsValue) Equal(o attr.Value) bool {
	other, ok := o.(MdnsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.VlanIds.Equal(other.VlanIds) {
		return false
	}

	return true
}

func (v MdnsValue) Type(ctx context.Context) attr.Type {
	return MdnsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v MdnsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"enabled": basetypes.BoolType{},
		"vlan_ids": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = SsdpType{}

type SsdpType struct {
	basetypes.ObjectType
}

func (t SsdpType) Equal(o attr.Type) bool {
	other, ok := o.(SsdpType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SsdpType) String() string {
	return "SsdpType"
}

func (t SsdpType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	vlanIdsAttribute, ok := attributes["vlan_ids"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan_ids is missing from object`)

		return nil, diags
	}

	vlanIdsVal, ok := vlanIdsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan_ids expected to be basetypes.ListValue, was: %T`, vlanIdsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SsdpValue{
		Enabled: enabledVal,
		VlanIds: vlanIdsVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewSsdpValueNull() SsdpValue {
	return SsdpValue{
		state: attr.ValueStateNull,
	}
}

func NewSsdpValueUnknown() SsdpValue {
	return SsdpValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSsdpValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SsdpValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SsdpValue Attribute Value",
				"While creating a SsdpValue value, a missing attribute value was detected. "+
					"A SsdpValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SsdpValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SsdpValue Attribute Type",
				"While creating a SsdpValue value, an invalid attribute value was detected. "+
					"A SsdpValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SsdpValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SsdpValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SsdpValue Attribute Value",
				"While creating a SsdpValue value, an extra attribute value was detected. "+
					"A SsdpValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SsdpValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSsdpValueUnknown(), diags
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewSsdpValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	vlanIdsAttribute, ok := attributes["vlan_ids"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan_ids is missing from object`)

		return NewSsdpValueUnknown(), diags
	}

	vlanIdsVal, ok := vlanIdsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan_ids expected to be basetypes.ListValue, was: %T`, vlanIdsAttribute))
	}

	if diags.HasError() {
		return NewSsdpValueUnknown(), diags
	}

	return SsdpValue{
		Enabled: enabledVal,
		VlanIds: vlanIdsVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewSsdpValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SsdpValue {
	object, diags := NewSsdpValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSsdpValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SsdpType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSsdpValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSsdpValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSsdpValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSsdpValueMust(SsdpValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SsdpType) ValueType(ctx context.Context) attr.Value {
	return SsdpValue{}
}

var _ basetypes.ObjectValuable = SsdpValue{}

type SsdpValue struct {
	Enabled basetypes.BoolValue `tfsdk:"enabled"`
	VlanIds basetypes.ListValue `tfsdk:"vlan_ids"`
	state   attr.ValueState
}

func (v SsdpValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["vlan_ids"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.VlanIds.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vlan_ids"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SsdpValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SsdpValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SsdpValue) String() string {
	return "SsdpValue"
}

func (v SsdpValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	vlanIdsVal, d := types.ListValue(types.StringType, v.VlanIds.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"enabled": basetypes.BoolType{},
			"vlan_ids": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"enabled": basetypes.BoolType{},
		"vlan_ids": basetypes.ListType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"enabled":  v.Enabled,
			"vlan_ids": vlanIdsVal,
		})

	return objVal, diags
}

func (v SsdpValue) Equal(o attr.Value) bool {
	other, ok := o.(SsdpValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.VlanIds.Equal(other.VlanIds) {
		return false
	}

	return true
}

func (v SsdpValue) Type(ctx context.Context) attr.Type {
	return SsdpType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SsdpValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"enabled": basetypes.BoolType{},
		"vlan_ids": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = TuntermOtherIpConfigsType{}

type TuntermOtherIpConfigsType struct {
	basetypes.ObjectType
}

func (t TuntermOtherIpConfigsType) Equal(o attr.Type) bool {
	other, ok := o.(TuntermOtherIpConfigsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t TuntermOtherIpConfigsType) String() string {
	return "TuntermOtherIpConfigsType"
}

func (t TuntermOtherIpConfigsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	ipAttribute, ok := attributes["ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip is missing from object`)

		return nil, diags
	}

	ipVal, ok := ipAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip expected to be basetypes.StringValue, was: %T`, ipAttribute))
	}

	netmaskAttribute, ok := attributes["netmask"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`netmask is missing from object`)

		return nil, diags
	}

	netmaskVal, ok := netmaskAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`netmask expected to be basetypes.StringValue, was: %T`, netmaskAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return TuntermOtherIpConfigsValue{
		Ip:      ipVal,
		Netmask: netmaskVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewTuntermOtherIpConfigsValueNull() TuntermOtherIpConfigsValue {
	return TuntermOtherIpConfigsValue{
		state: attr.ValueStateNull,
	}
}

func NewTuntermOtherIpConfigsValueUnknown() TuntermOtherIpConfigsValue {
	return TuntermOtherIpConfigsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewTuntermOtherIpConfigsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (TuntermOtherIpConfigsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing TuntermOtherIpConfigsValue Attribute Value",
				"While creating a TuntermOtherIpConfigsValue value, a missing attribute value was detected. "+
					"A TuntermOtherIpConfigsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TuntermOtherIpConfigsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid TuntermOtherIpConfigsValue Attribute Type",
				"While creating a TuntermOtherIpConfigsValue value, an invalid attribute value was detected. "+
					"A TuntermOtherIpConfigsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TuntermOtherIpConfigsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("TuntermOtherIpConfigsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra TuntermOtherIpConfigsValue Attribute Value",
				"While creating a TuntermOtherIpConfigsValue value, an extra attribute value was detected. "+
					"A TuntermOtherIpConfigsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra TuntermOtherIpConfigsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewTuntermOtherIpConfigsValueUnknown(), diags
	}

	ipAttribute, ok := attributes["ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip is missing from object`)

		return NewTuntermOtherIpConfigsValueUnknown(), diags
	}

	ipVal, ok := ipAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip expected to be basetypes.StringValue, was: %T`, ipAttribute))
	}

	netmaskAttribute, ok := attributes["netmask"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`netmask is missing from object`)

		return NewTuntermOtherIpConfigsValueUnknown(), diags
	}

	netmaskVal, ok := netmaskAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`netmask expected to be basetypes.StringValue, was: %T`, netmaskAttribute))
	}

	if diags.HasError() {
		return NewTuntermOtherIpConfigsValueUnknown(), diags
	}

	return TuntermOtherIpConfigsValue{
		Ip:      ipVal,
		Netmask: netmaskVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewTuntermOtherIpConfigsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) TuntermOtherIpConfigsValue {
	object, diags := NewTuntermOtherIpConfigsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewTuntermOtherIpConfigsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t TuntermOtherIpConfigsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewTuntermOtherIpConfigsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewTuntermOtherIpConfigsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewTuntermOtherIpConfigsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewTuntermOtherIpConfigsValueMust(TuntermOtherIpConfigsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t TuntermOtherIpConfigsType) ValueType(ctx context.Context) attr.Value {
	return TuntermOtherIpConfigsValue{}
}

var _ basetypes.ObjectValuable = TuntermOtherIpConfigsValue{}

type TuntermOtherIpConfigsValue struct {
	Ip      basetypes.StringValue `tfsdk:"ip"`
	Netmask basetypes.StringValue `tfsdk:"netmask"`
	state   attr.ValueState
}

func (v TuntermOtherIpConfigsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["ip"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["netmask"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Ip.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip"] = val

		val, err = v.Netmask.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["netmask"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v TuntermOtherIpConfigsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v TuntermOtherIpConfigsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v TuntermOtherIpConfigsValue) String() string {
	return "TuntermOtherIpConfigsValue"
}

func (v TuntermOtherIpConfigsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"ip":      basetypes.StringType{},
		"netmask": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"ip":      v.Ip,
			"netmask": v.Netmask,
		})

	return objVal, diags
}

func (v TuntermOtherIpConfigsValue) Equal(o attr.Value) bool {
	other, ok := o.(TuntermOtherIpConfigsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Ip.Equal(other.Ip) {
		return false
	}

	if !v.Netmask.Equal(other.Netmask) {
		return false
	}

	return true
}

func (v TuntermOtherIpConfigsValue) Type(ctx context.Context) attr.Type {
	return TuntermOtherIpConfigsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v TuntermOtherIpConfigsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"ip":      basetypes.StringType{},
		"netmask": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = TuntermPortConfigType{}

type TuntermPortConfigType struct {
	basetypes.ObjectType
}

func (t TuntermPortConfigType) Equal(o attr.Type) bool {
	other, ok := o.(TuntermPortConfigType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t TuntermPortConfigType) String() string {
	return "TuntermPortConfigType"
}

func (t TuntermPortConfigType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	downstreamPortsAttribute, ok := attributes["downstream_ports"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`downstream_ports is missing from object`)

		return nil, diags
	}

	downstreamPortsVal, ok := downstreamPortsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`downstream_ports expected to be basetypes.ListValue, was: %T`, downstreamPortsAttribute))
	}

	separateUpstreamDownstreamAttribute, ok := attributes["separate_upstream_downstream"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`separate_upstream_downstream is missing from object`)

		return nil, diags
	}

	separateUpstreamDownstreamVal, ok := separateUpstreamDownstreamAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`separate_upstream_downstream expected to be basetypes.BoolValue, was: %T`, separateUpstreamDownstreamAttribute))
	}

	upstreamPortVlanIdAttribute, ok := attributes["upstream_port_vlan_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`upstream_port_vlan_id is missing from object`)

		return nil, diags
	}

	upstreamPortVlanIdVal, ok := upstreamPortVlanIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`upstream_port_vlan_id expected to be basetypes.Int64Value, was: %T`, upstreamPortVlanIdAttribute))
	}

	upstreamPortsAttribute, ok := attributes["upstream_ports"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`upstream_ports is missing from object`)

		return nil, diags
	}

	upstreamPortsVal, ok := upstreamPortsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`upstream_ports expected to be basetypes.ListValue, was: %T`, upstreamPortsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return TuntermPortConfigValue{
		DownstreamPorts:            downstreamPortsVal,
		SeparateUpstreamDownstream: separateUpstreamDownstreamVal,
		UpstreamPortVlanId:         upstreamPortVlanIdVal,
		UpstreamPorts:              upstreamPortsVal,
		state:                      attr.ValueStateKnown,
	}, diags
}

func NewTuntermPortConfigValueNull() TuntermPortConfigValue {
	return TuntermPortConfigValue{
		state: attr.ValueStateNull,
	}
}

func NewTuntermPortConfigValueUnknown() TuntermPortConfigValue {
	return TuntermPortConfigValue{
		state: attr.ValueStateUnknown,
	}
}

func NewTuntermPortConfigValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (TuntermPortConfigValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing TuntermPortConfigValue Attribute Value",
				"While creating a TuntermPortConfigValue value, a missing attribute value was detected. "+
					"A TuntermPortConfigValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TuntermPortConfigValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid TuntermPortConfigValue Attribute Type",
				"While creating a TuntermPortConfigValue value, an invalid attribute value was detected. "+
					"A TuntermPortConfigValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TuntermPortConfigValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("TuntermPortConfigValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra TuntermPortConfigValue Attribute Value",
				"While creating a TuntermPortConfigValue value, an extra attribute value was detected. "+
					"A TuntermPortConfigValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra TuntermPortConfigValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewTuntermPortConfigValueUnknown(), diags
	}

	downstreamPortsAttribute, ok := attributes["downstream_ports"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`downstream_ports is missing from object`)

		return NewTuntermPortConfigValueUnknown(), diags
	}

	downstreamPortsVal, ok := downstreamPortsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`downstream_ports expected to be basetypes.ListValue, was: %T`, downstreamPortsAttribute))
	}

	separateUpstreamDownstreamAttribute, ok := attributes["separate_upstream_downstream"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`separate_upstream_downstream is missing from object`)

		return NewTuntermPortConfigValueUnknown(), diags
	}

	separateUpstreamDownstreamVal, ok := separateUpstreamDownstreamAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`separate_upstream_downstream expected to be basetypes.BoolValue, was: %T`, separateUpstreamDownstreamAttribute))
	}

	upstreamPortVlanIdAttribute, ok := attributes["upstream_port_vlan_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`upstream_port_vlan_id is missing from object`)

		return NewTuntermPortConfigValueUnknown(), diags
	}

	upstreamPortVlanIdVal, ok := upstreamPortVlanIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`upstream_port_vlan_id expected to be basetypes.Int64Value, was: %T`, upstreamPortVlanIdAttribute))
	}

	upstreamPortsAttribute, ok := attributes["upstream_ports"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`upstream_ports is missing from object`)

		return NewTuntermPortConfigValueUnknown(), diags
	}

	upstreamPortsVal, ok := upstreamPortsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`upstream_ports expected to be basetypes.ListValue, was: %T`, upstreamPortsAttribute))
	}

	if diags.HasError() {
		return NewTuntermPortConfigValueUnknown(), diags
	}

	return TuntermPortConfigValue{
		DownstreamPorts:            downstreamPortsVal,
		SeparateUpstreamDownstream: separateUpstreamDownstreamVal,
		UpstreamPortVlanId:         upstreamPortVlanIdVal,
		UpstreamPorts:              upstreamPortsVal,
		state:                      attr.ValueStateKnown,
	}, diags
}

func NewTuntermPortConfigValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) TuntermPortConfigValue {
	object, diags := NewTuntermPortConfigValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewTuntermPortConfigValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t TuntermPortConfigType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewTuntermPortConfigValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewTuntermPortConfigValueUnknown(), nil
	}

	if in.IsNull() {
		return NewTuntermPortConfigValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewTuntermPortConfigValueMust(TuntermPortConfigValue{}.AttributeTypes(ctx), attributes), nil
}

func (t TuntermPortConfigType) ValueType(ctx context.Context) attr.Value {
	return TuntermPortConfigValue{}
}

var _ basetypes.ObjectValuable = TuntermPortConfigValue{}

type TuntermPortConfigValue struct {
	DownstreamPorts            basetypes.ListValue  `tfsdk:"downstream_ports"`
	SeparateUpstreamDownstream basetypes.BoolValue  `tfsdk:"separate_upstream_downstream"`
	UpstreamPortVlanId         basetypes.Int64Value `tfsdk:"upstream_port_vlan_id"`
	UpstreamPorts              basetypes.ListValue  `tfsdk:"upstream_ports"`
	state                      attr.ValueState
}

func (v TuntermPortConfigValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["downstream_ports"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["separate_upstream_downstream"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["upstream_port_vlan_id"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["upstream_ports"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.DownstreamPorts.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["downstream_ports"] = val

		val, err = v.SeparateUpstreamDownstream.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["separate_upstream_downstream"] = val

		val, err = v.UpstreamPortVlanId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["upstream_port_vlan_id"] = val

		val, err = v.UpstreamPorts.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["upstream_ports"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v TuntermPortConfigValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v TuntermPortConfigValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v TuntermPortConfigValue) String() string {
	return "TuntermPortConfigValue"
}

func (v TuntermPortConfigValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	downstreamPortsVal, d := types.ListValue(types.StringType, v.DownstreamPorts.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"downstream_ports": basetypes.ListType{
				ElemType: types.StringType,
			},
			"separate_upstream_downstream": basetypes.BoolType{},
			"upstream_port_vlan_id":        basetypes.Int64Type{},
			"upstream_ports": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	upstreamPortsVal, d := types.ListValue(types.StringType, v.UpstreamPorts.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"downstream_ports": basetypes.ListType{
				ElemType: types.StringType,
			},
			"separate_upstream_downstream": basetypes.BoolType{},
			"upstream_port_vlan_id":        basetypes.Int64Type{},
			"upstream_ports": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"downstream_ports": basetypes.ListType{
			ElemType: types.StringType,
		},
		"separate_upstream_downstream": basetypes.BoolType{},
		"upstream_port_vlan_id":        basetypes.Int64Type{},
		"upstream_ports": basetypes.ListType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"downstream_ports":             downstreamPortsVal,
			"separate_upstream_downstream": v.SeparateUpstreamDownstream,
			"upstream_port_vlan_id":        v.UpstreamPortVlanId,
			"upstream_ports":               upstreamPortsVal,
		})

	return objVal, diags
}

func (v TuntermPortConfigValue) Equal(o attr.Value) bool {
	other, ok := o.(TuntermPortConfigValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.DownstreamPorts.Equal(other.DownstreamPorts) {
		return false
	}

	if !v.SeparateUpstreamDownstream.Equal(other.SeparateUpstreamDownstream) {
		return false
	}

	if !v.UpstreamPortVlanId.Equal(other.UpstreamPortVlanId) {
		return false
	}

	if !v.UpstreamPorts.Equal(other.UpstreamPorts) {
		return false
	}

	return true
}

func (v TuntermPortConfigValue) Type(ctx context.Context) attr.Type {
	return TuntermPortConfigType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v TuntermPortConfigValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"downstream_ports": basetypes.ListType{
			ElemType: types.StringType,
		},
		"separate_upstream_downstream": basetypes.BoolType{},
		"upstream_port_vlan_id":        basetypes.Int64Type{},
		"upstream_ports": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = TuntermSwitchConfigType{}

type TuntermSwitchConfigType struct {
	basetypes.ObjectType
}

func (t TuntermSwitchConfigType) Equal(o attr.Type) bool {
	other, ok := o.(TuntermSwitchConfigType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t TuntermSwitchConfigType) String() string {
	return "TuntermSwitchConfigType"
}

func (t TuntermSwitchConfigType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	portVlanIdAttribute, ok := attributes["port_vlan_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_vlan_id is missing from object`)

		return nil, diags
	}

	portVlanIdVal, ok := portVlanIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_vlan_id expected to be basetypes.Int64Value, was: %T`, portVlanIdAttribute))
	}

	vlanIdsAttribute, ok := attributes["vlan_ids"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan_ids is missing from object`)

		return nil, diags
	}

	vlanIdsVal, ok := vlanIdsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan_ids expected to be basetypes.ListValue, was: %T`, vlanIdsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return TuntermSwitchConfigValue{
		PortVlanId: portVlanIdVal,
		VlanIds:    vlanIdsVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewTuntermSwitchConfigValueNull() TuntermSwitchConfigValue {
	return TuntermSwitchConfigValue{
		state: attr.ValueStateNull,
	}
}

func NewTuntermSwitchConfigValueUnknown() TuntermSwitchConfigValue {
	return TuntermSwitchConfigValue{
		state: attr.ValueStateUnknown,
	}
}

func NewTuntermSwitchConfigValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (TuntermSwitchConfigValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing TuntermSwitchConfigValue Attribute Value",
				"While creating a TuntermSwitchConfigValue value, a missing attribute value was detected. "+
					"A TuntermSwitchConfigValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TuntermSwitchConfigValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid TuntermSwitchConfigValue Attribute Type",
				"While creating a TuntermSwitchConfigValue value, an invalid attribute value was detected. "+
					"A TuntermSwitchConfigValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TuntermSwitchConfigValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("TuntermSwitchConfigValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra TuntermSwitchConfigValue Attribute Value",
				"While creating a TuntermSwitchConfigValue value, an extra attribute value was detected. "+
					"A TuntermSwitchConfigValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra TuntermSwitchConfigValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewTuntermSwitchConfigValueUnknown(), diags
	}

	portVlanIdAttribute, ok := attributes["port_vlan_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_vlan_id is missing from object`)

		return NewTuntermSwitchConfigValueUnknown(), diags
	}

	portVlanIdVal, ok := portVlanIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_vlan_id expected to be basetypes.Int64Value, was: %T`, portVlanIdAttribute))
	}

	vlanIdsAttribute, ok := attributes["vlan_ids"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan_ids is missing from object`)

		return NewTuntermSwitchConfigValueUnknown(), diags
	}

	vlanIdsVal, ok := vlanIdsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan_ids expected to be basetypes.ListValue, was: %T`, vlanIdsAttribute))
	}

	if diags.HasError() {
		return NewTuntermSwitchConfigValueUnknown(), diags
	}

	return TuntermSwitchConfigValue{
		PortVlanId: portVlanIdVal,
		VlanIds:    vlanIdsVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewTuntermSwitchConfigValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) TuntermSwitchConfigValue {
	object, diags := NewTuntermSwitchConfigValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewTuntermSwitchConfigValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t TuntermSwitchConfigType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewTuntermSwitchConfigValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewTuntermSwitchConfigValueUnknown(), nil
	}

	if in.IsNull() {
		return NewTuntermSwitchConfigValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewTuntermSwitchConfigValueMust(TuntermSwitchConfigValue{}.AttributeTypes(ctx), attributes), nil
}

func (t TuntermSwitchConfigType) ValueType(ctx context.Context) attr.Value {
	return TuntermSwitchConfigValue{}
}

var _ basetypes.ObjectValuable = TuntermSwitchConfigValue{}

type TuntermSwitchConfigValue struct {
	PortVlanId basetypes.Int64Value `tfsdk:"port_vlan_id"`
	VlanIds    basetypes.ListValue  `tfsdk:"vlan_ids"`
	state      attr.ValueState
}

func (v TuntermSwitchConfigValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["port_vlan_id"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["vlan_ids"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.PortVlanId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port_vlan_id"] = val

		val, err = v.VlanIds.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vlan_ids"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v TuntermSwitchConfigValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v TuntermSwitchConfigValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v TuntermSwitchConfigValue) String() string {
	return "TuntermSwitchConfigValue"
}

func (v TuntermSwitchConfigValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	vlanIdsVal, d := types.ListValue(types.StringType, v.VlanIds.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"port_vlan_id": basetypes.Int64Type{},
			"vlan_ids": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"port_vlan_id": basetypes.Int64Type{},
		"vlan_ids": basetypes.ListType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"port_vlan_id": v.PortVlanId,
			"vlan_ids":     vlanIdsVal,
		})

	return objVal, diags
}

func (v TuntermSwitchConfigValue) Equal(o attr.Value) bool {
	other, ok := o.(TuntermSwitchConfigValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.PortVlanId.Equal(other.PortVlanId) {
		return false
	}

	if !v.VlanIds.Equal(other.VlanIds) {
		return false
	}

	return true
}

func (v TuntermSwitchConfigValue) Type(ctx context.Context) attr.Type {
	return TuntermSwitchConfigType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v TuntermSwitchConfigValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"port_vlan_id": basetypes.Int64Type{},
		"vlan_ids": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = VersionsType{}

type VersionsType struct {
	basetypes.ObjectType
}

func (t VersionsType) Equal(o attr.Type) bool {
	other, ok := o.(VersionsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t VersionsType) String() string {
	return "VersionsType"
}

func (t VersionsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	mxagentAttribute, ok := attributes["mxagent"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mxagent is missing from object`)

		return nil, diags
	}

	mxagentVal, ok := mxagentAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mxagent expected to be basetypes.StringValue, was: %T`, mxagentAttribute))
	}

	tuntnermAttribute, ok := attributes["tuntnerm"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tuntnerm is missing from object`)

		return nil, diags
	}

	tuntnermVal, ok := tuntnermAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tuntnerm expected to be basetypes.StringValue, was: %T`, tuntnermAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return VersionsValue{
		Mxagent:  mxagentVal,
		Tuntnerm: tuntnermVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewVersionsValueNull() VersionsValue {
	return VersionsValue{
		state: attr.ValueStateNull,
	}
}

func NewVersionsValueUnknown() VersionsValue {
	return VersionsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewVersionsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (VersionsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing VersionsValue Attribute Value",
				"While creating a VersionsValue value, a missing attribute value was detected. "+
					"A VersionsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VersionsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid VersionsValue Attribute Type",
				"While creating a VersionsValue value, an invalid attribute value was detected. "+
					"A VersionsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VersionsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("VersionsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra VersionsValue Attribute Value",
				"While creating a VersionsValue value, an extra attribute value was detected. "+
					"A VersionsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra VersionsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewVersionsValueUnknown(), diags
	}

	mxagentAttribute, ok := attributes["mxagent"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mxagent is missing from object`)

		return NewVersionsValueUnknown(), diags
	}

	mxagentVal, ok := mxagentAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mxagent expected to be basetypes.StringValue, was: %T`, mxagentAttribute))
	}

	tuntnermAttribute, ok := attributes["tuntnerm"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tuntnerm is missing from object`)

		return NewVersionsValueUnknown(), diags
	}

	tuntnermVal, ok := tuntnermAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tuntnerm expected to be basetypes.StringValue, was: %T`, tuntnermAttribute))
	}

	if diags.HasError() {
		return NewVersionsValueUnknown(), diags
	}

	return VersionsValue{
		Mxagent:  mxagentVal,
		Tuntnerm: tuntnermVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewVersionsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) VersionsValue {
	object, diags := NewVersionsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewVersionsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t VersionsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewVersionsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewVersionsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewVersionsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewVersionsValueMust(VersionsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t VersionsType) ValueType(ctx context.Context) attr.Value {
	return VersionsValue{}
}

var _ basetypes.ObjectValuable = VersionsValue{}

type VersionsValue struct {
	Mxagent  basetypes.StringValue `tfsdk:"mxagent"`
	Tuntnerm basetypes.StringValue `tfsdk:"tuntnerm"`
	state    attr.ValueState
}

func (v VersionsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["mxagent"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["tuntnerm"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Mxagent.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mxagent"] = val

		val, err = v.Tuntnerm.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tuntnerm"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v VersionsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v VersionsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v VersionsValue) String() string {
	return "VersionsValue"
}

func (v VersionsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"mxagent":  basetypes.StringType{},
		"tuntnerm": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"mxagent":  v.Mxagent,
			"tuntnerm": v.Tuntnerm,
		})

	return objVal, diags
}

func (v VersionsValue) Equal(o attr.Value) bool {
	other, ok := o.(VersionsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Mxagent.Equal(other.Mxagent) {
		return false
	}

	if !v.Tuntnerm.Equal(other.Tuntnerm) {
		return false
	}

	return true
}

func (v VersionsValue) Type(ctx context.Context) attr.Type {
	return VersionsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v VersionsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"mxagent":  basetypes.StringType{},
		"tuntnerm": basetypes.StringType{},
	}
}
