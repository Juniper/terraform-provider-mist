// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package resource_org_nactag

import (
	"context"
	"github.com/Juniper/terraform-provider-mist/internal/validators"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/booldefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"

	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
)

func OrgNactagResourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"allow_usermac_override": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Can be set to true to allow the override by usermac result",
				MarkdownDescription: "Can be set to true to allow the override by usermac result",
				Default:             booldefault.StaticBool(false),
			},
			"egress_vlan_names": schema.ListAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Description:         "If `type`==`egress_vlan_names`, list of egress vlans to return",
				MarkdownDescription: "If `type`==`egress_vlan_names`, list of egress vlans to return",
				Validators: []validator.List{
					mistvalidator.AllowedWhenValueIs(path.MatchRelative().AtParent().AtName("type"), types.StringValue("egress_vlan_names")),
				},
			},
			"gbp_tag": schema.StringAttribute{
				Optional: true,
				Validators: []validator.String{
					mistvalidator.AllowedWhenValueIs(path.MatchRelative().AtParent().AtName("type"), types.StringValue("gbp_tag")),
					stringvalidator.Any(
						mistvalidator.ParseInt(0, 65535),
						mistvalidator.ParseVar(),
					),
				},
			},
			"id": schema.StringAttribute{
				Computed:            true,
				Description:         "Unique ID of the object instance in the Mist Organization",
				MarkdownDescription: "Unique ID of the object instance in the Mist Organization",
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"match": schema.StringAttribute{
				Optional:            true,
				Description:         "if `type`==`match`. enum: `cert_cn`, `cert_issuer`, `cert_san`, `cert_serial`, `cert_sub`, `cert_template`, `client_mac`, `idp_role`, `ingress_vlan`, `mdm_status`, `nas_ip`, `radius_group`, `realm`, `ssid`, `user_name`, `usermac_label`",
				MarkdownDescription: "if `type`==`match`. enum: `cert_cn`, `cert_issuer`, `cert_san`, `cert_serial`, `cert_sub`, `cert_template`, `client_mac`, `idp_role`, `ingress_vlan`, `mdm_status`, `nas_ip`, `radius_group`, `realm`, `ssid`, `user_name`, `usermac_label`",
				Validators: []validator.String{
					stringvalidator.OneOf(
						"",
						"cert_cn",
						"cert_issuer",
						"cert_san",
						"cert_serial",
						"cert_sub",
						"client_mac",
						"idp_role",
						"mdm_status",
						"radius_group",
						"realm",
						"ssid",
						"user_name",
						"usermac_label",
					),
					mistvalidator.AllowedWhenValueIs(path.MatchRelative().AtParent().AtName("type"), types.StringValue("match")),
				},
			},
			"match_all": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "This field is applicable only when `type`==`match`\n  * `false`: means it is sufficient to match any of the values (i.e., match-any behavior)\n  * `true`: means all values should be matched (i.e., match-all behavior)\n\n\nCurrently it makes sense to set this field to `true` only if the `match`==`idp_role` or `match`==`usermac_label`",
				MarkdownDescription: "This field is applicable only when `type`==`match`\n  * `false`: means it is sufficient to match any of the values (i.e., match-any behavior)\n  * `true`: means all values should be matched (i.e., match-all behavior)\n\n\nCurrently it makes sense to set this field to `true` only if the `match`==`idp_role` or `match`==`usermac_label`",
				Default:             booldefault.StaticBool(false),
			},
			"name": schema.StringAttribute{
				Required: true,
				Validators: []validator.String{
					stringvalidator.LengthBetween(1, 32),
				},
			},
			"org_id": schema.StringAttribute{
				Required: true,
			},
			"radius_attrs": schema.ListAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Description:         "If `type`==`radius_attrs`, user can specify a list of one or more standard attributes in the field \"radius_attrs\". \nIt is the responsibility of the user to provide a syntactically correct string, otherwise it may not work as expected.\nNote that it is allowed to have more than one radius_attrs in the result of a given rule.",
				MarkdownDescription: "If `type`==`radius_attrs`, user can specify a list of one or more standard attributes in the field \"radius_attrs\". \nIt is the responsibility of the user to provide a syntactically correct string, otherwise it may not work as expected.\nNote that it is allowed to have more than one radius_attrs in the result of a given rule.",
				Validators: []validator.List{
					mistvalidator.AllowedWhenValueIs(path.MatchRelative().AtParent().AtName("type"), types.StringValue("radius_attrs")),
				},
			},
			"radius_group": schema.StringAttribute{
				Optional:            true,
				Description:         "If `type`==`radius_group`",
				MarkdownDescription: "If `type`==`radius_group`",
				Validators: []validator.String{
					mistvalidator.AllowedWhenValueIs(path.MatchRelative().AtParent().AtName("type"), types.StringValue("radius_group")),
				},
			},
			"radius_vendor_attrs": schema.ListAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Description:         "If `type`==`radius_vendor_attrs`, user can specify a list of one or more vendor-specific attributes in the field \"radius_vendor_attrs\". \nIt is the responsibility of the user to provide a syntactically correct string, otherwise it may not work as expected.\nNote that it is allowed to have more than one radius_vendor_attrs in the result of a given rule.",
				MarkdownDescription: "If `type`==`radius_vendor_attrs`, user can specify a list of one or more vendor-specific attributes in the field \"radius_vendor_attrs\". \nIt is the responsibility of the user to provide a syntactically correct string, otherwise it may not work as expected.\nNote that it is allowed to have more than one radius_vendor_attrs in the result of a given rule.",
				Validators: []validator.List{
					mistvalidator.AllowedWhenValueIs(path.MatchRelative().AtParent().AtName("type"), types.StringValue("radius_vendor_attrs")),
				},
			},
			"session_timeout": schema.Int64Attribute{
				Optional:            true,
				Description:         "If `type`==`session_timeout, in seconds",
				MarkdownDescription: "If `type`==`session_timeout, in seconds",
				Validators: []validator.Int64{
					mistvalidator.AllowedWhenValueIs(path.MatchRelative().AtParent().AtName("type"), types.StringValue("session_timeout")),
				},
			},
			"type": schema.StringAttribute{
				Required:            true,
				Description:         "enum: `egress_vlan_names`, `gbp_tag`, `match`, `radius_attrs`, `radius_group`, `radius_vendor_attrs`, `session_timeout`, `username_attr`, `vlan`",
				MarkdownDescription: "enum: `egress_vlan_names`, `gbp_tag`, `match`, `radius_attrs`, `radius_group`, `radius_vendor_attrs`, `session_timeout`, `username_attr`, `vlan`",
				Validators: []validator.String{
					stringvalidator.OneOf(
						"",
						"egress_vlan_names",
						"gbp_tag",
						"match",
						"radius_attrs",
						"radius_group",
						"radius_vendor_attrs",
						"session_timeout",
						"username_attr",
						"vlan",
					),
					stringvalidator.LengthAtLeast(1),
				},
			},
			"username_attr": schema.StringAttribute{
				Optional:            true,
				Description:         "enum: `automatic`, `cn`, `dns`, `email`, `upn`",
				MarkdownDescription: "enum: `automatic`, `cn`, `dns`, `email`, `upn`",
				Validators: []validator.String{
					stringvalidator.OneOf(
						"",
						"automatic",
						"cn",
						"dns",
						"email",
						"upn",
					),
				},
			},
			"values": schema.ListAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Description:         "If `type`==`match`",
				MarkdownDescription: "If `type`==`match`",
				Validators: []validator.List{
					mistvalidator.AllowedWhenValueIs(path.MatchRelative().AtParent().AtName("type"), types.StringValue("match")),
				},
			},
			"vlan": schema.StringAttribute{
				Optional:            true,
				Description:         "If `type`==`vlan`",
				MarkdownDescription: "If `type`==`vlan`",
				Validators: []validator.String{
					mistvalidator.AllowedWhenValueIs(path.MatchRelative().AtParent().AtName("type"), types.StringValue("vlan")),
				},
			},
		},
	}
}

type OrgNactagModel struct {
	AllowUsermacOverride types.Bool   `tfsdk:"allow_usermac_override"`
	EgressVlanNames      types.List   `tfsdk:"egress_vlan_names"`
	GbpTag               types.String `tfsdk:"gbp_tag"`
	Id                   types.String `tfsdk:"id"`
	Match                types.String `tfsdk:"match"`
	MatchAll             types.Bool   `tfsdk:"match_all"`
	Name                 types.String `tfsdk:"name"`
	OrgId                types.String `tfsdk:"org_id"`
	RadiusAttrs          types.List   `tfsdk:"radius_attrs"`
	RadiusGroup          types.String `tfsdk:"radius_group"`
	RadiusVendorAttrs    types.List   `tfsdk:"radius_vendor_attrs"`
	SessionTimeout       types.Int64  `tfsdk:"session_timeout"`
	Type                 types.String `tfsdk:"type"`
	UsernameAttr         types.String `tfsdk:"username_attr"`
	Values               types.List   `tfsdk:"values"`
	Vlan                 types.String `tfsdk:"vlan"`
}
