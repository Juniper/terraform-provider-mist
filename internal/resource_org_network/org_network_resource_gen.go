// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package resource_org_network

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/booldefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/listdefault"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"regexp"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
)

func OrgNetworkResourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"disallow_mist_services": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "whether to disallow Mist Devices in the network",
				MarkdownDescription: "whether to disallow Mist Devices in the network",
				Default:             booldefault.StaticBool(false),
			},
			"gateway": schema.StringAttribute{
				Optional: true,
			},
			"gateway6": schema.StringAttribute{
				Optional: true,
			},
			"id": schema.StringAttribute{
				Computed: true,
			},
			"internal_access": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"enabled": schema.BoolAttribute{
						Optional: true,
					},
				},
				CustomType: InternalAccessType{
					ObjectType: types.ObjectType{
						AttrTypes: InternalAccessValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
			},
			"internet_access": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"create_simple_service_policy": schema.BoolAttribute{
						Optional: true,
						Computed: true,
						Default:  booldefault.StaticBool(false),
					},
					"destination_nat": schema.MapNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"internal_ip": schema.StringAttribute{
									Optional: true,
								},
								"name": schema.StringAttribute{
									Optional: true,
								},
								"port": schema.Int64Attribute{
									Optional: true,
								},
							},
							CustomType: DestinationNatType{
								ObjectType: types.ObjectType{
									AttrTypes: DestinationNatValue{}.AttributeTypes(ctx),
								},
							},
						},
						Optional:            true,
						Description:         "Property key may be an IP/Port (i.e. \"63.16.0.3:443\"), or a port (i.e. \":2222\")",
						MarkdownDescription: "Property key may be an IP/Port (i.e. \"63.16.0.3:443\"), or a port (i.e. \":2222\")",
					},
					"enabled": schema.BoolAttribute{
						Optional: true,
					},
					"restricted": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "by default, all access is allowed, to only allow certain traffic, make `restricted`=`true` and define service_policies",
						MarkdownDescription: "by default, all access is allowed, to only allow certain traffic, make `restricted`=`true` and define service_policies",
						Default:             booldefault.StaticBool(false),
					},
					"static_nat": schema.MapNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"internal_ip": schema.StringAttribute{
									Optional: true,
								},
								"name": schema.StringAttribute{
									Optional: true,
								},
								"wan_name": schema.StringAttribute{
									Optional:            true,
									Description:         "If not set, we configure the nat policies against all WAN ports for simplicity",
									MarkdownDescription: "If not set, we configure the nat policies against all WAN ports for simplicity",
								},
							},
							CustomType: StaticNatType{
								ObjectType: types.ObjectType{
									AttrTypes: StaticNatValue{}.AttributeTypes(ctx),
								},
							},
						},
						Optional:            true,
						Description:         "Property key may be an IP Address (i.e. \"172.16.0.1\"), and IP Address and Port (i.e. \"172.16.0.1:8443\") or a CIDR (i.e. \"172.16.0.12/20\")",
						MarkdownDescription: "Property key may be an IP Address (i.e. \"172.16.0.1\"), and IP Address and Port (i.e. \"172.16.0.1:8443\") or a CIDR (i.e. \"172.16.0.12/20\")",
					},
				},
				CustomType: InternetAccessType{
					ObjectType: types.ObjectType{
						AttrTypes: InternetAccessValue{}.AttributeTypes(ctx),
					},
				},
				Optional:            true,
				Description:         "whether this network has direct internet access",
				MarkdownDescription: "whether this network has direct internet access",
			},
			"isolation": schema.BoolAttribute{
				Optional:            true,
				Description:         "whether to allow clients in the network to talk to each other",
				MarkdownDescription: "whether to allow clients in the network to talk to each other",
			},
			"name": schema.StringAttribute{
				Required: true,
			},
			"org_id": schema.StringAttribute{
				Required: true,
			},
			"routed_for_networks": schema.ListAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Description:         "for a Network (usually LAN), it can be routable to other networks (e.g. OSPF)",
				MarkdownDescription: "for a Network (usually LAN), it can be routable to other networks (e.g. OSPF)",
			},
			"subnet": schema.StringAttribute{
				Required: true,
				Validators: []validator.String{
					stringvalidator.RegexMatches(regexp.MustCompile(`([\d{1,3}\.]+)/(\d{2})`), "subnet must be a CIDR (e.g. 192.168.1.0/24)"),
				},
			},
			"subnet6": schema.StringAttribute{
				Optional: true,
			},
			"tenants": schema.MapNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"addresses": schema.ListAttribute{
							ElementType: types.StringType,
							Optional:    true,
						},
					},
					CustomType: TenantsType{
						ObjectType: types.ObjectType{
							AttrTypes: TenantsValue{}.AttributeTypes(ctx),
						},
					},
				},
				Optional: true,
			},
			"vlan_id": schema.Int64Attribute{
				Optional: true,
			},
			"vpn_access": schema.MapNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"advertised_subnet": schema.StringAttribute{
							Optional:            true,
							Description:         "if `routed`==`true`, whether to advertise an aggregated subnet toward HUB this is useful when there are multiple networks on SPOKE's side",
							MarkdownDescription: "if `routed`==`true`, whether to advertise an aggregated subnet toward HUB this is useful when there are multiple networks on SPOKE's side",
						},
						"allow_ping": schema.BoolAttribute{
							Optional:            true,
							Description:         "whether to allow ping from vpn into this routed network",
							MarkdownDescription: "whether to allow ping from vpn into this routed network",
						},
						"destination_nat": schema.MapNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"internal_ip": schema.StringAttribute{
										Optional: true,
									},
									"name": schema.StringAttribute{
										Optional: true,
									},
									"port": schema.Int64Attribute{
										Optional: true,
									},
								},
								CustomType: DestinationNatType{
									ObjectType: types.ObjectType{
										AttrTypes: DestinationNatValue{}.AttributeTypes(ctx),
									},
								},
							},
							Optional:            true,
							Computed:            true,
							Description:         "Property key may be an IP/Port (i.e. \"63.16.0.3:443\"), or a port (i.e. \":2222\")",
							MarkdownDescription: "Property key may be an IP/Port (i.e. \"63.16.0.3:443\"), or a port (i.e. \":2222\")",
						},
						"nat_pool": schema.StringAttribute{
							Optional:            true,
							Description:         "if `routed`==`false` (usually at Spoke), but some hosts needs to be reachable from Hub, a subnet is required to create and advertise the route to Hub",
							MarkdownDescription: "if `routed`==`false` (usually at Spoke), but some hosts needs to be reachable from Hub, a subnet is required to create and advertise the route to Hub",
						},
						"no_readvertise_to_lan_bgp": schema.BoolAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "toward LAN-side BGP peers",
							MarkdownDescription: "toward LAN-side BGP peers",
							Default:             booldefault.StaticBool(false),
						},
						"no_readvertise_to_lan_ospf": schema.BoolAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "toward LAN-side OSPF peers",
							MarkdownDescription: "toward LAN-side OSPF peers",
							Default:             booldefault.StaticBool(false),
						},
						"no_readvertise_to_overlay": schema.BoolAttribute{
							Optional:            true,
							Description:         "toward overlay\nhow HUB should deal with routes it received from Spokes",
							MarkdownDescription: "toward overlay\nhow HUB should deal with routes it received from Spokes",
						},
						"other_vrfs": schema.ListAttribute{
							ElementType:         types.StringType,
							Optional:            true,
							Computed:            true,
							Description:         "by default, the routes are only readvertised toward the same vrf on spoke\nto allow it to be leaked to other vrfs",
							MarkdownDescription: "by default, the routes are only readvertised toward the same vrf on spoke\nto allow it to be leaked to other vrfs",
							Default:             listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						},
						"routed": schema.BoolAttribute{
							Optional:            true,
							Description:         "whether this network is routable",
							MarkdownDescription: "whether this network is routable",
						},
						"source_nat": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"exteral_ip": schema.StringAttribute{
									Optional: true,
								},
							},
							CustomType: SourceNatType{
								ObjectType: types.ObjectType{
									AttrTypes: SourceNatValue{}.AttributeTypes(ctx),
								},
							},
							Optional:            true,
							Computed:            true,
							Description:         "if `routed`==`false` (usually at Spoke), but some hosts needs to be reachable from Hub",
							MarkdownDescription: "if `routed`==`false` (usually at Spoke), but some hosts needs to be reachable from Hub",
						},
						"static_nat": schema.MapNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"internal_ip": schema.StringAttribute{
										Optional: true,
									},
									"name": schema.StringAttribute{
										Optional: true,
									},
									"wan_name": schema.StringAttribute{
										Optional:            true,
										Description:         "If not set, we configure the nat policies against all WAN ports for simplicity",
										MarkdownDescription: "If not set, we configure the nat policies against all WAN ports for simplicity",
									},
								},
								CustomType: StaticNatType{
									ObjectType: types.ObjectType{
										AttrTypes: StaticNatValue{}.AttributeTypes(ctx),
									},
								},
							},
							Optional:            true,
							Computed:            true,
							Description:         "Property key may be an IP Address (i.e. \"172.16.0.1\"), and IP Address and Port (i.e. \"172.16.0.1:8443\") or a CIDR (i.e. \"172.16.0.12/20\")",
							MarkdownDescription: "Property key may be an IP Address (i.e. \"172.16.0.1\"), and IP Address and Port (i.e. \"172.16.0.1:8443\") or a CIDR (i.e. \"172.16.0.12/20\")",
						},
						"summarized_subnet": schema.StringAttribute{
							Optional:            true,
							Description:         "toward overlay\nhow HUB should deal with routes it received from Spokes",
							MarkdownDescription: "toward overlay\nhow HUB should deal with routes it received from Spokes",
						},
						"summarized_subnet_to_lan_bgp": schema.StringAttribute{
							Optional:            true,
							Description:         "toward LAN-side BGP peers",
							MarkdownDescription: "toward LAN-side BGP peers",
						},
						"summarized_subnet_to_lan_ospf": schema.StringAttribute{
							Optional:            true,
							Description:         "toward LAN-side OSPF peers",
							MarkdownDescription: "toward LAN-side OSPF peers",
						},
					},
					CustomType: VpnAccessType{
						ObjectType: types.ObjectType{
							AttrTypes: VpnAccessValue{}.AttributeTypes(ctx),
						},
					},
				},
				Optional:            true,
				Description:         "Property key is the VPN name. Whether this network can be accessed from vpn",
				MarkdownDescription: "Property key is the VPN name. Whether this network can be accessed from vpn",
			},
		},
	}
}

type OrgNetworkModel struct {
	DisallowMistServices types.Bool          `tfsdk:"disallow_mist_services"`
	Gateway              types.String        `tfsdk:"gateway"`
	Gateway6             types.String        `tfsdk:"gateway6"`
	Id                   types.String        `tfsdk:"id"`
	InternalAccess       InternalAccessValue `tfsdk:"internal_access"`
	InternetAccess       InternetAccessValue `tfsdk:"internet_access"`
	Isolation            types.Bool          `tfsdk:"isolation"`
	Name                 types.String        `tfsdk:"name"`
	OrgId                types.String        `tfsdk:"org_id"`
	RoutedForNetworks    types.List          `tfsdk:"routed_for_networks"`
	Subnet               types.String        `tfsdk:"subnet"`
	Subnet6              types.String        `tfsdk:"subnet6"`
	Tenants              types.Map           `tfsdk:"tenants"`
	VlanId               types.Int64         `tfsdk:"vlan_id"`
	VpnAccess            types.Map           `tfsdk:"vpn_access"`
}

var _ basetypes.ObjectTypable = InternalAccessType{}

type InternalAccessType struct {
	basetypes.ObjectType
}

func (t InternalAccessType) Equal(o attr.Type) bool {
	other, ok := o.(InternalAccessType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t InternalAccessType) String() string {
	return "InternalAccessType"
}

func (t InternalAccessType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return InternalAccessValue{
		Enabled: enabledVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewInternalAccessValueNull() InternalAccessValue {
	return InternalAccessValue{
		state: attr.ValueStateNull,
	}
}

func NewInternalAccessValueUnknown() InternalAccessValue {
	return InternalAccessValue{
		state: attr.ValueStateUnknown,
	}
}

func NewInternalAccessValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (InternalAccessValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing InternalAccessValue Attribute Value",
				"While creating a InternalAccessValue value, a missing attribute value was detected. "+
					"A InternalAccessValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("InternalAccessValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid InternalAccessValue Attribute Type",
				"While creating a InternalAccessValue value, an invalid attribute value was detected. "+
					"A InternalAccessValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("InternalAccessValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("InternalAccessValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra InternalAccessValue Attribute Value",
				"While creating a InternalAccessValue value, an extra attribute value was detected. "+
					"A InternalAccessValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra InternalAccessValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewInternalAccessValueUnknown(), diags
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewInternalAccessValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	if diags.HasError() {
		return NewInternalAccessValueUnknown(), diags
	}

	return InternalAccessValue{
		Enabled: enabledVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewInternalAccessValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) InternalAccessValue {
	object, diags := NewInternalAccessValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewInternalAccessValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t InternalAccessType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewInternalAccessValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewInternalAccessValueUnknown(), nil
	}

	if in.IsNull() {
		return NewInternalAccessValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewInternalAccessValueMust(InternalAccessValue{}.AttributeTypes(ctx), attributes), nil
}

func (t InternalAccessType) ValueType(ctx context.Context) attr.Value {
	return InternalAccessValue{}
}

var _ basetypes.ObjectValuable = InternalAccessValue{}

type InternalAccessValue struct {
	Enabled basetypes.BoolValue `tfsdk:"enabled"`
	state   attr.ValueState
}

func (v InternalAccessValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v InternalAccessValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v InternalAccessValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v InternalAccessValue) String() string {
	return "InternalAccessValue"
}

func (v InternalAccessValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"enabled": basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"enabled": v.Enabled,
		})

	return objVal, diags
}

func (v InternalAccessValue) Equal(o attr.Value) bool {
	other, ok := o.(InternalAccessValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	return true
}

func (v InternalAccessValue) Type(ctx context.Context) attr.Type {
	return InternalAccessType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v InternalAccessValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"enabled": basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = InternetAccessType{}

type InternetAccessType struct {
	basetypes.ObjectType
}

func (t InternetAccessType) Equal(o attr.Type) bool {
	other, ok := o.(InternetAccessType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t InternetAccessType) String() string {
	return "InternetAccessType"
}

func (t InternetAccessType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	createSimpleServicePolicyAttribute, ok := attributes["create_simple_service_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`create_simple_service_policy is missing from object`)

		return nil, diags
	}

	createSimpleServicePolicyVal, ok := createSimpleServicePolicyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`create_simple_service_policy expected to be basetypes.BoolValue, was: %T`, createSimpleServicePolicyAttribute))
	}

	destinationNatAttribute, ok := attributes["destination_nat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`destination_nat is missing from object`)

		return nil, diags
	}

	destinationNatVal, ok := destinationNatAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`destination_nat expected to be basetypes.MapValue, was: %T`, destinationNatAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	restrictedAttribute, ok := attributes["restricted"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`restricted is missing from object`)

		return nil, diags
	}

	restrictedVal, ok := restrictedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`restricted expected to be basetypes.BoolValue, was: %T`, restrictedAttribute))
	}

	staticNatAttribute, ok := attributes["static_nat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`static_nat is missing from object`)

		return nil, diags
	}

	staticNatVal, ok := staticNatAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`static_nat expected to be basetypes.MapValue, was: %T`, staticNatAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return InternetAccessValue{
		CreateSimpleServicePolicy: createSimpleServicePolicyVal,
		DestinationNat:            destinationNatVal,
		Enabled:                   enabledVal,
		Restricted:                restrictedVal,
		StaticNat:                 staticNatVal,
		state:                     attr.ValueStateKnown,
	}, diags
}

func NewInternetAccessValueNull() InternetAccessValue {
	return InternetAccessValue{
		state: attr.ValueStateNull,
	}
}

func NewInternetAccessValueUnknown() InternetAccessValue {
	return InternetAccessValue{
		state: attr.ValueStateUnknown,
	}
}

func NewInternetAccessValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (InternetAccessValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing InternetAccessValue Attribute Value",
				"While creating a InternetAccessValue value, a missing attribute value was detected. "+
					"A InternetAccessValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("InternetAccessValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid InternetAccessValue Attribute Type",
				"While creating a InternetAccessValue value, an invalid attribute value was detected. "+
					"A InternetAccessValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("InternetAccessValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("InternetAccessValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra InternetAccessValue Attribute Value",
				"While creating a InternetAccessValue value, an extra attribute value was detected. "+
					"A InternetAccessValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra InternetAccessValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewInternetAccessValueUnknown(), diags
	}

	createSimpleServicePolicyAttribute, ok := attributes["create_simple_service_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`create_simple_service_policy is missing from object`)

		return NewInternetAccessValueUnknown(), diags
	}

	createSimpleServicePolicyVal, ok := createSimpleServicePolicyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`create_simple_service_policy expected to be basetypes.BoolValue, was: %T`, createSimpleServicePolicyAttribute))
	}

	destinationNatAttribute, ok := attributes["destination_nat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`destination_nat is missing from object`)

		return NewInternetAccessValueUnknown(), diags
	}

	destinationNatVal, ok := destinationNatAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`destination_nat expected to be basetypes.MapValue, was: %T`, destinationNatAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewInternetAccessValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	restrictedAttribute, ok := attributes["restricted"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`restricted is missing from object`)

		return NewInternetAccessValueUnknown(), diags
	}

	restrictedVal, ok := restrictedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`restricted expected to be basetypes.BoolValue, was: %T`, restrictedAttribute))
	}

	staticNatAttribute, ok := attributes["static_nat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`static_nat is missing from object`)

		return NewInternetAccessValueUnknown(), diags
	}

	staticNatVal, ok := staticNatAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`static_nat expected to be basetypes.MapValue, was: %T`, staticNatAttribute))
	}

	if diags.HasError() {
		return NewInternetAccessValueUnknown(), diags
	}

	return InternetAccessValue{
		CreateSimpleServicePolicy: createSimpleServicePolicyVal,
		DestinationNat:            destinationNatVal,
		Enabled:                   enabledVal,
		Restricted:                restrictedVal,
		StaticNat:                 staticNatVal,
		state:                     attr.ValueStateKnown,
	}, diags
}

func NewInternetAccessValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) InternetAccessValue {
	object, diags := NewInternetAccessValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewInternetAccessValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t InternetAccessType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewInternetAccessValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewInternetAccessValueUnknown(), nil
	}

	if in.IsNull() {
		return NewInternetAccessValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewInternetAccessValueMust(InternetAccessValue{}.AttributeTypes(ctx), attributes), nil
}

func (t InternetAccessType) ValueType(ctx context.Context) attr.Value {
	return InternetAccessValue{}
}

var _ basetypes.ObjectValuable = InternetAccessValue{}

type InternetAccessValue struct {
	CreateSimpleServicePolicy basetypes.BoolValue `tfsdk:"create_simple_service_policy"`
	DestinationNat            basetypes.MapValue  `tfsdk:"destination_nat"`
	Enabled                   basetypes.BoolValue `tfsdk:"enabled"`
	Restricted                basetypes.BoolValue `tfsdk:"restricted"`
	StaticNat                 basetypes.MapValue  `tfsdk:"static_nat"`
	state                     attr.ValueState
}

func (v InternetAccessValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["create_simple_service_policy"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["destination_nat"] = basetypes.MapType{
		ElemType: DestinationNatValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["restricted"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["static_nat"] = basetypes.MapType{
		ElemType: StaticNatValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.CreateSimpleServicePolicy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["create_simple_service_policy"] = val

		val, err = v.DestinationNat.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["destination_nat"] = val

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.Restricted.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["restricted"] = val

		val, err = v.StaticNat.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["static_nat"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v InternetAccessValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v InternetAccessValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v InternetAccessValue) String() string {
	return "InternetAccessValue"
}

func (v InternetAccessValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	destinationNat := types.MapValueMust(
		DestinationNatType{
			basetypes.ObjectType{
				AttrTypes: DestinationNatValue{}.AttributeTypes(ctx),
			},
		},
		v.DestinationNat.Elements(),
	)

	if v.DestinationNat.IsNull() {
		destinationNat = types.MapNull(
			DestinationNatType{
				basetypes.ObjectType{
					AttrTypes: DestinationNatValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.DestinationNat.IsUnknown() {
		destinationNat = types.MapUnknown(
			DestinationNatType{
				basetypes.ObjectType{
					AttrTypes: DestinationNatValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	staticNat := types.MapValueMust(
		StaticNatType{
			basetypes.ObjectType{
				AttrTypes: StaticNatValue{}.AttributeTypes(ctx),
			},
		},
		v.StaticNat.Elements(),
	)

	if v.StaticNat.IsNull() {
		staticNat = types.MapNull(
			StaticNatType{
				basetypes.ObjectType{
					AttrTypes: StaticNatValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.StaticNat.IsUnknown() {
		staticNat = types.MapUnknown(
			StaticNatType{
				basetypes.ObjectType{
					AttrTypes: StaticNatValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"create_simple_service_policy": basetypes.BoolType{},
		"destination_nat": basetypes.MapType{
			ElemType: DestinationNatValue{}.Type(ctx),
		},
		"enabled":    basetypes.BoolType{},
		"restricted": basetypes.BoolType{},
		"static_nat": basetypes.MapType{
			ElemType: StaticNatValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"create_simple_service_policy": v.CreateSimpleServicePolicy,
			"destination_nat":              destinationNat,
			"enabled":                      v.Enabled,
			"restricted":                   v.Restricted,
			"static_nat":                   staticNat,
		})

	return objVal, diags
}

func (v InternetAccessValue) Equal(o attr.Value) bool {
	other, ok := o.(InternetAccessValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.CreateSimpleServicePolicy.Equal(other.CreateSimpleServicePolicy) {
		return false
	}

	if !v.DestinationNat.Equal(other.DestinationNat) {
		return false
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.Restricted.Equal(other.Restricted) {
		return false
	}

	if !v.StaticNat.Equal(other.StaticNat) {
		return false
	}

	return true
}

func (v InternetAccessValue) Type(ctx context.Context) attr.Type {
	return InternetAccessType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v InternetAccessValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"create_simple_service_policy": basetypes.BoolType{},
		"destination_nat": basetypes.MapType{
			ElemType: DestinationNatValue{}.Type(ctx),
		},
		"enabled":    basetypes.BoolType{},
		"restricted": basetypes.BoolType{},
		"static_nat": basetypes.MapType{
			ElemType: StaticNatValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = DestinationNatType{}

type DestinationNatType struct {
	basetypes.ObjectType
}

func (t DestinationNatType) Equal(o attr.Type) bool {
	other, ok := o.(DestinationNatType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t DestinationNatType) String() string {
	return "DestinationNatType"
}

func (t DestinationNatType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	internalIpAttribute, ok := attributes["internal_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`internal_ip is missing from object`)

		return nil, diags
	}

	internalIpVal, ok := internalIpAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`internal_ip expected to be basetypes.StringValue, was: %T`, internalIpAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	portAttribute, ok := attributes["port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port is missing from object`)

		return nil, diags
	}

	portVal, ok := portAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port expected to be basetypes.Int64Value, was: %T`, portAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return DestinationNatValue{
		InternalIp: internalIpVal,
		Name:       nameVal,
		Port:       portVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewDestinationNatValueNull() DestinationNatValue {
	return DestinationNatValue{
		state: attr.ValueStateNull,
	}
}

func NewDestinationNatValueUnknown() DestinationNatValue {
	return DestinationNatValue{
		state: attr.ValueStateUnknown,
	}
}

func NewDestinationNatValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (DestinationNatValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing DestinationNatValue Attribute Value",
				"While creating a DestinationNatValue value, a missing attribute value was detected. "+
					"A DestinationNatValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DestinationNatValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid DestinationNatValue Attribute Type",
				"While creating a DestinationNatValue value, an invalid attribute value was detected. "+
					"A DestinationNatValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DestinationNatValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("DestinationNatValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra DestinationNatValue Attribute Value",
				"While creating a DestinationNatValue value, an extra attribute value was detected. "+
					"A DestinationNatValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra DestinationNatValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewDestinationNatValueUnknown(), diags
	}

	internalIpAttribute, ok := attributes["internal_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`internal_ip is missing from object`)

		return NewDestinationNatValueUnknown(), diags
	}

	internalIpVal, ok := internalIpAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`internal_ip expected to be basetypes.StringValue, was: %T`, internalIpAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewDestinationNatValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	portAttribute, ok := attributes["port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port is missing from object`)

		return NewDestinationNatValueUnknown(), diags
	}

	portVal, ok := portAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port expected to be basetypes.Int64Value, was: %T`, portAttribute))
	}

	if diags.HasError() {
		return NewDestinationNatValueUnknown(), diags
	}

	return DestinationNatValue{
		InternalIp: internalIpVal,
		Name:       nameVal,
		Port:       portVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewDestinationNatValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) DestinationNatValue {
	object, diags := NewDestinationNatValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewDestinationNatValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t DestinationNatType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewDestinationNatValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewDestinationNatValueUnknown(), nil
	}

	if in.IsNull() {
		return NewDestinationNatValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewDestinationNatValueMust(DestinationNatValue{}.AttributeTypes(ctx), attributes), nil
}

func (t DestinationNatType) ValueType(ctx context.Context) attr.Value {
	return DestinationNatValue{}
}

var _ basetypes.ObjectValuable = DestinationNatValue{}

type DestinationNatValue struct {
	InternalIp basetypes.StringValue `tfsdk:"internal_ip"`
	Name       basetypes.StringValue `tfsdk:"name"`
	Port       basetypes.Int64Value  `tfsdk:"port"`
	state      attr.ValueState
}

func (v DestinationNatValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["internal_ip"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["port"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.InternalIp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["internal_ip"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Port.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v DestinationNatValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v DestinationNatValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v DestinationNatValue) String() string {
	return "DestinationNatValue"
}

func (v DestinationNatValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"internal_ip": basetypes.StringType{},
		"name":        basetypes.StringType{},
		"port":        basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"internal_ip": v.InternalIp,
			"name":        v.Name,
			"port":        v.Port,
		})

	return objVal, diags
}

func (v DestinationNatValue) Equal(o attr.Value) bool {
	other, ok := o.(DestinationNatValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.InternalIp.Equal(other.InternalIp) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Port.Equal(other.Port) {
		return false
	}

	return true
}

func (v DestinationNatValue) Type(ctx context.Context) attr.Type {
	return DestinationNatType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v DestinationNatValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"internal_ip": basetypes.StringType{},
		"name":        basetypes.StringType{},
		"port":        basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = StaticNatType{}

type StaticNatType struct {
	basetypes.ObjectType
}

func (t StaticNatType) Equal(o attr.Type) bool {
	other, ok := o.(StaticNatType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t StaticNatType) String() string {
	return "StaticNatType"
}

func (t StaticNatType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	internalIpAttribute, ok := attributes["internal_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`internal_ip is missing from object`)

		return nil, diags
	}

	internalIpVal, ok := internalIpAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`internal_ip expected to be basetypes.StringValue, was: %T`, internalIpAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	wanNameAttribute, ok := attributes["wan_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wan_name is missing from object`)

		return nil, diags
	}

	wanNameVal, ok := wanNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wan_name expected to be basetypes.StringValue, was: %T`, wanNameAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return StaticNatValue{
		InternalIp: internalIpVal,
		Name:       nameVal,
		WanName:    wanNameVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewStaticNatValueNull() StaticNatValue {
	return StaticNatValue{
		state: attr.ValueStateNull,
	}
}

func NewStaticNatValueUnknown() StaticNatValue {
	return StaticNatValue{
		state: attr.ValueStateUnknown,
	}
}

func NewStaticNatValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (StaticNatValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing StaticNatValue Attribute Value",
				"While creating a StaticNatValue value, a missing attribute value was detected. "+
					"A StaticNatValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StaticNatValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid StaticNatValue Attribute Type",
				"While creating a StaticNatValue value, an invalid attribute value was detected. "+
					"A StaticNatValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StaticNatValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("StaticNatValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra StaticNatValue Attribute Value",
				"While creating a StaticNatValue value, an extra attribute value was detected. "+
					"A StaticNatValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra StaticNatValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewStaticNatValueUnknown(), diags
	}

	internalIpAttribute, ok := attributes["internal_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`internal_ip is missing from object`)

		return NewStaticNatValueUnknown(), diags
	}

	internalIpVal, ok := internalIpAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`internal_ip expected to be basetypes.StringValue, was: %T`, internalIpAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewStaticNatValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	wanNameAttribute, ok := attributes["wan_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wan_name is missing from object`)

		return NewStaticNatValueUnknown(), diags
	}

	wanNameVal, ok := wanNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wan_name expected to be basetypes.StringValue, was: %T`, wanNameAttribute))
	}

	if diags.HasError() {
		return NewStaticNatValueUnknown(), diags
	}

	return StaticNatValue{
		InternalIp: internalIpVal,
		Name:       nameVal,
		WanName:    wanNameVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewStaticNatValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) StaticNatValue {
	object, diags := NewStaticNatValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewStaticNatValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t StaticNatType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewStaticNatValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewStaticNatValueUnknown(), nil
	}

	if in.IsNull() {
		return NewStaticNatValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewStaticNatValueMust(StaticNatValue{}.AttributeTypes(ctx), attributes), nil
}

func (t StaticNatType) ValueType(ctx context.Context) attr.Value {
	return StaticNatValue{}
}

var _ basetypes.ObjectValuable = StaticNatValue{}

type StaticNatValue struct {
	InternalIp basetypes.StringValue `tfsdk:"internal_ip"`
	Name       basetypes.StringValue `tfsdk:"name"`
	WanName    basetypes.StringValue `tfsdk:"wan_name"`
	state      attr.ValueState
}

func (v StaticNatValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["internal_ip"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["wan_name"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.InternalIp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["internal_ip"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.WanName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["wan_name"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v StaticNatValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v StaticNatValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v StaticNatValue) String() string {
	return "StaticNatValue"
}

func (v StaticNatValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"internal_ip": basetypes.StringType{},
		"name":        basetypes.StringType{},
		"wan_name":    basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"internal_ip": v.InternalIp,
			"name":        v.Name,
			"wan_name":    v.WanName,
		})

	return objVal, diags
}

func (v StaticNatValue) Equal(o attr.Value) bool {
	other, ok := o.(StaticNatValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.InternalIp.Equal(other.InternalIp) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.WanName.Equal(other.WanName) {
		return false
	}

	return true
}

func (v StaticNatValue) Type(ctx context.Context) attr.Type {
	return StaticNatType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v StaticNatValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"internal_ip": basetypes.StringType{},
		"name":        basetypes.StringType{},
		"wan_name":    basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = TenantsType{}

type TenantsType struct {
	basetypes.ObjectType
}

func (t TenantsType) Equal(o attr.Type) bool {
	other, ok := o.(TenantsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t TenantsType) String() string {
	return "TenantsType"
}

func (t TenantsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	addressesAttribute, ok := attributes["addresses"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`addresses is missing from object`)

		return nil, diags
	}

	addressesVal, ok := addressesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`addresses expected to be basetypes.ListValue, was: %T`, addressesAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return TenantsValue{
		Addresses: addressesVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewTenantsValueNull() TenantsValue {
	return TenantsValue{
		state: attr.ValueStateNull,
	}
}

func NewTenantsValueUnknown() TenantsValue {
	return TenantsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewTenantsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (TenantsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing TenantsValue Attribute Value",
				"While creating a TenantsValue value, a missing attribute value was detected. "+
					"A TenantsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TenantsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid TenantsValue Attribute Type",
				"While creating a TenantsValue value, an invalid attribute value was detected. "+
					"A TenantsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TenantsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("TenantsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra TenantsValue Attribute Value",
				"While creating a TenantsValue value, an extra attribute value was detected. "+
					"A TenantsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra TenantsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewTenantsValueUnknown(), diags
	}

	addressesAttribute, ok := attributes["addresses"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`addresses is missing from object`)

		return NewTenantsValueUnknown(), diags
	}

	addressesVal, ok := addressesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`addresses expected to be basetypes.ListValue, was: %T`, addressesAttribute))
	}

	if diags.HasError() {
		return NewTenantsValueUnknown(), diags
	}

	return TenantsValue{
		Addresses: addressesVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewTenantsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) TenantsValue {
	object, diags := NewTenantsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewTenantsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t TenantsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewTenantsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewTenantsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewTenantsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewTenantsValueMust(TenantsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t TenantsType) ValueType(ctx context.Context) attr.Value {
	return TenantsValue{}
}

var _ basetypes.ObjectValuable = TenantsValue{}

type TenantsValue struct {
	Addresses basetypes.ListValue `tfsdk:"addresses"`
	state     attr.ValueState
}

func (v TenantsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["addresses"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Addresses.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["addresses"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v TenantsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v TenantsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v TenantsValue) String() string {
	return "TenantsValue"
}

func (v TenantsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	addressesVal, d := types.ListValue(types.StringType, v.Addresses.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"addresses": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"addresses": basetypes.ListType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"addresses": addressesVal,
		})

	return objVal, diags
}

func (v TenantsValue) Equal(o attr.Value) bool {
	other, ok := o.(TenantsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Addresses.Equal(other.Addresses) {
		return false
	}

	return true
}

func (v TenantsValue) Type(ctx context.Context) attr.Type {
	return TenantsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v TenantsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"addresses": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = VpnAccessType{}

type VpnAccessType struct {
	basetypes.ObjectType
}

func (t VpnAccessType) Equal(o attr.Type) bool {
	other, ok := o.(VpnAccessType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t VpnAccessType) String() string {
	return "VpnAccessType"
}

func (t VpnAccessType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	advertisedSubnetAttribute, ok := attributes["advertised_subnet"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`advertised_subnet is missing from object`)

		return nil, diags
	}

	advertisedSubnetVal, ok := advertisedSubnetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`advertised_subnet expected to be basetypes.StringValue, was: %T`, advertisedSubnetAttribute))
	}

	allowPingAttribute, ok := attributes["allow_ping"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allow_ping is missing from object`)

		return nil, diags
	}

	allowPingVal, ok := allowPingAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allow_ping expected to be basetypes.BoolValue, was: %T`, allowPingAttribute))
	}

	destinationNatAttribute, ok := attributes["destination_nat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`destination_nat is missing from object`)

		return nil, diags
	}

	destinationNatVal, ok := destinationNatAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`destination_nat expected to be basetypes.MapValue, was: %T`, destinationNatAttribute))
	}

	natPoolAttribute, ok := attributes["nat_pool"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`nat_pool is missing from object`)

		return nil, diags
	}

	natPoolVal, ok := natPoolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`nat_pool expected to be basetypes.StringValue, was: %T`, natPoolAttribute))
	}

	noReadvertiseToLanBgpAttribute, ok := attributes["no_readvertise_to_lan_bgp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`no_readvertise_to_lan_bgp is missing from object`)

		return nil, diags
	}

	noReadvertiseToLanBgpVal, ok := noReadvertiseToLanBgpAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`no_readvertise_to_lan_bgp expected to be basetypes.BoolValue, was: %T`, noReadvertiseToLanBgpAttribute))
	}

	noReadvertiseToLanOspfAttribute, ok := attributes["no_readvertise_to_lan_ospf"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`no_readvertise_to_lan_ospf is missing from object`)

		return nil, diags
	}

	noReadvertiseToLanOspfVal, ok := noReadvertiseToLanOspfAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`no_readvertise_to_lan_ospf expected to be basetypes.BoolValue, was: %T`, noReadvertiseToLanOspfAttribute))
	}

	noReadvertiseToOverlayAttribute, ok := attributes["no_readvertise_to_overlay"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`no_readvertise_to_overlay is missing from object`)

		return nil, diags
	}

	noReadvertiseToOverlayVal, ok := noReadvertiseToOverlayAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`no_readvertise_to_overlay expected to be basetypes.BoolValue, was: %T`, noReadvertiseToOverlayAttribute))
	}

	otherVrfsAttribute, ok := attributes["other_vrfs"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`other_vrfs is missing from object`)

		return nil, diags
	}

	otherVrfsVal, ok := otherVrfsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`other_vrfs expected to be basetypes.ListValue, was: %T`, otherVrfsAttribute))
	}

	routedAttribute, ok := attributes["routed"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`routed is missing from object`)

		return nil, diags
	}

	routedVal, ok := routedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`routed expected to be basetypes.BoolValue, was: %T`, routedAttribute))
	}

	sourceNatAttribute, ok := attributes["source_nat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`source_nat is missing from object`)

		return nil, diags
	}

	sourceNatVal, ok := sourceNatAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`source_nat expected to be basetypes.ObjectValue, was: %T`, sourceNatAttribute))
	}

	staticNatAttribute, ok := attributes["static_nat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`static_nat is missing from object`)

		return nil, diags
	}

	staticNatVal, ok := staticNatAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`static_nat expected to be basetypes.MapValue, was: %T`, staticNatAttribute))
	}

	summarizedSubnetAttribute, ok := attributes["summarized_subnet"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`summarized_subnet is missing from object`)

		return nil, diags
	}

	summarizedSubnetVal, ok := summarizedSubnetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`summarized_subnet expected to be basetypes.StringValue, was: %T`, summarizedSubnetAttribute))
	}

	summarizedSubnetToLanBgpAttribute, ok := attributes["summarized_subnet_to_lan_bgp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`summarized_subnet_to_lan_bgp is missing from object`)

		return nil, diags
	}

	summarizedSubnetToLanBgpVal, ok := summarizedSubnetToLanBgpAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`summarized_subnet_to_lan_bgp expected to be basetypes.StringValue, was: %T`, summarizedSubnetToLanBgpAttribute))
	}

	summarizedSubnetToLanOspfAttribute, ok := attributes["summarized_subnet_to_lan_ospf"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`summarized_subnet_to_lan_ospf is missing from object`)

		return nil, diags
	}

	summarizedSubnetToLanOspfVal, ok := summarizedSubnetToLanOspfAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`summarized_subnet_to_lan_ospf expected to be basetypes.StringValue, was: %T`, summarizedSubnetToLanOspfAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return VpnAccessValue{
		AdvertisedSubnet:          advertisedSubnetVal,
		AllowPing:                 allowPingVal,
		DestinationNat:            destinationNatVal,
		NatPool:                   natPoolVal,
		NoReadvertiseToLanBgp:     noReadvertiseToLanBgpVal,
		NoReadvertiseToLanOspf:    noReadvertiseToLanOspfVal,
		NoReadvertiseToOverlay:    noReadvertiseToOverlayVal,
		OtherVrfs:                 otherVrfsVal,
		Routed:                    routedVal,
		SourceNat:                 sourceNatVal,
		StaticNat:                 staticNatVal,
		SummarizedSubnet:          summarizedSubnetVal,
		SummarizedSubnetToLanBgp:  summarizedSubnetToLanBgpVal,
		SummarizedSubnetToLanOspf: summarizedSubnetToLanOspfVal,
		state:                     attr.ValueStateKnown,
	}, diags
}

func NewVpnAccessValueNull() VpnAccessValue {
	return VpnAccessValue{
		state: attr.ValueStateNull,
	}
}

func NewVpnAccessValueUnknown() VpnAccessValue {
	return VpnAccessValue{
		state: attr.ValueStateUnknown,
	}
}

func NewVpnAccessValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (VpnAccessValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing VpnAccessValue Attribute Value",
				"While creating a VpnAccessValue value, a missing attribute value was detected. "+
					"A VpnAccessValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VpnAccessValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid VpnAccessValue Attribute Type",
				"While creating a VpnAccessValue value, an invalid attribute value was detected. "+
					"A VpnAccessValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VpnAccessValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("VpnAccessValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra VpnAccessValue Attribute Value",
				"While creating a VpnAccessValue value, an extra attribute value was detected. "+
					"A VpnAccessValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra VpnAccessValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewVpnAccessValueUnknown(), diags
	}

	advertisedSubnetAttribute, ok := attributes["advertised_subnet"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`advertised_subnet is missing from object`)

		return NewVpnAccessValueUnknown(), diags
	}

	advertisedSubnetVal, ok := advertisedSubnetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`advertised_subnet expected to be basetypes.StringValue, was: %T`, advertisedSubnetAttribute))
	}

	allowPingAttribute, ok := attributes["allow_ping"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allow_ping is missing from object`)

		return NewVpnAccessValueUnknown(), diags
	}

	allowPingVal, ok := allowPingAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allow_ping expected to be basetypes.BoolValue, was: %T`, allowPingAttribute))
	}

	destinationNatAttribute, ok := attributes["destination_nat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`destination_nat is missing from object`)

		return NewVpnAccessValueUnknown(), diags
	}

	destinationNatVal, ok := destinationNatAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`destination_nat expected to be basetypes.MapValue, was: %T`, destinationNatAttribute))
	}

	natPoolAttribute, ok := attributes["nat_pool"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`nat_pool is missing from object`)

		return NewVpnAccessValueUnknown(), diags
	}

	natPoolVal, ok := natPoolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`nat_pool expected to be basetypes.StringValue, was: %T`, natPoolAttribute))
	}

	noReadvertiseToLanBgpAttribute, ok := attributes["no_readvertise_to_lan_bgp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`no_readvertise_to_lan_bgp is missing from object`)

		return NewVpnAccessValueUnknown(), diags
	}

	noReadvertiseToLanBgpVal, ok := noReadvertiseToLanBgpAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`no_readvertise_to_lan_bgp expected to be basetypes.BoolValue, was: %T`, noReadvertiseToLanBgpAttribute))
	}

	noReadvertiseToLanOspfAttribute, ok := attributes["no_readvertise_to_lan_ospf"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`no_readvertise_to_lan_ospf is missing from object`)

		return NewVpnAccessValueUnknown(), diags
	}

	noReadvertiseToLanOspfVal, ok := noReadvertiseToLanOspfAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`no_readvertise_to_lan_ospf expected to be basetypes.BoolValue, was: %T`, noReadvertiseToLanOspfAttribute))
	}

	noReadvertiseToOverlayAttribute, ok := attributes["no_readvertise_to_overlay"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`no_readvertise_to_overlay is missing from object`)

		return NewVpnAccessValueUnknown(), diags
	}

	noReadvertiseToOverlayVal, ok := noReadvertiseToOverlayAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`no_readvertise_to_overlay expected to be basetypes.BoolValue, was: %T`, noReadvertiseToOverlayAttribute))
	}

	otherVrfsAttribute, ok := attributes["other_vrfs"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`other_vrfs is missing from object`)

		return NewVpnAccessValueUnknown(), diags
	}

	otherVrfsVal, ok := otherVrfsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`other_vrfs expected to be basetypes.ListValue, was: %T`, otherVrfsAttribute))
	}

	routedAttribute, ok := attributes["routed"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`routed is missing from object`)

		return NewVpnAccessValueUnknown(), diags
	}

	routedVal, ok := routedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`routed expected to be basetypes.BoolValue, was: %T`, routedAttribute))
	}

	sourceNatAttribute, ok := attributes["source_nat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`source_nat is missing from object`)

		return NewVpnAccessValueUnknown(), diags
	}

	sourceNatVal, ok := sourceNatAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`source_nat expected to be basetypes.ObjectValue, was: %T`, sourceNatAttribute))
	}

	staticNatAttribute, ok := attributes["static_nat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`static_nat is missing from object`)

		return NewVpnAccessValueUnknown(), diags
	}

	staticNatVal, ok := staticNatAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`static_nat expected to be basetypes.MapValue, was: %T`, staticNatAttribute))
	}

	summarizedSubnetAttribute, ok := attributes["summarized_subnet"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`summarized_subnet is missing from object`)

		return NewVpnAccessValueUnknown(), diags
	}

	summarizedSubnetVal, ok := summarizedSubnetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`summarized_subnet expected to be basetypes.StringValue, was: %T`, summarizedSubnetAttribute))
	}

	summarizedSubnetToLanBgpAttribute, ok := attributes["summarized_subnet_to_lan_bgp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`summarized_subnet_to_lan_bgp is missing from object`)

		return NewVpnAccessValueUnknown(), diags
	}

	summarizedSubnetToLanBgpVal, ok := summarizedSubnetToLanBgpAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`summarized_subnet_to_lan_bgp expected to be basetypes.StringValue, was: %T`, summarizedSubnetToLanBgpAttribute))
	}

	summarizedSubnetToLanOspfAttribute, ok := attributes["summarized_subnet_to_lan_ospf"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`summarized_subnet_to_lan_ospf is missing from object`)

		return NewVpnAccessValueUnknown(), diags
	}

	summarizedSubnetToLanOspfVal, ok := summarizedSubnetToLanOspfAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`summarized_subnet_to_lan_ospf expected to be basetypes.StringValue, was: %T`, summarizedSubnetToLanOspfAttribute))
	}

	if diags.HasError() {
		return NewVpnAccessValueUnknown(), diags
	}

	return VpnAccessValue{
		AdvertisedSubnet:          advertisedSubnetVal,
		AllowPing:                 allowPingVal,
		DestinationNat:            destinationNatVal,
		NatPool:                   natPoolVal,
		NoReadvertiseToLanBgp:     noReadvertiseToLanBgpVal,
		NoReadvertiseToLanOspf:    noReadvertiseToLanOspfVal,
		NoReadvertiseToOverlay:    noReadvertiseToOverlayVal,
		OtherVrfs:                 otherVrfsVal,
		Routed:                    routedVal,
		SourceNat:                 sourceNatVal,
		StaticNat:                 staticNatVal,
		SummarizedSubnet:          summarizedSubnetVal,
		SummarizedSubnetToLanBgp:  summarizedSubnetToLanBgpVal,
		SummarizedSubnetToLanOspf: summarizedSubnetToLanOspfVal,
		state:                     attr.ValueStateKnown,
	}, diags
}

func NewVpnAccessValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) VpnAccessValue {
	object, diags := NewVpnAccessValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewVpnAccessValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t VpnAccessType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewVpnAccessValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewVpnAccessValueUnknown(), nil
	}

	if in.IsNull() {
		return NewVpnAccessValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewVpnAccessValueMust(VpnAccessValue{}.AttributeTypes(ctx), attributes), nil
}

func (t VpnAccessType) ValueType(ctx context.Context) attr.Value {
	return VpnAccessValue{}
}

var _ basetypes.ObjectValuable = VpnAccessValue{}

type VpnAccessValue struct {
	AdvertisedSubnet          basetypes.StringValue `tfsdk:"advertised_subnet"`
	AllowPing                 basetypes.BoolValue   `tfsdk:"allow_ping"`
	DestinationNat            basetypes.MapValue    `tfsdk:"destination_nat"`
	NatPool                   basetypes.StringValue `tfsdk:"nat_pool"`
	NoReadvertiseToLanBgp     basetypes.BoolValue   `tfsdk:"no_readvertise_to_lan_bgp"`
	NoReadvertiseToLanOspf    basetypes.BoolValue   `tfsdk:"no_readvertise_to_lan_ospf"`
	NoReadvertiseToOverlay    basetypes.BoolValue   `tfsdk:"no_readvertise_to_overlay"`
	OtherVrfs                 basetypes.ListValue   `tfsdk:"other_vrfs"`
	Routed                    basetypes.BoolValue   `tfsdk:"routed"`
	SourceNat                 basetypes.ObjectValue `tfsdk:"source_nat"`
	StaticNat                 basetypes.MapValue    `tfsdk:"static_nat"`
	SummarizedSubnet          basetypes.StringValue `tfsdk:"summarized_subnet"`
	SummarizedSubnetToLanBgp  basetypes.StringValue `tfsdk:"summarized_subnet_to_lan_bgp"`
	SummarizedSubnetToLanOspf basetypes.StringValue `tfsdk:"summarized_subnet_to_lan_ospf"`
	state                     attr.ValueState
}

func (v VpnAccessValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 14)

	var val tftypes.Value
	var err error

	attrTypes["advertised_subnet"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["allow_ping"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["destination_nat"] = basetypes.MapType{
		ElemType: DestinationNatValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["nat_pool"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["no_readvertise_to_lan_bgp"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["no_readvertise_to_lan_ospf"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["no_readvertise_to_overlay"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["other_vrfs"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["routed"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["source_nat"] = basetypes.ObjectType{
		AttrTypes: SourceNatValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["static_nat"] = basetypes.MapType{
		ElemType: StaticNatValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["summarized_subnet"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["summarized_subnet_to_lan_bgp"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["summarized_subnet_to_lan_ospf"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 14)

		val, err = v.AdvertisedSubnet.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["advertised_subnet"] = val

		val, err = v.AllowPing.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["allow_ping"] = val

		val, err = v.DestinationNat.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["destination_nat"] = val

		val, err = v.NatPool.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["nat_pool"] = val

		val, err = v.NoReadvertiseToLanBgp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["no_readvertise_to_lan_bgp"] = val

		val, err = v.NoReadvertiseToLanOspf.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["no_readvertise_to_lan_ospf"] = val

		val, err = v.NoReadvertiseToOverlay.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["no_readvertise_to_overlay"] = val

		val, err = v.OtherVrfs.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["other_vrfs"] = val

		val, err = v.Routed.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["routed"] = val

		val, err = v.SourceNat.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["source_nat"] = val

		val, err = v.StaticNat.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["static_nat"] = val

		val, err = v.SummarizedSubnet.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["summarized_subnet"] = val

		val, err = v.SummarizedSubnetToLanBgp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["summarized_subnet_to_lan_bgp"] = val

		val, err = v.SummarizedSubnetToLanOspf.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["summarized_subnet_to_lan_ospf"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v VpnAccessValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v VpnAccessValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v VpnAccessValue) String() string {
	return "VpnAccessValue"
}

func (v VpnAccessValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	destinationNat := types.MapValueMust(
		DestinationNatType{
			basetypes.ObjectType{
				AttrTypes: DestinationNatValue{}.AttributeTypes(ctx),
			},
		},
		v.DestinationNat.Elements(),
	)

	if v.DestinationNat.IsNull() {
		destinationNat = types.MapNull(
			DestinationNatType{
				basetypes.ObjectType{
					AttrTypes: DestinationNatValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.DestinationNat.IsUnknown() {
		destinationNat = types.MapUnknown(
			DestinationNatType{
				basetypes.ObjectType{
					AttrTypes: DestinationNatValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var sourceNat basetypes.ObjectValue

	if v.SourceNat.IsNull() {
		sourceNat = types.ObjectNull(
			SourceNatValue{}.AttributeTypes(ctx),
		)
	}

	if v.SourceNat.IsUnknown() {
		sourceNat = types.ObjectUnknown(
			SourceNatValue{}.AttributeTypes(ctx),
		)
	}

	if !v.SourceNat.IsNull() && !v.SourceNat.IsUnknown() {
		sourceNat = types.ObjectValueMust(
			SourceNatValue{}.AttributeTypes(ctx),
			v.SourceNat.Attributes(),
		)
	}

	staticNat := types.MapValueMust(
		StaticNatType{
			basetypes.ObjectType{
				AttrTypes: StaticNatValue{}.AttributeTypes(ctx),
			},
		},
		v.StaticNat.Elements(),
	)

	if v.StaticNat.IsNull() {
		staticNat = types.MapNull(
			StaticNatType{
				basetypes.ObjectType{
					AttrTypes: StaticNatValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.StaticNat.IsUnknown() {
		staticNat = types.MapUnknown(
			StaticNatType{
				basetypes.ObjectType{
					AttrTypes: StaticNatValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	otherVrfsVal, d := types.ListValue(types.StringType, v.OtherVrfs.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"advertised_subnet": basetypes.StringType{},
			"allow_ping":        basetypes.BoolType{},
			"destination_nat": basetypes.MapType{
				ElemType: DestinationNatValue{}.Type(ctx),
			},
			"nat_pool":                   basetypes.StringType{},
			"no_readvertise_to_lan_bgp":  basetypes.BoolType{},
			"no_readvertise_to_lan_ospf": basetypes.BoolType{},
			"no_readvertise_to_overlay":  basetypes.BoolType{},
			"other_vrfs": basetypes.ListType{
				ElemType: types.StringType,
			},
			"routed": basetypes.BoolType{},
			"source_nat": basetypes.ObjectType{
				AttrTypes: SourceNatValue{}.AttributeTypes(ctx),
			},
			"static_nat": basetypes.MapType{
				ElemType: StaticNatValue{}.Type(ctx),
			},
			"summarized_subnet":             basetypes.StringType{},
			"summarized_subnet_to_lan_bgp":  basetypes.StringType{},
			"summarized_subnet_to_lan_ospf": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"advertised_subnet": basetypes.StringType{},
		"allow_ping":        basetypes.BoolType{},
		"destination_nat": basetypes.MapType{
			ElemType: DestinationNatValue{}.Type(ctx),
		},
		"nat_pool":                   basetypes.StringType{},
		"no_readvertise_to_lan_bgp":  basetypes.BoolType{},
		"no_readvertise_to_lan_ospf": basetypes.BoolType{},
		"no_readvertise_to_overlay":  basetypes.BoolType{},
		"other_vrfs": basetypes.ListType{
			ElemType: types.StringType,
		},
		"routed": basetypes.BoolType{},
		"source_nat": basetypes.ObjectType{
			AttrTypes: SourceNatValue{}.AttributeTypes(ctx),
		},
		"static_nat": basetypes.MapType{
			ElemType: StaticNatValue{}.Type(ctx),
		},
		"summarized_subnet":             basetypes.StringType{},
		"summarized_subnet_to_lan_bgp":  basetypes.StringType{},
		"summarized_subnet_to_lan_ospf": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"advertised_subnet":             v.AdvertisedSubnet,
			"allow_ping":                    v.AllowPing,
			"destination_nat":               destinationNat,
			"nat_pool":                      v.NatPool,
			"no_readvertise_to_lan_bgp":     v.NoReadvertiseToLanBgp,
			"no_readvertise_to_lan_ospf":    v.NoReadvertiseToLanOspf,
			"no_readvertise_to_overlay":     v.NoReadvertiseToOverlay,
			"other_vrfs":                    otherVrfsVal,
			"routed":                        v.Routed,
			"source_nat":                    sourceNat,
			"static_nat":                    staticNat,
			"summarized_subnet":             v.SummarizedSubnet,
			"summarized_subnet_to_lan_bgp":  v.SummarizedSubnetToLanBgp,
			"summarized_subnet_to_lan_ospf": v.SummarizedSubnetToLanOspf,
		})

	return objVal, diags
}

func (v VpnAccessValue) Equal(o attr.Value) bool {
	other, ok := o.(VpnAccessValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AdvertisedSubnet.Equal(other.AdvertisedSubnet) {
		return false
	}

	if !v.AllowPing.Equal(other.AllowPing) {
		return false
	}

	if !v.DestinationNat.Equal(other.DestinationNat) {
		return false
	}

	if !v.NatPool.Equal(other.NatPool) {
		return false
	}

	if !v.NoReadvertiseToLanBgp.Equal(other.NoReadvertiseToLanBgp) {
		return false
	}

	if !v.NoReadvertiseToLanOspf.Equal(other.NoReadvertiseToLanOspf) {
		return false
	}

	if !v.NoReadvertiseToOverlay.Equal(other.NoReadvertiseToOverlay) {
		return false
	}

	if !v.OtherVrfs.Equal(other.OtherVrfs) {
		return false
	}

	if !v.Routed.Equal(other.Routed) {
		return false
	}

	if !v.SourceNat.Equal(other.SourceNat) {
		return false
	}

	if !v.StaticNat.Equal(other.StaticNat) {
		return false
	}

	if !v.SummarizedSubnet.Equal(other.SummarizedSubnet) {
		return false
	}

	if !v.SummarizedSubnetToLanBgp.Equal(other.SummarizedSubnetToLanBgp) {
		return false
	}

	if !v.SummarizedSubnetToLanOspf.Equal(other.SummarizedSubnetToLanOspf) {
		return false
	}

	return true
}

func (v VpnAccessValue) Type(ctx context.Context) attr.Type {
	return VpnAccessType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v VpnAccessValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"advertised_subnet": basetypes.StringType{},
		"allow_ping":        basetypes.BoolType{},
		"destination_nat": basetypes.MapType{
			ElemType: DestinationNatValue{}.Type(ctx),
		},
		"nat_pool":                   basetypes.StringType{},
		"no_readvertise_to_lan_bgp":  basetypes.BoolType{},
		"no_readvertise_to_lan_ospf": basetypes.BoolType{},
		"no_readvertise_to_overlay":  basetypes.BoolType{},
		"other_vrfs": basetypes.ListType{
			ElemType: types.StringType,
		},
		"routed": basetypes.BoolType{},
		"source_nat": basetypes.ObjectType{
			AttrTypes: SourceNatValue{}.AttributeTypes(ctx),
		},
		"static_nat": basetypes.MapType{
			ElemType: StaticNatValue{}.Type(ctx),
		},
		"summarized_subnet":             basetypes.StringType{},
		"summarized_subnet_to_lan_bgp":  basetypes.StringType{},
		"summarized_subnet_to_lan_ospf": basetypes.StringType{},
	}
}






















var _ basetypes.ObjectTypable = SourceNatType{}

type SourceNatType struct {
	basetypes.ObjectType
}

func (t SourceNatType) Equal(o attr.Type) bool {
	other, ok := o.(SourceNatType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SourceNatType) String() string {
	return "SourceNatType"
}

func (t SourceNatType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	exteralIpAttribute, ok := attributes["exteral_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`exteral_ip is missing from object`)

		return nil, diags
	}

	exteralIpVal, ok := exteralIpAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`exteral_ip expected to be basetypes.StringValue, was: %T`, exteralIpAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SourceNatValue{
		ExteralIp: exteralIpVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewSourceNatValueNull() SourceNatValue {
	return SourceNatValue{
		state: attr.ValueStateNull,
	}
}

func NewSourceNatValueUnknown() SourceNatValue {
	return SourceNatValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSourceNatValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SourceNatValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SourceNatValue Attribute Value",
				"While creating a SourceNatValue value, a missing attribute value was detected. "+
					"A SourceNatValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SourceNatValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SourceNatValue Attribute Type",
				"While creating a SourceNatValue value, an invalid attribute value was detected. "+
					"A SourceNatValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SourceNatValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SourceNatValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SourceNatValue Attribute Value",
				"While creating a SourceNatValue value, an extra attribute value was detected. "+
					"A SourceNatValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SourceNatValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSourceNatValueUnknown(), diags
	}

	exteralIpAttribute, ok := attributes["exteral_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`exteral_ip is missing from object`)

		return NewSourceNatValueUnknown(), diags
	}

	exteralIpVal, ok := exteralIpAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`exteral_ip expected to be basetypes.StringValue, was: %T`, exteralIpAttribute))
	}

	if diags.HasError() {
		return NewSourceNatValueUnknown(), diags
	}

	return SourceNatValue{
		ExteralIp: exteralIpVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewSourceNatValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SourceNatValue {
	object, diags := NewSourceNatValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSourceNatValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SourceNatType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSourceNatValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSourceNatValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSourceNatValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSourceNatValueMust(SourceNatValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SourceNatType) ValueType(ctx context.Context) attr.Value {
	return SourceNatValue{}
}

var _ basetypes.ObjectValuable = SourceNatValue{}

type SourceNatValue struct {
	ExteralIp basetypes.StringValue `tfsdk:"exteral_ip"`
	state     attr.ValueState
}

func (v SourceNatValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["exteral_ip"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.ExteralIp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["exteral_ip"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SourceNatValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SourceNatValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SourceNatValue) String() string {
	return "SourceNatValue"
}

func (v SourceNatValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"exteral_ip": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"exteral_ip": v.ExteralIp,
		})

	return objVal, diags
}

func (v SourceNatValue) Equal(o attr.Value) bool {
	other, ok := o.(SourceNatValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.ExteralIp.Equal(other.ExteralIp) {
		return false
	}

	return true
}

func (v SourceNatValue) Type(ctx context.Context) attr.Type {
	return SourceNatType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SourceNatValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"exteral_ip": basetypes.StringType{},
	}
}





















