// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package resource_org_networktemplate

import (
	"context"
	"fmt"
	"github.com/Juniper/terraform-provider-mist/internal/validators"
	"github.com/hashicorp/terraform-plugin-framework-validators/int64validator"
	"github.com/hashicorp/terraform-plugin-framework-validators/listvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/mapvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/objectvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/booldefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/int64default"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/listdefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
)

func OrgNetworktemplateResourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"acl_policies": schema.ListNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"actions": schema.ListNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"action": schema.StringAttribute{
										Optional:            true,
										Description:         "enum: `allow`, `deny`",
										MarkdownDescription: "enum: `allow`, `deny`",
										Validators: []validator.String{
											stringvalidator.OneOf(
												"",
												"allow",
												"deny",
											),
										},
									},
									"dst_tag": schema.StringAttribute{
										Required: true,
									},
								},
								CustomType: ActionsType{
									ObjectType: types.ObjectType{
										AttrTypes: ActionsValue{}.AttributeTypes(ctx),
									},
								},
							},
							Optional:            true,
							Description:         "ACL Policy Actions:\n  - for GBP-based policy, all src_tags and dst_tags have to be gbp-based\n  - for ACL-based policy, `network` is required in either the source or destination so that we know where to attach the policy to",
							MarkdownDescription: "ACL Policy Actions:\n  - for GBP-based policy, all src_tags and dst_tags have to be gbp-based\n  - for ACL-based policy, `network` is required in either the source or destination so that we know where to attach the policy to",
							Validators: []validator.List{
								listvalidator.SizeAtLeast(1),
							},
						},
						"name": schema.StringAttribute{
							Optional: true,
						},
						"src_tags": schema.ListAttribute{
							ElementType:         types.StringType,
							Optional:            true,
							Description:         "ACL Policy Source Tags:\n  - for GBP-based policy, all src_tags and dst_tags have to be gbp-based\n  - for ACL-based policy, `network` is required in either the source or destination so that we know where to attach the policy to",
							MarkdownDescription: "ACL Policy Source Tags:\n  - for GBP-based policy, all src_tags and dst_tags have to be gbp-based\n  - for ACL-based policy, `network` is required in either the source or destination so that we know where to attach the policy to",
							Validators: []validator.List{
								listvalidator.SizeAtLeast(1),
							},
						},
					},
					CustomType: AclPoliciesType{
						ObjectType: types.ObjectType{
							AttrTypes: AclPoliciesValue{}.AttributeTypes(ctx),
						},
					},
				},
				Optional: true,
				Validators: []validator.List{
					listvalidator.SizeAtLeast(1),
				},
			},
			"acl_tags": schema.MapNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"ether_types": schema.ListAttribute{
							ElementType:         types.StringType,
							Optional:            true,
							Description:         "ARP / IPv6. Default is `any`",
							MarkdownDescription: "ARP / IPv6. Default is `any`",
							Validators: []validator.List{
								listvalidator.SizeAtLeast(1),
							},
						},
						"gbp_tag": schema.Int64Attribute{
							Optional:            true,
							Description:         "Required if\n  - `type`==`dynamic_gbp` (gbp_tag received from RADIUS)\n  - `type`==`gbp_resource`\n  - `type`==`static_gbp` (applying gbp tag against matching conditions)",
							MarkdownDescription: "Required if\n  - `type`==`dynamic_gbp` (gbp_tag received from RADIUS)\n  - `type`==`gbp_resource`\n  - `type`==`static_gbp` (applying gbp tag against matching conditions)",
							Validators: []validator.Int64{
								mistvalidator.RequiredWhenValueIs(path.MatchRelative().AtParent().AtName("type"), types.StringValue("dynamic_gbp")),
								mistvalidator.RequiredWhenValueIs(path.MatchRelative().AtParent().AtName("type"), types.StringValue("static_gbp")),
							},
						},
						"macs": schema.ListAttribute{
							ElementType:         types.StringType,
							Optional:            true,
							Description:         "Required if \n- `type`==`mac`\n- `type`==`static_gbp` if from matching mac",
							MarkdownDescription: "Required if \n- `type`==`mac`\n- `type`==`static_gbp` if from matching mac",
							Validators: []validator.List{
								mistvalidator.RequiredWhenValueIs(path.MatchRelative().AtParent().AtName("type"), types.StringValue("mac")),
								listvalidator.SizeAtLeast(1),
							},
						},
						"network": schema.StringAttribute{
							Optional:            true,
							Description:         "If:\n  * `type`==`mac` (optional. default is `any`)\n  * `type`==`subnet` (optional. default is `any`)\n  * `type`==`network`\n  * `type`==`resource` (optional. default is `any`)\n  * `type`==`static_gbp` if from matching network (vlan)",
							MarkdownDescription: "If:\n  * `type`==`mac` (optional. default is `any`)\n  * `type`==`subnet` (optional. default is `any`)\n  * `type`==`network`\n  * `type`==`resource` (optional. default is `any`)\n  * `type`==`static_gbp` if from matching network (vlan)",
							Validators: []validator.String{
								mistvalidator.RequiredWhenValueIs(path.MatchRelative().AtParent().AtName("type"), types.StringValue("network")),
							},
						},
						"port_usage": schema.StringAttribute{
							Optional:            true,
							Description:         "Required if `type`==`port_usage`",
							MarkdownDescription: "Required if `type`==`port_usage`",
						},
						"radius_group": schema.StringAttribute{
							Optional:            true,
							Description:         "Required if:\n  * `type`==`radius_group`\n  * `type`==`static_gbp`\nif from matching radius_group",
							MarkdownDescription: "Required if:\n  * `type`==`radius_group`\n  * `type`==`static_gbp`\nif from matching radius_group",
							Validators: []validator.String{
								mistvalidator.RequiredWhenValueIs(path.MatchRelative().AtParent().AtName("type"), types.StringValue("radius_group")),
							},
						},
						"specs": schema.ListNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"port_range": schema.StringAttribute{
										Optional:            true,
										Computed:            true,
										Description:         "Matched dst port, \"0\" means any",
										MarkdownDescription: "Matched dst port, \"0\" means any",
										Validators: []validator.String{
											mistvalidator.AllowedWhenValueIsIn(
												path.MatchRelative().AtParent().AtName("protocol"),
												[]attr.Value{
													types.StringValue("any"),
													types.StringValue("tcp"),
													types.StringValue("udp"),
												},
											),
											stringvalidator.Any(
												mistvalidator.ParseInt(0, 65535),
												mistvalidator.ParseRangeOfInt(0, 65535, true),
											),
										},
										Default: stringdefault.StaticString("0"),
									},
									"protocol": schema.StringAttribute{
										Optional:            true,
										Computed:            true,
										Description:         "`tcp` / `udp` / `icmp` / `icmp6` / `gre` / `any` / `:protocol_number`, `protocol_number` is between 1-254, default is `any` `protocol_number` is between 1-254",
										MarkdownDescription: "`tcp` / `udp` / `icmp` / `icmp6` / `gre` / `any` / `:protocol_number`, `protocol_number` is between 1-254, default is `any` `protocol_number` is between 1-254",
										Validators: []validator.String{
											stringvalidator.Any(
												stringvalidator.OneOf(
													"https",
													"tcp",
													"udp",
													"icmp",
													"gre",
													"any",
												),
												mistvalidator.ParseInt(1, 254),
											),
										},
										Default: stringdefault.StaticString("any"),
									},
								},
								CustomType: SpecsType{
									ObjectType: types.ObjectType{
										AttrTypes: SpecsValue{}.AttributeTypes(ctx),
									},
								},
							},
							Optional:            true,
							Description:         "If `type`==`resource`, `type`==`radius_group`, `type`==`port_usage` or `type`==`gbp_resource`. Empty means unrestricted, i.e. any",
							MarkdownDescription: "If `type`==`resource`, `type`==`radius_group`, `type`==`port_usage` or `type`==`gbp_resource`. Empty means unrestricted, i.e. any",
							Validators: []validator.List{
								listvalidator.SizeAtLeast(1),
							},
						},
						"subnets": schema.ListAttribute{
							ElementType:         types.StringType,
							Optional:            true,
							Description:         "If \n- `type`==`subnet` \n- `type`==`resource` (optional. default is `any`)\n- `type`==`static_gbp` if from matching subnet",
							MarkdownDescription: "If \n- `type`==`subnet` \n- `type`==`resource` (optional. default is `any`)\n- `type`==`static_gbp` if from matching subnet",
							Validators: []validator.List{
								mistvalidator.RequiredWhenValueIs(path.MatchRelative().AtParent().AtName("type"), types.StringValue("subnet")),
								listvalidator.SizeAtLeast(1),
							},
						},
						"type": schema.StringAttribute{
							Required:            true,
							Description:         "enum: \n  * `any`: matching anything not identified\n  * `dynamic_gbp`: from the gbp_tag received from RADIUS\n  * `gbp_resource`: can only be used in `dst_tags`\n  * `mac`\n  * `network`\n  * `port_usage`\n  * `radius_group`\n  * `resource`: can only be used in `dst_tags`\n  * `static_gbp`: applying gbp tag against matching conditions\n  * `subnet`'",
							MarkdownDescription: "enum: \n  * `any`: matching anything not identified\n  * `dynamic_gbp`: from the gbp_tag received from RADIUS\n  * `gbp_resource`: can only be used in `dst_tags`\n  * `mac`\n  * `network`\n  * `port_usage`\n  * `radius_group`\n  * `resource`: can only be used in `dst_tags`\n  * `static_gbp`: applying gbp tag against matching conditions\n  * `subnet`'",
							Validators: []validator.String{
								stringvalidator.OneOf(
									"",
									"any",
									"dynamic_gbp",
									"gbp_resource",
									"mac",
									"network",
									"port_usage",
									"radius_group",
									"resource",
									"static_gbp",
									"subnet",
								),
							},
						},
					},
					CustomType: AclTagsType{
						ObjectType: types.ObjectType{
							AttrTypes: AclTagsValue{}.AttributeTypes(ctx),
						},
					},
				},
				Optional:            true,
				Description:         "ACL Tags to identify traffic source or destination. Key name is the tag name",
				MarkdownDescription: "ACL Tags to identify traffic source or destination. Key name is the tag name",
				Validators: []validator.Map{
					mapvalidator.SizeAtLeast(1),
				},
			},
			"additional_config_cmds": schema.ListAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Description:         "additional CLI commands to append to the generated Junos config. **Note**: no check is done",
				MarkdownDescription: "additional CLI commands to append to the generated Junos config. **Note**: no check is done",
				Validators: []validator.List{
					listvalidator.SizeAtLeast(1),
				},
			},
			"bgp_config": schema.MapNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"auth_key": schema.StringAttribute{
							Optional: true,
						},
						"bfd_minimum_interval": schema.Int64Attribute{
							Optional:            true,
							Description:         "Minimum interval in milliseconds for BFD hello packets. A neighbor is considered failed when the device stops receiving replies after the specified interval. Value must be between 1 and 255000.",
							MarkdownDescription: "Minimum interval in milliseconds for BFD hello packets. A neighbor is considered failed when the device stops receiving replies after the specified interval. Value must be between 1 and 255000.",
							Validators: []validator.Int64{
								int64validator.Between(1, 255000),
							},
						},
						"export_policy": schema.StringAttribute{
							Optional:            true,
							Description:         "Export policy must match one of the policy names defined in the `routing_policies` property.",
							MarkdownDescription: "Export policy must match one of the policy names defined in the `routing_policies` property.",
						},
						"hold_time": schema.Int64Attribute{
							Optional:            true,
							Description:         "Hold time is three times the interval at which keepalive messages are sent. It indicates to the peer the length of time that it should consider the sender valid. Must be 0 or a number in the range 3-65535.",
							MarkdownDescription: "Hold time is three times the interval at which keepalive messages are sent. It indicates to the peer the length of time that it should consider the sender valid. Must be 0 or a number in the range 3-65535.",
							Validators: []validator.Int64{
								int64validator.Any(int64validator.OneOf(0), int64validator.Between(3, 65535)),
							},
						},
						"import_policy": schema.StringAttribute{
							Optional:            true,
							Description:         "Import policy must match one of the policy names defined in the `routing_policies` property.",
							MarkdownDescription: "Import policy must match one of the policy names defined in the `routing_policies` property.",
						},
						"local_as": schema.StringAttribute{
							Required: true,
							Validators: []validator.String{
								stringvalidator.Any(mistvalidator.ParseInt(1, 4294967294), mistvalidator.ParseVar()),
							},
						},
						"neighbors": schema.MapNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"export_policy": schema.StringAttribute{
										Optional:            true,
										Description:         "Export policy must match one of the policy names defined in the `routing_policies` property.",
										MarkdownDescription: "Export policy must match one of the policy names defined in the `routing_policies` property.",
									},
									"hold_time": schema.Int64Attribute{
										Optional:            true,
										Description:         "Hold time is three times the interval at which keepalive messages are sent. It indicates to the peer the length of time that it should consider the sender valid. Must be 0 or a number in the range 3-65535.",
										MarkdownDescription: "Hold time is three times the interval at which keepalive messages are sent. It indicates to the peer the length of time that it should consider the sender valid. Must be 0 or a number in the range 3-65535.",
										Validators: []validator.Int64{
											int64validator.Any(int64validator.OneOf(0), int64validator.Between(3, 65535)),
										},
									},
									"import_policy": schema.StringAttribute{
										Optional:            true,
										Description:         "Import policy must match one of the policy names defined in the `routing_policies` property.",
										MarkdownDescription: "Import policy must match one of the policy names defined in the `routing_policies` property.",
									},
									"multihop_ttl": schema.Int64Attribute{
										Optional: true,
										Validators: []validator.Int64{
											int64validator.Between(1, 255),
										},
									},
									"neighbor_as": schema.StringAttribute{
										Required:            true,
										Description:         "Autonomous System (AS) number of the BGP neighbor. For internal BGP, this must match `local_as`. For external BGP, this must differ from `local_as`.",
										MarkdownDescription: "Autonomous System (AS) number of the BGP neighbor. For internal BGP, this must match `local_as`. For external BGP, this must differ from `local_as`.",
										Validators: []validator.String{
											stringvalidator.Any(mistvalidator.ParseInt(1, 4294967294), mistvalidator.ParseVar()),
											mistvalidator.MustMatchWhenValueIs(
												path.MatchRelative().AtParent().AtParent().AtParent().AtName("type"),
												types.StringValue("internal"),
												path.MatchRelative().AtParent().AtParent().AtParent().AtName("local_as"),
											),
											mistvalidator.MustDifferWhenValueIs(
												path.MatchRelative().AtParent().AtParent().AtParent().AtName("type"),
												types.StringValue("external"),
												path.MatchRelative().AtParent().AtParent().AtParent().AtName("local_as"),
											),
										},
									},
								},
								CustomType: NeighborsType{
									ObjectType: types.ObjectType{
										AttrTypes: NeighborsValue{}.AttributeTypes(ctx),
									},
								},
							},
							Optional:            true,
							Description:         "Property key is the BGP Neighbor IP Address.",
							MarkdownDescription: "Property key is the BGP Neighbor IP Address.",
							Validators: []validator.Map{
								mapvalidator.SizeAtLeast(1),
							},
						},
						"networks": schema.ListAttribute{
							ElementType:         types.StringType,
							Optional:            true,
							Description:         "List of network names for BGP configuration. When a network is specified, a BGP group will be added to the VRF that network is part of.",
							MarkdownDescription: "List of network names for BGP configuration. When a network is specified, a BGP group will be added to the VRF that network is part of.",
						},
						"type": schema.StringAttribute{
							Required:            true,
							Description:         "enum: `external`, `internal`",
							MarkdownDescription: "enum: `external`, `internal`",
							Validators: []validator.String{
								stringvalidator.OneOf("external", "internal"),
							},
						},
					},
					CustomType: BgpConfigType{
						ObjectType: types.ObjectType{
							AttrTypes: BgpConfigValue{}.AttributeTypes(ctx),
						},
					},
				},
				Optional: true,
				Validators: []validator.Map{
					mapvalidator.SizeAtLeast(1),
				},
			},
			"dhcp_snooping": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"all_networks": schema.BoolAttribute{
						Optional: true,
					},
					"enable_arp_spoof_check": schema.BoolAttribute{
						Optional:            true,
						Description:         "Enable for dynamic ARP inspection check",
						MarkdownDescription: "Enable for dynamic ARP inspection check",
					},
					"enable_ip_source_guard": schema.BoolAttribute{
						Optional:            true,
						Description:         "Enable for check for forging source IP address",
						MarkdownDescription: "Enable for check for forging source IP address",
					},
					"enabled": schema.BoolAttribute{
						Optional: true,
					},
					"networks": schema.ListAttribute{
						ElementType:         types.StringType,
						Optional:            true,
						Description:         "If `all_networks`==`false`, list of network with DHCP snooping enabled",
						MarkdownDescription: "If `all_networks`==`false`, list of network with DHCP snooping enabled",
						Validators: []validator.List{
							mistvalidator.ForbiddenWhenValueIs(path.MatchRelative().AtParent().AtName("all_networks"), types.BoolValue(true)),
							listvalidator.SizeAtLeast(1),
						},
					},
				},
				CustomType: DhcpSnoopingType{
					ObjectType: types.ObjectType{
						AttrTypes: DhcpSnoopingValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
			},
			"dns_servers": schema.ListAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Computed:            true,
				Description:         "Global dns settings. To keep compatibility, dns settings in `ip_config` and `oob_ip_config` will overwrite this setting",
				MarkdownDescription: "Global dns settings. To keep compatibility, dns settings in `ip_config` and `oob_ip_config` will overwrite this setting",
				Validators: []validator.List{
					listvalidator.ValueStringsAre(
						stringvalidator.Any(
							mistvalidator.ParseIp(true, false),
							mistvalidator.ParseVar(),
						),
					),
					listvalidator.SizeAtLeast(1),
				},
				Default: listdefault.StaticValue(basetypes.NewListValueMust(basetypes.StringType{}, []attr.Value{})),
			},
			"dns_suffix": schema.ListAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Computed:            true,
				Description:         "Global dns settings. To keep compatibility, dns settings in `ip_config` and `oob_ip_config` will overwrite this setting",
				MarkdownDescription: "Global dns settings. To keep compatibility, dns settings in `ip_config` and `oob_ip_config` will overwrite this setting",
				Default:             listdefault.StaticValue(basetypes.NewListValueMust(basetypes.StringType{}, []attr.Value{})),
			},
			"extra_routes": schema.MapNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"discard": schema.BoolAttribute{
							Optional:            true,
							Description:         "This takes precedence",
							MarkdownDescription: "This takes precedence",
						},
						"metric": schema.Int64Attribute{
							Optional: true,
							Validators: []validator.Int64{
								int64validator.Between(0, 2147483647),
							},
						},
						"next_qualified": schema.MapNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"metric": schema.Int64Attribute{
										Optional: true,
									},
									"preference": schema.Int64Attribute{
										Optional: true,
									},
								},
								CustomType: NextQualifiedType{
									ObjectType: types.ObjectType{
										AttrTypes: NextQualifiedValue{}.AttributeTypes(ctx),
									},
								},
							},
							Optional: true,
							Validators: []validator.Map{
								mapvalidator.SizeAtLeast(1),
							},
						},
						"no_resolve": schema.BoolAttribute{
							Optional: true,
						},
						"preference": schema.Int64Attribute{
							Optional: true,
							Validators: []validator.Int64{
								int64validator.Between(0, 2147483647),
							},
						},
						"via": schema.StringAttribute{
							Required:            true,
							Description:         "Next-hop IP Address",
							MarkdownDescription: "Next-hop IP Address",
							Validators: []validator.String{
								stringvalidator.Any(mistvalidator.ParseIp(true, false), mistvalidator.ParseVar()),
							},
						},
					},
					CustomType: ExtraRoutesType{
						ObjectType: types.ObjectType{
							AttrTypes: ExtraRoutesValue{}.AttributeTypes(ctx),
						},
					},
				},
				Optional:            true,
				Description:         "Property key is the destination CIDR (e.g. \"10.0.0.0/8\")",
				MarkdownDescription: "Property key is the destination CIDR (e.g. \"10.0.0.0/8\")",
				Validators: []validator.Map{
					mapvalidator.SizeAtLeast(1), mapvalidator.KeysAre(stringvalidator.Any(mistvalidator.ParseCidr(true, false), mistvalidator.ParseVar())),
				},
			},
			"extra_routes6": schema.MapNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"discard": schema.BoolAttribute{
							Optional:            true,
							Description:         "This takes precedence",
							MarkdownDescription: "This takes precedence",
						},
						"metric": schema.Int64Attribute{
							Optional: true,
							Validators: []validator.Int64{
								int64validator.Between(0, 2147483647),
							},
						},
						"next_qualified": schema.MapNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"metric": schema.Int64Attribute{
										Optional: true,
									},
									"preference": schema.Int64Attribute{
										Optional: true,
									},
								},
								CustomType: NextQualifiedType{
									ObjectType: types.ObjectType{
										AttrTypes: NextQualifiedValue{}.AttributeTypes(ctx),
									},
								},
							},
							Optional: true,
							Validators: []validator.Map{
								mapvalidator.SizeAtLeast(1),
							},
						},
						"no_resolve": schema.BoolAttribute{
							Optional: true,
						},
						"preference": schema.Int64Attribute{
							Optional: true,
							Validators: []validator.Int64{
								int64validator.Between(0, 2147483647),
							},
						},
						"via": schema.StringAttribute{
							Required:            true,
							Description:         "Next-hop IP Address",
							MarkdownDescription: "Next-hop IP Address",
							Validators: []validator.String{
								stringvalidator.Any(mistvalidator.ParseIp(false, true), mistvalidator.ParseVar()),
							},
						},
					},
					CustomType: ExtraRoutes6Type{
						ObjectType: types.ObjectType{
							AttrTypes: ExtraRoutes6Value{}.AttributeTypes(ctx),
						},
					},
				},
				Optional:            true,
				Description:         "Property key is the destination CIDR (e.g. \"2a02:1234:420a:10c9::/64\")",
				MarkdownDescription: "Property key is the destination CIDR (e.g. \"2a02:1234:420a:10c9::/64\")",
				Validators: []validator.Map{
					mapvalidator.SizeAtLeast(1), mapvalidator.KeysAre(stringvalidator.Any(mistvalidator.ParseCidr(false, true), mistvalidator.ParseVar())),
				},
			},
			"id": schema.StringAttribute{
				Computed:            true,
				Description:         "Unique ID of the object instance in the Mist Organization",
				MarkdownDescription: "Unique ID of the object instance in the Mist Organization",
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"mist_nac": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"enabled": schema.BoolAttribute{
						Optional: true,
					},
					"network": schema.StringAttribute{
						Optional: true,
					},
				},
				CustomType: MistNacType{
					ObjectType: types.ObjectType{
						AttrTypes: MistNacValue{}.AttributeTypes(ctx),
					},
				},
				Optional:            true,
				Description:         "Enable mist_nac to use RadSec",
				MarkdownDescription: "Enable mist_nac to use RadSec",
			},
			"name": schema.StringAttribute{
				Required: true,
				Validators: []validator.String{
					stringvalidator.LengthBetween(2, 32),
				},
			},
			"networks": schema.MapNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"gateway": schema.StringAttribute{
							Optional:            true,
							Description:         "Only required for EVPN-VXLAN networks, IPv4 Virtual Gateway",
							MarkdownDescription: "Only required for EVPN-VXLAN networks, IPv4 Virtual Gateway",
							Validators: []validator.String{
								stringvalidator.Any(mistvalidator.ParseIp(true, false), mistvalidator.ParseVar()),
							},
						},
						"gateway6": schema.StringAttribute{
							Optional:            true,
							Description:         "Only required for EVPN-VXLAN networks, IPv6 Virtual Gateway",
							MarkdownDescription: "Only required for EVPN-VXLAN networks, IPv6 Virtual Gateway",
							Validators: []validator.String{
								stringvalidator.Any(mistvalidator.ParseIp(false, true), mistvalidator.ParseVar()),
							},
						},
						"isolation": schema.BoolAttribute{
							Optional:            true,
							Description:         "whether to stop clients to talk to each other, default is false (when enabled, a unique isolation_vlan_id is required). NOTE: this features requires uplink device to also a be Juniper device and `inter_switch_link` to be set. See also `inter_isolation_network_link` and `community_vlan_id` in port_usage",
							MarkdownDescription: "whether to stop clients to talk to each other, default is false (when enabled, a unique isolation_vlan_id is required). NOTE: this features requires uplink device to also a be Juniper device and `inter_switch_link` to be set. See also `inter_isolation_network_link` and `community_vlan_id` in port_usage",
						},
						"isolation_vlan_id": schema.StringAttribute{
							Optional: true,
						},
						"subnet": schema.StringAttribute{
							Optional:            true,
							Description:         "Optional for pure switching, required when L3 / routing features are used",
							MarkdownDescription: "Optional for pure switching, required when L3 / routing features are used",
							Validators: []validator.String{
								stringvalidator.Any(mistvalidator.ParseCidr(true, false), mistvalidator.ParseVar()),
							},
						},
						"subnet6": schema.StringAttribute{
							Optional:            true,
							Description:         "Optional for pure switching, required when L3 / routing features are used",
							MarkdownDescription: "Optional for pure switching, required when L3 / routing features are used",
							Validators: []validator.String{
								stringvalidator.Any(mistvalidator.ParseCidr(false, true), mistvalidator.ParseVar()),
							},
						},
						"vlan_id": schema.StringAttribute{
							Required: true,
							Validators: []validator.String{
								stringvalidator.Any(mistvalidator.ParseInt(1, 4094), mistvalidator.ParseVar()),
							},
						},
					},
					CustomType: NetworksType{
						ObjectType: types.ObjectType{
							AttrTypes: NetworksValue{}.AttributeTypes(ctx),
						},
					},
				},
				Optional:            true,
				Description:         "Property key is network name",
				MarkdownDescription: "Property key is network name",
				Validators: []validator.Map{
					mapvalidator.SizeAtLeast(1),
					mapvalidator.KeysAre(stringvalidator.All(
						stringvalidator.LengthBetween(2, 32),
						mistvalidator.ParseName()),
					),
				},
			},
			"ntp_servers": schema.ListAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Computed:            true,
				Description:         "List of NTP servers specific to this device. By default, those in Site Settings will be used",
				MarkdownDescription: "List of NTP servers specific to this device. By default, those in Site Settings will be used",
				Default:             listdefault.StaticValue(basetypes.NewListValueMust(basetypes.StringType{}, []attr.Value{})),
			},
			"org_id": schema.StringAttribute{
				Required: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"ospf_areas": schema.MapNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"include_loopback": schema.BoolAttribute{
							Optional: true,
							Computed: true,
							Default:  booldefault.StaticBool(false),
						},
						"networks": schema.MapNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"auth_keys": schema.MapAttribute{
										ElementType:         types.StringType,
										Optional:            true,
										Description:         "Required if `auth_type`==`md5`. Property key is the key number",
										MarkdownDescription: "Required if `auth_type`==`md5`. Property key is the key number",
										Validators: []validator.Map{
											mapvalidator.SizeAtLeast(1),
											mistvalidator.RequiredWhenValueIs(path.MatchRelative().AtParent().AtName("auth_type"), types.StringValue("md5")),
										},
									},
									"auth_password": schema.StringAttribute{
										Optional:            true,
										Description:         "Required if `auth_type`==`password`, the password, max length is 8",
										MarkdownDescription: "Required if `auth_type`==`password`, the password, max length is 8",
										Validators: []validator.String{
											mistvalidator.RequiredWhenValueIs(path.MatchRelative().AtParent().AtName("auth_type"), types.StringValue("password")),
											stringvalidator.LengthAtLeast(1),
											stringvalidator.LengthAtMost(8),
										},
									},
									"auth_type": schema.StringAttribute{
										Optional:            true,
										Description:         "auth type. enum: `md5`, `none`, `password`",
										MarkdownDescription: "auth type. enum: `md5`, `none`, `password`",
										Validators: []validator.String{
											stringvalidator.OneOf(
												"",
												"md5",
												"none",
												"password",
											),
										},
									},
									"bfd_minimum_interval": schema.Int64Attribute{
										Optional: true,
										Validators: []validator.Int64{
											int64validator.Between(1, 255000),
										},
									},
									"dead_interval": schema.Int64Attribute{
										Optional: true,
										Validators: []validator.Int64{
											int64validator.Between(1, 65535),
										},
									},
									"export_policy": schema.StringAttribute{
										Optional: true,
									},
									"hello_interval": schema.Int64Attribute{
										Optional: true,
										Validators: []validator.Int64{
											int64validator.Between(1, 255),
										},
									},
									"import_policy": schema.StringAttribute{
										Optional: true,
									},
									"interface_type": schema.StringAttribute{
										Optional:            true,
										Computed:            true,
										Description:         "interface type (nbma = non-broadcast multi-access). enum: `broadcast`, `nbma`, `p2mp`, `p2p`",
										MarkdownDescription: "interface type (nbma = non-broadcast multi-access). enum: `broadcast`, `nbma`, `p2mp`, `p2p`",
										Validators: []validator.String{
											stringvalidator.OneOf(
												"",
												"broadcast",
												"nbma",
												"p2mp",
												"p2p",
											),
										},
										Default: stringdefault.StaticString("broadcast"),
									},
									"metric": schema.Int64Attribute{
										Optional: true,
										Validators: []validator.Int64{
											int64validator.Between(1, 65535),
										},
									},
									"no_readvertise_to_overlay": schema.BoolAttribute{
										Optional:            true,
										Description:         "By default, we'll re-advertise all learned OSPF routes toward overlay",
										MarkdownDescription: "By default, we'll re-advertise all learned OSPF routes toward overlay",
									},
									"passive": schema.BoolAttribute{
										Optional:            true,
										Computed:            true,
										Description:         "Whether to send OSPF-Hello",
										MarkdownDescription: "Whether to send OSPF-Hello",
										Default:             booldefault.StaticBool(false),
									},
								},
								CustomType: OspfNetworksType{
									ObjectType: types.ObjectType{
										AttrTypes: OspfNetworksValue{}.AttributeTypes(ctx),
									},
								},
							},
							Required: true,
							Validators: []validator.Map{
								mapvalidator.SizeAtLeast(1),
							},
						},
						"type": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "OSPF type. enum: `default`, `nssa`, `stub`",
							MarkdownDescription: "OSPF type. enum: `default`, `nssa`, `stub`",
							Validators: []validator.String{
								stringvalidator.OneOf(
									"",
									"default",
									"nssa",
									"stub",
								),
							},
							Default: stringdefault.StaticString("default"),
						},
					},
					CustomType: OspfAreasType{
						ObjectType: types.ObjectType{
							AttrTypes: OspfAreasValue{}.AttributeTypes(ctx),
						},
					},
				},
				Optional:            true,
				Description:         "Junos OSPF areas. Property key is the OSPF Area (Area should be a number (0-255) / IP address)",
				MarkdownDescription: "Junos OSPF areas. Property key is the OSPF Area (Area should be a number (0-255) / IP address)",
				Validators: []validator.Map{
					mapvalidator.SizeAtLeast(1),
					mapvalidator.KeysAre(
						stringvalidator.Any(
							mistvalidator.ParseInt(0, 255),
							mistvalidator.ParseIp(true, false),
						),
					),
				},
			},
			"port_mirroring": schema.MapNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"input_networks_ingress": schema.ListAttribute{
							ElementType:         types.StringType,
							Optional:            true,
							Computed:            true,
							Description:         "At least one of the `input_port_ids_ingress`, `input_port_ids_egress` or `input_networks_ingress ` should be specified",
							MarkdownDescription: "At least one of the `input_port_ids_ingress`, `input_port_ids_egress` or `input_networks_ingress ` should be specified",
							Default:             listdefault.StaticValue(basetypes.NewListValueMust(basetypes.StringType{}, []attr.Value{})),
						},
						"input_port_ids_egress": schema.ListAttribute{
							ElementType:         types.StringType,
							Optional:            true,
							Computed:            true,
							Description:         "At least one of the `input_port_ids_ingress`, `input_port_ids_egress` or `input_networks_ingress ` should be specified",
							MarkdownDescription: "At least one of the `input_port_ids_ingress`, `input_port_ids_egress` or `input_networks_ingress ` should be specified",
							Default:             listdefault.StaticValue(basetypes.NewListValueMust(basetypes.StringType{}, []attr.Value{})),
						},
						"input_port_ids_ingress": schema.ListAttribute{
							ElementType:         types.StringType,
							Optional:            true,
							Computed:            true,
							Description:         "At least one of the `input_port_ids_ingress`, `input_port_ids_egress` or `input_networks_ingress ` should be specified",
							MarkdownDescription: "At least one of the `input_port_ids_ingress`, `input_port_ids_egress` or `input_networks_ingress ` should be specified",
							Default:             listdefault.StaticValue(basetypes.NewListValueMust(basetypes.StringType{}, []attr.Value{})),
						},
						"output_ip_address": schema.StringAttribute{
							Optional:            true,
							Description:         "Exactly one of the `output_ip_address`, `output_port_id` or `output_network` should be provided",
							MarkdownDescription: "Exactly one of the `output_ip_address`, `output_port_id` or `output_network` should be provided",
						},
						"output_network": schema.StringAttribute{
							Optional:            true,
							Description:         "Exactly one of the `output_ip_address`, `output_port_id` or `output_network` should be provided",
							MarkdownDescription: "Exactly one of the `output_ip_address`, `output_port_id` or `output_network` should be provided",
						},
						"output_port_id": schema.StringAttribute{
							Optional:            true,
							Description:         "Exactly one of the `output_ip_address`, `output_port_id` or `output_network` should be provided",
							MarkdownDescription: "Exactly one of the `output_ip_address`, `output_port_id` or `output_network` should be provided",
						},
					},
					CustomType: PortMirroringType{
						ObjectType: types.ObjectType{
							AttrTypes: PortMirroringValue{}.AttributeTypes(ctx),
						},
					},
					Validators: []validator.Object{
						mistvalidator.AtLeastNOf(
							1,
							path.MatchRelative().AtName("input_networks_ingress"),
							path.MatchRelative().AtName("input_port_ids_egress"),
							path.MatchRelative().AtName("input_port_ids_ingress"),
						),
						mistvalidator.AtMostNOf(
							1,
							path.MatchRelative().AtName("output_network"),
							path.MatchRelative().AtName("output_port_id"),
						),
					},
				},
				Optional:            true,
				Description:         "Property key is the port mirroring instance name. `port_mirroring` can be added under device/site settings. It takes interface and ports as input for ingress, interface as input for egress and can take interface and port as output. A maximum 4 mirroring ports is allowed",
				MarkdownDescription: "Property key is the port mirroring instance name. `port_mirroring` can be added under device/site settings. It takes interface and ports as input for ingress, interface as input for egress and can take interface and port as output. A maximum 4 mirroring ports is allowed",
				Validators: []validator.Map{
					mapvalidator.SizeAtMost(4),
				},
			},
			"port_usages": schema.MapNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"all_networks": schema.BoolAttribute{
							Optional:            true,
							Description:         "Only if `mode`==`trunk`. Whether to trunk all network/vlans",
							MarkdownDescription: "Only if `mode`==`trunk`. Whether to trunk all network/vlans",
							Validators: []validator.Bool{
								mistvalidator.AllowedWhenValueIsWithDefault(path.MatchRelative().AtParent().AtName("mode"), types.StringValue("trunk"), types.BoolValue(false)),
							},
						},
						"allow_dhcpd": schema.BoolAttribute{
							Optional:            true,
							Description:         "Only applies when `mode`!=`dynamic`. Controls whether DHCP server traffic is allowed on ports using this configuration if DHCP snooping is enabled. This is a tri-state setting; true: ports become trusted ports allowing DHCP server traffic, false: ports become untrusted blocking DHCP server traffic, undefined: use system defaults (access ports default to untrusted, trunk ports default to trusted).",
							MarkdownDescription: "Only applies when `mode`!=`dynamic`. Controls whether DHCP server traffic is allowed on ports using this configuration if DHCP snooping is enabled. This is a tri-state setting; true: ports become trusted ports allowing DHCP server traffic, false: ports become untrusted blocking DHCP server traffic, undefined: use system defaults (access ports default to untrusted, trunk ports default to trusted).",
							Validators: []validator.Bool{
								mistvalidator.CannotBeTrueWhenValueIs(path.MatchRelative().AtParent().AtName("mode"), types.StringValue("dynamic")),
							},
						},
						"allow_multiple_supplicants": schema.BoolAttribute{
							Optional:            true,
							Description:         "Only if `mode`!=`dynamic`",
							MarkdownDescription: "Only if `mode`!=`dynamic`",
							Validators: []validator.Bool{
								mistvalidator.ForbiddenWhenValueIsWithDefault(path.MatchRelative().AtParent().AtName("mode"), types.StringValue("dynamic"), types.BoolValue(false)),
							},
						},
						"bypass_auth_when_server_down": schema.BoolAttribute{
							Optional:            true,
							Description:         "Only if `mode`!=`dynamic` and `port_auth`==`dot1x`. Bypass auth for known clients if set to true when RADIUS server is down",
							MarkdownDescription: "Only if `mode`!=`dynamic` and `port_auth`==`dot1x`. Bypass auth for known clients if set to true when RADIUS server is down",
							Validators: []validator.Bool{
								mistvalidator.AllowedWhenValueIsWithDefault(path.MatchRelative().AtParent().AtName("port_auth"), types.StringValue("dot1x"), types.BoolValue(false)),
							},
						},
						"bypass_auth_when_server_down_for_unknown_client": schema.BoolAttribute{
							Optional:            true,
							Description:         "Only if `mode`!=`dynamic` and `port_auth`=`dot1x`. Bypass auth for all (including unknown clients) if set to true when RADIUS server is down",
							MarkdownDescription: "Only if `mode`!=`dynamic` and `port_auth`=`dot1x`. Bypass auth for all (including unknown clients) if set to true when RADIUS server is down",
							Validators: []validator.Bool{
								mistvalidator.AllowedWhenValueIsWithDefault(path.MatchRelative().AtParent().AtName("port_auth"), types.StringValue("dot1x"), types.BoolValue(false)),
							},
						},
						"bypass_auth_when_server_down_for_voip": schema.BoolAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "Only if `mode`!=`dynamic` and `port_auth`==`dot1x`. Bypass auth for VOIP if set to true when RADIUS server is down",
							MarkdownDescription: "Only if `mode`!=`dynamic` and `port_auth`==`dot1x`. Bypass auth for VOIP if set to true when RADIUS server is down",
							Default:             booldefault.StaticBool(false),
						},
						"community_vlan_id": schema.Int64Attribute{
							Optional:            true,
							Description:         "Only if `mode`!=`dynamic`. To be used together with `isolation` under networks. Signaling that this port connects to the networks isolated but wired clients belong to the same community can talk to each other",
							MarkdownDescription: "Only if `mode`!=`dynamic`. To be used together with `isolation` under networks. Signaling that this port connects to the networks isolated but wired clients belong to the same community can talk to each other",
						},
						"description": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "Only if `mode`!=`dynamic`",
							MarkdownDescription: "Only if `mode`!=`dynamic`",
							Validators: []validator.String{
								mistvalidator.ForbiddenWhenValueIs(path.MatchRelative().AtParent().AtName("mode"), types.StringValue("dynamic")),
							},
							Default: stringdefault.StaticString(""),
						},
						"disable_autoneg": schema.BoolAttribute{
							Optional:            true,
							Description:         "Only if `mode`!=`dynamic`. If speed and duplex are specified, whether to disable autonegotiation",
							MarkdownDescription: "Only if `mode`!=`dynamic`. If speed and duplex are specified, whether to disable autonegotiation",
							Validators: []validator.Bool{
								mistvalidator.ForbiddenWhenValueIsWithDefault(path.MatchRelative().AtParent().AtName("mode"), types.StringValue("dynamic"), types.BoolValue(false)),
							},
						},
						"disabled": schema.BoolAttribute{
							Optional:            true,
							Description:         "Only if `mode`!=`dynamic`. Whether the port is disabled",
							MarkdownDescription: "Only if `mode`!=`dynamic`. Whether the port is disabled",
							Validators: []validator.Bool{
								mistvalidator.ForbiddenWhenValueIsWithDefault(path.MatchRelative().AtParent().AtName("mode"), types.StringValue("dynamic"), types.BoolValue(false)),
							},
						},
						"duplex": schema.StringAttribute{
							Optional:            true,
							Description:         "Only if `mode`!=`dynamic`. Link connection mode. enum: `auto`, `full`, `half`",
							MarkdownDescription: "Only if `mode`!=`dynamic`. Link connection mode. enum: `auto`, `full`, `half`",
							Validators: []validator.String{
								stringvalidator.OneOf(
									"",
									"half",
									"full",
									"auto",
								),
								mistvalidator.ForbiddenWhenValueIsWithDefault(path.MatchRelative().AtParent().AtName("mode"), types.StringValue("dynamic"), types.StringValue("auto")),
							},
						},
						"dynamic_vlan_networks": schema.ListAttribute{
							ElementType:         types.StringType,
							Optional:            true,
							Description:         "Only if `mode`!=`dynamic` and `port_auth`==`dot1x`, if dynamic vlan is used, specify the possible networks/vlans RADIUS can return",
							MarkdownDescription: "Only if `mode`!=`dynamic` and `port_auth`==`dot1x`, if dynamic vlan is used, specify the possible networks/vlans RADIUS can return",
							Validators: []validator.List{
								mistvalidator.AllowedWhenValueIs(path.MatchRelative().AtParent().AtName("port_auth"), types.StringValue("dot1x")),
							},
						},
						"enable_mac_auth": schema.BoolAttribute{
							Optional:            true,
							Description:         "Only if `mode`!=`dynamic` and `port_auth`==`dot1x`. Whether to enable MAC Auth",
							MarkdownDescription: "Only if `mode`!=`dynamic` and `port_auth`==`dot1x`. Whether to enable MAC Auth",
							Validators: []validator.Bool{
								mistvalidator.AllowedWhenValueIsWithDefault(path.MatchRelative().AtParent().AtName("port_auth"), types.StringValue("dot1x"), types.BoolValue(false)),
							},
						},
						"enable_qos": schema.BoolAttribute{
							Optional:            true,
							Description:         "Only if `mode`!=`dynamic`",
							MarkdownDescription: "Only if `mode`!=`dynamic`",
							Validators: []validator.Bool{
								mistvalidator.ForbiddenWhenValueIsWithDefault(path.MatchRelative().AtParent().AtName("mode"), types.StringValue("dynamic"), types.BoolValue(false)),
							},
						},
						"guest_network": schema.StringAttribute{
							Optional:            true,
							Description:         "Only if `mode`!=`dynamic` and `port_auth`==`dot1x`. Which network to put the device into if the device cannot do dot1x. default is null (i.e. not allowed)",
							MarkdownDescription: "Only if `mode`!=`dynamic` and `port_auth`==`dot1x`. Which network to put the device into if the device cannot do dot1x. default is null (i.e. not allowed)",
							Validators: []validator.String{
								mistvalidator.AllowedWhenValueIs(path.MatchRelative().AtParent().AtName("port_auth"), types.StringValue("dot1x")),
							},
						},
						"inter_isolation_network_link": schema.BoolAttribute{
							Optional:            true,
							Description:         "Only if `mode`!=`dynamic`. `inter_isolation_network_link` is used together with `isolation` under networks, signaling that this port connects to isolated networks",
							MarkdownDescription: "Only if `mode`!=`dynamic`. `inter_isolation_network_link` is used together with `isolation` under networks, signaling that this port connects to isolated networks",
						},
						"inter_switch_link": schema.BoolAttribute{
							Optional:            true,
							Description:         "Only if `mode`!=`dynamic`. `inter_switch_link` is used together with `isolation` under networks. NOTE: `inter_switch_link` works only between Juniper devices. This has to be applied to both ports connected together",
							MarkdownDescription: "Only if `mode`!=`dynamic`. `inter_switch_link` is used together with `isolation` under networks. NOTE: `inter_switch_link` works only between Juniper devices. This has to be applied to both ports connected together",
							Validators: []validator.Bool{
								mistvalidator.AllowedWhenValueIsWithDefault(path.MatchRelative().AtParent().AtName("port_auth"), types.StringValue("dot1x"), types.BoolValue(false)),
							},
						},
						"mac_auth_only": schema.BoolAttribute{
							Optional:            true,
							Description:         "Only if `mode`!=`dynamic` and `enable_mac_auth`==`true`",
							MarkdownDescription: "Only if `mode`!=`dynamic` and `enable_mac_auth`==`true`",
							Validators: []validator.Bool{
								mistvalidator.ForbiddenWhenValueIs(path.MatchRelative().AtParent().AtName("mode"), types.StringValue("dynamic")),
							},
						},
						"mac_auth_preferred": schema.BoolAttribute{
							Optional:            true,
							Description:         "Only if `mode`!=`dynamic` + `enable_mac_auth`==`true` + `mac_auth_only`==`false`, dot1x will be given priority then mac_auth. Enable this to prefer mac_auth over dot1x.",
							MarkdownDescription: "Only if `mode`!=`dynamic` + `enable_mac_auth`==`true` + `mac_auth_only`==`false`, dot1x will be given priority then mac_auth. Enable this to prefer mac_auth over dot1x.",
						},
						"mac_auth_protocol": schema.StringAttribute{
							Optional:            true,
							Description:         "Only if `mode`!=`dynamic` and `enable_mac_auth` ==`true`. This type is ignored if mist_nac is enabled. enum: `eap-md5`, `eap-peap`, `pap`",
							MarkdownDescription: "Only if `mode`!=`dynamic` and `enable_mac_auth` ==`true`. This type is ignored if mist_nac is enabled. enum: `eap-md5`, `eap-peap`, `pap`",
							Validators: []validator.String{
								stringvalidator.OneOf(
									"",
									"pap",
									"eap-peap",
									"eap-md5",
								),
								mistvalidator.AllowedWhenValueIsWithDefault(path.MatchRelative().AtParent().AtName("enable_mac_auth"), types.BoolValue(true), types.StringValue("eap-md5")),
							},
						},
						"mac_limit": schema.StringAttribute{
							Optional:            true,
							Description:         "Only if `mode`!=`dynamic` max number of mac addresses, default is 0 for unlimited, otherwise range is 1 to 16383 (upper bound constrained by platform)",
							MarkdownDescription: "Only if `mode`!=`dynamic` max number of mac addresses, default is 0 for unlimited, otherwise range is 1 to 16383 (upper bound constrained by platform)",
							Validators: []validator.String{
								stringvalidator.Any(
									mistvalidator.ParseInt(0, 16383),
									mistvalidator.ParseVar(),
								),
								mistvalidator.ForbiddenWhenValueIsWithDefault(path.MatchRelative().AtParent().AtName("mode"), types.StringValue("dynamic"), types.StringValue("0")),
							},
						},
						"mode": schema.StringAttribute{
							Optional:            true,
							Description:         "`mode`==`dynamic` must only be used if the port usage name is `dynamic`. enum: `access`, `dynamic`, `inet`, `trunk`",
							MarkdownDescription: "`mode`==`dynamic` must only be used if the port usage name is `dynamic`. enum: `access`, `dynamic`, `inet`, `trunk`",
							Validators: []validator.String{
								stringvalidator.OneOf(
									"",
									"access",
									"dynamic",
									"inet",
									"trunk",
								),
							},
						},
						"mtu": schema.StringAttribute{
							Optional:            true,
							Description:         "Only if `mode`!=`dynamic` media maximum transmission unit (MTU) is the largest data unit that can be forwarded without fragmentation. Value between 256 and 9216, default value is 1514.",
							MarkdownDescription: "Only if `mode`!=`dynamic` media maximum transmission unit (MTU) is the largest data unit that can be forwarded without fragmentation. Value between 256 and 9216, default value is 1514.",
							Validators: []validator.String{
								stringvalidator.Any(
									mistvalidator.ParseInt(256, 9216),
									mistvalidator.ParseVar(),
								),
								mistvalidator.ForbiddenWhenValueIs(path.MatchRelative().AtParent().AtName("mode"), types.StringValue("dynamic")),
							},
						},
						"networks": schema.ListAttribute{
							ElementType:         types.StringType,
							Optional:            true,
							Computed:            true,
							Description:         "Only if `mode`==`trunk`, the list of network/vlans",
							MarkdownDescription: "Only if `mode`==`trunk`, the list of network/vlans",
							Validators: []validator.List{
								listvalidator.SizeAtLeast(1),
								mistvalidator.AllowedWhenValueIs(path.MatchRelative().AtParent().AtName("mode"), types.StringValue("trunk")),
							},
							Default: listdefault.StaticValue(types.ListNull(types.StringType)),
						},
						"persist_mac": schema.BoolAttribute{
							Optional:            true,
							Description:         "Only if `mode`==`access` and `port_auth`!=`dot1x`. Whether the port should retain dynamically learned MAC addresses",
							MarkdownDescription: "Only if `mode`==`access` and `port_auth`!=`dot1x`. Whether the port should retain dynamically learned MAC addresses",
						},
						"poe_disabled": schema.BoolAttribute{
							Optional:            true,
							Description:         "Only if `mode`!=`dynamic`. Whether PoE capabilities are disabled for a port",
							MarkdownDescription: "Only if `mode`!=`dynamic`. Whether PoE capabilities are disabled for a port",
							Validators: []validator.Bool{
								mistvalidator.ForbiddenWhenValueIsWithDefault(path.MatchRelative().AtParent().AtName("mode"), types.StringValue("dynamic"), types.BoolValue(false)),
							},
						},
						"poe_priority": schema.StringAttribute{
							Optional:            true,
							Description:         "PoE priority. enum: `low`, `high`",
							MarkdownDescription: "PoE priority. enum: `low`, `high`",
							Validators: []validator.String{
								stringvalidator.OneOf(
									"",
									"low",
									"high",
								),
							},
						},
						"port_auth": schema.StringAttribute{
							Optional:            true,
							Description:         "Only if `mode`!=`dynamic`. If dot1x is desired, set to dot1x. enum: `dot1x`",
							MarkdownDescription: "Only if `mode`!=`dynamic`. If dot1x is desired, set to dot1x. enum: `dot1x`",
							Validators: []validator.String{
								stringvalidator.OneOf(
									"",
									"dot1x",
									"none",
								),
								mistvalidator.ForbiddenWhenValueIs(path.MatchRelative().AtParent().AtName("mode"), types.StringValue("dynamic")),
							},
						},
						"port_network": schema.StringAttribute{
							Optional:            true,
							Description:         "Only if `mode`!=`dynamic`. Native network/vlan for untagged traffic",
							MarkdownDescription: "Only if `mode`!=`dynamic`. Native network/vlan for untagged traffic",
							Validators: []validator.String{
								mistvalidator.ForbiddenWhenValueIs(path.MatchRelative().AtParent().AtName("mode"), types.StringValue("dynamic")),
							},
						},
						"reauth_interval": schema.StringAttribute{
							Optional:            true,
							Description:         "Only if `mode`!=`dynamic` and `port_auth`=`dot1x` reauthentication interval range between 10 and 65535 (default: 3600)",
							MarkdownDescription: "Only if `mode`!=`dynamic` and `port_auth`=`dot1x` reauthentication interval range between 10 and 65535 (default: 3600)",
							Validators: []validator.String{
								stringvalidator.Any(
									mistvalidator.ParseInt(10, 65535),
									mistvalidator.ParseVar(),
								),
								mistvalidator.AllowedWhenValueIsWithDefault(path.MatchRelative().AtParent().AtName("port_auth"), types.StringValue("dot1x"), types.StringValue("3600")),
							},
						},
						"reset_default_when": schema.StringAttribute{
							Optional:            true,
							Description:         "Only if `mode`==`dynamic` Control when the DPC port should be changed to the default port usage. enum: `link_down`, `none` (let the DPC port keep at the current port usage)",
							MarkdownDescription: "Only if `mode`==`dynamic` Control when the DPC port should be changed to the default port usage. enum: `link_down`, `none` (let the DPC port keep at the current port usage)",
							Validators: []validator.String{
								stringvalidator.OneOf(
									"",
									"none",
									"link_down",
								),
								mistvalidator.AllowedWhenValueIsWithDefault(path.MatchRelative().AtParent().AtName("mode"), types.StringValue("dynamic"), types.StringValue("link_down")),
							},
						},
						"rules": schema.ListNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"equals": schema.StringAttribute{
										Optional: true,
									},
									"equals_any": schema.ListAttribute{
										ElementType:         types.StringType,
										Optional:            true,
										Description:         "Use `equals_any` to match any item in a list",
										MarkdownDescription: "Use `equals_any` to match any item in a list",
									},
									"expression": schema.StringAttribute{
										Optional:            true,
										Description:         "\"[0:3]\":\"abcdef\" -> \"abc\"\n\"split(.)[1]\": \"a.b.c\" -> \"b\"\n\"split(-)[1][0:3]: \"a1234-b5678-c90\" -> \"b56\"",
										MarkdownDescription: "\"[0:3]\":\"abcdef\" -> \"abc\"\n\"split(.)[1]\": \"a.b.c\" -> \"b\"\n\"split(-)[1][0:3]: \"a1234-b5678-c90\" -> \"b56\"",
									},
									"src": schema.StringAttribute{
										Required:            true,
										Description:         "enum: `link_peermac`, `lldp_chassis_id`, `lldp_hardware_revision`, `lldp_manufacturer_name`, `lldp_oui`, `lldp_serial_number`, `lldp_system_description`, `lldp_system_name`, `radius_dynamicfilter`, `radius_usermac`, `radius_username`",
										MarkdownDescription: "enum: `link_peermac`, `lldp_chassis_id`, `lldp_hardware_revision`, `lldp_manufacturer_name`, `lldp_oui`, `lldp_serial_number`, `lldp_system_description`, `lldp_system_name`, `radius_dynamicfilter`, `radius_usermac`, `radius_username`",
										Validators: []validator.String{
											stringvalidator.OneOf(
												"",
												"link_peermac",
												"lldp_chassis_id",
												"lldp_hardware_revision",
												"lldp_manufacturer_name",
												"lldp_oui",
												"lldp_serial_number",
												"lldp_system_description",
												"lldp_system_name",
												"radius_dynamicfilter",
												"radius_usermac",
												"radius_username",
											),
										},
									},
									"usage": schema.StringAttribute{
										Optional:            true,
										Description:         "`port_usage` name",
										MarkdownDescription: "`port_usage` name",
									},
								},
								CustomType: RulesType{
									ObjectType: types.ObjectType{
										AttrTypes: RulesValue{}.AttributeTypes(ctx),
									},
								},
							},
							Optional:            true,
							Description:         "Only if `mode`==`dynamic`",
							MarkdownDescription: "Only if `mode`==`dynamic`",
							Validators: []validator.List{
								mistvalidator.AllowedWhenValueIs(path.MatchRelative().AtParent().AtName("mode"), types.StringValue("dynamic")),
							},
						},
						"server_fail_network": schema.StringAttribute{
							Optional:            true,
							Description:         "Only if `mode`!=`dynamic` and `port_auth`==`dot1x`. Sets server fail fallback vlan",
							MarkdownDescription: "Only if `mode`!=`dynamic` and `port_auth`==`dot1x`. Sets server fail fallback vlan",
							Validators: []validator.String{
								mistvalidator.AllowedWhenValueIs(path.MatchRelative().AtParent().AtName("port_auth"), types.StringValue("dot1x")),
							},
						},
						"server_reject_network": schema.StringAttribute{
							Optional:            true,
							Description:         "Only if `mode`!=`dynamic` and `port_auth`==`dot1x`. When radius server reject / fails",
							MarkdownDescription: "Only if `mode`!=`dynamic` and `port_auth`==`dot1x`. When radius server reject / fails",
							Validators: []validator.String{
								mistvalidator.AllowedWhenValueIs(path.MatchRelative().AtParent().AtName("port_auth"), types.StringValue("dot1x")),
							},
						},
						"speed": schema.StringAttribute{
							Optional:            true,
							Description:         "Only if `mode`!=`dynamic`, Port speed, default is auto to automatically negotiate speed enum: `100m`, `10m`, `1g`, `2.5g`, `5g`, `10g`, `25g`, `40g`, `100g`,`auto`",
							MarkdownDescription: "Only if `mode`!=`dynamic`, Port speed, default is auto to automatically negotiate speed enum: `100m`, `10m`, `1g`, `2.5g`, `5g`, `10g`, `25g`, `40g`, `100g`,`auto`",
							Validators: []validator.String{
								mistvalidator.ForbiddenWhenValueIs(path.MatchRelative().AtParent().AtName("mode"), types.StringValue("dynamic")),
							},
						},
						"storm_control": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"disable_port": schema.BoolAttribute{
									Optional:            true,
									Description:         "Whether to disable the port when storm control is triggered",
									MarkdownDescription: "Whether to disable the port when storm control is triggered",
								},
								"no_broadcast": schema.BoolAttribute{
									Optional:            true,
									Description:         "Whether to disable storm control on broadcast traffic",
									MarkdownDescription: "Whether to disable storm control on broadcast traffic",
								},
								"no_multicast": schema.BoolAttribute{
									Optional:            true,
									Description:         "Whether to disable storm control on multicast traffic",
									MarkdownDescription: "Whether to disable storm control on multicast traffic",
								},
								"no_registered_multicast": schema.BoolAttribute{
									Optional:            true,
									Description:         "Whether to disable storm control on registered multicast traffic",
									MarkdownDescription: "Whether to disable storm control on registered multicast traffic",
								},
								"no_unknown_unicast": schema.BoolAttribute{
									Optional:            true,
									Description:         "Whether to disable storm control on unknown unicast traffic",
									MarkdownDescription: "Whether to disable storm control on unknown unicast traffic",
								},
								"percentage": schema.Int64Attribute{
									Optional:            true,
									Description:         "Bandwidth-percentage, configures the storm control level as a percentage of the available bandwidth",
									MarkdownDescription: "Bandwidth-percentage, configures the storm control level as a percentage of the available bandwidth",
									Validators: []validator.Int64{
										int64validator.Between(0, 100),
									},
								},
							},
							CustomType: StormControlType{
								ObjectType: types.ObjectType{
									AttrTypes: StormControlValue{}.AttributeTypes(ctx),
								},
							},
							Optional:            true,
							Description:         "Switch storm control. Only if `mode`!=`dynamic`",
							MarkdownDescription: "Switch storm control. Only if `mode`!=`dynamic`",
							Validators: []validator.Object{
								mistvalidator.ForbiddenWhenValueIs(path.MatchRelative().AtParent().AtName("mode"), types.StringValue("dynamic")),
							},
						},
						"stp_disable": schema.BoolAttribute{
							Optional:            true,
							Description:         "Only if `mode`!=`dynamic` and `stp_required`==`false`. Drop bridge protocol data units (BPDUs ) that enter any interface or a specified interface",
							MarkdownDescription: "Only if `mode`!=`dynamic` and `stp_required`==`false`. Drop bridge protocol data units (BPDUs ) that enter any interface or a specified interface",
							Validators: []validator.Bool{
								mistvalidator.ForbiddenWhenValueIsWithDefault(path.MatchRelative().AtParent().AtName("mode"), types.StringValue("dynamic"), types.BoolValue(false)),
								mistvalidator.CanOnlyBeTrueWhenValueIs(path.MatchRelative().AtParent().AtName("stp_required"), types.BoolValue(false)),
							},
						},
						"stp_edge": schema.BoolAttribute{
							Optional:            true,
							Description:         "Only if `mode`!=`dynamic`. When enabled, the port is not expected to receive BPDU frames",
							MarkdownDescription: "Only if `mode`!=`dynamic`. When enabled, the port is not expected to receive BPDU frames",
							Validators: []validator.Bool{
								mistvalidator.ForbiddenWhenValueIsWithDefault(path.MatchRelative().AtParent().AtName("mode"), types.StringValue("dynamic"), types.BoolValue(false)),
							},
						},
						"stp_no_root_port": schema.BoolAttribute{
							Optional:            true,
							Description:         "Only if `mode`!=`dynamic`",
							MarkdownDescription: "Only if `mode`!=`dynamic`",
							Validators: []validator.Bool{
								mistvalidator.ForbiddenWhenValueIsWithDefault(path.MatchRelative().AtParent().AtName("mode"), types.StringValue("dynamic"), types.BoolValue(false)),
							},
						},
						"stp_p2p": schema.BoolAttribute{
							Optional:            true,
							Description:         "Only if `mode`!=`dynamic`",
							MarkdownDescription: "Only if `mode`!=`dynamic`",
							Validators: []validator.Bool{
								mistvalidator.ForbiddenWhenValueIsWithDefault(path.MatchRelative().AtParent().AtName("mode"), types.StringValue("dynamic"), types.BoolValue(false)),
							},
						},
						"stp_required": schema.BoolAttribute{
							Optional:            true,
							Description:         "Only if `mode`!=`dynamic`. Whether to remain in block state if no BPDU is received",
							MarkdownDescription: "Only if `mode`!=`dynamic`. Whether to remain in block state if no BPDU is received",
							Validators: []validator.Bool{
								mistvalidator.ForbiddenWhenValueIsWithDefault(path.MatchRelative().AtParent().AtName("mode"), types.StringValue("dynamic"), types.BoolValue(false)),
							},
						},
						"ui_evpntopo_id": schema.StringAttribute{
							Optional:            true,
							Description:         "Optional for Campus Fabric Core-Distribution ESI-LAG profile. Helper used by the UI to select this port profile as the ESI-Lag between Distribution and Access switches",
							MarkdownDescription: "Optional for Campus Fabric Core-Distribution ESI-LAG profile. Helper used by the UI to select this port profile as the ESI-Lag between Distribution and Access switches",
						},
						"use_vstp": schema.BoolAttribute{
							Optional:            true,
							Description:         "If this is connected to a vstp network",
							MarkdownDescription: "If this is connected to a vstp network",
							Validators: []validator.Bool{
								mistvalidator.ForbiddenWhenValueIsWithDefault(path.MatchRelative().AtParent().AtName("mode"), types.StringValue("dynamic"), types.BoolValue(false)),
							},
						},
						"voip_network": schema.StringAttribute{
							Optional:            true,
							Description:         "Only if `mode`!=`dynamic`. Network/vlan for voip traffic, must also set port_network. to authenticate device, set port_auth",
							MarkdownDescription: "Only if `mode`!=`dynamic`. Network/vlan for voip traffic, must also set port_network. to authenticate device, set port_auth",
							Validators: []validator.String{
								mistvalidator.ForbiddenWhenValueIs(path.MatchRelative().AtParent().AtName("mode"), types.StringValue("dynamic")),
							},
						},
					},
					CustomType: PortUsagesType{
						ObjectType: types.ObjectType{
							AttrTypes: PortUsagesValue{}.AttributeTypes(ctx),
						},
					},
				},
				Optional:            true,
				Description:         "Property key is the port usage name. Defines the profiles of port configuration configured on the switch",
				MarkdownDescription: "Property key is the port usage name. Defines the profiles of port configuration configured on the switch",
				Validators: []validator.Map{
					mapvalidator.SizeAtLeast(1),
				},
			},
			"radius_config": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"acct_immediate_update": schema.BoolAttribute{
						Optional: true,
					},
					"acct_interim_interval": schema.Int64Attribute{
						Optional:            true,
						Computed:            true,
						Description:         "How frequently should interim accounting be reported, 60-65535. default is 0 (use one specified in Access-Accept request from RADIUS Server). Very frequent messages can affect the performance of the radius server, 600 and up is recommended when enabled",
						MarkdownDescription: "How frequently should interim accounting be reported, 60-65535. default is 0 (use one specified in Access-Accept request from RADIUS Server). Very frequent messages can affect the performance of the radius server, 600 and up is recommended when enabled",
						Validators: []validator.Int64{
							int64validator.Between(0, 65535),
						},
						Default: int64default.StaticInt64(0),
					},
					"acct_servers": schema.ListNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"host": schema.StringAttribute{
									Required:            true,
									Description:         "IP/ hostname of RADIUS server",
									MarkdownDescription: "IP/ hostname of RADIUS server",
								},
								"keywrap_enabled": schema.BoolAttribute{
									Optional: true,
								},
								"keywrap_format": schema.StringAttribute{
									Optional:            true,
									Description:         "enum: `ascii`, `hex`",
									MarkdownDescription: "enum: `ascii`, `hex`",
									Validators: []validator.String{
										stringvalidator.OneOf(
											"",
											"ascii",
											"hex",
										),
									},
								},
								"keywrap_kek": schema.StringAttribute{
									Optional: true,
								},
								"keywrap_mack": schema.StringAttribute{
									Optional: true,
								},
								"port": schema.StringAttribute{
									Optional: true,
								},
								"secret": schema.StringAttribute{
									Required:            true,
									Sensitive:           true,
									Description:         "Secret of RADIUS server",
									MarkdownDescription: "Secret of RADIUS server",
								},
							},
							CustomType: AcctServersType{
								ObjectType: types.ObjectType{
									AttrTypes: AcctServersValue{}.AttributeTypes(ctx),
								},
							},
						},
						Optional: true,
						Validators: []validator.List{
							listvalidator.SizeAtLeast(1),
						},
					},
					"auth_server_selection": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "enum: `ordered`, `unordered`",
						MarkdownDescription: "enum: `ordered`, `unordered`",
						Validators: []validator.String{
							stringvalidator.OneOf(
								"",
								"ordered",
								"unordered",
							),
						},
						Default: stringdefault.StaticString("ordered"),
					},
					"auth_servers": schema.ListNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"host": schema.StringAttribute{
									Required:            true,
									Description:         "IP/ hostname of RADIUS server",
									MarkdownDescription: "IP/ hostname of RADIUS server",
								},
								"keywrap_enabled": schema.BoolAttribute{
									Optional: true,
								},
								"keywrap_format": schema.StringAttribute{
									Optional:            true,
									Description:         "enum: `ascii`, `hex`",
									MarkdownDescription: "enum: `ascii`, `hex`",
									Validators: []validator.String{
										stringvalidator.OneOf(
											"",
											"ascii",
											"hex",
										),
									},
								},
								"keywrap_kek": schema.StringAttribute{
									Optional: true,
								},
								"keywrap_mack": schema.StringAttribute{
									Optional: true,
								},
								"port": schema.StringAttribute{
									Optional: true,
								},
								"require_message_authenticator": schema.BoolAttribute{
									Optional:            true,
									Description:         "Whether to require Message-Authenticator in requests",
									MarkdownDescription: "Whether to require Message-Authenticator in requests",
								},
								"secret": schema.StringAttribute{
									Required:            true,
									Sensitive:           true,
									Description:         "Secret of RADIUS server",
									MarkdownDescription: "Secret of RADIUS server",
								},
							},
							CustomType: AuthServersType{
								ObjectType: types.ObjectType{
									AttrTypes: AuthServersValue{}.AttributeTypes(ctx),
								},
							},
						},
						Optional: true,
						Validators: []validator.List{
							listvalidator.SizeAtLeast(1),
						},
					},
					"auth_servers_retries": schema.Int64Attribute{
						Optional:            true,
						Computed:            true,
						Description:         "Radius auth session retries",
						MarkdownDescription: "Radius auth session retries",
						Default:             int64default.StaticInt64(3),
					},
					"auth_servers_timeout": schema.Int64Attribute{
						Optional:            true,
						Computed:            true,
						Description:         "Radius auth session timeout",
						MarkdownDescription: "Radius auth session timeout",
						Default:             int64default.StaticInt64(5),
					},
					"coa_enabled": schema.BoolAttribute{
						Optional: true,
						Computed: true,
						Default:  booldefault.StaticBool(false),
					},
					"coa_port": schema.StringAttribute{
						Optional: true,
						Computed: true,
						Default:  stringdefault.StaticString(""),
					},
					"fast_dot1x_timers": schema.BoolAttribute{
						Optional: true,
						Computed: true,
						Default:  booldefault.StaticBool(false),
					},
					"network": schema.StringAttribute{
						Optional:            true,
						Description:         "Use `network`or `source_ip`. Which network the RADIUS server resides, if there's static IP for this network, we'd use it as source-ip",
						MarkdownDescription: "Use `network`or `source_ip`. Which network the RADIUS server resides, if there's static IP for this network, we'd use it as source-ip",
					},
					"source_ip": schema.StringAttribute{
						Optional:            true,
						Description:         "Use `network`or `source_ip`",
						MarkdownDescription: "Use `network`or `source_ip`",
					},
				},
				CustomType: RadiusConfigType{
					ObjectType: types.ObjectType{
						AttrTypes: RadiusConfigValue{}.AttributeTypes(ctx),
					},
				},
				Optional:            true,
				Description:         "Junos Radius config",
				MarkdownDescription: "Junos Radius config",
			},
			"remote_syslog": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"archive": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"files": schema.StringAttribute{
								Optional: true,
							},
							"size": schema.StringAttribute{
								Optional: true,
							},
						},
						CustomType: ArchiveType{
							ObjectType: types.ObjectType{
								AttrTypes: ArchiveValue{}.AttributeTypes(ctx),
							},
						},
						Optional: true,
					},
					"cacerts": schema.ListAttribute{
						ElementType: types.StringType,
						Optional:    true,
						Validators: []validator.List{
							listvalidator.SizeAtLeast(1),
						},
					},
					"console": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"contents": schema.ListNestedAttribute{
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"facility": schema.StringAttribute{
											Optional:            true,
											Computed:            true,
											Description:         "enum: `any`, `authorization`, `change-log`, `config`, `conflict-log`, `daemon`, `dfc`, `external`, `firewall`, `ftp`, `interactive-commands`, `kernel`, `ntp`, `pfe`, `security`, `user`",
											MarkdownDescription: "enum: `any`, `authorization`, `change-log`, `config`, `conflict-log`, `daemon`, `dfc`, `external`, `firewall`, `ftp`, `interactive-commands`, `kernel`, `ntp`, `pfe`, `security`, `user`",
											Validators: []validator.String{
												stringvalidator.OneOf(
													"",
													"any",
													"authorization",
													"change-log",
													"config",
													"conflict-log",
													"daemon",
													"dfc",
													"external",
													"firewall",
													"ftp",
													"interactive-commands",
													"kernel",
													"ntp",
													"pfe",
													"security",
													"user",
												),
											},
											Default: stringdefault.StaticString("any"),
										},
										"severity": schema.StringAttribute{
											Optional:            true,
											Computed:            true,
											Description:         "enum: `alert`, `any`, `critical`, `emergency`, `error`, `info`, `notice`, `warning`",
											MarkdownDescription: "enum: `alert`, `any`, `critical`, `emergency`, `error`, `info`, `notice`, `warning`",
											Validators: []validator.String{
												stringvalidator.OneOf(
													"",
													"alert",
													"any",
													"critical",
													"emergency",
													"error",
													"info",
													"notice",
													"warning",
												),
											},
											Default: stringdefault.StaticString("any"),
										},
									},
									CustomType: ContentsType{
										ObjectType: types.ObjectType{
											AttrTypes: ContentsValue{}.AttributeTypes(ctx),
										},
									},
								},
								Optional: true,
							},
						},
						CustomType: ConsoleType{
							ObjectType: types.ObjectType{
								AttrTypes: ConsoleValue{}.AttributeTypes(ctx),
							},
						},
						Optional: true,
					},
					"enabled": schema.BoolAttribute{
						Optional: true,
						Computed: true,
						Default:  booldefault.StaticBool(false),
					},
					"files": schema.ListNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"archive": schema.SingleNestedAttribute{
									Attributes: map[string]schema.Attribute{
										"files": schema.StringAttribute{
											Optional: true,
										},
										"size": schema.StringAttribute{
											Optional: true,
										},
									},
									CustomType: ArchiveType{
										ObjectType: types.ObjectType{
											AttrTypes: ArchiveValue{}.AttributeTypes(ctx),
										},
									},
									Optional: true,
								},
								"contents": schema.ListNestedAttribute{
									NestedObject: schema.NestedAttributeObject{
										Attributes: map[string]schema.Attribute{
											"facility": schema.StringAttribute{
												Optional:            true,
												Computed:            true,
												Description:         "enum: `any`, `authorization`, `change-log`, `config`, `conflict-log`, `daemon`, `dfc`, `external`, `firewall`, `ftp`, `interactive-commands`, `kernel`, `ntp`, `pfe`, `security`, `user`",
												MarkdownDescription: "enum: `any`, `authorization`, `change-log`, `config`, `conflict-log`, `daemon`, `dfc`, `external`, `firewall`, `ftp`, `interactive-commands`, `kernel`, `ntp`, `pfe`, `security`, `user`",
												Validators: []validator.String{
													stringvalidator.OneOf(
														"",
														"any",
														"authorization",
														"change-log",
														"config",
														"conflict-log",
														"daemon",
														"dfc",
														"external",
														"firewall",
														"ftp",
														"interactive-commands",
														"kernel",
														"ntp",
														"pfe",
														"security",
														"user",
													),
												},
												Default: stringdefault.StaticString("any"),
											},
											"severity": schema.StringAttribute{
												Optional:            true,
												Computed:            true,
												Description:         "enum: `alert`, `any`, `critical`, `emergency`, `error`, `info`, `notice`, `warning`",
												MarkdownDescription: "enum: `alert`, `any`, `critical`, `emergency`, `error`, `info`, `notice`, `warning`",
												Validators: []validator.String{
													stringvalidator.OneOf(
														"",
														"alert",
														"any",
														"critical",
														"emergency",
														"error",
														"info",
														"notice",
														"warning",
													),
												},
												Default: stringdefault.StaticString("any"),
											},
										},
										CustomType: ContentsType{
											ObjectType: types.ObjectType{
												AttrTypes: ContentsValue{}.AttributeTypes(ctx),
											},
										},
									},
									Optional: true,
								},
								"enable_tls": schema.BoolAttribute{
									Optional:            true,
									Description:         "Only if `protocol`==`tcp`",
									MarkdownDescription: "Only if `protocol`==`tcp`",
								},
								"explicit_priority": schema.BoolAttribute{
									Optional: true,
								},
								"file": schema.StringAttribute{
									Optional: true,
								},
								"match": schema.StringAttribute{
									Optional: true,
								},
								"structured_data": schema.BoolAttribute{
									Optional: true,
								},
							},
							CustomType: FilesType{
								ObjectType: types.ObjectType{
									AttrTypes: FilesValue{}.AttributeTypes(ctx),
								},
							},
						},
						Optional: true,
					},
					"network": schema.StringAttribute{
						Optional:            true,
						Description:         "If source_address is configured, will use the vlan firstly otherwise use source_ip",
						MarkdownDescription: "If source_address is configured, will use the vlan firstly otherwise use source_ip",
					},
					"send_to_all_servers": schema.BoolAttribute{
						Optional: true,
					},
					"servers": schema.ListNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"contents": schema.ListNestedAttribute{
									NestedObject: schema.NestedAttributeObject{
										Attributes: map[string]schema.Attribute{
											"facility": schema.StringAttribute{
												Optional:            true,
												Computed:            true,
												Description:         "enum: `any`, `authorization`, `change-log`, `config`, `conflict-log`, `daemon`, `dfc`, `external`, `firewall`, `ftp`, `interactive-commands`, `kernel`, `ntp`, `pfe`, `security`, `user`",
												MarkdownDescription: "enum: `any`, `authorization`, `change-log`, `config`, `conflict-log`, `daemon`, `dfc`, `external`, `firewall`, `ftp`, `interactive-commands`, `kernel`, `ntp`, `pfe`, `security`, `user`",
												Validators: []validator.String{
													stringvalidator.OneOf(
														"",
														"any",
														"authorization",
														"change-log",
														"config",
														"conflict-log",
														"daemon",
														"dfc",
														"external",
														"firewall",
														"ftp",
														"interactive-commands",
														"kernel",
														"ntp",
														"pfe",
														"security",
														"user",
													),
												},
												Default: stringdefault.StaticString("any"),
											},
											"severity": schema.StringAttribute{
												Optional:            true,
												Computed:            true,
												Description:         "enum: `alert`, `any`, `critical`, `emergency`, `error`, `info`, `notice`, `warning`",
												MarkdownDescription: "enum: `alert`, `any`, `critical`, `emergency`, `error`, `info`, `notice`, `warning`",
												Validators: []validator.String{
													stringvalidator.OneOf(
														"",
														"alert",
														"any",
														"critical",
														"emergency",
														"error",
														"info",
														"notice",
														"warning",
													),
												},
												Default: stringdefault.StaticString("any"),
											},
										},
										CustomType: ContentsType{
											ObjectType: types.ObjectType{
												AttrTypes: ContentsValue{}.AttributeTypes(ctx),
											},
										},
									},
									Optional: true,
								},
								"explicit_priority": schema.BoolAttribute{
									Optional: true,
								},
								"facility": schema.StringAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "enum: `any`, `authorization`, `change-log`, `config`, `conflict-log`, `daemon`, `dfc`, `external`, `firewall`, `ftp`, `interactive-commands`, `kernel`, `ntp`, `pfe`, `security`, `user`",
									MarkdownDescription: "enum: `any`, `authorization`, `change-log`, `config`, `conflict-log`, `daemon`, `dfc`, `external`, `firewall`, `ftp`, `interactive-commands`, `kernel`, `ntp`, `pfe`, `security`, `user`",
									Validators: []validator.String{
										stringvalidator.OneOf(
											"",
											"any",
											"authorization",
											"change-log",
											"config",
											"conflict-log",
											"daemon",
											"dfc",
											"external",
											"firewall",
											"ftp",
											"interactive-commands",
											"kernel",
											"ntp",
											"pfe",
											"security",
											"user",
										),
									},
									Default: stringdefault.StaticString("any"),
								},
								"host": schema.StringAttribute{
									Optional: true,
								},
								"match": schema.StringAttribute{
									Optional: true,
								},
								"port": schema.StringAttribute{
									Optional: true,
								},
								"protocol": schema.StringAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "enum: `tcp`, `udp`",
									MarkdownDescription: "enum: `tcp`, `udp`",
									Validators: []validator.String{
										stringvalidator.OneOf(
											"",
											"tcp",
											"udp",
										),
									},
									Default: stringdefault.StaticString("udp"),
								},
								"routing_instance": schema.StringAttribute{
									Optional: true,
								},
								"server_name": schema.StringAttribute{
									Optional:            true,
									Description:         "Name of the server",
									MarkdownDescription: "Name of the server",
								},
								"severity": schema.StringAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "enum: `alert`, `any`, `critical`, `emergency`, `error`, `info`, `notice`, `warning`",
									MarkdownDescription: "enum: `alert`, `any`, `critical`, `emergency`, `error`, `info`, `notice`, `warning`",
									Validators: []validator.String{
										stringvalidator.OneOf(
											"",
											"alert",
											"any",
											"critical",
											"emergency",
											"error",
											"info",
											"notice",
											"warning",
										),
									},
									Default: stringdefault.StaticString("any"),
								},
								"source_address": schema.StringAttribute{
									Optional:            true,
									Description:         "If source_address is configured, will use the vlan firstly otherwise use source_ip",
									MarkdownDescription: "If source_address is configured, will use the vlan firstly otherwise use source_ip",
								},
								"structured_data": schema.BoolAttribute{
									Optional: true,
								},
								"tag": schema.StringAttribute{
									Optional: true,
								},
							},
							CustomType: ServersType{
								ObjectType: types.ObjectType{
									AttrTypes: ServersValue{}.AttributeTypes(ctx),
								},
							},
						},
						Optional: true,
					},
					"time_format": schema.StringAttribute{
						Optional:            true,
						Description:         "enum: `millisecond`, `year`, `year millisecond`",
						MarkdownDescription: "enum: `millisecond`, `year`, `year millisecond`",
						Validators: []validator.String{
							stringvalidator.OneOf(
								"",
								"millisecond",
								"year",
								"year millisecond",
							),
						},
					},
					"users": schema.ListNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"contents": schema.ListNestedAttribute{
									NestedObject: schema.NestedAttributeObject{
										Attributes: map[string]schema.Attribute{
											"facility": schema.StringAttribute{
												Optional:            true,
												Computed:            true,
												Description:         "enum: `any`, `authorization`, `change-log`, `config`, `conflict-log`, `daemon`, `dfc`, `external`, `firewall`, `ftp`, `interactive-commands`, `kernel`, `ntp`, `pfe`, `security`, `user`",
												MarkdownDescription: "enum: `any`, `authorization`, `change-log`, `config`, `conflict-log`, `daemon`, `dfc`, `external`, `firewall`, `ftp`, `interactive-commands`, `kernel`, `ntp`, `pfe`, `security`, `user`",
												Validators: []validator.String{
													stringvalidator.OneOf(
														"",
														"any",
														"authorization",
														"change-log",
														"config",
														"conflict-log",
														"daemon",
														"dfc",
														"external",
														"firewall",
														"ftp",
														"interactive-commands",
														"kernel",
														"ntp",
														"pfe",
														"security",
														"user",
													),
												},
												Default: stringdefault.StaticString("any"),
											},
											"severity": schema.StringAttribute{
												Optional:            true,
												Computed:            true,
												Description:         "enum: `alert`, `any`, `critical`, `emergency`, `error`, `info`, `notice`, `warning`",
												MarkdownDescription: "enum: `alert`, `any`, `critical`, `emergency`, `error`, `info`, `notice`, `warning`",
												Validators: []validator.String{
													stringvalidator.OneOf(
														"",
														"alert",
														"any",
														"critical",
														"emergency",
														"error",
														"info",
														"notice",
														"warning",
													),
												},
												Default: stringdefault.StaticString("any"),
											},
										},
										CustomType: ContentsType{
											ObjectType: types.ObjectType{
												AttrTypes: ContentsValue{}.AttributeTypes(ctx),
											},
										},
									},
									Optional: true,
								},
								"match": schema.StringAttribute{
									Optional: true,
								},
								"user": schema.StringAttribute{
									Optional: true,
								},
							},
							CustomType: UsersType{
								ObjectType: types.ObjectType{
									AttrTypes: UsersValue{}.AttributeTypes(ctx),
								},
							},
						},
						Optional: true,
					},
				},
				CustomType: RemoteSyslogType{
					ObjectType: types.ObjectType{
						AttrTypes: RemoteSyslogValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
			},
			"remove_existing_configs": schema.BoolAttribute{
				Optional:            true,
				Description:         "By default, only the configuration generated by Mist is cleaned up during the configuration process. If `true`, all the existing configuration will be removed.",
				MarkdownDescription: "By default, only the configuration generated by Mist is cleaned up during the configuration process. If `true`, all the existing configuration will be removed.",
			},
			"snmp_config": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"client_list": schema.ListNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"client_list_name": schema.StringAttribute{
									Optional: true,
								},
								"clients": schema.ListAttribute{
									ElementType: types.StringType,
									Optional:    true,
								},
							},
							CustomType: ClientListType{
								ObjectType: types.ObjectType{
									AttrTypes: ClientListValue{}.AttributeTypes(ctx),
								},
							},
						},
						Optional: true,
						Validators: []validator.List{
							listvalidator.SizeAtLeast(1),
						},
					},
					"contact": schema.StringAttribute{
						Optional: true,
					},
					"description": schema.StringAttribute{
						Optional: true,
					},
					"enabled": schema.BoolAttribute{
						Optional: true,
						Computed: true,
						Default:  booldefault.StaticBool(true),
					},
					"engine_id": schema.StringAttribute{
						Optional: true,
						Validators: []validator.String{
							stringvalidator.LengthAtMost(27),
						},
					},
					"engine_id_type": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "enum: `local`, `use_mac_address`",
						MarkdownDescription: "enum: `local`, `use_mac_address`",
						Validators: []validator.String{
							stringvalidator.OneOf(
								"",
								"local",
								"use_mac_address",
							),
						},
						Default: stringdefault.StaticString("local"),
					},
					"location": schema.StringAttribute{
						Optional: true,
					},
					"name": schema.StringAttribute{
						Optional: true,
					},
					"network": schema.StringAttribute{
						Optional: true,
					},
					"trap_groups": schema.ListNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"categories": schema.ListAttribute{
									ElementType: types.StringType,
									Optional:    true,
								},
								"group_name": schema.StringAttribute{
									Optional:            true,
									Description:         "Categories list can refer to https://www.juniper.net/documentation/software/topics/task/configuration/snmp_trap-groups-configuring-junos-nm.html",
									MarkdownDescription: "Categories list can refer to https://www.juniper.net/documentation/software/topics/task/configuration/snmp_trap-groups-configuring-junos-nm.html",
								},
								"targets": schema.ListAttribute{
									ElementType: types.StringType,
									Optional:    true,
								},
								"version": schema.StringAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "enum: `all`, `v1`, `v2`",
									MarkdownDescription: "enum: `all`, `v1`, `v2`",
									Validators: []validator.String{
										stringvalidator.OneOf(
											"",
											"all",
											"v1",
											"v2",
										),
									},
									Default: stringdefault.StaticString("v2"),
								},
							},
							CustomType: TrapGroupsType{
								ObjectType: types.ObjectType{
									AttrTypes: TrapGroupsValue{}.AttributeTypes(ctx),
								},
							},
						},
						Optional: true,
					},
					"v2c_config": schema.ListNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"authorization": schema.StringAttribute{
									Optional: true,
								},
								"client_list_name": schema.StringAttribute{
									Optional:            true,
									Description:         "Client_list_name here should refer to client_list above",
									MarkdownDescription: "Client_list_name here should refer to client_list above",
								},
								"community_name": schema.StringAttribute{
									Optional: true,
								},
								"view": schema.StringAttribute{
									Optional:            true,
									Description:         "View name here should be defined in views above",
									MarkdownDescription: "View name here should be defined in views above",
								},
							},
							CustomType: V2cConfigType{
								ObjectType: types.ObjectType{
									AttrTypes: V2cConfigValue{}.AttributeTypes(ctx),
								},
							},
						},
						Optional: true,
					},
					"v3_config": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"notify": schema.ListNestedAttribute{
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											Required: true,
										},
										"tag": schema.StringAttribute{
											Required: true,
										},
										"type": schema.StringAttribute{
											Required:            true,
											Description:         "enum: `inform`, `trap`",
											MarkdownDescription: "enum: `inform`, `trap`",
											Validators: []validator.String{
												stringvalidator.OneOf(
													"",
													"inform",
													"trap",
												),
											},
										},
									},
									CustomType: NotifyType{
										ObjectType: types.ObjectType{
											AttrTypes: NotifyValue{}.AttributeTypes(ctx),
										},
									},
								},
								Optional: true,
								Validators: []validator.List{
									listvalidator.SizeAtLeast(1),
								},
							},
							"notify_filter": schema.ListNestedAttribute{
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"profile_name": schema.StringAttribute{
											Optional: true,
										},
										"contents": schema.ListNestedAttribute{
											NestedObject: schema.NestedAttributeObject{
												Attributes: map[string]schema.Attribute{
													"include": schema.BoolAttribute{
														Optional: true,
													},
													"oid": schema.StringAttribute{
														Required: true,
													},
												},
												CustomType: Snmpv3ContentsType{
													ObjectType: types.ObjectType{
														AttrTypes: Snmpv3ContentsValue{}.AttributeTypes(ctx),
													},
												},
											},
											Optional: true,
										},
									},
									CustomType: NotifyFilterType{
										ObjectType: types.ObjectType{
											AttrTypes: NotifyFilterValue{}.AttributeTypes(ctx),
										},
									},
								},
								Optional: true,
								Validators: []validator.List{
									listvalidator.SizeAtLeast(1),
								},
							},
							"target_address": schema.ListNestedAttribute{
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"address": schema.StringAttribute{
											Required: true,
										},
										"address_mask": schema.StringAttribute{
											Required: true,
										},
										"port": schema.StringAttribute{
											Optional: true,
											Computed: true,
											Default:  stringdefault.StaticString("161"),
										},
										"tag_list": schema.StringAttribute{
											Optional:            true,
											Description:         "Refer to notify tag, can be multiple with blank",
											MarkdownDescription: "Refer to notify tag, can be multiple with blank",
										},
										"target_address_name": schema.StringAttribute{
											Required: true,
										},
										"target_parameters": schema.StringAttribute{
											Optional:            true,
											Description:         "Refer to notify target parameters name",
											MarkdownDescription: "Refer to notify target parameters name",
										},
									},
									CustomType: TargetAddressType{
										ObjectType: types.ObjectType{
											AttrTypes: TargetAddressValue{}.AttributeTypes(ctx),
										},
									},
								},
								Optional: true,
								Validators: []validator.List{
									listvalidator.SizeAtLeast(1),
								},
							},
							"target_parameters": schema.ListNestedAttribute{
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"message_processing_model": schema.StringAttribute{
											Required:            true,
											Description:         "enum: `v1`, `v2c`, `v3`",
											MarkdownDescription: "enum: `v1`, `v2c`, `v3`",
											Validators: []validator.String{
												stringvalidator.OneOf(
													"",
													"v1",
													"v2c",
													"v3",
												),
											},
										},
										"name": schema.StringAttribute{
											Required: true,
										},
										"notify_filter": schema.StringAttribute{
											Optional:            true,
											Description:         "Refer to profile-name in notify_filter",
											MarkdownDescription: "Refer to profile-name in notify_filter",
										},
										"security_level": schema.StringAttribute{
											Optional:            true,
											Description:         "enum: `authentication`, `none`, `privacy`",
											MarkdownDescription: "enum: `authentication`, `none`, `privacy`",
											Validators: []validator.String{
												stringvalidator.OneOf(
													"",
													"authentication",
													"none",
													"privacy",
												),
											},
										},
										"security_model": schema.StringAttribute{
											Optional:            true,
											Description:         "enum: `usm`, `v1`, `v2c`",
											MarkdownDescription: "enum: `usm`, `v1`, `v2c`",
											Validators: []validator.String{
												stringvalidator.OneOf(
													"",
													"usm",
													"v1",
													"v2c",
												),
											},
										},
										"security_name": schema.StringAttribute{
											Optional:            true,
											Description:         "Refer to security_name in usm",
											MarkdownDescription: "Refer to security_name in usm",
										},
									},
									CustomType: TargetParametersType{
										ObjectType: types.ObjectType{
											AttrTypes: TargetParametersValue{}.AttributeTypes(ctx),
										},
									},
								},
								Optional: true,
								Validators: []validator.List{
									listvalidator.SizeAtLeast(1),
								},
							},
							"usm": schema.ListNestedAttribute{
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"engine_type": schema.StringAttribute{
											Required:            true,
											Description:         "enum: `local_engine`, `remote_engine`",
											MarkdownDescription: "enum: `local_engine`, `remote_engine`",
											Validators: []validator.String{
												stringvalidator.OneOf(
													"",
													"local_engine",
													"remote_engine",
												),
											},
										},
										"remote_engine_id": schema.StringAttribute{
											Optional:            true,
											Description:         "Required only if `engine_type`==`remote_engine`",
											MarkdownDescription: "Required only if `engine_type`==`remote_engine`",
											Validators: []validator.String{
												mistvalidator.RequiredWhenValueIs(path.MatchRelative().AtParent().AtName("engine_type"), types.StringValue("remote_engine")),
											},
										},
										"users": schema.ListNestedAttribute{
											NestedObject: schema.NestedAttributeObject{
												Attributes: map[string]schema.Attribute{
													"authentication_password": schema.StringAttribute{
														Optional:            true,
														Sensitive:           true,
														Description:         "Not required if `authentication_type`==`authentication-none`. Include alphabetic, numeric, and special characters, but it cannot include control characters.",
														MarkdownDescription: "Not required if `authentication_type`==`authentication-none`. Include alphabetic, numeric, and special characters, but it cannot include control characters.",
														Validators: []validator.String{
															stringvalidator.LengthAtLeast(7),
															mistvalidator.RequiredWhenValueIs(path.MatchRelative().AtParent().AtName("authentication_type"), types.StringValue("authentication-md5")),
															mistvalidator.RequiredWhenValueIs(path.MatchRelative().AtParent().AtName("authentication_type"), types.StringValue("authentication-sha")),
															mistvalidator.RequiredWhenValueIs(path.MatchRelative().AtParent().AtName("authentication_type"), types.StringValue("authentication-sha224")),
															mistvalidator.RequiredWhenValueIs(path.MatchRelative().AtParent().AtName("authentication_type"), types.StringValue("authentication-sha256")),
															mistvalidator.RequiredWhenValueIs(path.MatchRelative().AtParent().AtName("authentication_type"), types.StringValue("authentication-sha384")),
															mistvalidator.RequiredWhenValueIs(path.MatchRelative().AtParent().AtName("authentication_type"), types.StringValue("authentication-sha512")),
														},
													},
													"authentication_type": schema.StringAttribute{
														Optional:            true,
														Description:         "sha224, sha256, sha384, sha512 are supported in 21.1 and newer release. enum: `authentication-md5`, `authentication-none`, `authentication-sha`, `authentication-sha224`, `authentication-sha256`, `authentication-sha384`, `authentication-sha512`",
														MarkdownDescription: "sha224, sha256, sha384, sha512 are supported in 21.1 and newer release. enum: `authentication-md5`, `authentication-none`, `authentication-sha`, `authentication-sha224`, `authentication-sha256`, `authentication-sha384`, `authentication-sha512`",
														Validators: []validator.String{
															stringvalidator.OneOf(
																"",
																"authentication-md5",
																"authentication-none",
																"authentication-sha",
																"authentication-sha224",
																"authentication-sha256",
																"authentication-sha384",
																"authentication-sha512",
															),
														},
													},
													"encryption_password": schema.StringAttribute{
														Optional:            true,
														Sensitive:           true,
														Description:         "Not required if `encryption_type`==`privacy-none`. Include alphabetic, numeric, and special characters, but it cannot include control characters",
														MarkdownDescription: "Not required if `encryption_type`==`privacy-none`. Include alphabetic, numeric, and special characters, but it cannot include control characters",
														Validators: []validator.String{
															stringvalidator.LengthAtLeast(8),
															mistvalidator.RequiredWhenValueIs(path.MatchRelative().AtParent().AtName("encryption_type"), types.StringValue("privacy-aes128")),
															mistvalidator.RequiredWhenValueIs(path.MatchRelative().AtParent().AtName("encryption_type"), types.StringValue("privacy-des")),
															mistvalidator.RequiredWhenValueIs(path.MatchRelative().AtParent().AtName("encryption_type"), types.StringValue("privacy-3des")),
														},
													},
													"encryption_type": schema.StringAttribute{
														Optional:            true,
														Description:         "enum: `privacy-3des`, `privacy-aes128`, `privacy-des`, `privacy-none`",
														MarkdownDescription: "enum: `privacy-3des`, `privacy-aes128`, `privacy-des`, `privacy-none`",
														Validators: []validator.String{
															stringvalidator.OneOf(
																"",
																"privacy-3des",
																"privacy-aes128",
																"privacy-des",
																"privacy-none",
															),
														},
													},
													"name": schema.StringAttribute{
														Optional: true,
													},
												},
												CustomType: Snmpv3UsersType{
													ObjectType: types.ObjectType{
														AttrTypes: Snmpv3UsersValue{}.AttributeTypes(ctx),
													},
												},
											},
											Optional: true,
										},
									},
									CustomType: UsmType{
										ObjectType: types.ObjectType{
											AttrTypes: UsmValue{}.AttributeTypes(ctx),
										},
									},
								},
								Optional: true,
							},
							"vacm": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{
									"access": schema.ListNestedAttribute{
										NestedObject: schema.NestedAttributeObject{
											Attributes: map[string]schema.Attribute{
												"group_name": schema.StringAttribute{
													Optional: true,
												},
												"prefix_list": schema.ListNestedAttribute{
													NestedObject: schema.NestedAttributeObject{
														Attributes: map[string]schema.Attribute{
															"context_prefix": schema.StringAttribute{
																Optional:            true,
																Description:         "Only required if `type`==`context_prefix`",
																MarkdownDescription: "Only required if `type`==`context_prefix`",
																Validators: []validator.String{
																	stringvalidator.LengthAtLeast(7),
																	mistvalidator.RequiredWhenValueIs(path.MatchRelative().AtParent().AtName("type"), types.StringValue("context_prefix")),
																},
															},
															"notify_view": schema.StringAttribute{
																Optional:            true,
																Description:         "Refer to view name",
																MarkdownDescription: "Refer to view name",
															},
															"read_view": schema.StringAttribute{
																Optional:            true,
																Description:         "Refer to view name",
																MarkdownDescription: "Refer to view name",
															},
															"security_level": schema.StringAttribute{
																Optional:            true,
																Description:         "enum: `authentication`, `none`, `privacy`",
																MarkdownDescription: "enum: `authentication`, `none`, `privacy`",
																Validators: []validator.String{
																	stringvalidator.OneOf(
																		"",
																		"authentication",
																		"none",
																		"privacy",
																	),
																},
															},
															"security_model": schema.StringAttribute{
																Optional:            true,
																Description:         "enum: `any`, `usm`, `v1`, `v2c`",
																MarkdownDescription: "enum: `any`, `usm`, `v1`, `v2c`",
																Validators: []validator.String{
																	stringvalidator.OneOf(
																		"",
																		"any",
																		"usm",
																		"v1",
																		"v2c",
																	),
																},
															},
															"type": schema.StringAttribute{
																Optional:            true,
																Description:         "enum: `context_prefix`, `default_context_prefix`",
																MarkdownDescription: "enum: `context_prefix`, `default_context_prefix`",
																Validators: []validator.String{
																	stringvalidator.OneOf(
																		"",
																		"context_prefix",
																		"default_context_prefix",
																	),
																},
															},
															"write_view": schema.StringAttribute{
																Optional:            true,
																Description:         "Refer to view name",
																MarkdownDescription: "Refer to view name",
															},
														},
														CustomType: PrefixListType{
															ObjectType: types.ObjectType{
																AttrTypes: PrefixListValue{}.AttributeTypes(ctx),
															},
														},
													},
													Optional: true,
												},
											},
											CustomType: AccessType{
												ObjectType: types.ObjectType{
													AttrTypes: AccessValue{}.AttributeTypes(ctx),
												},
											},
										},
										Optional: true,
									},
									"security_to_group": schema.SingleNestedAttribute{
										Attributes: map[string]schema.Attribute{
											"security_model": schema.StringAttribute{
												Optional:            true,
												Description:         "enum: `usm`, `v1`, `v2c`",
												MarkdownDescription: "enum: `usm`, `v1`, `v2c`",
												Validators: []validator.String{
													stringvalidator.OneOf(
														"",
														"usm",
														"v1",
														"v2c",
													),
												},
											},
											"content": schema.ListNestedAttribute{
												NestedObject: schema.NestedAttributeObject{
													Attributes: map[string]schema.Attribute{
														"group": schema.StringAttribute{
															Optional:            true,
															Description:         "Refer to group_name under access",
															MarkdownDescription: "Refer to group_name under access",
														},
														"security_name": schema.StringAttribute{
															Optional: true,
														},
													},
													CustomType: Snmpv3VacmContentType{
														ObjectType: types.ObjectType{
															AttrTypes: Snmpv3VacmContentValue{}.AttributeTypes(ctx),
														},
													},
												},
												Optional: true,
											},
										},
										CustomType: SecurityToGroupType{
											ObjectType: types.ObjectType{
												AttrTypes: SecurityToGroupValue{}.AttributeTypes(ctx),
											},
										},
										Optional: true,
									},
								},
								CustomType: VacmType{
									ObjectType: types.ObjectType{
										AttrTypes: VacmValue{}.AttributeTypes(ctx),
									},
								},
								Optional: true,
							},
						},
						CustomType: V3ConfigType{
							ObjectType: types.ObjectType{
								AttrTypes: V3ConfigValue{}.AttributeTypes(ctx),
							},
						},
						Optional: true,
					},
					"views": schema.ListNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"include": schema.BoolAttribute{
									Optional:            true,
									Description:         "If the root oid configured is included",
									MarkdownDescription: "If the root oid configured is included",
								},
								"oid": schema.StringAttribute{
									Optional: true,
								},
								"view_name": schema.StringAttribute{
									Optional: true,
								},
							},
							CustomType: ViewsType{
								ObjectType: types.ObjectType{
									AttrTypes: ViewsValue{}.AttributeTypes(ctx),
								},
							},
						},
						Optional: true,
					},
				},
				CustomType: SnmpConfigType{
					ObjectType: types.ObjectType{
						AttrTypes: SnmpConfigValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
			},
			"switch_matching": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"enable": schema.BoolAttribute{
						Optional: true,
					},
					"rules": schema.ListNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"additional_config_cmds": schema.ListAttribute{
									ElementType:         types.StringType,
									Optional:            true,
									Description:         "additional CLI commands to append to the generated Junos config. **Note**: no check is done",
									MarkdownDescription: "additional CLI commands to append to the generated Junos config. **Note**: no check is done",
									Validators: []validator.List{
										listvalidator.SizeAtLeast(1),
									},
								},
								"ip_config": schema.SingleNestedAttribute{
									Attributes: map[string]schema.Attribute{
										"network": schema.StringAttribute{
											Optional:            true,
											Description:         "VLAN Name for the management interface",
											MarkdownDescription: "VLAN Name for the management interface",
										},
										"type": schema.StringAttribute{
											Optional:            true,
											Computed:            true,
											Description:         "enum: `dhcp`, `static`",
											MarkdownDescription: "enum: `dhcp`, `static`",
											Validators: []validator.String{
												stringvalidator.OneOf(
													"",
													"dhcp",
													"static",
												),
											},
											Default: stringdefault.StaticString("dhcp"),
										},
									},
									CustomType: IpConfigType{
										ObjectType: types.ObjectType{
											AttrTypes: IpConfigValue{}.AttributeTypes(ctx),
										},
									},
									Optional:            true,
									Description:         "In-Band Management interface configuration",
									MarkdownDescription: "In-Band Management interface configuration",
								},
								"match_model": schema.StringAttribute{
									Optional:            true,
									Description:         "string the switch model must start with to use this rule. It is possible to combine with the `match_name` and `match_role` attributes",
									MarkdownDescription: "string the switch model must start with to use this rule. It is possible to combine with the `match_name` and `match_role` attributes",
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.UseStateForUnknown(),
									},
									Validators: []validator.String{
										stringvalidator.LengthAtLeast(2),
									},
								},
								"match_name": schema.StringAttribute{
									Optional:            true,
									Description:         "string the switch name must start with to use this rule. Use the `match_name_offset` to indicate the first character of the switch name to compare to. It is possible to combine with the `match_model` and `match_role` attributes",
									MarkdownDescription: "string the switch name must start with to use this rule. Use the `match_name_offset` to indicate the first character of the switch name to compare to. It is possible to combine with the `match_model` and `match_role` attributes",
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.UseStateForUnknown(),
									},
									Validators: []validator.String{
										stringvalidator.LengthAtLeast(2),
									},
								},
								"match_name_offset": schema.Int64Attribute{
									Optional:            true,
									Computed:            true,
									Description:         "first character of the switch name to compare to the `match_name` value",
									MarkdownDescription: "first character of the switch name to compare to the `match_name` value",
									Validators: []validator.Int64{
										int64validator.AtLeast(0),
									},
									Default: int64default.StaticInt64(0),
								},
								"match_role": schema.StringAttribute{
									Optional:            true,
									Description:         "string the switch role must start with to use this rule. It is possible to combine with the `match_name` and `match_model` attributes",
									MarkdownDescription: "string the switch role must start with to use this rule. It is possible to combine with the `match_name` and `match_model` attributes",
								},
								"name": schema.StringAttribute{
									Optional:            true,
									Description:         "Rule name. WARNING: the name `default` is reserved and can only be used for the last rule in the list",
									MarkdownDescription: "Rule name. WARNING: the name `default` is reserved and can only be used for the last rule in the list",
									Validators: []validator.String{
										stringvalidator.LengthBetween(1, 32),
									},
								},
								"oob_ip_config": schema.SingleNestedAttribute{
									Attributes: map[string]schema.Attribute{
										"type": schema.StringAttribute{
											Optional:            true,
											Computed:            true,
											Description:         "enum: `dhcp`, `static`",
											MarkdownDescription: "enum: `dhcp`, `static`",
											Validators: []validator.String{
												stringvalidator.OneOf(
													"",
													"dhcp",
													"static",
												),
											},
											Default: stringdefault.StaticString("dhcp"),
										},
										"use_mgmt_vrf": schema.BoolAttribute{
											Optional:            true,
											Computed:            true,
											Description:         "If supported on the platform. If enabled, DNS will be using this routing-instance, too",
											MarkdownDescription: "If supported on the platform. If enabled, DNS will be using this routing-instance, too",
											Default:             booldefault.StaticBool(false),
										},
										"use_mgmt_vrf_for_host_out": schema.BoolAttribute{
											Optional:            true,
											Description:         "For host-out traffic (NTP/TACPLUS/RADIUS/SYSLOG/SNMP), if alternative source network/ip is desired",
											MarkdownDescription: "For host-out traffic (NTP/TACPLUS/RADIUS/SYSLOG/SNMP), if alternative source network/ip is desired",
										},
									},
									CustomType: OobIpConfigType{
										ObjectType: types.ObjectType{
											AttrTypes: OobIpConfigValue{}.AttributeTypes(ctx),
										},
									},
									Optional:            true,
									Description:         "Out-of-Band Management interface configuration",
									MarkdownDescription: "Out-of-Band Management interface configuration",
								},
								"port_config": schema.MapNestedAttribute{
									NestedObject: schema.NestedAttributeObject{
										Attributes: map[string]schema.Attribute{
											"ae_disable_lacp": schema.BoolAttribute{
												Optional:            true,
												Description:         "To disable LACP support for the AE interface",
												MarkdownDescription: "To disable LACP support for the AE interface",
											},
											"ae_idx": schema.Int64Attribute{
												Optional:            true,
												Description:         "Users could force to use the designated AE name",
												MarkdownDescription: "Users could force to use the designated AE name",
											},
											"ae_lacp_slow": schema.BoolAttribute{
												Optional:            true,
												Description:         "To use fast timeout",
												MarkdownDescription: "To use fast timeout",
											},
											"aggregated": schema.BoolAttribute{
												Optional: true,
											},
											"critical": schema.BoolAttribute{
												Optional:            true,
												Computed:            true,
												Description:         "To generate port up/down alarm",
												MarkdownDescription: "To generate port up/down alarm",
												Default:             booldefault.StaticBool(false),
											},
											"description": schema.StringAttribute{
												Optional: true,
											},
											"disable_autoneg": schema.BoolAttribute{
												Optional:            true,
												Description:         "If `speed` and `duplex` are specified, whether to disable autonegotiation",
												MarkdownDescription: "If `speed` and `duplex` are specified, whether to disable autonegotiation",
											},
											"duplex": schema.StringAttribute{
												Optional:            true,
												Description:         "enum: `auto`, `full`, `half`",
												MarkdownDescription: "enum: `auto`, `full`, `half`",
												Validators: []validator.String{
													stringvalidator.OneOf(
														"",
														"auto",
														"full",
														"half",
													),
												},
											},
											"dynamic_usage": schema.StringAttribute{
												Optional:            true,
												Description:         "Enable dynamic usage for this port. Set to `dynamic` to enable.",
												MarkdownDescription: "Enable dynamic usage for this port. Set to `dynamic` to enable.",
											},
											"esilag": schema.BoolAttribute{
												Optional: true,
											},
											"mtu": schema.Int64Attribute{
												Optional:            true,
												Description:         "Media maximum transmission unit (MTU) is the largest data unit that can be forwarded without fragmentation",
												MarkdownDescription: "Media maximum transmission unit (MTU) is the largest data unit that can be forwarded without fragmentation",
											},
											"networks": schema.ListAttribute{
												ElementType:         types.StringType,
												Optional:            true,
												Description:         "List of network names. Required if `usage`==`inet`",
												MarkdownDescription: "List of network names. Required if `usage`==`inet`",
											},
											"no_local_overwrite": schema.BoolAttribute{
												Optional:            true,
												Computed:            true,
												Description:         "Prevent helpdesk to override the port config",
												MarkdownDescription: "Prevent helpdesk to override the port config",
												Default:             booldefault.StaticBool(true),
											},
											"poe_disabled": schema.BoolAttribute{
												Optional: true,
											},
											"port_network": schema.StringAttribute{
												Optional:            true,
												Description:         "Required if `usage`==`vlan_tunnel`. Q-in-Q tunneling using All-in-one bundling. This also enables standard L2PT for interfaces that are not encapsulation tunnel interfaces and uses MAC rewrite operation. [View more information](https://www.juniper.net/documentation/us/en/software/junos/multicast-l2/topics/topic-map/q-in-q.html#id-understanding-qinq-tunneling-and-vlan-translation)",
												MarkdownDescription: "Required if `usage`==`vlan_tunnel`. Q-in-Q tunneling using All-in-one bundling. This also enables standard L2PT for interfaces that are not encapsulation tunnel interfaces and uses MAC rewrite operation. [View more information](https://www.juniper.net/documentation/us/en/software/junos/multicast-l2/topics/topic-map/q-in-q.html#id-understanding-qinq-tunneling-and-vlan-translation)",
											},
											"speed": schema.StringAttribute{
												Optional:            true,
												Description:         "enum: `100m`, `10m`, `1g`, `2.5g`, `5g`, `10g`, `25g`, `40g`, `100g`,`auto`",
												MarkdownDescription: "enum: `100m`, `10m`, `1g`, `2.5g`, `5g`, `10g`, `25g`, `40g`, `100g`,`auto`",
												Validators: []validator.String{
													stringvalidator.OneOf(
														"",
														"10m",
														"100m",
														"1g",
														"2.5g",
														"5g",
														"10g",
														"25g",
														"40g",
														"100g",
														"auto",
													),
												},
											},
											"usage": schema.StringAttribute{
												Required:            true,
												Description:         "Port usage name. For Q-in-Q, use `vlan_tunnel`. If EVPN is used, use `evpn_uplink`or `evpn_downlink`",
												MarkdownDescription: "Port usage name. For Q-in-Q, use `vlan_tunnel`. If EVPN is used, use `evpn_uplink`or `evpn_downlink`",
											},
										},
										CustomType: PortConfigType{
											ObjectType: types.ObjectType{
												AttrTypes: PortConfigValue{}.AttributeTypes(ctx),
											},
										},
									},
									Optional:            true,
									Description:         "Property key is the port name or range (e.g. \"ge-0/0/0-10\")",
									MarkdownDescription: "Property key is the port name or range (e.g. \"ge-0/0/0-10\")",
									Validators: []validator.Map{
										mapvalidator.SizeAtLeast(1),
									},
								},
								"port_mirroring": schema.MapNestedAttribute{
									NestedObject: schema.NestedAttributeObject{
										Attributes: map[string]schema.Attribute{
											"input_networks_ingress": schema.ListAttribute{
												ElementType:         types.StringType,
												Optional:            true,
												Computed:            true,
												Description:         "At least one of the `input_port_ids_ingress`, `input_port_ids_egress` or `input_networks_ingress ` should be specified",
												MarkdownDescription: "At least one of the `input_port_ids_ingress`, `input_port_ids_egress` or `input_networks_ingress ` should be specified",
												Default:             listdefault.StaticValue(basetypes.NewListValueMust(basetypes.StringType{}, []attr.Value{})),
											},
											"input_port_ids_egress": schema.ListAttribute{
												ElementType:         types.StringType,
												Optional:            true,
												Computed:            true,
												Description:         "At least one of the `input_port_ids_ingress`, `input_port_ids_egress` or `input_networks_ingress ` should be specified",
												MarkdownDescription: "At least one of the `input_port_ids_ingress`, `input_port_ids_egress` or `input_networks_ingress ` should be specified",
												Default:             listdefault.StaticValue(basetypes.NewListValueMust(basetypes.StringType{}, []attr.Value{})),
											},
											"input_port_ids_ingress": schema.ListAttribute{
												ElementType:         types.StringType,
												Optional:            true,
												Computed:            true,
												Description:         "At least one of the `input_port_ids_ingress`, `input_port_ids_egress` or `input_networks_ingress ` should be specified",
												MarkdownDescription: "At least one of the `input_port_ids_ingress`, `input_port_ids_egress` or `input_networks_ingress ` should be specified",
												Default:             listdefault.StaticValue(basetypes.NewListValueMust(basetypes.StringType{}, []attr.Value{})),
											},
											"output_ip_address": schema.StringAttribute{
												Optional:            true,
												Description:         "Exactly one of the `output_ip_address`, `output_port_id` or `output_network` should be provided",
												MarkdownDescription: "Exactly one of the `output_ip_address`, `output_port_id` or `output_network` should be provided",
											},
											"output_network": schema.StringAttribute{
												Optional:            true,
												Description:         "Exactly one of the `output_ip_address`, `output_port_id` or `output_network` should be provided",
												MarkdownDescription: "Exactly one of the `output_ip_address`, `output_port_id` or `output_network` should be provided",
											},
											"output_port_id": schema.StringAttribute{
												Optional:            true,
												Description:         "Exactly one of the `output_ip_address`, `output_port_id` or `output_network` should be provided",
												MarkdownDescription: "Exactly one of the `output_ip_address`, `output_port_id` or `output_network` should be provided",
											},
										},
										CustomType: PortMirroringType{
											ObjectType: types.ObjectType{
												AttrTypes: PortMirroringValue{}.AttributeTypes(ctx),
											},
										},
										Validators: []validator.Object{
											mistvalidator.AtLeastNOf(
												1,
												path.MatchRelative().AtName("input_networks_ingress"),
												path.MatchRelative().AtName("input_port_ids_egress"),
												path.MatchRelative().AtName("input_port_ids_ingress"),
											),
											mistvalidator.AtMostNOf(
												1,
												path.MatchRelative().AtName("output_network"),
												path.MatchRelative().AtName("output_port_id"),
											),
										},
									},
									Optional:            true,
									Description:         "Property key is the port mirroring instance name. `port_mirroring` can be added under device/site settings. It takes interface and ports as input for ingress, interface as input for egress and can take interface and port as output. A maximum 4 mirroring ports is allowed",
									MarkdownDescription: "Property key is the port mirroring instance name. `port_mirroring` can be added under device/site settings. It takes interface and ports as input for ingress, interface as input for egress and can take interface and port as output. A maximum 4 mirroring ports is allowed",
									Validators: []validator.Map{
										mapvalidator.SizeAtMost(4),
									},
								},
								"stp_config": schema.SingleNestedAttribute{
									Attributes: map[string]schema.Attribute{
										"bridge_priority": schema.StringAttribute{
											Optional:            true,
											Computed:            true,
											Description:         "Switch STP priority. Range [0, 4k, 8k.. 60k] in steps of 4k. Bridge priority applies to both VSTP and RSTP.",
											MarkdownDescription: "Switch STP priority. Range [0, 4k, 8k.. 60k] in steps of 4k. Bridge priority applies to both VSTP and RSTP.",
											Default:             stringdefault.StaticString("32k"),
										},
									},
									CustomType: StpConfigType{
										ObjectType: types.ObjectType{
											AttrTypes: StpConfigValue{}.AttributeTypes(ctx),
										},
									},
									Optional: true,
								},
							},
							CustomType: MatchingRulesType{
								ObjectType: types.ObjectType{
									AttrTypes: MatchingRulesValue{}.AttributeTypes(ctx),
								},
							},
							Validators: []validator.Object{
								objectvalidator.AtLeastOneOf(
									path.MatchRelative().AtName("match_type"),
									path.MatchRelative().AtName("match_model"),
									path.MatchRelative().AtName("match_name"),
									path.MatchRelative().AtName("match_role"),
								),
							},
						},
						Optional:            true,
						Description:         "list of rules to define custom switch configuration based on different criteria. Each list must have at least one of `match_model`, `match_name` or `match_role` must be defined",
						MarkdownDescription: "list of rules to define custom switch configuration based on different criteria. Each list must have at least one of `match_model`, `match_name` or `match_role` must be defined",
						Validators: []validator.List{
							listvalidator.SizeAtLeast(1),
							mistvalidator.SwitchMatchingRuleNames(),
						},
					},
				},
				CustomType: SwitchMatchingType{
					ObjectType: types.ObjectType{
						AttrTypes: SwitchMatchingValue{}.AttributeTypes(ctx),
					},
				},
				Optional:            true,
				Description:         "Defines custom switch configuration based on different criteria",
				MarkdownDescription: "Defines custom switch configuration based on different criteria",
			},
			"switch_mgmt": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"ap_affinity_threshold": schema.Int64Attribute{
						Optional:            true,
						Description:         "AP_affinity_threshold ap_affinity_threshold can be added as a field under site/setting. By default, this value is set to 12. If the field is set in both site/setting and org/setting, the value from site/setting will be used.",
						MarkdownDescription: "AP_affinity_threshold ap_affinity_threshold can be added as a field under site/setting. By default, this value is set to 12. If the field is set in both site/setting and org/setting, the value from site/setting will be used.",
					},
					"cli_banner": schema.StringAttribute{
						Optional:            true,
						Description:         "Set Banners for switches. Allows markup formatting",
						MarkdownDescription: "Set Banners for switches. Allows markup formatting",
					},
					"cli_idle_timeout": schema.Int64Attribute{
						Optional:            true,
						Description:         "Sets timeout for switches",
						MarkdownDescription: "Sets timeout for switches",
						Validators: []validator.Int64{
							int64validator.Between(1, 60),
						},
					},
					"config_revert_timer": schema.Int64Attribute{
						Optional:            true,
						Computed:            true,
						Description:         "Rollback timer for commit confirmed",
						MarkdownDescription: "Rollback timer for commit confirmed",
						Validators: []validator.Int64{
							int64validator.Between(1, 30),
						},
						Default: int64default.StaticInt64(10),
					},
					"dhcp_option_fqdn": schema.BoolAttribute{
						Optional:            true,
						Description:         "Enable to provide the FQDN with DHCP option 81",
						MarkdownDescription: "Enable to provide the FQDN with DHCP option 81",
					},
					"disable_oob_down_alarm": schema.BoolAttribute{
						Optional: true,
					},
					"fips_enabled": schema.BoolAttribute{
						Optional: true,
					},
					"local_accounts": schema.MapNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"password": schema.StringAttribute{
									Optional:  true,
									Sensitive: true,
								},
								"role": schema.StringAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "enum: `admin`, `helpdesk`, `none`, `read`",
									MarkdownDescription: "enum: `admin`, `helpdesk`, `none`, `read`",
									Validators: []validator.String{
										stringvalidator.OneOf(
											"",
											"admin",
											"helpdesk",
											"none",
											"read",
										),
									},
									Default: stringdefault.StaticString("none"),
								},
							},
							CustomType: LocalAccountsType{
								ObjectType: types.ObjectType{
									AttrTypes: LocalAccountsValue{}.AttributeTypes(ctx),
								},
							},
						},
						Optional:            true,
						Description:         "Property key is the user name. For Local user authentication",
						MarkdownDescription: "Property key is the user name. For Local user authentication",
					},
					"mxedge_proxy_host": schema.StringAttribute{
						Optional:            true,
						Description:         "IP Address or FQDN of the Mist Edge used to proxy the switch management traffic to the Mist Cloud",
						MarkdownDescription: "IP Address or FQDN of the Mist Edge used to proxy the switch management traffic to the Mist Cloud",
					},
					"mxedge_proxy_port": schema.StringAttribute{
						Optional:            true,
						Description:         "Mist Edge port used to proxy the switch management traffic to the Mist Cloud. Value in range 1-65535",
						MarkdownDescription: "Mist Edge port used to proxy the switch management traffic to the Mist Cloud. Value in range 1-65535",
						Validators: []validator.String{
							stringvalidator.Any(mistvalidator.ParseInt(1, 65535), mistvalidator.ParseVar()),
						},
					},
					"protect_re": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"allowed_services": schema.ListAttribute{
								ElementType:         types.StringType,
								Optional:            true,
								Computed:            true,
								Description:         "optionally, services we'll allow. enum: `icmp`, `ssh`",
								MarkdownDescription: "optionally, services we'll allow. enum: `icmp`, `ssh`",
								Validators: []validator.List{
									listvalidator.ValueStringsAre(
										stringvalidator.OneOf(
											"icmp",
											"ssh",
										),
									),
								},
								Default: listdefault.StaticValue(basetypes.NewListValueMust(basetypes.StringType{}, []attr.Value{})),
							},
							"custom": schema.ListNestedAttribute{
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"port_range": schema.StringAttribute{
											Optional:            true,
											Computed:            true,
											Description:         "matched dst port, \"0\" means any. Note: For `protocol`==`any` and  `port_range`==`any`, configure `trusted_hosts` instead",
											MarkdownDescription: "matched dst port, \"0\" means any. Note: For `protocol`==`any` and  `port_range`==`any`, configure `trusted_hosts` instead",
											Validators: []validator.String{
												stringvalidator.Any(mistvalidator.ParseRangeOfInt(0, 65535, true), mistvalidator.ParseInt(0, 65535)),
											},
											Default: stringdefault.StaticString("0"),
										},
										"protocol": schema.StringAttribute{
											Optional:            true,
											Computed:            true,
											Description:         "enum: `any`, `icmp`, `tcp`, `udp`. Note: For `protocol`==`any` and  `port_range`==`any`, configure `trusted_hosts` instead",
											MarkdownDescription: "enum: `any`, `icmp`, `tcp`, `udp`. Note: For `protocol`==`any` and  `port_range`==`any`, configure `trusted_hosts` instead",
											Validators: []validator.String{
												stringvalidator.OneOf(
													"",
													"any",
													"icmp",
													"tcp",
													"udp",
												),
											},
											Default: stringdefault.StaticString("any"),
										},
										"subnets": schema.ListAttribute{
											ElementType: types.StringType,
											Required:    true,
											Validators: []validator.List{
												listvalidator.SizeAtLeast(1),
												listvalidator.ValueStringsAre(
													stringvalidator.Any(
														mistvalidator.ParseCidr(false, false),
														mistvalidator.ParseIp(false, false),
													),
												),
											},
										},
									},
									CustomType: CustomType{
										ObjectType: types.ObjectType{
											AttrTypes: CustomValue{}.AttributeTypes(ctx),
										},
									},
								},
								Optional: true,
								Computed: true,
								Default:  listdefault.StaticValue(basetypes.NewListValueMust(CustomValue{}.Type(ctx), []attr.Value{})),
							},
							"enabled": schema.BoolAttribute{
								Optional:            true,
								Computed:            true,
								Description:         "When enabled, all traffic that is not essential to our operation will be dropped\ne.g. ntp / dns / traffic to mist will be allowed by default\n     if dhcpd is enabled, we'll make sure it works",
								MarkdownDescription: "When enabled, all traffic that is not essential to our operation will be dropped\ne.g. ntp / dns / traffic to mist will be allowed by default\n     if dhcpd is enabled, we'll make sure it works",
								Default:             booldefault.StaticBool(false),
							},
							"hit_count": schema.BoolAttribute{
								Optional:            true,
								Computed:            true,
								Description:         "Whether to enable hit count for Protect_RE policy",
								MarkdownDescription: "Whether to enable hit count for Protect_RE policy",
								Default:             booldefault.StaticBool(false),
							},
							"trusted_hosts": schema.ListAttribute{
								ElementType:         types.StringType,
								Optional:            true,
								Computed:            true,
								Description:         "host/subnets we'll allow traffic to/from",
								MarkdownDescription: "host/subnets we'll allow traffic to/from",
								Default:             listdefault.StaticValue(basetypes.NewListValueMust(basetypes.StringType{}, []attr.Value{})),
							},
						},
						CustomType: ProtectReType{
							ObjectType: types.ObjectType{
								AttrTypes: ProtectReValue{}.AttributeTypes(ctx),
							},
						},
						Optional:            true,
						Description:         "Restrict inbound-traffic to host\nwhen enabled, all traffic that is not essential to our operation will be dropped \ne.g. ntp / dns / traffic to mist will be allowed by default, if dhcpd is enabled, we'll make sure it works",
						MarkdownDescription: "Restrict inbound-traffic to host\nwhen enabled, all traffic that is not essential to our operation will be dropped \ne.g. ntp / dns / traffic to mist will be allowed by default, if dhcpd is enabled, we'll make sure it works",
					},
					"remove_existing_configs": schema.BoolAttribute{
						Optional:            true,
						Description:         "By default, only the configuration generated by Mist is cleaned up during the configuration process. If `true`, all the existing configuration will be removed.",
						MarkdownDescription: "By default, only the configuration generated by Mist is cleaned up during the configuration process. If `true`, all the existing configuration will be removed.",
					},
					"root_password": schema.StringAttribute{
						Optional:  true,
						Sensitive: true,
					},
					"tacacs": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"default_role": schema.StringAttribute{
								Optional:            true,
								Description:         "enum: `admin`, `helpdesk`, `none`, `read`",
								MarkdownDescription: "enum: `admin`, `helpdesk`, `none`, `read`",
								Validators: []validator.String{
									stringvalidator.OneOf(
										"",
										"admin",
										"helpdesk",
										"none",
										"read",
									),
								},
							},
							"enabled": schema.BoolAttribute{
								Optional: true,
							},
							"network": schema.StringAttribute{
								Optional:            true,
								Description:         "Which network the TACACS server resides",
								MarkdownDescription: "Which network the TACACS server resides",
							},
							"acct_servers": schema.ListNestedAttribute{
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"host": schema.StringAttribute{
											Optional: true,
										},
										"port": schema.StringAttribute{
											Optional: true,
										},
										"secret": schema.StringAttribute{
											Optional:  true,
											Sensitive: true,
										},
										"timeout": schema.Int64Attribute{
											Optional: true,
											Computed: true,
											Default:  int64default.StaticInt64(10),
										},
									},
									CustomType: TacacctServersType{
										ObjectType: types.ObjectType{
											AttrTypes: TacacctServersValue{}.AttributeTypes(ctx),
										},
									},
								},
								Optional: true,
								Validators: []validator.List{
									listvalidator.SizeAtLeast(1),
								},
							},
							"tacplus_servers": schema.ListNestedAttribute{
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"host": schema.StringAttribute{
											Optional: true,
										},
										"port": schema.StringAttribute{
											Optional: true,
										},
										"secret": schema.StringAttribute{
											Optional:  true,
											Sensitive: true,
										},
										"timeout": schema.Int64Attribute{
											Optional: true,
											Computed: true,
											Default:  int64default.StaticInt64(10),
										},
									},
									CustomType: TacplusServersType{
										ObjectType: types.ObjectType{
											AttrTypes: TacplusServersValue{}.AttributeTypes(ctx),
										},
									},
								},
								Optional: true,
								Validators: []validator.List{
									listvalidator.SizeAtLeast(1),
								},
							},
						},
						CustomType: TacacsType{
							ObjectType: types.ObjectType{
								AttrTypes: TacacsValue{}.AttributeTypes(ctx),
							},
						},
						Optional: true,
					},
					"use_mxedge_proxy": schema.BoolAttribute{
						Optional:            true,
						Description:         "To use mxedge as proxy",
						MarkdownDescription: "To use mxedge as proxy",
					},
				},
				CustomType: SwitchMgmtType{
					ObjectType: types.ObjectType{
						AttrTypes: SwitchMgmtValue{}.AttributeTypes(ctx),
					},
				},
				Optional:            true,
				Description:         "Switch settings",
				MarkdownDescription: "Switch settings",
			},
			"vrf_config": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"enabled": schema.BoolAttribute{
						Optional:            true,
						Description:         "Whether to enable VRF (when supported on the device)",
						MarkdownDescription: "Whether to enable VRF (when supported on the device)",
					},
				},
				CustomType: VrfConfigType{
					ObjectType: types.ObjectType{
						AttrTypes: VrfConfigValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
			},
			"vrf_instances": schema.MapNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"evpn_auto_loopback_subnet": schema.StringAttribute{
							Optional: true,
						},
						"evpn_auto_loopback_subnet6": schema.StringAttribute{
							Optional: true,
						},
						"networks": schema.ListAttribute{
							ElementType: types.StringType,
							Optional:    true,
							Validators: []validator.List{
								listvalidator.UniqueValues(),
							},
						},
						"extra_routes": schema.MapNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"via": schema.StringAttribute{
										Required:            true,
										Description:         "Next-hop address",
										MarkdownDescription: "Next-hop address",
										Validators: []validator.String{
											stringvalidator.Any(mistvalidator.ParseIp(false, true), mistvalidator.ParseVar()),
										},
									},
								},
								CustomType: VrfExtraRoutesType{
									ObjectType: types.ObjectType{
										AttrTypes: VrfExtraRoutesValue{}.AttributeTypes(ctx),
									},
								},
							},
							Optional:            true,
							Description:         "Property key is the destination CIDR (e.g. \"10.0.0.0/8\")",
							MarkdownDescription: "Property key is the destination CIDR (e.g. \"10.0.0.0/8\")",
							Validators: []validator.Map{
								mapvalidator.KeysAre(stringvalidator.Any(mistvalidator.ParseCidr(false, true), mistvalidator.ParseVar())),
							},
						},
						"extra_routes6": schema.MapNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"via": schema.StringAttribute{
										Optional:            true,
										Description:         "Next-hop address",
										MarkdownDescription: "Next-hop address",
									},
								},
								CustomType: VrfExtraRoutes6Type{
									ObjectType: types.ObjectType{
										AttrTypes: VrfExtraRoutes6Value{}.AttributeTypes(ctx),
									},
								},
							},
							Optional:            true,
							Description:         "Property key is the destination CIDR (e.g. \"2a02:1234:420a:10c9::/64\")",
							MarkdownDescription: "Property key is the destination CIDR (e.g. \"2a02:1234:420a:10c9::/64\")",
							Validators: []validator.Map{
								mapvalidator.SizeAtLeast(1),
							},
						},
					},
					CustomType: VrfInstancesType{
						ObjectType: types.ObjectType{
							AttrTypes: VrfInstancesValue{}.AttributeTypes(ctx),
						},
					},
				},
				Optional:            true,
				Description:         "Property key is the network name",
				MarkdownDescription: "Property key is the network name",
				Validators: []validator.Map{
					mapvalidator.KeysAre(mistvalidator.ParseName()),
				},
			},
		},
	}
}

type OrgNetworktemplateModel struct {
	AclPolicies           types.List          `tfsdk:"acl_policies"`
	AclTags               types.Map           `tfsdk:"acl_tags"`
	AdditionalConfigCmds  types.List          `tfsdk:"additional_config_cmds"`
	BgpConfig             types.Map           `tfsdk:"bgp_config"`
	DhcpSnooping          DhcpSnoopingValue   `tfsdk:"dhcp_snooping"`
	DnsServers            types.List          `tfsdk:"dns_servers"`
	DnsSuffix             types.List          `tfsdk:"dns_suffix"`
	ExtraRoutes           types.Map           `tfsdk:"extra_routes"`
	ExtraRoutes6          types.Map           `tfsdk:"extra_routes6"`
	Id                    types.String        `tfsdk:"id"`
	MistNac               MistNacValue        `tfsdk:"mist_nac"`
	Name                  types.String        `tfsdk:"name"`
	Networks              types.Map           `tfsdk:"networks"`
	NtpServers            types.List          `tfsdk:"ntp_servers"`
	OrgId                 types.String        `tfsdk:"org_id"`
	OspfAreas             types.Map           `tfsdk:"ospf_areas"`
	PortMirroring         types.Map           `tfsdk:"port_mirroring"`
	PortUsages            types.Map           `tfsdk:"port_usages"`
	RadiusConfig          RadiusConfigValue   `tfsdk:"radius_config"`
	RemoteSyslog          RemoteSyslogValue   `tfsdk:"remote_syslog"`
	RemoveExistingConfigs types.Bool          `tfsdk:"remove_existing_configs"`
	SnmpConfig            SnmpConfigValue     `tfsdk:"snmp_config"`
	SwitchMatching        SwitchMatchingValue `tfsdk:"switch_matching"`
	SwitchMgmt            SwitchMgmtValue     `tfsdk:"switch_mgmt"`
	VrfConfig             VrfConfigValue      `tfsdk:"vrf_config"`
	VrfInstances          types.Map           `tfsdk:"vrf_instances"`
}

var _ basetypes.ObjectTypable = AclPoliciesType{}

type AclPoliciesType struct {
	basetypes.ObjectType
}

func (t AclPoliciesType) Equal(o attr.Type) bool {
	other, ok := o.(AclPoliciesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AclPoliciesType) String() string {
	return "AclPoliciesType"
}

func (t AclPoliciesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	actionsAttribute, ok := attributes["actions"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`actions is missing from object`)

		return nil, diags
	}

	actionsVal, ok := actionsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`actions expected to be basetypes.ListValue, was: %T`, actionsAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	srcTagsAttribute, ok := attributes["src_tags"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`src_tags is missing from object`)

		return nil, diags
	}

	srcTagsVal, ok := srcTagsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`src_tags expected to be basetypes.ListValue, was: %T`, srcTagsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AclPoliciesValue{
		Actions: actionsVal,
		Name:    nameVal,
		SrcTags: srcTagsVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewAclPoliciesValueNull() AclPoliciesValue {
	return AclPoliciesValue{
		state: attr.ValueStateNull,
	}
}

func NewAclPoliciesValueUnknown() AclPoliciesValue {
	return AclPoliciesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewAclPoliciesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AclPoliciesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AclPoliciesValue Attribute Value",
				"While creating a AclPoliciesValue value, a missing attribute value was detected. "+
					"A AclPoliciesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AclPoliciesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AclPoliciesValue Attribute Type",
				"While creating a AclPoliciesValue value, an invalid attribute value was detected. "+
					"A AclPoliciesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AclPoliciesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AclPoliciesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AclPoliciesValue Attribute Value",
				"While creating a AclPoliciesValue value, an extra attribute value was detected. "+
					"A AclPoliciesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AclPoliciesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAclPoliciesValueUnknown(), diags
	}

	actionsAttribute, ok := attributes["actions"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`actions is missing from object`)

		return NewAclPoliciesValueUnknown(), diags
	}

	actionsVal, ok := actionsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`actions expected to be basetypes.ListValue, was: %T`, actionsAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewAclPoliciesValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	srcTagsAttribute, ok := attributes["src_tags"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`src_tags is missing from object`)

		return NewAclPoliciesValueUnknown(), diags
	}

	srcTagsVal, ok := srcTagsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`src_tags expected to be basetypes.ListValue, was: %T`, srcTagsAttribute))
	}

	if diags.HasError() {
		return NewAclPoliciesValueUnknown(), diags
	}

	return AclPoliciesValue{
		Actions: actionsVal,
		Name:    nameVal,
		SrcTags: srcTagsVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewAclPoliciesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AclPoliciesValue {
	object, diags := NewAclPoliciesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAclPoliciesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AclPoliciesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAclPoliciesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAclPoliciesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAclPoliciesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAclPoliciesValueMust(AclPoliciesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t AclPoliciesType) ValueType(ctx context.Context) attr.Value {
	return AclPoliciesValue{}
}

var _ basetypes.ObjectValuable = AclPoliciesValue{}

type AclPoliciesValue struct {
	Actions basetypes.ListValue   `tfsdk:"actions"`
	Name    basetypes.StringValue `tfsdk:"name"`
	SrcTags basetypes.ListValue   `tfsdk:"src_tags"`
	state   attr.ValueState
}

func (v AclPoliciesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["actions"] = basetypes.ListType{
		ElemType: ActionsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["src_tags"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Actions.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["actions"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.SrcTags.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["src_tags"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AclPoliciesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AclPoliciesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AclPoliciesValue) String() string {
	return "AclPoliciesValue"
}

func (v AclPoliciesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	actions := types.ListValueMust(
		ActionsType{
			basetypes.ObjectType{
				AttrTypes: ActionsValue{}.AttributeTypes(ctx),
			},
		},
		v.Actions.Elements(),
	)

	if v.Actions.IsNull() {
		actions = types.ListNull(
			ActionsType{
				basetypes.ObjectType{
					AttrTypes: ActionsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Actions.IsUnknown() {
		actions = types.ListUnknown(
			ActionsType{
				basetypes.ObjectType{
					AttrTypes: ActionsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var srcTagsVal basetypes.ListValue
	switch {
	case v.SrcTags.IsUnknown():
		srcTagsVal = types.ListUnknown(types.StringType)
	case v.SrcTags.IsNull():
		srcTagsVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		srcTagsVal, d = types.ListValue(types.StringType, v.SrcTags.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"actions": basetypes.ListType{
				ElemType: ActionsValue{}.Type(ctx),
			},
			"name": basetypes.StringType{},
			"src_tags": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"actions": basetypes.ListType{
			ElemType: ActionsValue{}.Type(ctx),
		},
		"name": basetypes.StringType{},
		"src_tags": basetypes.ListType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"actions":  actions,
			"name":     v.Name,
			"src_tags": srcTagsVal,
		})

	return objVal, diags
}

func (v AclPoliciesValue) Equal(o attr.Value) bool {
	other, ok := o.(AclPoliciesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Actions.Equal(other.Actions) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.SrcTags.Equal(other.SrcTags) {
		return false
	}

	return true
}

func (v AclPoliciesValue) Type(ctx context.Context) attr.Type {
	return AclPoliciesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AclPoliciesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"actions": basetypes.ListType{
			ElemType: ActionsValue{}.Type(ctx),
		},
		"name": basetypes.StringType{},
		"src_tags": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = ActionsType{}

type ActionsType struct {
	basetypes.ObjectType
}

func (t ActionsType) Equal(o attr.Type) bool {
	other, ok := o.(ActionsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ActionsType) String() string {
	return "ActionsType"
}

func (t ActionsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	actionAttribute, ok := attributes["action"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`action is missing from object`)

		return nil, diags
	}

	actionVal, ok := actionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`action expected to be basetypes.StringValue, was: %T`, actionAttribute))
	}

	dstTagAttribute, ok := attributes["dst_tag"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dst_tag is missing from object`)

		return nil, diags
	}

	dstTagVal, ok := dstTagAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dst_tag expected to be basetypes.StringValue, was: %T`, dstTagAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ActionsValue{
		Action: actionVal,
		DstTag: dstTagVal,
		state:  attr.ValueStateKnown,
	}, diags
}

func NewActionsValueNull() ActionsValue {
	return ActionsValue{
		state: attr.ValueStateNull,
	}
}

func NewActionsValueUnknown() ActionsValue {
	return ActionsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewActionsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ActionsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ActionsValue Attribute Value",
				"While creating a ActionsValue value, a missing attribute value was detected. "+
					"A ActionsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ActionsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ActionsValue Attribute Type",
				"While creating a ActionsValue value, an invalid attribute value was detected. "+
					"A ActionsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ActionsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ActionsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ActionsValue Attribute Value",
				"While creating a ActionsValue value, an extra attribute value was detected. "+
					"A ActionsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ActionsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewActionsValueUnknown(), diags
	}

	actionAttribute, ok := attributes["action"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`action is missing from object`)

		return NewActionsValueUnknown(), diags
	}

	actionVal, ok := actionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`action expected to be basetypes.StringValue, was: %T`, actionAttribute))
	}

	dstTagAttribute, ok := attributes["dst_tag"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dst_tag is missing from object`)

		return NewActionsValueUnknown(), diags
	}

	dstTagVal, ok := dstTagAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dst_tag expected to be basetypes.StringValue, was: %T`, dstTagAttribute))
	}

	if diags.HasError() {
		return NewActionsValueUnknown(), diags
	}

	return ActionsValue{
		Action: actionVal,
		DstTag: dstTagVal,
		state:  attr.ValueStateKnown,
	}, diags
}

func NewActionsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ActionsValue {
	object, diags := NewActionsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewActionsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ActionsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewActionsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewActionsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewActionsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewActionsValueMust(ActionsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ActionsType) ValueType(ctx context.Context) attr.Value {
	return ActionsValue{}
}

var _ basetypes.ObjectValuable = ActionsValue{}

type ActionsValue struct {
	Action basetypes.StringValue `tfsdk:"action"`
	DstTag basetypes.StringValue `tfsdk:"dst_tag"`
	state  attr.ValueState
}

func (v ActionsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["action"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["dst_tag"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Action.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["action"] = val

		val, err = v.DstTag.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dst_tag"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ActionsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ActionsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ActionsValue) String() string {
	return "ActionsValue"
}

func (v ActionsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"action":  basetypes.StringType{},
		"dst_tag": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"action":  v.Action,
			"dst_tag": v.DstTag,
		})

	return objVal, diags
}

func (v ActionsValue) Equal(o attr.Value) bool {
	other, ok := o.(ActionsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Action.Equal(other.Action) {
		return false
	}

	if !v.DstTag.Equal(other.DstTag) {
		return false
	}

	return true
}

func (v ActionsValue) Type(ctx context.Context) attr.Type {
	return ActionsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ActionsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"action":  basetypes.StringType{},
		"dst_tag": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = AclTagsType{}

type AclTagsType struct {
	basetypes.ObjectType
}

func (t AclTagsType) Equal(o attr.Type) bool {
	other, ok := o.(AclTagsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AclTagsType) String() string {
	return "AclTagsType"
}

func (t AclTagsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	etherTypesAttribute, ok := attributes["ether_types"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ether_types is missing from object`)

		return nil, diags
	}

	etherTypesVal, ok := etherTypesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ether_types expected to be basetypes.ListValue, was: %T`, etherTypesAttribute))
	}

	gbpTagAttribute, ok := attributes["gbp_tag"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gbp_tag is missing from object`)

		return nil, diags
	}

	gbpTagVal, ok := gbpTagAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gbp_tag expected to be basetypes.Int64Value, was: %T`, gbpTagAttribute))
	}

	macsAttribute, ok := attributes["macs"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`macs is missing from object`)

		return nil, diags
	}

	macsVal, ok := macsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`macs expected to be basetypes.ListValue, was: %T`, macsAttribute))
	}

	networkAttribute, ok := attributes["network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`network is missing from object`)

		return nil, diags
	}

	networkVal, ok := networkAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`network expected to be basetypes.StringValue, was: %T`, networkAttribute))
	}

	portUsageAttribute, ok := attributes["port_usage"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_usage is missing from object`)

		return nil, diags
	}

	portUsageVal, ok := portUsageAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_usage expected to be basetypes.StringValue, was: %T`, portUsageAttribute))
	}

	radiusGroupAttribute, ok := attributes["radius_group"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`radius_group is missing from object`)

		return nil, diags
	}

	radiusGroupVal, ok := radiusGroupAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`radius_group expected to be basetypes.StringValue, was: %T`, radiusGroupAttribute))
	}

	specsAttribute, ok := attributes["specs"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`specs is missing from object`)

		return nil, diags
	}

	specsVal, ok := specsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`specs expected to be basetypes.ListValue, was: %T`, specsAttribute))
	}

	subnetsAttribute, ok := attributes["subnets"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnets is missing from object`)

		return nil, diags
	}

	subnetsVal, ok := subnetsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnets expected to be basetypes.ListValue, was: %T`, subnetsAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AclTagsValue{
		EtherTypes:  etherTypesVal,
		GbpTag:      gbpTagVal,
		Macs:        macsVal,
		Network:     networkVal,
		PortUsage:   portUsageVal,
		RadiusGroup: radiusGroupVal,
		Specs:       specsVal,
		Subnets:     subnetsVal,
		AclTagsType: typeVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewAclTagsValueNull() AclTagsValue {
	return AclTagsValue{
		state: attr.ValueStateNull,
	}
}

func NewAclTagsValueUnknown() AclTagsValue {
	return AclTagsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewAclTagsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AclTagsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AclTagsValue Attribute Value",
				"While creating a AclTagsValue value, a missing attribute value was detected. "+
					"A AclTagsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AclTagsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AclTagsValue Attribute Type",
				"While creating a AclTagsValue value, an invalid attribute value was detected. "+
					"A AclTagsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AclTagsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AclTagsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AclTagsValue Attribute Value",
				"While creating a AclTagsValue value, an extra attribute value was detected. "+
					"A AclTagsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AclTagsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAclTagsValueUnknown(), diags
	}

	etherTypesAttribute, ok := attributes["ether_types"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ether_types is missing from object`)

		return NewAclTagsValueUnknown(), diags
	}

	etherTypesVal, ok := etherTypesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ether_types expected to be basetypes.ListValue, was: %T`, etherTypesAttribute))
	}

	gbpTagAttribute, ok := attributes["gbp_tag"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gbp_tag is missing from object`)

		return NewAclTagsValueUnknown(), diags
	}

	gbpTagVal, ok := gbpTagAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gbp_tag expected to be basetypes.Int64Value, was: %T`, gbpTagAttribute))
	}

	macsAttribute, ok := attributes["macs"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`macs is missing from object`)

		return NewAclTagsValueUnknown(), diags
	}

	macsVal, ok := macsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`macs expected to be basetypes.ListValue, was: %T`, macsAttribute))
	}

	networkAttribute, ok := attributes["network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`network is missing from object`)

		return NewAclTagsValueUnknown(), diags
	}

	networkVal, ok := networkAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`network expected to be basetypes.StringValue, was: %T`, networkAttribute))
	}

	portUsageAttribute, ok := attributes["port_usage"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_usage is missing from object`)

		return NewAclTagsValueUnknown(), diags
	}

	portUsageVal, ok := portUsageAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_usage expected to be basetypes.StringValue, was: %T`, portUsageAttribute))
	}

	radiusGroupAttribute, ok := attributes["radius_group"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`radius_group is missing from object`)

		return NewAclTagsValueUnknown(), diags
	}

	radiusGroupVal, ok := radiusGroupAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`radius_group expected to be basetypes.StringValue, was: %T`, radiusGroupAttribute))
	}

	specsAttribute, ok := attributes["specs"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`specs is missing from object`)

		return NewAclTagsValueUnknown(), diags
	}

	specsVal, ok := specsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`specs expected to be basetypes.ListValue, was: %T`, specsAttribute))
	}

	subnetsAttribute, ok := attributes["subnets"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnets is missing from object`)

		return NewAclTagsValueUnknown(), diags
	}

	subnetsVal, ok := subnetsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnets expected to be basetypes.ListValue, was: %T`, subnetsAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewAclTagsValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return NewAclTagsValueUnknown(), diags
	}

	return AclTagsValue{
		EtherTypes:  etherTypesVal,
		GbpTag:      gbpTagVal,
		Macs:        macsVal,
		Network:     networkVal,
		PortUsage:   portUsageVal,
		RadiusGroup: radiusGroupVal,
		Specs:       specsVal,
		Subnets:     subnetsVal,
		AclTagsType: typeVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewAclTagsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AclTagsValue {
	object, diags := NewAclTagsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAclTagsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AclTagsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAclTagsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAclTagsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAclTagsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAclTagsValueMust(AclTagsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t AclTagsType) ValueType(ctx context.Context) attr.Value {
	return AclTagsValue{}
}

var _ basetypes.ObjectValuable = AclTagsValue{}

type AclTagsValue struct {
	EtherTypes  basetypes.ListValue   `tfsdk:"ether_types"`
	GbpTag      basetypes.Int64Value  `tfsdk:"gbp_tag"`
	Macs        basetypes.ListValue   `tfsdk:"macs"`
	Network     basetypes.StringValue `tfsdk:"network"`
	PortUsage   basetypes.StringValue `tfsdk:"port_usage"`
	RadiusGroup basetypes.StringValue `tfsdk:"radius_group"`
	Specs       basetypes.ListValue   `tfsdk:"specs"`
	Subnets     basetypes.ListValue   `tfsdk:"subnets"`
	AclTagsType basetypes.StringValue `tfsdk:"type"`
	state       attr.ValueState
}

func (v AclTagsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 9)

	var val tftypes.Value
	var err error

	attrTypes["ether_types"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["gbp_tag"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["macs"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["network"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["port_usage"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["radius_group"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["specs"] = basetypes.ListType{
		ElemType: SpecsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["subnets"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 9)

		val, err = v.EtherTypes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ether_types"] = val

		val, err = v.GbpTag.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["gbp_tag"] = val

		val, err = v.Macs.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["macs"] = val

		val, err = v.Network.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["network"] = val

		val, err = v.PortUsage.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port_usage"] = val

		val, err = v.RadiusGroup.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["radius_group"] = val

		val, err = v.Specs.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["specs"] = val

		val, err = v.Subnets.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["subnets"] = val

		val, err = v.AclTagsType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AclTagsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AclTagsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AclTagsValue) String() string {
	return "AclTagsValue"
}

func (v AclTagsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	specs := types.ListValueMust(
		SpecsType{
			basetypes.ObjectType{
				AttrTypes: SpecsValue{}.AttributeTypes(ctx),
			},
		},
		v.Specs.Elements(),
	)

	if v.Specs.IsNull() {
		specs = types.ListNull(
			SpecsType{
				basetypes.ObjectType{
					AttrTypes: SpecsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Specs.IsUnknown() {
		specs = types.ListUnknown(
			SpecsType{
				basetypes.ObjectType{
					AttrTypes: SpecsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var etherTypesVal basetypes.ListValue
	switch {
	case v.EtherTypes.IsUnknown():
		etherTypesVal = types.ListUnknown(types.StringType)
	case v.EtherTypes.IsNull():
		etherTypesVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		etherTypesVal, d = types.ListValue(types.StringType, v.EtherTypes.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"ether_types": basetypes.ListType{
				ElemType: types.StringType,
			},
			"gbp_tag": basetypes.Int64Type{},
			"macs": basetypes.ListType{
				ElemType: types.StringType,
			},
			"network":      basetypes.StringType{},
			"port_usage":   basetypes.StringType{},
			"radius_group": basetypes.StringType{},
			"specs": basetypes.ListType{
				ElemType: SpecsValue{}.Type(ctx),
			},
			"subnets": basetypes.ListType{
				ElemType: types.StringType,
			},
			"type": basetypes.StringType{},
		}), diags
	}

	var macsVal basetypes.ListValue
	switch {
	case v.Macs.IsUnknown():
		macsVal = types.ListUnknown(types.StringType)
	case v.Macs.IsNull():
		macsVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		macsVal, d = types.ListValue(types.StringType, v.Macs.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"ether_types": basetypes.ListType{
				ElemType: types.StringType,
			},
			"gbp_tag": basetypes.Int64Type{},
			"macs": basetypes.ListType{
				ElemType: types.StringType,
			},
			"network":      basetypes.StringType{},
			"port_usage":   basetypes.StringType{},
			"radius_group": basetypes.StringType{},
			"specs": basetypes.ListType{
				ElemType: SpecsValue{}.Type(ctx),
			},
			"subnets": basetypes.ListType{
				ElemType: types.StringType,
			},
			"type": basetypes.StringType{},
		}), diags
	}

	var subnetsVal basetypes.ListValue
	switch {
	case v.Subnets.IsUnknown():
		subnetsVal = types.ListUnknown(types.StringType)
	case v.Subnets.IsNull():
		subnetsVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		subnetsVal, d = types.ListValue(types.StringType, v.Subnets.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"ether_types": basetypes.ListType{
				ElemType: types.StringType,
			},
			"gbp_tag": basetypes.Int64Type{},
			"macs": basetypes.ListType{
				ElemType: types.StringType,
			},
			"network":      basetypes.StringType{},
			"port_usage":   basetypes.StringType{},
			"radius_group": basetypes.StringType{},
			"specs": basetypes.ListType{
				ElemType: SpecsValue{}.Type(ctx),
			},
			"subnets": basetypes.ListType{
				ElemType: types.StringType,
			},
			"type": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"ether_types": basetypes.ListType{
			ElemType: types.StringType,
		},
		"gbp_tag": basetypes.Int64Type{},
		"macs": basetypes.ListType{
			ElemType: types.StringType,
		},
		"network":      basetypes.StringType{},
		"port_usage":   basetypes.StringType{},
		"radius_group": basetypes.StringType{},
		"specs": basetypes.ListType{
			ElemType: SpecsValue{}.Type(ctx),
		},
		"subnets": basetypes.ListType{
			ElemType: types.StringType,
		},
		"type": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"ether_types":  etherTypesVal,
			"gbp_tag":      v.GbpTag,
			"macs":         macsVal,
			"network":      v.Network,
			"port_usage":   v.PortUsage,
			"radius_group": v.RadiusGroup,
			"specs":        specs,
			"subnets":      subnetsVal,
			"type":         v.AclTagsType,
		})

	return objVal, diags
}

func (v AclTagsValue) Equal(o attr.Value) bool {
	other, ok := o.(AclTagsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.EtherTypes.Equal(other.EtherTypes) {
		return false
	}

	if !v.GbpTag.Equal(other.GbpTag) {
		return false
	}

	if !v.Macs.Equal(other.Macs) {
		return false
	}

	if !v.Network.Equal(other.Network) {
		return false
	}

	if !v.PortUsage.Equal(other.PortUsage) {
		return false
	}

	if !v.RadiusGroup.Equal(other.RadiusGroup) {
		return false
	}

	if !v.Specs.Equal(other.Specs) {
		return false
	}

	if !v.Subnets.Equal(other.Subnets) {
		return false
	}

	if !v.AclTagsType.Equal(other.AclTagsType) {
		return false
	}

	return true
}

func (v AclTagsValue) Type(ctx context.Context) attr.Type {
	return AclTagsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AclTagsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"ether_types": basetypes.ListType{
			ElemType: types.StringType,
		},
		"gbp_tag": basetypes.Int64Type{},
		"macs": basetypes.ListType{
			ElemType: types.StringType,
		},
		"network":      basetypes.StringType{},
		"port_usage":   basetypes.StringType{},
		"radius_group": basetypes.StringType{},
		"specs": basetypes.ListType{
			ElemType: SpecsValue{}.Type(ctx),
		},
		"subnets": basetypes.ListType{
			ElemType: types.StringType,
		},
		"type": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = SpecsType{}

type SpecsType struct {
	basetypes.ObjectType
}

func (t SpecsType) Equal(o attr.Type) bool {
	other, ok := o.(SpecsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SpecsType) String() string {
	return "SpecsType"
}

func (t SpecsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	portRangeAttribute, ok := attributes["port_range"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_range is missing from object`)

		return nil, diags
	}

	portRangeVal, ok := portRangeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_range expected to be basetypes.StringValue, was: %T`, portRangeAttribute))
	}

	protocolAttribute, ok := attributes["protocol"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`protocol is missing from object`)

		return nil, diags
	}

	protocolVal, ok := protocolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`protocol expected to be basetypes.StringValue, was: %T`, protocolAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SpecsValue{
		PortRange: portRangeVal,
		Protocol:  protocolVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewSpecsValueNull() SpecsValue {
	return SpecsValue{
		state: attr.ValueStateNull,
	}
}

func NewSpecsValueUnknown() SpecsValue {
	return SpecsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSpecsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SpecsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SpecsValue Attribute Value",
				"While creating a SpecsValue value, a missing attribute value was detected. "+
					"A SpecsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpecsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SpecsValue Attribute Type",
				"While creating a SpecsValue value, an invalid attribute value was detected. "+
					"A SpecsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpecsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SpecsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SpecsValue Attribute Value",
				"While creating a SpecsValue value, an extra attribute value was detected. "+
					"A SpecsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SpecsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSpecsValueUnknown(), diags
	}

	portRangeAttribute, ok := attributes["port_range"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_range is missing from object`)

		return NewSpecsValueUnknown(), diags
	}

	portRangeVal, ok := portRangeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_range expected to be basetypes.StringValue, was: %T`, portRangeAttribute))
	}

	protocolAttribute, ok := attributes["protocol"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`protocol is missing from object`)

		return NewSpecsValueUnknown(), diags
	}

	protocolVal, ok := protocolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`protocol expected to be basetypes.StringValue, was: %T`, protocolAttribute))
	}

	if diags.HasError() {
		return NewSpecsValueUnknown(), diags
	}

	return SpecsValue{
		PortRange: portRangeVal,
		Protocol:  protocolVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewSpecsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SpecsValue {
	object, diags := NewSpecsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSpecsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SpecsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSpecsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSpecsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSpecsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSpecsValueMust(SpecsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SpecsType) ValueType(ctx context.Context) attr.Value {
	return SpecsValue{}
}

var _ basetypes.ObjectValuable = SpecsValue{}

type SpecsValue struct {
	PortRange basetypes.StringValue `tfsdk:"port_range"`
	Protocol  basetypes.StringValue `tfsdk:"protocol"`
	state     attr.ValueState
}

func (v SpecsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["port_range"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["protocol"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.PortRange.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port_range"] = val

		val, err = v.Protocol.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["protocol"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SpecsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SpecsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SpecsValue) String() string {
	return "SpecsValue"
}

func (v SpecsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"port_range": basetypes.StringType{},
		"protocol":   basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"port_range": v.PortRange,
			"protocol":   v.Protocol,
		})

	return objVal, diags
}

func (v SpecsValue) Equal(o attr.Value) bool {
	other, ok := o.(SpecsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.PortRange.Equal(other.PortRange) {
		return false
	}

	if !v.Protocol.Equal(other.Protocol) {
		return false
	}

	return true
}

func (v SpecsValue) Type(ctx context.Context) attr.Type {
	return SpecsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SpecsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"port_range": basetypes.StringType{},
		"protocol":   basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = BgpConfigType{}

type BgpConfigType struct {
	basetypes.ObjectType
}

func (t BgpConfigType) Equal(o attr.Type) bool {
	other, ok := o.(BgpConfigType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t BgpConfigType) String() string {
	return "BgpConfigType"
}

func (t BgpConfigType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	authKeyAttribute, ok := attributes["auth_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auth_key is missing from object`)

		return nil, diags
	}

	authKeyVal, ok := authKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auth_key expected to be basetypes.StringValue, was: %T`, authKeyAttribute))
	}

	bfdMinimumIntervalAttribute, ok := attributes["bfd_minimum_interval"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bfd_minimum_interval is missing from object`)

		return nil, diags
	}

	bfdMinimumIntervalVal, ok := bfdMinimumIntervalAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bfd_minimum_interval expected to be basetypes.Int64Value, was: %T`, bfdMinimumIntervalAttribute))
	}

	exportPolicyAttribute, ok := attributes["export_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`export_policy is missing from object`)

		return nil, diags
	}

	exportPolicyVal, ok := exportPolicyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`export_policy expected to be basetypes.StringValue, was: %T`, exportPolicyAttribute))
	}

	holdTimeAttribute, ok := attributes["hold_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`hold_time is missing from object`)

		return nil, diags
	}

	holdTimeVal, ok := holdTimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`hold_time expected to be basetypes.Int64Value, was: %T`, holdTimeAttribute))
	}

	importPolicyAttribute, ok := attributes["import_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`import_policy is missing from object`)

		return nil, diags
	}

	importPolicyVal, ok := importPolicyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`import_policy expected to be basetypes.StringValue, was: %T`, importPolicyAttribute))
	}

	localAsAttribute, ok := attributes["local_as"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`local_as is missing from object`)

		return nil, diags
	}

	localAsVal, ok := localAsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`local_as expected to be basetypes.StringValue, was: %T`, localAsAttribute))
	}

	neighborsAttribute, ok := attributes["neighbors"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`neighbors is missing from object`)

		return nil, diags
	}

	neighborsVal, ok := neighborsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`neighbors expected to be basetypes.MapValue, was: %T`, neighborsAttribute))
	}

	networksAttribute, ok := attributes["networks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`networks is missing from object`)

		return nil, diags
	}

	networksVal, ok := networksAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`networks expected to be basetypes.ListValue, was: %T`, networksAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return BgpConfigValue{
		AuthKey:            authKeyVal,
		BfdMinimumInterval: bfdMinimumIntervalVal,
		ExportPolicy:       exportPolicyVal,
		HoldTime:           holdTimeVal,
		ImportPolicy:       importPolicyVal,
		LocalAs:            localAsVal,
		Neighbors:          neighborsVal,
		Networks:           networksVal,
		BgpConfigType:      typeVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewBgpConfigValueNull() BgpConfigValue {
	return BgpConfigValue{
		state: attr.ValueStateNull,
	}
}

func NewBgpConfigValueUnknown() BgpConfigValue {
	return BgpConfigValue{
		state: attr.ValueStateUnknown,
	}
}

func NewBgpConfigValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (BgpConfigValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing BgpConfigValue Attribute Value",
				"While creating a BgpConfigValue value, a missing attribute value was detected. "+
					"A BgpConfigValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("BgpConfigValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid BgpConfigValue Attribute Type",
				"While creating a BgpConfigValue value, an invalid attribute value was detected. "+
					"A BgpConfigValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("BgpConfigValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("BgpConfigValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra BgpConfigValue Attribute Value",
				"While creating a BgpConfigValue value, an extra attribute value was detected. "+
					"A BgpConfigValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra BgpConfigValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewBgpConfigValueUnknown(), diags
	}

	authKeyAttribute, ok := attributes["auth_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auth_key is missing from object`)

		return NewBgpConfigValueUnknown(), diags
	}

	authKeyVal, ok := authKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auth_key expected to be basetypes.StringValue, was: %T`, authKeyAttribute))
	}

	bfdMinimumIntervalAttribute, ok := attributes["bfd_minimum_interval"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bfd_minimum_interval is missing from object`)

		return NewBgpConfigValueUnknown(), diags
	}

	bfdMinimumIntervalVal, ok := bfdMinimumIntervalAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bfd_minimum_interval expected to be basetypes.Int64Value, was: %T`, bfdMinimumIntervalAttribute))
	}

	exportPolicyAttribute, ok := attributes["export_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`export_policy is missing from object`)

		return NewBgpConfigValueUnknown(), diags
	}

	exportPolicyVal, ok := exportPolicyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`export_policy expected to be basetypes.StringValue, was: %T`, exportPolicyAttribute))
	}

	holdTimeAttribute, ok := attributes["hold_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`hold_time is missing from object`)

		return NewBgpConfigValueUnknown(), diags
	}

	holdTimeVal, ok := holdTimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`hold_time expected to be basetypes.Int64Value, was: %T`, holdTimeAttribute))
	}

	importPolicyAttribute, ok := attributes["import_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`import_policy is missing from object`)

		return NewBgpConfigValueUnknown(), diags
	}

	importPolicyVal, ok := importPolicyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`import_policy expected to be basetypes.StringValue, was: %T`, importPolicyAttribute))
	}

	localAsAttribute, ok := attributes["local_as"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`local_as is missing from object`)

		return NewBgpConfigValueUnknown(), diags
	}

	localAsVal, ok := localAsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`local_as expected to be basetypes.StringValue, was: %T`, localAsAttribute))
	}

	neighborsAttribute, ok := attributes["neighbors"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`neighbors is missing from object`)

		return NewBgpConfigValueUnknown(), diags
	}

	neighborsVal, ok := neighborsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`neighbors expected to be basetypes.MapValue, was: %T`, neighborsAttribute))
	}

	networksAttribute, ok := attributes["networks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`networks is missing from object`)

		return NewBgpConfigValueUnknown(), diags
	}

	networksVal, ok := networksAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`networks expected to be basetypes.ListValue, was: %T`, networksAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewBgpConfigValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return NewBgpConfigValueUnknown(), diags
	}

	return BgpConfigValue{
		AuthKey:            authKeyVal,
		BfdMinimumInterval: bfdMinimumIntervalVal,
		ExportPolicy:       exportPolicyVal,
		HoldTime:           holdTimeVal,
		ImportPolicy:       importPolicyVal,
		LocalAs:            localAsVal,
		Neighbors:          neighborsVal,
		Networks:           networksVal,
		BgpConfigType:      typeVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewBgpConfigValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) BgpConfigValue {
	object, diags := NewBgpConfigValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewBgpConfigValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t BgpConfigType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewBgpConfigValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewBgpConfigValueUnknown(), nil
	}

	if in.IsNull() {
		return NewBgpConfigValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewBgpConfigValueMust(BgpConfigValue{}.AttributeTypes(ctx), attributes), nil
}

func (t BgpConfigType) ValueType(ctx context.Context) attr.Value {
	return BgpConfigValue{}
}

var _ basetypes.ObjectValuable = BgpConfigValue{}

type BgpConfigValue struct {
	AuthKey            basetypes.StringValue `tfsdk:"auth_key"`
	BfdMinimumInterval basetypes.Int64Value  `tfsdk:"bfd_minimum_interval"`
	ExportPolicy       basetypes.StringValue `tfsdk:"export_policy"`
	HoldTime           basetypes.Int64Value  `tfsdk:"hold_time"`
	ImportPolicy       basetypes.StringValue `tfsdk:"import_policy"`
	LocalAs            basetypes.StringValue `tfsdk:"local_as"`
	Neighbors          basetypes.MapValue    `tfsdk:"neighbors"`
	Networks           basetypes.ListValue   `tfsdk:"networks"`
	BgpConfigType      basetypes.StringValue `tfsdk:"type"`
	state              attr.ValueState
}

func (v BgpConfigValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 9)

	var val tftypes.Value
	var err error

	attrTypes["auth_key"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["bfd_minimum_interval"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["export_policy"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["hold_time"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["import_policy"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["local_as"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["neighbors"] = basetypes.MapType{
		ElemType: NeighborsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["networks"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 9)

		val, err = v.AuthKey.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["auth_key"] = val

		val, err = v.BfdMinimumInterval.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bfd_minimum_interval"] = val

		val, err = v.ExportPolicy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["export_policy"] = val

		val, err = v.HoldTime.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["hold_time"] = val

		val, err = v.ImportPolicy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["import_policy"] = val

		val, err = v.LocalAs.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["local_as"] = val

		val, err = v.Neighbors.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["neighbors"] = val

		val, err = v.Networks.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["networks"] = val

		val, err = v.BgpConfigType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v BgpConfigValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v BgpConfigValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v BgpConfigValue) String() string {
	return "BgpConfigValue"
}

func (v BgpConfigValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	neighbors := types.MapValueMust(
		NeighborsType{
			basetypes.ObjectType{
				AttrTypes: NeighborsValue{}.AttributeTypes(ctx),
			},
		},
		v.Neighbors.Elements(),
	)

	if v.Neighbors.IsNull() {
		neighbors = types.MapNull(
			NeighborsType{
				basetypes.ObjectType{
					AttrTypes: NeighborsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Neighbors.IsUnknown() {
		neighbors = types.MapUnknown(
			NeighborsType{
				basetypes.ObjectType{
					AttrTypes: NeighborsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var networksVal basetypes.ListValue
	switch {
	case v.Networks.IsUnknown():
		networksVal = types.ListUnknown(types.StringType)
	case v.Networks.IsNull():
		networksVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		networksVal, d = types.ListValue(types.StringType, v.Networks.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"auth_key":             basetypes.StringType{},
			"bfd_minimum_interval": basetypes.Int64Type{},
			"export_policy":        basetypes.StringType{},
			"hold_time":            basetypes.Int64Type{},
			"import_policy":        basetypes.StringType{},
			"local_as":             basetypes.StringType{},
			"neighbors": basetypes.MapType{
				ElemType: NeighborsValue{}.Type(ctx),
			},
			"networks": basetypes.ListType{
				ElemType: types.StringType,
			},
			"type": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"auth_key":             basetypes.StringType{},
		"bfd_minimum_interval": basetypes.Int64Type{},
		"export_policy":        basetypes.StringType{},
		"hold_time":            basetypes.Int64Type{},
		"import_policy":        basetypes.StringType{},
		"local_as":             basetypes.StringType{},
		"neighbors": basetypes.MapType{
			ElemType: NeighborsValue{}.Type(ctx),
		},
		"networks": basetypes.ListType{
			ElemType: types.StringType,
		},
		"type": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"auth_key":             v.AuthKey,
			"bfd_minimum_interval": v.BfdMinimumInterval,
			"export_policy":        v.ExportPolicy,
			"hold_time":            v.HoldTime,
			"import_policy":        v.ImportPolicy,
			"local_as":             v.LocalAs,
			"neighbors":            neighbors,
			"networks":             networksVal,
			"type":                 v.BgpConfigType,
		})

	return objVal, diags
}

func (v BgpConfigValue) Equal(o attr.Value) bool {
	other, ok := o.(BgpConfigValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AuthKey.Equal(other.AuthKey) {
		return false
	}

	if !v.BfdMinimumInterval.Equal(other.BfdMinimumInterval) {
		return false
	}

	if !v.ExportPolicy.Equal(other.ExportPolicy) {
		return false
	}

	if !v.HoldTime.Equal(other.HoldTime) {
		return false
	}

	if !v.ImportPolicy.Equal(other.ImportPolicy) {
		return false
	}

	if !v.LocalAs.Equal(other.LocalAs) {
		return false
	}

	if !v.Neighbors.Equal(other.Neighbors) {
		return false
	}

	if !v.Networks.Equal(other.Networks) {
		return false
	}

	if !v.BgpConfigType.Equal(other.BgpConfigType) {
		return false
	}

	return true
}

func (v BgpConfigValue) Type(ctx context.Context) attr.Type {
	return BgpConfigType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v BgpConfigValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"auth_key":             basetypes.StringType{},
		"bfd_minimum_interval": basetypes.Int64Type{},
		"export_policy":        basetypes.StringType{},
		"hold_time":            basetypes.Int64Type{},
		"import_policy":        basetypes.StringType{},
		"local_as":             basetypes.StringType{},
		"neighbors": basetypes.MapType{
			ElemType: NeighborsValue{}.Type(ctx),
		},
		"networks": basetypes.ListType{
			ElemType: types.StringType,
		},
		"type": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = NeighborsType{}

type NeighborsType struct {
	basetypes.ObjectType
}

func (t NeighborsType) Equal(o attr.Type) bool {
	other, ok := o.(NeighborsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t NeighborsType) String() string {
	return "NeighborsType"
}

func (t NeighborsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	exportPolicyAttribute, ok := attributes["export_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`export_policy is missing from object`)

		return nil, diags
	}

	exportPolicyVal, ok := exportPolicyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`export_policy expected to be basetypes.StringValue, was: %T`, exportPolicyAttribute))
	}

	holdTimeAttribute, ok := attributes["hold_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`hold_time is missing from object`)

		return nil, diags
	}

	holdTimeVal, ok := holdTimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`hold_time expected to be basetypes.Int64Value, was: %T`, holdTimeAttribute))
	}

	importPolicyAttribute, ok := attributes["import_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`import_policy is missing from object`)

		return nil, diags
	}

	importPolicyVal, ok := importPolicyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`import_policy expected to be basetypes.StringValue, was: %T`, importPolicyAttribute))
	}

	multihopTtlAttribute, ok := attributes["multihop_ttl"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`multihop_ttl is missing from object`)

		return nil, diags
	}

	multihopTtlVal, ok := multihopTtlAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`multihop_ttl expected to be basetypes.Int64Value, was: %T`, multihopTtlAttribute))
	}

	neighborAsAttribute, ok := attributes["neighbor_as"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`neighbor_as is missing from object`)

		return nil, diags
	}

	neighborAsVal, ok := neighborAsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`neighbor_as expected to be basetypes.StringValue, was: %T`, neighborAsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return NeighborsValue{
		ExportPolicy: exportPolicyVal,
		HoldTime:     holdTimeVal,
		ImportPolicy: importPolicyVal,
		MultihopTtl:  multihopTtlVal,
		NeighborAs:   neighborAsVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewNeighborsValueNull() NeighborsValue {
	return NeighborsValue{
		state: attr.ValueStateNull,
	}
}

func NewNeighborsValueUnknown() NeighborsValue {
	return NeighborsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewNeighborsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (NeighborsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing NeighborsValue Attribute Value",
				"While creating a NeighborsValue value, a missing attribute value was detected. "+
					"A NeighborsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NeighborsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid NeighborsValue Attribute Type",
				"While creating a NeighborsValue value, an invalid attribute value was detected. "+
					"A NeighborsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NeighborsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("NeighborsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra NeighborsValue Attribute Value",
				"While creating a NeighborsValue value, an extra attribute value was detected. "+
					"A NeighborsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra NeighborsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewNeighborsValueUnknown(), diags
	}

	exportPolicyAttribute, ok := attributes["export_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`export_policy is missing from object`)

		return NewNeighborsValueUnknown(), diags
	}

	exportPolicyVal, ok := exportPolicyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`export_policy expected to be basetypes.StringValue, was: %T`, exportPolicyAttribute))
	}

	holdTimeAttribute, ok := attributes["hold_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`hold_time is missing from object`)

		return NewNeighborsValueUnknown(), diags
	}

	holdTimeVal, ok := holdTimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`hold_time expected to be basetypes.Int64Value, was: %T`, holdTimeAttribute))
	}

	importPolicyAttribute, ok := attributes["import_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`import_policy is missing from object`)

		return NewNeighborsValueUnknown(), diags
	}

	importPolicyVal, ok := importPolicyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`import_policy expected to be basetypes.StringValue, was: %T`, importPolicyAttribute))
	}

	multihopTtlAttribute, ok := attributes["multihop_ttl"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`multihop_ttl is missing from object`)

		return NewNeighborsValueUnknown(), diags
	}

	multihopTtlVal, ok := multihopTtlAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`multihop_ttl expected to be basetypes.Int64Value, was: %T`, multihopTtlAttribute))
	}

	neighborAsAttribute, ok := attributes["neighbor_as"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`neighbor_as is missing from object`)

		return NewNeighborsValueUnknown(), diags
	}

	neighborAsVal, ok := neighborAsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`neighbor_as expected to be basetypes.StringValue, was: %T`, neighborAsAttribute))
	}

	if diags.HasError() {
		return NewNeighborsValueUnknown(), diags
	}

	return NeighborsValue{
		ExportPolicy: exportPolicyVal,
		HoldTime:     holdTimeVal,
		ImportPolicy: importPolicyVal,
		MultihopTtl:  multihopTtlVal,
		NeighborAs:   neighborAsVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewNeighborsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) NeighborsValue {
	object, diags := NewNeighborsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewNeighborsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t NeighborsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewNeighborsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewNeighborsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewNeighborsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewNeighborsValueMust(NeighborsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t NeighborsType) ValueType(ctx context.Context) attr.Value {
	return NeighborsValue{}
}

var _ basetypes.ObjectValuable = NeighborsValue{}

type NeighborsValue struct {
	ExportPolicy basetypes.StringValue `tfsdk:"export_policy"`
	HoldTime     basetypes.Int64Value  `tfsdk:"hold_time"`
	ImportPolicy basetypes.StringValue `tfsdk:"import_policy"`
	MultihopTtl  basetypes.Int64Value  `tfsdk:"multihop_ttl"`
	NeighborAs   basetypes.StringValue `tfsdk:"neighbor_as"`
	state        attr.ValueState
}

func (v NeighborsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["export_policy"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["hold_time"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["import_policy"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["multihop_ttl"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["neighbor_as"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.ExportPolicy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["export_policy"] = val

		val, err = v.HoldTime.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["hold_time"] = val

		val, err = v.ImportPolicy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["import_policy"] = val

		val, err = v.MultihopTtl.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["multihop_ttl"] = val

		val, err = v.NeighborAs.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["neighbor_as"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v NeighborsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v NeighborsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v NeighborsValue) String() string {
	return "NeighborsValue"
}

func (v NeighborsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"export_policy": basetypes.StringType{},
		"hold_time":     basetypes.Int64Type{},
		"import_policy": basetypes.StringType{},
		"multihop_ttl":  basetypes.Int64Type{},
		"neighbor_as":   basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"export_policy": v.ExportPolicy,
			"hold_time":     v.HoldTime,
			"import_policy": v.ImportPolicy,
			"multihop_ttl":  v.MultihopTtl,
			"neighbor_as":   v.NeighborAs,
		})

	return objVal, diags
}

func (v NeighborsValue) Equal(o attr.Value) bool {
	other, ok := o.(NeighborsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.ExportPolicy.Equal(other.ExportPolicy) {
		return false
	}

	if !v.HoldTime.Equal(other.HoldTime) {
		return false
	}

	if !v.ImportPolicy.Equal(other.ImportPolicy) {
		return false
	}

	if !v.MultihopTtl.Equal(other.MultihopTtl) {
		return false
	}

	if !v.NeighborAs.Equal(other.NeighborAs) {
		return false
	}

	return true
}

func (v NeighborsValue) Type(ctx context.Context) attr.Type {
	return NeighborsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v NeighborsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"export_policy": basetypes.StringType{},
		"hold_time":     basetypes.Int64Type{},
		"import_policy": basetypes.StringType{},
		"multihop_ttl":  basetypes.Int64Type{},
		"neighbor_as":   basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = DhcpSnoopingType{}

type DhcpSnoopingType struct {
	basetypes.ObjectType
}

func (t DhcpSnoopingType) Equal(o attr.Type) bool {
	other, ok := o.(DhcpSnoopingType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t DhcpSnoopingType) String() string {
	return "DhcpSnoopingType"
}

func (t DhcpSnoopingType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	allNetworksAttribute, ok := attributes["all_networks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`all_networks is missing from object`)

		return nil, diags
	}

	allNetworksVal, ok := allNetworksAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`all_networks expected to be basetypes.BoolValue, was: %T`, allNetworksAttribute))
	}

	enableArpSpoofCheckAttribute, ok := attributes["enable_arp_spoof_check"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable_arp_spoof_check is missing from object`)

		return nil, diags
	}

	enableArpSpoofCheckVal, ok := enableArpSpoofCheckAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable_arp_spoof_check expected to be basetypes.BoolValue, was: %T`, enableArpSpoofCheckAttribute))
	}

	enableIpSourceGuardAttribute, ok := attributes["enable_ip_source_guard"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable_ip_source_guard is missing from object`)

		return nil, diags
	}

	enableIpSourceGuardVal, ok := enableIpSourceGuardAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable_ip_source_guard expected to be basetypes.BoolValue, was: %T`, enableIpSourceGuardAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	networksAttribute, ok := attributes["networks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`networks is missing from object`)

		return nil, diags
	}

	networksVal, ok := networksAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`networks expected to be basetypes.ListValue, was: %T`, networksAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return DhcpSnoopingValue{
		AllNetworks:         allNetworksVal,
		EnableArpSpoofCheck: enableArpSpoofCheckVal,
		EnableIpSourceGuard: enableIpSourceGuardVal,
		Enabled:             enabledVal,
		Networks:            networksVal,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewDhcpSnoopingValueNull() DhcpSnoopingValue {
	return DhcpSnoopingValue{
		state: attr.ValueStateNull,
	}
}

func NewDhcpSnoopingValueUnknown() DhcpSnoopingValue {
	return DhcpSnoopingValue{
		state: attr.ValueStateUnknown,
	}
}

func NewDhcpSnoopingValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (DhcpSnoopingValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing DhcpSnoopingValue Attribute Value",
				"While creating a DhcpSnoopingValue value, a missing attribute value was detected. "+
					"A DhcpSnoopingValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DhcpSnoopingValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid DhcpSnoopingValue Attribute Type",
				"While creating a DhcpSnoopingValue value, an invalid attribute value was detected. "+
					"A DhcpSnoopingValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DhcpSnoopingValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("DhcpSnoopingValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra DhcpSnoopingValue Attribute Value",
				"While creating a DhcpSnoopingValue value, an extra attribute value was detected. "+
					"A DhcpSnoopingValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra DhcpSnoopingValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewDhcpSnoopingValueUnknown(), diags
	}

	allNetworksAttribute, ok := attributes["all_networks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`all_networks is missing from object`)

		return NewDhcpSnoopingValueUnknown(), diags
	}

	allNetworksVal, ok := allNetworksAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`all_networks expected to be basetypes.BoolValue, was: %T`, allNetworksAttribute))
	}

	enableArpSpoofCheckAttribute, ok := attributes["enable_arp_spoof_check"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable_arp_spoof_check is missing from object`)

		return NewDhcpSnoopingValueUnknown(), diags
	}

	enableArpSpoofCheckVal, ok := enableArpSpoofCheckAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable_arp_spoof_check expected to be basetypes.BoolValue, was: %T`, enableArpSpoofCheckAttribute))
	}

	enableIpSourceGuardAttribute, ok := attributes["enable_ip_source_guard"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable_ip_source_guard is missing from object`)

		return NewDhcpSnoopingValueUnknown(), diags
	}

	enableIpSourceGuardVal, ok := enableIpSourceGuardAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable_ip_source_guard expected to be basetypes.BoolValue, was: %T`, enableIpSourceGuardAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewDhcpSnoopingValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	networksAttribute, ok := attributes["networks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`networks is missing from object`)

		return NewDhcpSnoopingValueUnknown(), diags
	}

	networksVal, ok := networksAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`networks expected to be basetypes.ListValue, was: %T`, networksAttribute))
	}

	if diags.HasError() {
		return NewDhcpSnoopingValueUnknown(), diags
	}

	return DhcpSnoopingValue{
		AllNetworks:         allNetworksVal,
		EnableArpSpoofCheck: enableArpSpoofCheckVal,
		EnableIpSourceGuard: enableIpSourceGuardVal,
		Enabled:             enabledVal,
		Networks:            networksVal,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewDhcpSnoopingValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) DhcpSnoopingValue {
	object, diags := NewDhcpSnoopingValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewDhcpSnoopingValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t DhcpSnoopingType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewDhcpSnoopingValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewDhcpSnoopingValueUnknown(), nil
	}

	if in.IsNull() {
		return NewDhcpSnoopingValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewDhcpSnoopingValueMust(DhcpSnoopingValue{}.AttributeTypes(ctx), attributes), nil
}

func (t DhcpSnoopingType) ValueType(ctx context.Context) attr.Value {
	return DhcpSnoopingValue{}
}

var _ basetypes.ObjectValuable = DhcpSnoopingValue{}

type DhcpSnoopingValue struct {
	AllNetworks         basetypes.BoolValue `tfsdk:"all_networks"`
	EnableArpSpoofCheck basetypes.BoolValue `tfsdk:"enable_arp_spoof_check"`
	EnableIpSourceGuard basetypes.BoolValue `tfsdk:"enable_ip_source_guard"`
	Enabled             basetypes.BoolValue `tfsdk:"enabled"`
	Networks            basetypes.ListValue `tfsdk:"networks"`
	state               attr.ValueState
}

func (v DhcpSnoopingValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["all_networks"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["enable_arp_spoof_check"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["enable_ip_source_guard"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["networks"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.AllNetworks.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["all_networks"] = val

		val, err = v.EnableArpSpoofCheck.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enable_arp_spoof_check"] = val

		val, err = v.EnableIpSourceGuard.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enable_ip_source_guard"] = val

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.Networks.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["networks"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v DhcpSnoopingValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v DhcpSnoopingValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v DhcpSnoopingValue) String() string {
	return "DhcpSnoopingValue"
}

func (v DhcpSnoopingValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var networksVal basetypes.ListValue
	switch {
	case v.Networks.IsUnknown():
		networksVal = types.ListUnknown(types.StringType)
	case v.Networks.IsNull():
		networksVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		networksVal, d = types.ListValue(types.StringType, v.Networks.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"all_networks":           basetypes.BoolType{},
			"enable_arp_spoof_check": basetypes.BoolType{},
			"enable_ip_source_guard": basetypes.BoolType{},
			"enabled":                basetypes.BoolType{},
			"networks": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"all_networks":           basetypes.BoolType{},
		"enable_arp_spoof_check": basetypes.BoolType{},
		"enable_ip_source_guard": basetypes.BoolType{},
		"enabled":                basetypes.BoolType{},
		"networks": basetypes.ListType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"all_networks":           v.AllNetworks,
			"enable_arp_spoof_check": v.EnableArpSpoofCheck,
			"enable_ip_source_guard": v.EnableIpSourceGuard,
			"enabled":                v.Enabled,
			"networks":               networksVal,
		})

	return objVal, diags
}

func (v DhcpSnoopingValue) Equal(o attr.Value) bool {
	other, ok := o.(DhcpSnoopingValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AllNetworks.Equal(other.AllNetworks) {
		return false
	}

	if !v.EnableArpSpoofCheck.Equal(other.EnableArpSpoofCheck) {
		return false
	}

	if !v.EnableIpSourceGuard.Equal(other.EnableIpSourceGuard) {
		return false
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.Networks.Equal(other.Networks) {
		return false
	}

	return true
}

func (v DhcpSnoopingValue) Type(ctx context.Context) attr.Type {
	return DhcpSnoopingType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v DhcpSnoopingValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"all_networks":           basetypes.BoolType{},
		"enable_arp_spoof_check": basetypes.BoolType{},
		"enable_ip_source_guard": basetypes.BoolType{},
		"enabled":                basetypes.BoolType{},
		"networks": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = ExtraRoutesType{}

type ExtraRoutesType struct {
	basetypes.ObjectType
}

func (t ExtraRoutesType) Equal(o attr.Type) bool {
	other, ok := o.(ExtraRoutesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ExtraRoutesType) String() string {
	return "ExtraRoutesType"
}

func (t ExtraRoutesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	discardAttribute, ok := attributes["discard"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`discard is missing from object`)

		return nil, diags
	}

	discardVal, ok := discardAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`discard expected to be basetypes.BoolValue, was: %T`, discardAttribute))
	}

	metricAttribute, ok := attributes["metric"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`metric is missing from object`)

		return nil, diags
	}

	metricVal, ok := metricAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`metric expected to be basetypes.Int64Value, was: %T`, metricAttribute))
	}

	nextQualifiedAttribute, ok := attributes["next_qualified"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`next_qualified is missing from object`)

		return nil, diags
	}

	nextQualifiedVal, ok := nextQualifiedAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`next_qualified expected to be basetypes.MapValue, was: %T`, nextQualifiedAttribute))
	}

	noResolveAttribute, ok := attributes["no_resolve"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`no_resolve is missing from object`)

		return nil, diags
	}

	noResolveVal, ok := noResolveAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`no_resolve expected to be basetypes.BoolValue, was: %T`, noResolveAttribute))
	}

	preferenceAttribute, ok := attributes["preference"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`preference is missing from object`)

		return nil, diags
	}

	preferenceVal, ok := preferenceAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`preference expected to be basetypes.Int64Value, was: %T`, preferenceAttribute))
	}

	viaAttribute, ok := attributes["via"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`via is missing from object`)

		return nil, diags
	}

	viaVal, ok := viaAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`via expected to be basetypes.StringValue, was: %T`, viaAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ExtraRoutesValue{
		Discard:       discardVal,
		Metric:        metricVal,
		NextQualified: nextQualifiedVal,
		NoResolve:     noResolveVal,
		Preference:    preferenceVal,
		Via:           viaVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewExtraRoutesValueNull() ExtraRoutesValue {
	return ExtraRoutesValue{
		state: attr.ValueStateNull,
	}
}

func NewExtraRoutesValueUnknown() ExtraRoutesValue {
	return ExtraRoutesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewExtraRoutesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ExtraRoutesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ExtraRoutesValue Attribute Value",
				"While creating a ExtraRoutesValue value, a missing attribute value was detected. "+
					"A ExtraRoutesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ExtraRoutesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ExtraRoutesValue Attribute Type",
				"While creating a ExtraRoutesValue value, an invalid attribute value was detected. "+
					"A ExtraRoutesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ExtraRoutesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ExtraRoutesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ExtraRoutesValue Attribute Value",
				"While creating a ExtraRoutesValue value, an extra attribute value was detected. "+
					"A ExtraRoutesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ExtraRoutesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewExtraRoutesValueUnknown(), diags
	}

	discardAttribute, ok := attributes["discard"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`discard is missing from object`)

		return NewExtraRoutesValueUnknown(), diags
	}

	discardVal, ok := discardAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`discard expected to be basetypes.BoolValue, was: %T`, discardAttribute))
	}

	metricAttribute, ok := attributes["metric"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`metric is missing from object`)

		return NewExtraRoutesValueUnknown(), diags
	}

	metricVal, ok := metricAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`metric expected to be basetypes.Int64Value, was: %T`, metricAttribute))
	}

	nextQualifiedAttribute, ok := attributes["next_qualified"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`next_qualified is missing from object`)

		return NewExtraRoutesValueUnknown(), diags
	}

	nextQualifiedVal, ok := nextQualifiedAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`next_qualified expected to be basetypes.MapValue, was: %T`, nextQualifiedAttribute))
	}

	noResolveAttribute, ok := attributes["no_resolve"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`no_resolve is missing from object`)

		return NewExtraRoutesValueUnknown(), diags
	}

	noResolveVal, ok := noResolveAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`no_resolve expected to be basetypes.BoolValue, was: %T`, noResolveAttribute))
	}

	preferenceAttribute, ok := attributes["preference"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`preference is missing from object`)

		return NewExtraRoutesValueUnknown(), diags
	}

	preferenceVal, ok := preferenceAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`preference expected to be basetypes.Int64Value, was: %T`, preferenceAttribute))
	}

	viaAttribute, ok := attributes["via"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`via is missing from object`)

		return NewExtraRoutesValueUnknown(), diags
	}

	viaVal, ok := viaAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`via expected to be basetypes.StringValue, was: %T`, viaAttribute))
	}

	if diags.HasError() {
		return NewExtraRoutesValueUnknown(), diags
	}

	return ExtraRoutesValue{
		Discard:       discardVal,
		Metric:        metricVal,
		NextQualified: nextQualifiedVal,
		NoResolve:     noResolveVal,
		Preference:    preferenceVal,
		Via:           viaVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewExtraRoutesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ExtraRoutesValue {
	object, diags := NewExtraRoutesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewExtraRoutesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ExtraRoutesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewExtraRoutesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewExtraRoutesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewExtraRoutesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewExtraRoutesValueMust(ExtraRoutesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ExtraRoutesType) ValueType(ctx context.Context) attr.Value {
	return ExtraRoutesValue{}
}

var _ basetypes.ObjectValuable = ExtraRoutesValue{}

type ExtraRoutesValue struct {
	Discard       basetypes.BoolValue   `tfsdk:"discard"`
	Metric        basetypes.Int64Value  `tfsdk:"metric"`
	NextQualified basetypes.MapValue    `tfsdk:"next_qualified"`
	NoResolve     basetypes.BoolValue   `tfsdk:"no_resolve"`
	Preference    basetypes.Int64Value  `tfsdk:"preference"`
	Via           basetypes.StringValue `tfsdk:"via"`
	state         attr.ValueState
}

func (v ExtraRoutesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 6)

	var val tftypes.Value
	var err error

	attrTypes["discard"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["metric"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["next_qualified"] = basetypes.MapType{
		ElemType: NextQualifiedValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["no_resolve"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["preference"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["via"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 6)

		val, err = v.Discard.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["discard"] = val

		val, err = v.Metric.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["metric"] = val

		val, err = v.NextQualified.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["next_qualified"] = val

		val, err = v.NoResolve.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["no_resolve"] = val

		val, err = v.Preference.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["preference"] = val

		val, err = v.Via.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["via"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ExtraRoutesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ExtraRoutesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ExtraRoutesValue) String() string {
	return "ExtraRoutesValue"
}

func (v ExtraRoutesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	nextQualified := types.MapValueMust(
		NextQualifiedType{
			basetypes.ObjectType{
				AttrTypes: NextQualifiedValue{}.AttributeTypes(ctx),
			},
		},
		v.NextQualified.Elements(),
	)

	if v.NextQualified.IsNull() {
		nextQualified = types.MapNull(
			NextQualifiedType{
				basetypes.ObjectType{
					AttrTypes: NextQualifiedValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.NextQualified.IsUnknown() {
		nextQualified = types.MapUnknown(
			NextQualifiedType{
				basetypes.ObjectType{
					AttrTypes: NextQualifiedValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"discard": basetypes.BoolType{},
		"metric":  basetypes.Int64Type{},
		"next_qualified": basetypes.MapType{
			ElemType: NextQualifiedValue{}.Type(ctx),
		},
		"no_resolve": basetypes.BoolType{},
		"preference": basetypes.Int64Type{},
		"via":        basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"discard":        v.Discard,
			"metric":         v.Metric,
			"next_qualified": nextQualified,
			"no_resolve":     v.NoResolve,
			"preference":     v.Preference,
			"via":            v.Via,
		})

	return objVal, diags
}

func (v ExtraRoutesValue) Equal(o attr.Value) bool {
	other, ok := o.(ExtraRoutesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Discard.Equal(other.Discard) {
		return false
	}

	if !v.Metric.Equal(other.Metric) {
		return false
	}

	if !v.NextQualified.Equal(other.NextQualified) {
		return false
	}

	if !v.NoResolve.Equal(other.NoResolve) {
		return false
	}

	if !v.Preference.Equal(other.Preference) {
		return false
	}

	if !v.Via.Equal(other.Via) {
		return false
	}

	return true
}

func (v ExtraRoutesValue) Type(ctx context.Context) attr.Type {
	return ExtraRoutesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ExtraRoutesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"discard": basetypes.BoolType{},
		"metric":  basetypes.Int64Type{},
		"next_qualified": basetypes.MapType{
			ElemType: NextQualifiedValue{}.Type(ctx),
		},
		"no_resolve": basetypes.BoolType{},
		"preference": basetypes.Int64Type{},
		"via":        basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = NextQualifiedType{}

type NextQualifiedType struct {
	basetypes.ObjectType
}

func (t NextQualifiedType) Equal(o attr.Type) bool {
	other, ok := o.(NextQualifiedType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t NextQualifiedType) String() string {
	return "NextQualifiedType"
}

func (t NextQualifiedType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	metricAttribute, ok := attributes["metric"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`metric is missing from object`)

		return nil, diags
	}

	metricVal, ok := metricAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`metric expected to be basetypes.Int64Value, was: %T`, metricAttribute))
	}

	preferenceAttribute, ok := attributes["preference"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`preference is missing from object`)

		return nil, diags
	}

	preferenceVal, ok := preferenceAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`preference expected to be basetypes.Int64Value, was: %T`, preferenceAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return NextQualifiedValue{
		Metric:     metricVal,
		Preference: preferenceVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewNextQualifiedValueNull() NextQualifiedValue {
	return NextQualifiedValue{
		state: attr.ValueStateNull,
	}
}

func NewNextQualifiedValueUnknown() NextQualifiedValue {
	return NextQualifiedValue{
		state: attr.ValueStateUnknown,
	}
}

func NewNextQualifiedValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (NextQualifiedValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing NextQualifiedValue Attribute Value",
				"While creating a NextQualifiedValue value, a missing attribute value was detected. "+
					"A NextQualifiedValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NextQualifiedValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid NextQualifiedValue Attribute Type",
				"While creating a NextQualifiedValue value, an invalid attribute value was detected. "+
					"A NextQualifiedValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NextQualifiedValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("NextQualifiedValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra NextQualifiedValue Attribute Value",
				"While creating a NextQualifiedValue value, an extra attribute value was detected. "+
					"A NextQualifiedValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra NextQualifiedValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewNextQualifiedValueUnknown(), diags
	}

	metricAttribute, ok := attributes["metric"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`metric is missing from object`)

		return NewNextQualifiedValueUnknown(), diags
	}

	metricVal, ok := metricAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`metric expected to be basetypes.Int64Value, was: %T`, metricAttribute))
	}

	preferenceAttribute, ok := attributes["preference"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`preference is missing from object`)

		return NewNextQualifiedValueUnknown(), diags
	}

	preferenceVal, ok := preferenceAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`preference expected to be basetypes.Int64Value, was: %T`, preferenceAttribute))
	}

	if diags.HasError() {
		return NewNextQualifiedValueUnknown(), diags
	}

	return NextQualifiedValue{
		Metric:     metricVal,
		Preference: preferenceVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewNextQualifiedValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) NextQualifiedValue {
	object, diags := NewNextQualifiedValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewNextQualifiedValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t NextQualifiedType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewNextQualifiedValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewNextQualifiedValueUnknown(), nil
	}

	if in.IsNull() {
		return NewNextQualifiedValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewNextQualifiedValueMust(NextQualifiedValue{}.AttributeTypes(ctx), attributes), nil
}

func (t NextQualifiedType) ValueType(ctx context.Context) attr.Value {
	return NextQualifiedValue{}
}

var _ basetypes.ObjectValuable = NextQualifiedValue{}

type NextQualifiedValue struct {
	Metric     basetypes.Int64Value `tfsdk:"metric"`
	Preference basetypes.Int64Value `tfsdk:"preference"`
	state      attr.ValueState
}

func (v NextQualifiedValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["metric"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["preference"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Metric.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["metric"] = val

		val, err = v.Preference.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["preference"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v NextQualifiedValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v NextQualifiedValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v NextQualifiedValue) String() string {
	return "NextQualifiedValue"
}

func (v NextQualifiedValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"metric":     basetypes.Int64Type{},
		"preference": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"metric":     v.Metric,
			"preference": v.Preference,
		})

	return objVal, diags
}

func (v NextQualifiedValue) Equal(o attr.Value) bool {
	other, ok := o.(NextQualifiedValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Metric.Equal(other.Metric) {
		return false
	}

	if !v.Preference.Equal(other.Preference) {
		return false
	}

	return true
}

func (v NextQualifiedValue) Type(ctx context.Context) attr.Type {
	return NextQualifiedType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v NextQualifiedValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"metric":     basetypes.Int64Type{},
		"preference": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = ExtraRoutes6Type{}

type ExtraRoutes6Type struct {
	basetypes.ObjectType
}

func (t ExtraRoutes6Type) Equal(o attr.Type) bool {
	other, ok := o.(ExtraRoutes6Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ExtraRoutes6Type) String() string {
	return "ExtraRoutes6Type"
}

func (t ExtraRoutes6Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	discardAttribute, ok := attributes["discard"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`discard is missing from object`)

		return nil, diags
	}

	discardVal, ok := discardAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`discard expected to be basetypes.BoolValue, was: %T`, discardAttribute))
	}

	metricAttribute, ok := attributes["metric"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`metric is missing from object`)

		return nil, diags
	}

	metricVal, ok := metricAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`metric expected to be basetypes.Int64Value, was: %T`, metricAttribute))
	}

	nextQualifiedAttribute, ok := attributes["next_qualified"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`next_qualified is missing from object`)

		return nil, diags
	}

	nextQualifiedVal, ok := nextQualifiedAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`next_qualified expected to be basetypes.MapValue, was: %T`, nextQualifiedAttribute))
	}

	noResolveAttribute, ok := attributes["no_resolve"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`no_resolve is missing from object`)

		return nil, diags
	}

	noResolveVal, ok := noResolveAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`no_resolve expected to be basetypes.BoolValue, was: %T`, noResolveAttribute))
	}

	preferenceAttribute, ok := attributes["preference"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`preference is missing from object`)

		return nil, diags
	}

	preferenceVal, ok := preferenceAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`preference expected to be basetypes.Int64Value, was: %T`, preferenceAttribute))
	}

	viaAttribute, ok := attributes["via"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`via is missing from object`)

		return nil, diags
	}

	viaVal, ok := viaAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`via expected to be basetypes.StringValue, was: %T`, viaAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ExtraRoutes6Value{
		Discard:       discardVal,
		Metric:        metricVal,
		NextQualified: nextQualifiedVal,
		NoResolve:     noResolveVal,
		Preference:    preferenceVal,
		Via:           viaVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewExtraRoutes6ValueNull() ExtraRoutes6Value {
	return ExtraRoutes6Value{
		state: attr.ValueStateNull,
	}
}

func NewExtraRoutes6ValueUnknown() ExtraRoutes6Value {
	return ExtraRoutes6Value{
		state: attr.ValueStateUnknown,
	}
}

func NewExtraRoutes6Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ExtraRoutes6Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ExtraRoutes6Value Attribute Value",
				"While creating a ExtraRoutes6Value value, a missing attribute value was detected. "+
					"A ExtraRoutes6Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ExtraRoutes6Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ExtraRoutes6Value Attribute Type",
				"While creating a ExtraRoutes6Value value, an invalid attribute value was detected. "+
					"A ExtraRoutes6Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ExtraRoutes6Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ExtraRoutes6Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ExtraRoutes6Value Attribute Value",
				"While creating a ExtraRoutes6Value value, an extra attribute value was detected. "+
					"A ExtraRoutes6Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ExtraRoutes6Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewExtraRoutes6ValueUnknown(), diags
	}

	discardAttribute, ok := attributes["discard"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`discard is missing from object`)

		return NewExtraRoutes6ValueUnknown(), diags
	}

	discardVal, ok := discardAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`discard expected to be basetypes.BoolValue, was: %T`, discardAttribute))
	}

	metricAttribute, ok := attributes["metric"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`metric is missing from object`)

		return NewExtraRoutes6ValueUnknown(), diags
	}

	metricVal, ok := metricAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`metric expected to be basetypes.Int64Value, was: %T`, metricAttribute))
	}

	nextQualifiedAttribute, ok := attributes["next_qualified"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`next_qualified is missing from object`)

		return NewExtraRoutes6ValueUnknown(), diags
	}

	nextQualifiedVal, ok := nextQualifiedAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`next_qualified expected to be basetypes.MapValue, was: %T`, nextQualifiedAttribute))
	}

	noResolveAttribute, ok := attributes["no_resolve"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`no_resolve is missing from object`)

		return NewExtraRoutes6ValueUnknown(), diags
	}

	noResolveVal, ok := noResolveAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`no_resolve expected to be basetypes.BoolValue, was: %T`, noResolveAttribute))
	}

	preferenceAttribute, ok := attributes["preference"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`preference is missing from object`)

		return NewExtraRoutes6ValueUnknown(), diags
	}

	preferenceVal, ok := preferenceAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`preference expected to be basetypes.Int64Value, was: %T`, preferenceAttribute))
	}

	viaAttribute, ok := attributes["via"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`via is missing from object`)

		return NewExtraRoutes6ValueUnknown(), diags
	}

	viaVal, ok := viaAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`via expected to be basetypes.StringValue, was: %T`, viaAttribute))
	}

	if diags.HasError() {
		return NewExtraRoutes6ValueUnknown(), diags
	}

	return ExtraRoutes6Value{
		Discard:       discardVal,
		Metric:        metricVal,
		NextQualified: nextQualifiedVal,
		NoResolve:     noResolveVal,
		Preference:    preferenceVal,
		Via:           viaVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewExtraRoutes6ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ExtraRoutes6Value {
	object, diags := NewExtraRoutes6Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewExtraRoutes6ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ExtraRoutes6Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewExtraRoutes6ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewExtraRoutes6ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewExtraRoutes6ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewExtraRoutes6ValueMust(ExtraRoutes6Value{}.AttributeTypes(ctx), attributes), nil
}

func (t ExtraRoutes6Type) ValueType(ctx context.Context) attr.Value {
	return ExtraRoutes6Value{}
}

var _ basetypes.ObjectValuable = ExtraRoutes6Value{}

type ExtraRoutes6Value struct {
	Discard       basetypes.BoolValue   `tfsdk:"discard"`
	Metric        basetypes.Int64Value  `tfsdk:"metric"`
	NextQualified basetypes.MapValue    `tfsdk:"next_qualified"`
	NoResolve     basetypes.BoolValue   `tfsdk:"no_resolve"`
	Preference    basetypes.Int64Value  `tfsdk:"preference"`
	Via           basetypes.StringValue `tfsdk:"via"`
	state         attr.ValueState
}

func (v ExtraRoutes6Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 6)

	var val tftypes.Value
	var err error

	attrTypes["discard"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["metric"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["next_qualified"] = basetypes.MapType{
		ElemType: NextQualifiedValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["no_resolve"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["preference"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["via"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 6)

		val, err = v.Discard.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["discard"] = val

		val, err = v.Metric.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["metric"] = val

		val, err = v.NextQualified.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["next_qualified"] = val

		val, err = v.NoResolve.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["no_resolve"] = val

		val, err = v.Preference.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["preference"] = val

		val, err = v.Via.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["via"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ExtraRoutes6Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ExtraRoutes6Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ExtraRoutes6Value) String() string {
	return "ExtraRoutes6Value"
}

func (v ExtraRoutes6Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	nextQualified := types.MapValueMust(
		NextQualifiedType{
			basetypes.ObjectType{
				AttrTypes: NextQualifiedValue{}.AttributeTypes(ctx),
			},
		},
		v.NextQualified.Elements(),
	)

	if v.NextQualified.IsNull() {
		nextQualified = types.MapNull(
			NextQualifiedType{
				basetypes.ObjectType{
					AttrTypes: NextQualifiedValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.NextQualified.IsUnknown() {
		nextQualified = types.MapUnknown(
			NextQualifiedType{
				basetypes.ObjectType{
					AttrTypes: NextQualifiedValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"discard": basetypes.BoolType{},
		"metric":  basetypes.Int64Type{},
		"next_qualified": basetypes.MapType{
			ElemType: NextQualifiedValue{}.Type(ctx),
		},
		"no_resolve": basetypes.BoolType{},
		"preference": basetypes.Int64Type{},
		"via":        basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"discard":        v.Discard,
			"metric":         v.Metric,
			"next_qualified": nextQualified,
			"no_resolve":     v.NoResolve,
			"preference":     v.Preference,
			"via":            v.Via,
		})

	return objVal, diags
}

func (v ExtraRoutes6Value) Equal(o attr.Value) bool {
	other, ok := o.(ExtraRoutes6Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Discard.Equal(other.Discard) {
		return false
	}

	if !v.Metric.Equal(other.Metric) {
		return false
	}

	if !v.NextQualified.Equal(other.NextQualified) {
		return false
	}

	if !v.NoResolve.Equal(other.NoResolve) {
		return false
	}

	if !v.Preference.Equal(other.Preference) {
		return false
	}

	if !v.Via.Equal(other.Via) {
		return false
	}

	return true
}

func (v ExtraRoutes6Value) Type(ctx context.Context) attr.Type {
	return ExtraRoutes6Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ExtraRoutes6Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"discard": basetypes.BoolType{},
		"metric":  basetypes.Int64Type{},
		"next_qualified": basetypes.MapType{
			ElemType: NextQualifiedValue{}.Type(ctx),
		},
		"no_resolve": basetypes.BoolType{},
		"preference": basetypes.Int64Type{},
		"via":        basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = MistNacType{}

type MistNacType struct {
	basetypes.ObjectType
}

func (t MistNacType) Equal(o attr.Type) bool {
	other, ok := o.(MistNacType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t MistNacType) String() string {
	return "MistNacType"
}

func (t MistNacType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	networkAttribute, ok := attributes["network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`network is missing from object`)

		return nil, diags
	}

	networkVal, ok := networkAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`network expected to be basetypes.StringValue, was: %T`, networkAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return MistNacValue{
		Enabled: enabledVal,
		Network: networkVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewMistNacValueNull() MistNacValue {
	return MistNacValue{
		state: attr.ValueStateNull,
	}
}

func NewMistNacValueUnknown() MistNacValue {
	return MistNacValue{
		state: attr.ValueStateUnknown,
	}
}

func NewMistNacValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (MistNacValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing MistNacValue Attribute Value",
				"While creating a MistNacValue value, a missing attribute value was detected. "+
					"A MistNacValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MistNacValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid MistNacValue Attribute Type",
				"While creating a MistNacValue value, an invalid attribute value was detected. "+
					"A MistNacValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MistNacValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("MistNacValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra MistNacValue Attribute Value",
				"While creating a MistNacValue value, an extra attribute value was detected. "+
					"A MistNacValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra MistNacValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewMistNacValueUnknown(), diags
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewMistNacValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	networkAttribute, ok := attributes["network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`network is missing from object`)

		return NewMistNacValueUnknown(), diags
	}

	networkVal, ok := networkAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`network expected to be basetypes.StringValue, was: %T`, networkAttribute))
	}

	if diags.HasError() {
		return NewMistNacValueUnknown(), diags
	}

	return MistNacValue{
		Enabled: enabledVal,
		Network: networkVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewMistNacValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) MistNacValue {
	object, diags := NewMistNacValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewMistNacValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t MistNacType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewMistNacValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewMistNacValueUnknown(), nil
	}

	if in.IsNull() {
		return NewMistNacValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewMistNacValueMust(MistNacValue{}.AttributeTypes(ctx), attributes), nil
}

func (t MistNacType) ValueType(ctx context.Context) attr.Value {
	return MistNacValue{}
}

var _ basetypes.ObjectValuable = MistNacValue{}

type MistNacValue struct {
	Enabled basetypes.BoolValue   `tfsdk:"enabled"`
	Network basetypes.StringValue `tfsdk:"network"`
	state   attr.ValueState
}

func (v MistNacValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["network"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.Network.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["network"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v MistNacValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v MistNacValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v MistNacValue) String() string {
	return "MistNacValue"
}

func (v MistNacValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"enabled": basetypes.BoolType{},
		"network": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"enabled": v.Enabled,
			"network": v.Network,
		})

	return objVal, diags
}

func (v MistNacValue) Equal(o attr.Value) bool {
	other, ok := o.(MistNacValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.Network.Equal(other.Network) {
		return false
	}

	return true
}

func (v MistNacValue) Type(ctx context.Context) attr.Type {
	return MistNacType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v MistNacValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"enabled": basetypes.BoolType{},
		"network": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = NetworksType{}

type NetworksType struct {
	basetypes.ObjectType
}

func (t NetworksType) Equal(o attr.Type) bool {
	other, ok := o.(NetworksType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t NetworksType) String() string {
	return "NetworksType"
}

func (t NetworksType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	gatewayAttribute, ok := attributes["gateway"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gateway is missing from object`)

		return nil, diags
	}

	gatewayVal, ok := gatewayAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gateway expected to be basetypes.StringValue, was: %T`, gatewayAttribute))
	}

	gateway6Attribute, ok := attributes["gateway6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gateway6 is missing from object`)

		return nil, diags
	}

	gateway6Val, ok := gateway6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gateway6 expected to be basetypes.StringValue, was: %T`, gateway6Attribute))
	}

	isolationAttribute, ok := attributes["isolation"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`isolation is missing from object`)

		return nil, diags
	}

	isolationVal, ok := isolationAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`isolation expected to be basetypes.BoolValue, was: %T`, isolationAttribute))
	}

	isolationVlanIdAttribute, ok := attributes["isolation_vlan_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`isolation_vlan_id is missing from object`)

		return nil, diags
	}

	isolationVlanIdVal, ok := isolationVlanIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`isolation_vlan_id expected to be basetypes.StringValue, was: %T`, isolationVlanIdAttribute))
	}

	subnetAttribute, ok := attributes["subnet"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet is missing from object`)

		return nil, diags
	}

	subnetVal, ok := subnetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet expected to be basetypes.StringValue, was: %T`, subnetAttribute))
	}

	subnet6Attribute, ok := attributes["subnet6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet6 is missing from object`)

		return nil, diags
	}

	subnet6Val, ok := subnet6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet6 expected to be basetypes.StringValue, was: %T`, subnet6Attribute))
	}

	vlanIdAttribute, ok := attributes["vlan_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan_id is missing from object`)

		return nil, diags
	}

	vlanIdVal, ok := vlanIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan_id expected to be basetypes.StringValue, was: %T`, vlanIdAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return NetworksValue{
		Gateway:         gatewayVal,
		Gateway6:        gateway6Val,
		Isolation:       isolationVal,
		IsolationVlanId: isolationVlanIdVal,
		Subnet:          subnetVal,
		Subnet6:         subnet6Val,
		VlanId:          vlanIdVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewNetworksValueNull() NetworksValue {
	return NetworksValue{
		state: attr.ValueStateNull,
	}
}

func NewNetworksValueUnknown() NetworksValue {
	return NetworksValue{
		state: attr.ValueStateUnknown,
	}
}

func NewNetworksValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (NetworksValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing NetworksValue Attribute Value",
				"While creating a NetworksValue value, a missing attribute value was detected. "+
					"A NetworksValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NetworksValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid NetworksValue Attribute Type",
				"While creating a NetworksValue value, an invalid attribute value was detected. "+
					"A NetworksValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NetworksValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("NetworksValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra NetworksValue Attribute Value",
				"While creating a NetworksValue value, an extra attribute value was detected. "+
					"A NetworksValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra NetworksValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewNetworksValueUnknown(), diags
	}

	gatewayAttribute, ok := attributes["gateway"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gateway is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	gatewayVal, ok := gatewayAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gateway expected to be basetypes.StringValue, was: %T`, gatewayAttribute))
	}

	gateway6Attribute, ok := attributes["gateway6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gateway6 is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	gateway6Val, ok := gateway6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gateway6 expected to be basetypes.StringValue, was: %T`, gateway6Attribute))
	}

	isolationAttribute, ok := attributes["isolation"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`isolation is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	isolationVal, ok := isolationAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`isolation expected to be basetypes.BoolValue, was: %T`, isolationAttribute))
	}

	isolationVlanIdAttribute, ok := attributes["isolation_vlan_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`isolation_vlan_id is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	isolationVlanIdVal, ok := isolationVlanIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`isolation_vlan_id expected to be basetypes.StringValue, was: %T`, isolationVlanIdAttribute))
	}

	subnetAttribute, ok := attributes["subnet"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	subnetVal, ok := subnetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet expected to be basetypes.StringValue, was: %T`, subnetAttribute))
	}

	subnet6Attribute, ok := attributes["subnet6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet6 is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	subnet6Val, ok := subnet6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet6 expected to be basetypes.StringValue, was: %T`, subnet6Attribute))
	}

	vlanIdAttribute, ok := attributes["vlan_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan_id is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	vlanIdVal, ok := vlanIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan_id expected to be basetypes.StringValue, was: %T`, vlanIdAttribute))
	}

	if diags.HasError() {
		return NewNetworksValueUnknown(), diags
	}

	return NetworksValue{
		Gateway:         gatewayVal,
		Gateway6:        gateway6Val,
		Isolation:       isolationVal,
		IsolationVlanId: isolationVlanIdVal,
		Subnet:          subnetVal,
		Subnet6:         subnet6Val,
		VlanId:          vlanIdVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewNetworksValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) NetworksValue {
	object, diags := NewNetworksValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewNetworksValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t NetworksType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewNetworksValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewNetworksValueUnknown(), nil
	}

	if in.IsNull() {
		return NewNetworksValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewNetworksValueMust(NetworksValue{}.AttributeTypes(ctx), attributes), nil
}

func (t NetworksType) ValueType(ctx context.Context) attr.Value {
	return NetworksValue{}
}

var _ basetypes.ObjectValuable = NetworksValue{}

type NetworksValue struct {
	Gateway         basetypes.StringValue `tfsdk:"gateway"`
	Gateway6        basetypes.StringValue `tfsdk:"gateway6"`
	Isolation       basetypes.BoolValue   `tfsdk:"isolation"`
	IsolationVlanId basetypes.StringValue `tfsdk:"isolation_vlan_id"`
	Subnet          basetypes.StringValue `tfsdk:"subnet"`
	Subnet6         basetypes.StringValue `tfsdk:"subnet6"`
	VlanId          basetypes.StringValue `tfsdk:"vlan_id"`
	state           attr.ValueState
}

func (v NetworksValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 7)

	var val tftypes.Value
	var err error

	attrTypes["gateway"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["gateway6"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["isolation"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["isolation_vlan_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["subnet"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["subnet6"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["vlan_id"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 7)

		val, err = v.Gateway.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["gateway"] = val

		val, err = v.Gateway6.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["gateway6"] = val

		val, err = v.Isolation.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["isolation"] = val

		val, err = v.IsolationVlanId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["isolation_vlan_id"] = val

		val, err = v.Subnet.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["subnet"] = val

		val, err = v.Subnet6.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["subnet6"] = val

		val, err = v.VlanId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vlan_id"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v NetworksValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v NetworksValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v NetworksValue) String() string {
	return "NetworksValue"
}

func (v NetworksValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"gateway":           basetypes.StringType{},
		"gateway6":          basetypes.StringType{},
		"isolation":         basetypes.BoolType{},
		"isolation_vlan_id": basetypes.StringType{},
		"subnet":            basetypes.StringType{},
		"subnet6":           basetypes.StringType{},
		"vlan_id":           basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"gateway":           v.Gateway,
			"gateway6":          v.Gateway6,
			"isolation":         v.Isolation,
			"isolation_vlan_id": v.IsolationVlanId,
			"subnet":            v.Subnet,
			"subnet6":           v.Subnet6,
			"vlan_id":           v.VlanId,
		})

	return objVal, diags
}

func (v NetworksValue) Equal(o attr.Value) bool {
	other, ok := o.(NetworksValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Gateway.Equal(other.Gateway) {
		return false
	}

	if !v.Gateway6.Equal(other.Gateway6) {
		return false
	}

	if !v.Isolation.Equal(other.Isolation) {
		return false
	}

	if !v.IsolationVlanId.Equal(other.IsolationVlanId) {
		return false
	}

	if !v.Subnet.Equal(other.Subnet) {
		return false
	}

	if !v.Subnet6.Equal(other.Subnet6) {
		return false
	}

	if !v.VlanId.Equal(other.VlanId) {
		return false
	}

	return true
}

func (v NetworksValue) Type(ctx context.Context) attr.Type {
	return NetworksType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v NetworksValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"gateway":           basetypes.StringType{},
		"gateway6":          basetypes.StringType{},
		"isolation":         basetypes.BoolType{},
		"isolation_vlan_id": basetypes.StringType{},
		"subnet":            basetypes.StringType{},
		"subnet6":           basetypes.StringType{},
		"vlan_id":           basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = OspfAreasType{}

type OspfAreasType struct {
	basetypes.ObjectType
}

func (t OspfAreasType) Equal(o attr.Type) bool {
	other, ok := o.(OspfAreasType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t OspfAreasType) String() string {
	return "OspfAreasType"
}

func (t OspfAreasType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	includeLoopbackAttribute, ok := attributes["include_loopback"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`include_loopback is missing from object`)

		return nil, diags
	}

	includeLoopbackVal, ok := includeLoopbackAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`include_loopback expected to be basetypes.BoolValue, was: %T`, includeLoopbackAttribute))
	}

	ospfNetworksAttribute, ok := attributes["networks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`networks is missing from object`)

		return nil, diags
	}

	ospfNetworksVal, ok := ospfNetworksAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`networks expected to be basetypes.MapValue, was: %T`, ospfNetworksAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return OspfAreasValue{
		IncludeLoopback: includeLoopbackVal,
		OspfNetworks:    ospfNetworksVal,
		OspfAreasType:   typeVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewOspfAreasValueNull() OspfAreasValue {
	return OspfAreasValue{
		state: attr.ValueStateNull,
	}
}

func NewOspfAreasValueUnknown() OspfAreasValue {
	return OspfAreasValue{
		state: attr.ValueStateUnknown,
	}
}

func NewOspfAreasValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (OspfAreasValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing OspfAreasValue Attribute Value",
				"While creating a OspfAreasValue value, a missing attribute value was detected. "+
					"A OspfAreasValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OspfAreasValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid OspfAreasValue Attribute Type",
				"While creating a OspfAreasValue value, an invalid attribute value was detected. "+
					"A OspfAreasValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OspfAreasValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("OspfAreasValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra OspfAreasValue Attribute Value",
				"While creating a OspfAreasValue value, an extra attribute value was detected. "+
					"A OspfAreasValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra OspfAreasValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewOspfAreasValueUnknown(), diags
	}

	includeLoopbackAttribute, ok := attributes["include_loopback"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`include_loopback is missing from object`)

		return NewOspfAreasValueUnknown(), diags
	}

	includeLoopbackVal, ok := includeLoopbackAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`include_loopback expected to be basetypes.BoolValue, was: %T`, includeLoopbackAttribute))
	}

	ospfNetworksAttribute, ok := attributes["networks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`networks is missing from object`)

		return NewOspfAreasValueUnknown(), diags
	}

	ospfNetworksVal, ok := ospfNetworksAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`networks expected to be basetypes.MapValue, was: %T`, ospfNetworksAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewOspfAreasValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return NewOspfAreasValueUnknown(), diags
	}

	return OspfAreasValue{
		IncludeLoopback: includeLoopbackVal,
		OspfNetworks:    ospfNetworksVal,
		OspfAreasType:   typeVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewOspfAreasValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) OspfAreasValue {
	object, diags := NewOspfAreasValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewOspfAreasValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t OspfAreasType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewOspfAreasValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewOspfAreasValueUnknown(), nil
	}

	if in.IsNull() {
		return NewOspfAreasValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewOspfAreasValueMust(OspfAreasValue{}.AttributeTypes(ctx), attributes), nil
}

func (t OspfAreasType) ValueType(ctx context.Context) attr.Value {
	return OspfAreasValue{}
}

var _ basetypes.ObjectValuable = OspfAreasValue{}

type OspfAreasValue struct {
	IncludeLoopback basetypes.BoolValue   `tfsdk:"include_loopback"`
	OspfNetworks    basetypes.MapValue    `tfsdk:"networks"`
	OspfAreasType   basetypes.StringValue `tfsdk:"type"`
	state           attr.ValueState
}

func (v OspfAreasValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["include_loopback"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["networks"] = basetypes.MapType{
		ElemType: OspfNetworksValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.IncludeLoopback.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["include_loopback"] = val

		val, err = v.OspfNetworks.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["networks"] = val

		val, err = v.OspfAreasType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v OspfAreasValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v OspfAreasValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v OspfAreasValue) String() string {
	return "OspfAreasValue"
}

func (v OspfAreasValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	ospfNetworks := types.MapValueMust(
		OspfNetworksType{
			basetypes.ObjectType{
				AttrTypes: OspfNetworksValue{}.AttributeTypes(ctx),
			},
		},
		v.OspfNetworks.Elements(),
	)

	if v.OspfNetworks.IsNull() {
		ospfNetworks = types.MapNull(
			OspfNetworksType{
				basetypes.ObjectType{
					AttrTypes: OspfNetworksValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.OspfNetworks.IsUnknown() {
		ospfNetworks = types.MapUnknown(
			OspfNetworksType{
				basetypes.ObjectType{
					AttrTypes: OspfNetworksValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"include_loopback": basetypes.BoolType{},
		"networks": basetypes.MapType{
			ElemType: OspfNetworksValue{}.Type(ctx),
		},
		"type": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"include_loopback": v.IncludeLoopback,
			"networks":         ospfNetworks,
			"type":             v.OspfAreasType,
		})

	return objVal, diags
}

func (v OspfAreasValue) Equal(o attr.Value) bool {
	other, ok := o.(OspfAreasValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.IncludeLoopback.Equal(other.IncludeLoopback) {
		return false
	}

	if !v.OspfNetworks.Equal(other.OspfNetworks) {
		return false
	}

	if !v.OspfAreasType.Equal(other.OspfAreasType) {
		return false
	}

	return true
}

func (v OspfAreasValue) Type(ctx context.Context) attr.Type {
	return OspfAreasType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v OspfAreasValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"include_loopback": basetypes.BoolType{},
		"networks": basetypes.MapType{
			ElemType: OspfNetworksValue{}.Type(ctx),
		},
		"type": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = OspfNetworksType{}

type OspfNetworksType struct {
	basetypes.ObjectType
}

func (t OspfNetworksType) Equal(o attr.Type) bool {
	other, ok := o.(OspfNetworksType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t OspfNetworksType) String() string {
	return "OspfNetworksType"
}

func (t OspfNetworksType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	authKeysAttribute, ok := attributes["auth_keys"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auth_keys is missing from object`)

		return nil, diags
	}

	authKeysVal, ok := authKeysAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auth_keys expected to be basetypes.MapValue, was: %T`, authKeysAttribute))
	}

	authPasswordAttribute, ok := attributes["auth_password"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auth_password is missing from object`)

		return nil, diags
	}

	authPasswordVal, ok := authPasswordAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auth_password expected to be basetypes.StringValue, was: %T`, authPasswordAttribute))
	}

	authTypeAttribute, ok := attributes["auth_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auth_type is missing from object`)

		return nil, diags
	}

	authTypeVal, ok := authTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auth_type expected to be basetypes.StringValue, was: %T`, authTypeAttribute))
	}

	bfdMinimumIntervalAttribute, ok := attributes["bfd_minimum_interval"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bfd_minimum_interval is missing from object`)

		return nil, diags
	}

	bfdMinimumIntervalVal, ok := bfdMinimumIntervalAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bfd_minimum_interval expected to be basetypes.Int64Value, was: %T`, bfdMinimumIntervalAttribute))
	}

	deadIntervalAttribute, ok := attributes["dead_interval"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dead_interval is missing from object`)

		return nil, diags
	}

	deadIntervalVal, ok := deadIntervalAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dead_interval expected to be basetypes.Int64Value, was: %T`, deadIntervalAttribute))
	}

	exportPolicyAttribute, ok := attributes["export_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`export_policy is missing from object`)

		return nil, diags
	}

	exportPolicyVal, ok := exportPolicyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`export_policy expected to be basetypes.StringValue, was: %T`, exportPolicyAttribute))
	}

	helloIntervalAttribute, ok := attributes["hello_interval"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`hello_interval is missing from object`)

		return nil, diags
	}

	helloIntervalVal, ok := helloIntervalAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`hello_interval expected to be basetypes.Int64Value, was: %T`, helloIntervalAttribute))
	}

	importPolicyAttribute, ok := attributes["import_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`import_policy is missing from object`)

		return nil, diags
	}

	importPolicyVal, ok := importPolicyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`import_policy expected to be basetypes.StringValue, was: %T`, importPolicyAttribute))
	}

	interfaceTypeAttribute, ok := attributes["interface_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_type is missing from object`)

		return nil, diags
	}

	interfaceTypeVal, ok := interfaceTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_type expected to be basetypes.StringValue, was: %T`, interfaceTypeAttribute))
	}

	metricAttribute, ok := attributes["metric"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`metric is missing from object`)

		return nil, diags
	}

	metricVal, ok := metricAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`metric expected to be basetypes.Int64Value, was: %T`, metricAttribute))
	}

	noReadvertiseToOverlayAttribute, ok := attributes["no_readvertise_to_overlay"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`no_readvertise_to_overlay is missing from object`)

		return nil, diags
	}

	noReadvertiseToOverlayVal, ok := noReadvertiseToOverlayAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`no_readvertise_to_overlay expected to be basetypes.BoolValue, was: %T`, noReadvertiseToOverlayAttribute))
	}

	passiveAttribute, ok := attributes["passive"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`passive is missing from object`)

		return nil, diags
	}

	passiveVal, ok := passiveAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`passive expected to be basetypes.BoolValue, was: %T`, passiveAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return OspfNetworksValue{
		AuthKeys:               authKeysVal,
		AuthPassword:           authPasswordVal,
		AuthType:               authTypeVal,
		BfdMinimumInterval:     bfdMinimumIntervalVal,
		DeadInterval:           deadIntervalVal,
		ExportPolicy:           exportPolicyVal,
		HelloInterval:          helloIntervalVal,
		ImportPolicy:           importPolicyVal,
		InterfaceType:          interfaceTypeVal,
		Metric:                 metricVal,
		NoReadvertiseToOverlay: noReadvertiseToOverlayVal,
		Passive:                passiveVal,
		state:                  attr.ValueStateKnown,
	}, diags
}

func NewOspfNetworksValueNull() OspfNetworksValue {
	return OspfNetworksValue{
		state: attr.ValueStateNull,
	}
}

func NewOspfNetworksValueUnknown() OspfNetworksValue {
	return OspfNetworksValue{
		state: attr.ValueStateUnknown,
	}
}

func NewOspfNetworksValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (OspfNetworksValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing OspfNetworksValue Attribute Value",
				"While creating a OspfNetworksValue value, a missing attribute value was detected. "+
					"A OspfNetworksValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OspfNetworksValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid OspfNetworksValue Attribute Type",
				"While creating a OspfNetworksValue value, an invalid attribute value was detected. "+
					"A OspfNetworksValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OspfNetworksValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("OspfNetworksValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra OspfNetworksValue Attribute Value",
				"While creating a OspfNetworksValue value, an extra attribute value was detected. "+
					"A OspfNetworksValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra OspfNetworksValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewOspfNetworksValueUnknown(), diags
	}

	authKeysAttribute, ok := attributes["auth_keys"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auth_keys is missing from object`)

		return NewOspfNetworksValueUnknown(), diags
	}

	authKeysVal, ok := authKeysAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auth_keys expected to be basetypes.MapValue, was: %T`, authKeysAttribute))
	}

	authPasswordAttribute, ok := attributes["auth_password"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auth_password is missing from object`)

		return NewOspfNetworksValueUnknown(), diags
	}

	authPasswordVal, ok := authPasswordAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auth_password expected to be basetypes.StringValue, was: %T`, authPasswordAttribute))
	}

	authTypeAttribute, ok := attributes["auth_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auth_type is missing from object`)

		return NewOspfNetworksValueUnknown(), diags
	}

	authTypeVal, ok := authTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auth_type expected to be basetypes.StringValue, was: %T`, authTypeAttribute))
	}

	bfdMinimumIntervalAttribute, ok := attributes["bfd_minimum_interval"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bfd_minimum_interval is missing from object`)

		return NewOspfNetworksValueUnknown(), diags
	}

	bfdMinimumIntervalVal, ok := bfdMinimumIntervalAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bfd_minimum_interval expected to be basetypes.Int64Value, was: %T`, bfdMinimumIntervalAttribute))
	}

	deadIntervalAttribute, ok := attributes["dead_interval"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dead_interval is missing from object`)

		return NewOspfNetworksValueUnknown(), diags
	}

	deadIntervalVal, ok := deadIntervalAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dead_interval expected to be basetypes.Int64Value, was: %T`, deadIntervalAttribute))
	}

	exportPolicyAttribute, ok := attributes["export_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`export_policy is missing from object`)

		return NewOspfNetworksValueUnknown(), diags
	}

	exportPolicyVal, ok := exportPolicyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`export_policy expected to be basetypes.StringValue, was: %T`, exportPolicyAttribute))
	}

	helloIntervalAttribute, ok := attributes["hello_interval"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`hello_interval is missing from object`)

		return NewOspfNetworksValueUnknown(), diags
	}

	helloIntervalVal, ok := helloIntervalAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`hello_interval expected to be basetypes.Int64Value, was: %T`, helloIntervalAttribute))
	}

	importPolicyAttribute, ok := attributes["import_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`import_policy is missing from object`)

		return NewOspfNetworksValueUnknown(), diags
	}

	importPolicyVal, ok := importPolicyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`import_policy expected to be basetypes.StringValue, was: %T`, importPolicyAttribute))
	}

	interfaceTypeAttribute, ok := attributes["interface_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_type is missing from object`)

		return NewOspfNetworksValueUnknown(), diags
	}

	interfaceTypeVal, ok := interfaceTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_type expected to be basetypes.StringValue, was: %T`, interfaceTypeAttribute))
	}

	metricAttribute, ok := attributes["metric"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`metric is missing from object`)

		return NewOspfNetworksValueUnknown(), diags
	}

	metricVal, ok := metricAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`metric expected to be basetypes.Int64Value, was: %T`, metricAttribute))
	}

	noReadvertiseToOverlayAttribute, ok := attributes["no_readvertise_to_overlay"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`no_readvertise_to_overlay is missing from object`)

		return NewOspfNetworksValueUnknown(), diags
	}

	noReadvertiseToOverlayVal, ok := noReadvertiseToOverlayAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`no_readvertise_to_overlay expected to be basetypes.BoolValue, was: %T`, noReadvertiseToOverlayAttribute))
	}

	passiveAttribute, ok := attributes["passive"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`passive is missing from object`)

		return NewOspfNetworksValueUnknown(), diags
	}

	passiveVal, ok := passiveAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`passive expected to be basetypes.BoolValue, was: %T`, passiveAttribute))
	}

	if diags.HasError() {
		return NewOspfNetworksValueUnknown(), diags
	}

	return OspfNetworksValue{
		AuthKeys:               authKeysVal,
		AuthPassword:           authPasswordVal,
		AuthType:               authTypeVal,
		BfdMinimumInterval:     bfdMinimumIntervalVal,
		DeadInterval:           deadIntervalVal,
		ExportPolicy:           exportPolicyVal,
		HelloInterval:          helloIntervalVal,
		ImportPolicy:           importPolicyVal,
		InterfaceType:          interfaceTypeVal,
		Metric:                 metricVal,
		NoReadvertiseToOverlay: noReadvertiseToOverlayVal,
		Passive:                passiveVal,
		state:                  attr.ValueStateKnown,
	}, diags
}

func NewOspfNetworksValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) OspfNetworksValue {
	object, diags := NewOspfNetworksValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewOspfNetworksValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t OspfNetworksType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewOspfNetworksValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewOspfNetworksValueUnknown(), nil
	}

	if in.IsNull() {
		return NewOspfNetworksValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewOspfNetworksValueMust(OspfNetworksValue{}.AttributeTypes(ctx), attributes), nil
}

func (t OspfNetworksType) ValueType(ctx context.Context) attr.Value {
	return OspfNetworksValue{}
}

var _ basetypes.ObjectValuable = OspfNetworksValue{}

type OspfNetworksValue struct {
	AuthKeys               basetypes.MapValue    `tfsdk:"auth_keys"`
	AuthPassword           basetypes.StringValue `tfsdk:"auth_password"`
	AuthType               basetypes.StringValue `tfsdk:"auth_type"`
	BfdMinimumInterval     basetypes.Int64Value  `tfsdk:"bfd_minimum_interval"`
	DeadInterval           basetypes.Int64Value  `tfsdk:"dead_interval"`
	ExportPolicy           basetypes.StringValue `tfsdk:"export_policy"`
	HelloInterval          basetypes.Int64Value  `tfsdk:"hello_interval"`
	ImportPolicy           basetypes.StringValue `tfsdk:"import_policy"`
	InterfaceType          basetypes.StringValue `tfsdk:"interface_type"`
	Metric                 basetypes.Int64Value  `tfsdk:"metric"`
	NoReadvertiseToOverlay basetypes.BoolValue   `tfsdk:"no_readvertise_to_overlay"`
	Passive                basetypes.BoolValue   `tfsdk:"passive"`
	state                  attr.ValueState
}

func (v OspfNetworksValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 12)

	var val tftypes.Value
	var err error

	attrTypes["auth_keys"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["auth_password"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["auth_type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["bfd_minimum_interval"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["dead_interval"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["export_policy"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["hello_interval"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["import_policy"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["interface_type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["metric"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["no_readvertise_to_overlay"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["passive"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 12)

		val, err = v.AuthKeys.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["auth_keys"] = val

		val, err = v.AuthPassword.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["auth_password"] = val

		val, err = v.AuthType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["auth_type"] = val

		val, err = v.BfdMinimumInterval.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bfd_minimum_interval"] = val

		val, err = v.DeadInterval.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dead_interval"] = val

		val, err = v.ExportPolicy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["export_policy"] = val

		val, err = v.HelloInterval.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["hello_interval"] = val

		val, err = v.ImportPolicy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["import_policy"] = val

		val, err = v.InterfaceType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["interface_type"] = val

		val, err = v.Metric.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["metric"] = val

		val, err = v.NoReadvertiseToOverlay.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["no_readvertise_to_overlay"] = val

		val, err = v.Passive.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["passive"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v OspfNetworksValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v OspfNetworksValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v OspfNetworksValue) String() string {
	return "OspfNetworksValue"
}

func (v OspfNetworksValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var authKeysVal basetypes.MapValue
	switch {
	case v.AuthKeys.IsUnknown():
		authKeysVal = types.MapUnknown(types.StringType)
	case v.AuthKeys.IsNull():
		authKeysVal = types.MapNull(types.StringType)
	default:
		var d diag.Diagnostics
		authKeysVal, d = types.MapValue(types.StringType, v.AuthKeys.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"auth_keys": basetypes.MapType{
				ElemType: types.StringType,
			},
			"auth_password":             basetypes.StringType{},
			"auth_type":                 basetypes.StringType{},
			"bfd_minimum_interval":      basetypes.Int64Type{},
			"dead_interval":             basetypes.Int64Type{},
			"export_policy":             basetypes.StringType{},
			"hello_interval":            basetypes.Int64Type{},
			"import_policy":             basetypes.StringType{},
			"interface_type":            basetypes.StringType{},
			"metric":                    basetypes.Int64Type{},
			"no_readvertise_to_overlay": basetypes.BoolType{},
			"passive":                   basetypes.BoolType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"auth_keys": basetypes.MapType{
			ElemType: types.StringType,
		},
		"auth_password":             basetypes.StringType{},
		"auth_type":                 basetypes.StringType{},
		"bfd_minimum_interval":      basetypes.Int64Type{},
		"dead_interval":             basetypes.Int64Type{},
		"export_policy":             basetypes.StringType{},
		"hello_interval":            basetypes.Int64Type{},
		"import_policy":             basetypes.StringType{},
		"interface_type":            basetypes.StringType{},
		"metric":                    basetypes.Int64Type{},
		"no_readvertise_to_overlay": basetypes.BoolType{},
		"passive":                   basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"auth_keys":                 authKeysVal,
			"auth_password":             v.AuthPassword,
			"auth_type":                 v.AuthType,
			"bfd_minimum_interval":      v.BfdMinimumInterval,
			"dead_interval":             v.DeadInterval,
			"export_policy":             v.ExportPolicy,
			"hello_interval":            v.HelloInterval,
			"import_policy":             v.ImportPolicy,
			"interface_type":            v.InterfaceType,
			"metric":                    v.Metric,
			"no_readvertise_to_overlay": v.NoReadvertiseToOverlay,
			"passive":                   v.Passive,
		})

	return objVal, diags
}

func (v OspfNetworksValue) Equal(o attr.Value) bool {
	other, ok := o.(OspfNetworksValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AuthKeys.Equal(other.AuthKeys) {
		return false
	}

	if !v.AuthPassword.Equal(other.AuthPassword) {
		return false
	}

	if !v.AuthType.Equal(other.AuthType) {
		return false
	}

	if !v.BfdMinimumInterval.Equal(other.BfdMinimumInterval) {
		return false
	}

	if !v.DeadInterval.Equal(other.DeadInterval) {
		return false
	}

	if !v.ExportPolicy.Equal(other.ExportPolicy) {
		return false
	}

	if !v.HelloInterval.Equal(other.HelloInterval) {
		return false
	}

	if !v.ImportPolicy.Equal(other.ImportPolicy) {
		return false
	}

	if !v.InterfaceType.Equal(other.InterfaceType) {
		return false
	}

	if !v.Metric.Equal(other.Metric) {
		return false
	}

	if !v.NoReadvertiseToOverlay.Equal(other.NoReadvertiseToOverlay) {
		return false
	}

	if !v.Passive.Equal(other.Passive) {
		return false
	}

	return true
}

func (v OspfNetworksValue) Type(ctx context.Context) attr.Type {
	return OspfNetworksType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v OspfNetworksValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"auth_keys": basetypes.MapType{
			ElemType: types.StringType,
		},
		"auth_password":             basetypes.StringType{},
		"auth_type":                 basetypes.StringType{},
		"bfd_minimum_interval":      basetypes.Int64Type{},
		"dead_interval":             basetypes.Int64Type{},
		"export_policy":             basetypes.StringType{},
		"hello_interval":            basetypes.Int64Type{},
		"import_policy":             basetypes.StringType{},
		"interface_type":            basetypes.StringType{},
		"metric":                    basetypes.Int64Type{},
		"no_readvertise_to_overlay": basetypes.BoolType{},
		"passive":                   basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = PortMirroringType{}

type PortMirroringType struct {
	basetypes.ObjectType
}

func (t PortMirroringType) Equal(o attr.Type) bool {
	other, ok := o.(PortMirroringType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PortMirroringType) String() string {
	return "PortMirroringType"
}

func (t PortMirroringType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	inputNetworksIngressAttribute, ok := attributes["input_networks_ingress"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`input_networks_ingress is missing from object`)

		return nil, diags
	}

	inputNetworksIngressVal, ok := inputNetworksIngressAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`input_networks_ingress expected to be basetypes.ListValue, was: %T`, inputNetworksIngressAttribute))
	}

	inputPortIdsEgressAttribute, ok := attributes["input_port_ids_egress"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`input_port_ids_egress is missing from object`)

		return nil, diags
	}

	inputPortIdsEgressVal, ok := inputPortIdsEgressAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`input_port_ids_egress expected to be basetypes.ListValue, was: %T`, inputPortIdsEgressAttribute))
	}

	inputPortIdsIngressAttribute, ok := attributes["input_port_ids_ingress"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`input_port_ids_ingress is missing from object`)

		return nil, diags
	}

	inputPortIdsIngressVal, ok := inputPortIdsIngressAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`input_port_ids_ingress expected to be basetypes.ListValue, was: %T`, inputPortIdsIngressAttribute))
	}

	outputIpAddressAttribute, ok := attributes["output_ip_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`output_ip_address is missing from object`)

		return nil, diags
	}

	outputIpAddressVal, ok := outputIpAddressAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`output_ip_address expected to be basetypes.StringValue, was: %T`, outputIpAddressAttribute))
	}

	outputNetworkAttribute, ok := attributes["output_network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`output_network is missing from object`)

		return nil, diags
	}

	outputNetworkVal, ok := outputNetworkAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`output_network expected to be basetypes.StringValue, was: %T`, outputNetworkAttribute))
	}

	outputPortIdAttribute, ok := attributes["output_port_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`output_port_id is missing from object`)

		return nil, diags
	}

	outputPortIdVal, ok := outputPortIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`output_port_id expected to be basetypes.StringValue, was: %T`, outputPortIdAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PortMirroringValue{
		InputNetworksIngress: inputNetworksIngressVal,
		InputPortIdsEgress:   inputPortIdsEgressVal,
		InputPortIdsIngress:  inputPortIdsIngressVal,
		OutputIpAddress:      outputIpAddressVal,
		OutputNetwork:        outputNetworkVal,
		OutputPortId:         outputPortIdVal,
		state:                attr.ValueStateKnown,
	}, diags
}

func NewPortMirroringValueNull() PortMirroringValue {
	return PortMirroringValue{
		state: attr.ValueStateNull,
	}
}

func NewPortMirroringValueUnknown() PortMirroringValue {
	return PortMirroringValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPortMirroringValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PortMirroringValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PortMirroringValue Attribute Value",
				"While creating a PortMirroringValue value, a missing attribute value was detected. "+
					"A PortMirroringValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PortMirroringValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PortMirroringValue Attribute Type",
				"While creating a PortMirroringValue value, an invalid attribute value was detected. "+
					"A PortMirroringValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PortMirroringValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PortMirroringValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PortMirroringValue Attribute Value",
				"While creating a PortMirroringValue value, an extra attribute value was detected. "+
					"A PortMirroringValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PortMirroringValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPortMirroringValueUnknown(), diags
	}

	inputNetworksIngressAttribute, ok := attributes["input_networks_ingress"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`input_networks_ingress is missing from object`)

		return NewPortMirroringValueUnknown(), diags
	}

	inputNetworksIngressVal, ok := inputNetworksIngressAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`input_networks_ingress expected to be basetypes.ListValue, was: %T`, inputNetworksIngressAttribute))
	}

	inputPortIdsEgressAttribute, ok := attributes["input_port_ids_egress"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`input_port_ids_egress is missing from object`)

		return NewPortMirroringValueUnknown(), diags
	}

	inputPortIdsEgressVal, ok := inputPortIdsEgressAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`input_port_ids_egress expected to be basetypes.ListValue, was: %T`, inputPortIdsEgressAttribute))
	}

	inputPortIdsIngressAttribute, ok := attributes["input_port_ids_ingress"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`input_port_ids_ingress is missing from object`)

		return NewPortMirroringValueUnknown(), diags
	}

	inputPortIdsIngressVal, ok := inputPortIdsIngressAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`input_port_ids_ingress expected to be basetypes.ListValue, was: %T`, inputPortIdsIngressAttribute))
	}

	outputIpAddressAttribute, ok := attributes["output_ip_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`output_ip_address is missing from object`)

		return NewPortMirroringValueUnknown(), diags
	}

	outputIpAddressVal, ok := outputIpAddressAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`output_ip_address expected to be basetypes.StringValue, was: %T`, outputIpAddressAttribute))
	}

	outputNetworkAttribute, ok := attributes["output_network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`output_network is missing from object`)

		return NewPortMirroringValueUnknown(), diags
	}

	outputNetworkVal, ok := outputNetworkAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`output_network expected to be basetypes.StringValue, was: %T`, outputNetworkAttribute))
	}

	outputPortIdAttribute, ok := attributes["output_port_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`output_port_id is missing from object`)

		return NewPortMirroringValueUnknown(), diags
	}

	outputPortIdVal, ok := outputPortIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`output_port_id expected to be basetypes.StringValue, was: %T`, outputPortIdAttribute))
	}

	if diags.HasError() {
		return NewPortMirroringValueUnknown(), diags
	}

	return PortMirroringValue{
		InputNetworksIngress: inputNetworksIngressVal,
		InputPortIdsEgress:   inputPortIdsEgressVal,
		InputPortIdsIngress:  inputPortIdsIngressVal,
		OutputIpAddress:      outputIpAddressVal,
		OutputNetwork:        outputNetworkVal,
		OutputPortId:         outputPortIdVal,
		state:                attr.ValueStateKnown,
	}, diags
}

func NewPortMirroringValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PortMirroringValue {
	object, diags := NewPortMirroringValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPortMirroringValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PortMirroringType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPortMirroringValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPortMirroringValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPortMirroringValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPortMirroringValueMust(PortMirroringValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PortMirroringType) ValueType(ctx context.Context) attr.Value {
	return PortMirroringValue{}
}

var _ basetypes.ObjectValuable = PortMirroringValue{}

type PortMirroringValue struct {
	InputNetworksIngress basetypes.ListValue   `tfsdk:"input_networks_ingress"`
	InputPortIdsEgress   basetypes.ListValue   `tfsdk:"input_port_ids_egress"`
	InputPortIdsIngress  basetypes.ListValue   `tfsdk:"input_port_ids_ingress"`
	OutputIpAddress      basetypes.StringValue `tfsdk:"output_ip_address"`
	OutputNetwork        basetypes.StringValue `tfsdk:"output_network"`
	OutputPortId         basetypes.StringValue `tfsdk:"output_port_id"`
	state                attr.ValueState
}

func (v PortMirroringValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 6)

	var val tftypes.Value
	var err error

	attrTypes["input_networks_ingress"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["input_port_ids_egress"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["input_port_ids_ingress"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["output_ip_address"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["output_network"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["output_port_id"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 6)

		val, err = v.InputNetworksIngress.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["input_networks_ingress"] = val

		val, err = v.InputPortIdsEgress.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["input_port_ids_egress"] = val

		val, err = v.InputPortIdsIngress.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["input_port_ids_ingress"] = val

		val, err = v.OutputIpAddress.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["output_ip_address"] = val

		val, err = v.OutputNetwork.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["output_network"] = val

		val, err = v.OutputPortId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["output_port_id"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PortMirroringValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PortMirroringValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PortMirroringValue) String() string {
	return "PortMirroringValue"
}

func (v PortMirroringValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var inputNetworksIngressVal basetypes.ListValue
	switch {
	case v.InputNetworksIngress.IsUnknown():
		inputNetworksIngressVal = types.ListUnknown(types.StringType)
	case v.InputNetworksIngress.IsNull():
		inputNetworksIngressVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		inputNetworksIngressVal, d = types.ListValue(types.StringType, v.InputNetworksIngress.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"input_networks_ingress": basetypes.ListType{
				ElemType: types.StringType,
			},
			"input_port_ids_egress": basetypes.ListType{
				ElemType: types.StringType,
			},
			"input_port_ids_ingress": basetypes.ListType{
				ElemType: types.StringType,
			},
			"output_ip_address": basetypes.StringType{},
			"output_network":    basetypes.StringType{},
			"output_port_id":    basetypes.StringType{},
		}), diags
	}

	var inputPortIdsEgressVal basetypes.ListValue
	switch {
	case v.InputPortIdsEgress.IsUnknown():
		inputPortIdsEgressVal = types.ListUnknown(types.StringType)
	case v.InputPortIdsEgress.IsNull():
		inputPortIdsEgressVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		inputPortIdsEgressVal, d = types.ListValue(types.StringType, v.InputPortIdsEgress.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"input_networks_ingress": basetypes.ListType{
				ElemType: types.StringType,
			},
			"input_port_ids_egress": basetypes.ListType{
				ElemType: types.StringType,
			},
			"input_port_ids_ingress": basetypes.ListType{
				ElemType: types.StringType,
			},
			"output_ip_address": basetypes.StringType{},
			"output_network":    basetypes.StringType{},
			"output_port_id":    basetypes.StringType{},
		}), diags
	}

	var inputPortIdsIngressVal basetypes.ListValue
	switch {
	case v.InputPortIdsIngress.IsUnknown():
		inputPortIdsIngressVal = types.ListUnknown(types.StringType)
	case v.InputPortIdsIngress.IsNull():
		inputPortIdsIngressVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		inputPortIdsIngressVal, d = types.ListValue(types.StringType, v.InputPortIdsIngress.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"input_networks_ingress": basetypes.ListType{
				ElemType: types.StringType,
			},
			"input_port_ids_egress": basetypes.ListType{
				ElemType: types.StringType,
			},
			"input_port_ids_ingress": basetypes.ListType{
				ElemType: types.StringType,
			},
			"output_ip_address": basetypes.StringType{},
			"output_network":    basetypes.StringType{},
			"output_port_id":    basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"input_networks_ingress": basetypes.ListType{
			ElemType: types.StringType,
		},
		"input_port_ids_egress": basetypes.ListType{
			ElemType: types.StringType,
		},
		"input_port_ids_ingress": basetypes.ListType{
			ElemType: types.StringType,
		},
		"output_ip_address": basetypes.StringType{},
		"output_network":    basetypes.StringType{},
		"output_port_id":    basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"input_networks_ingress": inputNetworksIngressVal,
			"input_port_ids_egress":  inputPortIdsEgressVal,
			"input_port_ids_ingress": inputPortIdsIngressVal,
			"output_ip_address":      v.OutputIpAddress,
			"output_network":         v.OutputNetwork,
			"output_port_id":         v.OutputPortId,
		})

	return objVal, diags
}

func (v PortMirroringValue) Equal(o attr.Value) bool {
	other, ok := o.(PortMirroringValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.InputNetworksIngress.Equal(other.InputNetworksIngress) {
		return false
	}

	if !v.InputPortIdsEgress.Equal(other.InputPortIdsEgress) {
		return false
	}

	if !v.InputPortIdsIngress.Equal(other.InputPortIdsIngress) {
		return false
	}

	if !v.OutputIpAddress.Equal(other.OutputIpAddress) {
		return false
	}

	if !v.OutputNetwork.Equal(other.OutputNetwork) {
		return false
	}

	if !v.OutputPortId.Equal(other.OutputPortId) {
		return false
	}

	return true
}

func (v PortMirroringValue) Type(ctx context.Context) attr.Type {
	return PortMirroringType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PortMirroringValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"input_networks_ingress": basetypes.ListType{
			ElemType: types.StringType,
		},
		"input_port_ids_egress": basetypes.ListType{
			ElemType: types.StringType,
		},
		"input_port_ids_ingress": basetypes.ListType{
			ElemType: types.StringType,
		},
		"output_ip_address": basetypes.StringType{},
		"output_network":    basetypes.StringType{},
		"output_port_id":    basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = PortUsagesType{}

type PortUsagesType struct {
	basetypes.ObjectType
}

func (t PortUsagesType) Equal(o attr.Type) bool {
	other, ok := o.(PortUsagesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PortUsagesType) String() string {
	return "PortUsagesType"
}

func (t PortUsagesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	allNetworksAttribute, ok := attributes["all_networks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`all_networks is missing from object`)

		return nil, diags
	}

	allNetworksVal, ok := allNetworksAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`all_networks expected to be basetypes.BoolValue, was: %T`, allNetworksAttribute))
	}

	allowDhcpdAttribute, ok := attributes["allow_dhcpd"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allow_dhcpd is missing from object`)

		return nil, diags
	}

	allowDhcpdVal, ok := allowDhcpdAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allow_dhcpd expected to be basetypes.BoolValue, was: %T`, allowDhcpdAttribute))
	}

	allowMultipleSupplicantsAttribute, ok := attributes["allow_multiple_supplicants"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allow_multiple_supplicants is missing from object`)

		return nil, diags
	}

	allowMultipleSupplicantsVal, ok := allowMultipleSupplicantsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allow_multiple_supplicants expected to be basetypes.BoolValue, was: %T`, allowMultipleSupplicantsAttribute))
	}

	bypassAuthWhenServerDownAttribute, ok := attributes["bypass_auth_when_server_down"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bypass_auth_when_server_down is missing from object`)

		return nil, diags
	}

	bypassAuthWhenServerDownVal, ok := bypassAuthWhenServerDownAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bypass_auth_when_server_down expected to be basetypes.BoolValue, was: %T`, bypassAuthWhenServerDownAttribute))
	}

	bypassAuthWhenServerDownForUnknownClientAttribute, ok := attributes["bypass_auth_when_server_down_for_unknown_client"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bypass_auth_when_server_down_for_unknown_client is missing from object`)

		return nil, diags
	}

	bypassAuthWhenServerDownForUnknownClientVal, ok := bypassAuthWhenServerDownForUnknownClientAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bypass_auth_when_server_down_for_unknown_client expected to be basetypes.BoolValue, was: %T`, bypassAuthWhenServerDownForUnknownClientAttribute))
	}

	bypassAuthWhenServerDownForVoipAttribute, ok := attributes["bypass_auth_when_server_down_for_voip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bypass_auth_when_server_down_for_voip is missing from object`)

		return nil, diags
	}

	bypassAuthWhenServerDownForVoipVal, ok := bypassAuthWhenServerDownForVoipAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bypass_auth_when_server_down_for_voip expected to be basetypes.BoolValue, was: %T`, bypassAuthWhenServerDownForVoipAttribute))
	}

	communityVlanIdAttribute, ok := attributes["community_vlan_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`community_vlan_id is missing from object`)

		return nil, diags
	}

	communityVlanIdVal, ok := communityVlanIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`community_vlan_id expected to be basetypes.Int64Value, was: %T`, communityVlanIdAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return nil, diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	disableAutonegAttribute, ok := attributes["disable_autoneg"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disable_autoneg is missing from object`)

		return nil, diags
	}

	disableAutonegVal, ok := disableAutonegAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disable_autoneg expected to be basetypes.BoolValue, was: %T`, disableAutonegAttribute))
	}

	disabledAttribute, ok := attributes["disabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disabled is missing from object`)

		return nil, diags
	}

	disabledVal, ok := disabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disabled expected to be basetypes.BoolValue, was: %T`, disabledAttribute))
	}

	duplexAttribute, ok := attributes["duplex"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`duplex is missing from object`)

		return nil, diags
	}

	duplexVal, ok := duplexAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`duplex expected to be basetypes.StringValue, was: %T`, duplexAttribute))
	}

	dynamicVlanNetworksAttribute, ok := attributes["dynamic_vlan_networks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dynamic_vlan_networks is missing from object`)

		return nil, diags
	}

	dynamicVlanNetworksVal, ok := dynamicVlanNetworksAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dynamic_vlan_networks expected to be basetypes.ListValue, was: %T`, dynamicVlanNetworksAttribute))
	}

	enableMacAuthAttribute, ok := attributes["enable_mac_auth"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable_mac_auth is missing from object`)

		return nil, diags
	}

	enableMacAuthVal, ok := enableMacAuthAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable_mac_auth expected to be basetypes.BoolValue, was: %T`, enableMacAuthAttribute))
	}

	enableQosAttribute, ok := attributes["enable_qos"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable_qos is missing from object`)

		return nil, diags
	}

	enableQosVal, ok := enableQosAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable_qos expected to be basetypes.BoolValue, was: %T`, enableQosAttribute))
	}

	guestNetworkAttribute, ok := attributes["guest_network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`guest_network is missing from object`)

		return nil, diags
	}

	guestNetworkVal, ok := guestNetworkAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`guest_network expected to be basetypes.StringValue, was: %T`, guestNetworkAttribute))
	}

	interIsolationNetworkLinkAttribute, ok := attributes["inter_isolation_network_link"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`inter_isolation_network_link is missing from object`)

		return nil, diags
	}

	interIsolationNetworkLinkVal, ok := interIsolationNetworkLinkAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`inter_isolation_network_link expected to be basetypes.BoolValue, was: %T`, interIsolationNetworkLinkAttribute))
	}

	interSwitchLinkAttribute, ok := attributes["inter_switch_link"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`inter_switch_link is missing from object`)

		return nil, diags
	}

	interSwitchLinkVal, ok := interSwitchLinkAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`inter_switch_link expected to be basetypes.BoolValue, was: %T`, interSwitchLinkAttribute))
	}

	macAuthOnlyAttribute, ok := attributes["mac_auth_only"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mac_auth_only is missing from object`)

		return nil, diags
	}

	macAuthOnlyVal, ok := macAuthOnlyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mac_auth_only expected to be basetypes.BoolValue, was: %T`, macAuthOnlyAttribute))
	}

	macAuthPreferredAttribute, ok := attributes["mac_auth_preferred"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mac_auth_preferred is missing from object`)

		return nil, diags
	}

	macAuthPreferredVal, ok := macAuthPreferredAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mac_auth_preferred expected to be basetypes.BoolValue, was: %T`, macAuthPreferredAttribute))
	}

	macAuthProtocolAttribute, ok := attributes["mac_auth_protocol"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mac_auth_protocol is missing from object`)

		return nil, diags
	}

	macAuthProtocolVal, ok := macAuthProtocolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mac_auth_protocol expected to be basetypes.StringValue, was: %T`, macAuthProtocolAttribute))
	}

	macLimitAttribute, ok := attributes["mac_limit"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mac_limit is missing from object`)

		return nil, diags
	}

	macLimitVal, ok := macLimitAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mac_limit expected to be basetypes.StringValue, was: %T`, macLimitAttribute))
	}

	modeAttribute, ok := attributes["mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mode is missing from object`)

		return nil, diags
	}

	modeVal, ok := modeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mode expected to be basetypes.StringValue, was: %T`, modeAttribute))
	}

	mtuAttribute, ok := attributes["mtu"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mtu is missing from object`)

		return nil, diags
	}

	mtuVal, ok := mtuAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mtu expected to be basetypes.StringValue, was: %T`, mtuAttribute))
	}

	networksAttribute, ok := attributes["networks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`networks is missing from object`)

		return nil, diags
	}

	networksVal, ok := networksAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`networks expected to be basetypes.ListValue, was: %T`, networksAttribute))
	}

	persistMacAttribute, ok := attributes["persist_mac"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`persist_mac is missing from object`)

		return nil, diags
	}

	persistMacVal, ok := persistMacAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`persist_mac expected to be basetypes.BoolValue, was: %T`, persistMacAttribute))
	}

	poeDisabledAttribute, ok := attributes["poe_disabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`poe_disabled is missing from object`)

		return nil, diags
	}

	poeDisabledVal, ok := poeDisabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`poe_disabled expected to be basetypes.BoolValue, was: %T`, poeDisabledAttribute))
	}

	poePriorityAttribute, ok := attributes["poe_priority"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`poe_priority is missing from object`)

		return nil, diags
	}

	poePriorityVal, ok := poePriorityAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`poe_priority expected to be basetypes.StringValue, was: %T`, poePriorityAttribute))
	}

	portAuthAttribute, ok := attributes["port_auth"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_auth is missing from object`)

		return nil, diags
	}

	portAuthVal, ok := portAuthAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_auth expected to be basetypes.StringValue, was: %T`, portAuthAttribute))
	}

	portNetworkAttribute, ok := attributes["port_network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_network is missing from object`)

		return nil, diags
	}

	portNetworkVal, ok := portNetworkAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_network expected to be basetypes.StringValue, was: %T`, portNetworkAttribute))
	}

	reauthIntervalAttribute, ok := attributes["reauth_interval"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`reauth_interval is missing from object`)

		return nil, diags
	}

	reauthIntervalVal, ok := reauthIntervalAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`reauth_interval expected to be basetypes.StringValue, was: %T`, reauthIntervalAttribute))
	}

	resetDefaultWhenAttribute, ok := attributes["reset_default_when"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`reset_default_when is missing from object`)

		return nil, diags
	}

	resetDefaultWhenVal, ok := resetDefaultWhenAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`reset_default_when expected to be basetypes.StringValue, was: %T`, resetDefaultWhenAttribute))
	}

	rulesAttribute, ok := attributes["rules"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rules is missing from object`)

		return nil, diags
	}

	rulesVal, ok := rulesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rules expected to be basetypes.ListValue, was: %T`, rulesAttribute))
	}

	serverFailNetworkAttribute, ok := attributes["server_fail_network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`server_fail_network is missing from object`)

		return nil, diags
	}

	serverFailNetworkVal, ok := serverFailNetworkAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`server_fail_network expected to be basetypes.StringValue, was: %T`, serverFailNetworkAttribute))
	}

	serverRejectNetworkAttribute, ok := attributes["server_reject_network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`server_reject_network is missing from object`)

		return nil, diags
	}

	serverRejectNetworkVal, ok := serverRejectNetworkAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`server_reject_network expected to be basetypes.StringValue, was: %T`, serverRejectNetworkAttribute))
	}

	speedAttribute, ok := attributes["speed"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`speed is missing from object`)

		return nil, diags
	}

	speedVal, ok := speedAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`speed expected to be basetypes.StringValue, was: %T`, speedAttribute))
	}

	stormControlAttribute, ok := attributes["storm_control"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`storm_control is missing from object`)

		return nil, diags
	}

	stormControlVal, ok := stormControlAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`storm_control expected to be basetypes.ObjectValue, was: %T`, stormControlAttribute))
	}

	stpDisableAttribute, ok := attributes["stp_disable"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`stp_disable is missing from object`)

		return nil, diags
	}

	stpDisableVal, ok := stpDisableAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`stp_disable expected to be basetypes.BoolValue, was: %T`, stpDisableAttribute))
	}

	stpEdgeAttribute, ok := attributes["stp_edge"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`stp_edge is missing from object`)

		return nil, diags
	}

	stpEdgeVal, ok := stpEdgeAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`stp_edge expected to be basetypes.BoolValue, was: %T`, stpEdgeAttribute))
	}

	stpNoRootPortAttribute, ok := attributes["stp_no_root_port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`stp_no_root_port is missing from object`)

		return nil, diags
	}

	stpNoRootPortVal, ok := stpNoRootPortAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`stp_no_root_port expected to be basetypes.BoolValue, was: %T`, stpNoRootPortAttribute))
	}

	stpP2pAttribute, ok := attributes["stp_p2p"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`stp_p2p is missing from object`)

		return nil, diags
	}

	stpP2pVal, ok := stpP2pAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`stp_p2p expected to be basetypes.BoolValue, was: %T`, stpP2pAttribute))
	}

	stpRequiredAttribute, ok := attributes["stp_required"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`stp_required is missing from object`)

		return nil, diags
	}

	stpRequiredVal, ok := stpRequiredAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`stp_required expected to be basetypes.BoolValue, was: %T`, stpRequiredAttribute))
	}

	uiEvpntopoIdAttribute, ok := attributes["ui_evpntopo_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ui_evpntopo_id is missing from object`)

		return nil, diags
	}

	uiEvpntopoIdVal, ok := uiEvpntopoIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ui_evpntopo_id expected to be basetypes.StringValue, was: %T`, uiEvpntopoIdAttribute))
	}

	useVstpAttribute, ok := attributes["use_vstp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`use_vstp is missing from object`)

		return nil, diags
	}

	useVstpVal, ok := useVstpAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`use_vstp expected to be basetypes.BoolValue, was: %T`, useVstpAttribute))
	}

	voipNetworkAttribute, ok := attributes["voip_network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`voip_network is missing from object`)

		return nil, diags
	}

	voipNetworkVal, ok := voipNetworkAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`voip_network expected to be basetypes.StringValue, was: %T`, voipNetworkAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PortUsagesValue{
		AllNetworks:                              allNetworksVal,
		AllowDhcpd:                               allowDhcpdVal,
		AllowMultipleSupplicants:                 allowMultipleSupplicantsVal,
		BypassAuthWhenServerDown:                 bypassAuthWhenServerDownVal,
		BypassAuthWhenServerDownForUnknownClient: bypassAuthWhenServerDownForUnknownClientVal,
		BypassAuthWhenServerDownForVoip:          bypassAuthWhenServerDownForVoipVal,
		CommunityVlanId:                          communityVlanIdVal,
		Description:                              descriptionVal,
		DisableAutoneg:                           disableAutonegVal,
		Disabled:                                 disabledVal,
		Duplex:                                   duplexVal,
		DynamicVlanNetworks:                      dynamicVlanNetworksVal,
		EnableMacAuth:                            enableMacAuthVal,
		EnableQos:                                enableQosVal,
		GuestNetwork:                             guestNetworkVal,
		InterIsolationNetworkLink:                interIsolationNetworkLinkVal,
		InterSwitchLink:                          interSwitchLinkVal,
		MacAuthOnly:                              macAuthOnlyVal,
		MacAuthPreferred:                         macAuthPreferredVal,
		MacAuthProtocol:                          macAuthProtocolVal,
		MacLimit:                                 macLimitVal,
		Mode:                                     modeVal,
		Mtu:                                      mtuVal,
		Networks:                                 networksVal,
		PersistMac:                               persistMacVal,
		PoeDisabled:                              poeDisabledVal,
		PoePriority:                              poePriorityVal,
		PortAuth:                                 portAuthVal,
		PortNetwork:                              portNetworkVal,
		ReauthInterval:                           reauthIntervalVal,
		ResetDefaultWhen:                         resetDefaultWhenVal,
		Rules:                                    rulesVal,
		ServerFailNetwork:                        serverFailNetworkVal,
		ServerRejectNetwork:                      serverRejectNetworkVal,
		Speed:                                    speedVal,
		StormControl:                             stormControlVal,
		StpDisable:                               stpDisableVal,
		StpEdge:                                  stpEdgeVal,
		StpNoRootPort:                            stpNoRootPortVal,
		StpP2p:                                   stpP2pVal,
		StpRequired:                              stpRequiredVal,
		UiEvpntopoId:                             uiEvpntopoIdVal,
		UseVstp:                                  useVstpVal,
		VoipNetwork:                              voipNetworkVal,
		state:                                    attr.ValueStateKnown,
	}, diags
}

func NewPortUsagesValueNull() PortUsagesValue {
	return PortUsagesValue{
		state: attr.ValueStateNull,
	}
}

func NewPortUsagesValueUnknown() PortUsagesValue {
	return PortUsagesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPortUsagesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PortUsagesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PortUsagesValue Attribute Value",
				"While creating a PortUsagesValue value, a missing attribute value was detected. "+
					"A PortUsagesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PortUsagesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PortUsagesValue Attribute Type",
				"While creating a PortUsagesValue value, an invalid attribute value was detected. "+
					"A PortUsagesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PortUsagesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PortUsagesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PortUsagesValue Attribute Value",
				"While creating a PortUsagesValue value, an extra attribute value was detected. "+
					"A PortUsagesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PortUsagesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPortUsagesValueUnknown(), diags
	}

	allNetworksAttribute, ok := attributes["all_networks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`all_networks is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	allNetworksVal, ok := allNetworksAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`all_networks expected to be basetypes.BoolValue, was: %T`, allNetworksAttribute))
	}

	allowDhcpdAttribute, ok := attributes["allow_dhcpd"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allow_dhcpd is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	allowDhcpdVal, ok := allowDhcpdAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allow_dhcpd expected to be basetypes.BoolValue, was: %T`, allowDhcpdAttribute))
	}

	allowMultipleSupplicantsAttribute, ok := attributes["allow_multiple_supplicants"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allow_multiple_supplicants is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	allowMultipleSupplicantsVal, ok := allowMultipleSupplicantsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allow_multiple_supplicants expected to be basetypes.BoolValue, was: %T`, allowMultipleSupplicantsAttribute))
	}

	bypassAuthWhenServerDownAttribute, ok := attributes["bypass_auth_when_server_down"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bypass_auth_when_server_down is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	bypassAuthWhenServerDownVal, ok := bypassAuthWhenServerDownAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bypass_auth_when_server_down expected to be basetypes.BoolValue, was: %T`, bypassAuthWhenServerDownAttribute))
	}

	bypassAuthWhenServerDownForUnknownClientAttribute, ok := attributes["bypass_auth_when_server_down_for_unknown_client"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bypass_auth_when_server_down_for_unknown_client is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	bypassAuthWhenServerDownForUnknownClientVal, ok := bypassAuthWhenServerDownForUnknownClientAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bypass_auth_when_server_down_for_unknown_client expected to be basetypes.BoolValue, was: %T`, bypassAuthWhenServerDownForUnknownClientAttribute))
	}

	bypassAuthWhenServerDownForVoipAttribute, ok := attributes["bypass_auth_when_server_down_for_voip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bypass_auth_when_server_down_for_voip is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	bypassAuthWhenServerDownForVoipVal, ok := bypassAuthWhenServerDownForVoipAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bypass_auth_when_server_down_for_voip expected to be basetypes.BoolValue, was: %T`, bypassAuthWhenServerDownForVoipAttribute))
	}

	communityVlanIdAttribute, ok := attributes["community_vlan_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`community_vlan_id is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	communityVlanIdVal, ok := communityVlanIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`community_vlan_id expected to be basetypes.Int64Value, was: %T`, communityVlanIdAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	disableAutonegAttribute, ok := attributes["disable_autoneg"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disable_autoneg is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	disableAutonegVal, ok := disableAutonegAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disable_autoneg expected to be basetypes.BoolValue, was: %T`, disableAutonegAttribute))
	}

	disabledAttribute, ok := attributes["disabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disabled is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	disabledVal, ok := disabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disabled expected to be basetypes.BoolValue, was: %T`, disabledAttribute))
	}

	duplexAttribute, ok := attributes["duplex"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`duplex is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	duplexVal, ok := duplexAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`duplex expected to be basetypes.StringValue, was: %T`, duplexAttribute))
	}

	dynamicVlanNetworksAttribute, ok := attributes["dynamic_vlan_networks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dynamic_vlan_networks is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	dynamicVlanNetworksVal, ok := dynamicVlanNetworksAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dynamic_vlan_networks expected to be basetypes.ListValue, was: %T`, dynamicVlanNetworksAttribute))
	}

	enableMacAuthAttribute, ok := attributes["enable_mac_auth"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable_mac_auth is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	enableMacAuthVal, ok := enableMacAuthAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable_mac_auth expected to be basetypes.BoolValue, was: %T`, enableMacAuthAttribute))
	}

	enableQosAttribute, ok := attributes["enable_qos"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable_qos is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	enableQosVal, ok := enableQosAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable_qos expected to be basetypes.BoolValue, was: %T`, enableQosAttribute))
	}

	guestNetworkAttribute, ok := attributes["guest_network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`guest_network is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	guestNetworkVal, ok := guestNetworkAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`guest_network expected to be basetypes.StringValue, was: %T`, guestNetworkAttribute))
	}

	interIsolationNetworkLinkAttribute, ok := attributes["inter_isolation_network_link"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`inter_isolation_network_link is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	interIsolationNetworkLinkVal, ok := interIsolationNetworkLinkAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`inter_isolation_network_link expected to be basetypes.BoolValue, was: %T`, interIsolationNetworkLinkAttribute))
	}

	interSwitchLinkAttribute, ok := attributes["inter_switch_link"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`inter_switch_link is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	interSwitchLinkVal, ok := interSwitchLinkAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`inter_switch_link expected to be basetypes.BoolValue, was: %T`, interSwitchLinkAttribute))
	}

	macAuthOnlyAttribute, ok := attributes["mac_auth_only"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mac_auth_only is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	macAuthOnlyVal, ok := macAuthOnlyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mac_auth_only expected to be basetypes.BoolValue, was: %T`, macAuthOnlyAttribute))
	}

	macAuthPreferredAttribute, ok := attributes["mac_auth_preferred"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mac_auth_preferred is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	macAuthPreferredVal, ok := macAuthPreferredAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mac_auth_preferred expected to be basetypes.BoolValue, was: %T`, macAuthPreferredAttribute))
	}

	macAuthProtocolAttribute, ok := attributes["mac_auth_protocol"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mac_auth_protocol is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	macAuthProtocolVal, ok := macAuthProtocolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mac_auth_protocol expected to be basetypes.StringValue, was: %T`, macAuthProtocolAttribute))
	}

	macLimitAttribute, ok := attributes["mac_limit"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mac_limit is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	macLimitVal, ok := macLimitAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mac_limit expected to be basetypes.StringValue, was: %T`, macLimitAttribute))
	}

	modeAttribute, ok := attributes["mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mode is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	modeVal, ok := modeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mode expected to be basetypes.StringValue, was: %T`, modeAttribute))
	}

	mtuAttribute, ok := attributes["mtu"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mtu is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	mtuVal, ok := mtuAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mtu expected to be basetypes.StringValue, was: %T`, mtuAttribute))
	}

	networksAttribute, ok := attributes["networks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`networks is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	networksVal, ok := networksAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`networks expected to be basetypes.ListValue, was: %T`, networksAttribute))
	}

	persistMacAttribute, ok := attributes["persist_mac"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`persist_mac is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	persistMacVal, ok := persistMacAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`persist_mac expected to be basetypes.BoolValue, was: %T`, persistMacAttribute))
	}

	poeDisabledAttribute, ok := attributes["poe_disabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`poe_disabled is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	poeDisabledVal, ok := poeDisabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`poe_disabled expected to be basetypes.BoolValue, was: %T`, poeDisabledAttribute))
	}

	poePriorityAttribute, ok := attributes["poe_priority"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`poe_priority is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	poePriorityVal, ok := poePriorityAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`poe_priority expected to be basetypes.StringValue, was: %T`, poePriorityAttribute))
	}

	portAuthAttribute, ok := attributes["port_auth"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_auth is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	portAuthVal, ok := portAuthAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_auth expected to be basetypes.StringValue, was: %T`, portAuthAttribute))
	}

	portNetworkAttribute, ok := attributes["port_network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_network is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	portNetworkVal, ok := portNetworkAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_network expected to be basetypes.StringValue, was: %T`, portNetworkAttribute))
	}

	reauthIntervalAttribute, ok := attributes["reauth_interval"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`reauth_interval is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	reauthIntervalVal, ok := reauthIntervalAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`reauth_interval expected to be basetypes.StringValue, was: %T`, reauthIntervalAttribute))
	}

	resetDefaultWhenAttribute, ok := attributes["reset_default_when"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`reset_default_when is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	resetDefaultWhenVal, ok := resetDefaultWhenAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`reset_default_when expected to be basetypes.StringValue, was: %T`, resetDefaultWhenAttribute))
	}

	rulesAttribute, ok := attributes["rules"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rules is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	rulesVal, ok := rulesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rules expected to be basetypes.ListValue, was: %T`, rulesAttribute))
	}

	serverFailNetworkAttribute, ok := attributes["server_fail_network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`server_fail_network is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	serverFailNetworkVal, ok := serverFailNetworkAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`server_fail_network expected to be basetypes.StringValue, was: %T`, serverFailNetworkAttribute))
	}

	serverRejectNetworkAttribute, ok := attributes["server_reject_network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`server_reject_network is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	serverRejectNetworkVal, ok := serverRejectNetworkAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`server_reject_network expected to be basetypes.StringValue, was: %T`, serverRejectNetworkAttribute))
	}

	speedAttribute, ok := attributes["speed"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`speed is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	speedVal, ok := speedAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`speed expected to be basetypes.StringValue, was: %T`, speedAttribute))
	}

	stormControlAttribute, ok := attributes["storm_control"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`storm_control is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	stormControlVal, ok := stormControlAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`storm_control expected to be basetypes.ObjectValue, was: %T`, stormControlAttribute))
	}

	stpDisableAttribute, ok := attributes["stp_disable"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`stp_disable is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	stpDisableVal, ok := stpDisableAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`stp_disable expected to be basetypes.BoolValue, was: %T`, stpDisableAttribute))
	}

	stpEdgeAttribute, ok := attributes["stp_edge"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`stp_edge is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	stpEdgeVal, ok := stpEdgeAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`stp_edge expected to be basetypes.BoolValue, was: %T`, stpEdgeAttribute))
	}

	stpNoRootPortAttribute, ok := attributes["stp_no_root_port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`stp_no_root_port is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	stpNoRootPortVal, ok := stpNoRootPortAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`stp_no_root_port expected to be basetypes.BoolValue, was: %T`, stpNoRootPortAttribute))
	}

	stpP2pAttribute, ok := attributes["stp_p2p"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`stp_p2p is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	stpP2pVal, ok := stpP2pAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`stp_p2p expected to be basetypes.BoolValue, was: %T`, stpP2pAttribute))
	}

	stpRequiredAttribute, ok := attributes["stp_required"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`stp_required is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	stpRequiredVal, ok := stpRequiredAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`stp_required expected to be basetypes.BoolValue, was: %T`, stpRequiredAttribute))
	}

	uiEvpntopoIdAttribute, ok := attributes["ui_evpntopo_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ui_evpntopo_id is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	uiEvpntopoIdVal, ok := uiEvpntopoIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ui_evpntopo_id expected to be basetypes.StringValue, was: %T`, uiEvpntopoIdAttribute))
	}

	useVstpAttribute, ok := attributes["use_vstp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`use_vstp is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	useVstpVal, ok := useVstpAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`use_vstp expected to be basetypes.BoolValue, was: %T`, useVstpAttribute))
	}

	voipNetworkAttribute, ok := attributes["voip_network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`voip_network is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	voipNetworkVal, ok := voipNetworkAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`voip_network expected to be basetypes.StringValue, was: %T`, voipNetworkAttribute))
	}

	if diags.HasError() {
		return NewPortUsagesValueUnknown(), diags
	}

	return PortUsagesValue{
		AllNetworks:                              allNetworksVal,
		AllowDhcpd:                               allowDhcpdVal,
		AllowMultipleSupplicants:                 allowMultipleSupplicantsVal,
		BypassAuthWhenServerDown:                 bypassAuthWhenServerDownVal,
		BypassAuthWhenServerDownForUnknownClient: bypassAuthWhenServerDownForUnknownClientVal,
		BypassAuthWhenServerDownForVoip:          bypassAuthWhenServerDownForVoipVal,
		CommunityVlanId:                          communityVlanIdVal,
		Description:                              descriptionVal,
		DisableAutoneg:                           disableAutonegVal,
		Disabled:                                 disabledVal,
		Duplex:                                   duplexVal,
		DynamicVlanNetworks:                      dynamicVlanNetworksVal,
		EnableMacAuth:                            enableMacAuthVal,
		EnableQos:                                enableQosVal,
		GuestNetwork:                             guestNetworkVal,
		InterIsolationNetworkLink:                interIsolationNetworkLinkVal,
		InterSwitchLink:                          interSwitchLinkVal,
		MacAuthOnly:                              macAuthOnlyVal,
		MacAuthPreferred:                         macAuthPreferredVal,
		MacAuthProtocol:                          macAuthProtocolVal,
		MacLimit:                                 macLimitVal,
		Mode:                                     modeVal,
		Mtu:                                      mtuVal,
		Networks:                                 networksVal,
		PersistMac:                               persistMacVal,
		PoeDisabled:                              poeDisabledVal,
		PoePriority:                              poePriorityVal,
		PortAuth:                                 portAuthVal,
		PortNetwork:                              portNetworkVal,
		ReauthInterval:                           reauthIntervalVal,
		ResetDefaultWhen:                         resetDefaultWhenVal,
		Rules:                                    rulesVal,
		ServerFailNetwork:                        serverFailNetworkVal,
		ServerRejectNetwork:                      serverRejectNetworkVal,
		Speed:                                    speedVal,
		StormControl:                             stormControlVal,
		StpDisable:                               stpDisableVal,
		StpEdge:                                  stpEdgeVal,
		StpNoRootPort:                            stpNoRootPortVal,
		StpP2p:                                   stpP2pVal,
		StpRequired:                              stpRequiredVal,
		UiEvpntopoId:                             uiEvpntopoIdVal,
		UseVstp:                                  useVstpVal,
		VoipNetwork:                              voipNetworkVal,
		state:                                    attr.ValueStateKnown,
	}, diags
}

func NewPortUsagesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PortUsagesValue {
	object, diags := NewPortUsagesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPortUsagesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PortUsagesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPortUsagesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPortUsagesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPortUsagesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPortUsagesValueMust(PortUsagesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PortUsagesType) ValueType(ctx context.Context) attr.Value {
	return PortUsagesValue{}
}

var _ basetypes.ObjectValuable = PortUsagesValue{}

type PortUsagesValue struct {
	AllNetworks                              basetypes.BoolValue   `tfsdk:"all_networks"`
	AllowDhcpd                               basetypes.BoolValue   `tfsdk:"allow_dhcpd"`
	AllowMultipleSupplicants                 basetypes.BoolValue   `tfsdk:"allow_multiple_supplicants"`
	BypassAuthWhenServerDown                 basetypes.BoolValue   `tfsdk:"bypass_auth_when_server_down"`
	BypassAuthWhenServerDownForUnknownClient basetypes.BoolValue   `tfsdk:"bypass_auth_when_server_down_for_unknown_client"`
	BypassAuthWhenServerDownForVoip          basetypes.BoolValue   `tfsdk:"bypass_auth_when_server_down_for_voip"`
	CommunityVlanId                          basetypes.Int64Value  `tfsdk:"community_vlan_id"`
	Description                              basetypes.StringValue `tfsdk:"description"`
	DisableAutoneg                           basetypes.BoolValue   `tfsdk:"disable_autoneg"`
	Disabled                                 basetypes.BoolValue   `tfsdk:"disabled"`
	Duplex                                   basetypes.StringValue `tfsdk:"duplex"`
	DynamicVlanNetworks                      basetypes.ListValue   `tfsdk:"dynamic_vlan_networks"`
	EnableMacAuth                            basetypes.BoolValue   `tfsdk:"enable_mac_auth"`
	EnableQos                                basetypes.BoolValue   `tfsdk:"enable_qos"`
	GuestNetwork                             basetypes.StringValue `tfsdk:"guest_network"`
	InterIsolationNetworkLink                basetypes.BoolValue   `tfsdk:"inter_isolation_network_link"`
	InterSwitchLink                          basetypes.BoolValue   `tfsdk:"inter_switch_link"`
	MacAuthOnly                              basetypes.BoolValue   `tfsdk:"mac_auth_only"`
	MacAuthPreferred                         basetypes.BoolValue   `tfsdk:"mac_auth_preferred"`
	MacAuthProtocol                          basetypes.StringValue `tfsdk:"mac_auth_protocol"`
	MacLimit                                 basetypes.StringValue `tfsdk:"mac_limit"`
	Mode                                     basetypes.StringValue `tfsdk:"mode"`
	Mtu                                      basetypes.StringValue `tfsdk:"mtu"`
	Networks                                 basetypes.ListValue   `tfsdk:"networks"`
	PersistMac                               basetypes.BoolValue   `tfsdk:"persist_mac"`
	PoeDisabled                              basetypes.BoolValue   `tfsdk:"poe_disabled"`
	PoePriority                              basetypes.StringValue `tfsdk:"poe_priority"`
	PortAuth                                 basetypes.StringValue `tfsdk:"port_auth"`
	PortNetwork                              basetypes.StringValue `tfsdk:"port_network"`
	ReauthInterval                           basetypes.StringValue `tfsdk:"reauth_interval"`
	ResetDefaultWhen                         basetypes.StringValue `tfsdk:"reset_default_when"`
	Rules                                    basetypes.ListValue   `tfsdk:"rules"`
	ServerFailNetwork                        basetypes.StringValue `tfsdk:"server_fail_network"`
	ServerRejectNetwork                      basetypes.StringValue `tfsdk:"server_reject_network"`
	Speed                                    basetypes.StringValue `tfsdk:"speed"`
	StormControl                             basetypes.ObjectValue `tfsdk:"storm_control"`
	StpDisable                               basetypes.BoolValue   `tfsdk:"stp_disable"`
	StpEdge                                  basetypes.BoolValue   `tfsdk:"stp_edge"`
	StpNoRootPort                            basetypes.BoolValue   `tfsdk:"stp_no_root_port"`
	StpP2p                                   basetypes.BoolValue   `tfsdk:"stp_p2p"`
	StpRequired                              basetypes.BoolValue   `tfsdk:"stp_required"`
	UiEvpntopoId                             basetypes.StringValue `tfsdk:"ui_evpntopo_id"`
	UseVstp                                  basetypes.BoolValue   `tfsdk:"use_vstp"`
	VoipNetwork                              basetypes.StringValue `tfsdk:"voip_network"`
	state                                    attr.ValueState
}

func (v PortUsagesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 44)

	var val tftypes.Value
	var err error

	attrTypes["all_networks"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["allow_dhcpd"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["allow_multiple_supplicants"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["bypass_auth_when_server_down"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["bypass_auth_when_server_down_for_unknown_client"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["bypass_auth_when_server_down_for_voip"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["community_vlan_id"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["disable_autoneg"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["disabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["duplex"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["dynamic_vlan_networks"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["enable_mac_auth"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["enable_qos"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["guest_network"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["inter_isolation_network_link"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["inter_switch_link"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["mac_auth_only"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["mac_auth_preferred"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["mac_auth_protocol"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["mac_limit"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["mode"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["mtu"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["networks"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["persist_mac"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["poe_disabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["poe_priority"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["port_auth"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["port_network"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["reauth_interval"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["reset_default_when"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["rules"] = basetypes.ListType{
		ElemType: RulesValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["server_fail_network"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["server_reject_network"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["speed"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["storm_control"] = basetypes.ObjectType{
		AttrTypes: StormControlValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["stp_disable"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["stp_edge"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["stp_no_root_port"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["stp_p2p"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["stp_required"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["ui_evpntopo_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["use_vstp"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["voip_network"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 44)

		val, err = v.AllNetworks.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["all_networks"] = val

		val, err = v.AllowDhcpd.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["allow_dhcpd"] = val

		val, err = v.AllowMultipleSupplicants.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["allow_multiple_supplicants"] = val

		val, err = v.BypassAuthWhenServerDown.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bypass_auth_when_server_down"] = val

		val, err = v.BypassAuthWhenServerDownForUnknownClient.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bypass_auth_when_server_down_for_unknown_client"] = val

		val, err = v.BypassAuthWhenServerDownForVoip.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bypass_auth_when_server_down_for_voip"] = val

		val, err = v.CommunityVlanId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["community_vlan_id"] = val

		val, err = v.Description.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["description"] = val

		val, err = v.DisableAutoneg.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["disable_autoneg"] = val

		val, err = v.Disabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["disabled"] = val

		val, err = v.Duplex.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["duplex"] = val

		val, err = v.DynamicVlanNetworks.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dynamic_vlan_networks"] = val

		val, err = v.EnableMacAuth.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enable_mac_auth"] = val

		val, err = v.EnableQos.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enable_qos"] = val

		val, err = v.GuestNetwork.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["guest_network"] = val

		val, err = v.InterIsolationNetworkLink.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["inter_isolation_network_link"] = val

		val, err = v.InterSwitchLink.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["inter_switch_link"] = val

		val, err = v.MacAuthOnly.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mac_auth_only"] = val

		val, err = v.MacAuthPreferred.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mac_auth_preferred"] = val

		val, err = v.MacAuthProtocol.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mac_auth_protocol"] = val

		val, err = v.MacLimit.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mac_limit"] = val

		val, err = v.Mode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mode"] = val

		val, err = v.Mtu.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mtu"] = val

		val, err = v.Networks.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["networks"] = val

		val, err = v.PersistMac.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["persist_mac"] = val

		val, err = v.PoeDisabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["poe_disabled"] = val

		val, err = v.PoePriority.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["poe_priority"] = val

		val, err = v.PortAuth.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port_auth"] = val

		val, err = v.PortNetwork.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port_network"] = val

		val, err = v.ReauthInterval.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["reauth_interval"] = val

		val, err = v.ResetDefaultWhen.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["reset_default_when"] = val

		val, err = v.Rules.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["rules"] = val

		val, err = v.ServerFailNetwork.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["server_fail_network"] = val

		val, err = v.ServerRejectNetwork.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["server_reject_network"] = val

		val, err = v.Speed.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["speed"] = val

		val, err = v.StormControl.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["storm_control"] = val

		val, err = v.StpDisable.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["stp_disable"] = val

		val, err = v.StpEdge.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["stp_edge"] = val

		val, err = v.StpNoRootPort.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["stp_no_root_port"] = val

		val, err = v.StpP2p.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["stp_p2p"] = val

		val, err = v.StpRequired.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["stp_required"] = val

		val, err = v.UiEvpntopoId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ui_evpntopo_id"] = val

		val, err = v.UseVstp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["use_vstp"] = val

		val, err = v.VoipNetwork.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["voip_network"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PortUsagesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PortUsagesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PortUsagesValue) String() string {
	return "PortUsagesValue"
}

func (v PortUsagesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	rules := types.ListValueMust(
		RulesType{
			basetypes.ObjectType{
				AttrTypes: RulesValue{}.AttributeTypes(ctx),
			},
		},
		v.Rules.Elements(),
	)

	if v.Rules.IsNull() {
		rules = types.ListNull(
			RulesType{
				basetypes.ObjectType{
					AttrTypes: RulesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Rules.IsUnknown() {
		rules = types.ListUnknown(
			RulesType{
				basetypes.ObjectType{
					AttrTypes: RulesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var stormControl basetypes.ObjectValue

	if v.StormControl.IsNull() {
		stormControl = types.ObjectNull(
			StormControlValue{}.AttributeTypes(ctx),
		)
	}

	if v.StormControl.IsUnknown() {
		stormControl = types.ObjectUnknown(
			StormControlValue{}.AttributeTypes(ctx),
		)
	}

	if !v.StormControl.IsNull() && !v.StormControl.IsUnknown() {
		stormControl = types.ObjectValueMust(
			StormControlValue{}.AttributeTypes(ctx),
			v.StormControl.Attributes(),
		)
	}

	var dynamicVlanNetworksVal basetypes.ListValue
	switch {
	case v.DynamicVlanNetworks.IsUnknown():
		dynamicVlanNetworksVal = types.ListUnknown(types.StringType)
	case v.DynamicVlanNetworks.IsNull():
		dynamicVlanNetworksVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		dynamicVlanNetworksVal, d = types.ListValue(types.StringType, v.DynamicVlanNetworks.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"all_networks":                                    basetypes.BoolType{},
			"allow_dhcpd":                                     basetypes.BoolType{},
			"allow_multiple_supplicants":                      basetypes.BoolType{},
			"bypass_auth_when_server_down":                    basetypes.BoolType{},
			"bypass_auth_when_server_down_for_unknown_client": basetypes.BoolType{},
			"bypass_auth_when_server_down_for_voip":           basetypes.BoolType{},
			"community_vlan_id":                               basetypes.Int64Type{},
			"description":                                     basetypes.StringType{},
			"disable_autoneg":                                 basetypes.BoolType{},
			"disabled":                                        basetypes.BoolType{},
			"duplex":                                          basetypes.StringType{},
			"dynamic_vlan_networks": basetypes.ListType{
				ElemType: types.StringType,
			},
			"enable_mac_auth":              basetypes.BoolType{},
			"enable_qos":                   basetypes.BoolType{},
			"guest_network":                basetypes.StringType{},
			"inter_isolation_network_link": basetypes.BoolType{},
			"inter_switch_link":            basetypes.BoolType{},
			"mac_auth_only":                basetypes.BoolType{},
			"mac_auth_preferred":           basetypes.BoolType{},
			"mac_auth_protocol":            basetypes.StringType{},
			"mac_limit":                    basetypes.StringType{},
			"mode":                         basetypes.StringType{},
			"mtu":                          basetypes.StringType{},
			"networks": basetypes.ListType{
				ElemType: types.StringType,
			},
			"persist_mac":        basetypes.BoolType{},
			"poe_disabled":       basetypes.BoolType{},
			"poe_priority":       basetypes.StringType{},
			"port_auth":          basetypes.StringType{},
			"port_network":       basetypes.StringType{},
			"reauth_interval":    basetypes.StringType{},
			"reset_default_when": basetypes.StringType{},
			"rules": basetypes.ListType{
				ElemType: RulesValue{}.Type(ctx),
			},
			"server_fail_network":   basetypes.StringType{},
			"server_reject_network": basetypes.StringType{},
			"speed":                 basetypes.StringType{},
			"storm_control": basetypes.ObjectType{
				AttrTypes: StormControlValue{}.AttributeTypes(ctx),
			},
			"stp_disable":      basetypes.BoolType{},
			"stp_edge":         basetypes.BoolType{},
			"stp_no_root_port": basetypes.BoolType{},
			"stp_p2p":          basetypes.BoolType{},
			"stp_required":     basetypes.BoolType{},
			"ui_evpntopo_id":   basetypes.StringType{},
			"use_vstp":         basetypes.BoolType{},
			"voip_network":     basetypes.StringType{},
		}), diags
	}

	var networksVal basetypes.ListValue
	switch {
	case v.Networks.IsUnknown():
		networksVal = types.ListUnknown(types.StringType)
	case v.Networks.IsNull():
		networksVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		networksVal, d = types.ListValue(types.StringType, v.Networks.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"all_networks":                                    basetypes.BoolType{},
			"allow_dhcpd":                                     basetypes.BoolType{},
			"allow_multiple_supplicants":                      basetypes.BoolType{},
			"bypass_auth_when_server_down":                    basetypes.BoolType{},
			"bypass_auth_when_server_down_for_unknown_client": basetypes.BoolType{},
			"bypass_auth_when_server_down_for_voip":           basetypes.BoolType{},
			"community_vlan_id":                               basetypes.Int64Type{},
			"description":                                     basetypes.StringType{},
			"disable_autoneg":                                 basetypes.BoolType{},
			"disabled":                                        basetypes.BoolType{},
			"duplex":                                          basetypes.StringType{},
			"dynamic_vlan_networks": basetypes.ListType{
				ElemType: types.StringType,
			},
			"enable_mac_auth":              basetypes.BoolType{},
			"enable_qos":                   basetypes.BoolType{},
			"guest_network":                basetypes.StringType{},
			"inter_isolation_network_link": basetypes.BoolType{},
			"inter_switch_link":            basetypes.BoolType{},
			"mac_auth_only":                basetypes.BoolType{},
			"mac_auth_preferred":           basetypes.BoolType{},
			"mac_auth_protocol":            basetypes.StringType{},
			"mac_limit":                    basetypes.StringType{},
			"mode":                         basetypes.StringType{},
			"mtu":                          basetypes.StringType{},
			"networks": basetypes.ListType{
				ElemType: types.StringType,
			},
			"persist_mac":        basetypes.BoolType{},
			"poe_disabled":       basetypes.BoolType{},
			"poe_priority":       basetypes.StringType{},
			"port_auth":          basetypes.StringType{},
			"port_network":       basetypes.StringType{},
			"reauth_interval":    basetypes.StringType{},
			"reset_default_when": basetypes.StringType{},
			"rules": basetypes.ListType{
				ElemType: RulesValue{}.Type(ctx),
			},
			"server_fail_network":   basetypes.StringType{},
			"server_reject_network": basetypes.StringType{},
			"speed":                 basetypes.StringType{},
			"storm_control": basetypes.ObjectType{
				AttrTypes: StormControlValue{}.AttributeTypes(ctx),
			},
			"stp_disable":      basetypes.BoolType{},
			"stp_edge":         basetypes.BoolType{},
			"stp_no_root_port": basetypes.BoolType{},
			"stp_p2p":          basetypes.BoolType{},
			"stp_required":     basetypes.BoolType{},
			"ui_evpntopo_id":   basetypes.StringType{},
			"use_vstp":         basetypes.BoolType{},
			"voip_network":     basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"all_networks":                                    basetypes.BoolType{},
		"allow_dhcpd":                                     basetypes.BoolType{},
		"allow_multiple_supplicants":                      basetypes.BoolType{},
		"bypass_auth_when_server_down":                    basetypes.BoolType{},
		"bypass_auth_when_server_down_for_unknown_client": basetypes.BoolType{},
		"bypass_auth_when_server_down_for_voip":           basetypes.BoolType{},
		"community_vlan_id":                               basetypes.Int64Type{},
		"description":                                     basetypes.StringType{},
		"disable_autoneg":                                 basetypes.BoolType{},
		"disabled":                                        basetypes.BoolType{},
		"duplex":                                          basetypes.StringType{},
		"dynamic_vlan_networks": basetypes.ListType{
			ElemType: types.StringType,
		},
		"enable_mac_auth":              basetypes.BoolType{},
		"enable_qos":                   basetypes.BoolType{},
		"guest_network":                basetypes.StringType{},
		"inter_isolation_network_link": basetypes.BoolType{},
		"inter_switch_link":            basetypes.BoolType{},
		"mac_auth_only":                basetypes.BoolType{},
		"mac_auth_preferred":           basetypes.BoolType{},
		"mac_auth_protocol":            basetypes.StringType{},
		"mac_limit":                    basetypes.StringType{},
		"mode":                         basetypes.StringType{},
		"mtu":                          basetypes.StringType{},
		"networks": basetypes.ListType{
			ElemType: types.StringType,
		},
		"persist_mac":        basetypes.BoolType{},
		"poe_disabled":       basetypes.BoolType{},
		"poe_priority":       basetypes.StringType{},
		"port_auth":          basetypes.StringType{},
		"port_network":       basetypes.StringType{},
		"reauth_interval":    basetypes.StringType{},
		"reset_default_when": basetypes.StringType{},
		"rules": basetypes.ListType{
			ElemType: RulesValue{}.Type(ctx),
		},
		"server_fail_network":   basetypes.StringType{},
		"server_reject_network": basetypes.StringType{},
		"speed":                 basetypes.StringType{},
		"storm_control": basetypes.ObjectType{
			AttrTypes: StormControlValue{}.AttributeTypes(ctx),
		},
		"stp_disable":      basetypes.BoolType{},
		"stp_edge":         basetypes.BoolType{},
		"stp_no_root_port": basetypes.BoolType{},
		"stp_p2p":          basetypes.BoolType{},
		"stp_required":     basetypes.BoolType{},
		"ui_evpntopo_id":   basetypes.StringType{},
		"use_vstp":         basetypes.BoolType{},
		"voip_network":     basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"all_networks":                                    v.AllNetworks,
			"allow_dhcpd":                                     v.AllowDhcpd,
			"allow_multiple_supplicants":                      v.AllowMultipleSupplicants,
			"bypass_auth_when_server_down":                    v.BypassAuthWhenServerDown,
			"bypass_auth_when_server_down_for_unknown_client": v.BypassAuthWhenServerDownForUnknownClient,
			"bypass_auth_when_server_down_for_voip":           v.BypassAuthWhenServerDownForVoip,
			"community_vlan_id":                               v.CommunityVlanId,
			"description":                                     v.Description,
			"disable_autoneg":                                 v.DisableAutoneg,
			"disabled":                                        v.Disabled,
			"duplex":                                          v.Duplex,
			"dynamic_vlan_networks":                           dynamicVlanNetworksVal,
			"enable_mac_auth":                                 v.EnableMacAuth,
			"enable_qos":                                      v.EnableQos,
			"guest_network":                                   v.GuestNetwork,
			"inter_isolation_network_link":                    v.InterIsolationNetworkLink,
			"inter_switch_link":                               v.InterSwitchLink,
			"mac_auth_only":                                   v.MacAuthOnly,
			"mac_auth_preferred":                              v.MacAuthPreferred,
			"mac_auth_protocol":                               v.MacAuthProtocol,
			"mac_limit":                                       v.MacLimit,
			"mode":                                            v.Mode,
			"mtu":                                             v.Mtu,
			"networks":                                        networksVal,
			"persist_mac":                                     v.PersistMac,
			"poe_disabled":                                    v.PoeDisabled,
			"poe_priority":                                    v.PoePriority,
			"port_auth":                                       v.PortAuth,
			"port_network":                                    v.PortNetwork,
			"reauth_interval":                                 v.ReauthInterval,
			"reset_default_when":                              v.ResetDefaultWhen,
			"rules":                                           rules,
			"server_fail_network":                             v.ServerFailNetwork,
			"server_reject_network":                           v.ServerRejectNetwork,
			"speed":                                           v.Speed,
			"storm_control":                                   stormControl,
			"stp_disable":                                     v.StpDisable,
			"stp_edge":                                        v.StpEdge,
			"stp_no_root_port":                                v.StpNoRootPort,
			"stp_p2p":                                         v.StpP2p,
			"stp_required":                                    v.StpRequired,
			"ui_evpntopo_id":                                  v.UiEvpntopoId,
			"use_vstp":                                        v.UseVstp,
			"voip_network":                                    v.VoipNetwork,
		})

	return objVal, diags
}

func (v PortUsagesValue) Equal(o attr.Value) bool {
	other, ok := o.(PortUsagesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AllNetworks.Equal(other.AllNetworks) {
		return false
	}

	if !v.AllowDhcpd.Equal(other.AllowDhcpd) {
		return false
	}

	if !v.AllowMultipleSupplicants.Equal(other.AllowMultipleSupplicants) {
		return false
	}

	if !v.BypassAuthWhenServerDown.Equal(other.BypassAuthWhenServerDown) {
		return false
	}

	if !v.BypassAuthWhenServerDownForUnknownClient.Equal(other.BypassAuthWhenServerDownForUnknownClient) {
		return false
	}

	if !v.BypassAuthWhenServerDownForVoip.Equal(other.BypassAuthWhenServerDownForVoip) {
		return false
	}

	if !v.CommunityVlanId.Equal(other.CommunityVlanId) {
		return false
	}

	if !v.Description.Equal(other.Description) {
		return false
	}

	if !v.DisableAutoneg.Equal(other.DisableAutoneg) {
		return false
	}

	if !v.Disabled.Equal(other.Disabled) {
		return false
	}

	if !v.Duplex.Equal(other.Duplex) {
		return false
	}

	if !v.DynamicVlanNetworks.Equal(other.DynamicVlanNetworks) {
		return false
	}

	if !v.EnableMacAuth.Equal(other.EnableMacAuth) {
		return false
	}

	if !v.EnableQos.Equal(other.EnableQos) {
		return false
	}

	if !v.GuestNetwork.Equal(other.GuestNetwork) {
		return false
	}

	if !v.InterIsolationNetworkLink.Equal(other.InterIsolationNetworkLink) {
		return false
	}

	if !v.InterSwitchLink.Equal(other.InterSwitchLink) {
		return false
	}

	if !v.MacAuthOnly.Equal(other.MacAuthOnly) {
		return false
	}

	if !v.MacAuthPreferred.Equal(other.MacAuthPreferred) {
		return false
	}

	if !v.MacAuthProtocol.Equal(other.MacAuthProtocol) {
		return false
	}

	if !v.MacLimit.Equal(other.MacLimit) {
		return false
	}

	if !v.Mode.Equal(other.Mode) {
		return false
	}

	if !v.Mtu.Equal(other.Mtu) {
		return false
	}

	if !v.Networks.Equal(other.Networks) {
		return false
	}

	if !v.PersistMac.Equal(other.PersistMac) {
		return false
	}

	if !v.PoeDisabled.Equal(other.PoeDisabled) {
		return false
	}

	if !v.PoePriority.Equal(other.PoePriority) {
		return false
	}

	if !v.PortAuth.Equal(other.PortAuth) {
		return false
	}

	if !v.PortNetwork.Equal(other.PortNetwork) {
		return false
	}

	if !v.ReauthInterval.Equal(other.ReauthInterval) {
		return false
	}

	if !v.ResetDefaultWhen.Equal(other.ResetDefaultWhen) {
		return false
	}

	if !v.Rules.Equal(other.Rules) {
		return false
	}

	if !v.ServerFailNetwork.Equal(other.ServerFailNetwork) {
		return false
	}

	if !v.ServerRejectNetwork.Equal(other.ServerRejectNetwork) {
		return false
	}

	if !v.Speed.Equal(other.Speed) {
		return false
	}

	if !v.StormControl.Equal(other.StormControl) {
		return false
	}

	if !v.StpDisable.Equal(other.StpDisable) {
		return false
	}

	if !v.StpEdge.Equal(other.StpEdge) {
		return false
	}

	if !v.StpNoRootPort.Equal(other.StpNoRootPort) {
		return false
	}

	if !v.StpP2p.Equal(other.StpP2p) {
		return false
	}

	if !v.StpRequired.Equal(other.StpRequired) {
		return false
	}

	if !v.UiEvpntopoId.Equal(other.UiEvpntopoId) {
		return false
	}

	if !v.UseVstp.Equal(other.UseVstp) {
		return false
	}

	if !v.VoipNetwork.Equal(other.VoipNetwork) {
		return false
	}

	return true
}

func (v PortUsagesValue) Type(ctx context.Context) attr.Type {
	return PortUsagesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PortUsagesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"all_networks":                                    basetypes.BoolType{},
		"allow_dhcpd":                                     basetypes.BoolType{},
		"allow_multiple_supplicants":                      basetypes.BoolType{},
		"bypass_auth_when_server_down":                    basetypes.BoolType{},
		"bypass_auth_when_server_down_for_unknown_client": basetypes.BoolType{},
		"bypass_auth_when_server_down_for_voip":           basetypes.BoolType{},
		"community_vlan_id":                               basetypes.Int64Type{},
		"description":                                     basetypes.StringType{},
		"disable_autoneg":                                 basetypes.BoolType{},
		"disabled":                                        basetypes.BoolType{},
		"duplex":                                          basetypes.StringType{},
		"dynamic_vlan_networks": basetypes.ListType{
			ElemType: types.StringType,
		},
		"enable_mac_auth":              basetypes.BoolType{},
		"enable_qos":                   basetypes.BoolType{},
		"guest_network":                basetypes.StringType{},
		"inter_isolation_network_link": basetypes.BoolType{},
		"inter_switch_link":            basetypes.BoolType{},
		"mac_auth_only":                basetypes.BoolType{},
		"mac_auth_preferred":           basetypes.BoolType{},
		"mac_auth_protocol":            basetypes.StringType{},
		"mac_limit":                    basetypes.StringType{},
		"mode":                         basetypes.StringType{},
		"mtu":                          basetypes.StringType{},
		"networks": basetypes.ListType{
			ElemType: types.StringType,
		},
		"persist_mac":        basetypes.BoolType{},
		"poe_disabled":       basetypes.BoolType{},
		"poe_priority":       basetypes.StringType{},
		"port_auth":          basetypes.StringType{},
		"port_network":       basetypes.StringType{},
		"reauth_interval":    basetypes.StringType{},
		"reset_default_when": basetypes.StringType{},
		"rules": basetypes.ListType{
			ElemType: RulesValue{}.Type(ctx),
		},
		"server_fail_network":   basetypes.StringType{},
		"server_reject_network": basetypes.StringType{},
		"speed":                 basetypes.StringType{},
		"storm_control": basetypes.ObjectType{
			AttrTypes: StormControlValue{}.AttributeTypes(ctx),
		},
		"stp_disable":      basetypes.BoolType{},
		"stp_edge":         basetypes.BoolType{},
		"stp_no_root_port": basetypes.BoolType{},
		"stp_p2p":          basetypes.BoolType{},
		"stp_required":     basetypes.BoolType{},
		"ui_evpntopo_id":   basetypes.StringType{},
		"use_vstp":         basetypes.BoolType{},
		"voip_network":     basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = RulesType{}

type RulesType struct {
	basetypes.ObjectType
}

func (t RulesType) Equal(o attr.Type) bool {
	other, ok := o.(RulesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t RulesType) String() string {
	return "RulesType"
}

func (t RulesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	equalsAttribute, ok := attributes["equals"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`equals is missing from object`)

		return nil, diags
	}

	equalsVal, ok := equalsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`equals expected to be basetypes.StringValue, was: %T`, equalsAttribute))
	}

	equalsAnyAttribute, ok := attributes["equals_any"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`equals_any is missing from object`)

		return nil, diags
	}

	equalsAnyVal, ok := equalsAnyAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`equals_any expected to be basetypes.ListValue, was: %T`, equalsAnyAttribute))
	}

	expressionAttribute, ok := attributes["expression"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`expression is missing from object`)

		return nil, diags
	}

	expressionVal, ok := expressionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`expression expected to be basetypes.StringValue, was: %T`, expressionAttribute))
	}

	srcAttribute, ok := attributes["src"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`src is missing from object`)

		return nil, diags
	}

	srcVal, ok := srcAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`src expected to be basetypes.StringValue, was: %T`, srcAttribute))
	}

	usageAttribute, ok := attributes["usage"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`usage is missing from object`)

		return nil, diags
	}

	usageVal, ok := usageAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`usage expected to be basetypes.StringValue, was: %T`, usageAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return RulesValue{
		Equals:     equalsVal,
		EqualsAny:  equalsAnyVal,
		Expression: expressionVal,
		Src:        srcVal,
		Usage:      usageVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewRulesValueNull() RulesValue {
	return RulesValue{
		state: attr.ValueStateNull,
	}
}

func NewRulesValueUnknown() RulesValue {
	return RulesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewRulesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (RulesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing RulesValue Attribute Value",
				"While creating a RulesValue value, a missing attribute value was detected. "+
					"A RulesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RulesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid RulesValue Attribute Type",
				"While creating a RulesValue value, an invalid attribute value was detected. "+
					"A RulesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RulesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("RulesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra RulesValue Attribute Value",
				"While creating a RulesValue value, an extra attribute value was detected. "+
					"A RulesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra RulesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewRulesValueUnknown(), diags
	}

	equalsAttribute, ok := attributes["equals"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`equals is missing from object`)

		return NewRulesValueUnknown(), diags
	}

	equalsVal, ok := equalsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`equals expected to be basetypes.StringValue, was: %T`, equalsAttribute))
	}

	equalsAnyAttribute, ok := attributes["equals_any"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`equals_any is missing from object`)

		return NewRulesValueUnknown(), diags
	}

	equalsAnyVal, ok := equalsAnyAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`equals_any expected to be basetypes.ListValue, was: %T`, equalsAnyAttribute))
	}

	expressionAttribute, ok := attributes["expression"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`expression is missing from object`)

		return NewRulesValueUnknown(), diags
	}

	expressionVal, ok := expressionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`expression expected to be basetypes.StringValue, was: %T`, expressionAttribute))
	}

	srcAttribute, ok := attributes["src"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`src is missing from object`)

		return NewRulesValueUnknown(), diags
	}

	srcVal, ok := srcAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`src expected to be basetypes.StringValue, was: %T`, srcAttribute))
	}

	usageAttribute, ok := attributes["usage"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`usage is missing from object`)

		return NewRulesValueUnknown(), diags
	}

	usageVal, ok := usageAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`usage expected to be basetypes.StringValue, was: %T`, usageAttribute))
	}

	if diags.HasError() {
		return NewRulesValueUnknown(), diags
	}

	return RulesValue{
		Equals:     equalsVal,
		EqualsAny:  equalsAnyVal,
		Expression: expressionVal,
		Src:        srcVal,
		Usage:      usageVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewRulesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) RulesValue {
	object, diags := NewRulesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewRulesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t RulesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewRulesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewRulesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewRulesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewRulesValueMust(RulesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t RulesType) ValueType(ctx context.Context) attr.Value {
	return RulesValue{}
}

var _ basetypes.ObjectValuable = RulesValue{}

type RulesValue struct {
	Equals     basetypes.StringValue `tfsdk:"equals"`
	EqualsAny  basetypes.ListValue   `tfsdk:"equals_any"`
	Expression basetypes.StringValue `tfsdk:"expression"`
	Src        basetypes.StringValue `tfsdk:"src"`
	Usage      basetypes.StringValue `tfsdk:"usage"`
	state      attr.ValueState
}

func (v RulesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["equals"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["equals_any"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["expression"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["src"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["usage"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.Equals.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["equals"] = val

		val, err = v.EqualsAny.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["equals_any"] = val

		val, err = v.Expression.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["expression"] = val

		val, err = v.Src.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["src"] = val

		val, err = v.Usage.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["usage"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v RulesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v RulesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v RulesValue) String() string {
	return "RulesValue"
}

func (v RulesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var equalsAnyVal basetypes.ListValue
	switch {
	case v.EqualsAny.IsUnknown():
		equalsAnyVal = types.ListUnknown(types.StringType)
	case v.EqualsAny.IsNull():
		equalsAnyVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		equalsAnyVal, d = types.ListValue(types.StringType, v.EqualsAny.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"equals": basetypes.StringType{},
			"equals_any": basetypes.ListType{
				ElemType: types.StringType,
			},
			"expression": basetypes.StringType{},
			"src":        basetypes.StringType{},
			"usage":      basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"equals": basetypes.StringType{},
		"equals_any": basetypes.ListType{
			ElemType: types.StringType,
		},
		"expression": basetypes.StringType{},
		"src":        basetypes.StringType{},
		"usage":      basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"equals":     v.Equals,
			"equals_any": equalsAnyVal,
			"expression": v.Expression,
			"src":        v.Src,
			"usage":      v.Usage,
		})

	return objVal, diags
}

func (v RulesValue) Equal(o attr.Value) bool {
	other, ok := o.(RulesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Equals.Equal(other.Equals) {
		return false
	}

	if !v.EqualsAny.Equal(other.EqualsAny) {
		return false
	}

	if !v.Expression.Equal(other.Expression) {
		return false
	}

	if !v.Src.Equal(other.Src) {
		return false
	}

	if !v.Usage.Equal(other.Usage) {
		return false
	}

	return true
}

func (v RulesValue) Type(ctx context.Context) attr.Type {
	return RulesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v RulesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"equals": basetypes.StringType{},
		"equals_any": basetypes.ListType{
			ElemType: types.StringType,
		},
		"expression": basetypes.StringType{},
		"src":        basetypes.StringType{},
		"usage":      basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = StormControlType{}

type StormControlType struct {
	basetypes.ObjectType
}

func (t StormControlType) Equal(o attr.Type) bool {
	other, ok := o.(StormControlType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t StormControlType) String() string {
	return "StormControlType"
}

func (t StormControlType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	disablePortAttribute, ok := attributes["disable_port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disable_port is missing from object`)

		return nil, diags
	}

	disablePortVal, ok := disablePortAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disable_port expected to be basetypes.BoolValue, was: %T`, disablePortAttribute))
	}

	noBroadcastAttribute, ok := attributes["no_broadcast"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`no_broadcast is missing from object`)

		return nil, diags
	}

	noBroadcastVal, ok := noBroadcastAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`no_broadcast expected to be basetypes.BoolValue, was: %T`, noBroadcastAttribute))
	}

	noMulticastAttribute, ok := attributes["no_multicast"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`no_multicast is missing from object`)

		return nil, diags
	}

	noMulticastVal, ok := noMulticastAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`no_multicast expected to be basetypes.BoolValue, was: %T`, noMulticastAttribute))
	}

	noRegisteredMulticastAttribute, ok := attributes["no_registered_multicast"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`no_registered_multicast is missing from object`)

		return nil, diags
	}

	noRegisteredMulticastVal, ok := noRegisteredMulticastAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`no_registered_multicast expected to be basetypes.BoolValue, was: %T`, noRegisteredMulticastAttribute))
	}

	noUnknownUnicastAttribute, ok := attributes["no_unknown_unicast"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`no_unknown_unicast is missing from object`)

		return nil, diags
	}

	noUnknownUnicastVal, ok := noUnknownUnicastAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`no_unknown_unicast expected to be basetypes.BoolValue, was: %T`, noUnknownUnicastAttribute))
	}

	percentageAttribute, ok := attributes["percentage"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`percentage is missing from object`)

		return nil, diags
	}

	percentageVal, ok := percentageAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`percentage expected to be basetypes.Int64Value, was: %T`, percentageAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return StormControlValue{
		DisablePort:           disablePortVal,
		NoBroadcast:           noBroadcastVal,
		NoMulticast:           noMulticastVal,
		NoRegisteredMulticast: noRegisteredMulticastVal,
		NoUnknownUnicast:      noUnknownUnicastVal,
		Percentage:            percentageVal,
		state:                 attr.ValueStateKnown,
	}, diags
}

func NewStormControlValueNull() StormControlValue {
	return StormControlValue{
		state: attr.ValueStateNull,
	}
}

func NewStormControlValueUnknown() StormControlValue {
	return StormControlValue{
		state: attr.ValueStateUnknown,
	}
}

func NewStormControlValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (StormControlValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing StormControlValue Attribute Value",
				"While creating a StormControlValue value, a missing attribute value was detected. "+
					"A StormControlValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StormControlValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid StormControlValue Attribute Type",
				"While creating a StormControlValue value, an invalid attribute value was detected. "+
					"A StormControlValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StormControlValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("StormControlValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra StormControlValue Attribute Value",
				"While creating a StormControlValue value, an extra attribute value was detected. "+
					"A StormControlValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra StormControlValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewStormControlValueUnknown(), diags
	}

	disablePortAttribute, ok := attributes["disable_port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disable_port is missing from object`)

		return NewStormControlValueUnknown(), diags
	}

	disablePortVal, ok := disablePortAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disable_port expected to be basetypes.BoolValue, was: %T`, disablePortAttribute))
	}

	noBroadcastAttribute, ok := attributes["no_broadcast"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`no_broadcast is missing from object`)

		return NewStormControlValueUnknown(), diags
	}

	noBroadcastVal, ok := noBroadcastAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`no_broadcast expected to be basetypes.BoolValue, was: %T`, noBroadcastAttribute))
	}

	noMulticastAttribute, ok := attributes["no_multicast"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`no_multicast is missing from object`)

		return NewStormControlValueUnknown(), diags
	}

	noMulticastVal, ok := noMulticastAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`no_multicast expected to be basetypes.BoolValue, was: %T`, noMulticastAttribute))
	}

	noRegisteredMulticastAttribute, ok := attributes["no_registered_multicast"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`no_registered_multicast is missing from object`)

		return NewStormControlValueUnknown(), diags
	}

	noRegisteredMulticastVal, ok := noRegisteredMulticastAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`no_registered_multicast expected to be basetypes.BoolValue, was: %T`, noRegisteredMulticastAttribute))
	}

	noUnknownUnicastAttribute, ok := attributes["no_unknown_unicast"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`no_unknown_unicast is missing from object`)

		return NewStormControlValueUnknown(), diags
	}

	noUnknownUnicastVal, ok := noUnknownUnicastAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`no_unknown_unicast expected to be basetypes.BoolValue, was: %T`, noUnknownUnicastAttribute))
	}

	percentageAttribute, ok := attributes["percentage"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`percentage is missing from object`)

		return NewStormControlValueUnknown(), diags
	}

	percentageVal, ok := percentageAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`percentage expected to be basetypes.Int64Value, was: %T`, percentageAttribute))
	}

	if diags.HasError() {
		return NewStormControlValueUnknown(), diags
	}

	return StormControlValue{
		DisablePort:           disablePortVal,
		NoBroadcast:           noBroadcastVal,
		NoMulticast:           noMulticastVal,
		NoRegisteredMulticast: noRegisteredMulticastVal,
		NoUnknownUnicast:      noUnknownUnicastVal,
		Percentage:            percentageVal,
		state:                 attr.ValueStateKnown,
	}, diags
}

func NewStormControlValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) StormControlValue {
	object, diags := NewStormControlValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewStormControlValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t StormControlType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewStormControlValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewStormControlValueUnknown(), nil
	}

	if in.IsNull() {
		return NewStormControlValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewStormControlValueMust(StormControlValue{}.AttributeTypes(ctx), attributes), nil
}

func (t StormControlType) ValueType(ctx context.Context) attr.Value {
	return StormControlValue{}
}

var _ basetypes.ObjectValuable = StormControlValue{}

type StormControlValue struct {
	DisablePort           basetypes.BoolValue  `tfsdk:"disable_port"`
	NoBroadcast           basetypes.BoolValue  `tfsdk:"no_broadcast"`
	NoMulticast           basetypes.BoolValue  `tfsdk:"no_multicast"`
	NoRegisteredMulticast basetypes.BoolValue  `tfsdk:"no_registered_multicast"`
	NoUnknownUnicast      basetypes.BoolValue  `tfsdk:"no_unknown_unicast"`
	Percentage            basetypes.Int64Value `tfsdk:"percentage"`
	state                 attr.ValueState
}

func (v StormControlValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 6)

	var val tftypes.Value
	var err error

	attrTypes["disable_port"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["no_broadcast"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["no_multicast"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["no_registered_multicast"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["no_unknown_unicast"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["percentage"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 6)

		val, err = v.DisablePort.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["disable_port"] = val

		val, err = v.NoBroadcast.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["no_broadcast"] = val

		val, err = v.NoMulticast.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["no_multicast"] = val

		val, err = v.NoRegisteredMulticast.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["no_registered_multicast"] = val

		val, err = v.NoUnknownUnicast.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["no_unknown_unicast"] = val

		val, err = v.Percentage.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["percentage"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v StormControlValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v StormControlValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v StormControlValue) String() string {
	return "StormControlValue"
}

func (v StormControlValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"disable_port":            basetypes.BoolType{},
		"no_broadcast":            basetypes.BoolType{},
		"no_multicast":            basetypes.BoolType{},
		"no_registered_multicast": basetypes.BoolType{},
		"no_unknown_unicast":      basetypes.BoolType{},
		"percentage":              basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"disable_port":            v.DisablePort,
			"no_broadcast":            v.NoBroadcast,
			"no_multicast":            v.NoMulticast,
			"no_registered_multicast": v.NoRegisteredMulticast,
			"no_unknown_unicast":      v.NoUnknownUnicast,
			"percentage":              v.Percentage,
		})

	return objVal, diags
}

func (v StormControlValue) Equal(o attr.Value) bool {
	other, ok := o.(StormControlValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.DisablePort.Equal(other.DisablePort) {
		return false
	}

	if !v.NoBroadcast.Equal(other.NoBroadcast) {
		return false
	}

	if !v.NoMulticast.Equal(other.NoMulticast) {
		return false
	}

	if !v.NoRegisteredMulticast.Equal(other.NoRegisteredMulticast) {
		return false
	}

	if !v.NoUnknownUnicast.Equal(other.NoUnknownUnicast) {
		return false
	}

	if !v.Percentage.Equal(other.Percentage) {
		return false
	}

	return true
}

func (v StormControlValue) Type(ctx context.Context) attr.Type {
	return StormControlType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v StormControlValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"disable_port":            basetypes.BoolType{},
		"no_broadcast":            basetypes.BoolType{},
		"no_multicast":            basetypes.BoolType{},
		"no_registered_multicast": basetypes.BoolType{},
		"no_unknown_unicast":      basetypes.BoolType{},
		"percentage":              basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = RadiusConfigType{}

type RadiusConfigType struct {
	basetypes.ObjectType
}

func (t RadiusConfigType) Equal(o attr.Type) bool {
	other, ok := o.(RadiusConfigType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t RadiusConfigType) String() string {
	return "RadiusConfigType"
}

func (t RadiusConfigType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	acctImmediateUpdateAttribute, ok := attributes["acct_immediate_update"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`acct_immediate_update is missing from object`)

		return nil, diags
	}

	acctImmediateUpdateVal, ok := acctImmediateUpdateAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`acct_immediate_update expected to be basetypes.BoolValue, was: %T`, acctImmediateUpdateAttribute))
	}

	acctInterimIntervalAttribute, ok := attributes["acct_interim_interval"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`acct_interim_interval is missing from object`)

		return nil, diags
	}

	acctInterimIntervalVal, ok := acctInterimIntervalAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`acct_interim_interval expected to be basetypes.Int64Value, was: %T`, acctInterimIntervalAttribute))
	}

	acctServersAttribute, ok := attributes["acct_servers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`acct_servers is missing from object`)

		return nil, diags
	}

	acctServersVal, ok := acctServersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`acct_servers expected to be basetypes.ListValue, was: %T`, acctServersAttribute))
	}

	authServerSelectionAttribute, ok := attributes["auth_server_selection"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auth_server_selection is missing from object`)

		return nil, diags
	}

	authServerSelectionVal, ok := authServerSelectionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auth_server_selection expected to be basetypes.StringValue, was: %T`, authServerSelectionAttribute))
	}

	authServersAttribute, ok := attributes["auth_servers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auth_servers is missing from object`)

		return nil, diags
	}

	authServersVal, ok := authServersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auth_servers expected to be basetypes.ListValue, was: %T`, authServersAttribute))
	}

	authServersRetriesAttribute, ok := attributes["auth_servers_retries"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auth_servers_retries is missing from object`)

		return nil, diags
	}

	authServersRetriesVal, ok := authServersRetriesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auth_servers_retries expected to be basetypes.Int64Value, was: %T`, authServersRetriesAttribute))
	}

	authServersTimeoutAttribute, ok := attributes["auth_servers_timeout"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auth_servers_timeout is missing from object`)

		return nil, diags
	}

	authServersTimeoutVal, ok := authServersTimeoutAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auth_servers_timeout expected to be basetypes.Int64Value, was: %T`, authServersTimeoutAttribute))
	}

	coaEnabledAttribute, ok := attributes["coa_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`coa_enabled is missing from object`)

		return nil, diags
	}

	coaEnabledVal, ok := coaEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`coa_enabled expected to be basetypes.BoolValue, was: %T`, coaEnabledAttribute))
	}

	coaPortAttribute, ok := attributes["coa_port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`coa_port is missing from object`)

		return nil, diags
	}

	coaPortVal, ok := coaPortAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`coa_port expected to be basetypes.StringValue, was: %T`, coaPortAttribute))
	}

	fastDot1xTimersAttribute, ok := attributes["fast_dot1x_timers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fast_dot1x_timers is missing from object`)

		return nil, diags
	}

	fastDot1xTimersVal, ok := fastDot1xTimersAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fast_dot1x_timers expected to be basetypes.BoolValue, was: %T`, fastDot1xTimersAttribute))
	}

	networkAttribute, ok := attributes["network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`network is missing from object`)

		return nil, diags
	}

	networkVal, ok := networkAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`network expected to be basetypes.StringValue, was: %T`, networkAttribute))
	}

	sourceIpAttribute, ok := attributes["source_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`source_ip is missing from object`)

		return nil, diags
	}

	sourceIpVal, ok := sourceIpAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`source_ip expected to be basetypes.StringValue, was: %T`, sourceIpAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return RadiusConfigValue{
		AcctImmediateUpdate: acctImmediateUpdateVal,
		AcctInterimInterval: acctInterimIntervalVal,
		AcctServers:         acctServersVal,
		AuthServerSelection: authServerSelectionVal,
		AuthServers:         authServersVal,
		AuthServersRetries:  authServersRetriesVal,
		AuthServersTimeout:  authServersTimeoutVal,
		CoaEnabled:          coaEnabledVal,
		CoaPort:             coaPortVal,
		FastDot1xTimers:     fastDot1xTimersVal,
		Network:             networkVal,
		SourceIp:            sourceIpVal,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewRadiusConfigValueNull() RadiusConfigValue {
	return RadiusConfigValue{
		state: attr.ValueStateNull,
	}
}

func NewRadiusConfigValueUnknown() RadiusConfigValue {
	return RadiusConfigValue{
		state: attr.ValueStateUnknown,
	}
}

func NewRadiusConfigValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (RadiusConfigValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing RadiusConfigValue Attribute Value",
				"While creating a RadiusConfigValue value, a missing attribute value was detected. "+
					"A RadiusConfigValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RadiusConfigValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid RadiusConfigValue Attribute Type",
				"While creating a RadiusConfigValue value, an invalid attribute value was detected. "+
					"A RadiusConfigValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RadiusConfigValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("RadiusConfigValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra RadiusConfigValue Attribute Value",
				"While creating a RadiusConfigValue value, an extra attribute value was detected. "+
					"A RadiusConfigValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra RadiusConfigValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewRadiusConfigValueUnknown(), diags
	}

	acctImmediateUpdateAttribute, ok := attributes["acct_immediate_update"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`acct_immediate_update is missing from object`)

		return NewRadiusConfigValueUnknown(), diags
	}

	acctImmediateUpdateVal, ok := acctImmediateUpdateAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`acct_immediate_update expected to be basetypes.BoolValue, was: %T`, acctImmediateUpdateAttribute))
	}

	acctInterimIntervalAttribute, ok := attributes["acct_interim_interval"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`acct_interim_interval is missing from object`)

		return NewRadiusConfigValueUnknown(), diags
	}

	acctInterimIntervalVal, ok := acctInterimIntervalAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`acct_interim_interval expected to be basetypes.Int64Value, was: %T`, acctInterimIntervalAttribute))
	}

	acctServersAttribute, ok := attributes["acct_servers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`acct_servers is missing from object`)

		return NewRadiusConfigValueUnknown(), diags
	}

	acctServersVal, ok := acctServersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`acct_servers expected to be basetypes.ListValue, was: %T`, acctServersAttribute))
	}

	authServerSelectionAttribute, ok := attributes["auth_server_selection"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auth_server_selection is missing from object`)

		return NewRadiusConfigValueUnknown(), diags
	}

	authServerSelectionVal, ok := authServerSelectionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auth_server_selection expected to be basetypes.StringValue, was: %T`, authServerSelectionAttribute))
	}

	authServersAttribute, ok := attributes["auth_servers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auth_servers is missing from object`)

		return NewRadiusConfigValueUnknown(), diags
	}

	authServersVal, ok := authServersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auth_servers expected to be basetypes.ListValue, was: %T`, authServersAttribute))
	}

	authServersRetriesAttribute, ok := attributes["auth_servers_retries"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auth_servers_retries is missing from object`)

		return NewRadiusConfigValueUnknown(), diags
	}

	authServersRetriesVal, ok := authServersRetriesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auth_servers_retries expected to be basetypes.Int64Value, was: %T`, authServersRetriesAttribute))
	}

	authServersTimeoutAttribute, ok := attributes["auth_servers_timeout"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auth_servers_timeout is missing from object`)

		return NewRadiusConfigValueUnknown(), diags
	}

	authServersTimeoutVal, ok := authServersTimeoutAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auth_servers_timeout expected to be basetypes.Int64Value, was: %T`, authServersTimeoutAttribute))
	}

	coaEnabledAttribute, ok := attributes["coa_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`coa_enabled is missing from object`)

		return NewRadiusConfigValueUnknown(), diags
	}

	coaEnabledVal, ok := coaEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`coa_enabled expected to be basetypes.BoolValue, was: %T`, coaEnabledAttribute))
	}

	coaPortAttribute, ok := attributes["coa_port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`coa_port is missing from object`)

		return NewRadiusConfigValueUnknown(), diags
	}

	coaPortVal, ok := coaPortAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`coa_port expected to be basetypes.StringValue, was: %T`, coaPortAttribute))
	}

	fastDot1xTimersAttribute, ok := attributes["fast_dot1x_timers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fast_dot1x_timers is missing from object`)

		return NewRadiusConfigValueUnknown(), diags
	}

	fastDot1xTimersVal, ok := fastDot1xTimersAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fast_dot1x_timers expected to be basetypes.BoolValue, was: %T`, fastDot1xTimersAttribute))
	}

	networkAttribute, ok := attributes["network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`network is missing from object`)

		return NewRadiusConfigValueUnknown(), diags
	}

	networkVal, ok := networkAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`network expected to be basetypes.StringValue, was: %T`, networkAttribute))
	}

	sourceIpAttribute, ok := attributes["source_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`source_ip is missing from object`)

		return NewRadiusConfigValueUnknown(), diags
	}

	sourceIpVal, ok := sourceIpAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`source_ip expected to be basetypes.StringValue, was: %T`, sourceIpAttribute))
	}

	if diags.HasError() {
		return NewRadiusConfigValueUnknown(), diags
	}

	return RadiusConfigValue{
		AcctImmediateUpdate: acctImmediateUpdateVal,
		AcctInterimInterval: acctInterimIntervalVal,
		AcctServers:         acctServersVal,
		AuthServerSelection: authServerSelectionVal,
		AuthServers:         authServersVal,
		AuthServersRetries:  authServersRetriesVal,
		AuthServersTimeout:  authServersTimeoutVal,
		CoaEnabled:          coaEnabledVal,
		CoaPort:             coaPortVal,
		FastDot1xTimers:     fastDot1xTimersVal,
		Network:             networkVal,
		SourceIp:            sourceIpVal,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewRadiusConfigValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) RadiusConfigValue {
	object, diags := NewRadiusConfigValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewRadiusConfigValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t RadiusConfigType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewRadiusConfigValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewRadiusConfigValueUnknown(), nil
	}

	if in.IsNull() {
		return NewRadiusConfigValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewRadiusConfigValueMust(RadiusConfigValue{}.AttributeTypes(ctx), attributes), nil
}

func (t RadiusConfigType) ValueType(ctx context.Context) attr.Value {
	return RadiusConfigValue{}
}

var _ basetypes.ObjectValuable = RadiusConfigValue{}

type RadiusConfigValue struct {
	AcctImmediateUpdate basetypes.BoolValue   `tfsdk:"acct_immediate_update"`
	AcctInterimInterval basetypes.Int64Value  `tfsdk:"acct_interim_interval"`
	AcctServers         basetypes.ListValue   `tfsdk:"acct_servers"`
	AuthServerSelection basetypes.StringValue `tfsdk:"auth_server_selection"`
	AuthServers         basetypes.ListValue   `tfsdk:"auth_servers"`
	AuthServersRetries  basetypes.Int64Value  `tfsdk:"auth_servers_retries"`
	AuthServersTimeout  basetypes.Int64Value  `tfsdk:"auth_servers_timeout"`
	CoaEnabled          basetypes.BoolValue   `tfsdk:"coa_enabled"`
	CoaPort             basetypes.StringValue `tfsdk:"coa_port"`
	FastDot1xTimers     basetypes.BoolValue   `tfsdk:"fast_dot1x_timers"`
	Network             basetypes.StringValue `tfsdk:"network"`
	SourceIp            basetypes.StringValue `tfsdk:"source_ip"`
	state               attr.ValueState
}

func (v RadiusConfigValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 12)

	var val tftypes.Value
	var err error

	attrTypes["acct_immediate_update"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["acct_interim_interval"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["acct_servers"] = basetypes.ListType{
		ElemType: AcctServersValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["auth_server_selection"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["auth_servers"] = basetypes.ListType{
		ElemType: AuthServersValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["auth_servers_retries"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["auth_servers_timeout"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["coa_enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["coa_port"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["fast_dot1x_timers"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["network"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["source_ip"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 12)

		val, err = v.AcctImmediateUpdate.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["acct_immediate_update"] = val

		val, err = v.AcctInterimInterval.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["acct_interim_interval"] = val

		val, err = v.AcctServers.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["acct_servers"] = val

		val, err = v.AuthServerSelection.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["auth_server_selection"] = val

		val, err = v.AuthServers.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["auth_servers"] = val

		val, err = v.AuthServersRetries.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["auth_servers_retries"] = val

		val, err = v.AuthServersTimeout.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["auth_servers_timeout"] = val

		val, err = v.CoaEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["coa_enabled"] = val

		val, err = v.CoaPort.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["coa_port"] = val

		val, err = v.FastDot1xTimers.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["fast_dot1x_timers"] = val

		val, err = v.Network.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["network"] = val

		val, err = v.SourceIp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["source_ip"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v RadiusConfigValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v RadiusConfigValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v RadiusConfigValue) String() string {
	return "RadiusConfigValue"
}

func (v RadiusConfigValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	acctServers := types.ListValueMust(
		AcctServersType{
			basetypes.ObjectType{
				AttrTypes: AcctServersValue{}.AttributeTypes(ctx),
			},
		},
		v.AcctServers.Elements(),
	)

	if v.AcctServers.IsNull() {
		acctServers = types.ListNull(
			AcctServersType{
				basetypes.ObjectType{
					AttrTypes: AcctServersValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.AcctServers.IsUnknown() {
		acctServers = types.ListUnknown(
			AcctServersType{
				basetypes.ObjectType{
					AttrTypes: AcctServersValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	authServers := types.ListValueMust(
		AuthServersType{
			basetypes.ObjectType{
				AttrTypes: AuthServersValue{}.AttributeTypes(ctx),
			},
		},
		v.AuthServers.Elements(),
	)

	if v.AuthServers.IsNull() {
		authServers = types.ListNull(
			AuthServersType{
				basetypes.ObjectType{
					AttrTypes: AuthServersValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.AuthServers.IsUnknown() {
		authServers = types.ListUnknown(
			AuthServersType{
				basetypes.ObjectType{
					AttrTypes: AuthServersValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"acct_immediate_update": basetypes.BoolType{},
		"acct_interim_interval": basetypes.Int64Type{},
		"acct_servers": basetypes.ListType{
			ElemType: AcctServersValue{}.Type(ctx),
		},
		"auth_server_selection": basetypes.StringType{},
		"auth_servers": basetypes.ListType{
			ElemType: AuthServersValue{}.Type(ctx),
		},
		"auth_servers_retries": basetypes.Int64Type{},
		"auth_servers_timeout": basetypes.Int64Type{},
		"coa_enabled":          basetypes.BoolType{},
		"coa_port":             basetypes.StringType{},
		"fast_dot1x_timers":    basetypes.BoolType{},
		"network":              basetypes.StringType{},
		"source_ip":            basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"acct_immediate_update": v.AcctImmediateUpdate,
			"acct_interim_interval": v.AcctInterimInterval,
			"acct_servers":          acctServers,
			"auth_server_selection": v.AuthServerSelection,
			"auth_servers":          authServers,
			"auth_servers_retries":  v.AuthServersRetries,
			"auth_servers_timeout":  v.AuthServersTimeout,
			"coa_enabled":           v.CoaEnabled,
			"coa_port":              v.CoaPort,
			"fast_dot1x_timers":     v.FastDot1xTimers,
			"network":               v.Network,
			"source_ip":             v.SourceIp,
		})

	return objVal, diags
}

func (v RadiusConfigValue) Equal(o attr.Value) bool {
	other, ok := o.(RadiusConfigValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AcctImmediateUpdate.Equal(other.AcctImmediateUpdate) {
		return false
	}

	if !v.AcctInterimInterval.Equal(other.AcctInterimInterval) {
		return false
	}

	if !v.AcctServers.Equal(other.AcctServers) {
		return false
	}

	if !v.AuthServerSelection.Equal(other.AuthServerSelection) {
		return false
	}

	if !v.AuthServers.Equal(other.AuthServers) {
		return false
	}

	if !v.AuthServersRetries.Equal(other.AuthServersRetries) {
		return false
	}

	if !v.AuthServersTimeout.Equal(other.AuthServersTimeout) {
		return false
	}

	if !v.CoaEnabled.Equal(other.CoaEnabled) {
		return false
	}

	if !v.CoaPort.Equal(other.CoaPort) {
		return false
	}

	if !v.FastDot1xTimers.Equal(other.FastDot1xTimers) {
		return false
	}

	if !v.Network.Equal(other.Network) {
		return false
	}

	if !v.SourceIp.Equal(other.SourceIp) {
		return false
	}

	return true
}

func (v RadiusConfigValue) Type(ctx context.Context) attr.Type {
	return RadiusConfigType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v RadiusConfigValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"acct_immediate_update": basetypes.BoolType{},
		"acct_interim_interval": basetypes.Int64Type{},
		"acct_servers": basetypes.ListType{
			ElemType: AcctServersValue{}.Type(ctx),
		},
		"auth_server_selection": basetypes.StringType{},
		"auth_servers": basetypes.ListType{
			ElemType: AuthServersValue{}.Type(ctx),
		},
		"auth_servers_retries": basetypes.Int64Type{},
		"auth_servers_timeout": basetypes.Int64Type{},
		"coa_enabled":          basetypes.BoolType{},
		"coa_port":             basetypes.StringType{},
		"fast_dot1x_timers":    basetypes.BoolType{},
		"network":              basetypes.StringType{},
		"source_ip":            basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = AcctServersType{}

type AcctServersType struct {
	basetypes.ObjectType
}

func (t AcctServersType) Equal(o attr.Type) bool {
	other, ok := o.(AcctServersType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AcctServersType) String() string {
	return "AcctServersType"
}

func (t AcctServersType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	hostAttribute, ok := attributes["host"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`host is missing from object`)

		return nil, diags
	}

	hostVal, ok := hostAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`host expected to be basetypes.StringValue, was: %T`, hostAttribute))
	}

	keywrapEnabledAttribute, ok := attributes["keywrap_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywrap_enabled is missing from object`)

		return nil, diags
	}

	keywrapEnabledVal, ok := keywrapEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywrap_enabled expected to be basetypes.BoolValue, was: %T`, keywrapEnabledAttribute))
	}

	keywrapFormatAttribute, ok := attributes["keywrap_format"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywrap_format is missing from object`)

		return nil, diags
	}

	keywrapFormatVal, ok := keywrapFormatAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywrap_format expected to be basetypes.StringValue, was: %T`, keywrapFormatAttribute))
	}

	keywrapKekAttribute, ok := attributes["keywrap_kek"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywrap_kek is missing from object`)

		return nil, diags
	}

	keywrapKekVal, ok := keywrapKekAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywrap_kek expected to be basetypes.StringValue, was: %T`, keywrapKekAttribute))
	}

	keywrapMackAttribute, ok := attributes["keywrap_mack"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywrap_mack is missing from object`)

		return nil, diags
	}

	keywrapMackVal, ok := keywrapMackAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywrap_mack expected to be basetypes.StringValue, was: %T`, keywrapMackAttribute))
	}

	portAttribute, ok := attributes["port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port is missing from object`)

		return nil, diags
	}

	portVal, ok := portAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port expected to be basetypes.StringValue, was: %T`, portAttribute))
	}

	secretAttribute, ok := attributes["secret"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`secret is missing from object`)

		return nil, diags
	}

	secretVal, ok := secretAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`secret expected to be basetypes.StringValue, was: %T`, secretAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AcctServersValue{
		Host:           hostVal,
		KeywrapEnabled: keywrapEnabledVal,
		KeywrapFormat:  keywrapFormatVal,
		KeywrapKek:     keywrapKekVal,
		KeywrapMack:    keywrapMackVal,
		Port:           portVal,
		Secret:         secretVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewAcctServersValueNull() AcctServersValue {
	return AcctServersValue{
		state: attr.ValueStateNull,
	}
}

func NewAcctServersValueUnknown() AcctServersValue {
	return AcctServersValue{
		state: attr.ValueStateUnknown,
	}
}

func NewAcctServersValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AcctServersValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AcctServersValue Attribute Value",
				"While creating a AcctServersValue value, a missing attribute value was detected. "+
					"A AcctServersValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AcctServersValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AcctServersValue Attribute Type",
				"While creating a AcctServersValue value, an invalid attribute value was detected. "+
					"A AcctServersValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AcctServersValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AcctServersValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AcctServersValue Attribute Value",
				"While creating a AcctServersValue value, an extra attribute value was detected. "+
					"A AcctServersValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AcctServersValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAcctServersValueUnknown(), diags
	}

	hostAttribute, ok := attributes["host"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`host is missing from object`)

		return NewAcctServersValueUnknown(), diags
	}

	hostVal, ok := hostAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`host expected to be basetypes.StringValue, was: %T`, hostAttribute))
	}

	keywrapEnabledAttribute, ok := attributes["keywrap_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywrap_enabled is missing from object`)

		return NewAcctServersValueUnknown(), diags
	}

	keywrapEnabledVal, ok := keywrapEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywrap_enabled expected to be basetypes.BoolValue, was: %T`, keywrapEnabledAttribute))
	}

	keywrapFormatAttribute, ok := attributes["keywrap_format"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywrap_format is missing from object`)

		return NewAcctServersValueUnknown(), diags
	}

	keywrapFormatVal, ok := keywrapFormatAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywrap_format expected to be basetypes.StringValue, was: %T`, keywrapFormatAttribute))
	}

	keywrapKekAttribute, ok := attributes["keywrap_kek"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywrap_kek is missing from object`)

		return NewAcctServersValueUnknown(), diags
	}

	keywrapKekVal, ok := keywrapKekAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywrap_kek expected to be basetypes.StringValue, was: %T`, keywrapKekAttribute))
	}

	keywrapMackAttribute, ok := attributes["keywrap_mack"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywrap_mack is missing from object`)

		return NewAcctServersValueUnknown(), diags
	}

	keywrapMackVal, ok := keywrapMackAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywrap_mack expected to be basetypes.StringValue, was: %T`, keywrapMackAttribute))
	}

	portAttribute, ok := attributes["port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port is missing from object`)

		return NewAcctServersValueUnknown(), diags
	}

	portVal, ok := portAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port expected to be basetypes.StringValue, was: %T`, portAttribute))
	}

	secretAttribute, ok := attributes["secret"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`secret is missing from object`)

		return NewAcctServersValueUnknown(), diags
	}

	secretVal, ok := secretAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`secret expected to be basetypes.StringValue, was: %T`, secretAttribute))
	}

	if diags.HasError() {
		return NewAcctServersValueUnknown(), diags
	}

	return AcctServersValue{
		Host:           hostVal,
		KeywrapEnabled: keywrapEnabledVal,
		KeywrapFormat:  keywrapFormatVal,
		KeywrapKek:     keywrapKekVal,
		KeywrapMack:    keywrapMackVal,
		Port:           portVal,
		Secret:         secretVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewAcctServersValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AcctServersValue {
	object, diags := NewAcctServersValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAcctServersValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AcctServersType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAcctServersValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAcctServersValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAcctServersValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAcctServersValueMust(AcctServersValue{}.AttributeTypes(ctx), attributes), nil
}

func (t AcctServersType) ValueType(ctx context.Context) attr.Value {
	return AcctServersValue{}
}

var _ basetypes.ObjectValuable = AcctServersValue{}

type AcctServersValue struct {
	Host           basetypes.StringValue `tfsdk:"host"`
	KeywrapEnabled basetypes.BoolValue   `tfsdk:"keywrap_enabled"`
	KeywrapFormat  basetypes.StringValue `tfsdk:"keywrap_format"`
	KeywrapKek     basetypes.StringValue `tfsdk:"keywrap_kek"`
	KeywrapMack    basetypes.StringValue `tfsdk:"keywrap_mack"`
	Port           basetypes.StringValue `tfsdk:"port"`
	Secret         basetypes.StringValue `tfsdk:"secret"`
	state          attr.ValueState
}

func (v AcctServersValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 7)

	var val tftypes.Value
	var err error

	attrTypes["host"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["keywrap_enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["keywrap_format"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["keywrap_kek"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["keywrap_mack"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["port"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["secret"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 7)

		val, err = v.Host.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["host"] = val

		val, err = v.KeywrapEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["keywrap_enabled"] = val

		val, err = v.KeywrapFormat.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["keywrap_format"] = val

		val, err = v.KeywrapKek.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["keywrap_kek"] = val

		val, err = v.KeywrapMack.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["keywrap_mack"] = val

		val, err = v.Port.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port"] = val

		val, err = v.Secret.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["secret"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AcctServersValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AcctServersValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AcctServersValue) String() string {
	return "AcctServersValue"
}

func (v AcctServersValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"host":            basetypes.StringType{},
		"keywrap_enabled": basetypes.BoolType{},
		"keywrap_format":  basetypes.StringType{},
		"keywrap_kek":     basetypes.StringType{},
		"keywrap_mack":    basetypes.StringType{},
		"port":            basetypes.StringType{},
		"secret":          basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"host":            v.Host,
			"keywrap_enabled": v.KeywrapEnabled,
			"keywrap_format":  v.KeywrapFormat,
			"keywrap_kek":     v.KeywrapKek,
			"keywrap_mack":    v.KeywrapMack,
			"port":            v.Port,
			"secret":          v.Secret,
		})

	return objVal, diags
}

func (v AcctServersValue) Equal(o attr.Value) bool {
	other, ok := o.(AcctServersValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Host.Equal(other.Host) {
		return false
	}

	if !v.KeywrapEnabled.Equal(other.KeywrapEnabled) {
		return false
	}

	if !v.KeywrapFormat.Equal(other.KeywrapFormat) {
		return false
	}

	if !v.KeywrapKek.Equal(other.KeywrapKek) {
		return false
	}

	if !v.KeywrapMack.Equal(other.KeywrapMack) {
		return false
	}

	if !v.Port.Equal(other.Port) {
		return false
	}

	if !v.Secret.Equal(other.Secret) {
		return false
	}

	return true
}

func (v AcctServersValue) Type(ctx context.Context) attr.Type {
	return AcctServersType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AcctServersValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"host":            basetypes.StringType{},
		"keywrap_enabled": basetypes.BoolType{},
		"keywrap_format":  basetypes.StringType{},
		"keywrap_kek":     basetypes.StringType{},
		"keywrap_mack":    basetypes.StringType{},
		"port":            basetypes.StringType{},
		"secret":          basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = AuthServersType{}

type AuthServersType struct {
	basetypes.ObjectType
}

func (t AuthServersType) Equal(o attr.Type) bool {
	other, ok := o.(AuthServersType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AuthServersType) String() string {
	return "AuthServersType"
}

func (t AuthServersType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	hostAttribute, ok := attributes["host"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`host is missing from object`)

		return nil, diags
	}

	hostVal, ok := hostAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`host expected to be basetypes.StringValue, was: %T`, hostAttribute))
	}

	keywrapEnabledAttribute, ok := attributes["keywrap_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywrap_enabled is missing from object`)

		return nil, diags
	}

	keywrapEnabledVal, ok := keywrapEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywrap_enabled expected to be basetypes.BoolValue, was: %T`, keywrapEnabledAttribute))
	}

	keywrapFormatAttribute, ok := attributes["keywrap_format"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywrap_format is missing from object`)

		return nil, diags
	}

	keywrapFormatVal, ok := keywrapFormatAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywrap_format expected to be basetypes.StringValue, was: %T`, keywrapFormatAttribute))
	}

	keywrapKekAttribute, ok := attributes["keywrap_kek"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywrap_kek is missing from object`)

		return nil, diags
	}

	keywrapKekVal, ok := keywrapKekAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywrap_kek expected to be basetypes.StringValue, was: %T`, keywrapKekAttribute))
	}

	keywrapMackAttribute, ok := attributes["keywrap_mack"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywrap_mack is missing from object`)

		return nil, diags
	}

	keywrapMackVal, ok := keywrapMackAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywrap_mack expected to be basetypes.StringValue, was: %T`, keywrapMackAttribute))
	}

	portAttribute, ok := attributes["port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port is missing from object`)

		return nil, diags
	}

	portVal, ok := portAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port expected to be basetypes.StringValue, was: %T`, portAttribute))
	}

	requireMessageAuthenticatorAttribute, ok := attributes["require_message_authenticator"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`require_message_authenticator is missing from object`)

		return nil, diags
	}

	requireMessageAuthenticatorVal, ok := requireMessageAuthenticatorAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`require_message_authenticator expected to be basetypes.BoolValue, was: %T`, requireMessageAuthenticatorAttribute))
	}

	secretAttribute, ok := attributes["secret"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`secret is missing from object`)

		return nil, diags
	}

	secretVal, ok := secretAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`secret expected to be basetypes.StringValue, was: %T`, secretAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AuthServersValue{
		Host:                        hostVal,
		KeywrapEnabled:              keywrapEnabledVal,
		KeywrapFormat:               keywrapFormatVal,
		KeywrapKek:                  keywrapKekVal,
		KeywrapMack:                 keywrapMackVal,
		Port:                        portVal,
		RequireMessageAuthenticator: requireMessageAuthenticatorVal,
		Secret:                      secretVal,
		state:                       attr.ValueStateKnown,
	}, diags
}

func NewAuthServersValueNull() AuthServersValue {
	return AuthServersValue{
		state: attr.ValueStateNull,
	}
}

func NewAuthServersValueUnknown() AuthServersValue {
	return AuthServersValue{
		state: attr.ValueStateUnknown,
	}
}

func NewAuthServersValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AuthServersValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AuthServersValue Attribute Value",
				"While creating a AuthServersValue value, a missing attribute value was detected. "+
					"A AuthServersValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AuthServersValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AuthServersValue Attribute Type",
				"While creating a AuthServersValue value, an invalid attribute value was detected. "+
					"A AuthServersValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AuthServersValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AuthServersValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AuthServersValue Attribute Value",
				"While creating a AuthServersValue value, an extra attribute value was detected. "+
					"A AuthServersValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AuthServersValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAuthServersValueUnknown(), diags
	}

	hostAttribute, ok := attributes["host"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`host is missing from object`)

		return NewAuthServersValueUnknown(), diags
	}

	hostVal, ok := hostAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`host expected to be basetypes.StringValue, was: %T`, hostAttribute))
	}

	keywrapEnabledAttribute, ok := attributes["keywrap_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywrap_enabled is missing from object`)

		return NewAuthServersValueUnknown(), diags
	}

	keywrapEnabledVal, ok := keywrapEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywrap_enabled expected to be basetypes.BoolValue, was: %T`, keywrapEnabledAttribute))
	}

	keywrapFormatAttribute, ok := attributes["keywrap_format"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywrap_format is missing from object`)

		return NewAuthServersValueUnknown(), diags
	}

	keywrapFormatVal, ok := keywrapFormatAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywrap_format expected to be basetypes.StringValue, was: %T`, keywrapFormatAttribute))
	}

	keywrapKekAttribute, ok := attributes["keywrap_kek"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywrap_kek is missing from object`)

		return NewAuthServersValueUnknown(), diags
	}

	keywrapKekVal, ok := keywrapKekAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywrap_kek expected to be basetypes.StringValue, was: %T`, keywrapKekAttribute))
	}

	keywrapMackAttribute, ok := attributes["keywrap_mack"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywrap_mack is missing from object`)

		return NewAuthServersValueUnknown(), diags
	}

	keywrapMackVal, ok := keywrapMackAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywrap_mack expected to be basetypes.StringValue, was: %T`, keywrapMackAttribute))
	}

	portAttribute, ok := attributes["port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port is missing from object`)

		return NewAuthServersValueUnknown(), diags
	}

	portVal, ok := portAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port expected to be basetypes.StringValue, was: %T`, portAttribute))
	}

	requireMessageAuthenticatorAttribute, ok := attributes["require_message_authenticator"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`require_message_authenticator is missing from object`)

		return NewAuthServersValueUnknown(), diags
	}

	requireMessageAuthenticatorVal, ok := requireMessageAuthenticatorAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`require_message_authenticator expected to be basetypes.BoolValue, was: %T`, requireMessageAuthenticatorAttribute))
	}

	secretAttribute, ok := attributes["secret"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`secret is missing from object`)

		return NewAuthServersValueUnknown(), diags
	}

	secretVal, ok := secretAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`secret expected to be basetypes.StringValue, was: %T`, secretAttribute))
	}

	if diags.HasError() {
		return NewAuthServersValueUnknown(), diags
	}

	return AuthServersValue{
		Host:                        hostVal,
		KeywrapEnabled:              keywrapEnabledVal,
		KeywrapFormat:               keywrapFormatVal,
		KeywrapKek:                  keywrapKekVal,
		KeywrapMack:                 keywrapMackVal,
		Port:                        portVal,
		RequireMessageAuthenticator: requireMessageAuthenticatorVal,
		Secret:                      secretVal,
		state:                       attr.ValueStateKnown,
	}, diags
}

func NewAuthServersValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AuthServersValue {
	object, diags := NewAuthServersValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAuthServersValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AuthServersType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAuthServersValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAuthServersValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAuthServersValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAuthServersValueMust(AuthServersValue{}.AttributeTypes(ctx), attributes), nil
}

func (t AuthServersType) ValueType(ctx context.Context) attr.Value {
	return AuthServersValue{}
}

var _ basetypes.ObjectValuable = AuthServersValue{}

type AuthServersValue struct {
	Host                        basetypes.StringValue `tfsdk:"host"`
	KeywrapEnabled              basetypes.BoolValue   `tfsdk:"keywrap_enabled"`
	KeywrapFormat               basetypes.StringValue `tfsdk:"keywrap_format"`
	KeywrapKek                  basetypes.StringValue `tfsdk:"keywrap_kek"`
	KeywrapMack                 basetypes.StringValue `tfsdk:"keywrap_mack"`
	Port                        basetypes.StringValue `tfsdk:"port"`
	RequireMessageAuthenticator basetypes.BoolValue   `tfsdk:"require_message_authenticator"`
	Secret                      basetypes.StringValue `tfsdk:"secret"`
	state                       attr.ValueState
}

func (v AuthServersValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 8)

	var val tftypes.Value
	var err error

	attrTypes["host"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["keywrap_enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["keywrap_format"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["keywrap_kek"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["keywrap_mack"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["port"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["require_message_authenticator"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["secret"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 8)

		val, err = v.Host.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["host"] = val

		val, err = v.KeywrapEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["keywrap_enabled"] = val

		val, err = v.KeywrapFormat.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["keywrap_format"] = val

		val, err = v.KeywrapKek.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["keywrap_kek"] = val

		val, err = v.KeywrapMack.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["keywrap_mack"] = val

		val, err = v.Port.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port"] = val

		val, err = v.RequireMessageAuthenticator.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["require_message_authenticator"] = val

		val, err = v.Secret.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["secret"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AuthServersValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AuthServersValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AuthServersValue) String() string {
	return "AuthServersValue"
}

func (v AuthServersValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"host":                          basetypes.StringType{},
		"keywrap_enabled":               basetypes.BoolType{},
		"keywrap_format":                basetypes.StringType{},
		"keywrap_kek":                   basetypes.StringType{},
		"keywrap_mack":                  basetypes.StringType{},
		"port":                          basetypes.StringType{},
		"require_message_authenticator": basetypes.BoolType{},
		"secret":                        basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"host":                          v.Host,
			"keywrap_enabled":               v.KeywrapEnabled,
			"keywrap_format":                v.KeywrapFormat,
			"keywrap_kek":                   v.KeywrapKek,
			"keywrap_mack":                  v.KeywrapMack,
			"port":                          v.Port,
			"require_message_authenticator": v.RequireMessageAuthenticator,
			"secret":                        v.Secret,
		})

	return objVal, diags
}

func (v AuthServersValue) Equal(o attr.Value) bool {
	other, ok := o.(AuthServersValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Host.Equal(other.Host) {
		return false
	}

	if !v.KeywrapEnabled.Equal(other.KeywrapEnabled) {
		return false
	}

	if !v.KeywrapFormat.Equal(other.KeywrapFormat) {
		return false
	}

	if !v.KeywrapKek.Equal(other.KeywrapKek) {
		return false
	}

	if !v.KeywrapMack.Equal(other.KeywrapMack) {
		return false
	}

	if !v.Port.Equal(other.Port) {
		return false
	}

	if !v.RequireMessageAuthenticator.Equal(other.RequireMessageAuthenticator) {
		return false
	}

	if !v.Secret.Equal(other.Secret) {
		return false
	}

	return true
}

func (v AuthServersValue) Type(ctx context.Context) attr.Type {
	return AuthServersType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AuthServersValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"host":                          basetypes.StringType{},
		"keywrap_enabled":               basetypes.BoolType{},
		"keywrap_format":                basetypes.StringType{},
		"keywrap_kek":                   basetypes.StringType{},
		"keywrap_mack":                  basetypes.StringType{},
		"port":                          basetypes.StringType{},
		"require_message_authenticator": basetypes.BoolType{},
		"secret":                        basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = RemoteSyslogType{}

type RemoteSyslogType struct {
	basetypes.ObjectType
}

func (t RemoteSyslogType) Equal(o attr.Type) bool {
	other, ok := o.(RemoteSyslogType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t RemoteSyslogType) String() string {
	return "RemoteSyslogType"
}

func (t RemoteSyslogType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	archiveAttribute, ok := attributes["archive"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`archive is missing from object`)

		return nil, diags
	}

	archiveVal, ok := archiveAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`archive expected to be basetypes.ObjectValue, was: %T`, archiveAttribute))
	}

	cacertsAttribute, ok := attributes["cacerts"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cacerts is missing from object`)

		return nil, diags
	}

	cacertsVal, ok := cacertsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cacerts expected to be basetypes.ListValue, was: %T`, cacertsAttribute))
	}

	consoleAttribute, ok := attributes["console"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`console is missing from object`)

		return nil, diags
	}

	consoleVal, ok := consoleAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`console expected to be basetypes.ObjectValue, was: %T`, consoleAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	filesAttribute, ok := attributes["files"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`files is missing from object`)

		return nil, diags
	}

	filesVal, ok := filesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`files expected to be basetypes.ListValue, was: %T`, filesAttribute))
	}

	networkAttribute, ok := attributes["network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`network is missing from object`)

		return nil, diags
	}

	networkVal, ok := networkAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`network expected to be basetypes.StringValue, was: %T`, networkAttribute))
	}

	sendToAllServersAttribute, ok := attributes["send_to_all_servers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`send_to_all_servers is missing from object`)

		return nil, diags
	}

	sendToAllServersVal, ok := sendToAllServersAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`send_to_all_servers expected to be basetypes.BoolValue, was: %T`, sendToAllServersAttribute))
	}

	serversAttribute, ok := attributes["servers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`servers is missing from object`)

		return nil, diags
	}

	serversVal, ok := serversAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`servers expected to be basetypes.ListValue, was: %T`, serversAttribute))
	}

	timeFormatAttribute, ok := attributes["time_format"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`time_format is missing from object`)

		return nil, diags
	}

	timeFormatVal, ok := timeFormatAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`time_format expected to be basetypes.StringValue, was: %T`, timeFormatAttribute))
	}

	usersAttribute, ok := attributes["users"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`users is missing from object`)

		return nil, diags
	}

	usersVal, ok := usersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`users expected to be basetypes.ListValue, was: %T`, usersAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return RemoteSyslogValue{
		Archive:          archiveVal,
		Cacerts:          cacertsVal,
		Console:          consoleVal,
		Enabled:          enabledVal,
		Files:            filesVal,
		Network:          networkVal,
		SendToAllServers: sendToAllServersVal,
		Servers:          serversVal,
		TimeFormat:       timeFormatVal,
		Users:            usersVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewRemoteSyslogValueNull() RemoteSyslogValue {
	return RemoteSyslogValue{
		state: attr.ValueStateNull,
	}
}

func NewRemoteSyslogValueUnknown() RemoteSyslogValue {
	return RemoteSyslogValue{
		state: attr.ValueStateUnknown,
	}
}

func NewRemoteSyslogValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (RemoteSyslogValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing RemoteSyslogValue Attribute Value",
				"While creating a RemoteSyslogValue value, a missing attribute value was detected. "+
					"A RemoteSyslogValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RemoteSyslogValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid RemoteSyslogValue Attribute Type",
				"While creating a RemoteSyslogValue value, an invalid attribute value was detected. "+
					"A RemoteSyslogValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RemoteSyslogValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("RemoteSyslogValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra RemoteSyslogValue Attribute Value",
				"While creating a RemoteSyslogValue value, an extra attribute value was detected. "+
					"A RemoteSyslogValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra RemoteSyslogValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewRemoteSyslogValueUnknown(), diags
	}

	archiveAttribute, ok := attributes["archive"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`archive is missing from object`)

		return NewRemoteSyslogValueUnknown(), diags
	}

	archiveVal, ok := archiveAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`archive expected to be basetypes.ObjectValue, was: %T`, archiveAttribute))
	}

	cacertsAttribute, ok := attributes["cacerts"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cacerts is missing from object`)

		return NewRemoteSyslogValueUnknown(), diags
	}

	cacertsVal, ok := cacertsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cacerts expected to be basetypes.ListValue, was: %T`, cacertsAttribute))
	}

	consoleAttribute, ok := attributes["console"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`console is missing from object`)

		return NewRemoteSyslogValueUnknown(), diags
	}

	consoleVal, ok := consoleAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`console expected to be basetypes.ObjectValue, was: %T`, consoleAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewRemoteSyslogValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	filesAttribute, ok := attributes["files"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`files is missing from object`)

		return NewRemoteSyslogValueUnknown(), diags
	}

	filesVal, ok := filesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`files expected to be basetypes.ListValue, was: %T`, filesAttribute))
	}

	networkAttribute, ok := attributes["network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`network is missing from object`)

		return NewRemoteSyslogValueUnknown(), diags
	}

	networkVal, ok := networkAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`network expected to be basetypes.StringValue, was: %T`, networkAttribute))
	}

	sendToAllServersAttribute, ok := attributes["send_to_all_servers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`send_to_all_servers is missing from object`)

		return NewRemoteSyslogValueUnknown(), diags
	}

	sendToAllServersVal, ok := sendToAllServersAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`send_to_all_servers expected to be basetypes.BoolValue, was: %T`, sendToAllServersAttribute))
	}

	serversAttribute, ok := attributes["servers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`servers is missing from object`)

		return NewRemoteSyslogValueUnknown(), diags
	}

	serversVal, ok := serversAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`servers expected to be basetypes.ListValue, was: %T`, serversAttribute))
	}

	timeFormatAttribute, ok := attributes["time_format"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`time_format is missing from object`)

		return NewRemoteSyslogValueUnknown(), diags
	}

	timeFormatVal, ok := timeFormatAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`time_format expected to be basetypes.StringValue, was: %T`, timeFormatAttribute))
	}

	usersAttribute, ok := attributes["users"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`users is missing from object`)

		return NewRemoteSyslogValueUnknown(), diags
	}

	usersVal, ok := usersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`users expected to be basetypes.ListValue, was: %T`, usersAttribute))
	}

	if diags.HasError() {
		return NewRemoteSyslogValueUnknown(), diags
	}

	return RemoteSyslogValue{
		Archive:          archiveVal,
		Cacerts:          cacertsVal,
		Console:          consoleVal,
		Enabled:          enabledVal,
		Files:            filesVal,
		Network:          networkVal,
		SendToAllServers: sendToAllServersVal,
		Servers:          serversVal,
		TimeFormat:       timeFormatVal,
		Users:            usersVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewRemoteSyslogValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) RemoteSyslogValue {
	object, diags := NewRemoteSyslogValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewRemoteSyslogValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t RemoteSyslogType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewRemoteSyslogValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewRemoteSyslogValueUnknown(), nil
	}

	if in.IsNull() {
		return NewRemoteSyslogValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewRemoteSyslogValueMust(RemoteSyslogValue{}.AttributeTypes(ctx), attributes), nil
}

func (t RemoteSyslogType) ValueType(ctx context.Context) attr.Value {
	return RemoteSyslogValue{}
}

var _ basetypes.ObjectValuable = RemoteSyslogValue{}

type RemoteSyslogValue struct {
	Archive          basetypes.ObjectValue `tfsdk:"archive"`
	Cacerts          basetypes.ListValue   `tfsdk:"cacerts"`
	Console          basetypes.ObjectValue `tfsdk:"console"`
	Enabled          basetypes.BoolValue   `tfsdk:"enabled"`
	Files            basetypes.ListValue   `tfsdk:"files"`
	Network          basetypes.StringValue `tfsdk:"network"`
	SendToAllServers basetypes.BoolValue   `tfsdk:"send_to_all_servers"`
	Servers          basetypes.ListValue   `tfsdk:"servers"`
	TimeFormat       basetypes.StringValue `tfsdk:"time_format"`
	Users            basetypes.ListValue   `tfsdk:"users"`
	state            attr.ValueState
}

func (v RemoteSyslogValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 10)

	var val tftypes.Value
	var err error

	attrTypes["archive"] = basetypes.ObjectType{
		AttrTypes: ArchiveValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["cacerts"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["console"] = basetypes.ObjectType{
		AttrTypes: ConsoleValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["files"] = basetypes.ListType{
		ElemType: FilesValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["network"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["send_to_all_servers"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["servers"] = basetypes.ListType{
		ElemType: ServersValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["time_format"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["users"] = basetypes.ListType{
		ElemType: UsersValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 10)

		val, err = v.Archive.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["archive"] = val

		val, err = v.Cacerts.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cacerts"] = val

		val, err = v.Console.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["console"] = val

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.Files.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["files"] = val

		val, err = v.Network.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["network"] = val

		val, err = v.SendToAllServers.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["send_to_all_servers"] = val

		val, err = v.Servers.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["servers"] = val

		val, err = v.TimeFormat.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["time_format"] = val

		val, err = v.Users.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["users"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v RemoteSyslogValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v RemoteSyslogValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v RemoteSyslogValue) String() string {
	return "RemoteSyslogValue"
}

func (v RemoteSyslogValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var archive basetypes.ObjectValue

	if v.Archive.IsNull() {
		archive = types.ObjectNull(
			ArchiveValue{}.AttributeTypes(ctx),
		)
	}

	if v.Archive.IsUnknown() {
		archive = types.ObjectUnknown(
			ArchiveValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Archive.IsNull() && !v.Archive.IsUnknown() {
		archive = types.ObjectValueMust(
			ArchiveValue{}.AttributeTypes(ctx),
			v.Archive.Attributes(),
		)
	}

	var console basetypes.ObjectValue

	if v.Console.IsNull() {
		console = types.ObjectNull(
			ConsoleValue{}.AttributeTypes(ctx),
		)
	}

	if v.Console.IsUnknown() {
		console = types.ObjectUnknown(
			ConsoleValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Console.IsNull() && !v.Console.IsUnknown() {
		console = types.ObjectValueMust(
			ConsoleValue{}.AttributeTypes(ctx),
			v.Console.Attributes(),
		)
	}

	files := types.ListValueMust(
		FilesType{
			basetypes.ObjectType{
				AttrTypes: FilesValue{}.AttributeTypes(ctx),
			},
		},
		v.Files.Elements(),
	)

	if v.Files.IsNull() {
		files = types.ListNull(
			FilesType{
				basetypes.ObjectType{
					AttrTypes: FilesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Files.IsUnknown() {
		files = types.ListUnknown(
			FilesType{
				basetypes.ObjectType{
					AttrTypes: FilesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	servers := types.ListValueMust(
		ServersType{
			basetypes.ObjectType{
				AttrTypes: ServersValue{}.AttributeTypes(ctx),
			},
		},
		v.Servers.Elements(),
	)

	if v.Servers.IsNull() {
		servers = types.ListNull(
			ServersType{
				basetypes.ObjectType{
					AttrTypes: ServersValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Servers.IsUnknown() {
		servers = types.ListUnknown(
			ServersType{
				basetypes.ObjectType{
					AttrTypes: ServersValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	users := types.ListValueMust(
		UsersType{
			basetypes.ObjectType{
				AttrTypes: UsersValue{}.AttributeTypes(ctx),
			},
		},
		v.Users.Elements(),
	)

	if v.Users.IsNull() {
		users = types.ListNull(
			UsersType{
				basetypes.ObjectType{
					AttrTypes: UsersValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Users.IsUnknown() {
		users = types.ListUnknown(
			UsersType{
				basetypes.ObjectType{
					AttrTypes: UsersValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var cacertsVal basetypes.ListValue
	switch {
	case v.Cacerts.IsUnknown():
		cacertsVal = types.ListUnknown(types.StringType)
	case v.Cacerts.IsNull():
		cacertsVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		cacertsVal, d = types.ListValue(types.StringType, v.Cacerts.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"archive": basetypes.ObjectType{
				AttrTypes: ArchiveValue{}.AttributeTypes(ctx),
			},
			"cacerts": basetypes.ListType{
				ElemType: types.StringType,
			},
			"console": basetypes.ObjectType{
				AttrTypes: ConsoleValue{}.AttributeTypes(ctx),
			},
			"enabled": basetypes.BoolType{},
			"files": basetypes.ListType{
				ElemType: FilesValue{}.Type(ctx),
			},
			"network":             basetypes.StringType{},
			"send_to_all_servers": basetypes.BoolType{},
			"servers": basetypes.ListType{
				ElemType: ServersValue{}.Type(ctx),
			},
			"time_format": basetypes.StringType{},
			"users": basetypes.ListType{
				ElemType: UsersValue{}.Type(ctx),
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"archive": basetypes.ObjectType{
			AttrTypes: ArchiveValue{}.AttributeTypes(ctx),
		},
		"cacerts": basetypes.ListType{
			ElemType: types.StringType,
		},
		"console": basetypes.ObjectType{
			AttrTypes: ConsoleValue{}.AttributeTypes(ctx),
		},
		"enabled": basetypes.BoolType{},
		"files": basetypes.ListType{
			ElemType: FilesValue{}.Type(ctx),
		},
		"network":             basetypes.StringType{},
		"send_to_all_servers": basetypes.BoolType{},
		"servers": basetypes.ListType{
			ElemType: ServersValue{}.Type(ctx),
		},
		"time_format": basetypes.StringType{},
		"users": basetypes.ListType{
			ElemType: UsersValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"archive":             archive,
			"cacerts":             cacertsVal,
			"console":             console,
			"enabled":             v.Enabled,
			"files":               files,
			"network":             v.Network,
			"send_to_all_servers": v.SendToAllServers,
			"servers":             servers,
			"time_format":         v.TimeFormat,
			"users":               users,
		})

	return objVal, diags
}

func (v RemoteSyslogValue) Equal(o attr.Value) bool {
	other, ok := o.(RemoteSyslogValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Archive.Equal(other.Archive) {
		return false
	}

	if !v.Cacerts.Equal(other.Cacerts) {
		return false
	}

	if !v.Console.Equal(other.Console) {
		return false
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.Files.Equal(other.Files) {
		return false
	}

	if !v.Network.Equal(other.Network) {
		return false
	}

	if !v.SendToAllServers.Equal(other.SendToAllServers) {
		return false
	}

	if !v.Servers.Equal(other.Servers) {
		return false
	}

	if !v.TimeFormat.Equal(other.TimeFormat) {
		return false
	}

	if !v.Users.Equal(other.Users) {
		return false
	}

	return true
}

func (v RemoteSyslogValue) Type(ctx context.Context) attr.Type {
	return RemoteSyslogType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v RemoteSyslogValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"archive": basetypes.ObjectType{
			AttrTypes: ArchiveValue{}.AttributeTypes(ctx),
		},
		"cacerts": basetypes.ListType{
			ElemType: types.StringType,
		},
		"console": basetypes.ObjectType{
			AttrTypes: ConsoleValue{}.AttributeTypes(ctx),
		},
		"enabled": basetypes.BoolType{},
		"files": basetypes.ListType{
			ElemType: FilesValue{}.Type(ctx),
		},
		"network":             basetypes.StringType{},
		"send_to_all_servers": basetypes.BoolType{},
		"servers": basetypes.ListType{
			ElemType: ServersValue{}.Type(ctx),
		},
		"time_format": basetypes.StringType{},
		"users": basetypes.ListType{
			ElemType: UsersValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = ArchiveType{}

type ArchiveType struct {
	basetypes.ObjectType
}

func (t ArchiveType) Equal(o attr.Type) bool {
	other, ok := o.(ArchiveType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ArchiveType) String() string {
	return "ArchiveType"
}

func (t ArchiveType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	filesAttribute, ok := attributes["files"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`files is missing from object`)

		return nil, diags
	}

	filesVal, ok := filesAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`files expected to be basetypes.StringValue, was: %T`, filesAttribute))
	}

	sizeAttribute, ok := attributes["size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`size is missing from object`)

		return nil, diags
	}

	sizeVal, ok := sizeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`size expected to be basetypes.StringValue, was: %T`, sizeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ArchiveValue{
		Files: filesVal,
		Size:  sizeVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewArchiveValueNull() ArchiveValue {
	return ArchiveValue{
		state: attr.ValueStateNull,
	}
}

func NewArchiveValueUnknown() ArchiveValue {
	return ArchiveValue{
		state: attr.ValueStateUnknown,
	}
}

func NewArchiveValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ArchiveValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ArchiveValue Attribute Value",
				"While creating a ArchiveValue value, a missing attribute value was detected. "+
					"A ArchiveValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ArchiveValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ArchiveValue Attribute Type",
				"While creating a ArchiveValue value, an invalid attribute value was detected. "+
					"A ArchiveValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ArchiveValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ArchiveValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ArchiveValue Attribute Value",
				"While creating a ArchiveValue value, an extra attribute value was detected. "+
					"A ArchiveValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ArchiveValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewArchiveValueUnknown(), diags
	}

	filesAttribute, ok := attributes["files"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`files is missing from object`)

		return NewArchiveValueUnknown(), diags
	}

	filesVal, ok := filesAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`files expected to be basetypes.StringValue, was: %T`, filesAttribute))
	}

	sizeAttribute, ok := attributes["size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`size is missing from object`)

		return NewArchiveValueUnknown(), diags
	}

	sizeVal, ok := sizeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`size expected to be basetypes.StringValue, was: %T`, sizeAttribute))
	}

	if diags.HasError() {
		return NewArchiveValueUnknown(), diags
	}

	return ArchiveValue{
		Files: filesVal,
		Size:  sizeVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewArchiveValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ArchiveValue {
	object, diags := NewArchiveValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewArchiveValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ArchiveType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewArchiveValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewArchiveValueUnknown(), nil
	}

	if in.IsNull() {
		return NewArchiveValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewArchiveValueMust(ArchiveValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ArchiveType) ValueType(ctx context.Context) attr.Value {
	return ArchiveValue{}
}

var _ basetypes.ObjectValuable = ArchiveValue{}

type ArchiveValue struct {
	Files basetypes.StringValue `tfsdk:"files"`
	Size  basetypes.StringValue `tfsdk:"size"`
	state attr.ValueState
}

func (v ArchiveValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["files"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["size"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Files.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["files"] = val

		val, err = v.Size.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["size"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ArchiveValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ArchiveValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ArchiveValue) String() string {
	return "ArchiveValue"
}

func (v ArchiveValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"files": basetypes.StringType{},
		"size":  basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"files": v.Files,
			"size":  v.Size,
		})

	return objVal, diags
}

func (v ArchiveValue) Equal(o attr.Value) bool {
	other, ok := o.(ArchiveValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Files.Equal(other.Files) {
		return false
	}

	if !v.Size.Equal(other.Size) {
		return false
	}

	return true
}

func (v ArchiveValue) Type(ctx context.Context) attr.Type {
	return ArchiveType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ArchiveValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"files": basetypes.StringType{},
		"size":  basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = ConsoleType{}

type ConsoleType struct {
	basetypes.ObjectType
}

func (t ConsoleType) Equal(o attr.Type) bool {
	other, ok := o.(ConsoleType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ConsoleType) String() string {
	return "ConsoleType"
}

func (t ConsoleType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	contentsAttribute, ok := attributes["contents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`contents is missing from object`)

		return nil, diags
	}

	contentsVal, ok := contentsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`contents expected to be basetypes.ListValue, was: %T`, contentsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ConsoleValue{
		Contents: contentsVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewConsoleValueNull() ConsoleValue {
	return ConsoleValue{
		state: attr.ValueStateNull,
	}
}

func NewConsoleValueUnknown() ConsoleValue {
	return ConsoleValue{
		state: attr.ValueStateUnknown,
	}
}

func NewConsoleValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ConsoleValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ConsoleValue Attribute Value",
				"While creating a ConsoleValue value, a missing attribute value was detected. "+
					"A ConsoleValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ConsoleValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ConsoleValue Attribute Type",
				"While creating a ConsoleValue value, an invalid attribute value was detected. "+
					"A ConsoleValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ConsoleValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ConsoleValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ConsoleValue Attribute Value",
				"While creating a ConsoleValue value, an extra attribute value was detected. "+
					"A ConsoleValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ConsoleValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewConsoleValueUnknown(), diags
	}

	contentsAttribute, ok := attributes["contents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`contents is missing from object`)

		return NewConsoleValueUnknown(), diags
	}

	contentsVal, ok := contentsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`contents expected to be basetypes.ListValue, was: %T`, contentsAttribute))
	}

	if diags.HasError() {
		return NewConsoleValueUnknown(), diags
	}

	return ConsoleValue{
		Contents: contentsVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewConsoleValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ConsoleValue {
	object, diags := NewConsoleValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewConsoleValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ConsoleType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewConsoleValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewConsoleValueUnknown(), nil
	}

	if in.IsNull() {
		return NewConsoleValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewConsoleValueMust(ConsoleValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ConsoleType) ValueType(ctx context.Context) attr.Value {
	return ConsoleValue{}
}

var _ basetypes.ObjectValuable = ConsoleValue{}

type ConsoleValue struct {
	Contents basetypes.ListValue `tfsdk:"contents"`
	state    attr.ValueState
}

func (v ConsoleValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["contents"] = basetypes.ListType{
		ElemType: ContentsValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Contents.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["contents"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ConsoleValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ConsoleValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ConsoleValue) String() string {
	return "ConsoleValue"
}

func (v ConsoleValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	contents := types.ListValueMust(
		ContentsType{
			basetypes.ObjectType{
				AttrTypes: ContentsValue{}.AttributeTypes(ctx),
			},
		},
		v.Contents.Elements(),
	)

	if v.Contents.IsNull() {
		contents = types.ListNull(
			ContentsType{
				basetypes.ObjectType{
					AttrTypes: ContentsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Contents.IsUnknown() {
		contents = types.ListUnknown(
			ContentsType{
				basetypes.ObjectType{
					AttrTypes: ContentsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"contents": basetypes.ListType{
			ElemType: ContentsValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"contents": contents,
		})

	return objVal, diags
}

func (v ConsoleValue) Equal(o attr.Value) bool {
	other, ok := o.(ConsoleValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Contents.Equal(other.Contents) {
		return false
	}

	return true
}

func (v ConsoleValue) Type(ctx context.Context) attr.Type {
	return ConsoleType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ConsoleValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"contents": basetypes.ListType{
			ElemType: ContentsValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = ContentsType{}

type ContentsType struct {
	basetypes.ObjectType
}

func (t ContentsType) Equal(o attr.Type) bool {
	other, ok := o.(ContentsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ContentsType) String() string {
	return "ContentsType"
}

func (t ContentsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	facilityAttribute, ok := attributes["facility"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`facility is missing from object`)

		return nil, diags
	}

	facilityVal, ok := facilityAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`facility expected to be basetypes.StringValue, was: %T`, facilityAttribute))
	}

	severityAttribute, ok := attributes["severity"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`severity is missing from object`)

		return nil, diags
	}

	severityVal, ok := severityAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`severity expected to be basetypes.StringValue, was: %T`, severityAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ContentsValue{
		Facility: facilityVal,
		Severity: severityVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewContentsValueNull() ContentsValue {
	return ContentsValue{
		state: attr.ValueStateNull,
	}
}

func NewContentsValueUnknown() ContentsValue {
	return ContentsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewContentsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ContentsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ContentsValue Attribute Value",
				"While creating a ContentsValue value, a missing attribute value was detected. "+
					"A ContentsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ContentsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ContentsValue Attribute Type",
				"While creating a ContentsValue value, an invalid attribute value was detected. "+
					"A ContentsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ContentsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ContentsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ContentsValue Attribute Value",
				"While creating a ContentsValue value, an extra attribute value was detected. "+
					"A ContentsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ContentsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewContentsValueUnknown(), diags
	}

	facilityAttribute, ok := attributes["facility"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`facility is missing from object`)

		return NewContentsValueUnknown(), diags
	}

	facilityVal, ok := facilityAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`facility expected to be basetypes.StringValue, was: %T`, facilityAttribute))
	}

	severityAttribute, ok := attributes["severity"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`severity is missing from object`)

		return NewContentsValueUnknown(), diags
	}

	severityVal, ok := severityAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`severity expected to be basetypes.StringValue, was: %T`, severityAttribute))
	}

	if diags.HasError() {
		return NewContentsValueUnknown(), diags
	}

	return ContentsValue{
		Facility: facilityVal,
		Severity: severityVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewContentsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ContentsValue {
	object, diags := NewContentsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewContentsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ContentsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewContentsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewContentsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewContentsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewContentsValueMust(ContentsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ContentsType) ValueType(ctx context.Context) attr.Value {
	return ContentsValue{}
}

var _ basetypes.ObjectValuable = ContentsValue{}

type ContentsValue struct {
	Facility basetypes.StringValue `tfsdk:"facility"`
	Severity basetypes.StringValue `tfsdk:"severity"`
	state    attr.ValueState
}

func (v ContentsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["facility"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["severity"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Facility.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["facility"] = val

		val, err = v.Severity.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["severity"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ContentsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ContentsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ContentsValue) String() string {
	return "ContentsValue"
}

func (v ContentsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"facility": basetypes.StringType{},
		"severity": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"facility": v.Facility,
			"severity": v.Severity,
		})

	return objVal, diags
}

func (v ContentsValue) Equal(o attr.Value) bool {
	other, ok := o.(ContentsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Facility.Equal(other.Facility) {
		return false
	}

	if !v.Severity.Equal(other.Severity) {
		return false
	}

	return true
}

func (v ContentsValue) Type(ctx context.Context) attr.Type {
	return ContentsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ContentsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"facility": basetypes.StringType{},
		"severity": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = FilesType{}

type FilesType struct {
	basetypes.ObjectType
}

func (t FilesType) Equal(o attr.Type) bool {
	other, ok := o.(FilesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t FilesType) String() string {
	return "FilesType"
}

func (t FilesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	archiveAttribute, ok := attributes["archive"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`archive is missing from object`)

		return nil, diags
	}

	archiveVal, ok := archiveAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`archive expected to be basetypes.ObjectValue, was: %T`, archiveAttribute))
	}

	contentsAttribute, ok := attributes["contents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`contents is missing from object`)

		return nil, diags
	}

	contentsVal, ok := contentsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`contents expected to be basetypes.ListValue, was: %T`, contentsAttribute))
	}

	enableTlsAttribute, ok := attributes["enable_tls"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable_tls is missing from object`)

		return nil, diags
	}

	enableTlsVal, ok := enableTlsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable_tls expected to be basetypes.BoolValue, was: %T`, enableTlsAttribute))
	}

	explicitPriorityAttribute, ok := attributes["explicit_priority"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`explicit_priority is missing from object`)

		return nil, diags
	}

	explicitPriorityVal, ok := explicitPriorityAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`explicit_priority expected to be basetypes.BoolValue, was: %T`, explicitPriorityAttribute))
	}

	fileAttribute, ok := attributes["file"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`file is missing from object`)

		return nil, diags
	}

	fileVal, ok := fileAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`file expected to be basetypes.StringValue, was: %T`, fileAttribute))
	}

	matchAttribute, ok := attributes["match"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`match is missing from object`)

		return nil, diags
	}

	matchVal, ok := matchAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`match expected to be basetypes.StringValue, was: %T`, matchAttribute))
	}

	structuredDataAttribute, ok := attributes["structured_data"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`structured_data is missing from object`)

		return nil, diags
	}

	structuredDataVal, ok := structuredDataAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`structured_data expected to be basetypes.BoolValue, was: %T`, structuredDataAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return FilesValue{
		Archive:          archiveVal,
		Contents:         contentsVal,
		EnableTls:        enableTlsVal,
		ExplicitPriority: explicitPriorityVal,
		File:             fileVal,
		Match:            matchVal,
		StructuredData:   structuredDataVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewFilesValueNull() FilesValue {
	return FilesValue{
		state: attr.ValueStateNull,
	}
}

func NewFilesValueUnknown() FilesValue {
	return FilesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewFilesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (FilesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing FilesValue Attribute Value",
				"While creating a FilesValue value, a missing attribute value was detected. "+
					"A FilesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("FilesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid FilesValue Attribute Type",
				"While creating a FilesValue value, an invalid attribute value was detected. "+
					"A FilesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("FilesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("FilesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra FilesValue Attribute Value",
				"While creating a FilesValue value, an extra attribute value was detected. "+
					"A FilesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra FilesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewFilesValueUnknown(), diags
	}

	archiveAttribute, ok := attributes["archive"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`archive is missing from object`)

		return NewFilesValueUnknown(), diags
	}

	archiveVal, ok := archiveAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`archive expected to be basetypes.ObjectValue, was: %T`, archiveAttribute))
	}

	contentsAttribute, ok := attributes["contents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`contents is missing from object`)

		return NewFilesValueUnknown(), diags
	}

	contentsVal, ok := contentsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`contents expected to be basetypes.ListValue, was: %T`, contentsAttribute))
	}

	enableTlsAttribute, ok := attributes["enable_tls"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable_tls is missing from object`)

		return NewFilesValueUnknown(), diags
	}

	enableTlsVal, ok := enableTlsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable_tls expected to be basetypes.BoolValue, was: %T`, enableTlsAttribute))
	}

	explicitPriorityAttribute, ok := attributes["explicit_priority"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`explicit_priority is missing from object`)

		return NewFilesValueUnknown(), diags
	}

	explicitPriorityVal, ok := explicitPriorityAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`explicit_priority expected to be basetypes.BoolValue, was: %T`, explicitPriorityAttribute))
	}

	fileAttribute, ok := attributes["file"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`file is missing from object`)

		return NewFilesValueUnknown(), diags
	}

	fileVal, ok := fileAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`file expected to be basetypes.StringValue, was: %T`, fileAttribute))
	}

	matchAttribute, ok := attributes["match"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`match is missing from object`)

		return NewFilesValueUnknown(), diags
	}

	matchVal, ok := matchAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`match expected to be basetypes.StringValue, was: %T`, matchAttribute))
	}

	structuredDataAttribute, ok := attributes["structured_data"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`structured_data is missing from object`)

		return NewFilesValueUnknown(), diags
	}

	structuredDataVal, ok := structuredDataAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`structured_data expected to be basetypes.BoolValue, was: %T`, structuredDataAttribute))
	}

	if diags.HasError() {
		return NewFilesValueUnknown(), diags
	}

	return FilesValue{
		Archive:          archiveVal,
		Contents:         contentsVal,
		EnableTls:        enableTlsVal,
		ExplicitPriority: explicitPriorityVal,
		File:             fileVal,
		Match:            matchVal,
		StructuredData:   structuredDataVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewFilesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) FilesValue {
	object, diags := NewFilesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewFilesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t FilesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewFilesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewFilesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewFilesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewFilesValueMust(FilesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t FilesType) ValueType(ctx context.Context) attr.Value {
	return FilesValue{}
}

var _ basetypes.ObjectValuable = FilesValue{}

type FilesValue struct {
	Archive          basetypes.ObjectValue `tfsdk:"archive"`
	Contents         basetypes.ListValue   `tfsdk:"contents"`
	EnableTls        basetypes.BoolValue   `tfsdk:"enable_tls"`
	ExplicitPriority basetypes.BoolValue   `tfsdk:"explicit_priority"`
	File             basetypes.StringValue `tfsdk:"file"`
	Match            basetypes.StringValue `tfsdk:"match"`
	StructuredData   basetypes.BoolValue   `tfsdk:"structured_data"`
	state            attr.ValueState
}

func (v FilesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 7)

	var val tftypes.Value
	var err error

	attrTypes["archive"] = basetypes.ObjectType{
		AttrTypes: ArchiveValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["contents"] = basetypes.ListType{
		ElemType: ContentsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["enable_tls"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["explicit_priority"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["file"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["match"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["structured_data"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 7)

		val, err = v.Archive.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["archive"] = val

		val, err = v.Contents.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["contents"] = val

		val, err = v.EnableTls.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enable_tls"] = val

		val, err = v.ExplicitPriority.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["explicit_priority"] = val

		val, err = v.File.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["file"] = val

		val, err = v.Match.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["match"] = val

		val, err = v.StructuredData.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["structured_data"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v FilesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v FilesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v FilesValue) String() string {
	return "FilesValue"
}

func (v FilesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var archive basetypes.ObjectValue

	if v.Archive.IsNull() {
		archive = types.ObjectNull(
			ArchiveValue{}.AttributeTypes(ctx),
		)
	}

	if v.Archive.IsUnknown() {
		archive = types.ObjectUnknown(
			ArchiveValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Archive.IsNull() && !v.Archive.IsUnknown() {
		archive = types.ObjectValueMust(
			ArchiveValue{}.AttributeTypes(ctx),
			v.Archive.Attributes(),
		)
	}

	contents := types.ListValueMust(
		ContentsType{
			basetypes.ObjectType{
				AttrTypes: ContentsValue{}.AttributeTypes(ctx),
			},
		},
		v.Contents.Elements(),
	)

	if v.Contents.IsNull() {
		contents = types.ListNull(
			ContentsType{
				basetypes.ObjectType{
					AttrTypes: ContentsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Contents.IsUnknown() {
		contents = types.ListUnknown(
			ContentsType{
				basetypes.ObjectType{
					AttrTypes: ContentsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"archive": basetypes.ObjectType{
			AttrTypes: ArchiveValue{}.AttributeTypes(ctx),
		},
		"contents": basetypes.ListType{
			ElemType: ContentsValue{}.Type(ctx),
		},
		"enable_tls":        basetypes.BoolType{},
		"explicit_priority": basetypes.BoolType{},
		"file":              basetypes.StringType{},
		"match":             basetypes.StringType{},
		"structured_data":   basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"archive":           archive,
			"contents":          contents,
			"enable_tls":        v.EnableTls,
			"explicit_priority": v.ExplicitPriority,
			"file":              v.File,
			"match":             v.Match,
			"structured_data":   v.StructuredData,
		})

	return objVal, diags
}

func (v FilesValue) Equal(o attr.Value) bool {
	other, ok := o.(FilesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Archive.Equal(other.Archive) {
		return false
	}

	if !v.Contents.Equal(other.Contents) {
		return false
	}

	if !v.EnableTls.Equal(other.EnableTls) {
		return false
	}

	if !v.ExplicitPriority.Equal(other.ExplicitPriority) {
		return false
	}

	if !v.File.Equal(other.File) {
		return false
	}

	if !v.Match.Equal(other.Match) {
		return false
	}

	if !v.StructuredData.Equal(other.StructuredData) {
		return false
	}

	return true
}

func (v FilesValue) Type(ctx context.Context) attr.Type {
	return FilesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v FilesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"archive": basetypes.ObjectType{
			AttrTypes: ArchiveValue{}.AttributeTypes(ctx),
		},
		"contents": basetypes.ListType{
			ElemType: ContentsValue{}.Type(ctx),
		},
		"enable_tls":        basetypes.BoolType{},
		"explicit_priority": basetypes.BoolType{},
		"file":              basetypes.StringType{},
		"match":             basetypes.StringType{},
		"structured_data":   basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = ServersType{}

type ServersType struct {
	basetypes.ObjectType
}

func (t ServersType) Equal(o attr.Type) bool {
	other, ok := o.(ServersType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ServersType) String() string {
	return "ServersType"
}

func (t ServersType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	contentsAttribute, ok := attributes["contents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`contents is missing from object`)

		return nil, diags
	}

	contentsVal, ok := contentsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`contents expected to be basetypes.ListValue, was: %T`, contentsAttribute))
	}

	explicitPriorityAttribute, ok := attributes["explicit_priority"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`explicit_priority is missing from object`)

		return nil, diags
	}

	explicitPriorityVal, ok := explicitPriorityAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`explicit_priority expected to be basetypes.BoolValue, was: %T`, explicitPriorityAttribute))
	}

	facilityAttribute, ok := attributes["facility"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`facility is missing from object`)

		return nil, diags
	}

	facilityVal, ok := facilityAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`facility expected to be basetypes.StringValue, was: %T`, facilityAttribute))
	}

	hostAttribute, ok := attributes["host"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`host is missing from object`)

		return nil, diags
	}

	hostVal, ok := hostAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`host expected to be basetypes.StringValue, was: %T`, hostAttribute))
	}

	matchAttribute, ok := attributes["match"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`match is missing from object`)

		return nil, diags
	}

	matchVal, ok := matchAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`match expected to be basetypes.StringValue, was: %T`, matchAttribute))
	}

	portAttribute, ok := attributes["port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port is missing from object`)

		return nil, diags
	}

	portVal, ok := portAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port expected to be basetypes.StringValue, was: %T`, portAttribute))
	}

	protocolAttribute, ok := attributes["protocol"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`protocol is missing from object`)

		return nil, diags
	}

	protocolVal, ok := protocolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`protocol expected to be basetypes.StringValue, was: %T`, protocolAttribute))
	}

	routingInstanceAttribute, ok := attributes["routing_instance"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`routing_instance is missing from object`)

		return nil, diags
	}

	routingInstanceVal, ok := routingInstanceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`routing_instance expected to be basetypes.StringValue, was: %T`, routingInstanceAttribute))
	}

	serverNameAttribute, ok := attributes["server_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`server_name is missing from object`)

		return nil, diags
	}

	serverNameVal, ok := serverNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`server_name expected to be basetypes.StringValue, was: %T`, serverNameAttribute))
	}

	severityAttribute, ok := attributes["severity"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`severity is missing from object`)

		return nil, diags
	}

	severityVal, ok := severityAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`severity expected to be basetypes.StringValue, was: %T`, severityAttribute))
	}

	sourceAddressAttribute, ok := attributes["source_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`source_address is missing from object`)

		return nil, diags
	}

	sourceAddressVal, ok := sourceAddressAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`source_address expected to be basetypes.StringValue, was: %T`, sourceAddressAttribute))
	}

	structuredDataAttribute, ok := attributes["structured_data"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`structured_data is missing from object`)

		return nil, diags
	}

	structuredDataVal, ok := structuredDataAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`structured_data expected to be basetypes.BoolValue, was: %T`, structuredDataAttribute))
	}

	tagAttribute, ok := attributes["tag"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tag is missing from object`)

		return nil, diags
	}

	tagVal, ok := tagAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tag expected to be basetypes.StringValue, was: %T`, tagAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ServersValue{
		Contents:         contentsVal,
		ExplicitPriority: explicitPriorityVal,
		Facility:         facilityVal,
		Host:             hostVal,
		Match:            matchVal,
		Port:             portVal,
		Protocol:         protocolVal,
		RoutingInstance:  routingInstanceVal,
		ServerName:       serverNameVal,
		Severity:         severityVal,
		SourceAddress:    sourceAddressVal,
		StructuredData:   structuredDataVal,
		Tag:              tagVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewServersValueNull() ServersValue {
	return ServersValue{
		state: attr.ValueStateNull,
	}
}

func NewServersValueUnknown() ServersValue {
	return ServersValue{
		state: attr.ValueStateUnknown,
	}
}

func NewServersValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ServersValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ServersValue Attribute Value",
				"While creating a ServersValue value, a missing attribute value was detected. "+
					"A ServersValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ServersValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ServersValue Attribute Type",
				"While creating a ServersValue value, an invalid attribute value was detected. "+
					"A ServersValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ServersValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ServersValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ServersValue Attribute Value",
				"While creating a ServersValue value, an extra attribute value was detected. "+
					"A ServersValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ServersValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewServersValueUnknown(), diags
	}

	contentsAttribute, ok := attributes["contents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`contents is missing from object`)

		return NewServersValueUnknown(), diags
	}

	contentsVal, ok := contentsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`contents expected to be basetypes.ListValue, was: %T`, contentsAttribute))
	}

	explicitPriorityAttribute, ok := attributes["explicit_priority"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`explicit_priority is missing from object`)

		return NewServersValueUnknown(), diags
	}

	explicitPriorityVal, ok := explicitPriorityAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`explicit_priority expected to be basetypes.BoolValue, was: %T`, explicitPriorityAttribute))
	}

	facilityAttribute, ok := attributes["facility"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`facility is missing from object`)

		return NewServersValueUnknown(), diags
	}

	facilityVal, ok := facilityAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`facility expected to be basetypes.StringValue, was: %T`, facilityAttribute))
	}

	hostAttribute, ok := attributes["host"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`host is missing from object`)

		return NewServersValueUnknown(), diags
	}

	hostVal, ok := hostAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`host expected to be basetypes.StringValue, was: %T`, hostAttribute))
	}

	matchAttribute, ok := attributes["match"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`match is missing from object`)

		return NewServersValueUnknown(), diags
	}

	matchVal, ok := matchAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`match expected to be basetypes.StringValue, was: %T`, matchAttribute))
	}

	portAttribute, ok := attributes["port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port is missing from object`)

		return NewServersValueUnknown(), diags
	}

	portVal, ok := portAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port expected to be basetypes.StringValue, was: %T`, portAttribute))
	}

	protocolAttribute, ok := attributes["protocol"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`protocol is missing from object`)

		return NewServersValueUnknown(), diags
	}

	protocolVal, ok := protocolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`protocol expected to be basetypes.StringValue, was: %T`, protocolAttribute))
	}

	routingInstanceAttribute, ok := attributes["routing_instance"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`routing_instance is missing from object`)

		return NewServersValueUnknown(), diags
	}

	routingInstanceVal, ok := routingInstanceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`routing_instance expected to be basetypes.StringValue, was: %T`, routingInstanceAttribute))
	}

	serverNameAttribute, ok := attributes["server_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`server_name is missing from object`)

		return NewServersValueUnknown(), diags
	}

	serverNameVal, ok := serverNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`server_name expected to be basetypes.StringValue, was: %T`, serverNameAttribute))
	}

	severityAttribute, ok := attributes["severity"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`severity is missing from object`)

		return NewServersValueUnknown(), diags
	}

	severityVal, ok := severityAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`severity expected to be basetypes.StringValue, was: %T`, severityAttribute))
	}

	sourceAddressAttribute, ok := attributes["source_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`source_address is missing from object`)

		return NewServersValueUnknown(), diags
	}

	sourceAddressVal, ok := sourceAddressAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`source_address expected to be basetypes.StringValue, was: %T`, sourceAddressAttribute))
	}

	structuredDataAttribute, ok := attributes["structured_data"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`structured_data is missing from object`)

		return NewServersValueUnknown(), diags
	}

	structuredDataVal, ok := structuredDataAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`structured_data expected to be basetypes.BoolValue, was: %T`, structuredDataAttribute))
	}

	tagAttribute, ok := attributes["tag"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tag is missing from object`)

		return NewServersValueUnknown(), diags
	}

	tagVal, ok := tagAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tag expected to be basetypes.StringValue, was: %T`, tagAttribute))
	}

	if diags.HasError() {
		return NewServersValueUnknown(), diags
	}

	return ServersValue{
		Contents:         contentsVal,
		ExplicitPriority: explicitPriorityVal,
		Facility:         facilityVal,
		Host:             hostVal,
		Match:            matchVal,
		Port:             portVal,
		Protocol:         protocolVal,
		RoutingInstance:  routingInstanceVal,
		ServerName:       serverNameVal,
		Severity:         severityVal,
		SourceAddress:    sourceAddressVal,
		StructuredData:   structuredDataVal,
		Tag:              tagVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewServersValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ServersValue {
	object, diags := NewServersValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewServersValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ServersType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewServersValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewServersValueUnknown(), nil
	}

	if in.IsNull() {
		return NewServersValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewServersValueMust(ServersValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ServersType) ValueType(ctx context.Context) attr.Value {
	return ServersValue{}
}

var _ basetypes.ObjectValuable = ServersValue{}

type ServersValue struct {
	Contents         basetypes.ListValue   `tfsdk:"contents"`
	ExplicitPriority basetypes.BoolValue   `tfsdk:"explicit_priority"`
	Facility         basetypes.StringValue `tfsdk:"facility"`
	Host             basetypes.StringValue `tfsdk:"host"`
	Match            basetypes.StringValue `tfsdk:"match"`
	Port             basetypes.StringValue `tfsdk:"port"`
	Protocol         basetypes.StringValue `tfsdk:"protocol"`
	RoutingInstance  basetypes.StringValue `tfsdk:"routing_instance"`
	ServerName       basetypes.StringValue `tfsdk:"server_name"`
	Severity         basetypes.StringValue `tfsdk:"severity"`
	SourceAddress    basetypes.StringValue `tfsdk:"source_address"`
	StructuredData   basetypes.BoolValue   `tfsdk:"structured_data"`
	Tag              basetypes.StringValue `tfsdk:"tag"`
	state            attr.ValueState
}

func (v ServersValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 13)

	var val tftypes.Value
	var err error

	attrTypes["contents"] = basetypes.ListType{
		ElemType: ContentsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["explicit_priority"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["facility"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["host"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["match"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["port"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["protocol"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["routing_instance"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["server_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["severity"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["source_address"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["structured_data"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["tag"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 13)

		val, err = v.Contents.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["contents"] = val

		val, err = v.ExplicitPriority.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["explicit_priority"] = val

		val, err = v.Facility.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["facility"] = val

		val, err = v.Host.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["host"] = val

		val, err = v.Match.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["match"] = val

		val, err = v.Port.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port"] = val

		val, err = v.Protocol.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["protocol"] = val

		val, err = v.RoutingInstance.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["routing_instance"] = val

		val, err = v.ServerName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["server_name"] = val

		val, err = v.Severity.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["severity"] = val

		val, err = v.SourceAddress.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["source_address"] = val

		val, err = v.StructuredData.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["structured_data"] = val

		val, err = v.Tag.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tag"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ServersValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ServersValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ServersValue) String() string {
	return "ServersValue"
}

func (v ServersValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	contents := types.ListValueMust(
		ContentsType{
			basetypes.ObjectType{
				AttrTypes: ContentsValue{}.AttributeTypes(ctx),
			},
		},
		v.Contents.Elements(),
	)

	if v.Contents.IsNull() {
		contents = types.ListNull(
			ContentsType{
				basetypes.ObjectType{
					AttrTypes: ContentsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Contents.IsUnknown() {
		contents = types.ListUnknown(
			ContentsType{
				basetypes.ObjectType{
					AttrTypes: ContentsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"contents": basetypes.ListType{
			ElemType: ContentsValue{}.Type(ctx),
		},
		"explicit_priority": basetypes.BoolType{},
		"facility":          basetypes.StringType{},
		"host":              basetypes.StringType{},
		"match":             basetypes.StringType{},
		"port":              basetypes.StringType{},
		"protocol":          basetypes.StringType{},
		"routing_instance":  basetypes.StringType{},
		"server_name":       basetypes.StringType{},
		"severity":          basetypes.StringType{},
		"source_address":    basetypes.StringType{},
		"structured_data":   basetypes.BoolType{},
		"tag":               basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"contents":          contents,
			"explicit_priority": v.ExplicitPriority,
			"facility":          v.Facility,
			"host":              v.Host,
			"match":             v.Match,
			"port":              v.Port,
			"protocol":          v.Protocol,
			"routing_instance":  v.RoutingInstance,
			"server_name":       v.ServerName,
			"severity":          v.Severity,
			"source_address":    v.SourceAddress,
			"structured_data":   v.StructuredData,
			"tag":               v.Tag,
		})

	return objVal, diags
}

func (v ServersValue) Equal(o attr.Value) bool {
	other, ok := o.(ServersValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Contents.Equal(other.Contents) {
		return false
	}

	if !v.ExplicitPriority.Equal(other.ExplicitPriority) {
		return false
	}

	if !v.Facility.Equal(other.Facility) {
		return false
	}

	if !v.Host.Equal(other.Host) {
		return false
	}

	if !v.Match.Equal(other.Match) {
		return false
	}

	if !v.Port.Equal(other.Port) {
		return false
	}

	if !v.Protocol.Equal(other.Protocol) {
		return false
	}

	if !v.RoutingInstance.Equal(other.RoutingInstance) {
		return false
	}

	if !v.ServerName.Equal(other.ServerName) {
		return false
	}

	if !v.Severity.Equal(other.Severity) {
		return false
	}

	if !v.SourceAddress.Equal(other.SourceAddress) {
		return false
	}

	if !v.StructuredData.Equal(other.StructuredData) {
		return false
	}

	if !v.Tag.Equal(other.Tag) {
		return false
	}

	return true
}

func (v ServersValue) Type(ctx context.Context) attr.Type {
	return ServersType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ServersValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"contents": basetypes.ListType{
			ElemType: ContentsValue{}.Type(ctx),
		},
		"explicit_priority": basetypes.BoolType{},
		"facility":          basetypes.StringType{},
		"host":              basetypes.StringType{},
		"match":             basetypes.StringType{},
		"port":              basetypes.StringType{},
		"protocol":          basetypes.StringType{},
		"routing_instance":  basetypes.StringType{},
		"server_name":       basetypes.StringType{},
		"severity":          basetypes.StringType{},
		"source_address":    basetypes.StringType{},
		"structured_data":   basetypes.BoolType{},
		"tag":               basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = UsersType{}

type UsersType struct {
	basetypes.ObjectType
}

func (t UsersType) Equal(o attr.Type) bool {
	other, ok := o.(UsersType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t UsersType) String() string {
	return "UsersType"
}

func (t UsersType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	contentsAttribute, ok := attributes["contents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`contents is missing from object`)

		return nil, diags
	}

	contentsVal, ok := contentsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`contents expected to be basetypes.ListValue, was: %T`, contentsAttribute))
	}

	matchAttribute, ok := attributes["match"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`match is missing from object`)

		return nil, diags
	}

	matchVal, ok := matchAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`match expected to be basetypes.StringValue, was: %T`, matchAttribute))
	}

	userAttribute, ok := attributes["user"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`user is missing from object`)

		return nil, diags
	}

	userVal, ok := userAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`user expected to be basetypes.StringValue, was: %T`, userAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return UsersValue{
		Contents: contentsVal,
		Match:    matchVal,
		User:     userVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewUsersValueNull() UsersValue {
	return UsersValue{
		state: attr.ValueStateNull,
	}
}

func NewUsersValueUnknown() UsersValue {
	return UsersValue{
		state: attr.ValueStateUnknown,
	}
}

func NewUsersValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (UsersValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing UsersValue Attribute Value",
				"While creating a UsersValue value, a missing attribute value was detected. "+
					"A UsersValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("UsersValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid UsersValue Attribute Type",
				"While creating a UsersValue value, an invalid attribute value was detected. "+
					"A UsersValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("UsersValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("UsersValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra UsersValue Attribute Value",
				"While creating a UsersValue value, an extra attribute value was detected. "+
					"A UsersValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra UsersValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewUsersValueUnknown(), diags
	}

	contentsAttribute, ok := attributes["contents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`contents is missing from object`)

		return NewUsersValueUnknown(), diags
	}

	contentsVal, ok := contentsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`contents expected to be basetypes.ListValue, was: %T`, contentsAttribute))
	}

	matchAttribute, ok := attributes["match"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`match is missing from object`)

		return NewUsersValueUnknown(), diags
	}

	matchVal, ok := matchAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`match expected to be basetypes.StringValue, was: %T`, matchAttribute))
	}

	userAttribute, ok := attributes["user"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`user is missing from object`)

		return NewUsersValueUnknown(), diags
	}

	userVal, ok := userAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`user expected to be basetypes.StringValue, was: %T`, userAttribute))
	}

	if diags.HasError() {
		return NewUsersValueUnknown(), diags
	}

	return UsersValue{
		Contents: contentsVal,
		Match:    matchVal,
		User:     userVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewUsersValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) UsersValue {
	object, diags := NewUsersValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewUsersValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t UsersType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewUsersValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewUsersValueUnknown(), nil
	}

	if in.IsNull() {
		return NewUsersValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewUsersValueMust(UsersValue{}.AttributeTypes(ctx), attributes), nil
}

func (t UsersType) ValueType(ctx context.Context) attr.Value {
	return UsersValue{}
}

var _ basetypes.ObjectValuable = UsersValue{}

type UsersValue struct {
	Contents basetypes.ListValue   `tfsdk:"contents"`
	Match    basetypes.StringValue `tfsdk:"match"`
	User     basetypes.StringValue `tfsdk:"user"`
	state    attr.ValueState
}

func (v UsersValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["contents"] = basetypes.ListType{
		ElemType: ContentsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["match"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["user"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Contents.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["contents"] = val

		val, err = v.Match.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["match"] = val

		val, err = v.User.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["user"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v UsersValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v UsersValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v UsersValue) String() string {
	return "UsersValue"
}

func (v UsersValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	contents := types.ListValueMust(
		ContentsType{
			basetypes.ObjectType{
				AttrTypes: ContentsValue{}.AttributeTypes(ctx),
			},
		},
		v.Contents.Elements(),
	)

	if v.Contents.IsNull() {
		contents = types.ListNull(
			ContentsType{
				basetypes.ObjectType{
					AttrTypes: ContentsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Contents.IsUnknown() {
		contents = types.ListUnknown(
			ContentsType{
				basetypes.ObjectType{
					AttrTypes: ContentsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"contents": basetypes.ListType{
			ElemType: ContentsValue{}.Type(ctx),
		},
		"match": basetypes.StringType{},
		"user":  basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"contents": contents,
			"match":    v.Match,
			"user":     v.User,
		})

	return objVal, diags
}

func (v UsersValue) Equal(o attr.Value) bool {
	other, ok := o.(UsersValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Contents.Equal(other.Contents) {
		return false
	}

	if !v.Match.Equal(other.Match) {
		return false
	}

	if !v.User.Equal(other.User) {
		return false
	}

	return true
}

func (v UsersValue) Type(ctx context.Context) attr.Type {
	return UsersType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v UsersValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"contents": basetypes.ListType{
			ElemType: ContentsValue{}.Type(ctx),
		},
		"match": basetypes.StringType{},
		"user":  basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = SnmpConfigType{}

type SnmpConfigType struct {
	basetypes.ObjectType
}

func (t SnmpConfigType) Equal(o attr.Type) bool {
	other, ok := o.(SnmpConfigType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SnmpConfigType) String() string {
	return "SnmpConfigType"
}

func (t SnmpConfigType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	clientListAttribute, ok := attributes["client_list"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`client_list is missing from object`)

		return nil, diags
	}

	clientListVal, ok := clientListAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`client_list expected to be basetypes.ListValue, was: %T`, clientListAttribute))
	}

	contactAttribute, ok := attributes["contact"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`contact is missing from object`)

		return nil, diags
	}

	contactVal, ok := contactAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`contact expected to be basetypes.StringValue, was: %T`, contactAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return nil, diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	engineIdAttribute, ok := attributes["engine_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`engine_id is missing from object`)

		return nil, diags
	}

	engineIdVal, ok := engineIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`engine_id expected to be basetypes.StringValue, was: %T`, engineIdAttribute))
	}

	engineIdTypeAttribute, ok := attributes["engine_id_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`engine_id_type is missing from object`)

		return nil, diags
	}

	engineIdTypeVal, ok := engineIdTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`engine_id_type expected to be basetypes.StringValue, was: %T`, engineIdTypeAttribute))
	}

	locationAttribute, ok := attributes["location"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`location is missing from object`)

		return nil, diags
	}

	locationVal, ok := locationAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`location expected to be basetypes.StringValue, was: %T`, locationAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	networkAttribute, ok := attributes["network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`network is missing from object`)

		return nil, diags
	}

	networkVal, ok := networkAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`network expected to be basetypes.StringValue, was: %T`, networkAttribute))
	}

	trapGroupsAttribute, ok := attributes["trap_groups"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`trap_groups is missing from object`)

		return nil, diags
	}

	trapGroupsVal, ok := trapGroupsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`trap_groups expected to be basetypes.ListValue, was: %T`, trapGroupsAttribute))
	}

	v2cConfigAttribute, ok := attributes["v2c_config"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`v2c_config is missing from object`)

		return nil, diags
	}

	v2cConfigVal, ok := v2cConfigAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`v2c_config expected to be basetypes.ListValue, was: %T`, v2cConfigAttribute))
	}

	v3ConfigAttribute, ok := attributes["v3_config"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`v3_config is missing from object`)

		return nil, diags
	}

	v3ConfigVal, ok := v3ConfigAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`v3_config expected to be basetypes.ObjectValue, was: %T`, v3ConfigAttribute))
	}

	viewsAttribute, ok := attributes["views"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`views is missing from object`)

		return nil, diags
	}

	viewsVal, ok := viewsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`views expected to be basetypes.ListValue, was: %T`, viewsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SnmpConfigValue{
		ClientList:   clientListVal,
		Contact:      contactVal,
		Description:  descriptionVal,
		Enabled:      enabledVal,
		EngineId:     engineIdVal,
		EngineIdType: engineIdTypeVal,
		Location:     locationVal,
		Name:         nameVal,
		Network:      networkVal,
		TrapGroups:   trapGroupsVal,
		V2cConfig:    v2cConfigVal,
		V3Config:     v3ConfigVal,
		Views:        viewsVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewSnmpConfigValueNull() SnmpConfigValue {
	return SnmpConfigValue{
		state: attr.ValueStateNull,
	}
}

func NewSnmpConfigValueUnknown() SnmpConfigValue {
	return SnmpConfigValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSnmpConfigValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SnmpConfigValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SnmpConfigValue Attribute Value",
				"While creating a SnmpConfigValue value, a missing attribute value was detected. "+
					"A SnmpConfigValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SnmpConfigValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SnmpConfigValue Attribute Type",
				"While creating a SnmpConfigValue value, an invalid attribute value was detected. "+
					"A SnmpConfigValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SnmpConfigValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SnmpConfigValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SnmpConfigValue Attribute Value",
				"While creating a SnmpConfigValue value, an extra attribute value was detected. "+
					"A SnmpConfigValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SnmpConfigValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSnmpConfigValueUnknown(), diags
	}

	clientListAttribute, ok := attributes["client_list"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`client_list is missing from object`)

		return NewSnmpConfigValueUnknown(), diags
	}

	clientListVal, ok := clientListAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`client_list expected to be basetypes.ListValue, was: %T`, clientListAttribute))
	}

	contactAttribute, ok := attributes["contact"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`contact is missing from object`)

		return NewSnmpConfigValueUnknown(), diags
	}

	contactVal, ok := contactAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`contact expected to be basetypes.StringValue, was: %T`, contactAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return NewSnmpConfigValueUnknown(), diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewSnmpConfigValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	engineIdAttribute, ok := attributes["engine_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`engine_id is missing from object`)

		return NewSnmpConfigValueUnknown(), diags
	}

	engineIdVal, ok := engineIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`engine_id expected to be basetypes.StringValue, was: %T`, engineIdAttribute))
	}

	engineIdTypeAttribute, ok := attributes["engine_id_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`engine_id_type is missing from object`)

		return NewSnmpConfigValueUnknown(), diags
	}

	engineIdTypeVal, ok := engineIdTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`engine_id_type expected to be basetypes.StringValue, was: %T`, engineIdTypeAttribute))
	}

	locationAttribute, ok := attributes["location"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`location is missing from object`)

		return NewSnmpConfigValueUnknown(), diags
	}

	locationVal, ok := locationAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`location expected to be basetypes.StringValue, was: %T`, locationAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewSnmpConfigValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	networkAttribute, ok := attributes["network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`network is missing from object`)

		return NewSnmpConfigValueUnknown(), diags
	}

	networkVal, ok := networkAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`network expected to be basetypes.StringValue, was: %T`, networkAttribute))
	}

	trapGroupsAttribute, ok := attributes["trap_groups"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`trap_groups is missing from object`)

		return NewSnmpConfigValueUnknown(), diags
	}

	trapGroupsVal, ok := trapGroupsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`trap_groups expected to be basetypes.ListValue, was: %T`, trapGroupsAttribute))
	}

	v2cConfigAttribute, ok := attributes["v2c_config"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`v2c_config is missing from object`)

		return NewSnmpConfigValueUnknown(), diags
	}

	v2cConfigVal, ok := v2cConfigAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`v2c_config expected to be basetypes.ListValue, was: %T`, v2cConfigAttribute))
	}

	v3ConfigAttribute, ok := attributes["v3_config"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`v3_config is missing from object`)

		return NewSnmpConfigValueUnknown(), diags
	}

	v3ConfigVal, ok := v3ConfigAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`v3_config expected to be basetypes.ObjectValue, was: %T`, v3ConfigAttribute))
	}

	viewsAttribute, ok := attributes["views"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`views is missing from object`)

		return NewSnmpConfigValueUnknown(), diags
	}

	viewsVal, ok := viewsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`views expected to be basetypes.ListValue, was: %T`, viewsAttribute))
	}

	if diags.HasError() {
		return NewSnmpConfigValueUnknown(), diags
	}

	return SnmpConfigValue{
		ClientList:   clientListVal,
		Contact:      contactVal,
		Description:  descriptionVal,
		Enabled:      enabledVal,
		EngineId:     engineIdVal,
		EngineIdType: engineIdTypeVal,
		Location:     locationVal,
		Name:         nameVal,
		Network:      networkVal,
		TrapGroups:   trapGroupsVal,
		V2cConfig:    v2cConfigVal,
		V3Config:     v3ConfigVal,
		Views:        viewsVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewSnmpConfigValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SnmpConfigValue {
	object, diags := NewSnmpConfigValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSnmpConfigValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SnmpConfigType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSnmpConfigValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSnmpConfigValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSnmpConfigValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSnmpConfigValueMust(SnmpConfigValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SnmpConfigType) ValueType(ctx context.Context) attr.Value {
	return SnmpConfigValue{}
}

var _ basetypes.ObjectValuable = SnmpConfigValue{}

type SnmpConfigValue struct {
	ClientList   basetypes.ListValue   `tfsdk:"client_list"`
	Contact      basetypes.StringValue `tfsdk:"contact"`
	Description  basetypes.StringValue `tfsdk:"description"`
	Enabled      basetypes.BoolValue   `tfsdk:"enabled"`
	EngineId     basetypes.StringValue `tfsdk:"engine_id"`
	EngineIdType basetypes.StringValue `tfsdk:"engine_id_type"`
	Location     basetypes.StringValue `tfsdk:"location"`
	Name         basetypes.StringValue `tfsdk:"name"`
	Network      basetypes.StringValue `tfsdk:"network"`
	TrapGroups   basetypes.ListValue   `tfsdk:"trap_groups"`
	V2cConfig    basetypes.ListValue   `tfsdk:"v2c_config"`
	V3Config     basetypes.ObjectValue `tfsdk:"v3_config"`
	Views        basetypes.ListValue   `tfsdk:"views"`
	state        attr.ValueState
}

func (v SnmpConfigValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 13)

	var val tftypes.Value
	var err error

	attrTypes["client_list"] = basetypes.ListType{
		ElemType: ClientListValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["contact"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["engine_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["engine_id_type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["location"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["network"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["trap_groups"] = basetypes.ListType{
		ElemType: TrapGroupsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["v2c_config"] = basetypes.ListType{
		ElemType: V2cConfigValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["v3_config"] = basetypes.ObjectType{
		AttrTypes: V3ConfigValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["views"] = basetypes.ListType{
		ElemType: ViewsValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 13)

		val, err = v.ClientList.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["client_list"] = val

		val, err = v.Contact.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["contact"] = val

		val, err = v.Description.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["description"] = val

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.EngineId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["engine_id"] = val

		val, err = v.EngineIdType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["engine_id_type"] = val

		val, err = v.Location.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["location"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Network.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["network"] = val

		val, err = v.TrapGroups.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["trap_groups"] = val

		val, err = v.V2cConfig.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["v2c_config"] = val

		val, err = v.V3Config.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["v3_config"] = val

		val, err = v.Views.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["views"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SnmpConfigValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SnmpConfigValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SnmpConfigValue) String() string {
	return "SnmpConfigValue"
}

func (v SnmpConfigValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	clientList := types.ListValueMust(
		ClientListType{
			basetypes.ObjectType{
				AttrTypes: ClientListValue{}.AttributeTypes(ctx),
			},
		},
		v.ClientList.Elements(),
	)

	if v.ClientList.IsNull() {
		clientList = types.ListNull(
			ClientListType{
				basetypes.ObjectType{
					AttrTypes: ClientListValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.ClientList.IsUnknown() {
		clientList = types.ListUnknown(
			ClientListType{
				basetypes.ObjectType{
					AttrTypes: ClientListValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	trapGroups := types.ListValueMust(
		TrapGroupsType{
			basetypes.ObjectType{
				AttrTypes: TrapGroupsValue{}.AttributeTypes(ctx),
			},
		},
		v.TrapGroups.Elements(),
	)

	if v.TrapGroups.IsNull() {
		trapGroups = types.ListNull(
			TrapGroupsType{
				basetypes.ObjectType{
					AttrTypes: TrapGroupsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.TrapGroups.IsUnknown() {
		trapGroups = types.ListUnknown(
			TrapGroupsType{
				basetypes.ObjectType{
					AttrTypes: TrapGroupsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	v2cConfig := types.ListValueMust(
		V2cConfigType{
			basetypes.ObjectType{
				AttrTypes: V2cConfigValue{}.AttributeTypes(ctx),
			},
		},
		v.V2cConfig.Elements(),
	)

	if v.V2cConfig.IsNull() {
		v2cConfig = types.ListNull(
			V2cConfigType{
				basetypes.ObjectType{
					AttrTypes: V2cConfigValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.V2cConfig.IsUnknown() {
		v2cConfig = types.ListUnknown(
			V2cConfigType{
				basetypes.ObjectType{
					AttrTypes: V2cConfigValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var v3Config basetypes.ObjectValue

	if v.V3Config.IsNull() {
		v3Config = types.ObjectNull(
			V3ConfigValue{}.AttributeTypes(ctx),
		)
	}

	if v.V3Config.IsUnknown() {
		v3Config = types.ObjectUnknown(
			V3ConfigValue{}.AttributeTypes(ctx),
		)
	}

	if !v.V3Config.IsNull() && !v.V3Config.IsUnknown() {
		v3Config = types.ObjectValueMust(
			V3ConfigValue{}.AttributeTypes(ctx),
			v.V3Config.Attributes(),
		)
	}

	views := types.ListValueMust(
		ViewsType{
			basetypes.ObjectType{
				AttrTypes: ViewsValue{}.AttributeTypes(ctx),
			},
		},
		v.Views.Elements(),
	)

	if v.Views.IsNull() {
		views = types.ListNull(
			ViewsType{
				basetypes.ObjectType{
					AttrTypes: ViewsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Views.IsUnknown() {
		views = types.ListUnknown(
			ViewsType{
				basetypes.ObjectType{
					AttrTypes: ViewsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"client_list": basetypes.ListType{
			ElemType: ClientListValue{}.Type(ctx),
		},
		"contact":        basetypes.StringType{},
		"description":    basetypes.StringType{},
		"enabled":        basetypes.BoolType{},
		"engine_id":      basetypes.StringType{},
		"engine_id_type": basetypes.StringType{},
		"location":       basetypes.StringType{},
		"name":           basetypes.StringType{},
		"network":        basetypes.StringType{},
		"trap_groups": basetypes.ListType{
			ElemType: TrapGroupsValue{}.Type(ctx),
		},
		"v2c_config": basetypes.ListType{
			ElemType: V2cConfigValue{}.Type(ctx),
		},
		"v3_config": basetypes.ObjectType{
			AttrTypes: V3ConfigValue{}.AttributeTypes(ctx),
		},
		"views": basetypes.ListType{
			ElemType: ViewsValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"client_list":    clientList,
			"contact":        v.Contact,
			"description":    v.Description,
			"enabled":        v.Enabled,
			"engine_id":      v.EngineId,
			"engine_id_type": v.EngineIdType,
			"location":       v.Location,
			"name":           v.Name,
			"network":        v.Network,
			"trap_groups":    trapGroups,
			"v2c_config":     v2cConfig,
			"v3_config":      v3Config,
			"views":          views,
		})

	return objVal, diags
}

func (v SnmpConfigValue) Equal(o attr.Value) bool {
	other, ok := o.(SnmpConfigValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.ClientList.Equal(other.ClientList) {
		return false
	}

	if !v.Contact.Equal(other.Contact) {
		return false
	}

	if !v.Description.Equal(other.Description) {
		return false
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.EngineId.Equal(other.EngineId) {
		return false
	}

	if !v.EngineIdType.Equal(other.EngineIdType) {
		return false
	}

	if !v.Location.Equal(other.Location) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Network.Equal(other.Network) {
		return false
	}

	if !v.TrapGroups.Equal(other.TrapGroups) {
		return false
	}

	if !v.V2cConfig.Equal(other.V2cConfig) {
		return false
	}

	if !v.V3Config.Equal(other.V3Config) {
		return false
	}

	if !v.Views.Equal(other.Views) {
		return false
	}

	return true
}

func (v SnmpConfigValue) Type(ctx context.Context) attr.Type {
	return SnmpConfigType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SnmpConfigValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"client_list": basetypes.ListType{
			ElemType: ClientListValue{}.Type(ctx),
		},
		"contact":        basetypes.StringType{},
		"description":    basetypes.StringType{},
		"enabled":        basetypes.BoolType{},
		"engine_id":      basetypes.StringType{},
		"engine_id_type": basetypes.StringType{},
		"location":       basetypes.StringType{},
		"name":           basetypes.StringType{},
		"network":        basetypes.StringType{},
		"trap_groups": basetypes.ListType{
			ElemType: TrapGroupsValue{}.Type(ctx),
		},
		"v2c_config": basetypes.ListType{
			ElemType: V2cConfigValue{}.Type(ctx),
		},
		"v3_config": basetypes.ObjectType{
			AttrTypes: V3ConfigValue{}.AttributeTypes(ctx),
		},
		"views": basetypes.ListType{
			ElemType: ViewsValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = ClientListType{}

type ClientListType struct {
	basetypes.ObjectType
}

func (t ClientListType) Equal(o attr.Type) bool {
	other, ok := o.(ClientListType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ClientListType) String() string {
	return "ClientListType"
}

func (t ClientListType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	clientListNameAttribute, ok := attributes["client_list_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`client_list_name is missing from object`)

		return nil, diags
	}

	clientListNameVal, ok := clientListNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`client_list_name expected to be basetypes.StringValue, was: %T`, clientListNameAttribute))
	}

	clientsAttribute, ok := attributes["clients"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`clients is missing from object`)

		return nil, diags
	}

	clientsVal, ok := clientsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`clients expected to be basetypes.ListValue, was: %T`, clientsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ClientListValue{
		ClientListName: clientListNameVal,
		Clients:        clientsVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewClientListValueNull() ClientListValue {
	return ClientListValue{
		state: attr.ValueStateNull,
	}
}

func NewClientListValueUnknown() ClientListValue {
	return ClientListValue{
		state: attr.ValueStateUnknown,
	}
}

func NewClientListValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ClientListValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ClientListValue Attribute Value",
				"While creating a ClientListValue value, a missing attribute value was detected. "+
					"A ClientListValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ClientListValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ClientListValue Attribute Type",
				"While creating a ClientListValue value, an invalid attribute value was detected. "+
					"A ClientListValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ClientListValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ClientListValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ClientListValue Attribute Value",
				"While creating a ClientListValue value, an extra attribute value was detected. "+
					"A ClientListValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ClientListValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewClientListValueUnknown(), diags
	}

	clientListNameAttribute, ok := attributes["client_list_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`client_list_name is missing from object`)

		return NewClientListValueUnknown(), diags
	}

	clientListNameVal, ok := clientListNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`client_list_name expected to be basetypes.StringValue, was: %T`, clientListNameAttribute))
	}

	clientsAttribute, ok := attributes["clients"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`clients is missing from object`)

		return NewClientListValueUnknown(), diags
	}

	clientsVal, ok := clientsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`clients expected to be basetypes.ListValue, was: %T`, clientsAttribute))
	}

	if diags.HasError() {
		return NewClientListValueUnknown(), diags
	}

	return ClientListValue{
		ClientListName: clientListNameVal,
		Clients:        clientsVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewClientListValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ClientListValue {
	object, diags := NewClientListValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewClientListValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ClientListType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewClientListValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewClientListValueUnknown(), nil
	}

	if in.IsNull() {
		return NewClientListValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewClientListValueMust(ClientListValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ClientListType) ValueType(ctx context.Context) attr.Value {
	return ClientListValue{}
}

var _ basetypes.ObjectValuable = ClientListValue{}

type ClientListValue struct {
	ClientListName basetypes.StringValue `tfsdk:"client_list_name"`
	Clients        basetypes.ListValue   `tfsdk:"clients"`
	state          attr.ValueState
}

func (v ClientListValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["client_list_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["clients"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.ClientListName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["client_list_name"] = val

		val, err = v.Clients.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["clients"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ClientListValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ClientListValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ClientListValue) String() string {
	return "ClientListValue"
}

func (v ClientListValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var clientsVal basetypes.ListValue
	switch {
	case v.Clients.IsUnknown():
		clientsVal = types.ListUnknown(types.StringType)
	case v.Clients.IsNull():
		clientsVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		clientsVal, d = types.ListValue(types.StringType, v.Clients.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"client_list_name": basetypes.StringType{},
			"clients": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"client_list_name": basetypes.StringType{},
		"clients": basetypes.ListType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"client_list_name": v.ClientListName,
			"clients":          clientsVal,
		})

	return objVal, diags
}

func (v ClientListValue) Equal(o attr.Value) bool {
	other, ok := o.(ClientListValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.ClientListName.Equal(other.ClientListName) {
		return false
	}

	if !v.Clients.Equal(other.Clients) {
		return false
	}

	return true
}

func (v ClientListValue) Type(ctx context.Context) attr.Type {
	return ClientListType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ClientListValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"client_list_name": basetypes.StringType{},
		"clients": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = TrapGroupsType{}

type TrapGroupsType struct {
	basetypes.ObjectType
}

func (t TrapGroupsType) Equal(o attr.Type) bool {
	other, ok := o.(TrapGroupsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t TrapGroupsType) String() string {
	return "TrapGroupsType"
}

func (t TrapGroupsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	categoriesAttribute, ok := attributes["categories"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`categories is missing from object`)

		return nil, diags
	}

	categoriesVal, ok := categoriesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`categories expected to be basetypes.ListValue, was: %T`, categoriesAttribute))
	}

	groupNameAttribute, ok := attributes["group_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`group_name is missing from object`)

		return nil, diags
	}

	groupNameVal, ok := groupNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`group_name expected to be basetypes.StringValue, was: %T`, groupNameAttribute))
	}

	targetsAttribute, ok := attributes["targets"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`targets is missing from object`)

		return nil, diags
	}

	targetsVal, ok := targetsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`targets expected to be basetypes.ListValue, was: %T`, targetsAttribute))
	}

	versionAttribute, ok := attributes["version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`version is missing from object`)

		return nil, diags
	}

	versionVal, ok := versionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`version expected to be basetypes.StringValue, was: %T`, versionAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return TrapGroupsValue{
		Categories: categoriesVal,
		GroupName:  groupNameVal,
		Targets:    targetsVal,
		Version:    versionVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewTrapGroupsValueNull() TrapGroupsValue {
	return TrapGroupsValue{
		state: attr.ValueStateNull,
	}
}

func NewTrapGroupsValueUnknown() TrapGroupsValue {
	return TrapGroupsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewTrapGroupsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (TrapGroupsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing TrapGroupsValue Attribute Value",
				"While creating a TrapGroupsValue value, a missing attribute value was detected. "+
					"A TrapGroupsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TrapGroupsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid TrapGroupsValue Attribute Type",
				"While creating a TrapGroupsValue value, an invalid attribute value was detected. "+
					"A TrapGroupsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TrapGroupsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("TrapGroupsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra TrapGroupsValue Attribute Value",
				"While creating a TrapGroupsValue value, an extra attribute value was detected. "+
					"A TrapGroupsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra TrapGroupsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewTrapGroupsValueUnknown(), diags
	}

	categoriesAttribute, ok := attributes["categories"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`categories is missing from object`)

		return NewTrapGroupsValueUnknown(), diags
	}

	categoriesVal, ok := categoriesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`categories expected to be basetypes.ListValue, was: %T`, categoriesAttribute))
	}

	groupNameAttribute, ok := attributes["group_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`group_name is missing from object`)

		return NewTrapGroupsValueUnknown(), diags
	}

	groupNameVal, ok := groupNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`group_name expected to be basetypes.StringValue, was: %T`, groupNameAttribute))
	}

	targetsAttribute, ok := attributes["targets"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`targets is missing from object`)

		return NewTrapGroupsValueUnknown(), diags
	}

	targetsVal, ok := targetsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`targets expected to be basetypes.ListValue, was: %T`, targetsAttribute))
	}

	versionAttribute, ok := attributes["version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`version is missing from object`)

		return NewTrapGroupsValueUnknown(), diags
	}

	versionVal, ok := versionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`version expected to be basetypes.StringValue, was: %T`, versionAttribute))
	}

	if diags.HasError() {
		return NewTrapGroupsValueUnknown(), diags
	}

	return TrapGroupsValue{
		Categories: categoriesVal,
		GroupName:  groupNameVal,
		Targets:    targetsVal,
		Version:    versionVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewTrapGroupsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) TrapGroupsValue {
	object, diags := NewTrapGroupsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewTrapGroupsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t TrapGroupsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewTrapGroupsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewTrapGroupsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewTrapGroupsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewTrapGroupsValueMust(TrapGroupsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t TrapGroupsType) ValueType(ctx context.Context) attr.Value {
	return TrapGroupsValue{}
}

var _ basetypes.ObjectValuable = TrapGroupsValue{}

type TrapGroupsValue struct {
	Categories basetypes.ListValue   `tfsdk:"categories"`
	GroupName  basetypes.StringValue `tfsdk:"group_name"`
	Targets    basetypes.ListValue   `tfsdk:"targets"`
	Version    basetypes.StringValue `tfsdk:"version"`
	state      attr.ValueState
}

func (v TrapGroupsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["categories"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["group_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["targets"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["version"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Categories.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["categories"] = val

		val, err = v.GroupName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["group_name"] = val

		val, err = v.Targets.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["targets"] = val

		val, err = v.Version.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["version"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v TrapGroupsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v TrapGroupsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v TrapGroupsValue) String() string {
	return "TrapGroupsValue"
}

func (v TrapGroupsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var categoriesVal basetypes.ListValue
	switch {
	case v.Categories.IsUnknown():
		categoriesVal = types.ListUnknown(types.StringType)
	case v.Categories.IsNull():
		categoriesVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		categoriesVal, d = types.ListValue(types.StringType, v.Categories.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"categories": basetypes.ListType{
				ElemType: types.StringType,
			},
			"group_name": basetypes.StringType{},
			"targets": basetypes.ListType{
				ElemType: types.StringType,
			},
			"version": basetypes.StringType{},
		}), diags
	}

	var targetsVal basetypes.ListValue
	switch {
	case v.Targets.IsUnknown():
		targetsVal = types.ListUnknown(types.StringType)
	case v.Targets.IsNull():
		targetsVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		targetsVal, d = types.ListValue(types.StringType, v.Targets.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"categories": basetypes.ListType{
				ElemType: types.StringType,
			},
			"group_name": basetypes.StringType{},
			"targets": basetypes.ListType{
				ElemType: types.StringType,
			},
			"version": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"categories": basetypes.ListType{
			ElemType: types.StringType,
		},
		"group_name": basetypes.StringType{},
		"targets": basetypes.ListType{
			ElemType: types.StringType,
		},
		"version": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"categories": categoriesVal,
			"group_name": v.GroupName,
			"targets":    targetsVal,
			"version":    v.Version,
		})

	return objVal, diags
}

func (v TrapGroupsValue) Equal(o attr.Value) bool {
	other, ok := o.(TrapGroupsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Categories.Equal(other.Categories) {
		return false
	}

	if !v.GroupName.Equal(other.GroupName) {
		return false
	}

	if !v.Targets.Equal(other.Targets) {
		return false
	}

	if !v.Version.Equal(other.Version) {
		return false
	}

	return true
}

func (v TrapGroupsValue) Type(ctx context.Context) attr.Type {
	return TrapGroupsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v TrapGroupsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"categories": basetypes.ListType{
			ElemType: types.StringType,
		},
		"group_name": basetypes.StringType{},
		"targets": basetypes.ListType{
			ElemType: types.StringType,
		},
		"version": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = V2cConfigType{}

type V2cConfigType struct {
	basetypes.ObjectType
}

func (t V2cConfigType) Equal(o attr.Type) bool {
	other, ok := o.(V2cConfigType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t V2cConfigType) String() string {
	return "V2cConfigType"
}

func (t V2cConfigType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	authorizationAttribute, ok := attributes["authorization"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`authorization is missing from object`)

		return nil, diags
	}

	authorizationVal, ok := authorizationAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`authorization expected to be basetypes.StringValue, was: %T`, authorizationAttribute))
	}

	clientListNameAttribute, ok := attributes["client_list_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`client_list_name is missing from object`)

		return nil, diags
	}

	clientListNameVal, ok := clientListNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`client_list_name expected to be basetypes.StringValue, was: %T`, clientListNameAttribute))
	}

	communityNameAttribute, ok := attributes["community_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`community_name is missing from object`)

		return nil, diags
	}

	communityNameVal, ok := communityNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`community_name expected to be basetypes.StringValue, was: %T`, communityNameAttribute))
	}

	viewAttribute, ok := attributes["view"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`view is missing from object`)

		return nil, diags
	}

	viewVal, ok := viewAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`view expected to be basetypes.StringValue, was: %T`, viewAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return V2cConfigValue{
		Authorization:  authorizationVal,
		ClientListName: clientListNameVal,
		CommunityName:  communityNameVal,
		View:           viewVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewV2cConfigValueNull() V2cConfigValue {
	return V2cConfigValue{
		state: attr.ValueStateNull,
	}
}

func NewV2cConfigValueUnknown() V2cConfigValue {
	return V2cConfigValue{
		state: attr.ValueStateUnknown,
	}
}

func NewV2cConfigValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (V2cConfigValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing V2cConfigValue Attribute Value",
				"While creating a V2cConfigValue value, a missing attribute value was detected. "+
					"A V2cConfigValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("V2cConfigValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid V2cConfigValue Attribute Type",
				"While creating a V2cConfigValue value, an invalid attribute value was detected. "+
					"A V2cConfigValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("V2cConfigValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("V2cConfigValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra V2cConfigValue Attribute Value",
				"While creating a V2cConfigValue value, an extra attribute value was detected. "+
					"A V2cConfigValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra V2cConfigValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewV2cConfigValueUnknown(), diags
	}

	authorizationAttribute, ok := attributes["authorization"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`authorization is missing from object`)

		return NewV2cConfigValueUnknown(), diags
	}

	authorizationVal, ok := authorizationAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`authorization expected to be basetypes.StringValue, was: %T`, authorizationAttribute))
	}

	clientListNameAttribute, ok := attributes["client_list_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`client_list_name is missing from object`)

		return NewV2cConfigValueUnknown(), diags
	}

	clientListNameVal, ok := clientListNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`client_list_name expected to be basetypes.StringValue, was: %T`, clientListNameAttribute))
	}

	communityNameAttribute, ok := attributes["community_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`community_name is missing from object`)

		return NewV2cConfigValueUnknown(), diags
	}

	communityNameVal, ok := communityNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`community_name expected to be basetypes.StringValue, was: %T`, communityNameAttribute))
	}

	viewAttribute, ok := attributes["view"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`view is missing from object`)

		return NewV2cConfigValueUnknown(), diags
	}

	viewVal, ok := viewAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`view expected to be basetypes.StringValue, was: %T`, viewAttribute))
	}

	if diags.HasError() {
		return NewV2cConfigValueUnknown(), diags
	}

	return V2cConfigValue{
		Authorization:  authorizationVal,
		ClientListName: clientListNameVal,
		CommunityName:  communityNameVal,
		View:           viewVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewV2cConfigValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) V2cConfigValue {
	object, diags := NewV2cConfigValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewV2cConfigValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t V2cConfigType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewV2cConfigValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewV2cConfigValueUnknown(), nil
	}

	if in.IsNull() {
		return NewV2cConfigValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewV2cConfigValueMust(V2cConfigValue{}.AttributeTypes(ctx), attributes), nil
}

func (t V2cConfigType) ValueType(ctx context.Context) attr.Value {
	return V2cConfigValue{}
}

var _ basetypes.ObjectValuable = V2cConfigValue{}

type V2cConfigValue struct {
	Authorization  basetypes.StringValue `tfsdk:"authorization"`
	ClientListName basetypes.StringValue `tfsdk:"client_list_name"`
	CommunityName  basetypes.StringValue `tfsdk:"community_name"`
	View           basetypes.StringValue `tfsdk:"view"`
	state          attr.ValueState
}

func (v V2cConfigValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["authorization"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["client_list_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["community_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["view"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Authorization.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["authorization"] = val

		val, err = v.ClientListName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["client_list_name"] = val

		val, err = v.CommunityName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["community_name"] = val

		val, err = v.View.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["view"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v V2cConfigValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v V2cConfigValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v V2cConfigValue) String() string {
	return "V2cConfigValue"
}

func (v V2cConfigValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"authorization":    basetypes.StringType{},
		"client_list_name": basetypes.StringType{},
		"community_name":   basetypes.StringType{},
		"view":             basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"authorization":    v.Authorization,
			"client_list_name": v.ClientListName,
			"community_name":   v.CommunityName,
			"view":             v.View,
		})

	return objVal, diags
}

func (v V2cConfigValue) Equal(o attr.Value) bool {
	other, ok := o.(V2cConfigValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Authorization.Equal(other.Authorization) {
		return false
	}

	if !v.ClientListName.Equal(other.ClientListName) {
		return false
	}

	if !v.CommunityName.Equal(other.CommunityName) {
		return false
	}

	if !v.View.Equal(other.View) {
		return false
	}

	return true
}

func (v V2cConfigValue) Type(ctx context.Context) attr.Type {
	return V2cConfigType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v V2cConfigValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"authorization":    basetypes.StringType{},
		"client_list_name": basetypes.StringType{},
		"community_name":   basetypes.StringType{},
		"view":             basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = V3ConfigType{}

type V3ConfigType struct {
	basetypes.ObjectType
}

func (t V3ConfigType) Equal(o attr.Type) bool {
	other, ok := o.(V3ConfigType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t V3ConfigType) String() string {
	return "V3ConfigType"
}

func (t V3ConfigType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	notifyAttribute, ok := attributes["notify"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`notify is missing from object`)

		return nil, diags
	}

	notifyVal, ok := notifyAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`notify expected to be basetypes.ListValue, was: %T`, notifyAttribute))
	}

	notifyFilterAttribute, ok := attributes["notify_filter"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`notify_filter is missing from object`)

		return nil, diags
	}

	notifyFilterVal, ok := notifyFilterAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`notify_filter expected to be basetypes.ListValue, was: %T`, notifyFilterAttribute))
	}

	targetAddressAttribute, ok := attributes["target_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`target_address is missing from object`)

		return nil, diags
	}

	targetAddressVal, ok := targetAddressAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`target_address expected to be basetypes.ListValue, was: %T`, targetAddressAttribute))
	}

	targetParametersAttribute, ok := attributes["target_parameters"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`target_parameters is missing from object`)

		return nil, diags
	}

	targetParametersVal, ok := targetParametersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`target_parameters expected to be basetypes.ListValue, was: %T`, targetParametersAttribute))
	}

	usmAttribute, ok := attributes["usm"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`usm is missing from object`)

		return nil, diags
	}

	usmVal, ok := usmAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`usm expected to be basetypes.ListValue, was: %T`, usmAttribute))
	}

	vacmAttribute, ok := attributes["vacm"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vacm is missing from object`)

		return nil, diags
	}

	vacmVal, ok := vacmAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vacm expected to be basetypes.ObjectValue, was: %T`, vacmAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return V3ConfigValue{
		Notify:           notifyVal,
		NotifyFilter:     notifyFilterVal,
		TargetAddress:    targetAddressVal,
		TargetParameters: targetParametersVal,
		Usm:              usmVal,
		Vacm:             vacmVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewV3ConfigValueNull() V3ConfigValue {
	return V3ConfigValue{
		state: attr.ValueStateNull,
	}
}

func NewV3ConfigValueUnknown() V3ConfigValue {
	return V3ConfigValue{
		state: attr.ValueStateUnknown,
	}
}

func NewV3ConfigValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (V3ConfigValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing V3ConfigValue Attribute Value",
				"While creating a V3ConfigValue value, a missing attribute value was detected. "+
					"A V3ConfigValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("V3ConfigValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid V3ConfigValue Attribute Type",
				"While creating a V3ConfigValue value, an invalid attribute value was detected. "+
					"A V3ConfigValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("V3ConfigValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("V3ConfigValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra V3ConfigValue Attribute Value",
				"While creating a V3ConfigValue value, an extra attribute value was detected. "+
					"A V3ConfigValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra V3ConfigValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewV3ConfigValueUnknown(), diags
	}

	notifyAttribute, ok := attributes["notify"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`notify is missing from object`)

		return NewV3ConfigValueUnknown(), diags
	}

	notifyVal, ok := notifyAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`notify expected to be basetypes.ListValue, was: %T`, notifyAttribute))
	}

	notifyFilterAttribute, ok := attributes["notify_filter"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`notify_filter is missing from object`)

		return NewV3ConfigValueUnknown(), diags
	}

	notifyFilterVal, ok := notifyFilterAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`notify_filter expected to be basetypes.ListValue, was: %T`, notifyFilterAttribute))
	}

	targetAddressAttribute, ok := attributes["target_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`target_address is missing from object`)

		return NewV3ConfigValueUnknown(), diags
	}

	targetAddressVal, ok := targetAddressAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`target_address expected to be basetypes.ListValue, was: %T`, targetAddressAttribute))
	}

	targetParametersAttribute, ok := attributes["target_parameters"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`target_parameters is missing from object`)

		return NewV3ConfigValueUnknown(), diags
	}

	targetParametersVal, ok := targetParametersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`target_parameters expected to be basetypes.ListValue, was: %T`, targetParametersAttribute))
	}

	usmAttribute, ok := attributes["usm"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`usm is missing from object`)

		return NewV3ConfigValueUnknown(), diags
	}

	usmVal, ok := usmAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`usm expected to be basetypes.ListValue, was: %T`, usmAttribute))
	}

	vacmAttribute, ok := attributes["vacm"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vacm is missing from object`)

		return NewV3ConfigValueUnknown(), diags
	}

	vacmVal, ok := vacmAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vacm expected to be basetypes.ObjectValue, was: %T`, vacmAttribute))
	}

	if diags.HasError() {
		return NewV3ConfigValueUnknown(), diags
	}

	return V3ConfigValue{
		Notify:           notifyVal,
		NotifyFilter:     notifyFilterVal,
		TargetAddress:    targetAddressVal,
		TargetParameters: targetParametersVal,
		Usm:              usmVal,
		Vacm:             vacmVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewV3ConfigValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) V3ConfigValue {
	object, diags := NewV3ConfigValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewV3ConfigValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t V3ConfigType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewV3ConfigValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewV3ConfigValueUnknown(), nil
	}

	if in.IsNull() {
		return NewV3ConfigValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewV3ConfigValueMust(V3ConfigValue{}.AttributeTypes(ctx), attributes), nil
}

func (t V3ConfigType) ValueType(ctx context.Context) attr.Value {
	return V3ConfigValue{}
}

var _ basetypes.ObjectValuable = V3ConfigValue{}

type V3ConfigValue struct {
	Notify           basetypes.ListValue   `tfsdk:"notify"`
	NotifyFilter     basetypes.ListValue   `tfsdk:"notify_filter"`
	TargetAddress    basetypes.ListValue   `tfsdk:"target_address"`
	TargetParameters basetypes.ListValue   `tfsdk:"target_parameters"`
	Usm              basetypes.ListValue   `tfsdk:"usm"`
	Vacm             basetypes.ObjectValue `tfsdk:"vacm"`
	state            attr.ValueState
}

func (v V3ConfigValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 6)

	var val tftypes.Value
	var err error

	attrTypes["notify"] = basetypes.ListType{
		ElemType: NotifyValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["notify_filter"] = basetypes.ListType{
		ElemType: NotifyFilterValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["target_address"] = basetypes.ListType{
		ElemType: TargetAddressValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["target_parameters"] = basetypes.ListType{
		ElemType: TargetParametersValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["usm"] = basetypes.ListType{
		ElemType: UsmValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["vacm"] = basetypes.ObjectType{
		AttrTypes: VacmValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 6)

		val, err = v.Notify.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["notify"] = val

		val, err = v.NotifyFilter.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["notify_filter"] = val

		val, err = v.TargetAddress.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["target_address"] = val

		val, err = v.TargetParameters.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["target_parameters"] = val

		val, err = v.Usm.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["usm"] = val

		val, err = v.Vacm.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vacm"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v V3ConfigValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v V3ConfigValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v V3ConfigValue) String() string {
	return "V3ConfigValue"
}

func (v V3ConfigValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	notify := types.ListValueMust(
		NotifyType{
			basetypes.ObjectType{
				AttrTypes: NotifyValue{}.AttributeTypes(ctx),
			},
		},
		v.Notify.Elements(),
	)

	if v.Notify.IsNull() {
		notify = types.ListNull(
			NotifyType{
				basetypes.ObjectType{
					AttrTypes: NotifyValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Notify.IsUnknown() {
		notify = types.ListUnknown(
			NotifyType{
				basetypes.ObjectType{
					AttrTypes: NotifyValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	notifyFilter := types.ListValueMust(
		NotifyFilterType{
			basetypes.ObjectType{
				AttrTypes: NotifyFilterValue{}.AttributeTypes(ctx),
			},
		},
		v.NotifyFilter.Elements(),
	)

	if v.NotifyFilter.IsNull() {
		notifyFilter = types.ListNull(
			NotifyFilterType{
				basetypes.ObjectType{
					AttrTypes: NotifyFilterValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.NotifyFilter.IsUnknown() {
		notifyFilter = types.ListUnknown(
			NotifyFilterType{
				basetypes.ObjectType{
					AttrTypes: NotifyFilterValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	targetAddress := types.ListValueMust(
		TargetAddressType{
			basetypes.ObjectType{
				AttrTypes: TargetAddressValue{}.AttributeTypes(ctx),
			},
		},
		v.TargetAddress.Elements(),
	)

	if v.TargetAddress.IsNull() {
		targetAddress = types.ListNull(
			TargetAddressType{
				basetypes.ObjectType{
					AttrTypes: TargetAddressValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.TargetAddress.IsUnknown() {
		targetAddress = types.ListUnknown(
			TargetAddressType{
				basetypes.ObjectType{
					AttrTypes: TargetAddressValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	targetParameters := types.ListValueMust(
		TargetParametersType{
			basetypes.ObjectType{
				AttrTypes: TargetParametersValue{}.AttributeTypes(ctx),
			},
		},
		v.TargetParameters.Elements(),
	)

	if v.TargetParameters.IsNull() {
		targetParameters = types.ListNull(
			TargetParametersType{
				basetypes.ObjectType{
					AttrTypes: TargetParametersValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.TargetParameters.IsUnknown() {
		targetParameters = types.ListUnknown(
			TargetParametersType{
				basetypes.ObjectType{
					AttrTypes: TargetParametersValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	usm := types.ListValueMust(
		UsmType{
			basetypes.ObjectType{
				AttrTypes: UsmValue{}.AttributeTypes(ctx),
			},
		},
		v.Usm.Elements(),
	)

	if v.Usm.IsNull() {
		usm = types.ListNull(
			UsmType{
				basetypes.ObjectType{
					AttrTypes: UsmValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Usm.IsUnknown() {
		usm = types.ListUnknown(
			UsmType{
				basetypes.ObjectType{
					AttrTypes: UsmValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var vacm basetypes.ObjectValue

	if v.Vacm.IsNull() {
		vacm = types.ObjectNull(
			VacmValue{}.AttributeTypes(ctx),
		)
	}

	if v.Vacm.IsUnknown() {
		vacm = types.ObjectUnknown(
			VacmValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Vacm.IsNull() && !v.Vacm.IsUnknown() {
		vacm = types.ObjectValueMust(
			VacmValue{}.AttributeTypes(ctx),
			v.Vacm.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"notify": basetypes.ListType{
			ElemType: NotifyValue{}.Type(ctx),
		},
		"notify_filter": basetypes.ListType{
			ElemType: NotifyFilterValue{}.Type(ctx),
		},
		"target_address": basetypes.ListType{
			ElemType: TargetAddressValue{}.Type(ctx),
		},
		"target_parameters": basetypes.ListType{
			ElemType: TargetParametersValue{}.Type(ctx),
		},
		"usm": basetypes.ListType{
			ElemType: UsmValue{}.Type(ctx),
		},
		"vacm": basetypes.ObjectType{
			AttrTypes: VacmValue{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"notify":            notify,
			"notify_filter":     notifyFilter,
			"target_address":    targetAddress,
			"target_parameters": targetParameters,
			"usm":               usm,
			"vacm":              vacm,
		})

	return objVal, diags
}

func (v V3ConfigValue) Equal(o attr.Value) bool {
	other, ok := o.(V3ConfigValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Notify.Equal(other.Notify) {
		return false
	}

	if !v.NotifyFilter.Equal(other.NotifyFilter) {
		return false
	}

	if !v.TargetAddress.Equal(other.TargetAddress) {
		return false
	}

	if !v.TargetParameters.Equal(other.TargetParameters) {
		return false
	}

	if !v.Usm.Equal(other.Usm) {
		return false
	}

	if !v.Vacm.Equal(other.Vacm) {
		return false
	}

	return true
}

func (v V3ConfigValue) Type(ctx context.Context) attr.Type {
	return V3ConfigType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v V3ConfigValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"notify": basetypes.ListType{
			ElemType: NotifyValue{}.Type(ctx),
		},
		"notify_filter": basetypes.ListType{
			ElemType: NotifyFilterValue{}.Type(ctx),
		},
		"target_address": basetypes.ListType{
			ElemType: TargetAddressValue{}.Type(ctx),
		},
		"target_parameters": basetypes.ListType{
			ElemType: TargetParametersValue{}.Type(ctx),
		},
		"usm": basetypes.ListType{
			ElemType: UsmValue{}.Type(ctx),
		},
		"vacm": basetypes.ObjectType{
			AttrTypes: VacmValue{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = NotifyType{}

type NotifyType struct {
	basetypes.ObjectType
}

func (t NotifyType) Equal(o attr.Type) bool {
	other, ok := o.(NotifyType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t NotifyType) String() string {
	return "NotifyType"
}

func (t NotifyType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	tagAttribute, ok := attributes["tag"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tag is missing from object`)

		return nil, diags
	}

	tagVal, ok := tagAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tag expected to be basetypes.StringValue, was: %T`, tagAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return NotifyValue{
		Name:       nameVal,
		Tag:        tagVal,
		NotifyType: typeVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewNotifyValueNull() NotifyValue {
	return NotifyValue{
		state: attr.ValueStateNull,
	}
}

func NewNotifyValueUnknown() NotifyValue {
	return NotifyValue{
		state: attr.ValueStateUnknown,
	}
}

func NewNotifyValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (NotifyValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing NotifyValue Attribute Value",
				"While creating a NotifyValue value, a missing attribute value was detected. "+
					"A NotifyValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NotifyValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid NotifyValue Attribute Type",
				"While creating a NotifyValue value, an invalid attribute value was detected. "+
					"A NotifyValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NotifyValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("NotifyValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra NotifyValue Attribute Value",
				"While creating a NotifyValue value, an extra attribute value was detected. "+
					"A NotifyValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra NotifyValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewNotifyValueUnknown(), diags
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewNotifyValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	tagAttribute, ok := attributes["tag"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tag is missing from object`)

		return NewNotifyValueUnknown(), diags
	}

	tagVal, ok := tagAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tag expected to be basetypes.StringValue, was: %T`, tagAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewNotifyValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return NewNotifyValueUnknown(), diags
	}

	return NotifyValue{
		Name:       nameVal,
		Tag:        tagVal,
		NotifyType: typeVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewNotifyValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) NotifyValue {
	object, diags := NewNotifyValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewNotifyValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t NotifyType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewNotifyValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewNotifyValueUnknown(), nil
	}

	if in.IsNull() {
		return NewNotifyValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewNotifyValueMust(NotifyValue{}.AttributeTypes(ctx), attributes), nil
}

func (t NotifyType) ValueType(ctx context.Context) attr.Value {
	return NotifyValue{}
}

var _ basetypes.ObjectValuable = NotifyValue{}

type NotifyValue struct {
	Name       basetypes.StringValue `tfsdk:"name"`
	Tag        basetypes.StringValue `tfsdk:"tag"`
	NotifyType basetypes.StringValue `tfsdk:"type"`
	state      attr.ValueState
}

func (v NotifyValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["tag"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Tag.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tag"] = val

		val, err = v.NotifyType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v NotifyValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v NotifyValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v NotifyValue) String() string {
	return "NotifyValue"
}

func (v NotifyValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"name": basetypes.StringType{},
		"tag":  basetypes.StringType{},
		"type": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"name": v.Name,
			"tag":  v.Tag,
			"type": v.NotifyType,
		})

	return objVal, diags
}

func (v NotifyValue) Equal(o attr.Value) bool {
	other, ok := o.(NotifyValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Tag.Equal(other.Tag) {
		return false
	}

	if !v.NotifyType.Equal(other.NotifyType) {
		return false
	}

	return true
}

func (v NotifyValue) Type(ctx context.Context) attr.Type {
	return NotifyType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v NotifyValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"name": basetypes.StringType{},
		"tag":  basetypes.StringType{},
		"type": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = NotifyFilterType{}

type NotifyFilterType struct {
	basetypes.ObjectType
}

func (t NotifyFilterType) Equal(o attr.Type) bool {
	other, ok := o.(NotifyFilterType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t NotifyFilterType) String() string {
	return "NotifyFilterType"
}

func (t NotifyFilterType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	profileNameAttribute, ok := attributes["profile_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`profile_name is missing from object`)

		return nil, diags
	}

	profileNameVal, ok := profileNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`profile_name expected to be basetypes.StringValue, was: %T`, profileNameAttribute))
	}

	snmpv3ContentsAttribute, ok := attributes["contents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`contents is missing from object`)

		return nil, diags
	}

	snmpv3ContentsVal, ok := snmpv3ContentsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`contents expected to be basetypes.ListValue, was: %T`, snmpv3ContentsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return NotifyFilterValue{
		ProfileName:    profileNameVal,
		Snmpv3Contents: snmpv3ContentsVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewNotifyFilterValueNull() NotifyFilterValue {
	return NotifyFilterValue{
		state: attr.ValueStateNull,
	}
}

func NewNotifyFilterValueUnknown() NotifyFilterValue {
	return NotifyFilterValue{
		state: attr.ValueStateUnknown,
	}
}

func NewNotifyFilterValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (NotifyFilterValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing NotifyFilterValue Attribute Value",
				"While creating a NotifyFilterValue value, a missing attribute value was detected. "+
					"A NotifyFilterValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NotifyFilterValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid NotifyFilterValue Attribute Type",
				"While creating a NotifyFilterValue value, an invalid attribute value was detected. "+
					"A NotifyFilterValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NotifyFilterValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("NotifyFilterValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra NotifyFilterValue Attribute Value",
				"While creating a NotifyFilterValue value, an extra attribute value was detected. "+
					"A NotifyFilterValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra NotifyFilterValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewNotifyFilterValueUnknown(), diags
	}

	profileNameAttribute, ok := attributes["profile_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`profile_name is missing from object`)

		return NewNotifyFilterValueUnknown(), diags
	}

	profileNameVal, ok := profileNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`profile_name expected to be basetypes.StringValue, was: %T`, profileNameAttribute))
	}

	snmpv3ContentsAttribute, ok := attributes["contents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`contents is missing from object`)

		return NewNotifyFilterValueUnknown(), diags
	}

	snmpv3ContentsVal, ok := snmpv3ContentsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`contents expected to be basetypes.ListValue, was: %T`, snmpv3ContentsAttribute))
	}

	if diags.HasError() {
		return NewNotifyFilterValueUnknown(), diags
	}

	return NotifyFilterValue{
		ProfileName:    profileNameVal,
		Snmpv3Contents: snmpv3ContentsVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewNotifyFilterValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) NotifyFilterValue {
	object, diags := NewNotifyFilterValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewNotifyFilterValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t NotifyFilterType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewNotifyFilterValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewNotifyFilterValueUnknown(), nil
	}

	if in.IsNull() {
		return NewNotifyFilterValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewNotifyFilterValueMust(NotifyFilterValue{}.AttributeTypes(ctx), attributes), nil
}

func (t NotifyFilterType) ValueType(ctx context.Context) attr.Value {
	return NotifyFilterValue{}
}

var _ basetypes.ObjectValuable = NotifyFilterValue{}

type NotifyFilterValue struct {
	ProfileName    basetypes.StringValue `tfsdk:"profile_name"`
	Snmpv3Contents basetypes.ListValue   `tfsdk:"contents"`
	state          attr.ValueState
}

func (v NotifyFilterValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["profile_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["contents"] = basetypes.ListType{
		ElemType: Snmpv3ContentsValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.ProfileName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["profile_name"] = val

		val, err = v.Snmpv3Contents.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["contents"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v NotifyFilterValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v NotifyFilterValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v NotifyFilterValue) String() string {
	return "NotifyFilterValue"
}

func (v NotifyFilterValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	snmpv3Contents := types.ListValueMust(
		Snmpv3ContentsType{
			basetypes.ObjectType{
				AttrTypes: Snmpv3ContentsValue{}.AttributeTypes(ctx),
			},
		},
		v.Snmpv3Contents.Elements(),
	)

	if v.Snmpv3Contents.IsNull() {
		snmpv3Contents = types.ListNull(
			Snmpv3ContentsType{
				basetypes.ObjectType{
					AttrTypes: Snmpv3ContentsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Snmpv3Contents.IsUnknown() {
		snmpv3Contents = types.ListUnknown(
			Snmpv3ContentsType{
				basetypes.ObjectType{
					AttrTypes: Snmpv3ContentsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"profile_name": basetypes.StringType{},
		"contents": basetypes.ListType{
			ElemType: Snmpv3ContentsValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"profile_name": v.ProfileName,
			"contents":     snmpv3Contents,
		})

	return objVal, diags
}

func (v NotifyFilterValue) Equal(o attr.Value) bool {
	other, ok := o.(NotifyFilterValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.ProfileName.Equal(other.ProfileName) {
		return false
	}

	if !v.Snmpv3Contents.Equal(other.Snmpv3Contents) {
		return false
	}

	return true
}

func (v NotifyFilterValue) Type(ctx context.Context) attr.Type {
	return NotifyFilterType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v NotifyFilterValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"profile_name": basetypes.StringType{},
		"contents": basetypes.ListType{
			ElemType: Snmpv3ContentsValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = Snmpv3ContentsType{}

type Snmpv3ContentsType struct {
	basetypes.ObjectType
}

func (t Snmpv3ContentsType) Equal(o attr.Type) bool {
	other, ok := o.(Snmpv3ContentsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Snmpv3ContentsType) String() string {
	return "Snmpv3ContentsType"
}

func (t Snmpv3ContentsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	includeAttribute, ok := attributes["include"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`include is missing from object`)

		return nil, diags
	}

	includeVal, ok := includeAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`include expected to be basetypes.BoolValue, was: %T`, includeAttribute))
	}

	oidAttribute, ok := attributes["oid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`oid is missing from object`)

		return nil, diags
	}

	oidVal, ok := oidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`oid expected to be basetypes.StringValue, was: %T`, oidAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Snmpv3ContentsValue{
		Include: includeVal,
		Oid:     oidVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewSnmpv3ContentsValueNull() Snmpv3ContentsValue {
	return Snmpv3ContentsValue{
		state: attr.ValueStateNull,
	}
}

func NewSnmpv3ContentsValueUnknown() Snmpv3ContentsValue {
	return Snmpv3ContentsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSnmpv3ContentsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Snmpv3ContentsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Snmpv3ContentsValue Attribute Value",
				"While creating a Snmpv3ContentsValue value, a missing attribute value was detected. "+
					"A Snmpv3ContentsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Snmpv3ContentsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Snmpv3ContentsValue Attribute Type",
				"While creating a Snmpv3ContentsValue value, an invalid attribute value was detected. "+
					"A Snmpv3ContentsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Snmpv3ContentsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Snmpv3ContentsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Snmpv3ContentsValue Attribute Value",
				"While creating a Snmpv3ContentsValue value, an extra attribute value was detected. "+
					"A Snmpv3ContentsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Snmpv3ContentsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSnmpv3ContentsValueUnknown(), diags
	}

	includeAttribute, ok := attributes["include"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`include is missing from object`)

		return NewSnmpv3ContentsValueUnknown(), diags
	}

	includeVal, ok := includeAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`include expected to be basetypes.BoolValue, was: %T`, includeAttribute))
	}

	oidAttribute, ok := attributes["oid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`oid is missing from object`)

		return NewSnmpv3ContentsValueUnknown(), diags
	}

	oidVal, ok := oidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`oid expected to be basetypes.StringValue, was: %T`, oidAttribute))
	}

	if diags.HasError() {
		return NewSnmpv3ContentsValueUnknown(), diags
	}

	return Snmpv3ContentsValue{
		Include: includeVal,
		Oid:     oidVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewSnmpv3ContentsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Snmpv3ContentsValue {
	object, diags := NewSnmpv3ContentsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSnmpv3ContentsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Snmpv3ContentsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSnmpv3ContentsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSnmpv3ContentsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSnmpv3ContentsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSnmpv3ContentsValueMust(Snmpv3ContentsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t Snmpv3ContentsType) ValueType(ctx context.Context) attr.Value {
	return Snmpv3ContentsValue{}
}

var _ basetypes.ObjectValuable = Snmpv3ContentsValue{}

type Snmpv3ContentsValue struct {
	Include basetypes.BoolValue   `tfsdk:"include"`
	Oid     basetypes.StringValue `tfsdk:"oid"`
	state   attr.ValueState
}

func (v Snmpv3ContentsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["include"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["oid"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Include.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["include"] = val

		val, err = v.Oid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["oid"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Snmpv3ContentsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Snmpv3ContentsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Snmpv3ContentsValue) String() string {
	return "Snmpv3ContentsValue"
}

func (v Snmpv3ContentsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"include": basetypes.BoolType{},
		"oid":     basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"include": v.Include,
			"oid":     v.Oid,
		})

	return objVal, diags
}

func (v Snmpv3ContentsValue) Equal(o attr.Value) bool {
	other, ok := o.(Snmpv3ContentsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Include.Equal(other.Include) {
		return false
	}

	if !v.Oid.Equal(other.Oid) {
		return false
	}

	return true
}

func (v Snmpv3ContentsValue) Type(ctx context.Context) attr.Type {
	return Snmpv3ContentsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Snmpv3ContentsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"include": basetypes.BoolType{},
		"oid":     basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = TargetAddressType{}

type TargetAddressType struct {
	basetypes.ObjectType
}

func (t TargetAddressType) Equal(o attr.Type) bool {
	other, ok := o.(TargetAddressType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t TargetAddressType) String() string {
	return "TargetAddressType"
}

func (t TargetAddressType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	addressAttribute, ok := attributes["address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`address is missing from object`)

		return nil, diags
	}

	addressVal, ok := addressAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`address expected to be basetypes.StringValue, was: %T`, addressAttribute))
	}

	addressMaskAttribute, ok := attributes["address_mask"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`address_mask is missing from object`)

		return nil, diags
	}

	addressMaskVal, ok := addressMaskAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`address_mask expected to be basetypes.StringValue, was: %T`, addressMaskAttribute))
	}

	portAttribute, ok := attributes["port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port is missing from object`)

		return nil, diags
	}

	portVal, ok := portAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port expected to be basetypes.StringValue, was: %T`, portAttribute))
	}

	tagListAttribute, ok := attributes["tag_list"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tag_list is missing from object`)

		return nil, diags
	}

	tagListVal, ok := tagListAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tag_list expected to be basetypes.StringValue, was: %T`, tagListAttribute))
	}

	targetAddressNameAttribute, ok := attributes["target_address_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`target_address_name is missing from object`)

		return nil, diags
	}

	targetAddressNameVal, ok := targetAddressNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`target_address_name expected to be basetypes.StringValue, was: %T`, targetAddressNameAttribute))
	}

	targetParametersAttribute, ok := attributes["target_parameters"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`target_parameters is missing from object`)

		return nil, diags
	}

	targetParametersVal, ok := targetParametersAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`target_parameters expected to be basetypes.StringValue, was: %T`, targetParametersAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return TargetAddressValue{
		Address:           addressVal,
		AddressMask:       addressMaskVal,
		Port:              portVal,
		TagList:           tagListVal,
		TargetAddressName: targetAddressNameVal,
		TargetParameters:  targetParametersVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewTargetAddressValueNull() TargetAddressValue {
	return TargetAddressValue{
		state: attr.ValueStateNull,
	}
}

func NewTargetAddressValueUnknown() TargetAddressValue {
	return TargetAddressValue{
		state: attr.ValueStateUnknown,
	}
}

func NewTargetAddressValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (TargetAddressValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing TargetAddressValue Attribute Value",
				"While creating a TargetAddressValue value, a missing attribute value was detected. "+
					"A TargetAddressValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TargetAddressValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid TargetAddressValue Attribute Type",
				"While creating a TargetAddressValue value, an invalid attribute value was detected. "+
					"A TargetAddressValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TargetAddressValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("TargetAddressValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra TargetAddressValue Attribute Value",
				"While creating a TargetAddressValue value, an extra attribute value was detected. "+
					"A TargetAddressValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra TargetAddressValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewTargetAddressValueUnknown(), diags
	}

	addressAttribute, ok := attributes["address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`address is missing from object`)

		return NewTargetAddressValueUnknown(), diags
	}

	addressVal, ok := addressAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`address expected to be basetypes.StringValue, was: %T`, addressAttribute))
	}

	addressMaskAttribute, ok := attributes["address_mask"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`address_mask is missing from object`)

		return NewTargetAddressValueUnknown(), diags
	}

	addressMaskVal, ok := addressMaskAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`address_mask expected to be basetypes.StringValue, was: %T`, addressMaskAttribute))
	}

	portAttribute, ok := attributes["port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port is missing from object`)

		return NewTargetAddressValueUnknown(), diags
	}

	portVal, ok := portAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port expected to be basetypes.StringValue, was: %T`, portAttribute))
	}

	tagListAttribute, ok := attributes["tag_list"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tag_list is missing from object`)

		return NewTargetAddressValueUnknown(), diags
	}

	tagListVal, ok := tagListAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tag_list expected to be basetypes.StringValue, was: %T`, tagListAttribute))
	}

	targetAddressNameAttribute, ok := attributes["target_address_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`target_address_name is missing from object`)

		return NewTargetAddressValueUnknown(), diags
	}

	targetAddressNameVal, ok := targetAddressNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`target_address_name expected to be basetypes.StringValue, was: %T`, targetAddressNameAttribute))
	}

	targetParametersAttribute, ok := attributes["target_parameters"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`target_parameters is missing from object`)

		return NewTargetAddressValueUnknown(), diags
	}

	targetParametersVal, ok := targetParametersAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`target_parameters expected to be basetypes.StringValue, was: %T`, targetParametersAttribute))
	}

	if diags.HasError() {
		return NewTargetAddressValueUnknown(), diags
	}

	return TargetAddressValue{
		Address:           addressVal,
		AddressMask:       addressMaskVal,
		Port:              portVal,
		TagList:           tagListVal,
		TargetAddressName: targetAddressNameVal,
		TargetParameters:  targetParametersVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewTargetAddressValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) TargetAddressValue {
	object, diags := NewTargetAddressValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewTargetAddressValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t TargetAddressType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewTargetAddressValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewTargetAddressValueUnknown(), nil
	}

	if in.IsNull() {
		return NewTargetAddressValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewTargetAddressValueMust(TargetAddressValue{}.AttributeTypes(ctx), attributes), nil
}

func (t TargetAddressType) ValueType(ctx context.Context) attr.Value {
	return TargetAddressValue{}
}

var _ basetypes.ObjectValuable = TargetAddressValue{}

type TargetAddressValue struct {
	Address           basetypes.StringValue `tfsdk:"address"`
	AddressMask       basetypes.StringValue `tfsdk:"address_mask"`
	Port              basetypes.StringValue `tfsdk:"port"`
	TagList           basetypes.StringValue `tfsdk:"tag_list"`
	TargetAddressName basetypes.StringValue `tfsdk:"target_address_name"`
	TargetParameters  basetypes.StringValue `tfsdk:"target_parameters"`
	state             attr.ValueState
}

func (v TargetAddressValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 6)

	var val tftypes.Value
	var err error

	attrTypes["address"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["address_mask"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["port"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["tag_list"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["target_address_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["target_parameters"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 6)

		val, err = v.Address.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["address"] = val

		val, err = v.AddressMask.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["address_mask"] = val

		val, err = v.Port.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port"] = val

		val, err = v.TagList.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tag_list"] = val

		val, err = v.TargetAddressName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["target_address_name"] = val

		val, err = v.TargetParameters.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["target_parameters"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v TargetAddressValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v TargetAddressValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v TargetAddressValue) String() string {
	return "TargetAddressValue"
}

func (v TargetAddressValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"address":             basetypes.StringType{},
		"address_mask":        basetypes.StringType{},
		"port":                basetypes.StringType{},
		"tag_list":            basetypes.StringType{},
		"target_address_name": basetypes.StringType{},
		"target_parameters":   basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"address":             v.Address,
			"address_mask":        v.AddressMask,
			"port":                v.Port,
			"tag_list":            v.TagList,
			"target_address_name": v.TargetAddressName,
			"target_parameters":   v.TargetParameters,
		})

	return objVal, diags
}

func (v TargetAddressValue) Equal(o attr.Value) bool {
	other, ok := o.(TargetAddressValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Address.Equal(other.Address) {
		return false
	}

	if !v.AddressMask.Equal(other.AddressMask) {
		return false
	}

	if !v.Port.Equal(other.Port) {
		return false
	}

	if !v.TagList.Equal(other.TagList) {
		return false
	}

	if !v.TargetAddressName.Equal(other.TargetAddressName) {
		return false
	}

	if !v.TargetParameters.Equal(other.TargetParameters) {
		return false
	}

	return true
}

func (v TargetAddressValue) Type(ctx context.Context) attr.Type {
	return TargetAddressType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v TargetAddressValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"address":             basetypes.StringType{},
		"address_mask":        basetypes.StringType{},
		"port":                basetypes.StringType{},
		"tag_list":            basetypes.StringType{},
		"target_address_name": basetypes.StringType{},
		"target_parameters":   basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = TargetParametersType{}

type TargetParametersType struct {
	basetypes.ObjectType
}

func (t TargetParametersType) Equal(o attr.Type) bool {
	other, ok := o.(TargetParametersType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t TargetParametersType) String() string {
	return "TargetParametersType"
}

func (t TargetParametersType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	messageProcessingModelAttribute, ok := attributes["message_processing_model"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`message_processing_model is missing from object`)

		return nil, diags
	}

	messageProcessingModelVal, ok := messageProcessingModelAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`message_processing_model expected to be basetypes.StringValue, was: %T`, messageProcessingModelAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	notifyFilterAttribute, ok := attributes["notify_filter"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`notify_filter is missing from object`)

		return nil, diags
	}

	notifyFilterVal, ok := notifyFilterAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`notify_filter expected to be basetypes.StringValue, was: %T`, notifyFilterAttribute))
	}

	securityLevelAttribute, ok := attributes["security_level"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`security_level is missing from object`)

		return nil, diags
	}

	securityLevelVal, ok := securityLevelAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`security_level expected to be basetypes.StringValue, was: %T`, securityLevelAttribute))
	}

	securityModelAttribute, ok := attributes["security_model"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`security_model is missing from object`)

		return nil, diags
	}

	securityModelVal, ok := securityModelAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`security_model expected to be basetypes.StringValue, was: %T`, securityModelAttribute))
	}

	securityNameAttribute, ok := attributes["security_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`security_name is missing from object`)

		return nil, diags
	}

	securityNameVal, ok := securityNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`security_name expected to be basetypes.StringValue, was: %T`, securityNameAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return TargetParametersValue{
		MessageProcessingModel: messageProcessingModelVal,
		Name:                   nameVal,
		NotifyFilter:           notifyFilterVal,
		SecurityLevel:          securityLevelVal,
		SecurityModel:          securityModelVal,
		SecurityName:           securityNameVal,
		state:                  attr.ValueStateKnown,
	}, diags
}

func NewTargetParametersValueNull() TargetParametersValue {
	return TargetParametersValue{
		state: attr.ValueStateNull,
	}
}

func NewTargetParametersValueUnknown() TargetParametersValue {
	return TargetParametersValue{
		state: attr.ValueStateUnknown,
	}
}

func NewTargetParametersValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (TargetParametersValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing TargetParametersValue Attribute Value",
				"While creating a TargetParametersValue value, a missing attribute value was detected. "+
					"A TargetParametersValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TargetParametersValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid TargetParametersValue Attribute Type",
				"While creating a TargetParametersValue value, an invalid attribute value was detected. "+
					"A TargetParametersValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TargetParametersValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("TargetParametersValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra TargetParametersValue Attribute Value",
				"While creating a TargetParametersValue value, an extra attribute value was detected. "+
					"A TargetParametersValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra TargetParametersValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewTargetParametersValueUnknown(), diags
	}

	messageProcessingModelAttribute, ok := attributes["message_processing_model"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`message_processing_model is missing from object`)

		return NewTargetParametersValueUnknown(), diags
	}

	messageProcessingModelVal, ok := messageProcessingModelAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`message_processing_model expected to be basetypes.StringValue, was: %T`, messageProcessingModelAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewTargetParametersValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	notifyFilterAttribute, ok := attributes["notify_filter"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`notify_filter is missing from object`)

		return NewTargetParametersValueUnknown(), diags
	}

	notifyFilterVal, ok := notifyFilterAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`notify_filter expected to be basetypes.StringValue, was: %T`, notifyFilterAttribute))
	}

	securityLevelAttribute, ok := attributes["security_level"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`security_level is missing from object`)

		return NewTargetParametersValueUnknown(), diags
	}

	securityLevelVal, ok := securityLevelAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`security_level expected to be basetypes.StringValue, was: %T`, securityLevelAttribute))
	}

	securityModelAttribute, ok := attributes["security_model"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`security_model is missing from object`)

		return NewTargetParametersValueUnknown(), diags
	}

	securityModelVal, ok := securityModelAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`security_model expected to be basetypes.StringValue, was: %T`, securityModelAttribute))
	}

	securityNameAttribute, ok := attributes["security_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`security_name is missing from object`)

		return NewTargetParametersValueUnknown(), diags
	}

	securityNameVal, ok := securityNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`security_name expected to be basetypes.StringValue, was: %T`, securityNameAttribute))
	}

	if diags.HasError() {
		return NewTargetParametersValueUnknown(), diags
	}

	return TargetParametersValue{
		MessageProcessingModel: messageProcessingModelVal,
		Name:                   nameVal,
		NotifyFilter:           notifyFilterVal,
		SecurityLevel:          securityLevelVal,
		SecurityModel:          securityModelVal,
		SecurityName:           securityNameVal,
		state:                  attr.ValueStateKnown,
	}, diags
}

func NewTargetParametersValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) TargetParametersValue {
	object, diags := NewTargetParametersValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewTargetParametersValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t TargetParametersType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewTargetParametersValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewTargetParametersValueUnknown(), nil
	}

	if in.IsNull() {
		return NewTargetParametersValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewTargetParametersValueMust(TargetParametersValue{}.AttributeTypes(ctx), attributes), nil
}

func (t TargetParametersType) ValueType(ctx context.Context) attr.Value {
	return TargetParametersValue{}
}

var _ basetypes.ObjectValuable = TargetParametersValue{}

type TargetParametersValue struct {
	MessageProcessingModel basetypes.StringValue `tfsdk:"message_processing_model"`
	Name                   basetypes.StringValue `tfsdk:"name"`
	NotifyFilter           basetypes.StringValue `tfsdk:"notify_filter"`
	SecurityLevel          basetypes.StringValue `tfsdk:"security_level"`
	SecurityModel          basetypes.StringValue `tfsdk:"security_model"`
	SecurityName           basetypes.StringValue `tfsdk:"security_name"`
	state                  attr.ValueState
}

func (v TargetParametersValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 6)

	var val tftypes.Value
	var err error

	attrTypes["message_processing_model"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["notify_filter"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["security_level"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["security_model"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["security_name"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 6)

		val, err = v.MessageProcessingModel.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["message_processing_model"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.NotifyFilter.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["notify_filter"] = val

		val, err = v.SecurityLevel.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["security_level"] = val

		val, err = v.SecurityModel.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["security_model"] = val

		val, err = v.SecurityName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["security_name"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v TargetParametersValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v TargetParametersValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v TargetParametersValue) String() string {
	return "TargetParametersValue"
}

func (v TargetParametersValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"message_processing_model": basetypes.StringType{},
		"name":                     basetypes.StringType{},
		"notify_filter":            basetypes.StringType{},
		"security_level":           basetypes.StringType{},
		"security_model":           basetypes.StringType{},
		"security_name":            basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"message_processing_model": v.MessageProcessingModel,
			"name":                     v.Name,
			"notify_filter":            v.NotifyFilter,
			"security_level":           v.SecurityLevel,
			"security_model":           v.SecurityModel,
			"security_name":            v.SecurityName,
		})

	return objVal, diags
}

func (v TargetParametersValue) Equal(o attr.Value) bool {
	other, ok := o.(TargetParametersValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.MessageProcessingModel.Equal(other.MessageProcessingModel) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.NotifyFilter.Equal(other.NotifyFilter) {
		return false
	}

	if !v.SecurityLevel.Equal(other.SecurityLevel) {
		return false
	}

	if !v.SecurityModel.Equal(other.SecurityModel) {
		return false
	}

	if !v.SecurityName.Equal(other.SecurityName) {
		return false
	}

	return true
}

func (v TargetParametersValue) Type(ctx context.Context) attr.Type {
	return TargetParametersType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v TargetParametersValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"message_processing_model": basetypes.StringType{},
		"name":                     basetypes.StringType{},
		"notify_filter":            basetypes.StringType{},
		"security_level":           basetypes.StringType{},
		"security_model":           basetypes.StringType{},
		"security_name":            basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = UsmType{}

type UsmType struct {
	basetypes.ObjectType
}

func (t UsmType) Equal(o attr.Type) bool {
	other, ok := o.(UsmType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t UsmType) String() string {
	return "UsmType"
}

func (t UsmType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	engineTypeAttribute, ok := attributes["engine_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`engine_type is missing from object`)

		return nil, diags
	}

	engineTypeVal, ok := engineTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`engine_type expected to be basetypes.StringValue, was: %T`, engineTypeAttribute))
	}

	remoteEngineIdAttribute, ok := attributes["remote_engine_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remote_engine_id is missing from object`)

		return nil, diags
	}

	remoteEngineIdVal, ok := remoteEngineIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remote_engine_id expected to be basetypes.StringValue, was: %T`, remoteEngineIdAttribute))
	}

	snmpv3UsersAttribute, ok := attributes["users"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`users is missing from object`)

		return nil, diags
	}

	snmpv3UsersVal, ok := snmpv3UsersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`users expected to be basetypes.ListValue, was: %T`, snmpv3UsersAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return UsmValue{
		EngineType:     engineTypeVal,
		RemoteEngineId: remoteEngineIdVal,
		Snmpv3Users:    snmpv3UsersVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewUsmValueNull() UsmValue {
	return UsmValue{
		state: attr.ValueStateNull,
	}
}

func NewUsmValueUnknown() UsmValue {
	return UsmValue{
		state: attr.ValueStateUnknown,
	}
}

func NewUsmValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (UsmValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing UsmValue Attribute Value",
				"While creating a UsmValue value, a missing attribute value was detected. "+
					"A UsmValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("UsmValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid UsmValue Attribute Type",
				"While creating a UsmValue value, an invalid attribute value was detected. "+
					"A UsmValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("UsmValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("UsmValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra UsmValue Attribute Value",
				"While creating a UsmValue value, an extra attribute value was detected. "+
					"A UsmValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra UsmValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewUsmValueUnknown(), diags
	}

	engineTypeAttribute, ok := attributes["engine_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`engine_type is missing from object`)

		return NewUsmValueUnknown(), diags
	}

	engineTypeVal, ok := engineTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`engine_type expected to be basetypes.StringValue, was: %T`, engineTypeAttribute))
	}

	remoteEngineIdAttribute, ok := attributes["remote_engine_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remote_engine_id is missing from object`)

		return NewUsmValueUnknown(), diags
	}

	remoteEngineIdVal, ok := remoteEngineIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remote_engine_id expected to be basetypes.StringValue, was: %T`, remoteEngineIdAttribute))
	}

	snmpv3UsersAttribute, ok := attributes["users"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`users is missing from object`)

		return NewUsmValueUnknown(), diags
	}

	snmpv3UsersVal, ok := snmpv3UsersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`users expected to be basetypes.ListValue, was: %T`, snmpv3UsersAttribute))
	}

	if diags.HasError() {
		return NewUsmValueUnknown(), diags
	}

	return UsmValue{
		EngineType:     engineTypeVal,
		RemoteEngineId: remoteEngineIdVal,
		Snmpv3Users:    snmpv3UsersVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewUsmValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) UsmValue {
	object, diags := NewUsmValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewUsmValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t UsmType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewUsmValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewUsmValueUnknown(), nil
	}

	if in.IsNull() {
		return NewUsmValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewUsmValueMust(UsmValue{}.AttributeTypes(ctx), attributes), nil
}

func (t UsmType) ValueType(ctx context.Context) attr.Value {
	return UsmValue{}
}

var _ basetypes.ObjectValuable = UsmValue{}

type UsmValue struct {
	EngineType     basetypes.StringValue `tfsdk:"engine_type"`
	RemoteEngineId basetypes.StringValue `tfsdk:"remote_engine_id"`
	Snmpv3Users    basetypes.ListValue   `tfsdk:"users"`
	state          attr.ValueState
}

func (v UsmValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["engine_type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["remote_engine_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["users"] = basetypes.ListType{
		ElemType: Snmpv3UsersValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.EngineType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["engine_type"] = val

		val, err = v.RemoteEngineId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["remote_engine_id"] = val

		val, err = v.Snmpv3Users.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["users"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v UsmValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v UsmValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v UsmValue) String() string {
	return "UsmValue"
}

func (v UsmValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	snmpv3Users := types.ListValueMust(
		Snmpv3UsersType{
			basetypes.ObjectType{
				AttrTypes: Snmpv3UsersValue{}.AttributeTypes(ctx),
			},
		},
		v.Snmpv3Users.Elements(),
	)

	if v.Snmpv3Users.IsNull() {
		snmpv3Users = types.ListNull(
			Snmpv3UsersType{
				basetypes.ObjectType{
					AttrTypes: Snmpv3UsersValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Snmpv3Users.IsUnknown() {
		snmpv3Users = types.ListUnknown(
			Snmpv3UsersType{
				basetypes.ObjectType{
					AttrTypes: Snmpv3UsersValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"engine_type":      basetypes.StringType{},
		"remote_engine_id": basetypes.StringType{},
		"users": basetypes.ListType{
			ElemType: Snmpv3UsersValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"engine_type":      v.EngineType,
			"remote_engine_id": v.RemoteEngineId,
			"users":            snmpv3Users,
		})

	return objVal, diags
}

func (v UsmValue) Equal(o attr.Value) bool {
	other, ok := o.(UsmValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.EngineType.Equal(other.EngineType) {
		return false
	}

	if !v.RemoteEngineId.Equal(other.RemoteEngineId) {
		return false
	}

	if !v.Snmpv3Users.Equal(other.Snmpv3Users) {
		return false
	}

	return true
}

func (v UsmValue) Type(ctx context.Context) attr.Type {
	return UsmType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v UsmValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"engine_type":      basetypes.StringType{},
		"remote_engine_id": basetypes.StringType{},
		"users": basetypes.ListType{
			ElemType: Snmpv3UsersValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = Snmpv3UsersType{}

type Snmpv3UsersType struct {
	basetypes.ObjectType
}

func (t Snmpv3UsersType) Equal(o attr.Type) bool {
	other, ok := o.(Snmpv3UsersType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Snmpv3UsersType) String() string {
	return "Snmpv3UsersType"
}

func (t Snmpv3UsersType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	authenticationPasswordAttribute, ok := attributes["authentication_password"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`authentication_password is missing from object`)

		return nil, diags
	}

	authenticationPasswordVal, ok := authenticationPasswordAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`authentication_password expected to be basetypes.StringValue, was: %T`, authenticationPasswordAttribute))
	}

	authenticationTypeAttribute, ok := attributes["authentication_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`authentication_type is missing from object`)

		return nil, diags
	}

	authenticationTypeVal, ok := authenticationTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`authentication_type expected to be basetypes.StringValue, was: %T`, authenticationTypeAttribute))
	}

	encryptionPasswordAttribute, ok := attributes["encryption_password"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`encryption_password is missing from object`)

		return nil, diags
	}

	encryptionPasswordVal, ok := encryptionPasswordAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`encryption_password expected to be basetypes.StringValue, was: %T`, encryptionPasswordAttribute))
	}

	encryptionTypeAttribute, ok := attributes["encryption_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`encryption_type is missing from object`)

		return nil, diags
	}

	encryptionTypeVal, ok := encryptionTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`encryption_type expected to be basetypes.StringValue, was: %T`, encryptionTypeAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Snmpv3UsersValue{
		AuthenticationPassword: authenticationPasswordVal,
		AuthenticationType:     authenticationTypeVal,
		EncryptionPassword:     encryptionPasswordVal,
		EncryptionType:         encryptionTypeVal,
		Name:                   nameVal,
		state:                  attr.ValueStateKnown,
	}, diags
}

func NewSnmpv3UsersValueNull() Snmpv3UsersValue {
	return Snmpv3UsersValue{
		state: attr.ValueStateNull,
	}
}

func NewSnmpv3UsersValueUnknown() Snmpv3UsersValue {
	return Snmpv3UsersValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSnmpv3UsersValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Snmpv3UsersValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Snmpv3UsersValue Attribute Value",
				"While creating a Snmpv3UsersValue value, a missing attribute value was detected. "+
					"A Snmpv3UsersValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Snmpv3UsersValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Snmpv3UsersValue Attribute Type",
				"While creating a Snmpv3UsersValue value, an invalid attribute value was detected. "+
					"A Snmpv3UsersValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Snmpv3UsersValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Snmpv3UsersValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Snmpv3UsersValue Attribute Value",
				"While creating a Snmpv3UsersValue value, an extra attribute value was detected. "+
					"A Snmpv3UsersValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Snmpv3UsersValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSnmpv3UsersValueUnknown(), diags
	}

	authenticationPasswordAttribute, ok := attributes["authentication_password"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`authentication_password is missing from object`)

		return NewSnmpv3UsersValueUnknown(), diags
	}

	authenticationPasswordVal, ok := authenticationPasswordAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`authentication_password expected to be basetypes.StringValue, was: %T`, authenticationPasswordAttribute))
	}

	authenticationTypeAttribute, ok := attributes["authentication_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`authentication_type is missing from object`)

		return NewSnmpv3UsersValueUnknown(), diags
	}

	authenticationTypeVal, ok := authenticationTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`authentication_type expected to be basetypes.StringValue, was: %T`, authenticationTypeAttribute))
	}

	encryptionPasswordAttribute, ok := attributes["encryption_password"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`encryption_password is missing from object`)

		return NewSnmpv3UsersValueUnknown(), diags
	}

	encryptionPasswordVal, ok := encryptionPasswordAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`encryption_password expected to be basetypes.StringValue, was: %T`, encryptionPasswordAttribute))
	}

	encryptionTypeAttribute, ok := attributes["encryption_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`encryption_type is missing from object`)

		return NewSnmpv3UsersValueUnknown(), diags
	}

	encryptionTypeVal, ok := encryptionTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`encryption_type expected to be basetypes.StringValue, was: %T`, encryptionTypeAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewSnmpv3UsersValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	if diags.HasError() {
		return NewSnmpv3UsersValueUnknown(), diags
	}

	return Snmpv3UsersValue{
		AuthenticationPassword: authenticationPasswordVal,
		AuthenticationType:     authenticationTypeVal,
		EncryptionPassword:     encryptionPasswordVal,
		EncryptionType:         encryptionTypeVal,
		Name:                   nameVal,
		state:                  attr.ValueStateKnown,
	}, diags
}

func NewSnmpv3UsersValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Snmpv3UsersValue {
	object, diags := NewSnmpv3UsersValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSnmpv3UsersValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Snmpv3UsersType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSnmpv3UsersValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSnmpv3UsersValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSnmpv3UsersValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSnmpv3UsersValueMust(Snmpv3UsersValue{}.AttributeTypes(ctx), attributes), nil
}

func (t Snmpv3UsersType) ValueType(ctx context.Context) attr.Value {
	return Snmpv3UsersValue{}
}

var _ basetypes.ObjectValuable = Snmpv3UsersValue{}

type Snmpv3UsersValue struct {
	AuthenticationPassword basetypes.StringValue `tfsdk:"authentication_password"`
	AuthenticationType     basetypes.StringValue `tfsdk:"authentication_type"`
	EncryptionPassword     basetypes.StringValue `tfsdk:"encryption_password"`
	EncryptionType         basetypes.StringValue `tfsdk:"encryption_type"`
	Name                   basetypes.StringValue `tfsdk:"name"`
	state                  attr.ValueState
}

func (v Snmpv3UsersValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["authentication_password"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["authentication_type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["encryption_password"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["encryption_type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.AuthenticationPassword.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["authentication_password"] = val

		val, err = v.AuthenticationType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["authentication_type"] = val

		val, err = v.EncryptionPassword.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["encryption_password"] = val

		val, err = v.EncryptionType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["encryption_type"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Snmpv3UsersValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Snmpv3UsersValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Snmpv3UsersValue) String() string {
	return "Snmpv3UsersValue"
}

func (v Snmpv3UsersValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"authentication_password": basetypes.StringType{},
		"authentication_type":     basetypes.StringType{},
		"encryption_password":     basetypes.StringType{},
		"encryption_type":         basetypes.StringType{},
		"name":                    basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"authentication_password": v.AuthenticationPassword,
			"authentication_type":     v.AuthenticationType,
			"encryption_password":     v.EncryptionPassword,
			"encryption_type":         v.EncryptionType,
			"name":                    v.Name,
		})

	return objVal, diags
}

func (v Snmpv3UsersValue) Equal(o attr.Value) bool {
	other, ok := o.(Snmpv3UsersValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AuthenticationPassword.Equal(other.AuthenticationPassword) {
		return false
	}

	if !v.AuthenticationType.Equal(other.AuthenticationType) {
		return false
	}

	if !v.EncryptionPassword.Equal(other.EncryptionPassword) {
		return false
	}

	if !v.EncryptionType.Equal(other.EncryptionType) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	return true
}

func (v Snmpv3UsersValue) Type(ctx context.Context) attr.Type {
	return Snmpv3UsersType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Snmpv3UsersValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"authentication_password": basetypes.StringType{},
		"authentication_type":     basetypes.StringType{},
		"encryption_password":     basetypes.StringType{},
		"encryption_type":         basetypes.StringType{},
		"name":                    basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = VacmType{}

type VacmType struct {
	basetypes.ObjectType
}

func (t VacmType) Equal(o attr.Type) bool {
	other, ok := o.(VacmType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t VacmType) String() string {
	return "VacmType"
}

func (t VacmType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	accessAttribute, ok := attributes["access"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`access is missing from object`)

		return nil, diags
	}

	accessVal, ok := accessAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`access expected to be basetypes.ListValue, was: %T`, accessAttribute))
	}

	securityToGroupAttribute, ok := attributes["security_to_group"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`security_to_group is missing from object`)

		return nil, diags
	}

	securityToGroupVal, ok := securityToGroupAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`security_to_group expected to be basetypes.ObjectValue, was: %T`, securityToGroupAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return VacmValue{
		Access:          accessVal,
		SecurityToGroup: securityToGroupVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewVacmValueNull() VacmValue {
	return VacmValue{
		state: attr.ValueStateNull,
	}
}

func NewVacmValueUnknown() VacmValue {
	return VacmValue{
		state: attr.ValueStateUnknown,
	}
}

func NewVacmValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (VacmValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing VacmValue Attribute Value",
				"While creating a VacmValue value, a missing attribute value was detected. "+
					"A VacmValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VacmValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid VacmValue Attribute Type",
				"While creating a VacmValue value, an invalid attribute value was detected. "+
					"A VacmValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VacmValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("VacmValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra VacmValue Attribute Value",
				"While creating a VacmValue value, an extra attribute value was detected. "+
					"A VacmValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra VacmValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewVacmValueUnknown(), diags
	}

	accessAttribute, ok := attributes["access"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`access is missing from object`)

		return NewVacmValueUnknown(), diags
	}

	accessVal, ok := accessAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`access expected to be basetypes.ListValue, was: %T`, accessAttribute))
	}

	securityToGroupAttribute, ok := attributes["security_to_group"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`security_to_group is missing from object`)

		return NewVacmValueUnknown(), diags
	}

	securityToGroupVal, ok := securityToGroupAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`security_to_group expected to be basetypes.ObjectValue, was: %T`, securityToGroupAttribute))
	}

	if diags.HasError() {
		return NewVacmValueUnknown(), diags
	}

	return VacmValue{
		Access:          accessVal,
		SecurityToGroup: securityToGroupVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewVacmValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) VacmValue {
	object, diags := NewVacmValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewVacmValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t VacmType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewVacmValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewVacmValueUnknown(), nil
	}

	if in.IsNull() {
		return NewVacmValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewVacmValueMust(VacmValue{}.AttributeTypes(ctx), attributes), nil
}

func (t VacmType) ValueType(ctx context.Context) attr.Value {
	return VacmValue{}
}

var _ basetypes.ObjectValuable = VacmValue{}

type VacmValue struct {
	Access          basetypes.ListValue   `tfsdk:"access"`
	SecurityToGroup basetypes.ObjectValue `tfsdk:"security_to_group"`
	state           attr.ValueState
}

func (v VacmValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["access"] = basetypes.ListType{
		ElemType: AccessValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["security_to_group"] = basetypes.ObjectType{
		AttrTypes: SecurityToGroupValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Access.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["access"] = val

		val, err = v.SecurityToGroup.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["security_to_group"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v VacmValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v VacmValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v VacmValue) String() string {
	return "VacmValue"
}

func (v VacmValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	access := types.ListValueMust(
		AccessType{
			basetypes.ObjectType{
				AttrTypes: AccessValue{}.AttributeTypes(ctx),
			},
		},
		v.Access.Elements(),
	)

	if v.Access.IsNull() {
		access = types.ListNull(
			AccessType{
				basetypes.ObjectType{
					AttrTypes: AccessValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Access.IsUnknown() {
		access = types.ListUnknown(
			AccessType{
				basetypes.ObjectType{
					AttrTypes: AccessValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var securityToGroup basetypes.ObjectValue

	if v.SecurityToGroup.IsNull() {
		securityToGroup = types.ObjectNull(
			SecurityToGroupValue{}.AttributeTypes(ctx),
		)
	}

	if v.SecurityToGroup.IsUnknown() {
		securityToGroup = types.ObjectUnknown(
			SecurityToGroupValue{}.AttributeTypes(ctx),
		)
	}

	if !v.SecurityToGroup.IsNull() && !v.SecurityToGroup.IsUnknown() {
		securityToGroup = types.ObjectValueMust(
			SecurityToGroupValue{}.AttributeTypes(ctx),
			v.SecurityToGroup.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"access": basetypes.ListType{
			ElemType: AccessValue{}.Type(ctx),
		},
		"security_to_group": basetypes.ObjectType{
			AttrTypes: SecurityToGroupValue{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"access":            access,
			"security_to_group": securityToGroup,
		})

	return objVal, diags
}

func (v VacmValue) Equal(o attr.Value) bool {
	other, ok := o.(VacmValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Access.Equal(other.Access) {
		return false
	}

	if !v.SecurityToGroup.Equal(other.SecurityToGroup) {
		return false
	}

	return true
}

func (v VacmValue) Type(ctx context.Context) attr.Type {
	return VacmType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v VacmValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"access": basetypes.ListType{
			ElemType: AccessValue{}.Type(ctx),
		},
		"security_to_group": basetypes.ObjectType{
			AttrTypes: SecurityToGroupValue{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = AccessType{}

type AccessType struct {
	basetypes.ObjectType
}

func (t AccessType) Equal(o attr.Type) bool {
	other, ok := o.(AccessType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AccessType) String() string {
	return "AccessType"
}

func (t AccessType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	groupNameAttribute, ok := attributes["group_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`group_name is missing from object`)

		return nil, diags
	}

	groupNameVal, ok := groupNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`group_name expected to be basetypes.StringValue, was: %T`, groupNameAttribute))
	}

	prefixListAttribute, ok := attributes["prefix_list"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix_list is missing from object`)

		return nil, diags
	}

	prefixListVal, ok := prefixListAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix_list expected to be basetypes.ListValue, was: %T`, prefixListAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AccessValue{
		GroupName:  groupNameVal,
		PrefixList: prefixListVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewAccessValueNull() AccessValue {
	return AccessValue{
		state: attr.ValueStateNull,
	}
}

func NewAccessValueUnknown() AccessValue {
	return AccessValue{
		state: attr.ValueStateUnknown,
	}
}

func NewAccessValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AccessValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AccessValue Attribute Value",
				"While creating a AccessValue value, a missing attribute value was detected. "+
					"A AccessValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AccessValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AccessValue Attribute Type",
				"While creating a AccessValue value, an invalid attribute value was detected. "+
					"A AccessValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AccessValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AccessValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AccessValue Attribute Value",
				"While creating a AccessValue value, an extra attribute value was detected. "+
					"A AccessValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AccessValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAccessValueUnknown(), diags
	}

	groupNameAttribute, ok := attributes["group_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`group_name is missing from object`)

		return NewAccessValueUnknown(), diags
	}

	groupNameVal, ok := groupNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`group_name expected to be basetypes.StringValue, was: %T`, groupNameAttribute))
	}

	prefixListAttribute, ok := attributes["prefix_list"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix_list is missing from object`)

		return NewAccessValueUnknown(), diags
	}

	prefixListVal, ok := prefixListAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix_list expected to be basetypes.ListValue, was: %T`, prefixListAttribute))
	}

	if diags.HasError() {
		return NewAccessValueUnknown(), diags
	}

	return AccessValue{
		GroupName:  groupNameVal,
		PrefixList: prefixListVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewAccessValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AccessValue {
	object, diags := NewAccessValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAccessValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AccessType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAccessValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAccessValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAccessValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAccessValueMust(AccessValue{}.AttributeTypes(ctx), attributes), nil
}

func (t AccessType) ValueType(ctx context.Context) attr.Value {
	return AccessValue{}
}

var _ basetypes.ObjectValuable = AccessValue{}

type AccessValue struct {
	GroupName  basetypes.StringValue `tfsdk:"group_name"`
	PrefixList basetypes.ListValue   `tfsdk:"prefix_list"`
	state      attr.ValueState
}

func (v AccessValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["group_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["prefix_list"] = basetypes.ListType{
		ElemType: PrefixListValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.GroupName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["group_name"] = val

		val, err = v.PrefixList.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["prefix_list"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AccessValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AccessValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AccessValue) String() string {
	return "AccessValue"
}

func (v AccessValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	prefixList := types.ListValueMust(
		PrefixListType{
			basetypes.ObjectType{
				AttrTypes: PrefixListValue{}.AttributeTypes(ctx),
			},
		},
		v.PrefixList.Elements(),
	)

	if v.PrefixList.IsNull() {
		prefixList = types.ListNull(
			PrefixListType{
				basetypes.ObjectType{
					AttrTypes: PrefixListValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.PrefixList.IsUnknown() {
		prefixList = types.ListUnknown(
			PrefixListType{
				basetypes.ObjectType{
					AttrTypes: PrefixListValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"group_name": basetypes.StringType{},
		"prefix_list": basetypes.ListType{
			ElemType: PrefixListValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"group_name":  v.GroupName,
			"prefix_list": prefixList,
		})

	return objVal, diags
}

func (v AccessValue) Equal(o attr.Value) bool {
	other, ok := o.(AccessValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.GroupName.Equal(other.GroupName) {
		return false
	}

	if !v.PrefixList.Equal(other.PrefixList) {
		return false
	}

	return true
}

func (v AccessValue) Type(ctx context.Context) attr.Type {
	return AccessType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AccessValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"group_name": basetypes.StringType{},
		"prefix_list": basetypes.ListType{
			ElemType: PrefixListValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = PrefixListType{}

type PrefixListType struct {
	basetypes.ObjectType
}

func (t PrefixListType) Equal(o attr.Type) bool {
	other, ok := o.(PrefixListType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PrefixListType) String() string {
	return "PrefixListType"
}

func (t PrefixListType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	contextPrefixAttribute, ok := attributes["context_prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`context_prefix is missing from object`)

		return nil, diags
	}

	contextPrefixVal, ok := contextPrefixAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`context_prefix expected to be basetypes.StringValue, was: %T`, contextPrefixAttribute))
	}

	notifyViewAttribute, ok := attributes["notify_view"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`notify_view is missing from object`)

		return nil, diags
	}

	notifyViewVal, ok := notifyViewAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`notify_view expected to be basetypes.StringValue, was: %T`, notifyViewAttribute))
	}

	readViewAttribute, ok := attributes["read_view"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`read_view is missing from object`)

		return nil, diags
	}

	readViewVal, ok := readViewAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`read_view expected to be basetypes.StringValue, was: %T`, readViewAttribute))
	}

	securityLevelAttribute, ok := attributes["security_level"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`security_level is missing from object`)

		return nil, diags
	}

	securityLevelVal, ok := securityLevelAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`security_level expected to be basetypes.StringValue, was: %T`, securityLevelAttribute))
	}

	securityModelAttribute, ok := attributes["security_model"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`security_model is missing from object`)

		return nil, diags
	}

	securityModelVal, ok := securityModelAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`security_model expected to be basetypes.StringValue, was: %T`, securityModelAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	writeViewAttribute, ok := attributes["write_view"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`write_view is missing from object`)

		return nil, diags
	}

	writeViewVal, ok := writeViewAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`write_view expected to be basetypes.StringValue, was: %T`, writeViewAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PrefixListValue{
		ContextPrefix:  contextPrefixVal,
		NotifyView:     notifyViewVal,
		ReadView:       readViewVal,
		SecurityLevel:  securityLevelVal,
		SecurityModel:  securityModelVal,
		PrefixListType: typeVal,
		WriteView:      writeViewVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewPrefixListValueNull() PrefixListValue {
	return PrefixListValue{
		state: attr.ValueStateNull,
	}
}

func NewPrefixListValueUnknown() PrefixListValue {
	return PrefixListValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPrefixListValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PrefixListValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PrefixListValue Attribute Value",
				"While creating a PrefixListValue value, a missing attribute value was detected. "+
					"A PrefixListValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PrefixListValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PrefixListValue Attribute Type",
				"While creating a PrefixListValue value, an invalid attribute value was detected. "+
					"A PrefixListValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PrefixListValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PrefixListValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PrefixListValue Attribute Value",
				"While creating a PrefixListValue value, an extra attribute value was detected. "+
					"A PrefixListValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PrefixListValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPrefixListValueUnknown(), diags
	}

	contextPrefixAttribute, ok := attributes["context_prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`context_prefix is missing from object`)

		return NewPrefixListValueUnknown(), diags
	}

	contextPrefixVal, ok := contextPrefixAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`context_prefix expected to be basetypes.StringValue, was: %T`, contextPrefixAttribute))
	}

	notifyViewAttribute, ok := attributes["notify_view"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`notify_view is missing from object`)

		return NewPrefixListValueUnknown(), diags
	}

	notifyViewVal, ok := notifyViewAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`notify_view expected to be basetypes.StringValue, was: %T`, notifyViewAttribute))
	}

	readViewAttribute, ok := attributes["read_view"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`read_view is missing from object`)

		return NewPrefixListValueUnknown(), diags
	}

	readViewVal, ok := readViewAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`read_view expected to be basetypes.StringValue, was: %T`, readViewAttribute))
	}

	securityLevelAttribute, ok := attributes["security_level"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`security_level is missing from object`)

		return NewPrefixListValueUnknown(), diags
	}

	securityLevelVal, ok := securityLevelAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`security_level expected to be basetypes.StringValue, was: %T`, securityLevelAttribute))
	}

	securityModelAttribute, ok := attributes["security_model"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`security_model is missing from object`)

		return NewPrefixListValueUnknown(), diags
	}

	securityModelVal, ok := securityModelAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`security_model expected to be basetypes.StringValue, was: %T`, securityModelAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewPrefixListValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	writeViewAttribute, ok := attributes["write_view"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`write_view is missing from object`)

		return NewPrefixListValueUnknown(), diags
	}

	writeViewVal, ok := writeViewAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`write_view expected to be basetypes.StringValue, was: %T`, writeViewAttribute))
	}

	if diags.HasError() {
		return NewPrefixListValueUnknown(), diags
	}

	return PrefixListValue{
		ContextPrefix:  contextPrefixVal,
		NotifyView:     notifyViewVal,
		ReadView:       readViewVal,
		SecurityLevel:  securityLevelVal,
		SecurityModel:  securityModelVal,
		PrefixListType: typeVal,
		WriteView:      writeViewVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewPrefixListValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PrefixListValue {
	object, diags := NewPrefixListValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPrefixListValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PrefixListType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPrefixListValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPrefixListValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPrefixListValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPrefixListValueMust(PrefixListValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PrefixListType) ValueType(ctx context.Context) attr.Value {
	return PrefixListValue{}
}

var _ basetypes.ObjectValuable = PrefixListValue{}

type PrefixListValue struct {
	ContextPrefix  basetypes.StringValue `tfsdk:"context_prefix"`
	NotifyView     basetypes.StringValue `tfsdk:"notify_view"`
	ReadView       basetypes.StringValue `tfsdk:"read_view"`
	SecurityLevel  basetypes.StringValue `tfsdk:"security_level"`
	SecurityModel  basetypes.StringValue `tfsdk:"security_model"`
	PrefixListType basetypes.StringValue `tfsdk:"type"`
	WriteView      basetypes.StringValue `tfsdk:"write_view"`
	state          attr.ValueState
}

func (v PrefixListValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 7)

	var val tftypes.Value
	var err error

	attrTypes["context_prefix"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["notify_view"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["read_view"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["security_level"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["security_model"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["write_view"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 7)

		val, err = v.ContextPrefix.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["context_prefix"] = val

		val, err = v.NotifyView.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["notify_view"] = val

		val, err = v.ReadView.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["read_view"] = val

		val, err = v.SecurityLevel.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["security_level"] = val

		val, err = v.SecurityModel.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["security_model"] = val

		val, err = v.PrefixListType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		val, err = v.WriteView.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["write_view"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PrefixListValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PrefixListValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PrefixListValue) String() string {
	return "PrefixListValue"
}

func (v PrefixListValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"context_prefix": basetypes.StringType{},
		"notify_view":    basetypes.StringType{},
		"read_view":      basetypes.StringType{},
		"security_level": basetypes.StringType{},
		"security_model": basetypes.StringType{},
		"type":           basetypes.StringType{},
		"write_view":     basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"context_prefix": v.ContextPrefix,
			"notify_view":    v.NotifyView,
			"read_view":      v.ReadView,
			"security_level": v.SecurityLevel,
			"security_model": v.SecurityModel,
			"type":           v.PrefixListType,
			"write_view":     v.WriteView,
		})

	return objVal, diags
}

func (v PrefixListValue) Equal(o attr.Value) bool {
	other, ok := o.(PrefixListValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.ContextPrefix.Equal(other.ContextPrefix) {
		return false
	}

	if !v.NotifyView.Equal(other.NotifyView) {
		return false
	}

	if !v.ReadView.Equal(other.ReadView) {
		return false
	}

	if !v.SecurityLevel.Equal(other.SecurityLevel) {
		return false
	}

	if !v.SecurityModel.Equal(other.SecurityModel) {
		return false
	}

	if !v.PrefixListType.Equal(other.PrefixListType) {
		return false
	}

	if !v.WriteView.Equal(other.WriteView) {
		return false
	}

	return true
}

func (v PrefixListValue) Type(ctx context.Context) attr.Type {
	return PrefixListType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PrefixListValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"context_prefix": basetypes.StringType{},
		"notify_view":    basetypes.StringType{},
		"read_view":      basetypes.StringType{},
		"security_level": basetypes.StringType{},
		"security_model": basetypes.StringType{},
		"type":           basetypes.StringType{},
		"write_view":     basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = SecurityToGroupType{}

type SecurityToGroupType struct {
	basetypes.ObjectType
}

func (t SecurityToGroupType) Equal(o attr.Type) bool {
	other, ok := o.(SecurityToGroupType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SecurityToGroupType) String() string {
	return "SecurityToGroupType"
}

func (t SecurityToGroupType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	securityModelAttribute, ok := attributes["security_model"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`security_model is missing from object`)

		return nil, diags
	}

	securityModelVal, ok := securityModelAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`security_model expected to be basetypes.StringValue, was: %T`, securityModelAttribute))
	}

	snmpv3VacmContentAttribute, ok := attributes["content"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`content is missing from object`)

		return nil, diags
	}

	snmpv3VacmContentVal, ok := snmpv3VacmContentAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`content expected to be basetypes.ListValue, was: %T`, snmpv3VacmContentAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SecurityToGroupValue{
		SecurityModel:     securityModelVal,
		Snmpv3VacmContent: snmpv3VacmContentVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewSecurityToGroupValueNull() SecurityToGroupValue {
	return SecurityToGroupValue{
		state: attr.ValueStateNull,
	}
}

func NewSecurityToGroupValueUnknown() SecurityToGroupValue {
	return SecurityToGroupValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSecurityToGroupValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SecurityToGroupValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SecurityToGroupValue Attribute Value",
				"While creating a SecurityToGroupValue value, a missing attribute value was detected. "+
					"A SecurityToGroupValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SecurityToGroupValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SecurityToGroupValue Attribute Type",
				"While creating a SecurityToGroupValue value, an invalid attribute value was detected. "+
					"A SecurityToGroupValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SecurityToGroupValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SecurityToGroupValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SecurityToGroupValue Attribute Value",
				"While creating a SecurityToGroupValue value, an extra attribute value was detected. "+
					"A SecurityToGroupValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SecurityToGroupValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSecurityToGroupValueUnknown(), diags
	}

	securityModelAttribute, ok := attributes["security_model"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`security_model is missing from object`)

		return NewSecurityToGroupValueUnknown(), diags
	}

	securityModelVal, ok := securityModelAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`security_model expected to be basetypes.StringValue, was: %T`, securityModelAttribute))
	}

	snmpv3VacmContentAttribute, ok := attributes["content"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`content is missing from object`)

		return NewSecurityToGroupValueUnknown(), diags
	}

	snmpv3VacmContentVal, ok := snmpv3VacmContentAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`content expected to be basetypes.ListValue, was: %T`, snmpv3VacmContentAttribute))
	}

	if diags.HasError() {
		return NewSecurityToGroupValueUnknown(), diags
	}

	return SecurityToGroupValue{
		SecurityModel:     securityModelVal,
		Snmpv3VacmContent: snmpv3VacmContentVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewSecurityToGroupValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SecurityToGroupValue {
	object, diags := NewSecurityToGroupValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSecurityToGroupValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SecurityToGroupType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSecurityToGroupValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSecurityToGroupValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSecurityToGroupValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSecurityToGroupValueMust(SecurityToGroupValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SecurityToGroupType) ValueType(ctx context.Context) attr.Value {
	return SecurityToGroupValue{}
}

var _ basetypes.ObjectValuable = SecurityToGroupValue{}

type SecurityToGroupValue struct {
	SecurityModel     basetypes.StringValue `tfsdk:"security_model"`
	Snmpv3VacmContent basetypes.ListValue   `tfsdk:"content"`
	state             attr.ValueState
}

func (v SecurityToGroupValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["security_model"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["content"] = basetypes.ListType{
		ElemType: Snmpv3VacmContentValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.SecurityModel.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["security_model"] = val

		val, err = v.Snmpv3VacmContent.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["content"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SecurityToGroupValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SecurityToGroupValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SecurityToGroupValue) String() string {
	return "SecurityToGroupValue"
}

func (v SecurityToGroupValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	snmpv3VacmContent := types.ListValueMust(
		Snmpv3VacmContentType{
			basetypes.ObjectType{
				AttrTypes: Snmpv3VacmContentValue{}.AttributeTypes(ctx),
			},
		},
		v.Snmpv3VacmContent.Elements(),
	)

	if v.Snmpv3VacmContent.IsNull() {
		snmpv3VacmContent = types.ListNull(
			Snmpv3VacmContentType{
				basetypes.ObjectType{
					AttrTypes: Snmpv3VacmContentValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Snmpv3VacmContent.IsUnknown() {
		snmpv3VacmContent = types.ListUnknown(
			Snmpv3VacmContentType{
				basetypes.ObjectType{
					AttrTypes: Snmpv3VacmContentValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"security_model": basetypes.StringType{},
		"content": basetypes.ListType{
			ElemType: Snmpv3VacmContentValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"security_model": v.SecurityModel,
			"content":        snmpv3VacmContent,
		})

	return objVal, diags
}

func (v SecurityToGroupValue) Equal(o attr.Value) bool {
	other, ok := o.(SecurityToGroupValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.SecurityModel.Equal(other.SecurityModel) {
		return false
	}

	if !v.Snmpv3VacmContent.Equal(other.Snmpv3VacmContent) {
		return false
	}

	return true
}

func (v SecurityToGroupValue) Type(ctx context.Context) attr.Type {
	return SecurityToGroupType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SecurityToGroupValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"security_model": basetypes.StringType{},
		"content": basetypes.ListType{
			ElemType: Snmpv3VacmContentValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = Snmpv3VacmContentType{}

type Snmpv3VacmContentType struct {
	basetypes.ObjectType
}

func (t Snmpv3VacmContentType) Equal(o attr.Type) bool {
	other, ok := o.(Snmpv3VacmContentType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Snmpv3VacmContentType) String() string {
	return "Snmpv3VacmContentType"
}

func (t Snmpv3VacmContentType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	groupAttribute, ok := attributes["group"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`group is missing from object`)

		return nil, diags
	}

	groupVal, ok := groupAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`group expected to be basetypes.StringValue, was: %T`, groupAttribute))
	}

	securityNameAttribute, ok := attributes["security_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`security_name is missing from object`)

		return nil, diags
	}

	securityNameVal, ok := securityNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`security_name expected to be basetypes.StringValue, was: %T`, securityNameAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Snmpv3VacmContentValue{
		Group:        groupVal,
		SecurityName: securityNameVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewSnmpv3VacmContentValueNull() Snmpv3VacmContentValue {
	return Snmpv3VacmContentValue{
		state: attr.ValueStateNull,
	}
}

func NewSnmpv3VacmContentValueUnknown() Snmpv3VacmContentValue {
	return Snmpv3VacmContentValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSnmpv3VacmContentValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Snmpv3VacmContentValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Snmpv3VacmContentValue Attribute Value",
				"While creating a Snmpv3VacmContentValue value, a missing attribute value was detected. "+
					"A Snmpv3VacmContentValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Snmpv3VacmContentValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Snmpv3VacmContentValue Attribute Type",
				"While creating a Snmpv3VacmContentValue value, an invalid attribute value was detected. "+
					"A Snmpv3VacmContentValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Snmpv3VacmContentValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Snmpv3VacmContentValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Snmpv3VacmContentValue Attribute Value",
				"While creating a Snmpv3VacmContentValue value, an extra attribute value was detected. "+
					"A Snmpv3VacmContentValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Snmpv3VacmContentValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSnmpv3VacmContentValueUnknown(), diags
	}

	groupAttribute, ok := attributes["group"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`group is missing from object`)

		return NewSnmpv3VacmContentValueUnknown(), diags
	}

	groupVal, ok := groupAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`group expected to be basetypes.StringValue, was: %T`, groupAttribute))
	}

	securityNameAttribute, ok := attributes["security_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`security_name is missing from object`)

		return NewSnmpv3VacmContentValueUnknown(), diags
	}

	securityNameVal, ok := securityNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`security_name expected to be basetypes.StringValue, was: %T`, securityNameAttribute))
	}

	if diags.HasError() {
		return NewSnmpv3VacmContentValueUnknown(), diags
	}

	return Snmpv3VacmContentValue{
		Group:        groupVal,
		SecurityName: securityNameVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewSnmpv3VacmContentValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Snmpv3VacmContentValue {
	object, diags := NewSnmpv3VacmContentValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSnmpv3VacmContentValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Snmpv3VacmContentType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSnmpv3VacmContentValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSnmpv3VacmContentValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSnmpv3VacmContentValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSnmpv3VacmContentValueMust(Snmpv3VacmContentValue{}.AttributeTypes(ctx), attributes), nil
}

func (t Snmpv3VacmContentType) ValueType(ctx context.Context) attr.Value {
	return Snmpv3VacmContentValue{}
}

var _ basetypes.ObjectValuable = Snmpv3VacmContentValue{}

type Snmpv3VacmContentValue struct {
	Group        basetypes.StringValue `tfsdk:"group"`
	SecurityName basetypes.StringValue `tfsdk:"security_name"`
	state        attr.ValueState
}

func (v Snmpv3VacmContentValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["group"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["security_name"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Group.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["group"] = val

		val, err = v.SecurityName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["security_name"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Snmpv3VacmContentValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Snmpv3VacmContentValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Snmpv3VacmContentValue) String() string {
	return "Snmpv3VacmContentValue"
}

func (v Snmpv3VacmContentValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"group":         basetypes.StringType{},
		"security_name": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"group":         v.Group,
			"security_name": v.SecurityName,
		})

	return objVal, diags
}

func (v Snmpv3VacmContentValue) Equal(o attr.Value) bool {
	other, ok := o.(Snmpv3VacmContentValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Group.Equal(other.Group) {
		return false
	}

	if !v.SecurityName.Equal(other.SecurityName) {
		return false
	}

	return true
}

func (v Snmpv3VacmContentValue) Type(ctx context.Context) attr.Type {
	return Snmpv3VacmContentType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Snmpv3VacmContentValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"group":         basetypes.StringType{},
		"security_name": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = ViewsType{}

type ViewsType struct {
	basetypes.ObjectType
}

func (t ViewsType) Equal(o attr.Type) bool {
	other, ok := o.(ViewsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ViewsType) String() string {
	return "ViewsType"
}

func (t ViewsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	includeAttribute, ok := attributes["include"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`include is missing from object`)

		return nil, diags
	}

	includeVal, ok := includeAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`include expected to be basetypes.BoolValue, was: %T`, includeAttribute))
	}

	oidAttribute, ok := attributes["oid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`oid is missing from object`)

		return nil, diags
	}

	oidVal, ok := oidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`oid expected to be basetypes.StringValue, was: %T`, oidAttribute))
	}

	viewNameAttribute, ok := attributes["view_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`view_name is missing from object`)

		return nil, diags
	}

	viewNameVal, ok := viewNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`view_name expected to be basetypes.StringValue, was: %T`, viewNameAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ViewsValue{
		Include:  includeVal,
		Oid:      oidVal,
		ViewName: viewNameVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewViewsValueNull() ViewsValue {
	return ViewsValue{
		state: attr.ValueStateNull,
	}
}

func NewViewsValueUnknown() ViewsValue {
	return ViewsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewViewsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ViewsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ViewsValue Attribute Value",
				"While creating a ViewsValue value, a missing attribute value was detected. "+
					"A ViewsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ViewsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ViewsValue Attribute Type",
				"While creating a ViewsValue value, an invalid attribute value was detected. "+
					"A ViewsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ViewsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ViewsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ViewsValue Attribute Value",
				"While creating a ViewsValue value, an extra attribute value was detected. "+
					"A ViewsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ViewsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewViewsValueUnknown(), diags
	}

	includeAttribute, ok := attributes["include"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`include is missing from object`)

		return NewViewsValueUnknown(), diags
	}

	includeVal, ok := includeAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`include expected to be basetypes.BoolValue, was: %T`, includeAttribute))
	}

	oidAttribute, ok := attributes["oid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`oid is missing from object`)

		return NewViewsValueUnknown(), diags
	}

	oidVal, ok := oidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`oid expected to be basetypes.StringValue, was: %T`, oidAttribute))
	}

	viewNameAttribute, ok := attributes["view_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`view_name is missing from object`)

		return NewViewsValueUnknown(), diags
	}

	viewNameVal, ok := viewNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`view_name expected to be basetypes.StringValue, was: %T`, viewNameAttribute))
	}

	if diags.HasError() {
		return NewViewsValueUnknown(), diags
	}

	return ViewsValue{
		Include:  includeVal,
		Oid:      oidVal,
		ViewName: viewNameVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewViewsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ViewsValue {
	object, diags := NewViewsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewViewsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ViewsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewViewsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewViewsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewViewsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewViewsValueMust(ViewsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ViewsType) ValueType(ctx context.Context) attr.Value {
	return ViewsValue{}
}

var _ basetypes.ObjectValuable = ViewsValue{}

type ViewsValue struct {
	Include  basetypes.BoolValue   `tfsdk:"include"`
	Oid      basetypes.StringValue `tfsdk:"oid"`
	ViewName basetypes.StringValue `tfsdk:"view_name"`
	state    attr.ValueState
}

func (v ViewsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["include"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["oid"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["view_name"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Include.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["include"] = val

		val, err = v.Oid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["oid"] = val

		val, err = v.ViewName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["view_name"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ViewsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ViewsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ViewsValue) String() string {
	return "ViewsValue"
}

func (v ViewsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"include":   basetypes.BoolType{},
		"oid":       basetypes.StringType{},
		"view_name": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"include":   v.Include,
			"oid":       v.Oid,
			"view_name": v.ViewName,
		})

	return objVal, diags
}

func (v ViewsValue) Equal(o attr.Value) bool {
	other, ok := o.(ViewsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Include.Equal(other.Include) {
		return false
	}

	if !v.Oid.Equal(other.Oid) {
		return false
	}

	if !v.ViewName.Equal(other.ViewName) {
		return false
	}

	return true
}

func (v ViewsValue) Type(ctx context.Context) attr.Type {
	return ViewsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ViewsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"include":   basetypes.BoolType{},
		"oid":       basetypes.StringType{},
		"view_name": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = SwitchMatchingType{}

type SwitchMatchingType struct {
	basetypes.ObjectType
}

func (t SwitchMatchingType) Equal(o attr.Type) bool {
	other, ok := o.(SwitchMatchingType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SwitchMatchingType) String() string {
	return "SwitchMatchingType"
}

func (t SwitchMatchingType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	enableAttribute, ok := attributes["enable"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable is missing from object`)

		return nil, diags
	}

	enableVal, ok := enableAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable expected to be basetypes.BoolValue, was: %T`, enableAttribute))
	}

	matchingRulesAttribute, ok := attributes["rules"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rules is missing from object`)

		return nil, diags
	}

	matchingRulesVal, ok := matchingRulesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rules expected to be basetypes.ListValue, was: %T`, matchingRulesAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SwitchMatchingValue{
		Enable:        enableVal,
		MatchingRules: matchingRulesVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewSwitchMatchingValueNull() SwitchMatchingValue {
	return SwitchMatchingValue{
		state: attr.ValueStateNull,
	}
}

func NewSwitchMatchingValueUnknown() SwitchMatchingValue {
	return SwitchMatchingValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSwitchMatchingValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SwitchMatchingValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SwitchMatchingValue Attribute Value",
				"While creating a SwitchMatchingValue value, a missing attribute value was detected. "+
					"A SwitchMatchingValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SwitchMatchingValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SwitchMatchingValue Attribute Type",
				"While creating a SwitchMatchingValue value, an invalid attribute value was detected. "+
					"A SwitchMatchingValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SwitchMatchingValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SwitchMatchingValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SwitchMatchingValue Attribute Value",
				"While creating a SwitchMatchingValue value, an extra attribute value was detected. "+
					"A SwitchMatchingValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SwitchMatchingValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSwitchMatchingValueUnknown(), diags
	}

	enableAttribute, ok := attributes["enable"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable is missing from object`)

		return NewSwitchMatchingValueUnknown(), diags
	}

	enableVal, ok := enableAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable expected to be basetypes.BoolValue, was: %T`, enableAttribute))
	}

	matchingRulesAttribute, ok := attributes["rules"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rules is missing from object`)

		return NewSwitchMatchingValueUnknown(), diags
	}

	matchingRulesVal, ok := matchingRulesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rules expected to be basetypes.ListValue, was: %T`, matchingRulesAttribute))
	}

	if diags.HasError() {
		return NewSwitchMatchingValueUnknown(), diags
	}

	return SwitchMatchingValue{
		Enable:        enableVal,
		MatchingRules: matchingRulesVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewSwitchMatchingValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SwitchMatchingValue {
	object, diags := NewSwitchMatchingValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSwitchMatchingValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SwitchMatchingType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSwitchMatchingValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSwitchMatchingValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSwitchMatchingValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSwitchMatchingValueMust(SwitchMatchingValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SwitchMatchingType) ValueType(ctx context.Context) attr.Value {
	return SwitchMatchingValue{}
}

var _ basetypes.ObjectValuable = SwitchMatchingValue{}

type SwitchMatchingValue struct {
	Enable        basetypes.BoolValue `tfsdk:"enable"`
	MatchingRules basetypes.ListValue `tfsdk:"rules"`
	state         attr.ValueState
}

func (v SwitchMatchingValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["enable"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["rules"] = basetypes.ListType{
		ElemType: MatchingRulesValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Enable.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enable"] = val

		val, err = v.MatchingRules.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["rules"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SwitchMatchingValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SwitchMatchingValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SwitchMatchingValue) String() string {
	return "SwitchMatchingValue"
}

func (v SwitchMatchingValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	matchingRules := types.ListValueMust(
		MatchingRulesType{
			basetypes.ObjectType{
				AttrTypes: MatchingRulesValue{}.AttributeTypes(ctx),
			},
		},
		v.MatchingRules.Elements(),
	)

	if v.MatchingRules.IsNull() {
		matchingRules = types.ListNull(
			MatchingRulesType{
				basetypes.ObjectType{
					AttrTypes: MatchingRulesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.MatchingRules.IsUnknown() {
		matchingRules = types.ListUnknown(
			MatchingRulesType{
				basetypes.ObjectType{
					AttrTypes: MatchingRulesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"enable": basetypes.BoolType{},
		"rules": basetypes.ListType{
			ElemType: MatchingRulesValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"enable": v.Enable,
			"rules":  matchingRules,
		})

	return objVal, diags
}

func (v SwitchMatchingValue) Equal(o attr.Value) bool {
	other, ok := o.(SwitchMatchingValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Enable.Equal(other.Enable) {
		return false
	}

	if !v.MatchingRules.Equal(other.MatchingRules) {
		return false
	}

	return true
}

func (v SwitchMatchingValue) Type(ctx context.Context) attr.Type {
	return SwitchMatchingType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SwitchMatchingValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"enable": basetypes.BoolType{},
		"rules": basetypes.ListType{
			ElemType: MatchingRulesValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = MatchingRulesType{}

type MatchingRulesType struct {
	basetypes.ObjectType
}

func (t MatchingRulesType) Equal(o attr.Type) bool {
	other, ok := o.(MatchingRulesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t MatchingRulesType) String() string {
	return "MatchingRulesType"
}

func (t MatchingRulesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	additionalConfigCmdsAttribute, ok := attributes["additional_config_cmds"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`additional_config_cmds is missing from object`)

		return nil, diags
	}

	additionalConfigCmdsVal, ok := additionalConfigCmdsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`additional_config_cmds expected to be basetypes.ListValue, was: %T`, additionalConfigCmdsAttribute))
	}

	ipConfigAttribute, ok := attributes["ip_config"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_config is missing from object`)

		return nil, diags
	}

	ipConfigVal, ok := ipConfigAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_config expected to be basetypes.ObjectValue, was: %T`, ipConfigAttribute))
	}

	matchModelAttribute, ok := attributes["match_model"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`match_model is missing from object`)

		return nil, diags
	}

	matchModelVal, ok := matchModelAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`match_model expected to be basetypes.StringValue, was: %T`, matchModelAttribute))
	}

	matchNameAttribute, ok := attributes["match_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`match_name is missing from object`)

		return nil, diags
	}

	matchNameVal, ok := matchNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`match_name expected to be basetypes.StringValue, was: %T`, matchNameAttribute))
	}

	matchNameOffsetAttribute, ok := attributes["match_name_offset"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`match_name_offset is missing from object`)

		return nil, diags
	}

	matchNameOffsetVal, ok := matchNameOffsetAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`match_name_offset expected to be basetypes.Int64Value, was: %T`, matchNameOffsetAttribute))
	}

	matchRoleAttribute, ok := attributes["match_role"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`match_role is missing from object`)

		return nil, diags
	}

	matchRoleVal, ok := matchRoleAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`match_role expected to be basetypes.StringValue, was: %T`, matchRoleAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	oobIpConfigAttribute, ok := attributes["oob_ip_config"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`oob_ip_config is missing from object`)

		return nil, diags
	}

	oobIpConfigVal, ok := oobIpConfigAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`oob_ip_config expected to be basetypes.ObjectValue, was: %T`, oobIpConfigAttribute))
	}

	portConfigAttribute, ok := attributes["port_config"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_config is missing from object`)

		return nil, diags
	}

	portConfigVal, ok := portConfigAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_config expected to be basetypes.MapValue, was: %T`, portConfigAttribute))
	}

	portMirroringAttribute, ok := attributes["port_mirroring"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_mirroring is missing from object`)

		return nil, diags
	}

	portMirroringVal, ok := portMirroringAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_mirroring expected to be basetypes.MapValue, was: %T`, portMirroringAttribute))
	}

	stpConfigAttribute, ok := attributes["stp_config"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`stp_config is missing from object`)

		return nil, diags
	}

	stpConfigVal, ok := stpConfigAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`stp_config expected to be basetypes.ObjectValue, was: %T`, stpConfigAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return MatchingRulesValue{
		AdditionalConfigCmds: additionalConfigCmdsVal,
		IpConfig:             ipConfigVal,
		MatchModel:           matchModelVal,
		MatchName:            matchNameVal,
		MatchNameOffset:      matchNameOffsetVal,
		MatchRole:            matchRoleVal,
		Name:                 nameVal,
		OobIpConfig:          oobIpConfigVal,
		PortConfig:           portConfigVal,
		PortMirroring:        portMirroringVal,
		StpConfig:            stpConfigVal,
		state:                attr.ValueStateKnown,
	}, diags
}

func NewMatchingRulesValueNull() MatchingRulesValue {
	return MatchingRulesValue{
		state: attr.ValueStateNull,
	}
}

func NewMatchingRulesValueUnknown() MatchingRulesValue {
	return MatchingRulesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewMatchingRulesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (MatchingRulesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing MatchingRulesValue Attribute Value",
				"While creating a MatchingRulesValue value, a missing attribute value was detected. "+
					"A MatchingRulesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MatchingRulesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid MatchingRulesValue Attribute Type",
				"While creating a MatchingRulesValue value, an invalid attribute value was detected. "+
					"A MatchingRulesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MatchingRulesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("MatchingRulesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra MatchingRulesValue Attribute Value",
				"While creating a MatchingRulesValue value, an extra attribute value was detected. "+
					"A MatchingRulesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra MatchingRulesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewMatchingRulesValueUnknown(), diags
	}

	additionalConfigCmdsAttribute, ok := attributes["additional_config_cmds"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`additional_config_cmds is missing from object`)

		return NewMatchingRulesValueUnknown(), diags
	}

	additionalConfigCmdsVal, ok := additionalConfigCmdsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`additional_config_cmds expected to be basetypes.ListValue, was: %T`, additionalConfigCmdsAttribute))
	}

	ipConfigAttribute, ok := attributes["ip_config"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_config is missing from object`)

		return NewMatchingRulesValueUnknown(), diags
	}

	ipConfigVal, ok := ipConfigAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_config expected to be basetypes.ObjectValue, was: %T`, ipConfigAttribute))
	}

	matchModelAttribute, ok := attributes["match_model"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`match_model is missing from object`)

		return NewMatchingRulesValueUnknown(), diags
	}

	matchModelVal, ok := matchModelAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`match_model expected to be basetypes.StringValue, was: %T`, matchModelAttribute))
	}

	matchNameAttribute, ok := attributes["match_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`match_name is missing from object`)

		return NewMatchingRulesValueUnknown(), diags
	}

	matchNameVal, ok := matchNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`match_name expected to be basetypes.StringValue, was: %T`, matchNameAttribute))
	}

	matchNameOffsetAttribute, ok := attributes["match_name_offset"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`match_name_offset is missing from object`)

		return NewMatchingRulesValueUnknown(), diags
	}

	matchNameOffsetVal, ok := matchNameOffsetAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`match_name_offset expected to be basetypes.Int64Value, was: %T`, matchNameOffsetAttribute))
	}

	matchRoleAttribute, ok := attributes["match_role"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`match_role is missing from object`)

		return NewMatchingRulesValueUnknown(), diags
	}

	matchRoleVal, ok := matchRoleAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`match_role expected to be basetypes.StringValue, was: %T`, matchRoleAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewMatchingRulesValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	oobIpConfigAttribute, ok := attributes["oob_ip_config"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`oob_ip_config is missing from object`)

		return NewMatchingRulesValueUnknown(), diags
	}

	oobIpConfigVal, ok := oobIpConfigAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`oob_ip_config expected to be basetypes.ObjectValue, was: %T`, oobIpConfigAttribute))
	}

	portConfigAttribute, ok := attributes["port_config"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_config is missing from object`)

		return NewMatchingRulesValueUnknown(), diags
	}

	portConfigVal, ok := portConfigAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_config expected to be basetypes.MapValue, was: %T`, portConfigAttribute))
	}

	portMirroringAttribute, ok := attributes["port_mirroring"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_mirroring is missing from object`)

		return NewMatchingRulesValueUnknown(), diags
	}

	portMirroringVal, ok := portMirroringAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_mirroring expected to be basetypes.MapValue, was: %T`, portMirroringAttribute))
	}

	stpConfigAttribute, ok := attributes["stp_config"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`stp_config is missing from object`)

		return NewMatchingRulesValueUnknown(), diags
	}

	stpConfigVal, ok := stpConfigAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`stp_config expected to be basetypes.ObjectValue, was: %T`, stpConfigAttribute))
	}

	if diags.HasError() {
		return NewMatchingRulesValueUnknown(), diags
	}

	return MatchingRulesValue{
		AdditionalConfigCmds: additionalConfigCmdsVal,
		IpConfig:             ipConfigVal,
		MatchModel:           matchModelVal,
		MatchName:            matchNameVal,
		MatchNameOffset:      matchNameOffsetVal,
		MatchRole:            matchRoleVal,
		Name:                 nameVal,
		OobIpConfig:          oobIpConfigVal,
		PortConfig:           portConfigVal,
		PortMirroring:        portMirroringVal,
		StpConfig:            stpConfigVal,
		state:                attr.ValueStateKnown,
	}, diags
}

func NewMatchingRulesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) MatchingRulesValue {
	object, diags := NewMatchingRulesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewMatchingRulesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t MatchingRulesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewMatchingRulesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewMatchingRulesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewMatchingRulesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewMatchingRulesValueMust(MatchingRulesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t MatchingRulesType) ValueType(ctx context.Context) attr.Value {
	return MatchingRulesValue{}
}

var _ basetypes.ObjectValuable = MatchingRulesValue{}

type MatchingRulesValue struct {
	AdditionalConfigCmds basetypes.ListValue   `tfsdk:"additional_config_cmds"`
	IpConfig             basetypes.ObjectValue `tfsdk:"ip_config"`
	MatchModel           basetypes.StringValue `tfsdk:"match_model"`
	MatchName            basetypes.StringValue `tfsdk:"match_name"`
	MatchNameOffset      basetypes.Int64Value  `tfsdk:"match_name_offset"`
	MatchRole            basetypes.StringValue `tfsdk:"match_role"`
	Name                 basetypes.StringValue `tfsdk:"name"`
	OobIpConfig          basetypes.ObjectValue `tfsdk:"oob_ip_config"`
	PortConfig           basetypes.MapValue    `tfsdk:"port_config"`
	PortMirroring        basetypes.MapValue    `tfsdk:"port_mirroring"`
	StpConfig            basetypes.ObjectValue `tfsdk:"stp_config"`
	state                attr.ValueState
}

func (v MatchingRulesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 11)

	var val tftypes.Value
	var err error

	attrTypes["additional_config_cmds"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["ip_config"] = basetypes.ObjectType{
		AttrTypes: IpConfigValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["match_model"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["match_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["match_name_offset"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["match_role"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["oob_ip_config"] = basetypes.ObjectType{
		AttrTypes: OobIpConfigValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["port_config"] = basetypes.MapType{
		ElemType: PortConfigValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["port_mirroring"] = basetypes.MapType{
		ElemType: PortMirroringValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["stp_config"] = basetypes.ObjectType{
		AttrTypes: StpConfigValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 11)

		val, err = v.AdditionalConfigCmds.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["additional_config_cmds"] = val

		val, err = v.IpConfig.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip_config"] = val

		val, err = v.MatchModel.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["match_model"] = val

		val, err = v.MatchName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["match_name"] = val

		val, err = v.MatchNameOffset.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["match_name_offset"] = val

		val, err = v.MatchRole.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["match_role"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.OobIpConfig.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["oob_ip_config"] = val

		val, err = v.PortConfig.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port_config"] = val

		val, err = v.PortMirroring.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port_mirroring"] = val

		val, err = v.StpConfig.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["stp_config"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v MatchingRulesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v MatchingRulesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v MatchingRulesValue) String() string {
	return "MatchingRulesValue"
}

func (v MatchingRulesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var ipConfig basetypes.ObjectValue

	if v.IpConfig.IsNull() {
		ipConfig = types.ObjectNull(
			IpConfigValue{}.AttributeTypes(ctx),
		)
	}

	if v.IpConfig.IsUnknown() {
		ipConfig = types.ObjectUnknown(
			IpConfigValue{}.AttributeTypes(ctx),
		)
	}

	if !v.IpConfig.IsNull() && !v.IpConfig.IsUnknown() {
		ipConfig = types.ObjectValueMust(
			IpConfigValue{}.AttributeTypes(ctx),
			v.IpConfig.Attributes(),
		)
	}

	var oobIpConfig basetypes.ObjectValue

	if v.OobIpConfig.IsNull() {
		oobIpConfig = types.ObjectNull(
			OobIpConfigValue{}.AttributeTypes(ctx),
		)
	}

	if v.OobIpConfig.IsUnknown() {
		oobIpConfig = types.ObjectUnknown(
			OobIpConfigValue{}.AttributeTypes(ctx),
		)
	}

	if !v.OobIpConfig.IsNull() && !v.OobIpConfig.IsUnknown() {
		oobIpConfig = types.ObjectValueMust(
			OobIpConfigValue{}.AttributeTypes(ctx),
			v.OobIpConfig.Attributes(),
		)
	}

	portConfig := types.MapValueMust(
		PortConfigType{
			basetypes.ObjectType{
				AttrTypes: PortConfigValue{}.AttributeTypes(ctx),
			},
		},
		v.PortConfig.Elements(),
	)

	if v.PortConfig.IsNull() {
		portConfig = types.MapNull(
			PortConfigType{
				basetypes.ObjectType{
					AttrTypes: PortConfigValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.PortConfig.IsUnknown() {
		portConfig = types.MapUnknown(
			PortConfigType{
				basetypes.ObjectType{
					AttrTypes: PortConfigValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	portMirroring := types.MapValueMust(
		PortMirroringType{
			basetypes.ObjectType{
				AttrTypes: PortMirroringValue{}.AttributeTypes(ctx),
			},
		},
		v.PortMirroring.Elements(),
	)

	if v.PortMirroring.IsNull() {
		portMirroring = types.MapNull(
			PortMirroringType{
				basetypes.ObjectType{
					AttrTypes: PortMirroringValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.PortMirroring.IsUnknown() {
		portMirroring = types.MapUnknown(
			PortMirroringType{
				basetypes.ObjectType{
					AttrTypes: PortMirroringValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var stpConfig basetypes.ObjectValue

	if v.StpConfig.IsNull() {
		stpConfig = types.ObjectNull(
			StpConfigValue{}.AttributeTypes(ctx),
		)
	}

	if v.StpConfig.IsUnknown() {
		stpConfig = types.ObjectUnknown(
			StpConfigValue{}.AttributeTypes(ctx),
		)
	}

	if !v.StpConfig.IsNull() && !v.StpConfig.IsUnknown() {
		stpConfig = types.ObjectValueMust(
			StpConfigValue{}.AttributeTypes(ctx),
			v.StpConfig.Attributes(),
		)
	}

	var additionalConfigCmdsVal basetypes.ListValue
	switch {
	case v.AdditionalConfigCmds.IsUnknown():
		additionalConfigCmdsVal = types.ListUnknown(types.StringType)
	case v.AdditionalConfigCmds.IsNull():
		additionalConfigCmdsVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		additionalConfigCmdsVal, d = types.ListValue(types.StringType, v.AdditionalConfigCmds.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"additional_config_cmds": basetypes.ListType{
				ElemType: types.StringType,
			},
			"ip_config": basetypes.ObjectType{
				AttrTypes: IpConfigValue{}.AttributeTypes(ctx),
			},
			"match_model":       basetypes.StringType{},
			"match_name":        basetypes.StringType{},
			"match_name_offset": basetypes.Int64Type{},
			"match_role":        basetypes.StringType{},
			"name":              basetypes.StringType{},
			"oob_ip_config": basetypes.ObjectType{
				AttrTypes: OobIpConfigValue{}.AttributeTypes(ctx),
			},
			"port_config": basetypes.MapType{
				ElemType: PortConfigValue{}.Type(ctx),
			},
			"port_mirroring": basetypes.MapType{
				ElemType: PortMirroringValue{}.Type(ctx),
			},
			"stp_config": basetypes.ObjectType{
				AttrTypes: StpConfigValue{}.AttributeTypes(ctx),
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"additional_config_cmds": basetypes.ListType{
			ElemType: types.StringType,
		},
		"ip_config": basetypes.ObjectType{
			AttrTypes: IpConfigValue{}.AttributeTypes(ctx),
		},
		"match_model":       basetypes.StringType{},
		"match_name":        basetypes.StringType{},
		"match_name_offset": basetypes.Int64Type{},
		"match_role":        basetypes.StringType{},
		"name":              basetypes.StringType{},
		"oob_ip_config": basetypes.ObjectType{
			AttrTypes: OobIpConfigValue{}.AttributeTypes(ctx),
		},
		"port_config": basetypes.MapType{
			ElemType: PortConfigValue{}.Type(ctx),
		},
		"port_mirroring": basetypes.MapType{
			ElemType: PortMirroringValue{}.Type(ctx),
		},
		"stp_config": basetypes.ObjectType{
			AttrTypes: StpConfigValue{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"additional_config_cmds": additionalConfigCmdsVal,
			"ip_config":              ipConfig,
			"match_model":            v.MatchModel,
			"match_name":             v.MatchName,
			"match_name_offset":      v.MatchNameOffset,
			"match_role":             v.MatchRole,
			"name":                   v.Name,
			"oob_ip_config":          oobIpConfig,
			"port_config":            portConfig,
			"port_mirroring":         portMirroring,
			"stp_config":             stpConfig,
		})

	return objVal, diags
}

func (v MatchingRulesValue) Equal(o attr.Value) bool {
	other, ok := o.(MatchingRulesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AdditionalConfigCmds.Equal(other.AdditionalConfigCmds) {
		return false
	}

	if !v.IpConfig.Equal(other.IpConfig) {
		return false
	}

	if !v.MatchModel.Equal(other.MatchModel) {
		return false
	}

	if !v.MatchName.Equal(other.MatchName) {
		return false
	}

	if !v.MatchNameOffset.Equal(other.MatchNameOffset) {
		return false
	}

	if !v.MatchRole.Equal(other.MatchRole) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.OobIpConfig.Equal(other.OobIpConfig) {
		return false
	}

	if !v.PortConfig.Equal(other.PortConfig) {
		return false
	}

	if !v.PortMirroring.Equal(other.PortMirroring) {
		return false
	}

	if !v.StpConfig.Equal(other.StpConfig) {
		return false
	}

	return true
}

func (v MatchingRulesValue) Type(ctx context.Context) attr.Type {
	return MatchingRulesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v MatchingRulesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"additional_config_cmds": basetypes.ListType{
			ElemType: types.StringType,
		},
		"ip_config": basetypes.ObjectType{
			AttrTypes: IpConfigValue{}.AttributeTypes(ctx),
		},
		"match_model":       basetypes.StringType{},
		"match_name":        basetypes.StringType{},
		"match_name_offset": basetypes.Int64Type{},
		"match_role":        basetypes.StringType{},
		"name":              basetypes.StringType{},
		"oob_ip_config": basetypes.ObjectType{
			AttrTypes: OobIpConfigValue{}.AttributeTypes(ctx),
		},
		"port_config": basetypes.MapType{
			ElemType: PortConfigValue{}.Type(ctx),
		},
		"port_mirroring": basetypes.MapType{
			ElemType: PortMirroringValue{}.Type(ctx),
		},
		"stp_config": basetypes.ObjectType{
			AttrTypes: StpConfigValue{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = IpConfigType{}

type IpConfigType struct {
	basetypes.ObjectType
}

func (t IpConfigType) Equal(o attr.Type) bool {
	other, ok := o.(IpConfigType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t IpConfigType) String() string {
	return "IpConfigType"
}

func (t IpConfigType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	networkAttribute, ok := attributes["network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`network is missing from object`)

		return nil, diags
	}

	networkVal, ok := networkAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`network expected to be basetypes.StringValue, was: %T`, networkAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return IpConfigValue{
		Network:      networkVal,
		IpConfigType: typeVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewIpConfigValueNull() IpConfigValue {
	return IpConfigValue{
		state: attr.ValueStateNull,
	}
}

func NewIpConfigValueUnknown() IpConfigValue {
	return IpConfigValue{
		state: attr.ValueStateUnknown,
	}
}

func NewIpConfigValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (IpConfigValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing IpConfigValue Attribute Value",
				"While creating a IpConfigValue value, a missing attribute value was detected. "+
					"A IpConfigValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("IpConfigValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid IpConfigValue Attribute Type",
				"While creating a IpConfigValue value, an invalid attribute value was detected. "+
					"A IpConfigValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("IpConfigValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("IpConfigValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra IpConfigValue Attribute Value",
				"While creating a IpConfigValue value, an extra attribute value was detected. "+
					"A IpConfigValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra IpConfigValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewIpConfigValueUnknown(), diags
	}

	networkAttribute, ok := attributes["network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`network is missing from object`)

		return NewIpConfigValueUnknown(), diags
	}

	networkVal, ok := networkAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`network expected to be basetypes.StringValue, was: %T`, networkAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewIpConfigValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return NewIpConfigValueUnknown(), diags
	}

	return IpConfigValue{
		Network:      networkVal,
		IpConfigType: typeVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewIpConfigValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) IpConfigValue {
	object, diags := NewIpConfigValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewIpConfigValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t IpConfigType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewIpConfigValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewIpConfigValueUnknown(), nil
	}

	if in.IsNull() {
		return NewIpConfigValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewIpConfigValueMust(IpConfigValue{}.AttributeTypes(ctx), attributes), nil
}

func (t IpConfigType) ValueType(ctx context.Context) attr.Value {
	return IpConfigValue{}
}

var _ basetypes.ObjectValuable = IpConfigValue{}

type IpConfigValue struct {
	Network      basetypes.StringValue `tfsdk:"network"`
	IpConfigType basetypes.StringValue `tfsdk:"type"`
	state        attr.ValueState
}

func (v IpConfigValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["network"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Network.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["network"] = val

		val, err = v.IpConfigType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v IpConfigValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v IpConfigValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v IpConfigValue) String() string {
	return "IpConfigValue"
}

func (v IpConfigValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"network": basetypes.StringType{},
		"type":    basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"network": v.Network,
			"type":    v.IpConfigType,
		})

	return objVal, diags
}

func (v IpConfigValue) Equal(o attr.Value) bool {
	other, ok := o.(IpConfigValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Network.Equal(other.Network) {
		return false
	}

	if !v.IpConfigType.Equal(other.IpConfigType) {
		return false
	}

	return true
}

func (v IpConfigValue) Type(ctx context.Context) attr.Type {
	return IpConfigType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v IpConfigValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"network": basetypes.StringType{},
		"type":    basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = OobIpConfigType{}

type OobIpConfigType struct {
	basetypes.ObjectType
}

func (t OobIpConfigType) Equal(o attr.Type) bool {
	other, ok := o.(OobIpConfigType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t OobIpConfigType) String() string {
	return "OobIpConfigType"
}

func (t OobIpConfigType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	useMgmtVrfAttribute, ok := attributes["use_mgmt_vrf"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`use_mgmt_vrf is missing from object`)

		return nil, diags
	}

	useMgmtVrfVal, ok := useMgmtVrfAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`use_mgmt_vrf expected to be basetypes.BoolValue, was: %T`, useMgmtVrfAttribute))
	}

	useMgmtVrfForHostOutAttribute, ok := attributes["use_mgmt_vrf_for_host_out"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`use_mgmt_vrf_for_host_out is missing from object`)

		return nil, diags
	}

	useMgmtVrfForHostOutVal, ok := useMgmtVrfForHostOutAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`use_mgmt_vrf_for_host_out expected to be basetypes.BoolValue, was: %T`, useMgmtVrfForHostOutAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return OobIpConfigValue{
		OobIpConfigType:      typeVal,
		UseMgmtVrf:           useMgmtVrfVal,
		UseMgmtVrfForHostOut: useMgmtVrfForHostOutVal,
		state:                attr.ValueStateKnown,
	}, diags
}

func NewOobIpConfigValueNull() OobIpConfigValue {
	return OobIpConfigValue{
		state: attr.ValueStateNull,
	}
}

func NewOobIpConfigValueUnknown() OobIpConfigValue {
	return OobIpConfigValue{
		state: attr.ValueStateUnknown,
	}
}

func NewOobIpConfigValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (OobIpConfigValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing OobIpConfigValue Attribute Value",
				"While creating a OobIpConfigValue value, a missing attribute value was detected. "+
					"A OobIpConfigValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OobIpConfigValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid OobIpConfigValue Attribute Type",
				"While creating a OobIpConfigValue value, an invalid attribute value was detected. "+
					"A OobIpConfigValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OobIpConfigValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("OobIpConfigValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra OobIpConfigValue Attribute Value",
				"While creating a OobIpConfigValue value, an extra attribute value was detected. "+
					"A OobIpConfigValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra OobIpConfigValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewOobIpConfigValueUnknown(), diags
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewOobIpConfigValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	useMgmtVrfAttribute, ok := attributes["use_mgmt_vrf"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`use_mgmt_vrf is missing from object`)

		return NewOobIpConfigValueUnknown(), diags
	}

	useMgmtVrfVal, ok := useMgmtVrfAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`use_mgmt_vrf expected to be basetypes.BoolValue, was: %T`, useMgmtVrfAttribute))
	}

	useMgmtVrfForHostOutAttribute, ok := attributes["use_mgmt_vrf_for_host_out"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`use_mgmt_vrf_for_host_out is missing from object`)

		return NewOobIpConfigValueUnknown(), diags
	}

	useMgmtVrfForHostOutVal, ok := useMgmtVrfForHostOutAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`use_mgmt_vrf_for_host_out expected to be basetypes.BoolValue, was: %T`, useMgmtVrfForHostOutAttribute))
	}

	if diags.HasError() {
		return NewOobIpConfigValueUnknown(), diags
	}

	return OobIpConfigValue{
		OobIpConfigType:      typeVal,
		UseMgmtVrf:           useMgmtVrfVal,
		UseMgmtVrfForHostOut: useMgmtVrfForHostOutVal,
		state:                attr.ValueStateKnown,
	}, diags
}

func NewOobIpConfigValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) OobIpConfigValue {
	object, diags := NewOobIpConfigValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewOobIpConfigValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t OobIpConfigType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewOobIpConfigValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewOobIpConfigValueUnknown(), nil
	}

	if in.IsNull() {
		return NewOobIpConfigValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewOobIpConfigValueMust(OobIpConfigValue{}.AttributeTypes(ctx), attributes), nil
}

func (t OobIpConfigType) ValueType(ctx context.Context) attr.Value {
	return OobIpConfigValue{}
}

var _ basetypes.ObjectValuable = OobIpConfigValue{}

type OobIpConfigValue struct {
	OobIpConfigType      basetypes.StringValue `tfsdk:"type"`
	UseMgmtVrf           basetypes.BoolValue   `tfsdk:"use_mgmt_vrf"`
	UseMgmtVrfForHostOut basetypes.BoolValue   `tfsdk:"use_mgmt_vrf_for_host_out"`
	state                attr.ValueState
}

func (v OobIpConfigValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["use_mgmt_vrf"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["use_mgmt_vrf_for_host_out"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.OobIpConfigType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		val, err = v.UseMgmtVrf.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["use_mgmt_vrf"] = val

		val, err = v.UseMgmtVrfForHostOut.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["use_mgmt_vrf_for_host_out"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v OobIpConfigValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v OobIpConfigValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v OobIpConfigValue) String() string {
	return "OobIpConfigValue"
}

func (v OobIpConfigValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"type":                      basetypes.StringType{},
		"use_mgmt_vrf":              basetypes.BoolType{},
		"use_mgmt_vrf_for_host_out": basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"type":                      v.OobIpConfigType,
			"use_mgmt_vrf":              v.UseMgmtVrf,
			"use_mgmt_vrf_for_host_out": v.UseMgmtVrfForHostOut,
		})

	return objVal, diags
}

func (v OobIpConfigValue) Equal(o attr.Value) bool {
	other, ok := o.(OobIpConfigValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.OobIpConfigType.Equal(other.OobIpConfigType) {
		return false
	}

	if !v.UseMgmtVrf.Equal(other.UseMgmtVrf) {
		return false
	}

	if !v.UseMgmtVrfForHostOut.Equal(other.UseMgmtVrfForHostOut) {
		return false
	}

	return true
}

func (v OobIpConfigValue) Type(ctx context.Context) attr.Type {
	return OobIpConfigType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v OobIpConfigValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"type":                      basetypes.StringType{},
		"use_mgmt_vrf":              basetypes.BoolType{},
		"use_mgmt_vrf_for_host_out": basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = PortConfigType{}

type PortConfigType struct {
	basetypes.ObjectType
}

func (t PortConfigType) Equal(o attr.Type) bool {
	other, ok := o.(PortConfigType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PortConfigType) String() string {
	return "PortConfigType"
}

func (t PortConfigType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	aeDisableLacpAttribute, ok := attributes["ae_disable_lacp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ae_disable_lacp is missing from object`)

		return nil, diags
	}

	aeDisableLacpVal, ok := aeDisableLacpAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ae_disable_lacp expected to be basetypes.BoolValue, was: %T`, aeDisableLacpAttribute))
	}

	aeIdxAttribute, ok := attributes["ae_idx"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ae_idx is missing from object`)

		return nil, diags
	}

	aeIdxVal, ok := aeIdxAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ae_idx expected to be basetypes.Int64Value, was: %T`, aeIdxAttribute))
	}

	aeLacpSlowAttribute, ok := attributes["ae_lacp_slow"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ae_lacp_slow is missing from object`)

		return nil, diags
	}

	aeLacpSlowVal, ok := aeLacpSlowAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ae_lacp_slow expected to be basetypes.BoolValue, was: %T`, aeLacpSlowAttribute))
	}

	aggregatedAttribute, ok := attributes["aggregated"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`aggregated is missing from object`)

		return nil, diags
	}

	aggregatedVal, ok := aggregatedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`aggregated expected to be basetypes.BoolValue, was: %T`, aggregatedAttribute))
	}

	criticalAttribute, ok := attributes["critical"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`critical is missing from object`)

		return nil, diags
	}

	criticalVal, ok := criticalAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`critical expected to be basetypes.BoolValue, was: %T`, criticalAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return nil, diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	disableAutonegAttribute, ok := attributes["disable_autoneg"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disable_autoneg is missing from object`)

		return nil, diags
	}

	disableAutonegVal, ok := disableAutonegAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disable_autoneg expected to be basetypes.BoolValue, was: %T`, disableAutonegAttribute))
	}

	duplexAttribute, ok := attributes["duplex"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`duplex is missing from object`)

		return nil, diags
	}

	duplexVal, ok := duplexAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`duplex expected to be basetypes.StringValue, was: %T`, duplexAttribute))
	}

	dynamicUsageAttribute, ok := attributes["dynamic_usage"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dynamic_usage is missing from object`)

		return nil, diags
	}

	dynamicUsageVal, ok := dynamicUsageAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dynamic_usage expected to be basetypes.StringValue, was: %T`, dynamicUsageAttribute))
	}

	esilagAttribute, ok := attributes["esilag"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`esilag is missing from object`)

		return nil, diags
	}

	esilagVal, ok := esilagAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`esilag expected to be basetypes.BoolValue, was: %T`, esilagAttribute))
	}

	mtuAttribute, ok := attributes["mtu"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mtu is missing from object`)

		return nil, diags
	}

	mtuVal, ok := mtuAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mtu expected to be basetypes.Int64Value, was: %T`, mtuAttribute))
	}

	networksAttribute, ok := attributes["networks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`networks is missing from object`)

		return nil, diags
	}

	networksVal, ok := networksAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`networks expected to be basetypes.ListValue, was: %T`, networksAttribute))
	}

	noLocalOverwriteAttribute, ok := attributes["no_local_overwrite"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`no_local_overwrite is missing from object`)

		return nil, diags
	}

	noLocalOverwriteVal, ok := noLocalOverwriteAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`no_local_overwrite expected to be basetypes.BoolValue, was: %T`, noLocalOverwriteAttribute))
	}

	poeDisabledAttribute, ok := attributes["poe_disabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`poe_disabled is missing from object`)

		return nil, diags
	}

	poeDisabledVal, ok := poeDisabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`poe_disabled expected to be basetypes.BoolValue, was: %T`, poeDisabledAttribute))
	}

	portNetworkAttribute, ok := attributes["port_network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_network is missing from object`)

		return nil, diags
	}

	portNetworkVal, ok := portNetworkAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_network expected to be basetypes.StringValue, was: %T`, portNetworkAttribute))
	}

	speedAttribute, ok := attributes["speed"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`speed is missing from object`)

		return nil, diags
	}

	speedVal, ok := speedAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`speed expected to be basetypes.StringValue, was: %T`, speedAttribute))
	}

	usageAttribute, ok := attributes["usage"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`usage is missing from object`)

		return nil, diags
	}

	usageVal, ok := usageAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`usage expected to be basetypes.StringValue, was: %T`, usageAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PortConfigValue{
		AeDisableLacp:    aeDisableLacpVal,
		AeIdx:            aeIdxVal,
		AeLacpSlow:       aeLacpSlowVal,
		Aggregated:       aggregatedVal,
		Critical:         criticalVal,
		Description:      descriptionVal,
		DisableAutoneg:   disableAutonegVal,
		Duplex:           duplexVal,
		DynamicUsage:     dynamicUsageVal,
		Esilag:           esilagVal,
		Mtu:              mtuVal,
		Networks:         networksVal,
		NoLocalOverwrite: noLocalOverwriteVal,
		PoeDisabled:      poeDisabledVal,
		PortNetwork:      portNetworkVal,
		Speed:            speedVal,
		Usage:            usageVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewPortConfigValueNull() PortConfigValue {
	return PortConfigValue{
		state: attr.ValueStateNull,
	}
}

func NewPortConfigValueUnknown() PortConfigValue {
	return PortConfigValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPortConfigValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PortConfigValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PortConfigValue Attribute Value",
				"While creating a PortConfigValue value, a missing attribute value was detected. "+
					"A PortConfigValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PortConfigValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PortConfigValue Attribute Type",
				"While creating a PortConfigValue value, an invalid attribute value was detected. "+
					"A PortConfigValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PortConfigValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PortConfigValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PortConfigValue Attribute Value",
				"While creating a PortConfigValue value, an extra attribute value was detected. "+
					"A PortConfigValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PortConfigValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPortConfigValueUnknown(), diags
	}

	aeDisableLacpAttribute, ok := attributes["ae_disable_lacp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ae_disable_lacp is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	aeDisableLacpVal, ok := aeDisableLacpAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ae_disable_lacp expected to be basetypes.BoolValue, was: %T`, aeDisableLacpAttribute))
	}

	aeIdxAttribute, ok := attributes["ae_idx"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ae_idx is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	aeIdxVal, ok := aeIdxAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ae_idx expected to be basetypes.Int64Value, was: %T`, aeIdxAttribute))
	}

	aeLacpSlowAttribute, ok := attributes["ae_lacp_slow"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ae_lacp_slow is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	aeLacpSlowVal, ok := aeLacpSlowAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ae_lacp_slow expected to be basetypes.BoolValue, was: %T`, aeLacpSlowAttribute))
	}

	aggregatedAttribute, ok := attributes["aggregated"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`aggregated is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	aggregatedVal, ok := aggregatedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`aggregated expected to be basetypes.BoolValue, was: %T`, aggregatedAttribute))
	}

	criticalAttribute, ok := attributes["critical"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`critical is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	criticalVal, ok := criticalAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`critical expected to be basetypes.BoolValue, was: %T`, criticalAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	disableAutonegAttribute, ok := attributes["disable_autoneg"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disable_autoneg is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	disableAutonegVal, ok := disableAutonegAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disable_autoneg expected to be basetypes.BoolValue, was: %T`, disableAutonegAttribute))
	}

	duplexAttribute, ok := attributes["duplex"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`duplex is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	duplexVal, ok := duplexAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`duplex expected to be basetypes.StringValue, was: %T`, duplexAttribute))
	}

	dynamicUsageAttribute, ok := attributes["dynamic_usage"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dynamic_usage is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	dynamicUsageVal, ok := dynamicUsageAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dynamic_usage expected to be basetypes.StringValue, was: %T`, dynamicUsageAttribute))
	}

	esilagAttribute, ok := attributes["esilag"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`esilag is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	esilagVal, ok := esilagAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`esilag expected to be basetypes.BoolValue, was: %T`, esilagAttribute))
	}

	mtuAttribute, ok := attributes["mtu"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mtu is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	mtuVal, ok := mtuAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mtu expected to be basetypes.Int64Value, was: %T`, mtuAttribute))
	}

	networksAttribute, ok := attributes["networks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`networks is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	networksVal, ok := networksAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`networks expected to be basetypes.ListValue, was: %T`, networksAttribute))
	}

	noLocalOverwriteAttribute, ok := attributes["no_local_overwrite"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`no_local_overwrite is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	noLocalOverwriteVal, ok := noLocalOverwriteAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`no_local_overwrite expected to be basetypes.BoolValue, was: %T`, noLocalOverwriteAttribute))
	}

	poeDisabledAttribute, ok := attributes["poe_disabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`poe_disabled is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	poeDisabledVal, ok := poeDisabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`poe_disabled expected to be basetypes.BoolValue, was: %T`, poeDisabledAttribute))
	}

	portNetworkAttribute, ok := attributes["port_network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_network is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	portNetworkVal, ok := portNetworkAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_network expected to be basetypes.StringValue, was: %T`, portNetworkAttribute))
	}

	speedAttribute, ok := attributes["speed"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`speed is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	speedVal, ok := speedAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`speed expected to be basetypes.StringValue, was: %T`, speedAttribute))
	}

	usageAttribute, ok := attributes["usage"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`usage is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	usageVal, ok := usageAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`usage expected to be basetypes.StringValue, was: %T`, usageAttribute))
	}

	if diags.HasError() {
		return NewPortConfigValueUnknown(), diags
	}

	return PortConfigValue{
		AeDisableLacp:    aeDisableLacpVal,
		AeIdx:            aeIdxVal,
		AeLacpSlow:       aeLacpSlowVal,
		Aggregated:       aggregatedVal,
		Critical:         criticalVal,
		Description:      descriptionVal,
		DisableAutoneg:   disableAutonegVal,
		Duplex:           duplexVal,
		DynamicUsage:     dynamicUsageVal,
		Esilag:           esilagVal,
		Mtu:              mtuVal,
		Networks:         networksVal,
		NoLocalOverwrite: noLocalOverwriteVal,
		PoeDisabled:      poeDisabledVal,
		PortNetwork:      portNetworkVal,
		Speed:            speedVal,
		Usage:            usageVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewPortConfigValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PortConfigValue {
	object, diags := NewPortConfigValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPortConfigValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PortConfigType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPortConfigValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPortConfigValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPortConfigValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPortConfigValueMust(PortConfigValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PortConfigType) ValueType(ctx context.Context) attr.Value {
	return PortConfigValue{}
}

var _ basetypes.ObjectValuable = PortConfigValue{}

type PortConfigValue struct {
	AeDisableLacp    basetypes.BoolValue   `tfsdk:"ae_disable_lacp"`
	AeIdx            basetypes.Int64Value  `tfsdk:"ae_idx"`
	AeLacpSlow       basetypes.BoolValue   `tfsdk:"ae_lacp_slow"`
	Aggregated       basetypes.BoolValue   `tfsdk:"aggregated"`
	Critical         basetypes.BoolValue   `tfsdk:"critical"`
	Description      basetypes.StringValue `tfsdk:"description"`
	DisableAutoneg   basetypes.BoolValue   `tfsdk:"disable_autoneg"`
	Duplex           basetypes.StringValue `tfsdk:"duplex"`
	DynamicUsage     basetypes.StringValue `tfsdk:"dynamic_usage"`
	Esilag           basetypes.BoolValue   `tfsdk:"esilag"`
	Mtu              basetypes.Int64Value  `tfsdk:"mtu"`
	Networks         basetypes.ListValue   `tfsdk:"networks"`
	NoLocalOverwrite basetypes.BoolValue   `tfsdk:"no_local_overwrite"`
	PoeDisabled      basetypes.BoolValue   `tfsdk:"poe_disabled"`
	PortNetwork      basetypes.StringValue `tfsdk:"port_network"`
	Speed            basetypes.StringValue `tfsdk:"speed"`
	Usage            basetypes.StringValue `tfsdk:"usage"`
	state            attr.ValueState
}

func (v PortConfigValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 17)

	var val tftypes.Value
	var err error

	attrTypes["ae_disable_lacp"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["ae_idx"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["ae_lacp_slow"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["aggregated"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["critical"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["disable_autoneg"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["duplex"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["dynamic_usage"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["esilag"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["mtu"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["networks"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["no_local_overwrite"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["poe_disabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["port_network"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["speed"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["usage"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 17)

		val, err = v.AeDisableLacp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ae_disable_lacp"] = val

		val, err = v.AeIdx.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ae_idx"] = val

		val, err = v.AeLacpSlow.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ae_lacp_slow"] = val

		val, err = v.Aggregated.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["aggregated"] = val

		val, err = v.Critical.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["critical"] = val

		val, err = v.Description.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["description"] = val

		val, err = v.DisableAutoneg.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["disable_autoneg"] = val

		val, err = v.Duplex.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["duplex"] = val

		val, err = v.DynamicUsage.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dynamic_usage"] = val

		val, err = v.Esilag.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["esilag"] = val

		val, err = v.Mtu.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mtu"] = val

		val, err = v.Networks.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["networks"] = val

		val, err = v.NoLocalOverwrite.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["no_local_overwrite"] = val

		val, err = v.PoeDisabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["poe_disabled"] = val

		val, err = v.PortNetwork.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port_network"] = val

		val, err = v.Speed.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["speed"] = val

		val, err = v.Usage.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["usage"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PortConfigValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PortConfigValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PortConfigValue) String() string {
	return "PortConfigValue"
}

func (v PortConfigValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var networksVal basetypes.ListValue
	switch {
	case v.Networks.IsUnknown():
		networksVal = types.ListUnknown(types.StringType)
	case v.Networks.IsNull():
		networksVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		networksVal, d = types.ListValue(types.StringType, v.Networks.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"ae_disable_lacp": basetypes.BoolType{},
			"ae_idx":          basetypes.Int64Type{},
			"ae_lacp_slow":    basetypes.BoolType{},
			"aggregated":      basetypes.BoolType{},
			"critical":        basetypes.BoolType{},
			"description":     basetypes.StringType{},
			"disable_autoneg": basetypes.BoolType{},
			"duplex":          basetypes.StringType{},
			"dynamic_usage":   basetypes.StringType{},
			"esilag":          basetypes.BoolType{},
			"mtu":             basetypes.Int64Type{},
			"networks": basetypes.ListType{
				ElemType: types.StringType,
			},
			"no_local_overwrite": basetypes.BoolType{},
			"poe_disabled":       basetypes.BoolType{},
			"port_network":       basetypes.StringType{},
			"speed":              basetypes.StringType{},
			"usage":              basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"ae_disable_lacp": basetypes.BoolType{},
		"ae_idx":          basetypes.Int64Type{},
		"ae_lacp_slow":    basetypes.BoolType{},
		"aggregated":      basetypes.BoolType{},
		"critical":        basetypes.BoolType{},
		"description":     basetypes.StringType{},
		"disable_autoneg": basetypes.BoolType{},
		"duplex":          basetypes.StringType{},
		"dynamic_usage":   basetypes.StringType{},
		"esilag":          basetypes.BoolType{},
		"mtu":             basetypes.Int64Type{},
		"networks": basetypes.ListType{
			ElemType: types.StringType,
		},
		"no_local_overwrite": basetypes.BoolType{},
		"poe_disabled":       basetypes.BoolType{},
		"port_network":       basetypes.StringType{},
		"speed":              basetypes.StringType{},
		"usage":              basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"ae_disable_lacp":    v.AeDisableLacp,
			"ae_idx":             v.AeIdx,
			"ae_lacp_slow":       v.AeLacpSlow,
			"aggregated":         v.Aggregated,
			"critical":           v.Critical,
			"description":        v.Description,
			"disable_autoneg":    v.DisableAutoneg,
			"duplex":             v.Duplex,
			"dynamic_usage":      v.DynamicUsage,
			"esilag":             v.Esilag,
			"mtu":                v.Mtu,
			"networks":           networksVal,
			"no_local_overwrite": v.NoLocalOverwrite,
			"poe_disabled":       v.PoeDisabled,
			"port_network":       v.PortNetwork,
			"speed":              v.Speed,
			"usage":              v.Usage,
		})

	return objVal, diags
}

func (v PortConfigValue) Equal(o attr.Value) bool {
	other, ok := o.(PortConfigValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AeDisableLacp.Equal(other.AeDisableLacp) {
		return false
	}

	if !v.AeIdx.Equal(other.AeIdx) {
		return false
	}

	if !v.AeLacpSlow.Equal(other.AeLacpSlow) {
		return false
	}

	if !v.Aggregated.Equal(other.Aggregated) {
		return false
	}

	if !v.Critical.Equal(other.Critical) {
		return false
	}

	if !v.Description.Equal(other.Description) {
		return false
	}

	if !v.DisableAutoneg.Equal(other.DisableAutoneg) {
		return false
	}

	if !v.Duplex.Equal(other.Duplex) {
		return false
	}

	if !v.DynamicUsage.Equal(other.DynamicUsage) {
		return false
	}

	if !v.Esilag.Equal(other.Esilag) {
		return false
	}

	if !v.Mtu.Equal(other.Mtu) {
		return false
	}

	if !v.Networks.Equal(other.Networks) {
		return false
	}

	if !v.NoLocalOverwrite.Equal(other.NoLocalOverwrite) {
		return false
	}

	if !v.PoeDisabled.Equal(other.PoeDisabled) {
		return false
	}

	if !v.PortNetwork.Equal(other.PortNetwork) {
		return false
	}

	if !v.Speed.Equal(other.Speed) {
		return false
	}

	if !v.Usage.Equal(other.Usage) {
		return false
	}

	return true
}

func (v PortConfigValue) Type(ctx context.Context) attr.Type {
	return PortConfigType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PortConfigValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"ae_disable_lacp": basetypes.BoolType{},
		"ae_idx":          basetypes.Int64Type{},
		"ae_lacp_slow":    basetypes.BoolType{},
		"aggregated":      basetypes.BoolType{},
		"critical":        basetypes.BoolType{},
		"description":     basetypes.StringType{},
		"disable_autoneg": basetypes.BoolType{},
		"duplex":          basetypes.StringType{},
		"dynamic_usage":   basetypes.StringType{},
		"esilag":          basetypes.BoolType{},
		"mtu":             basetypes.Int64Type{},
		"networks": basetypes.ListType{
			ElemType: types.StringType,
		},
		"no_local_overwrite": basetypes.BoolType{},
		"poe_disabled":       basetypes.BoolType{},
		"port_network":       basetypes.StringType{},
		"speed":              basetypes.StringType{},
		"usage":              basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = StpConfigType{}

type StpConfigType struct {
	basetypes.ObjectType
}

func (t StpConfigType) Equal(o attr.Type) bool {
	other, ok := o.(StpConfigType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t StpConfigType) String() string {
	return "StpConfigType"
}

func (t StpConfigType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	bridgePriorityAttribute, ok := attributes["bridge_priority"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bridge_priority is missing from object`)

		return nil, diags
	}

	bridgePriorityVal, ok := bridgePriorityAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bridge_priority expected to be basetypes.StringValue, was: %T`, bridgePriorityAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return StpConfigValue{
		BridgePriority: bridgePriorityVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewStpConfigValueNull() StpConfigValue {
	return StpConfigValue{
		state: attr.ValueStateNull,
	}
}

func NewStpConfigValueUnknown() StpConfigValue {
	return StpConfigValue{
		state: attr.ValueStateUnknown,
	}
}

func NewStpConfigValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (StpConfigValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing StpConfigValue Attribute Value",
				"While creating a StpConfigValue value, a missing attribute value was detected. "+
					"A StpConfigValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StpConfigValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid StpConfigValue Attribute Type",
				"While creating a StpConfigValue value, an invalid attribute value was detected. "+
					"A StpConfigValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StpConfigValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("StpConfigValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra StpConfigValue Attribute Value",
				"While creating a StpConfigValue value, an extra attribute value was detected. "+
					"A StpConfigValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra StpConfigValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewStpConfigValueUnknown(), diags
	}

	bridgePriorityAttribute, ok := attributes["bridge_priority"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bridge_priority is missing from object`)

		return NewStpConfigValueUnknown(), diags
	}

	bridgePriorityVal, ok := bridgePriorityAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bridge_priority expected to be basetypes.StringValue, was: %T`, bridgePriorityAttribute))
	}

	if diags.HasError() {
		return NewStpConfigValueUnknown(), diags
	}

	return StpConfigValue{
		BridgePriority: bridgePriorityVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewStpConfigValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) StpConfigValue {
	object, diags := NewStpConfigValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewStpConfigValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t StpConfigType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewStpConfigValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewStpConfigValueUnknown(), nil
	}

	if in.IsNull() {
		return NewStpConfigValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewStpConfigValueMust(StpConfigValue{}.AttributeTypes(ctx), attributes), nil
}

func (t StpConfigType) ValueType(ctx context.Context) attr.Value {
	return StpConfigValue{}
}

var _ basetypes.ObjectValuable = StpConfigValue{}

type StpConfigValue struct {
	BridgePriority basetypes.StringValue `tfsdk:"bridge_priority"`
	state          attr.ValueState
}

func (v StpConfigValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["bridge_priority"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.BridgePriority.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bridge_priority"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v StpConfigValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v StpConfigValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v StpConfigValue) String() string {
	return "StpConfigValue"
}

func (v StpConfigValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"bridge_priority": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"bridge_priority": v.BridgePriority,
		})

	return objVal, diags
}

func (v StpConfigValue) Equal(o attr.Value) bool {
	other, ok := o.(StpConfigValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.BridgePriority.Equal(other.BridgePriority) {
		return false
	}

	return true
}

func (v StpConfigValue) Type(ctx context.Context) attr.Type {
	return StpConfigType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v StpConfigValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"bridge_priority": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = SwitchMgmtType{}

type SwitchMgmtType struct {
	basetypes.ObjectType
}

func (t SwitchMgmtType) Equal(o attr.Type) bool {
	other, ok := o.(SwitchMgmtType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SwitchMgmtType) String() string {
	return "SwitchMgmtType"
}

func (t SwitchMgmtType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	apAffinityThresholdAttribute, ok := attributes["ap_affinity_threshold"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ap_affinity_threshold is missing from object`)

		return nil, diags
	}

	apAffinityThresholdVal, ok := apAffinityThresholdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ap_affinity_threshold expected to be basetypes.Int64Value, was: %T`, apAffinityThresholdAttribute))
	}

	cliBannerAttribute, ok := attributes["cli_banner"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cli_banner is missing from object`)

		return nil, diags
	}

	cliBannerVal, ok := cliBannerAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cli_banner expected to be basetypes.StringValue, was: %T`, cliBannerAttribute))
	}

	cliIdleTimeoutAttribute, ok := attributes["cli_idle_timeout"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cli_idle_timeout is missing from object`)

		return nil, diags
	}

	cliIdleTimeoutVal, ok := cliIdleTimeoutAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cli_idle_timeout expected to be basetypes.Int64Value, was: %T`, cliIdleTimeoutAttribute))
	}

	configRevertTimerAttribute, ok := attributes["config_revert_timer"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`config_revert_timer is missing from object`)

		return nil, diags
	}

	configRevertTimerVal, ok := configRevertTimerAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`config_revert_timer expected to be basetypes.Int64Value, was: %T`, configRevertTimerAttribute))
	}

	dhcpOptionFqdnAttribute, ok := attributes["dhcp_option_fqdn"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dhcp_option_fqdn is missing from object`)

		return nil, diags
	}

	dhcpOptionFqdnVal, ok := dhcpOptionFqdnAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dhcp_option_fqdn expected to be basetypes.BoolValue, was: %T`, dhcpOptionFqdnAttribute))
	}

	disableOobDownAlarmAttribute, ok := attributes["disable_oob_down_alarm"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disable_oob_down_alarm is missing from object`)

		return nil, diags
	}

	disableOobDownAlarmVal, ok := disableOobDownAlarmAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disable_oob_down_alarm expected to be basetypes.BoolValue, was: %T`, disableOobDownAlarmAttribute))
	}

	fipsEnabledAttribute, ok := attributes["fips_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fips_enabled is missing from object`)

		return nil, diags
	}

	fipsEnabledVal, ok := fipsEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fips_enabled expected to be basetypes.BoolValue, was: %T`, fipsEnabledAttribute))
	}

	localAccountsAttribute, ok := attributes["local_accounts"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`local_accounts is missing from object`)

		return nil, diags
	}

	localAccountsVal, ok := localAccountsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`local_accounts expected to be basetypes.MapValue, was: %T`, localAccountsAttribute))
	}

	mxedgeProxyHostAttribute, ok := attributes["mxedge_proxy_host"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mxedge_proxy_host is missing from object`)

		return nil, diags
	}

	mxedgeProxyHostVal, ok := mxedgeProxyHostAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mxedge_proxy_host expected to be basetypes.StringValue, was: %T`, mxedgeProxyHostAttribute))
	}

	mxedgeProxyPortAttribute, ok := attributes["mxedge_proxy_port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mxedge_proxy_port is missing from object`)

		return nil, diags
	}

	mxedgeProxyPortVal, ok := mxedgeProxyPortAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mxedge_proxy_port expected to be basetypes.StringValue, was: %T`, mxedgeProxyPortAttribute))
	}

	protectReAttribute, ok := attributes["protect_re"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`protect_re is missing from object`)

		return nil, diags
	}

	protectReVal, ok := protectReAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`protect_re expected to be basetypes.ObjectValue, was: %T`, protectReAttribute))
	}

	removeExistingConfigsAttribute, ok := attributes["remove_existing_configs"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remove_existing_configs is missing from object`)

		return nil, diags
	}

	removeExistingConfigsVal, ok := removeExistingConfigsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remove_existing_configs expected to be basetypes.BoolValue, was: %T`, removeExistingConfigsAttribute))
	}

	rootPasswordAttribute, ok := attributes["root_password"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`root_password is missing from object`)

		return nil, diags
	}

	rootPasswordVal, ok := rootPasswordAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`root_password expected to be basetypes.StringValue, was: %T`, rootPasswordAttribute))
	}

	tacacsAttribute, ok := attributes["tacacs"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tacacs is missing from object`)

		return nil, diags
	}

	tacacsVal, ok := tacacsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tacacs expected to be basetypes.ObjectValue, was: %T`, tacacsAttribute))
	}

	useMxedgeProxyAttribute, ok := attributes["use_mxedge_proxy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`use_mxedge_proxy is missing from object`)

		return nil, diags
	}

	useMxedgeProxyVal, ok := useMxedgeProxyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`use_mxedge_proxy expected to be basetypes.BoolValue, was: %T`, useMxedgeProxyAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SwitchMgmtValue{
		ApAffinityThreshold:   apAffinityThresholdVal,
		CliBanner:             cliBannerVal,
		CliIdleTimeout:        cliIdleTimeoutVal,
		ConfigRevertTimer:     configRevertTimerVal,
		DhcpOptionFqdn:        dhcpOptionFqdnVal,
		DisableOobDownAlarm:   disableOobDownAlarmVal,
		FipsEnabled:           fipsEnabledVal,
		LocalAccounts:         localAccountsVal,
		MxedgeProxyHost:       mxedgeProxyHostVal,
		MxedgeProxyPort:       mxedgeProxyPortVal,
		ProtectRe:             protectReVal,
		RemoveExistingConfigs: removeExistingConfigsVal,
		RootPassword:          rootPasswordVal,
		Tacacs:                tacacsVal,
		UseMxedgeProxy:        useMxedgeProxyVal,
		state:                 attr.ValueStateKnown,
	}, diags
}

func NewSwitchMgmtValueNull() SwitchMgmtValue {
	return SwitchMgmtValue{
		state: attr.ValueStateNull,
	}
}

func NewSwitchMgmtValueUnknown() SwitchMgmtValue {
	return SwitchMgmtValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSwitchMgmtValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SwitchMgmtValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SwitchMgmtValue Attribute Value",
				"While creating a SwitchMgmtValue value, a missing attribute value was detected. "+
					"A SwitchMgmtValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SwitchMgmtValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SwitchMgmtValue Attribute Type",
				"While creating a SwitchMgmtValue value, an invalid attribute value was detected. "+
					"A SwitchMgmtValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SwitchMgmtValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SwitchMgmtValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SwitchMgmtValue Attribute Value",
				"While creating a SwitchMgmtValue value, an extra attribute value was detected. "+
					"A SwitchMgmtValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SwitchMgmtValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSwitchMgmtValueUnknown(), diags
	}

	apAffinityThresholdAttribute, ok := attributes["ap_affinity_threshold"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ap_affinity_threshold is missing from object`)

		return NewSwitchMgmtValueUnknown(), diags
	}

	apAffinityThresholdVal, ok := apAffinityThresholdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ap_affinity_threshold expected to be basetypes.Int64Value, was: %T`, apAffinityThresholdAttribute))
	}

	cliBannerAttribute, ok := attributes["cli_banner"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cli_banner is missing from object`)

		return NewSwitchMgmtValueUnknown(), diags
	}

	cliBannerVal, ok := cliBannerAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cli_banner expected to be basetypes.StringValue, was: %T`, cliBannerAttribute))
	}

	cliIdleTimeoutAttribute, ok := attributes["cli_idle_timeout"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cli_idle_timeout is missing from object`)

		return NewSwitchMgmtValueUnknown(), diags
	}

	cliIdleTimeoutVal, ok := cliIdleTimeoutAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cli_idle_timeout expected to be basetypes.Int64Value, was: %T`, cliIdleTimeoutAttribute))
	}

	configRevertTimerAttribute, ok := attributes["config_revert_timer"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`config_revert_timer is missing from object`)

		return NewSwitchMgmtValueUnknown(), diags
	}

	configRevertTimerVal, ok := configRevertTimerAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`config_revert_timer expected to be basetypes.Int64Value, was: %T`, configRevertTimerAttribute))
	}

	dhcpOptionFqdnAttribute, ok := attributes["dhcp_option_fqdn"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dhcp_option_fqdn is missing from object`)

		return NewSwitchMgmtValueUnknown(), diags
	}

	dhcpOptionFqdnVal, ok := dhcpOptionFqdnAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dhcp_option_fqdn expected to be basetypes.BoolValue, was: %T`, dhcpOptionFqdnAttribute))
	}

	disableOobDownAlarmAttribute, ok := attributes["disable_oob_down_alarm"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disable_oob_down_alarm is missing from object`)

		return NewSwitchMgmtValueUnknown(), diags
	}

	disableOobDownAlarmVal, ok := disableOobDownAlarmAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disable_oob_down_alarm expected to be basetypes.BoolValue, was: %T`, disableOobDownAlarmAttribute))
	}

	fipsEnabledAttribute, ok := attributes["fips_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fips_enabled is missing from object`)

		return NewSwitchMgmtValueUnknown(), diags
	}

	fipsEnabledVal, ok := fipsEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fips_enabled expected to be basetypes.BoolValue, was: %T`, fipsEnabledAttribute))
	}

	localAccountsAttribute, ok := attributes["local_accounts"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`local_accounts is missing from object`)

		return NewSwitchMgmtValueUnknown(), diags
	}

	localAccountsVal, ok := localAccountsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`local_accounts expected to be basetypes.MapValue, was: %T`, localAccountsAttribute))
	}

	mxedgeProxyHostAttribute, ok := attributes["mxedge_proxy_host"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mxedge_proxy_host is missing from object`)

		return NewSwitchMgmtValueUnknown(), diags
	}

	mxedgeProxyHostVal, ok := mxedgeProxyHostAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mxedge_proxy_host expected to be basetypes.StringValue, was: %T`, mxedgeProxyHostAttribute))
	}

	mxedgeProxyPortAttribute, ok := attributes["mxedge_proxy_port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mxedge_proxy_port is missing from object`)

		return NewSwitchMgmtValueUnknown(), diags
	}

	mxedgeProxyPortVal, ok := mxedgeProxyPortAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mxedge_proxy_port expected to be basetypes.StringValue, was: %T`, mxedgeProxyPortAttribute))
	}

	protectReAttribute, ok := attributes["protect_re"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`protect_re is missing from object`)

		return NewSwitchMgmtValueUnknown(), diags
	}

	protectReVal, ok := protectReAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`protect_re expected to be basetypes.ObjectValue, was: %T`, protectReAttribute))
	}

	removeExistingConfigsAttribute, ok := attributes["remove_existing_configs"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remove_existing_configs is missing from object`)

		return NewSwitchMgmtValueUnknown(), diags
	}

	removeExistingConfigsVal, ok := removeExistingConfigsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remove_existing_configs expected to be basetypes.BoolValue, was: %T`, removeExistingConfigsAttribute))
	}

	rootPasswordAttribute, ok := attributes["root_password"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`root_password is missing from object`)

		return NewSwitchMgmtValueUnknown(), diags
	}

	rootPasswordVal, ok := rootPasswordAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`root_password expected to be basetypes.StringValue, was: %T`, rootPasswordAttribute))
	}

	tacacsAttribute, ok := attributes["tacacs"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tacacs is missing from object`)

		return NewSwitchMgmtValueUnknown(), diags
	}

	tacacsVal, ok := tacacsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tacacs expected to be basetypes.ObjectValue, was: %T`, tacacsAttribute))
	}

	useMxedgeProxyAttribute, ok := attributes["use_mxedge_proxy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`use_mxedge_proxy is missing from object`)

		return NewSwitchMgmtValueUnknown(), diags
	}

	useMxedgeProxyVal, ok := useMxedgeProxyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`use_mxedge_proxy expected to be basetypes.BoolValue, was: %T`, useMxedgeProxyAttribute))
	}

	if diags.HasError() {
		return NewSwitchMgmtValueUnknown(), diags
	}

	return SwitchMgmtValue{
		ApAffinityThreshold:   apAffinityThresholdVal,
		CliBanner:             cliBannerVal,
		CliIdleTimeout:        cliIdleTimeoutVal,
		ConfigRevertTimer:     configRevertTimerVal,
		DhcpOptionFqdn:        dhcpOptionFqdnVal,
		DisableOobDownAlarm:   disableOobDownAlarmVal,
		FipsEnabled:           fipsEnabledVal,
		LocalAccounts:         localAccountsVal,
		MxedgeProxyHost:       mxedgeProxyHostVal,
		MxedgeProxyPort:       mxedgeProxyPortVal,
		ProtectRe:             protectReVal,
		RemoveExistingConfigs: removeExistingConfigsVal,
		RootPassword:          rootPasswordVal,
		Tacacs:                tacacsVal,
		UseMxedgeProxy:        useMxedgeProxyVal,
		state:                 attr.ValueStateKnown,
	}, diags
}

func NewSwitchMgmtValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SwitchMgmtValue {
	object, diags := NewSwitchMgmtValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSwitchMgmtValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SwitchMgmtType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSwitchMgmtValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSwitchMgmtValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSwitchMgmtValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSwitchMgmtValueMust(SwitchMgmtValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SwitchMgmtType) ValueType(ctx context.Context) attr.Value {
	return SwitchMgmtValue{}
}

var _ basetypes.ObjectValuable = SwitchMgmtValue{}

type SwitchMgmtValue struct {
	ApAffinityThreshold   basetypes.Int64Value  `tfsdk:"ap_affinity_threshold"`
	CliBanner             basetypes.StringValue `tfsdk:"cli_banner"`
	CliIdleTimeout        basetypes.Int64Value  `tfsdk:"cli_idle_timeout"`
	ConfigRevertTimer     basetypes.Int64Value  `tfsdk:"config_revert_timer"`
	DhcpOptionFqdn        basetypes.BoolValue   `tfsdk:"dhcp_option_fqdn"`
	DisableOobDownAlarm   basetypes.BoolValue   `tfsdk:"disable_oob_down_alarm"`
	FipsEnabled           basetypes.BoolValue   `tfsdk:"fips_enabled"`
	LocalAccounts         basetypes.MapValue    `tfsdk:"local_accounts"`
	MxedgeProxyHost       basetypes.StringValue `tfsdk:"mxedge_proxy_host"`
	MxedgeProxyPort       basetypes.StringValue `tfsdk:"mxedge_proxy_port"`
	ProtectRe             basetypes.ObjectValue `tfsdk:"protect_re"`
	RemoveExistingConfigs basetypes.BoolValue   `tfsdk:"remove_existing_configs"`
	RootPassword          basetypes.StringValue `tfsdk:"root_password"`
	Tacacs                basetypes.ObjectValue `tfsdk:"tacacs"`
	UseMxedgeProxy        basetypes.BoolValue   `tfsdk:"use_mxedge_proxy"`
	state                 attr.ValueState
}

func (v SwitchMgmtValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 15)

	var val tftypes.Value
	var err error

	attrTypes["ap_affinity_threshold"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["cli_banner"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["cli_idle_timeout"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["config_revert_timer"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["dhcp_option_fqdn"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["disable_oob_down_alarm"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["fips_enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["local_accounts"] = basetypes.MapType{
		ElemType: LocalAccountsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["mxedge_proxy_host"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["mxedge_proxy_port"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["protect_re"] = basetypes.ObjectType{
		AttrTypes: ProtectReValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["remove_existing_configs"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["root_password"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["tacacs"] = basetypes.ObjectType{
		AttrTypes: TacacsValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["use_mxedge_proxy"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 15)

		val, err = v.ApAffinityThreshold.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ap_affinity_threshold"] = val

		val, err = v.CliBanner.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cli_banner"] = val

		val, err = v.CliIdleTimeout.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cli_idle_timeout"] = val

		val, err = v.ConfigRevertTimer.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["config_revert_timer"] = val

		val, err = v.DhcpOptionFqdn.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dhcp_option_fqdn"] = val

		val, err = v.DisableOobDownAlarm.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["disable_oob_down_alarm"] = val

		val, err = v.FipsEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["fips_enabled"] = val

		val, err = v.LocalAccounts.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["local_accounts"] = val

		val, err = v.MxedgeProxyHost.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mxedge_proxy_host"] = val

		val, err = v.MxedgeProxyPort.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mxedge_proxy_port"] = val

		val, err = v.ProtectRe.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["protect_re"] = val

		val, err = v.RemoveExistingConfigs.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["remove_existing_configs"] = val

		val, err = v.RootPassword.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["root_password"] = val

		val, err = v.Tacacs.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tacacs"] = val

		val, err = v.UseMxedgeProxy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["use_mxedge_proxy"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SwitchMgmtValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SwitchMgmtValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SwitchMgmtValue) String() string {
	return "SwitchMgmtValue"
}

func (v SwitchMgmtValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	localAccounts := types.MapValueMust(
		LocalAccountsType{
			basetypes.ObjectType{
				AttrTypes: LocalAccountsValue{}.AttributeTypes(ctx),
			},
		},
		v.LocalAccounts.Elements(),
	)

	if v.LocalAccounts.IsNull() {
		localAccounts = types.MapNull(
			LocalAccountsType{
				basetypes.ObjectType{
					AttrTypes: LocalAccountsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.LocalAccounts.IsUnknown() {
		localAccounts = types.MapUnknown(
			LocalAccountsType{
				basetypes.ObjectType{
					AttrTypes: LocalAccountsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var protectRe basetypes.ObjectValue

	if v.ProtectRe.IsNull() {
		protectRe = types.ObjectNull(
			ProtectReValue{}.AttributeTypes(ctx),
		)
	}

	if v.ProtectRe.IsUnknown() {
		protectRe = types.ObjectUnknown(
			ProtectReValue{}.AttributeTypes(ctx),
		)
	}

	if !v.ProtectRe.IsNull() && !v.ProtectRe.IsUnknown() {
		protectRe = types.ObjectValueMust(
			ProtectReValue{}.AttributeTypes(ctx),
			v.ProtectRe.Attributes(),
		)
	}

	var tacacs basetypes.ObjectValue

	if v.Tacacs.IsNull() {
		tacacs = types.ObjectNull(
			TacacsValue{}.AttributeTypes(ctx),
		)
	}

	if v.Tacacs.IsUnknown() {
		tacacs = types.ObjectUnknown(
			TacacsValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Tacacs.IsNull() && !v.Tacacs.IsUnknown() {
		tacacs = types.ObjectValueMust(
			TacacsValue{}.AttributeTypes(ctx),
			v.Tacacs.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"ap_affinity_threshold":  basetypes.Int64Type{},
		"cli_banner":             basetypes.StringType{},
		"cli_idle_timeout":       basetypes.Int64Type{},
		"config_revert_timer":    basetypes.Int64Type{},
		"dhcp_option_fqdn":       basetypes.BoolType{},
		"disable_oob_down_alarm": basetypes.BoolType{},
		"fips_enabled":           basetypes.BoolType{},
		"local_accounts": basetypes.MapType{
			ElemType: LocalAccountsValue{}.Type(ctx),
		},
		"mxedge_proxy_host": basetypes.StringType{},
		"mxedge_proxy_port": basetypes.StringType{},
		"protect_re": basetypes.ObjectType{
			AttrTypes: ProtectReValue{}.AttributeTypes(ctx),
		},
		"remove_existing_configs": basetypes.BoolType{},
		"root_password":           basetypes.StringType{},
		"tacacs": basetypes.ObjectType{
			AttrTypes: TacacsValue{}.AttributeTypes(ctx),
		},
		"use_mxedge_proxy": basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"ap_affinity_threshold":   v.ApAffinityThreshold,
			"cli_banner":              v.CliBanner,
			"cli_idle_timeout":        v.CliIdleTimeout,
			"config_revert_timer":     v.ConfigRevertTimer,
			"dhcp_option_fqdn":        v.DhcpOptionFqdn,
			"disable_oob_down_alarm":  v.DisableOobDownAlarm,
			"fips_enabled":            v.FipsEnabled,
			"local_accounts":          localAccounts,
			"mxedge_proxy_host":       v.MxedgeProxyHost,
			"mxedge_proxy_port":       v.MxedgeProxyPort,
			"protect_re":              protectRe,
			"remove_existing_configs": v.RemoveExistingConfigs,
			"root_password":           v.RootPassword,
			"tacacs":                  tacacs,
			"use_mxedge_proxy":        v.UseMxedgeProxy,
		})

	return objVal, diags
}

func (v SwitchMgmtValue) Equal(o attr.Value) bool {
	other, ok := o.(SwitchMgmtValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.ApAffinityThreshold.Equal(other.ApAffinityThreshold) {
		return false
	}

	if !v.CliBanner.Equal(other.CliBanner) {
		return false
	}

	if !v.CliIdleTimeout.Equal(other.CliIdleTimeout) {
		return false
	}

	if !v.ConfigRevertTimer.Equal(other.ConfigRevertTimer) {
		return false
	}

	if !v.DhcpOptionFqdn.Equal(other.DhcpOptionFqdn) {
		return false
	}

	if !v.DisableOobDownAlarm.Equal(other.DisableOobDownAlarm) {
		return false
	}

	if !v.FipsEnabled.Equal(other.FipsEnabled) {
		return false
	}

	if !v.LocalAccounts.Equal(other.LocalAccounts) {
		return false
	}

	if !v.MxedgeProxyHost.Equal(other.MxedgeProxyHost) {
		return false
	}

	if !v.MxedgeProxyPort.Equal(other.MxedgeProxyPort) {
		return false
	}

	if !v.ProtectRe.Equal(other.ProtectRe) {
		return false
	}

	if !v.RemoveExistingConfigs.Equal(other.RemoveExistingConfigs) {
		return false
	}

	if !v.RootPassword.Equal(other.RootPassword) {
		return false
	}

	if !v.Tacacs.Equal(other.Tacacs) {
		return false
	}

	if !v.UseMxedgeProxy.Equal(other.UseMxedgeProxy) {
		return false
	}

	return true
}

func (v SwitchMgmtValue) Type(ctx context.Context) attr.Type {
	return SwitchMgmtType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SwitchMgmtValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"ap_affinity_threshold":  basetypes.Int64Type{},
		"cli_banner":             basetypes.StringType{},
		"cli_idle_timeout":       basetypes.Int64Type{},
		"config_revert_timer":    basetypes.Int64Type{},
		"dhcp_option_fqdn":       basetypes.BoolType{},
		"disable_oob_down_alarm": basetypes.BoolType{},
		"fips_enabled":           basetypes.BoolType{},
		"local_accounts": basetypes.MapType{
			ElemType: LocalAccountsValue{}.Type(ctx),
		},
		"mxedge_proxy_host": basetypes.StringType{},
		"mxedge_proxy_port": basetypes.StringType{},
		"protect_re": basetypes.ObjectType{
			AttrTypes: ProtectReValue{}.AttributeTypes(ctx),
		},
		"remove_existing_configs": basetypes.BoolType{},
		"root_password":           basetypes.StringType{},
		"tacacs": basetypes.ObjectType{
			AttrTypes: TacacsValue{}.AttributeTypes(ctx),
		},
		"use_mxedge_proxy": basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = LocalAccountsType{}

type LocalAccountsType struct {
	basetypes.ObjectType
}

func (t LocalAccountsType) Equal(o attr.Type) bool {
	other, ok := o.(LocalAccountsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t LocalAccountsType) String() string {
	return "LocalAccountsType"
}

func (t LocalAccountsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	passwordAttribute, ok := attributes["password"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`password is missing from object`)

		return nil, diags
	}

	passwordVal, ok := passwordAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`password expected to be basetypes.StringValue, was: %T`, passwordAttribute))
	}

	roleAttribute, ok := attributes["role"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`role is missing from object`)

		return nil, diags
	}

	roleVal, ok := roleAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`role expected to be basetypes.StringValue, was: %T`, roleAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return LocalAccountsValue{
		Password: passwordVal,
		Role:     roleVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewLocalAccountsValueNull() LocalAccountsValue {
	return LocalAccountsValue{
		state: attr.ValueStateNull,
	}
}

func NewLocalAccountsValueUnknown() LocalAccountsValue {
	return LocalAccountsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewLocalAccountsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (LocalAccountsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing LocalAccountsValue Attribute Value",
				"While creating a LocalAccountsValue value, a missing attribute value was detected. "+
					"A LocalAccountsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("LocalAccountsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid LocalAccountsValue Attribute Type",
				"While creating a LocalAccountsValue value, an invalid attribute value was detected. "+
					"A LocalAccountsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("LocalAccountsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("LocalAccountsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra LocalAccountsValue Attribute Value",
				"While creating a LocalAccountsValue value, an extra attribute value was detected. "+
					"A LocalAccountsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra LocalAccountsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewLocalAccountsValueUnknown(), diags
	}

	passwordAttribute, ok := attributes["password"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`password is missing from object`)

		return NewLocalAccountsValueUnknown(), diags
	}

	passwordVal, ok := passwordAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`password expected to be basetypes.StringValue, was: %T`, passwordAttribute))
	}

	roleAttribute, ok := attributes["role"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`role is missing from object`)

		return NewLocalAccountsValueUnknown(), diags
	}

	roleVal, ok := roleAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`role expected to be basetypes.StringValue, was: %T`, roleAttribute))
	}

	if diags.HasError() {
		return NewLocalAccountsValueUnknown(), diags
	}

	return LocalAccountsValue{
		Password: passwordVal,
		Role:     roleVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewLocalAccountsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) LocalAccountsValue {
	object, diags := NewLocalAccountsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewLocalAccountsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t LocalAccountsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewLocalAccountsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewLocalAccountsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewLocalAccountsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewLocalAccountsValueMust(LocalAccountsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t LocalAccountsType) ValueType(ctx context.Context) attr.Value {
	return LocalAccountsValue{}
}

var _ basetypes.ObjectValuable = LocalAccountsValue{}

type LocalAccountsValue struct {
	Password basetypes.StringValue `tfsdk:"password"`
	Role     basetypes.StringValue `tfsdk:"role"`
	state    attr.ValueState
}

func (v LocalAccountsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["password"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["role"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Password.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["password"] = val

		val, err = v.Role.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["role"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v LocalAccountsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v LocalAccountsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v LocalAccountsValue) String() string {
	return "LocalAccountsValue"
}

func (v LocalAccountsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"password": basetypes.StringType{},
		"role":     basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"password": v.Password,
			"role":     v.Role,
		})

	return objVal, diags
}

func (v LocalAccountsValue) Equal(o attr.Value) bool {
	other, ok := o.(LocalAccountsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Password.Equal(other.Password) {
		return false
	}

	if !v.Role.Equal(other.Role) {
		return false
	}

	return true
}

func (v LocalAccountsValue) Type(ctx context.Context) attr.Type {
	return LocalAccountsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v LocalAccountsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"password": basetypes.StringType{},
		"role":     basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = ProtectReType{}

type ProtectReType struct {
	basetypes.ObjectType
}

func (t ProtectReType) Equal(o attr.Type) bool {
	other, ok := o.(ProtectReType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ProtectReType) String() string {
	return "ProtectReType"
}

func (t ProtectReType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	allowedServicesAttribute, ok := attributes["allowed_services"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allowed_services is missing from object`)

		return nil, diags
	}

	allowedServicesVal, ok := allowedServicesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allowed_services expected to be basetypes.ListValue, was: %T`, allowedServicesAttribute))
	}

	customAttribute, ok := attributes["custom"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`custom is missing from object`)

		return nil, diags
	}

	customVal, ok := customAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`custom expected to be basetypes.ListValue, was: %T`, customAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	hitCountAttribute, ok := attributes["hit_count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`hit_count is missing from object`)

		return nil, diags
	}

	hitCountVal, ok := hitCountAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`hit_count expected to be basetypes.BoolValue, was: %T`, hitCountAttribute))
	}

	trustedHostsAttribute, ok := attributes["trusted_hosts"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`trusted_hosts is missing from object`)

		return nil, diags
	}

	trustedHostsVal, ok := trustedHostsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`trusted_hosts expected to be basetypes.ListValue, was: %T`, trustedHostsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ProtectReValue{
		AllowedServices: allowedServicesVal,
		Custom:          customVal,
		Enabled:         enabledVal,
		HitCount:        hitCountVal,
		TrustedHosts:    trustedHostsVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewProtectReValueNull() ProtectReValue {
	return ProtectReValue{
		state: attr.ValueStateNull,
	}
}

func NewProtectReValueUnknown() ProtectReValue {
	return ProtectReValue{
		state: attr.ValueStateUnknown,
	}
}

func NewProtectReValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ProtectReValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ProtectReValue Attribute Value",
				"While creating a ProtectReValue value, a missing attribute value was detected. "+
					"A ProtectReValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ProtectReValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ProtectReValue Attribute Type",
				"While creating a ProtectReValue value, an invalid attribute value was detected. "+
					"A ProtectReValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ProtectReValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ProtectReValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ProtectReValue Attribute Value",
				"While creating a ProtectReValue value, an extra attribute value was detected. "+
					"A ProtectReValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ProtectReValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewProtectReValueUnknown(), diags
	}

	allowedServicesAttribute, ok := attributes["allowed_services"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allowed_services is missing from object`)

		return NewProtectReValueUnknown(), diags
	}

	allowedServicesVal, ok := allowedServicesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allowed_services expected to be basetypes.ListValue, was: %T`, allowedServicesAttribute))
	}

	customAttribute, ok := attributes["custom"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`custom is missing from object`)

		return NewProtectReValueUnknown(), diags
	}

	customVal, ok := customAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`custom expected to be basetypes.ListValue, was: %T`, customAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewProtectReValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	hitCountAttribute, ok := attributes["hit_count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`hit_count is missing from object`)

		return NewProtectReValueUnknown(), diags
	}

	hitCountVal, ok := hitCountAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`hit_count expected to be basetypes.BoolValue, was: %T`, hitCountAttribute))
	}

	trustedHostsAttribute, ok := attributes["trusted_hosts"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`trusted_hosts is missing from object`)

		return NewProtectReValueUnknown(), diags
	}

	trustedHostsVal, ok := trustedHostsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`trusted_hosts expected to be basetypes.ListValue, was: %T`, trustedHostsAttribute))
	}

	if diags.HasError() {
		return NewProtectReValueUnknown(), diags
	}

	return ProtectReValue{
		AllowedServices: allowedServicesVal,
		Custom:          customVal,
		Enabled:         enabledVal,
		HitCount:        hitCountVal,
		TrustedHosts:    trustedHostsVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewProtectReValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ProtectReValue {
	object, diags := NewProtectReValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewProtectReValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ProtectReType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewProtectReValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewProtectReValueUnknown(), nil
	}

	if in.IsNull() {
		return NewProtectReValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewProtectReValueMust(ProtectReValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ProtectReType) ValueType(ctx context.Context) attr.Value {
	return ProtectReValue{}
}

var _ basetypes.ObjectValuable = ProtectReValue{}

type ProtectReValue struct {
	AllowedServices basetypes.ListValue `tfsdk:"allowed_services"`
	Custom          basetypes.ListValue `tfsdk:"custom"`
	Enabled         basetypes.BoolValue `tfsdk:"enabled"`
	HitCount        basetypes.BoolValue `tfsdk:"hit_count"`
	TrustedHosts    basetypes.ListValue `tfsdk:"trusted_hosts"`
	state           attr.ValueState
}

func (v ProtectReValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["allowed_services"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["custom"] = basetypes.ListType{
		ElemType: CustomValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["hit_count"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["trusted_hosts"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.AllowedServices.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["allowed_services"] = val

		val, err = v.Custom.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["custom"] = val

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.HitCount.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["hit_count"] = val

		val, err = v.TrustedHosts.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["trusted_hosts"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ProtectReValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ProtectReValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ProtectReValue) String() string {
	return "ProtectReValue"
}

func (v ProtectReValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	custom := types.ListValueMust(
		CustomType{
			basetypes.ObjectType{
				AttrTypes: CustomValue{}.AttributeTypes(ctx),
			},
		},
		v.Custom.Elements(),
	)

	if v.Custom.IsNull() {
		custom = types.ListNull(
			CustomType{
				basetypes.ObjectType{
					AttrTypes: CustomValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Custom.IsUnknown() {
		custom = types.ListUnknown(
			CustomType{
				basetypes.ObjectType{
					AttrTypes: CustomValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var allowedServicesVal basetypes.ListValue
	switch {
	case v.AllowedServices.IsUnknown():
		allowedServicesVal = types.ListUnknown(types.StringType)
	case v.AllowedServices.IsNull():
		allowedServicesVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		allowedServicesVal, d = types.ListValue(types.StringType, v.AllowedServices.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"allowed_services": basetypes.ListType{
				ElemType: types.StringType,
			},
			"custom": basetypes.ListType{
				ElemType: CustomValue{}.Type(ctx),
			},
			"enabled":   basetypes.BoolType{},
			"hit_count": basetypes.BoolType{},
			"trusted_hosts": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	var trustedHostsVal basetypes.ListValue
	switch {
	case v.TrustedHosts.IsUnknown():
		trustedHostsVal = types.ListUnknown(types.StringType)
	case v.TrustedHosts.IsNull():
		trustedHostsVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		trustedHostsVal, d = types.ListValue(types.StringType, v.TrustedHosts.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"allowed_services": basetypes.ListType{
				ElemType: types.StringType,
			},
			"custom": basetypes.ListType{
				ElemType: CustomValue{}.Type(ctx),
			},
			"enabled":   basetypes.BoolType{},
			"hit_count": basetypes.BoolType{},
			"trusted_hosts": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"allowed_services": basetypes.ListType{
			ElemType: types.StringType,
		},
		"custom": basetypes.ListType{
			ElemType: CustomValue{}.Type(ctx),
		},
		"enabled":   basetypes.BoolType{},
		"hit_count": basetypes.BoolType{},
		"trusted_hosts": basetypes.ListType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"allowed_services": allowedServicesVal,
			"custom":           custom,
			"enabled":          v.Enabled,
			"hit_count":        v.HitCount,
			"trusted_hosts":    trustedHostsVal,
		})

	return objVal, diags
}

func (v ProtectReValue) Equal(o attr.Value) bool {
	other, ok := o.(ProtectReValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AllowedServices.Equal(other.AllowedServices) {
		return false
	}

	if !v.Custom.Equal(other.Custom) {
		return false
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.HitCount.Equal(other.HitCount) {
		return false
	}

	if !v.TrustedHosts.Equal(other.TrustedHosts) {
		return false
	}

	return true
}

func (v ProtectReValue) Type(ctx context.Context) attr.Type {
	return ProtectReType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ProtectReValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"allowed_services": basetypes.ListType{
			ElemType: types.StringType,
		},
		"custom": basetypes.ListType{
			ElemType: CustomValue{}.Type(ctx),
		},
		"enabled":   basetypes.BoolType{},
		"hit_count": basetypes.BoolType{},
		"trusted_hosts": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = CustomType{}

type CustomType struct {
	basetypes.ObjectType
}

func (t CustomType) Equal(o attr.Type) bool {
	other, ok := o.(CustomType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t CustomType) String() string {
	return "CustomType"
}

func (t CustomType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	portRangeAttribute, ok := attributes["port_range"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_range is missing from object`)

		return nil, diags
	}

	portRangeVal, ok := portRangeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_range expected to be basetypes.StringValue, was: %T`, portRangeAttribute))
	}

	protocolAttribute, ok := attributes["protocol"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`protocol is missing from object`)

		return nil, diags
	}

	protocolVal, ok := protocolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`protocol expected to be basetypes.StringValue, was: %T`, protocolAttribute))
	}

	subnetsAttribute, ok := attributes["subnets"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnets is missing from object`)

		return nil, diags
	}

	subnetsVal, ok := subnetsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnets expected to be basetypes.ListValue, was: %T`, subnetsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return CustomValue{
		PortRange: portRangeVal,
		Protocol:  protocolVal,
		Subnets:   subnetsVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewCustomValueNull() CustomValue {
	return CustomValue{
		state: attr.ValueStateNull,
	}
}

func NewCustomValueUnknown() CustomValue {
	return CustomValue{
		state: attr.ValueStateUnknown,
	}
}

func NewCustomValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (CustomValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing CustomValue Attribute Value",
				"While creating a CustomValue value, a missing attribute value was detected. "+
					"A CustomValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CustomValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid CustomValue Attribute Type",
				"While creating a CustomValue value, an invalid attribute value was detected. "+
					"A CustomValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CustomValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("CustomValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra CustomValue Attribute Value",
				"While creating a CustomValue value, an extra attribute value was detected. "+
					"A CustomValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra CustomValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewCustomValueUnknown(), diags
	}

	portRangeAttribute, ok := attributes["port_range"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_range is missing from object`)

		return NewCustomValueUnknown(), diags
	}

	portRangeVal, ok := portRangeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_range expected to be basetypes.StringValue, was: %T`, portRangeAttribute))
	}

	protocolAttribute, ok := attributes["protocol"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`protocol is missing from object`)

		return NewCustomValueUnknown(), diags
	}

	protocolVal, ok := protocolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`protocol expected to be basetypes.StringValue, was: %T`, protocolAttribute))
	}

	subnetsAttribute, ok := attributes["subnets"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnets is missing from object`)

		return NewCustomValueUnknown(), diags
	}

	subnetsVal, ok := subnetsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnets expected to be basetypes.ListValue, was: %T`, subnetsAttribute))
	}

	if diags.HasError() {
		return NewCustomValueUnknown(), diags
	}

	return CustomValue{
		PortRange: portRangeVal,
		Protocol:  protocolVal,
		Subnets:   subnetsVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewCustomValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) CustomValue {
	object, diags := NewCustomValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewCustomValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t CustomType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewCustomValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewCustomValueUnknown(), nil
	}

	if in.IsNull() {
		return NewCustomValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewCustomValueMust(CustomValue{}.AttributeTypes(ctx), attributes), nil
}

func (t CustomType) ValueType(ctx context.Context) attr.Value {
	return CustomValue{}
}

var _ basetypes.ObjectValuable = CustomValue{}

type CustomValue struct {
	PortRange basetypes.StringValue `tfsdk:"port_range"`
	Protocol  basetypes.StringValue `tfsdk:"protocol"`
	Subnets   basetypes.ListValue   `tfsdk:"subnets"`
	state     attr.ValueState
}

func (v CustomValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["port_range"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["protocol"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["subnets"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.PortRange.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port_range"] = val

		val, err = v.Protocol.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["protocol"] = val

		val, err = v.Subnets.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["subnets"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v CustomValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v CustomValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v CustomValue) String() string {
	return "CustomValue"
}

func (v CustomValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var subnetsVal basetypes.ListValue
	switch {
	case v.Subnets.IsUnknown():
		subnetsVal = types.ListUnknown(types.StringType)
	case v.Subnets.IsNull():
		subnetsVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		subnetsVal, d = types.ListValue(types.StringType, v.Subnets.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"port_range": basetypes.StringType{},
			"protocol":   basetypes.StringType{},
			"subnets": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"port_range": basetypes.StringType{},
		"protocol":   basetypes.StringType{},
		"subnets": basetypes.ListType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"port_range": v.PortRange,
			"protocol":   v.Protocol,
			"subnets":    subnetsVal,
		})

	return objVal, diags
}

func (v CustomValue) Equal(o attr.Value) bool {
	other, ok := o.(CustomValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.PortRange.Equal(other.PortRange) {
		return false
	}

	if !v.Protocol.Equal(other.Protocol) {
		return false
	}

	if !v.Subnets.Equal(other.Subnets) {
		return false
	}

	return true
}

func (v CustomValue) Type(ctx context.Context) attr.Type {
	return CustomType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v CustomValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"port_range": basetypes.StringType{},
		"protocol":   basetypes.StringType{},
		"subnets": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = TacacsType{}

type TacacsType struct {
	basetypes.ObjectType
}

func (t TacacsType) Equal(o attr.Type) bool {
	other, ok := o.(TacacsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t TacacsType) String() string {
	return "TacacsType"
}

func (t TacacsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	defaultRoleAttribute, ok := attributes["default_role"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`default_role is missing from object`)

		return nil, diags
	}

	defaultRoleVal, ok := defaultRoleAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`default_role expected to be basetypes.StringValue, was: %T`, defaultRoleAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	networkAttribute, ok := attributes["network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`network is missing from object`)

		return nil, diags
	}

	networkVal, ok := networkAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`network expected to be basetypes.StringValue, was: %T`, networkAttribute))
	}

	tacacctServersAttribute, ok := attributes["acct_servers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`acct_servers is missing from object`)

		return nil, diags
	}

	tacacctServersVal, ok := tacacctServersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`acct_servers expected to be basetypes.ListValue, was: %T`, tacacctServersAttribute))
	}

	tacplusServersAttribute, ok := attributes["tacplus_servers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tacplus_servers is missing from object`)

		return nil, diags
	}

	tacplusServersVal, ok := tacplusServersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tacplus_servers expected to be basetypes.ListValue, was: %T`, tacplusServersAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return TacacsValue{
		DefaultRole:    defaultRoleVal,
		Enabled:        enabledVal,
		Network:        networkVal,
		TacacctServers: tacacctServersVal,
		TacplusServers: tacplusServersVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewTacacsValueNull() TacacsValue {
	return TacacsValue{
		state: attr.ValueStateNull,
	}
}

func NewTacacsValueUnknown() TacacsValue {
	return TacacsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewTacacsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (TacacsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing TacacsValue Attribute Value",
				"While creating a TacacsValue value, a missing attribute value was detected. "+
					"A TacacsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TacacsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid TacacsValue Attribute Type",
				"While creating a TacacsValue value, an invalid attribute value was detected. "+
					"A TacacsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TacacsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("TacacsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra TacacsValue Attribute Value",
				"While creating a TacacsValue value, an extra attribute value was detected. "+
					"A TacacsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra TacacsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewTacacsValueUnknown(), diags
	}

	defaultRoleAttribute, ok := attributes["default_role"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`default_role is missing from object`)

		return NewTacacsValueUnknown(), diags
	}

	defaultRoleVal, ok := defaultRoleAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`default_role expected to be basetypes.StringValue, was: %T`, defaultRoleAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewTacacsValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	networkAttribute, ok := attributes["network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`network is missing from object`)

		return NewTacacsValueUnknown(), diags
	}

	networkVal, ok := networkAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`network expected to be basetypes.StringValue, was: %T`, networkAttribute))
	}

	tacacctServersAttribute, ok := attributes["acct_servers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`acct_servers is missing from object`)

		return NewTacacsValueUnknown(), diags
	}

	tacacctServersVal, ok := tacacctServersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`acct_servers expected to be basetypes.ListValue, was: %T`, tacacctServersAttribute))
	}

	tacplusServersAttribute, ok := attributes["tacplus_servers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tacplus_servers is missing from object`)

		return NewTacacsValueUnknown(), diags
	}

	tacplusServersVal, ok := tacplusServersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tacplus_servers expected to be basetypes.ListValue, was: %T`, tacplusServersAttribute))
	}

	if diags.HasError() {
		return NewTacacsValueUnknown(), diags
	}

	return TacacsValue{
		DefaultRole:    defaultRoleVal,
		Enabled:        enabledVal,
		Network:        networkVal,
		TacacctServers: tacacctServersVal,
		TacplusServers: tacplusServersVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewTacacsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) TacacsValue {
	object, diags := NewTacacsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewTacacsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t TacacsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewTacacsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewTacacsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewTacacsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewTacacsValueMust(TacacsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t TacacsType) ValueType(ctx context.Context) attr.Value {
	return TacacsValue{}
}

var _ basetypes.ObjectValuable = TacacsValue{}

type TacacsValue struct {
	DefaultRole    basetypes.StringValue `tfsdk:"default_role"`
	Enabled        basetypes.BoolValue   `tfsdk:"enabled"`
	Network        basetypes.StringValue `tfsdk:"network"`
	TacacctServers basetypes.ListValue   `tfsdk:"acct_servers"`
	TacplusServers basetypes.ListValue   `tfsdk:"tacplus_servers"`
	state          attr.ValueState
}

func (v TacacsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["default_role"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["network"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["acct_servers"] = basetypes.ListType{
		ElemType: TacacctServersValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["tacplus_servers"] = basetypes.ListType{
		ElemType: TacplusServersValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.DefaultRole.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["default_role"] = val

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.Network.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["network"] = val

		val, err = v.TacacctServers.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["acct_servers"] = val

		val, err = v.TacplusServers.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tacplus_servers"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v TacacsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v TacacsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v TacacsValue) String() string {
	return "TacacsValue"
}

func (v TacacsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	tacacctServers := types.ListValueMust(
		TacacctServersType{
			basetypes.ObjectType{
				AttrTypes: TacacctServersValue{}.AttributeTypes(ctx),
			},
		},
		v.TacacctServers.Elements(),
	)

	if v.TacacctServers.IsNull() {
		tacacctServers = types.ListNull(
			TacacctServersType{
				basetypes.ObjectType{
					AttrTypes: TacacctServersValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.TacacctServers.IsUnknown() {
		tacacctServers = types.ListUnknown(
			TacacctServersType{
				basetypes.ObjectType{
					AttrTypes: TacacctServersValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	tacplusServers := types.ListValueMust(
		TacplusServersType{
			basetypes.ObjectType{
				AttrTypes: TacplusServersValue{}.AttributeTypes(ctx),
			},
		},
		v.TacplusServers.Elements(),
	)

	if v.TacplusServers.IsNull() {
		tacplusServers = types.ListNull(
			TacplusServersType{
				basetypes.ObjectType{
					AttrTypes: TacplusServersValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.TacplusServers.IsUnknown() {
		tacplusServers = types.ListUnknown(
			TacplusServersType{
				basetypes.ObjectType{
					AttrTypes: TacplusServersValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"default_role": basetypes.StringType{},
		"enabled":      basetypes.BoolType{},
		"network":      basetypes.StringType{},
		"acct_servers": basetypes.ListType{
			ElemType: TacacctServersValue{}.Type(ctx),
		},
		"tacplus_servers": basetypes.ListType{
			ElemType: TacplusServersValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"default_role":    v.DefaultRole,
			"enabled":         v.Enabled,
			"network":         v.Network,
			"acct_servers":    tacacctServers,
			"tacplus_servers": tacplusServers,
		})

	return objVal, diags
}

func (v TacacsValue) Equal(o attr.Value) bool {
	other, ok := o.(TacacsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.DefaultRole.Equal(other.DefaultRole) {
		return false
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.Network.Equal(other.Network) {
		return false
	}

	if !v.TacacctServers.Equal(other.TacacctServers) {
		return false
	}

	if !v.TacplusServers.Equal(other.TacplusServers) {
		return false
	}

	return true
}

func (v TacacsValue) Type(ctx context.Context) attr.Type {
	return TacacsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v TacacsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"default_role": basetypes.StringType{},
		"enabled":      basetypes.BoolType{},
		"network":      basetypes.StringType{},
		"acct_servers": basetypes.ListType{
			ElemType: TacacctServersValue{}.Type(ctx),
		},
		"tacplus_servers": basetypes.ListType{
			ElemType: TacplusServersValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = TacacctServersType{}

type TacacctServersType struct {
	basetypes.ObjectType
}

func (t TacacctServersType) Equal(o attr.Type) bool {
	other, ok := o.(TacacctServersType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t TacacctServersType) String() string {
	return "TacacctServersType"
}

func (t TacacctServersType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	hostAttribute, ok := attributes["host"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`host is missing from object`)

		return nil, diags
	}

	hostVal, ok := hostAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`host expected to be basetypes.StringValue, was: %T`, hostAttribute))
	}

	portAttribute, ok := attributes["port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port is missing from object`)

		return nil, diags
	}

	portVal, ok := portAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port expected to be basetypes.StringValue, was: %T`, portAttribute))
	}

	secretAttribute, ok := attributes["secret"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`secret is missing from object`)

		return nil, diags
	}

	secretVal, ok := secretAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`secret expected to be basetypes.StringValue, was: %T`, secretAttribute))
	}

	timeoutAttribute, ok := attributes["timeout"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`timeout is missing from object`)

		return nil, diags
	}

	timeoutVal, ok := timeoutAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`timeout expected to be basetypes.Int64Value, was: %T`, timeoutAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return TacacctServersValue{
		Host:    hostVal,
		Port:    portVal,
		Secret:  secretVal,
		Timeout: timeoutVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewTacacctServersValueNull() TacacctServersValue {
	return TacacctServersValue{
		state: attr.ValueStateNull,
	}
}

func NewTacacctServersValueUnknown() TacacctServersValue {
	return TacacctServersValue{
		state: attr.ValueStateUnknown,
	}
}

func NewTacacctServersValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (TacacctServersValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing TacacctServersValue Attribute Value",
				"While creating a TacacctServersValue value, a missing attribute value was detected. "+
					"A TacacctServersValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TacacctServersValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid TacacctServersValue Attribute Type",
				"While creating a TacacctServersValue value, an invalid attribute value was detected. "+
					"A TacacctServersValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TacacctServersValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("TacacctServersValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra TacacctServersValue Attribute Value",
				"While creating a TacacctServersValue value, an extra attribute value was detected. "+
					"A TacacctServersValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra TacacctServersValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewTacacctServersValueUnknown(), diags
	}

	hostAttribute, ok := attributes["host"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`host is missing from object`)

		return NewTacacctServersValueUnknown(), diags
	}

	hostVal, ok := hostAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`host expected to be basetypes.StringValue, was: %T`, hostAttribute))
	}

	portAttribute, ok := attributes["port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port is missing from object`)

		return NewTacacctServersValueUnknown(), diags
	}

	portVal, ok := portAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port expected to be basetypes.StringValue, was: %T`, portAttribute))
	}

	secretAttribute, ok := attributes["secret"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`secret is missing from object`)

		return NewTacacctServersValueUnknown(), diags
	}

	secretVal, ok := secretAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`secret expected to be basetypes.StringValue, was: %T`, secretAttribute))
	}

	timeoutAttribute, ok := attributes["timeout"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`timeout is missing from object`)

		return NewTacacctServersValueUnknown(), diags
	}

	timeoutVal, ok := timeoutAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`timeout expected to be basetypes.Int64Value, was: %T`, timeoutAttribute))
	}

	if diags.HasError() {
		return NewTacacctServersValueUnknown(), diags
	}

	return TacacctServersValue{
		Host:    hostVal,
		Port:    portVal,
		Secret:  secretVal,
		Timeout: timeoutVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewTacacctServersValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) TacacctServersValue {
	object, diags := NewTacacctServersValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewTacacctServersValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t TacacctServersType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewTacacctServersValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewTacacctServersValueUnknown(), nil
	}

	if in.IsNull() {
		return NewTacacctServersValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewTacacctServersValueMust(TacacctServersValue{}.AttributeTypes(ctx), attributes), nil
}

func (t TacacctServersType) ValueType(ctx context.Context) attr.Value {
	return TacacctServersValue{}
}

var _ basetypes.ObjectValuable = TacacctServersValue{}

type TacacctServersValue struct {
	Host    basetypes.StringValue `tfsdk:"host"`
	Port    basetypes.StringValue `tfsdk:"port"`
	Secret  basetypes.StringValue `tfsdk:"secret"`
	Timeout basetypes.Int64Value  `tfsdk:"timeout"`
	state   attr.ValueState
}

func (v TacacctServersValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["host"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["port"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["secret"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["timeout"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Host.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["host"] = val

		val, err = v.Port.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port"] = val

		val, err = v.Secret.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["secret"] = val

		val, err = v.Timeout.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["timeout"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v TacacctServersValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v TacacctServersValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v TacacctServersValue) String() string {
	return "TacacctServersValue"
}

func (v TacacctServersValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"host":    basetypes.StringType{},
		"port":    basetypes.StringType{},
		"secret":  basetypes.StringType{},
		"timeout": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"host":    v.Host,
			"port":    v.Port,
			"secret":  v.Secret,
			"timeout": v.Timeout,
		})

	return objVal, diags
}

func (v TacacctServersValue) Equal(o attr.Value) bool {
	other, ok := o.(TacacctServersValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Host.Equal(other.Host) {
		return false
	}

	if !v.Port.Equal(other.Port) {
		return false
	}

	if !v.Secret.Equal(other.Secret) {
		return false
	}

	if !v.Timeout.Equal(other.Timeout) {
		return false
	}

	return true
}

func (v TacacctServersValue) Type(ctx context.Context) attr.Type {
	return TacacctServersType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v TacacctServersValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"host":    basetypes.StringType{},
		"port":    basetypes.StringType{},
		"secret":  basetypes.StringType{},
		"timeout": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = TacplusServersType{}

type TacplusServersType struct {
	basetypes.ObjectType
}

func (t TacplusServersType) Equal(o attr.Type) bool {
	other, ok := o.(TacplusServersType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t TacplusServersType) String() string {
	return "TacplusServersType"
}

func (t TacplusServersType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	hostAttribute, ok := attributes["host"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`host is missing from object`)

		return nil, diags
	}

	hostVal, ok := hostAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`host expected to be basetypes.StringValue, was: %T`, hostAttribute))
	}

	portAttribute, ok := attributes["port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port is missing from object`)

		return nil, diags
	}

	portVal, ok := portAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port expected to be basetypes.StringValue, was: %T`, portAttribute))
	}

	secretAttribute, ok := attributes["secret"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`secret is missing from object`)

		return nil, diags
	}

	secretVal, ok := secretAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`secret expected to be basetypes.StringValue, was: %T`, secretAttribute))
	}

	timeoutAttribute, ok := attributes["timeout"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`timeout is missing from object`)

		return nil, diags
	}

	timeoutVal, ok := timeoutAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`timeout expected to be basetypes.Int64Value, was: %T`, timeoutAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return TacplusServersValue{
		Host:    hostVal,
		Port:    portVal,
		Secret:  secretVal,
		Timeout: timeoutVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewTacplusServersValueNull() TacplusServersValue {
	return TacplusServersValue{
		state: attr.ValueStateNull,
	}
}

func NewTacplusServersValueUnknown() TacplusServersValue {
	return TacplusServersValue{
		state: attr.ValueStateUnknown,
	}
}

func NewTacplusServersValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (TacplusServersValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing TacplusServersValue Attribute Value",
				"While creating a TacplusServersValue value, a missing attribute value was detected. "+
					"A TacplusServersValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TacplusServersValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid TacplusServersValue Attribute Type",
				"While creating a TacplusServersValue value, an invalid attribute value was detected. "+
					"A TacplusServersValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TacplusServersValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("TacplusServersValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra TacplusServersValue Attribute Value",
				"While creating a TacplusServersValue value, an extra attribute value was detected. "+
					"A TacplusServersValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra TacplusServersValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewTacplusServersValueUnknown(), diags
	}

	hostAttribute, ok := attributes["host"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`host is missing from object`)

		return NewTacplusServersValueUnknown(), diags
	}

	hostVal, ok := hostAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`host expected to be basetypes.StringValue, was: %T`, hostAttribute))
	}

	portAttribute, ok := attributes["port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port is missing from object`)

		return NewTacplusServersValueUnknown(), diags
	}

	portVal, ok := portAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port expected to be basetypes.StringValue, was: %T`, portAttribute))
	}

	secretAttribute, ok := attributes["secret"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`secret is missing from object`)

		return NewTacplusServersValueUnknown(), diags
	}

	secretVal, ok := secretAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`secret expected to be basetypes.StringValue, was: %T`, secretAttribute))
	}

	timeoutAttribute, ok := attributes["timeout"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`timeout is missing from object`)

		return NewTacplusServersValueUnknown(), diags
	}

	timeoutVal, ok := timeoutAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`timeout expected to be basetypes.Int64Value, was: %T`, timeoutAttribute))
	}

	if diags.HasError() {
		return NewTacplusServersValueUnknown(), diags
	}

	return TacplusServersValue{
		Host:    hostVal,
		Port:    portVal,
		Secret:  secretVal,
		Timeout: timeoutVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewTacplusServersValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) TacplusServersValue {
	object, diags := NewTacplusServersValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewTacplusServersValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t TacplusServersType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewTacplusServersValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewTacplusServersValueUnknown(), nil
	}

	if in.IsNull() {
		return NewTacplusServersValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewTacplusServersValueMust(TacplusServersValue{}.AttributeTypes(ctx), attributes), nil
}

func (t TacplusServersType) ValueType(ctx context.Context) attr.Value {
	return TacplusServersValue{}
}

var _ basetypes.ObjectValuable = TacplusServersValue{}

type TacplusServersValue struct {
	Host    basetypes.StringValue `tfsdk:"host"`
	Port    basetypes.StringValue `tfsdk:"port"`
	Secret  basetypes.StringValue `tfsdk:"secret"`
	Timeout basetypes.Int64Value  `tfsdk:"timeout"`
	state   attr.ValueState
}

func (v TacplusServersValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["host"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["port"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["secret"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["timeout"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Host.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["host"] = val

		val, err = v.Port.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port"] = val

		val, err = v.Secret.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["secret"] = val

		val, err = v.Timeout.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["timeout"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v TacplusServersValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v TacplusServersValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v TacplusServersValue) String() string {
	return "TacplusServersValue"
}

func (v TacplusServersValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"host":    basetypes.StringType{},
		"port":    basetypes.StringType{},
		"secret":  basetypes.StringType{},
		"timeout": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"host":    v.Host,
			"port":    v.Port,
			"secret":  v.Secret,
			"timeout": v.Timeout,
		})

	return objVal, diags
}

func (v TacplusServersValue) Equal(o attr.Value) bool {
	other, ok := o.(TacplusServersValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Host.Equal(other.Host) {
		return false
	}

	if !v.Port.Equal(other.Port) {
		return false
	}

	if !v.Secret.Equal(other.Secret) {
		return false
	}

	if !v.Timeout.Equal(other.Timeout) {
		return false
	}

	return true
}

func (v TacplusServersValue) Type(ctx context.Context) attr.Type {
	return TacplusServersType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v TacplusServersValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"host":    basetypes.StringType{},
		"port":    basetypes.StringType{},
		"secret":  basetypes.StringType{},
		"timeout": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = VrfConfigType{}

type VrfConfigType struct {
	basetypes.ObjectType
}

func (t VrfConfigType) Equal(o attr.Type) bool {
	other, ok := o.(VrfConfigType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t VrfConfigType) String() string {
	return "VrfConfigType"
}

func (t VrfConfigType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return VrfConfigValue{
		Enabled: enabledVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewVrfConfigValueNull() VrfConfigValue {
	return VrfConfigValue{
		state: attr.ValueStateNull,
	}
}

func NewVrfConfigValueUnknown() VrfConfigValue {
	return VrfConfigValue{
		state: attr.ValueStateUnknown,
	}
}

func NewVrfConfigValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (VrfConfigValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing VrfConfigValue Attribute Value",
				"While creating a VrfConfigValue value, a missing attribute value was detected. "+
					"A VrfConfigValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VrfConfigValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid VrfConfigValue Attribute Type",
				"While creating a VrfConfigValue value, an invalid attribute value was detected. "+
					"A VrfConfigValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VrfConfigValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("VrfConfigValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra VrfConfigValue Attribute Value",
				"While creating a VrfConfigValue value, an extra attribute value was detected. "+
					"A VrfConfigValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra VrfConfigValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewVrfConfigValueUnknown(), diags
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewVrfConfigValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	if diags.HasError() {
		return NewVrfConfigValueUnknown(), diags
	}

	return VrfConfigValue{
		Enabled: enabledVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewVrfConfigValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) VrfConfigValue {
	object, diags := NewVrfConfigValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewVrfConfigValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t VrfConfigType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewVrfConfigValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewVrfConfigValueUnknown(), nil
	}

	if in.IsNull() {
		return NewVrfConfigValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewVrfConfigValueMust(VrfConfigValue{}.AttributeTypes(ctx), attributes), nil
}

func (t VrfConfigType) ValueType(ctx context.Context) attr.Value {
	return VrfConfigValue{}
}

var _ basetypes.ObjectValuable = VrfConfigValue{}

type VrfConfigValue struct {
	Enabled basetypes.BoolValue `tfsdk:"enabled"`
	state   attr.ValueState
}

func (v VrfConfigValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v VrfConfigValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v VrfConfigValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v VrfConfigValue) String() string {
	return "VrfConfigValue"
}

func (v VrfConfigValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"enabled": basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"enabled": v.Enabled,
		})

	return objVal, diags
}

func (v VrfConfigValue) Equal(o attr.Value) bool {
	other, ok := o.(VrfConfigValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	return true
}

func (v VrfConfigValue) Type(ctx context.Context) attr.Type {
	return VrfConfigType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v VrfConfigValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"enabled": basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = VrfInstancesType{}

type VrfInstancesType struct {
	basetypes.ObjectType
}

func (t VrfInstancesType) Equal(o attr.Type) bool {
	other, ok := o.(VrfInstancesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t VrfInstancesType) String() string {
	return "VrfInstancesType"
}

func (t VrfInstancesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	evpnAutoLoopbackSubnetAttribute, ok := attributes["evpn_auto_loopback_subnet"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`evpn_auto_loopback_subnet is missing from object`)

		return nil, diags
	}

	evpnAutoLoopbackSubnetVal, ok := evpnAutoLoopbackSubnetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`evpn_auto_loopback_subnet expected to be basetypes.StringValue, was: %T`, evpnAutoLoopbackSubnetAttribute))
	}

	evpnAutoLoopbackSubnet6Attribute, ok := attributes["evpn_auto_loopback_subnet6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`evpn_auto_loopback_subnet6 is missing from object`)

		return nil, diags
	}

	evpnAutoLoopbackSubnet6Val, ok := evpnAutoLoopbackSubnet6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`evpn_auto_loopback_subnet6 expected to be basetypes.StringValue, was: %T`, evpnAutoLoopbackSubnet6Attribute))
	}

	networksAttribute, ok := attributes["networks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`networks is missing from object`)

		return nil, diags
	}

	networksVal, ok := networksAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`networks expected to be basetypes.ListValue, was: %T`, networksAttribute))
	}

	vrfExtraRoutesAttribute, ok := attributes["extra_routes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`extra_routes is missing from object`)

		return nil, diags
	}

	vrfExtraRoutesVal, ok := vrfExtraRoutesAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`extra_routes expected to be basetypes.MapValue, was: %T`, vrfExtraRoutesAttribute))
	}

	vrfExtraRoutes6Attribute, ok := attributes["extra_routes6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`extra_routes6 is missing from object`)

		return nil, diags
	}

	vrfExtraRoutes6Val, ok := vrfExtraRoutes6Attribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`extra_routes6 expected to be basetypes.MapValue, was: %T`, vrfExtraRoutes6Attribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return VrfInstancesValue{
		EvpnAutoLoopbackSubnet:  evpnAutoLoopbackSubnetVal,
		EvpnAutoLoopbackSubnet6: evpnAutoLoopbackSubnet6Val,
		Networks:                networksVal,
		VrfExtraRoutes:          vrfExtraRoutesVal,
		VrfExtraRoutes6:         vrfExtraRoutes6Val,
		state:                   attr.ValueStateKnown,
	}, diags
}

func NewVrfInstancesValueNull() VrfInstancesValue {
	return VrfInstancesValue{
		state: attr.ValueStateNull,
	}
}

func NewVrfInstancesValueUnknown() VrfInstancesValue {
	return VrfInstancesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewVrfInstancesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (VrfInstancesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing VrfInstancesValue Attribute Value",
				"While creating a VrfInstancesValue value, a missing attribute value was detected. "+
					"A VrfInstancesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VrfInstancesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid VrfInstancesValue Attribute Type",
				"While creating a VrfInstancesValue value, an invalid attribute value was detected. "+
					"A VrfInstancesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VrfInstancesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("VrfInstancesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra VrfInstancesValue Attribute Value",
				"While creating a VrfInstancesValue value, an extra attribute value was detected. "+
					"A VrfInstancesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra VrfInstancesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewVrfInstancesValueUnknown(), diags
	}

	evpnAutoLoopbackSubnetAttribute, ok := attributes["evpn_auto_loopback_subnet"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`evpn_auto_loopback_subnet is missing from object`)

		return NewVrfInstancesValueUnknown(), diags
	}

	evpnAutoLoopbackSubnetVal, ok := evpnAutoLoopbackSubnetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`evpn_auto_loopback_subnet expected to be basetypes.StringValue, was: %T`, evpnAutoLoopbackSubnetAttribute))
	}

	evpnAutoLoopbackSubnet6Attribute, ok := attributes["evpn_auto_loopback_subnet6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`evpn_auto_loopback_subnet6 is missing from object`)

		return NewVrfInstancesValueUnknown(), diags
	}

	evpnAutoLoopbackSubnet6Val, ok := evpnAutoLoopbackSubnet6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`evpn_auto_loopback_subnet6 expected to be basetypes.StringValue, was: %T`, evpnAutoLoopbackSubnet6Attribute))
	}

	networksAttribute, ok := attributes["networks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`networks is missing from object`)

		return NewVrfInstancesValueUnknown(), diags
	}

	networksVal, ok := networksAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`networks expected to be basetypes.ListValue, was: %T`, networksAttribute))
	}

	vrfExtraRoutesAttribute, ok := attributes["extra_routes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`extra_routes is missing from object`)

		return NewVrfInstancesValueUnknown(), diags
	}

	vrfExtraRoutesVal, ok := vrfExtraRoutesAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`extra_routes expected to be basetypes.MapValue, was: %T`, vrfExtraRoutesAttribute))
	}

	vrfExtraRoutes6Attribute, ok := attributes["extra_routes6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`extra_routes6 is missing from object`)

		return NewVrfInstancesValueUnknown(), diags
	}

	vrfExtraRoutes6Val, ok := vrfExtraRoutes6Attribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`extra_routes6 expected to be basetypes.MapValue, was: %T`, vrfExtraRoutes6Attribute))
	}

	if diags.HasError() {
		return NewVrfInstancesValueUnknown(), diags
	}

	return VrfInstancesValue{
		EvpnAutoLoopbackSubnet:  evpnAutoLoopbackSubnetVal,
		EvpnAutoLoopbackSubnet6: evpnAutoLoopbackSubnet6Val,
		Networks:                networksVal,
		VrfExtraRoutes:          vrfExtraRoutesVal,
		VrfExtraRoutes6:         vrfExtraRoutes6Val,
		state:                   attr.ValueStateKnown,
	}, diags
}

func NewVrfInstancesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) VrfInstancesValue {
	object, diags := NewVrfInstancesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewVrfInstancesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t VrfInstancesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewVrfInstancesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewVrfInstancesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewVrfInstancesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewVrfInstancesValueMust(VrfInstancesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t VrfInstancesType) ValueType(ctx context.Context) attr.Value {
	return VrfInstancesValue{}
}

var _ basetypes.ObjectValuable = VrfInstancesValue{}

type VrfInstancesValue struct {
	EvpnAutoLoopbackSubnet  basetypes.StringValue `tfsdk:"evpn_auto_loopback_subnet"`
	EvpnAutoLoopbackSubnet6 basetypes.StringValue `tfsdk:"evpn_auto_loopback_subnet6"`
	Networks                basetypes.ListValue   `tfsdk:"networks"`
	VrfExtraRoutes          basetypes.MapValue    `tfsdk:"extra_routes"`
	VrfExtraRoutes6         basetypes.MapValue    `tfsdk:"extra_routes6"`
	state                   attr.ValueState
}

func (v VrfInstancesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["evpn_auto_loopback_subnet"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["evpn_auto_loopback_subnet6"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["networks"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["extra_routes"] = basetypes.MapType{
		ElemType: VrfExtraRoutesValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["extra_routes6"] = basetypes.MapType{
		ElemType: VrfExtraRoutes6Value{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.EvpnAutoLoopbackSubnet.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["evpn_auto_loopback_subnet"] = val

		val, err = v.EvpnAutoLoopbackSubnet6.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["evpn_auto_loopback_subnet6"] = val

		val, err = v.Networks.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["networks"] = val

		val, err = v.VrfExtraRoutes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["extra_routes"] = val

		val, err = v.VrfExtraRoutes6.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["extra_routes6"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v VrfInstancesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v VrfInstancesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v VrfInstancesValue) String() string {
	return "VrfInstancesValue"
}

func (v VrfInstancesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	vrfExtraRoutes := types.MapValueMust(
		VrfExtraRoutesType{
			basetypes.ObjectType{
				AttrTypes: VrfExtraRoutesValue{}.AttributeTypes(ctx),
			},
		},
		v.VrfExtraRoutes.Elements(),
	)

	if v.VrfExtraRoutes.IsNull() {
		vrfExtraRoutes = types.MapNull(
			VrfExtraRoutesType{
				basetypes.ObjectType{
					AttrTypes: VrfExtraRoutesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.VrfExtraRoutes.IsUnknown() {
		vrfExtraRoutes = types.MapUnknown(
			VrfExtraRoutesType{
				basetypes.ObjectType{
					AttrTypes: VrfExtraRoutesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	vrfExtraRoutes6 := types.MapValueMust(
		VrfExtraRoutes6Type{
			basetypes.ObjectType{
				AttrTypes: VrfExtraRoutes6Value{}.AttributeTypes(ctx),
			},
		},
		v.VrfExtraRoutes6.Elements(),
	)

	if v.VrfExtraRoutes6.IsNull() {
		vrfExtraRoutes6 = types.MapNull(
			VrfExtraRoutes6Type{
				basetypes.ObjectType{
					AttrTypes: VrfExtraRoutes6Value{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.VrfExtraRoutes6.IsUnknown() {
		vrfExtraRoutes6 = types.MapUnknown(
			VrfExtraRoutes6Type{
				basetypes.ObjectType{
					AttrTypes: VrfExtraRoutes6Value{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var networksVal basetypes.ListValue
	switch {
	case v.Networks.IsUnknown():
		networksVal = types.ListUnknown(types.StringType)
	case v.Networks.IsNull():
		networksVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		networksVal, d = types.ListValue(types.StringType, v.Networks.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"evpn_auto_loopback_subnet":  basetypes.StringType{},
			"evpn_auto_loopback_subnet6": basetypes.StringType{},
			"networks": basetypes.ListType{
				ElemType: types.StringType,
			},
			"extra_routes": basetypes.MapType{
				ElemType: VrfExtraRoutesValue{}.Type(ctx),
			},
			"extra_routes6": basetypes.MapType{
				ElemType: VrfExtraRoutes6Value{}.Type(ctx),
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"evpn_auto_loopback_subnet":  basetypes.StringType{},
		"evpn_auto_loopback_subnet6": basetypes.StringType{},
		"networks": basetypes.ListType{
			ElemType: types.StringType,
		},
		"extra_routes": basetypes.MapType{
			ElemType: VrfExtraRoutesValue{}.Type(ctx),
		},
		"extra_routes6": basetypes.MapType{
			ElemType: VrfExtraRoutes6Value{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"evpn_auto_loopback_subnet":  v.EvpnAutoLoopbackSubnet,
			"evpn_auto_loopback_subnet6": v.EvpnAutoLoopbackSubnet6,
			"networks":                   networksVal,
			"extra_routes":               vrfExtraRoutes,
			"extra_routes6":              vrfExtraRoutes6,
		})

	return objVal, diags
}

func (v VrfInstancesValue) Equal(o attr.Value) bool {
	other, ok := o.(VrfInstancesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.EvpnAutoLoopbackSubnet.Equal(other.EvpnAutoLoopbackSubnet) {
		return false
	}

	if !v.EvpnAutoLoopbackSubnet6.Equal(other.EvpnAutoLoopbackSubnet6) {
		return false
	}

	if !v.Networks.Equal(other.Networks) {
		return false
	}

	if !v.VrfExtraRoutes.Equal(other.VrfExtraRoutes) {
		return false
	}

	if !v.VrfExtraRoutes6.Equal(other.VrfExtraRoutes6) {
		return false
	}

	return true
}

func (v VrfInstancesValue) Type(ctx context.Context) attr.Type {
	return VrfInstancesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v VrfInstancesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"evpn_auto_loopback_subnet":  basetypes.StringType{},
		"evpn_auto_loopback_subnet6": basetypes.StringType{},
		"networks": basetypes.ListType{
			ElemType: types.StringType,
		},
		"extra_routes": basetypes.MapType{
			ElemType: VrfExtraRoutesValue{}.Type(ctx),
		},
		"extra_routes6": basetypes.MapType{
			ElemType: VrfExtraRoutes6Value{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = VrfExtraRoutesType{}

type VrfExtraRoutesType struct {
	basetypes.ObjectType
}

func (t VrfExtraRoutesType) Equal(o attr.Type) bool {
	other, ok := o.(VrfExtraRoutesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t VrfExtraRoutesType) String() string {
	return "VrfExtraRoutesType"
}

func (t VrfExtraRoutesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	viaAttribute, ok := attributes["via"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`via is missing from object`)

		return nil, diags
	}

	viaVal, ok := viaAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`via expected to be basetypes.StringValue, was: %T`, viaAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return VrfExtraRoutesValue{
		Via:   viaVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewVrfExtraRoutesValueNull() VrfExtraRoutesValue {
	return VrfExtraRoutesValue{
		state: attr.ValueStateNull,
	}
}

func NewVrfExtraRoutesValueUnknown() VrfExtraRoutesValue {
	return VrfExtraRoutesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewVrfExtraRoutesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (VrfExtraRoutesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing VrfExtraRoutesValue Attribute Value",
				"While creating a VrfExtraRoutesValue value, a missing attribute value was detected. "+
					"A VrfExtraRoutesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VrfExtraRoutesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid VrfExtraRoutesValue Attribute Type",
				"While creating a VrfExtraRoutesValue value, an invalid attribute value was detected. "+
					"A VrfExtraRoutesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VrfExtraRoutesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("VrfExtraRoutesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra VrfExtraRoutesValue Attribute Value",
				"While creating a VrfExtraRoutesValue value, an extra attribute value was detected. "+
					"A VrfExtraRoutesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra VrfExtraRoutesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewVrfExtraRoutesValueUnknown(), diags
	}

	viaAttribute, ok := attributes["via"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`via is missing from object`)

		return NewVrfExtraRoutesValueUnknown(), diags
	}

	viaVal, ok := viaAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`via expected to be basetypes.StringValue, was: %T`, viaAttribute))
	}

	if diags.HasError() {
		return NewVrfExtraRoutesValueUnknown(), diags
	}

	return VrfExtraRoutesValue{
		Via:   viaVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewVrfExtraRoutesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) VrfExtraRoutesValue {
	object, diags := NewVrfExtraRoutesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewVrfExtraRoutesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t VrfExtraRoutesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewVrfExtraRoutesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewVrfExtraRoutesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewVrfExtraRoutesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewVrfExtraRoutesValueMust(VrfExtraRoutesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t VrfExtraRoutesType) ValueType(ctx context.Context) attr.Value {
	return VrfExtraRoutesValue{}
}

var _ basetypes.ObjectValuable = VrfExtraRoutesValue{}

type VrfExtraRoutesValue struct {
	Via   basetypes.StringValue `tfsdk:"via"`
	state attr.ValueState
}

func (v VrfExtraRoutesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["via"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Via.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["via"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v VrfExtraRoutesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v VrfExtraRoutesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v VrfExtraRoutesValue) String() string {
	return "VrfExtraRoutesValue"
}

func (v VrfExtraRoutesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"via": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"via": v.Via,
		})

	return objVal, diags
}

func (v VrfExtraRoutesValue) Equal(o attr.Value) bool {
	other, ok := o.(VrfExtraRoutesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Via.Equal(other.Via) {
		return false
	}

	return true
}

func (v VrfExtraRoutesValue) Type(ctx context.Context) attr.Type {
	return VrfExtraRoutesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v VrfExtraRoutesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"via": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = VrfExtraRoutes6Type{}

type VrfExtraRoutes6Type struct {
	basetypes.ObjectType
}

func (t VrfExtraRoutes6Type) Equal(o attr.Type) bool {
	other, ok := o.(VrfExtraRoutes6Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t VrfExtraRoutes6Type) String() string {
	return "VrfExtraRoutes6Type"
}

func (t VrfExtraRoutes6Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	viaAttribute, ok := attributes["via"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`via is missing from object`)

		return nil, diags
	}

	viaVal, ok := viaAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`via expected to be basetypes.StringValue, was: %T`, viaAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return VrfExtraRoutes6Value{
		Via:   viaVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewVrfExtraRoutes6ValueNull() VrfExtraRoutes6Value {
	return VrfExtraRoutes6Value{
		state: attr.ValueStateNull,
	}
}

func NewVrfExtraRoutes6ValueUnknown() VrfExtraRoutes6Value {
	return VrfExtraRoutes6Value{
		state: attr.ValueStateUnknown,
	}
}

func NewVrfExtraRoutes6Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (VrfExtraRoutes6Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing VrfExtraRoutes6Value Attribute Value",
				"While creating a VrfExtraRoutes6Value value, a missing attribute value was detected. "+
					"A VrfExtraRoutes6Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VrfExtraRoutes6Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid VrfExtraRoutes6Value Attribute Type",
				"While creating a VrfExtraRoutes6Value value, an invalid attribute value was detected. "+
					"A VrfExtraRoutes6Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VrfExtraRoutes6Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("VrfExtraRoutes6Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra VrfExtraRoutes6Value Attribute Value",
				"While creating a VrfExtraRoutes6Value value, an extra attribute value was detected. "+
					"A VrfExtraRoutes6Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra VrfExtraRoutes6Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewVrfExtraRoutes6ValueUnknown(), diags
	}

	viaAttribute, ok := attributes["via"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`via is missing from object`)

		return NewVrfExtraRoutes6ValueUnknown(), diags
	}

	viaVal, ok := viaAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`via expected to be basetypes.StringValue, was: %T`, viaAttribute))
	}

	if diags.HasError() {
		return NewVrfExtraRoutes6ValueUnknown(), diags
	}

	return VrfExtraRoutes6Value{
		Via:   viaVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewVrfExtraRoutes6ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) VrfExtraRoutes6Value {
	object, diags := NewVrfExtraRoutes6Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewVrfExtraRoutes6ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t VrfExtraRoutes6Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewVrfExtraRoutes6ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewVrfExtraRoutes6ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewVrfExtraRoutes6ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewVrfExtraRoutes6ValueMust(VrfExtraRoutes6Value{}.AttributeTypes(ctx), attributes), nil
}

func (t VrfExtraRoutes6Type) ValueType(ctx context.Context) attr.Value {
	return VrfExtraRoutes6Value{}
}

var _ basetypes.ObjectValuable = VrfExtraRoutes6Value{}

type VrfExtraRoutes6Value struct {
	Via   basetypes.StringValue `tfsdk:"via"`
	state attr.ValueState
}

func (v VrfExtraRoutes6Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["via"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Via.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["via"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v VrfExtraRoutes6Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v VrfExtraRoutes6Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v VrfExtraRoutes6Value) String() string {
	return "VrfExtraRoutes6Value"
}

func (v VrfExtraRoutes6Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"via": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"via": v.Via,
		})

	return objVal, diags
}

func (v VrfExtraRoutes6Value) Equal(o attr.Value) bool {
	other, ok := o.(VrfExtraRoutes6Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Via.Equal(other.Via) {
		return false
	}

	return true
}

func (v VrfExtraRoutes6Value) Type(ctx context.Context) attr.Type {
	return VrfExtraRoutes6Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v VrfExtraRoutes6Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"via": basetypes.StringType{},
	}
}
