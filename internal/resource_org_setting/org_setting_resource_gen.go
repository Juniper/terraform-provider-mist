// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package resource_org_setting

import (
	"context"
	"fmt"
	"github.com/Juniper/terraform-provider-mist/internal/validators"
	"github.com/hashicorp/terraform-plugin-framework-validators/int64validator"
	"github.com/hashicorp/terraform-plugin-framework-validators/listvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/mapvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/booldefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/int64default"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
)

func OrgSettingResourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"ap_updown_threshold": schema.Int64Attribute{
				Optional:            true,
				Description:         "Enable threshold-based device down delivery for AP devices only. When configured it takes effect for AP devices and `device_updown_threshold` is ignored.",
				MarkdownDescription: "Enable threshold-based device down delivery for AP devices only. When configured it takes effect for AP devices and `device_updown_threshold` is ignored.",
				Validators: []validator.Int64{
					int64validator.Between(0, 240),
				},
			},
			"api_policy": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"no_reveal": schema.BoolAttribute{
						Optional:            true,
						Description:         "By default, API hides password/secrets when the user doesn't have write access\n  * `true`: API will hide passwords/secrets for all users\n  * `false`: API will hide passwords/secrets for read-only users",
						MarkdownDescription: "By default, API hides password/secrets when the user doesn't have write access\n  * `true`: API will hide passwords/secrets for all users\n  * `false`: API will hide passwords/secrets for read-only users",
					},
				},
				CustomType: ApiPolicyType{
					ObjectType: types.ObjectType{
						AttrTypes: ApiPolicyValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
			},
			"cacerts": schema.ListAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Computed:            true,
				Description:         "RADSec certificates for AP",
				MarkdownDescription: "RADSec certificates for AP",
				Validators: []validator.List{
					listvalidator.SizeAtLeast(1),
				},
			},
			"celona": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"api_key": schema.StringAttribute{
						Required: true,
					},
					"api_prefix": schema.StringAttribute{
						Required: true,
					},
				},
				CustomType: CelonaType{
					ObjectType: types.ObjectType{
						AttrTypes: CelonaValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
			},
			"cloudshark": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"apitoken": schema.StringAttribute{
						Optional:  true,
						Computed:  true,
						Sensitive: true,
						Default:   stringdefault.StaticString(""),
					},
					"url": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "If using CS Enterprise",
						MarkdownDescription: "If using CS Enterprise",
						Default:             stringdefault.StaticString(""),
					},
				},
				CustomType: CloudsharkType{
					ObjectType: types.ObjectType{
						AttrTypes: CloudsharkValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
			},
			"cradlepoint": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"cp_api_id": schema.StringAttribute{
						Computed: true,
					},
					"cp_api_key": schema.StringAttribute{
						Computed:  true,
						Sensitive: true,
					},
					"ecm_api_id": schema.StringAttribute{
						Computed: true,
					},
					"ecm_api_key": schema.StringAttribute{
						Computed:  true,
						Sensitive: true,
					},
					"enable_lldp": schema.BoolAttribute{
						Computed: true,
					},
				},
				CustomType: CradlepointType{
					ObjectType: types.ObjectType{
						AttrTypes: CradlepointValue{}.AttributeTypes(ctx),
					},
				},
				Computed: true,
			},
			"device_cert": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"cert": schema.StringAttribute{
						Required: true,
					},
					"key": schema.StringAttribute{
						Required:  true,
						Sensitive: true,
					},
				},
				CustomType: DeviceCertType{
					ObjectType: types.ObjectType{
						AttrTypes: DeviceCertValue{}.AttributeTypes(ctx),
					},
				},
				Optional:            true,
				Description:         "common device cert, optional",
				MarkdownDescription: "common device cert, optional",
			},
			"device_updown_threshold": schema.Int64Attribute{
				Optional:            true,
				Description:         "Enable threshold-based device down delivery via\n  * device-updowns webhooks topic, \n  * Mist Alert Framework; e.g. send AP/SW/GW down event only if AP/SW/GW Up is not seen within the threshold in minutes; 0 - 240, default is 0 (trigger immediate)",
				MarkdownDescription: "Enable threshold-based device down delivery via\n  * device-updowns webhooks topic, \n  * Mist Alert Framework; e.g. send AP/SW/GW down event only if AP/SW/GW Up is not seen within the threshold in minutes; 0 - 240, default is 0 (trigger immediate)",
				Validators: []validator.Int64{
					int64validator.Between(0, 240),
				},
			},
			"disable_pcap": schema.BoolAttribute{
				Optional:            true,
				Description:         "Whether to disallow Mist to analyze pcap files (this is required for marvis pcap)",
				MarkdownDescription: "Whether to disallow Mist to analyze pcap files (this is required for marvis pcap)",
			},
			"disable_remote_shell": schema.BoolAttribute{
				Optional:            true,
				Description:         "Whether to disable remote shell access for an entire org",
				MarkdownDescription: "Whether to disable remote shell access for an entire org",
			},
			"gateway_updown_threshold": schema.Int64Attribute{
				Optional:            true,
				Description:         "Enable threshold-based device down delivery for Gateway devices only. When configured it takes effect for GW devices and `device_updown_threshold` is ignored.",
				MarkdownDescription: "Enable threshold-based device down delivery for Gateway devices only. When configured it takes effect for GW devices and `device_updown_threshold` is ignored.",
				Validators: []validator.Int64{
					int64validator.Between(0, 240),
				},
			},
			"installer": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"allow_all_devices": schema.BoolAttribute{
						Optional: true,
					},
					"allow_all_sites": schema.BoolAttribute{
						Optional: true,
					},
					"extra_site_ids": schema.ListAttribute{
						ElementType: types.StringType,
						Optional:    true,
						Validators: []validator.List{
							listvalidator.SizeAtLeast(1),
						},
					},
					"grace_period": schema.Int64Attribute{
						Optional: true,
					},
				},
				CustomType: InstallerType{
					ObjectType: types.ObjectType{
						AttrTypes: InstallerValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
			},
			"jcloud": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"org_apitoken": schema.StringAttribute{
						Required:            true,
						Description:         "JCloud Org Token",
						MarkdownDescription: "JCloud Org Token",
					},
					"org_apitoken_name": schema.StringAttribute{
						Required:            true,
						Description:         "JCloud Org Token Name",
						MarkdownDescription: "JCloud Org Token Name",
					},
					"org_id": schema.StringAttribute{
						Required:            true,
						Description:         "JCloud Org ID",
						MarkdownDescription: "JCloud Org ID",
					},
				},
				CustomType: JcloudType{
					ObjectType: types.ObjectType{
						AttrTypes: JcloudValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
			},
			"jcloud_ra": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"org_apitoken": schema.StringAttribute{
						Optional:            true,
						Description:         "JCloud Routing Assurance Org Token",
						MarkdownDescription: "JCloud Routing Assurance Org Token",
					},
					"org_apitoken_name": schema.StringAttribute{
						Optional:            true,
						Description:         "JCloud Routing Assurance Org Token Name",
						MarkdownDescription: "JCloud Routing Assurance Org Token Name",
					},
					"org_id": schema.StringAttribute{
						Optional:            true,
						Description:         "JCloud Routing Assurance Org ID",
						MarkdownDescription: "JCloud Routing Assurance Org ID",
					},
				},
				CustomType: JcloudRaType{
					ObjectType: types.ObjectType{
						AttrTypes: JcloudRaValue{}.AttributeTypes(ctx),
					},
				},
				Optional:            true,
				Description:         "JCloud Routing Assurance connexion",
				MarkdownDescription: "JCloud Routing Assurance connexion",
			},
			"juniper": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"accounts": schema.ListNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"linked_by": schema.StringAttribute{
									Computed: true,
								},
								"name": schema.StringAttribute{
									Computed: true,
								},
							},
							CustomType: AccountsType{
								ObjectType: types.ObjectType{
									AttrTypes: AccountsValue{}.AttributeTypes(ctx),
								},
							},
						},
						Computed: true,
					},
				},
				CustomType: JuniperType{
					ObjectType: types.ObjectType{
						AttrTypes: JuniperValue{}.AttributeTypes(ctx),
					},
				},
				Computed: true,
			},
			"juniper_srx": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"auto_upgrade": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"custom_versions": schema.MapAttribute{
								ElementType:         types.StringType,
								Optional:            true,
								Description:         "Property key is the SRX Hardware model (e.g. \"SRX4600\")",
								MarkdownDescription: "Property key is the SRX Hardware model (e.g. \"SRX4600\")",
							},
							"enabled": schema.BoolAttribute{
								Optional: true,
							},
							"snapshot": schema.BoolAttribute{
								Optional: true,
							},
						},
						CustomType: SrxAutoUpgradeType{
							ObjectType: types.ObjectType{
								AttrTypes: SrxAutoUpgradeValue{}.AttributeTypes(ctx),
							},
						},
						Optional:            true,
						Description:         "auto_upgrade device first time it is onboarded",
						MarkdownDescription: "auto_upgrade device first time it is onboarded",
					},
				},
				CustomType: JuniperSrxType{
					ObjectType: types.ObjectType{
						AttrTypes: JuniperSrxValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
			},
			"junos_shell_access": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"admin": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "enum: `admin`, `viewer`, `none`",
						MarkdownDescription: "enum: `admin`, `viewer`, `none`",
						Validators: []validator.String{
							stringvalidator.OneOf(
								"",
								"admin",
								"none",
								"viewer",
							),
						},
						Default: stringdefault.StaticString("admin"),
					},
					"helpdesk": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "enum: `admin`, `viewer`, `none`",
						MarkdownDescription: "enum: `admin`, `viewer`, `none`",
						Validators: []validator.String{
							stringvalidator.OneOf(
								"",
								"admin",
								"none",
								"viewer",
							),
						},
						Default: stringdefault.StaticString("none"),
					},
					"read": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "enum: `admin`, `viewer`, `none`",
						MarkdownDescription: "enum: `admin`, `viewer`, `none`",
						Validators: []validator.String{
							stringvalidator.OneOf(
								"",
								"admin",
								"none",
								"viewer",
							),
						},
						Default: stringdefault.StaticString("none"),
					},
					"write": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "enum: `admin`, `viewer`, `none`",
						MarkdownDescription: "enum: `admin`, `viewer`, `none`",
						Validators: []validator.String{
							stringvalidator.OneOf(
								"",
								"admin",
								"none",
								"viewer",
							),
						},
						Default: stringdefault.StaticString("admin"),
					},
				},
				CustomType: JunosShellAccessType{
					ObjectType: types.ObjectType{
						AttrTypes: JunosShellAccessValue{}.AttributeTypes(ctx),
					},
				},
				Optional:            true,
				Description:         "junos_shell_access: Manages role-based web-shell access.  \nWhen junos_shell access is not defined (Default) - No additional users are configured and web-shell uses default `mist` user to login.  \nWhen junos_shell_access is defined - Additional users mist-web-admin (admin permission), mist-web-viewer(viewer permission) are configured on the device and web-shell logs in with the mist-web-admin/mist-web-viewer user depending upon the shell access level. Setting the shell access level to \"none\", disables web-shell access for that specific role.\n",
				MarkdownDescription: "junos_shell_access: Manages role-based web-shell access.  \nWhen junos_shell access is not defined (Default) - No additional users are configured and web-shell uses default `mist` user to login.  \nWhen junos_shell_access is defined - Additional users mist-web-admin (admin permission), mist-web-viewer(viewer permission) are configured on the device and web-shell logs in with the mist-web-admin/mist-web-viewer user depending upon the shell access level. Setting the shell access level to \"none\", disables web-shell access for that specific role.\n",
			},
			"marvis": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"auto_operations": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"bounce_port_for_abnormal_poe_client": schema.BoolAttribute{
								Optional: true,
								Computed: true,
								Default:  booldefault.StaticBool(false),
							},
							"disable_port_when_ddos_protocol_violation": schema.BoolAttribute{
								Optional: true,
								Computed: true,
								Default:  booldefault.StaticBool(false),
							},
							"disable_port_when_rogue_dhcp_server_detected": schema.BoolAttribute{
								Optional: true,
								Computed: true,
								Default:  booldefault.StaticBool(false),
							},
						},
						CustomType: AutoOperationsType{
							ObjectType: types.ObjectType{
								AttrTypes: AutoOperationsValue{}.AttributeTypes(ctx),
							},
						},
						Optional: true,
					},
				},
				CustomType: MarvisType{
					ObjectType: types.ObjectType{
						AttrTypes: MarvisValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
			},
			"mgmt": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"mxtunnel_ids": schema.ListAttribute{
						ElementType:         types.StringType,
						Optional:            true,
						Description:         "List of Mist Tunnels",
						MarkdownDescription: "List of Mist Tunnels",
						Validators: []validator.List{
							listvalidator.SizeAtLeast(1),
						},
					},
					"use_mxtunnel": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "Whether to use Mist Tunnel for mgmt connectivity, this takes precedence over use_wxtunnel",
						MarkdownDescription: "Whether to use Mist Tunnel for mgmt connectivity, this takes precedence over use_wxtunnel",
						Default:             booldefault.StaticBool(false),
					},
					"use_wxtunnel": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "Whether to use wxtunnel for mgmt connectivity",
						MarkdownDescription: "Whether to use wxtunnel for mgmt connectivity",
						Default:             booldefault.StaticBool(false),
					},
				},
				CustomType: MgmtType{
					ObjectType: types.ObjectType{
						AttrTypes: MgmtValue{}.AttributeTypes(ctx),
					},
				},
				Optional:            true,
				Description:         "management-related properties",
				MarkdownDescription: "management-related properties",
			},
			"mist_nac": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"cacerts": schema.ListAttribute{
						ElementType:         types.StringType,
						Optional:            true,
						Computed:            true,
						Description:         "List of PEM-encoded ca certs",
						MarkdownDescription: "List of PEM-encoded ca certs",
						Validators: []validator.List{
							listvalidator.SizeAtLeast(1),
						},
					},
					"default_idp_id": schema.StringAttribute{
						Optional:            true,
						Description:         "use this IDP when no explicit realm present in the incoming username/CN OR when no IDP is explicitly mapped to the incoming realm.",
						MarkdownDescription: "use this IDP when no explicit realm present in the incoming username/CN OR when no IDP is explicitly mapped to the incoming realm.",
					},
					"disable_rsae_algorithms": schema.BoolAttribute{
						Optional:            true,
						Description:         "to disable RSAE_PSS_SHA256, RSAE_PSS_SHA384, RSAE_PSS_SHA512 from server side. see https://www.openssl.org/docs/man3.0/man1/openssl-ciphers.html",
						MarkdownDescription: "to disable RSAE_PSS_SHA256, RSAE_PSS_SHA384, RSAE_PSS_SHA512 from server side. see https://www.openssl.org/docs/man3.0/man1/openssl-ciphers.html",
					},
					"eap_ssl_security_level": schema.Int64Attribute{
						Optional:            true,
						Description:         "eap ssl security level, see https://www.openssl.org/docs/man1.1.1/man3/SSL_CTX_set_security_level.html#DEFAULT-CALLBACK-BEHAVIOUR",
						MarkdownDescription: "eap ssl security level, see https://www.openssl.org/docs/man1.1.1/man3/SSL_CTX_set_security_level.html#DEFAULT-CALLBACK-BEHAVIOUR",
						Validators: []validator.Int64{
							int64validator.Between(1, 4),
						},
					},
					"eu_only": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "By default, NAC POD failover considers all NAC pods available around the globe, i.e. EU, US, or APAC based, failover happens based on geo IP of the originating site. For strict GDPR compliance NAC POD failover would only happen between the PODs located within the EU environment, and no authentication would take place outside of EU. This is an org setting that is applicable to WLANs, switch templates, mxedge clusters that have mist_nac enabled",
						MarkdownDescription: "By default, NAC POD failover considers all NAC pods available around the globe, i.e. EU, US, or APAC based, failover happens based on geo IP of the originating site. For strict GDPR compliance NAC POD failover would only happen between the PODs located within the EU environment, and no authentication would take place outside of EU. This is an org setting that is applicable to WLANs, switch templates, mxedge clusters that have mist_nac enabled",
						Default:             booldefault.StaticBool(false),
					},
					"idp_machine_cert_lookup_field": schema.StringAttribute{
						Optional:            true,
						Description:         "allow customer to choose the EAP-TLS client certificate's field to use for IDP Machine Groups lookup. enum: `automatic`, `cn`, `dns`",
						MarkdownDescription: "allow customer to choose the EAP-TLS client certificate's field to use for IDP Machine Groups lookup. enum: `automatic`, `cn`, `dns`",
						Validators: []validator.String{
							stringvalidator.OneOf(
								"",
								"automatic",
								"cn",
								"dns",
							),
						},
					},
					"idp_user_cert_lookup_field": schema.StringAttribute{
						Optional:            true,
						Description:         "allow customer to choose the EAP-TLS client certificate's field. To use for IDP User Groups lookup. enum: `automatic`, `cn`, `email`, `upn`",
						MarkdownDescription: "allow customer to choose the EAP-TLS client certificate's field. To use for IDP User Groups lookup. enum: `automatic`, `cn`, `email`, `upn`",
						Validators: []validator.String{
							stringvalidator.OneOf(
								"",
								"automatic",
								"cn",
								"email",
								"upn",
							),
						},
					},
					"idps": schema.ListNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"exclude_realms": schema.ListAttribute{
									ElementType:         types.StringType,
									Optional:            true,
									Description:         "When the IDP of mxedge_proxy type, exclude the following realms from proxying in addition to other valid home realms in this org",
									MarkdownDescription: "When the IDP of mxedge_proxy type, exclude the following realms from proxying in addition to other valid home realms in this org",
									Validators: []validator.List{
										listvalidator.SizeAtLeast(1),
									},
								},
								"id": schema.StringAttribute{
									Required:            true,
									Description:         "ID of the `mist_nacidp`",
									MarkdownDescription: "ID of the `mist_nacidp`",
								},
								"user_realms": schema.ListAttribute{
									ElementType:         types.StringType,
									Required:            true,
									Description:         "Which realm should trigger this IDP. User Realm is extracted from:\n  * Username-AVP (`mist.com` from john@mist.com)\n  * Cert CN",
									MarkdownDescription: "Which realm should trigger this IDP. User Realm is extracted from:\n  * Username-AVP (`mist.com` from john@mist.com)\n  * Cert CN",
									Validators: []validator.List{
										listvalidator.SizeAtLeast(1),
									},
								},
							},
							CustomType: IdpsType{
								ObjectType: types.ObjectType{
									AttrTypes: IdpsValue{}.AttributeTypes(ctx),
								},
							},
						},
						Optional: true,
						Computed: true,
						Validators: []validator.List{
							listvalidator.SizeAtLeast(1),
							mistvalidator.RequiredWhenValueIsNotNull(path.MatchRelative().AtParent().AtName("default_idp_id")),
						},
					},
					"server_cert": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"cert": schema.StringAttribute{
								Optional: true,
							},
							"key": schema.StringAttribute{
								Optional:  true,
								Sensitive: true,
							},
							"password": schema.StringAttribute{
								Optional:            true,
								Sensitive:           true,
								Description:         "private key password (optional)",
								MarkdownDescription: "private key password (optional)",
							},
						},
						CustomType: ServerCertType{
							ObjectType: types.ObjectType{
								AttrTypes: ServerCertValue{}.AttributeTypes(ctx),
							},
						},
						Optional:            true,
						Description:         "radius server cert to be presented in EAP TLS",
						MarkdownDescription: "radius server cert to be presented in EAP TLS",
					},
					"use_ip_version": schema.StringAttribute{
						Optional:            true,
						Description:         "by default, NAS devices(switches/aps) and proxies(mxedge) are configured to reach mist-nac via IPv4. enum: `v4`, `v6`",
						MarkdownDescription: "by default, NAS devices(switches/aps) and proxies(mxedge) are configured to reach mist-nac via IPv4. enum: `v4`, `v6`",
						Validators: []validator.String{
							stringvalidator.OneOf(
								"",
								"v4",
								"v6",
							),
						},
					},
					"use_ssl_port": schema.BoolAttribute{
						Optional:            true,
						Description:         "By default, NAS devices (switches/aps) and proxies(mxedge) are configured to use port TCP2083(RadSec) to reach mist-nac. Set `use_ssl_port`==`true` to override that port with TCP43 (ssl), This is an org level setting that is applicable to wlans, switch_templates, and mxedge_clusters that have mist-nac enabled",
						MarkdownDescription: "By default, NAS devices (switches/aps) and proxies(mxedge) are configured to use port TCP2083(RadSec) to reach mist-nac. Set `use_ssl_port`==`true` to override that port with TCP43 (ssl), This is an org level setting that is applicable to wlans, switch_templates, and mxedge_clusters that have mist-nac enabled",
					},
				},
				CustomType: MistNacType{
					ObjectType: types.ObjectType{
						AttrTypes: MistNacValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
			},
			"mxedge_mgmt": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"config_auto_revert": schema.BoolAttribute{
						Optional: true,
					},
					"fips_enabled": schema.BoolAttribute{
						Optional: true,
						Computed: true,
						Default:  booldefault.StaticBool(false),
					},
					"mist_password": schema.StringAttribute{
						Optional:  true,
						Sensitive: true,
					},
					"oob_ip_type": schema.StringAttribute{
						Optional:            true,
						Description:         "enum: `dhcp`, `disabled`, `static`",
						MarkdownDescription: "enum: `dhcp`, `disabled`, `static`",
						Validators: []validator.String{
							stringvalidator.OneOf(
								"",
								"dhcp",
								"disabled",
								"static",
							),
						},
					},
					"oob_ip_type6": schema.StringAttribute{
						Optional:            true,
						Description:         "enum: `autoconf`, `dhcp`, `disabled`, `static`",
						MarkdownDescription: "enum: `autoconf`, `dhcp`, `disabled`, `static`",
						Validators: []validator.String{
							stringvalidator.OneOf(
								"",
								"autoconf",
								"dhcp",
								"disabled",
								"static",
							),
						},
					},
					"root_password": schema.StringAttribute{
						Optional:  true,
						Sensitive: true,
					},
				},
				CustomType: MxedgeMgmtType{
					ObjectType: types.ObjectType{
						AttrTypes: MxedgeMgmtValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
			},
			"optic_port_config": schema.MapNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"channelized": schema.BoolAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "Enable channelization",
							MarkdownDescription: "Enable channelization",
							Default:             booldefault.StaticBool(false),
						},
						"speed": schema.StringAttribute{
							Optional:            true,
							Description:         "Interface speed (e.g. `25g`, `50g`), use the chassis speed by default",
							MarkdownDescription: "Interface speed (e.g. `25g`, `50g`), use the chassis speed by default",
						},
					},
					CustomType: OpticPortConfigType{
						ObjectType: types.ObjectType{
							AttrTypes: OpticPortConfigValue{}.AttributeTypes(ctx),
						},
					},
				},
				Optional:            true,
				Description:         "Property key is the interface name or range (e.g. `et-0/0/47`, `et-0/0/48-49`)",
				MarkdownDescription: "Property key is the interface name or range (e.g. `et-0/0/47`, `et-0/0/48-49`)",
				Validators: []validator.Map{
					mapvalidator.SizeAtLeast(1),
				},
			},
			"org_id": schema.StringAttribute{
				Required: true,
			},
			"password_policy": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"enabled": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "Whether the policy is enabled",
						MarkdownDescription: "Whether the policy is enabled",
						Default:             booldefault.StaticBool(false),
					},
					"expiry_in_days": schema.Int64Attribute{
						Optional:            true,
						Description:         "password expiry in days",
						MarkdownDescription: "password expiry in days",
					},
					"min_length": schema.Int64Attribute{
						Optional:            true,
						Computed:            true,
						Description:         "Required password length",
						MarkdownDescription: "Required password length",
						Default:             int64default.StaticInt64(8),
					},
					"requires_special_char": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "Whether to require special character",
						MarkdownDescription: "Whether to require special character",
						Default:             booldefault.StaticBool(false),
					},
					"requires_two_factor_auth": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "Whether to require two-factor auth",
						MarkdownDescription: "Whether to require two-factor auth",
						Default:             booldefault.StaticBool(false),
					},
				},
				CustomType: PasswordPolicyType{
					ObjectType: types.ObjectType{
						AttrTypes: PasswordPolicyValue{}.AttributeTypes(ctx),
					},
				},
				Optional:            true,
				Description:         "password policy",
				MarkdownDescription: "password policy",
			},
			"pcap": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"bucket": schema.StringAttribute{
						Optional: true,
					},
					"max_pkt_len": schema.Int64Attribute{
						Optional:            true,
						Computed:            true,
						Description:         "Max_len of non-management packets to capture",
						MarkdownDescription: "Max_len of non-management packets to capture",
						Validators: []validator.Int64{
							int64validator.AtMost(128),
						},
						Default: int64default.StaticInt64(128),
					},
				},
				CustomType: PcapType{
					ObjectType: types.ObjectType{
						AttrTypes: PcapValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
			},
			"security": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"disable_local_ssh": schema.BoolAttribute{
						Optional:            true,
						Description:         "Whether to disable local SSH (by default, local SSH is enabled with allow_mist in Org is enabled",
						MarkdownDescription: "Whether to disable local SSH (by default, local SSH is enabled with allow_mist in Org is enabled",
					},
					"fips_zeroize_password": schema.StringAttribute{
						Optional:            true,
						Sensitive:           true,
						Description:         "password required to zeroize devices (FIPS) on site level",
						MarkdownDescription: "password required to zeroize devices (FIPS) on site level",
					},
					"limit_ssh_access": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "Whether to allow certain SSH keys to SSH into the AP (see Site:Setting)",
						MarkdownDescription: "Whether to allow certain SSH keys to SSH into the AP (see Site:Setting)",
						Default:             booldefault.StaticBool(false),
					},
				},
				CustomType: SecurityType{
					ObjectType: types.ObjectType{
						AttrTypes: SecurityValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
			},
			"ssr": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"conductor_hosts": schema.ListAttribute{
						ElementType:         types.StringType,
						Optional:            true,
						Description:         "List of Conductor IP Addresses or Hosts to be used by the SSR Devices",
						MarkdownDescription: "List of Conductor IP Addresses or Hosts to be used by the SSR Devices",
						Validators: []validator.List{
							listvalidator.SizeAtLeast(1),
						},
					},
					"conductor_token": schema.StringAttribute{
						Optional:            true,
						Sensitive:           true,
						Description:         "Token to be used by the SSR Devices to connect to the Conductor",
						MarkdownDescription: "Token to be used by the SSR Devices to connect to the Conductor",
					},
					"disable_stats": schema.BoolAttribute{
						Optional:            true,
						Description:         "Disable stats collection on SSR devices",
						MarkdownDescription: "Disable stats collection on SSR devices",
					},
					"proxy": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"url": schema.StringAttribute{
								Optional: true,
							},
						},
						CustomType: ProxyType{
							ObjectType: types.ObjectType{
								AttrTypes: ProxyValue{}.AttributeTypes(ctx),
							},
						},
						Optional:            true,
						Description:         "Proxy Configuration to talk to Mist",
						MarkdownDescription: "Proxy Configuration to talk to Mist",
					},
					"auto_upgrade": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"channel": schema.StringAttribute{
								Optional:            true,
								Description:         "upgrade channel to follow. enum: `alpha`, `beta`, `stable`",
								MarkdownDescription: "upgrade channel to follow. enum: `alpha`, `beta`, `stable`",
								Validators: []validator.String{
									stringvalidator.OneOf(
										"",
										"alpha",
										"beta",
										"stable",
									),
								},
							},
							"custom_versions": schema.MapAttribute{
								ElementType:         types.StringType,
								Optional:            true,
								Description:         "Property key is the SSR model (e.g. \"SSR130\").",
								MarkdownDescription: "Property key is the SSR model (e.g. \"SSR130\").",
							},
							"enabled": schema.BoolAttribute{
								Optional: true,
							},
						},
						CustomType: SsrAutoUpgradeType{
							ObjectType: types.ObjectType{
								AttrTypes: SsrAutoUpgradeValue{}.AttributeTypes(ctx),
							},
						},
						Optional:            true,
						Description:         "auto_upgrade device first time it is onboarded",
						MarkdownDescription: "auto_upgrade device first time it is onboarded",
					},
				},
				CustomType: SsrType{
					ObjectType: types.ObjectType{
						AttrTypes: SsrValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
			},
			"switch": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"auto_upgrade": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"custom_versions": schema.MapAttribute{
								ElementType:         types.StringType,
								Optional:            true,
								Description:         "Custom version to be used. The Property Key is the switch hardware and the property value is the firmware version",
								MarkdownDescription: "Custom version to be used. The Property Key is the switch hardware and the property value is the firmware version",
							},
							"enabled": schema.BoolAttribute{
								Optional:            true,
								Description:         "Enable auto upgrade for the switch",
								MarkdownDescription: "Enable auto upgrade for the switch",
							},
							"snapshot": schema.BoolAttribute{
								Optional:            true,
								Computed:            true,
								Description:         "Enable snapshot during the upgrade process",
								MarkdownDescription: "Enable snapshot during the upgrade process",
								Default:             booldefault.StaticBool(false),
							},
						},
						CustomType: AutoUpgradeType{
							ObjectType: types.ObjectType{
								AttrTypes: AutoUpgradeValue{}.AttributeTypes(ctx),
							},
						},
						Optional: true,
					},
				},
				CustomType: SwitchType{
					ObjectType: types.ObjectType{
						AttrTypes: SwitchValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
			},
			"switch_mgmt": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"ap_affinity_threshold": schema.Int64Attribute{
						Optional:            true,
						Computed:            true,
						Description:         "If the field is set in both site/setting and org/setting, the value from site/setting will be used.",
						MarkdownDescription: "If the field is set in both site/setting and org/setting, the value from site/setting will be used.",
						Default:             int64default.StaticInt64(12),
					},
				},
				CustomType: SwitchMgmtType{
					ObjectType: types.ObjectType{
						AttrTypes: SwitchMgmtValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
			},
			"switch_updown_threshold": schema.Int64Attribute{
				Optional:            true,
				Description:         "Enable threshold-based device down delivery for Switch devices only. When configured it takes effect for SW devices and `device_updown_threshold` is ignored.",
				MarkdownDescription: "Enable threshold-based device down delivery for Switch devices only. When configured it takes effect for SW devices and `device_updown_threshold` is ignored.",
			},
			"synthetic_test": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"aggressiveness": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "enum: `auto`, `high`, `low`",
						MarkdownDescription: "enum: `auto`, `high`, `low`",
						Validators: []validator.String{
							stringvalidator.OneOf(
								"",
								"auto",
								"high",
								"med",
								"low",
							),
						},
						Default: stringdefault.StaticString("auto"),
					},
					"custom_probes": schema.MapNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"aggressiveness": schema.StringAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "enum: `auto`, `high`, `low`",
									MarkdownDescription: "enum: `auto`, `high`, `low`",
									Validators: []validator.String{
										stringvalidator.OneOf(
											"",
											"auto",
											"high",
											"med",
											"low",
										),
									},
									Default: stringdefault.StaticString("auto"),
								},
								"host": schema.StringAttribute{
									Optional:            true,
									Description:         "If `type`==`icmp` or `type`==`tcp`, Host to be used for the custom probe",
									MarkdownDescription: "If `type`==`icmp` or `type`==`tcp`, Host to be used for the custom probe",
								},
								"port": schema.Int64Attribute{
									Optional:            true,
									Description:         "If `type`==`tcp`, Port to be used for the custom probe",
									MarkdownDescription: "If `type`==`tcp`, Port to be used for the custom probe",
								},
								"threshold": schema.Int64Attribute{
									Optional:            true,
									Description:         "In milliseconds",
									MarkdownDescription: "In milliseconds",
								},
								"type": schema.StringAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "enum: `curl`, `icmp`, `tcp`",
									MarkdownDescription: "enum: `curl`, `icmp`, `tcp`",
									Validators: []validator.String{
										stringvalidator.OneOf(
											"",
											"curl",
											"icmp",
											"tcp",
										),
									},
									Default: stringdefault.StaticString("icmp"),
								},
								"url": schema.StringAttribute{
									Optional:            true,
									Description:         "If `type`==`curl`, URL to be used for the custom probe, can be url or IP",
									MarkdownDescription: "If `type`==`curl`, URL to be used for the custom probe, can be url or IP",
								},
							},
							CustomType: CustomProbesType{
								ObjectType: types.ObjectType{
									AttrTypes: CustomProbesValue{}.AttributeTypes(ctx),
								},
							},
						},
						Optional:            true,
						Description:         "Custom probes to be used for synthetic tests",
						MarkdownDescription: "Custom probes to be used for synthetic tests",
						Validators: []validator.Map{
							mapvalidator.SizeAtLeast(1),
						},
					},
					"disabled": schema.BoolAttribute{
						Optional: true,
						Computed: true,
						Default:  booldefault.StaticBool(false),
					},
					"lan_networks": schema.ListNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"networks": schema.ListAttribute{
									ElementType:         types.StringType,
									Optional:            true,
									Description:         "List of networks to be used for synthetic tests",
									MarkdownDescription: "List of networks to be used for synthetic tests",
									Validators: []validator.List{
										listvalidator.SizeAtLeast(1),
									},
								},
								"probes": schema.ListAttribute{
									ElementType:         types.StringType,
									Optional:            true,
									Description:         "app name comes from `custom_probes` above or /const/synthetic_test_probes",
									MarkdownDescription: "app name comes from `custom_probes` above or /const/synthetic_test_probes",
								},
							},
							CustomType: LanNetworksType{
								ObjectType: types.ObjectType{
									AttrTypes: LanNetworksValue{}.AttributeTypes(ctx),
								},
							},
						},
						Optional:            true,
						Description:         "List of networks to be used for synthetic tests",
						MarkdownDescription: "List of networks to be used for synthetic tests",
					},
					"vlans": schema.ListNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"custom_test_urls": schema.ListAttribute{
									ElementType:        types.StringType,
									Optional:           true,
									Computed:           true,
									DeprecationMessage: "This attribute is deprecated.",
									Validators: []validator.List{
										listvalidator.SizeAtLeast(1),
									},
								},
								"disabled": schema.BoolAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "For some vlans where we don't want this to run",
									MarkdownDescription: "For some vlans where we don't want this to run",
									Default:             booldefault.StaticBool(false),
								},
								"probes": schema.ListAttribute{
									ElementType:         types.StringType,
									Optional:            true,
									Description:         "app name comes from `custom_probes` above or /const/synthetic_test_probes",
									MarkdownDescription: "app name comes from `custom_probes` above or /const/synthetic_test_probes",
									Validators: []validator.List{
										listvalidator.SizeAtLeast(1),
									},
								},
								"vlan_ids": schema.ListAttribute{
									ElementType: types.StringType,
									Optional:    true,
									Computed:    true,
									Validators: []validator.List{
										listvalidator.SizeAtLeast(1),
										listvalidator.ValueStringsAre(
											stringvalidator.Any(
												mistvalidator.ParseInt(1, 4094),
												mistvalidator.ParseVar(),
											),
										),
									},
								},
							},
							CustomType: VlansType{
								ObjectType: types.ObjectType{
									AttrTypes: VlansValue{}.AttributeTypes(ctx),
								},
							},
						},
						Optional:           true,
						DeprecationMessage: "This attribute is deprecated.",
						Validators: []validator.List{
							listvalidator.SizeAtLeast(1),
						},
					},
					"wan_speedtest": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"enabled": schema.BoolAttribute{
								Optional: true,
							},
							"time_of_day": schema.StringAttribute{
								Optional:            true,
								Computed:            true,
								Description:         "`any` / HH:MM (24-hour format)",
								MarkdownDescription: "`any` / HH:MM (24-hour format)",
								Default:             stringdefault.StaticString("any"),
							},
						},
						CustomType: WanSpeedtestType{
							ObjectType: types.ObjectType{
								AttrTypes: WanSpeedtestValue{}.AttributeTypes(ctx),
							},
						},
						Optional: true,
					},
				},
				CustomType: SyntheticTestType{
					ObjectType: types.ObjectType{
						AttrTypes: SyntheticTestValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
			},
			"ui_idle_timeout": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "Automatically logout the user when UI session is inactive. `0` means disabled",
				MarkdownDescription: "Automatically logout the user when UI session is inactive. `0` means disabled",
				Validators: []validator.Int64{
					int64validator.Between(0, 480),
				},
				Default: int64default.StaticInt64(0),
			},
			"ui_no_tracking": schema.BoolAttribute{
				Optional: true,
			},
			"vpn_options": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"as_base": schema.Int64Attribute{
						Optional: true,
						Validators: []validator.Int64{
							int64validator.Between(1, 2147483647),
						},
					},
					"enable_ipv6": schema.BoolAttribute{
						Optional: true,
						Computed: true,
						Default:  booldefault.StaticBool(false),
					},
					"st_subnet": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "requiring /12 or bigger to support 16 private IPs for 65535 gateways",
						MarkdownDescription: "requiring /12 or bigger to support 16 private IPs for 65535 gateways",
						Default:             stringdefault.StaticString("10.224.0.0/12"),
					},
				},
				CustomType: VpnOptionsType{
					ObjectType: types.ObjectType{
						AttrTypes: VpnOptionsValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
			},
			"wan_pma": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"enabled": schema.BoolAttribute{
						Optional: true,
						Computed: true,
						Default:  booldefault.StaticBool(false),
					},
				},
				CustomType: WanPmaType{
					ObjectType: types.ObjectType{
						AttrTypes: WanPmaValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
			},
			"wired_pma": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"enabled": schema.BoolAttribute{
						Optional: true,
						Computed: true,
						Default:  booldefault.StaticBool(false),
					},
				},
				CustomType: WiredPmaType{
					ObjectType: types.ObjectType{
						AttrTypes: WiredPmaValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
			},
			"wireless_pma": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"enabled": schema.BoolAttribute{
						Optional: true,
						Computed: true,
						Default:  booldefault.StaticBool(true),
					},
				},
				CustomType: WirelessPmaType{
					ObjectType: types.ObjectType{
						AttrTypes: WirelessPmaValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
			},
		},
	}
}

type OrgSettingModel struct {
	ApUpdownThreshold      types.Int64           `tfsdk:"ap_updown_threshold"`
	ApiPolicy              ApiPolicyValue        `tfsdk:"api_policy"`
	Cacerts                types.List            `tfsdk:"cacerts"`
	Celona                 CelonaValue           `tfsdk:"celona"`
	Cloudshark             CloudsharkValue       `tfsdk:"cloudshark"`
	Cradlepoint            CradlepointValue      `tfsdk:"cradlepoint"`
	DeviceCert             DeviceCertValue       `tfsdk:"device_cert"`
	DeviceUpdownThreshold  types.Int64           `tfsdk:"device_updown_threshold"`
	DisablePcap            types.Bool            `tfsdk:"disable_pcap"`
	DisableRemoteShell     types.Bool            `tfsdk:"disable_remote_shell"`
	GatewayUpdownThreshold types.Int64           `tfsdk:"gateway_updown_threshold"`
	Installer              InstallerValue        `tfsdk:"installer"`
	Jcloud                 JcloudValue           `tfsdk:"jcloud"`
	JcloudRa               JcloudRaValue         `tfsdk:"jcloud_ra"`
	Juniper                JuniperValue          `tfsdk:"juniper"`
	JuniperSrx             JuniperSrxValue       `tfsdk:"juniper_srx"`
	JunosShellAccess       JunosShellAccessValue `tfsdk:"junos_shell_access"`
	Marvis                 MarvisValue           `tfsdk:"marvis"`
	Mgmt                   MgmtValue             `tfsdk:"mgmt"`
	MistNac                MistNacValue          `tfsdk:"mist_nac"`
	MxedgeMgmt             MxedgeMgmtValue       `tfsdk:"mxedge_mgmt"`
	OpticPortConfig        types.Map             `tfsdk:"optic_port_config"`
	OrgId                  types.String          `tfsdk:"org_id"`
	PasswordPolicy         PasswordPolicyValue   `tfsdk:"password_policy"`
	Pcap                   PcapValue             `tfsdk:"pcap"`
	Security               SecurityValue         `tfsdk:"security"`
	Ssr                    SsrValue              `tfsdk:"ssr"`
	Switch                 SwitchValue           `tfsdk:"switch"`
	SwitchMgmt             SwitchMgmtValue       `tfsdk:"switch_mgmt"`
	SwitchUpdownThreshold  types.Int64           `tfsdk:"switch_updown_threshold"`
	SyntheticTest          SyntheticTestValue    `tfsdk:"synthetic_test"`
	UiIdleTimeout          types.Int64           `tfsdk:"ui_idle_timeout"`
	UiNoTracking           types.Bool            `tfsdk:"ui_no_tracking"`
	VpnOptions             VpnOptionsValue       `tfsdk:"vpn_options"`
	WanPma                 WanPmaValue           `tfsdk:"wan_pma"`
	WiredPma               WiredPmaValue         `tfsdk:"wired_pma"`
	WirelessPma            WirelessPmaValue      `tfsdk:"wireless_pma"`
}

var _ basetypes.ObjectTypable = ApiPolicyType{}

type ApiPolicyType struct {
	basetypes.ObjectType
}

func (t ApiPolicyType) Equal(o attr.Type) bool {
	other, ok := o.(ApiPolicyType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ApiPolicyType) String() string {
	return "ApiPolicyType"
}

func (t ApiPolicyType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	noRevealAttribute, ok := attributes["no_reveal"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`no_reveal is missing from object`)

		return nil, diags
	}

	noRevealVal, ok := noRevealAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`no_reveal expected to be basetypes.BoolValue, was: %T`, noRevealAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ApiPolicyValue{
		NoReveal: noRevealVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewApiPolicyValueNull() ApiPolicyValue {
	return ApiPolicyValue{
		state: attr.ValueStateNull,
	}
}

func NewApiPolicyValueUnknown() ApiPolicyValue {
	return ApiPolicyValue{
		state: attr.ValueStateUnknown,
	}
}

func NewApiPolicyValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ApiPolicyValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ApiPolicyValue Attribute Value",
				"While creating a ApiPolicyValue value, a missing attribute value was detected. "+
					"A ApiPolicyValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ApiPolicyValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ApiPolicyValue Attribute Type",
				"While creating a ApiPolicyValue value, an invalid attribute value was detected. "+
					"A ApiPolicyValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ApiPolicyValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ApiPolicyValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ApiPolicyValue Attribute Value",
				"While creating a ApiPolicyValue value, an extra attribute value was detected. "+
					"A ApiPolicyValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ApiPolicyValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewApiPolicyValueUnknown(), diags
	}

	noRevealAttribute, ok := attributes["no_reveal"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`no_reveal is missing from object`)

		return NewApiPolicyValueUnknown(), diags
	}

	noRevealVal, ok := noRevealAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`no_reveal expected to be basetypes.BoolValue, was: %T`, noRevealAttribute))
	}

	if diags.HasError() {
		return NewApiPolicyValueUnknown(), diags
	}

	return ApiPolicyValue{
		NoReveal: noRevealVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewApiPolicyValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ApiPolicyValue {
	object, diags := NewApiPolicyValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewApiPolicyValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ApiPolicyType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewApiPolicyValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewApiPolicyValueUnknown(), nil
	}

	if in.IsNull() {
		return NewApiPolicyValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewApiPolicyValueMust(ApiPolicyValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ApiPolicyType) ValueType(ctx context.Context) attr.Value {
	return ApiPolicyValue{}
}

var _ basetypes.ObjectValuable = ApiPolicyValue{}

type ApiPolicyValue struct {
	NoReveal basetypes.BoolValue `tfsdk:"no_reveal"`
	state    attr.ValueState
}

func (v ApiPolicyValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["no_reveal"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.NoReveal.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["no_reveal"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ApiPolicyValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ApiPolicyValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ApiPolicyValue) String() string {
	return "ApiPolicyValue"
}

func (v ApiPolicyValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"no_reveal": basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"no_reveal": v.NoReveal,
		})

	return objVal, diags
}

func (v ApiPolicyValue) Equal(o attr.Value) bool {
	other, ok := o.(ApiPolicyValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.NoReveal.Equal(other.NoReveal) {
		return false
	}

	return true
}

func (v ApiPolicyValue) Type(ctx context.Context) attr.Type {
	return ApiPolicyType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ApiPolicyValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"no_reveal": basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = CelonaType{}

type CelonaType struct {
	basetypes.ObjectType
}

func (t CelonaType) Equal(o attr.Type) bool {
	other, ok := o.(CelonaType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t CelonaType) String() string {
	return "CelonaType"
}

func (t CelonaType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	apiKeyAttribute, ok := attributes["api_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`api_key is missing from object`)

		return nil, diags
	}

	apiKeyVal, ok := apiKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`api_key expected to be basetypes.StringValue, was: %T`, apiKeyAttribute))
	}

	apiPrefixAttribute, ok := attributes["api_prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`api_prefix is missing from object`)

		return nil, diags
	}

	apiPrefixVal, ok := apiPrefixAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`api_prefix expected to be basetypes.StringValue, was: %T`, apiPrefixAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return CelonaValue{
		ApiKey:    apiKeyVal,
		ApiPrefix: apiPrefixVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewCelonaValueNull() CelonaValue {
	return CelonaValue{
		state: attr.ValueStateNull,
	}
}

func NewCelonaValueUnknown() CelonaValue {
	return CelonaValue{
		state: attr.ValueStateUnknown,
	}
}

func NewCelonaValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (CelonaValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing CelonaValue Attribute Value",
				"While creating a CelonaValue value, a missing attribute value was detected. "+
					"A CelonaValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CelonaValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid CelonaValue Attribute Type",
				"While creating a CelonaValue value, an invalid attribute value was detected. "+
					"A CelonaValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CelonaValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("CelonaValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra CelonaValue Attribute Value",
				"While creating a CelonaValue value, an extra attribute value was detected. "+
					"A CelonaValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra CelonaValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewCelonaValueUnknown(), diags
	}

	apiKeyAttribute, ok := attributes["api_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`api_key is missing from object`)

		return NewCelonaValueUnknown(), diags
	}

	apiKeyVal, ok := apiKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`api_key expected to be basetypes.StringValue, was: %T`, apiKeyAttribute))
	}

	apiPrefixAttribute, ok := attributes["api_prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`api_prefix is missing from object`)

		return NewCelonaValueUnknown(), diags
	}

	apiPrefixVal, ok := apiPrefixAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`api_prefix expected to be basetypes.StringValue, was: %T`, apiPrefixAttribute))
	}

	if diags.HasError() {
		return NewCelonaValueUnknown(), diags
	}

	return CelonaValue{
		ApiKey:    apiKeyVal,
		ApiPrefix: apiPrefixVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewCelonaValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) CelonaValue {
	object, diags := NewCelonaValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewCelonaValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t CelonaType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewCelonaValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewCelonaValueUnknown(), nil
	}

	if in.IsNull() {
		return NewCelonaValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewCelonaValueMust(CelonaValue{}.AttributeTypes(ctx), attributes), nil
}

func (t CelonaType) ValueType(ctx context.Context) attr.Value {
	return CelonaValue{}
}

var _ basetypes.ObjectValuable = CelonaValue{}

type CelonaValue struct {
	ApiKey    basetypes.StringValue `tfsdk:"api_key"`
	ApiPrefix basetypes.StringValue `tfsdk:"api_prefix"`
	state     attr.ValueState
}

func (v CelonaValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["api_key"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["api_prefix"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.ApiKey.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["api_key"] = val

		val, err = v.ApiPrefix.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["api_prefix"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v CelonaValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v CelonaValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v CelonaValue) String() string {
	return "CelonaValue"
}

func (v CelonaValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"api_key":    basetypes.StringType{},
		"api_prefix": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"api_key":    v.ApiKey,
			"api_prefix": v.ApiPrefix,
		})

	return objVal, diags
}

func (v CelonaValue) Equal(o attr.Value) bool {
	other, ok := o.(CelonaValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.ApiKey.Equal(other.ApiKey) {
		return false
	}

	if !v.ApiPrefix.Equal(other.ApiPrefix) {
		return false
	}

	return true
}

func (v CelonaValue) Type(ctx context.Context) attr.Type {
	return CelonaType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v CelonaValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"api_key":    basetypes.StringType{},
		"api_prefix": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = CloudsharkType{}

type CloudsharkType struct {
	basetypes.ObjectType
}

func (t CloudsharkType) Equal(o attr.Type) bool {
	other, ok := o.(CloudsharkType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t CloudsharkType) String() string {
	return "CloudsharkType"
}

func (t CloudsharkType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	apitokenAttribute, ok := attributes["apitoken"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`apitoken is missing from object`)

		return nil, diags
	}

	apitokenVal, ok := apitokenAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`apitoken expected to be basetypes.StringValue, was: %T`, apitokenAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return nil, diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return CloudsharkValue{
		Apitoken: apitokenVal,
		Url:      urlVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewCloudsharkValueNull() CloudsharkValue {
	return CloudsharkValue{
		state: attr.ValueStateNull,
	}
}

func NewCloudsharkValueUnknown() CloudsharkValue {
	return CloudsharkValue{
		state: attr.ValueStateUnknown,
	}
}

func NewCloudsharkValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (CloudsharkValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing CloudsharkValue Attribute Value",
				"While creating a CloudsharkValue value, a missing attribute value was detected. "+
					"A CloudsharkValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CloudsharkValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid CloudsharkValue Attribute Type",
				"While creating a CloudsharkValue value, an invalid attribute value was detected. "+
					"A CloudsharkValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CloudsharkValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("CloudsharkValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra CloudsharkValue Attribute Value",
				"While creating a CloudsharkValue value, an extra attribute value was detected. "+
					"A CloudsharkValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra CloudsharkValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewCloudsharkValueUnknown(), diags
	}

	apitokenAttribute, ok := attributes["apitoken"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`apitoken is missing from object`)

		return NewCloudsharkValueUnknown(), diags
	}

	apitokenVal, ok := apitokenAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`apitoken expected to be basetypes.StringValue, was: %T`, apitokenAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return NewCloudsharkValueUnknown(), diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	if diags.HasError() {
		return NewCloudsharkValueUnknown(), diags
	}

	return CloudsharkValue{
		Apitoken: apitokenVal,
		Url:      urlVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewCloudsharkValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) CloudsharkValue {
	object, diags := NewCloudsharkValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewCloudsharkValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t CloudsharkType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewCloudsharkValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewCloudsharkValueUnknown(), nil
	}

	if in.IsNull() {
		return NewCloudsharkValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewCloudsharkValueMust(CloudsharkValue{}.AttributeTypes(ctx), attributes), nil
}

func (t CloudsharkType) ValueType(ctx context.Context) attr.Value {
	return CloudsharkValue{}
}

var _ basetypes.ObjectValuable = CloudsharkValue{}

type CloudsharkValue struct {
	Apitoken basetypes.StringValue `tfsdk:"apitoken"`
	Url      basetypes.StringValue `tfsdk:"url"`
	state    attr.ValueState
}

func (v CloudsharkValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["apitoken"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["url"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Apitoken.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["apitoken"] = val

		val, err = v.Url.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["url"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v CloudsharkValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v CloudsharkValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v CloudsharkValue) String() string {
	return "CloudsharkValue"
}

func (v CloudsharkValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"apitoken": basetypes.StringType{},
		"url":      basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"apitoken": v.Apitoken,
			"url":      v.Url,
		})

	return objVal, diags
}

func (v CloudsharkValue) Equal(o attr.Value) bool {
	other, ok := o.(CloudsharkValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Apitoken.Equal(other.Apitoken) {
		return false
	}

	if !v.Url.Equal(other.Url) {
		return false
	}

	return true
}

func (v CloudsharkValue) Type(ctx context.Context) attr.Type {
	return CloudsharkType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v CloudsharkValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"apitoken": basetypes.StringType{},
		"url":      basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = CradlepointType{}

type CradlepointType struct {
	basetypes.ObjectType
}

func (t CradlepointType) Equal(o attr.Type) bool {
	other, ok := o.(CradlepointType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t CradlepointType) String() string {
	return "CradlepointType"
}

func (t CradlepointType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	cpApiIdAttribute, ok := attributes["cp_api_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cp_api_id is missing from object`)

		return nil, diags
	}

	cpApiIdVal, ok := cpApiIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cp_api_id expected to be basetypes.StringValue, was: %T`, cpApiIdAttribute))
	}

	cpApiKeyAttribute, ok := attributes["cp_api_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cp_api_key is missing from object`)

		return nil, diags
	}

	cpApiKeyVal, ok := cpApiKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cp_api_key expected to be basetypes.StringValue, was: %T`, cpApiKeyAttribute))
	}

	ecmApiIdAttribute, ok := attributes["ecm_api_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ecm_api_id is missing from object`)

		return nil, diags
	}

	ecmApiIdVal, ok := ecmApiIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ecm_api_id expected to be basetypes.StringValue, was: %T`, ecmApiIdAttribute))
	}

	ecmApiKeyAttribute, ok := attributes["ecm_api_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ecm_api_key is missing from object`)

		return nil, diags
	}

	ecmApiKeyVal, ok := ecmApiKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ecm_api_key expected to be basetypes.StringValue, was: %T`, ecmApiKeyAttribute))
	}

	enableLldpAttribute, ok := attributes["enable_lldp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable_lldp is missing from object`)

		return nil, diags
	}

	enableLldpVal, ok := enableLldpAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable_lldp expected to be basetypes.BoolValue, was: %T`, enableLldpAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return CradlepointValue{
		CpApiId:    cpApiIdVal,
		CpApiKey:   cpApiKeyVal,
		EcmApiId:   ecmApiIdVal,
		EcmApiKey:  ecmApiKeyVal,
		EnableLldp: enableLldpVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewCradlepointValueNull() CradlepointValue {
	return CradlepointValue{
		state: attr.ValueStateNull,
	}
}

func NewCradlepointValueUnknown() CradlepointValue {
	return CradlepointValue{
		state: attr.ValueStateUnknown,
	}
}

func NewCradlepointValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (CradlepointValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing CradlepointValue Attribute Value",
				"While creating a CradlepointValue value, a missing attribute value was detected. "+
					"A CradlepointValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CradlepointValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid CradlepointValue Attribute Type",
				"While creating a CradlepointValue value, an invalid attribute value was detected. "+
					"A CradlepointValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CradlepointValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("CradlepointValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra CradlepointValue Attribute Value",
				"While creating a CradlepointValue value, an extra attribute value was detected. "+
					"A CradlepointValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra CradlepointValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewCradlepointValueUnknown(), diags
	}

	cpApiIdAttribute, ok := attributes["cp_api_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cp_api_id is missing from object`)

		return NewCradlepointValueUnknown(), diags
	}

	cpApiIdVal, ok := cpApiIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cp_api_id expected to be basetypes.StringValue, was: %T`, cpApiIdAttribute))
	}

	cpApiKeyAttribute, ok := attributes["cp_api_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cp_api_key is missing from object`)

		return NewCradlepointValueUnknown(), diags
	}

	cpApiKeyVal, ok := cpApiKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cp_api_key expected to be basetypes.StringValue, was: %T`, cpApiKeyAttribute))
	}

	ecmApiIdAttribute, ok := attributes["ecm_api_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ecm_api_id is missing from object`)

		return NewCradlepointValueUnknown(), diags
	}

	ecmApiIdVal, ok := ecmApiIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ecm_api_id expected to be basetypes.StringValue, was: %T`, ecmApiIdAttribute))
	}

	ecmApiKeyAttribute, ok := attributes["ecm_api_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ecm_api_key is missing from object`)

		return NewCradlepointValueUnknown(), diags
	}

	ecmApiKeyVal, ok := ecmApiKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ecm_api_key expected to be basetypes.StringValue, was: %T`, ecmApiKeyAttribute))
	}

	enableLldpAttribute, ok := attributes["enable_lldp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable_lldp is missing from object`)

		return NewCradlepointValueUnknown(), diags
	}

	enableLldpVal, ok := enableLldpAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable_lldp expected to be basetypes.BoolValue, was: %T`, enableLldpAttribute))
	}

	if diags.HasError() {
		return NewCradlepointValueUnknown(), diags
	}

	return CradlepointValue{
		CpApiId:    cpApiIdVal,
		CpApiKey:   cpApiKeyVal,
		EcmApiId:   ecmApiIdVal,
		EcmApiKey:  ecmApiKeyVal,
		EnableLldp: enableLldpVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewCradlepointValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) CradlepointValue {
	object, diags := NewCradlepointValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewCradlepointValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t CradlepointType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewCradlepointValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewCradlepointValueUnknown(), nil
	}

	if in.IsNull() {
		return NewCradlepointValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewCradlepointValueMust(CradlepointValue{}.AttributeTypes(ctx), attributes), nil
}

func (t CradlepointType) ValueType(ctx context.Context) attr.Value {
	return CradlepointValue{}
}

var _ basetypes.ObjectValuable = CradlepointValue{}

type CradlepointValue struct {
	CpApiId    basetypes.StringValue `tfsdk:"cp_api_id"`
	CpApiKey   basetypes.StringValue `tfsdk:"cp_api_key"`
	EcmApiId   basetypes.StringValue `tfsdk:"ecm_api_id"`
	EcmApiKey  basetypes.StringValue `tfsdk:"ecm_api_key"`
	EnableLldp basetypes.BoolValue   `tfsdk:"enable_lldp"`
	state      attr.ValueState
}

func (v CradlepointValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["cp_api_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["cp_api_key"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ecm_api_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ecm_api_key"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["enable_lldp"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.CpApiId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cp_api_id"] = val

		val, err = v.CpApiKey.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cp_api_key"] = val

		val, err = v.EcmApiId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ecm_api_id"] = val

		val, err = v.EcmApiKey.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ecm_api_key"] = val

		val, err = v.EnableLldp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enable_lldp"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v CradlepointValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v CradlepointValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v CradlepointValue) String() string {
	return "CradlepointValue"
}

func (v CradlepointValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"cp_api_id":   basetypes.StringType{},
		"cp_api_key":  basetypes.StringType{},
		"ecm_api_id":  basetypes.StringType{},
		"ecm_api_key": basetypes.StringType{},
		"enable_lldp": basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"cp_api_id":   v.CpApiId,
			"cp_api_key":  v.CpApiKey,
			"ecm_api_id":  v.EcmApiId,
			"ecm_api_key": v.EcmApiKey,
			"enable_lldp": v.EnableLldp,
		})

	return objVal, diags
}

func (v CradlepointValue) Equal(o attr.Value) bool {
	other, ok := o.(CradlepointValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.CpApiId.Equal(other.CpApiId) {
		return false
	}

	if !v.CpApiKey.Equal(other.CpApiKey) {
		return false
	}

	if !v.EcmApiId.Equal(other.EcmApiId) {
		return false
	}

	if !v.EcmApiKey.Equal(other.EcmApiKey) {
		return false
	}

	if !v.EnableLldp.Equal(other.EnableLldp) {
		return false
	}

	return true
}

func (v CradlepointValue) Type(ctx context.Context) attr.Type {
	return CradlepointType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v CradlepointValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"cp_api_id":   basetypes.StringType{},
		"cp_api_key":  basetypes.StringType{},
		"ecm_api_id":  basetypes.StringType{},
		"ecm_api_key": basetypes.StringType{},
		"enable_lldp": basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = DeviceCertType{}

type DeviceCertType struct {
	basetypes.ObjectType
}

func (t DeviceCertType) Equal(o attr.Type) bool {
	other, ok := o.(DeviceCertType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t DeviceCertType) String() string {
	return "DeviceCertType"
}

func (t DeviceCertType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	certAttribute, ok := attributes["cert"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cert is missing from object`)

		return nil, diags
	}

	certVal, ok := certAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cert expected to be basetypes.StringValue, was: %T`, certAttribute))
	}

	keyAttribute, ok := attributes["key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`key is missing from object`)

		return nil, diags
	}

	keyVal, ok := keyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`key expected to be basetypes.StringValue, was: %T`, keyAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return DeviceCertValue{
		Cert:  certVal,
		Key:   keyVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewDeviceCertValueNull() DeviceCertValue {
	return DeviceCertValue{
		state: attr.ValueStateNull,
	}
}

func NewDeviceCertValueUnknown() DeviceCertValue {
	return DeviceCertValue{
		state: attr.ValueStateUnknown,
	}
}

func NewDeviceCertValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (DeviceCertValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing DeviceCertValue Attribute Value",
				"While creating a DeviceCertValue value, a missing attribute value was detected. "+
					"A DeviceCertValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DeviceCertValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid DeviceCertValue Attribute Type",
				"While creating a DeviceCertValue value, an invalid attribute value was detected. "+
					"A DeviceCertValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DeviceCertValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("DeviceCertValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra DeviceCertValue Attribute Value",
				"While creating a DeviceCertValue value, an extra attribute value was detected. "+
					"A DeviceCertValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra DeviceCertValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewDeviceCertValueUnknown(), diags
	}

	certAttribute, ok := attributes["cert"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cert is missing from object`)

		return NewDeviceCertValueUnknown(), diags
	}

	certVal, ok := certAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cert expected to be basetypes.StringValue, was: %T`, certAttribute))
	}

	keyAttribute, ok := attributes["key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`key is missing from object`)

		return NewDeviceCertValueUnknown(), diags
	}

	keyVal, ok := keyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`key expected to be basetypes.StringValue, was: %T`, keyAttribute))
	}

	if diags.HasError() {
		return NewDeviceCertValueUnknown(), diags
	}

	return DeviceCertValue{
		Cert:  certVal,
		Key:   keyVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewDeviceCertValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) DeviceCertValue {
	object, diags := NewDeviceCertValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewDeviceCertValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t DeviceCertType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewDeviceCertValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewDeviceCertValueUnknown(), nil
	}

	if in.IsNull() {
		return NewDeviceCertValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewDeviceCertValueMust(DeviceCertValue{}.AttributeTypes(ctx), attributes), nil
}

func (t DeviceCertType) ValueType(ctx context.Context) attr.Value {
	return DeviceCertValue{}
}

var _ basetypes.ObjectValuable = DeviceCertValue{}

type DeviceCertValue struct {
	Cert  basetypes.StringValue `tfsdk:"cert"`
	Key   basetypes.StringValue `tfsdk:"key"`
	state attr.ValueState
}

func (v DeviceCertValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["cert"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["key"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Cert.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cert"] = val

		val, err = v.Key.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["key"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v DeviceCertValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v DeviceCertValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v DeviceCertValue) String() string {
	return "DeviceCertValue"
}

func (v DeviceCertValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"cert": basetypes.StringType{},
		"key":  basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"cert": v.Cert,
			"key":  v.Key,
		})

	return objVal, diags
}

func (v DeviceCertValue) Equal(o attr.Value) bool {
	other, ok := o.(DeviceCertValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Cert.Equal(other.Cert) {
		return false
	}

	if !v.Key.Equal(other.Key) {
		return false
	}

	return true
}

func (v DeviceCertValue) Type(ctx context.Context) attr.Type {
	return DeviceCertType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v DeviceCertValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"cert": basetypes.StringType{},
		"key":  basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = InstallerType{}

type InstallerType struct {
	basetypes.ObjectType
}

func (t InstallerType) Equal(o attr.Type) bool {
	other, ok := o.(InstallerType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t InstallerType) String() string {
	return "InstallerType"
}

func (t InstallerType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	allowAllDevicesAttribute, ok := attributes["allow_all_devices"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allow_all_devices is missing from object`)

		return nil, diags
	}

	allowAllDevicesVal, ok := allowAllDevicesAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allow_all_devices expected to be basetypes.BoolValue, was: %T`, allowAllDevicesAttribute))
	}

	allowAllSitesAttribute, ok := attributes["allow_all_sites"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allow_all_sites is missing from object`)

		return nil, diags
	}

	allowAllSitesVal, ok := allowAllSitesAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allow_all_sites expected to be basetypes.BoolValue, was: %T`, allowAllSitesAttribute))
	}

	extraSiteIdsAttribute, ok := attributes["extra_site_ids"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`extra_site_ids is missing from object`)

		return nil, diags
	}

	extraSiteIdsVal, ok := extraSiteIdsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`extra_site_ids expected to be basetypes.ListValue, was: %T`, extraSiteIdsAttribute))
	}

	gracePeriodAttribute, ok := attributes["grace_period"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`grace_period is missing from object`)

		return nil, diags
	}

	gracePeriodVal, ok := gracePeriodAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`grace_period expected to be basetypes.Int64Value, was: %T`, gracePeriodAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return InstallerValue{
		AllowAllDevices: allowAllDevicesVal,
		AllowAllSites:   allowAllSitesVal,
		ExtraSiteIds:    extraSiteIdsVal,
		GracePeriod:     gracePeriodVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewInstallerValueNull() InstallerValue {
	return InstallerValue{
		state: attr.ValueStateNull,
	}
}

func NewInstallerValueUnknown() InstallerValue {
	return InstallerValue{
		state: attr.ValueStateUnknown,
	}
}

func NewInstallerValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (InstallerValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing InstallerValue Attribute Value",
				"While creating a InstallerValue value, a missing attribute value was detected. "+
					"A InstallerValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("InstallerValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid InstallerValue Attribute Type",
				"While creating a InstallerValue value, an invalid attribute value was detected. "+
					"A InstallerValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("InstallerValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("InstallerValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra InstallerValue Attribute Value",
				"While creating a InstallerValue value, an extra attribute value was detected. "+
					"A InstallerValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra InstallerValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewInstallerValueUnknown(), diags
	}

	allowAllDevicesAttribute, ok := attributes["allow_all_devices"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allow_all_devices is missing from object`)

		return NewInstallerValueUnknown(), diags
	}

	allowAllDevicesVal, ok := allowAllDevicesAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allow_all_devices expected to be basetypes.BoolValue, was: %T`, allowAllDevicesAttribute))
	}

	allowAllSitesAttribute, ok := attributes["allow_all_sites"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allow_all_sites is missing from object`)

		return NewInstallerValueUnknown(), diags
	}

	allowAllSitesVal, ok := allowAllSitesAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allow_all_sites expected to be basetypes.BoolValue, was: %T`, allowAllSitesAttribute))
	}

	extraSiteIdsAttribute, ok := attributes["extra_site_ids"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`extra_site_ids is missing from object`)

		return NewInstallerValueUnknown(), diags
	}

	extraSiteIdsVal, ok := extraSiteIdsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`extra_site_ids expected to be basetypes.ListValue, was: %T`, extraSiteIdsAttribute))
	}

	gracePeriodAttribute, ok := attributes["grace_period"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`grace_period is missing from object`)

		return NewInstallerValueUnknown(), diags
	}

	gracePeriodVal, ok := gracePeriodAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`grace_period expected to be basetypes.Int64Value, was: %T`, gracePeriodAttribute))
	}

	if diags.HasError() {
		return NewInstallerValueUnknown(), diags
	}

	return InstallerValue{
		AllowAllDevices: allowAllDevicesVal,
		AllowAllSites:   allowAllSitesVal,
		ExtraSiteIds:    extraSiteIdsVal,
		GracePeriod:     gracePeriodVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewInstallerValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) InstallerValue {
	object, diags := NewInstallerValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewInstallerValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t InstallerType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewInstallerValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewInstallerValueUnknown(), nil
	}

	if in.IsNull() {
		return NewInstallerValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewInstallerValueMust(InstallerValue{}.AttributeTypes(ctx), attributes), nil
}

func (t InstallerType) ValueType(ctx context.Context) attr.Value {
	return InstallerValue{}
}

var _ basetypes.ObjectValuable = InstallerValue{}

type InstallerValue struct {
	AllowAllDevices basetypes.BoolValue  `tfsdk:"allow_all_devices"`
	AllowAllSites   basetypes.BoolValue  `tfsdk:"allow_all_sites"`
	ExtraSiteIds    basetypes.ListValue  `tfsdk:"extra_site_ids"`
	GracePeriod     basetypes.Int64Value `tfsdk:"grace_period"`
	state           attr.ValueState
}

func (v InstallerValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["allow_all_devices"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["allow_all_sites"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["extra_site_ids"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["grace_period"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.AllowAllDevices.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["allow_all_devices"] = val

		val, err = v.AllowAllSites.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["allow_all_sites"] = val

		val, err = v.ExtraSiteIds.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["extra_site_ids"] = val

		val, err = v.GracePeriod.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["grace_period"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v InstallerValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v InstallerValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v InstallerValue) String() string {
	return "InstallerValue"
}

func (v InstallerValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var extraSiteIdsVal basetypes.ListValue
	switch {
	case v.ExtraSiteIds.IsUnknown():
		extraSiteIdsVal = types.ListUnknown(types.StringType)
	case v.ExtraSiteIds.IsNull():
		extraSiteIdsVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		extraSiteIdsVal, d = types.ListValue(types.StringType, v.ExtraSiteIds.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"allow_all_devices": basetypes.BoolType{},
			"allow_all_sites":   basetypes.BoolType{},
			"extra_site_ids": basetypes.ListType{
				ElemType: types.StringType,
			},
			"grace_period": basetypes.Int64Type{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"allow_all_devices": basetypes.BoolType{},
		"allow_all_sites":   basetypes.BoolType{},
		"extra_site_ids": basetypes.ListType{
			ElemType: types.StringType,
		},
		"grace_period": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"allow_all_devices": v.AllowAllDevices,
			"allow_all_sites":   v.AllowAllSites,
			"extra_site_ids":    extraSiteIdsVal,
			"grace_period":      v.GracePeriod,
		})

	return objVal, diags
}

func (v InstallerValue) Equal(o attr.Value) bool {
	other, ok := o.(InstallerValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AllowAllDevices.Equal(other.AllowAllDevices) {
		return false
	}

	if !v.AllowAllSites.Equal(other.AllowAllSites) {
		return false
	}

	if !v.ExtraSiteIds.Equal(other.ExtraSiteIds) {
		return false
	}

	if !v.GracePeriod.Equal(other.GracePeriod) {
		return false
	}

	return true
}

func (v InstallerValue) Type(ctx context.Context) attr.Type {
	return InstallerType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v InstallerValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"allow_all_devices": basetypes.BoolType{},
		"allow_all_sites":   basetypes.BoolType{},
		"extra_site_ids": basetypes.ListType{
			ElemType: types.StringType,
		},
		"grace_period": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = JcloudType{}

type JcloudType struct {
	basetypes.ObjectType
}

func (t JcloudType) Equal(o attr.Type) bool {
	other, ok := o.(JcloudType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t JcloudType) String() string {
	return "JcloudType"
}

func (t JcloudType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	orgApitokenAttribute, ok := attributes["org_apitoken"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`org_apitoken is missing from object`)

		return nil, diags
	}

	orgApitokenVal, ok := orgApitokenAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`org_apitoken expected to be basetypes.StringValue, was: %T`, orgApitokenAttribute))
	}

	orgApitokenNameAttribute, ok := attributes["org_apitoken_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`org_apitoken_name is missing from object`)

		return nil, diags
	}

	orgApitokenNameVal, ok := orgApitokenNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`org_apitoken_name expected to be basetypes.StringValue, was: %T`, orgApitokenNameAttribute))
	}

	orgIdAttribute, ok := attributes["org_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`org_id is missing from object`)

		return nil, diags
	}

	orgIdVal, ok := orgIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`org_id expected to be basetypes.StringValue, was: %T`, orgIdAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return JcloudValue{
		OrgApitoken:     orgApitokenVal,
		OrgApitokenName: orgApitokenNameVal,
		OrgId:           orgIdVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewJcloudValueNull() JcloudValue {
	return JcloudValue{
		state: attr.ValueStateNull,
	}
}

func NewJcloudValueUnknown() JcloudValue {
	return JcloudValue{
		state: attr.ValueStateUnknown,
	}
}

func NewJcloudValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (JcloudValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing JcloudValue Attribute Value",
				"While creating a JcloudValue value, a missing attribute value was detected. "+
					"A JcloudValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("JcloudValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid JcloudValue Attribute Type",
				"While creating a JcloudValue value, an invalid attribute value was detected. "+
					"A JcloudValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("JcloudValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("JcloudValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra JcloudValue Attribute Value",
				"While creating a JcloudValue value, an extra attribute value was detected. "+
					"A JcloudValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra JcloudValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewJcloudValueUnknown(), diags
	}

	orgApitokenAttribute, ok := attributes["org_apitoken"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`org_apitoken is missing from object`)

		return NewJcloudValueUnknown(), diags
	}

	orgApitokenVal, ok := orgApitokenAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`org_apitoken expected to be basetypes.StringValue, was: %T`, orgApitokenAttribute))
	}

	orgApitokenNameAttribute, ok := attributes["org_apitoken_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`org_apitoken_name is missing from object`)

		return NewJcloudValueUnknown(), diags
	}

	orgApitokenNameVal, ok := orgApitokenNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`org_apitoken_name expected to be basetypes.StringValue, was: %T`, orgApitokenNameAttribute))
	}

	orgIdAttribute, ok := attributes["org_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`org_id is missing from object`)

		return NewJcloudValueUnknown(), diags
	}

	orgIdVal, ok := orgIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`org_id expected to be basetypes.StringValue, was: %T`, orgIdAttribute))
	}

	if diags.HasError() {
		return NewJcloudValueUnknown(), diags
	}

	return JcloudValue{
		OrgApitoken:     orgApitokenVal,
		OrgApitokenName: orgApitokenNameVal,
		OrgId:           orgIdVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewJcloudValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) JcloudValue {
	object, diags := NewJcloudValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewJcloudValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t JcloudType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewJcloudValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewJcloudValueUnknown(), nil
	}

	if in.IsNull() {
		return NewJcloudValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewJcloudValueMust(JcloudValue{}.AttributeTypes(ctx), attributes), nil
}

func (t JcloudType) ValueType(ctx context.Context) attr.Value {
	return JcloudValue{}
}

var _ basetypes.ObjectValuable = JcloudValue{}

type JcloudValue struct {
	OrgApitoken     basetypes.StringValue `tfsdk:"org_apitoken"`
	OrgApitokenName basetypes.StringValue `tfsdk:"org_apitoken_name"`
	OrgId           basetypes.StringValue `tfsdk:"org_id"`
	state           attr.ValueState
}

func (v JcloudValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["org_apitoken"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["org_apitoken_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["org_id"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.OrgApitoken.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["org_apitoken"] = val

		val, err = v.OrgApitokenName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["org_apitoken_name"] = val

		val, err = v.OrgId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["org_id"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v JcloudValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v JcloudValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v JcloudValue) String() string {
	return "JcloudValue"
}

func (v JcloudValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"org_apitoken":      basetypes.StringType{},
		"org_apitoken_name": basetypes.StringType{},
		"org_id":            basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"org_apitoken":      v.OrgApitoken,
			"org_apitoken_name": v.OrgApitokenName,
			"org_id":            v.OrgId,
		})

	return objVal, diags
}

func (v JcloudValue) Equal(o attr.Value) bool {
	other, ok := o.(JcloudValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.OrgApitoken.Equal(other.OrgApitoken) {
		return false
	}

	if !v.OrgApitokenName.Equal(other.OrgApitokenName) {
		return false
	}

	if !v.OrgId.Equal(other.OrgId) {
		return false
	}

	return true
}

func (v JcloudValue) Type(ctx context.Context) attr.Type {
	return JcloudType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v JcloudValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"org_apitoken":      basetypes.StringType{},
		"org_apitoken_name": basetypes.StringType{},
		"org_id":            basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = JcloudRaType{}

type JcloudRaType struct {
	basetypes.ObjectType
}

func (t JcloudRaType) Equal(o attr.Type) bool {
	other, ok := o.(JcloudRaType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t JcloudRaType) String() string {
	return "JcloudRaType"
}

func (t JcloudRaType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	orgApitokenAttribute, ok := attributes["org_apitoken"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`org_apitoken is missing from object`)

		return nil, diags
	}

	orgApitokenVal, ok := orgApitokenAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`org_apitoken expected to be basetypes.StringValue, was: %T`, orgApitokenAttribute))
	}

	orgApitokenNameAttribute, ok := attributes["org_apitoken_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`org_apitoken_name is missing from object`)

		return nil, diags
	}

	orgApitokenNameVal, ok := orgApitokenNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`org_apitoken_name expected to be basetypes.StringValue, was: %T`, orgApitokenNameAttribute))
	}

	orgIdAttribute, ok := attributes["org_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`org_id is missing from object`)

		return nil, diags
	}

	orgIdVal, ok := orgIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`org_id expected to be basetypes.StringValue, was: %T`, orgIdAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return JcloudRaValue{
		OrgApitoken:     orgApitokenVal,
		OrgApitokenName: orgApitokenNameVal,
		OrgId:           orgIdVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewJcloudRaValueNull() JcloudRaValue {
	return JcloudRaValue{
		state: attr.ValueStateNull,
	}
}

func NewJcloudRaValueUnknown() JcloudRaValue {
	return JcloudRaValue{
		state: attr.ValueStateUnknown,
	}
}

func NewJcloudRaValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (JcloudRaValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing JcloudRaValue Attribute Value",
				"While creating a JcloudRaValue value, a missing attribute value was detected. "+
					"A JcloudRaValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("JcloudRaValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid JcloudRaValue Attribute Type",
				"While creating a JcloudRaValue value, an invalid attribute value was detected. "+
					"A JcloudRaValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("JcloudRaValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("JcloudRaValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra JcloudRaValue Attribute Value",
				"While creating a JcloudRaValue value, an extra attribute value was detected. "+
					"A JcloudRaValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra JcloudRaValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewJcloudRaValueUnknown(), diags
	}

	orgApitokenAttribute, ok := attributes["org_apitoken"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`org_apitoken is missing from object`)

		return NewJcloudRaValueUnknown(), diags
	}

	orgApitokenVal, ok := orgApitokenAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`org_apitoken expected to be basetypes.StringValue, was: %T`, orgApitokenAttribute))
	}

	orgApitokenNameAttribute, ok := attributes["org_apitoken_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`org_apitoken_name is missing from object`)

		return NewJcloudRaValueUnknown(), diags
	}

	orgApitokenNameVal, ok := orgApitokenNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`org_apitoken_name expected to be basetypes.StringValue, was: %T`, orgApitokenNameAttribute))
	}

	orgIdAttribute, ok := attributes["org_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`org_id is missing from object`)

		return NewJcloudRaValueUnknown(), diags
	}

	orgIdVal, ok := orgIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`org_id expected to be basetypes.StringValue, was: %T`, orgIdAttribute))
	}

	if diags.HasError() {
		return NewJcloudRaValueUnknown(), diags
	}

	return JcloudRaValue{
		OrgApitoken:     orgApitokenVal,
		OrgApitokenName: orgApitokenNameVal,
		OrgId:           orgIdVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewJcloudRaValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) JcloudRaValue {
	object, diags := NewJcloudRaValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewJcloudRaValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t JcloudRaType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewJcloudRaValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewJcloudRaValueUnknown(), nil
	}

	if in.IsNull() {
		return NewJcloudRaValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewJcloudRaValueMust(JcloudRaValue{}.AttributeTypes(ctx), attributes), nil
}

func (t JcloudRaType) ValueType(ctx context.Context) attr.Value {
	return JcloudRaValue{}
}

var _ basetypes.ObjectValuable = JcloudRaValue{}

type JcloudRaValue struct {
	OrgApitoken     basetypes.StringValue `tfsdk:"org_apitoken"`
	OrgApitokenName basetypes.StringValue `tfsdk:"org_apitoken_name"`
	OrgId           basetypes.StringValue `tfsdk:"org_id"`
	state           attr.ValueState
}

func (v JcloudRaValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["org_apitoken"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["org_apitoken_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["org_id"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.OrgApitoken.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["org_apitoken"] = val

		val, err = v.OrgApitokenName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["org_apitoken_name"] = val

		val, err = v.OrgId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["org_id"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v JcloudRaValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v JcloudRaValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v JcloudRaValue) String() string {
	return "JcloudRaValue"
}

func (v JcloudRaValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"org_apitoken":      basetypes.StringType{},
		"org_apitoken_name": basetypes.StringType{},
		"org_id":            basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"org_apitoken":      v.OrgApitoken,
			"org_apitoken_name": v.OrgApitokenName,
			"org_id":            v.OrgId,
		})

	return objVal, diags
}

func (v JcloudRaValue) Equal(o attr.Value) bool {
	other, ok := o.(JcloudRaValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.OrgApitoken.Equal(other.OrgApitoken) {
		return false
	}

	if !v.OrgApitokenName.Equal(other.OrgApitokenName) {
		return false
	}

	if !v.OrgId.Equal(other.OrgId) {
		return false
	}

	return true
}

func (v JcloudRaValue) Type(ctx context.Context) attr.Type {
	return JcloudRaType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v JcloudRaValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"org_apitoken":      basetypes.StringType{},
		"org_apitoken_name": basetypes.StringType{},
		"org_id":            basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = JuniperType{}

type JuniperType struct {
	basetypes.ObjectType
}

func (t JuniperType) Equal(o attr.Type) bool {
	other, ok := o.(JuniperType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t JuniperType) String() string {
	return "JuniperType"
}

func (t JuniperType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	accountsAttribute, ok := attributes["accounts"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`accounts is missing from object`)

		return nil, diags
	}

	accountsVal, ok := accountsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`accounts expected to be basetypes.ListValue, was: %T`, accountsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return JuniperValue{
		Accounts: accountsVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewJuniperValueNull() JuniperValue {
	return JuniperValue{
		state: attr.ValueStateNull,
	}
}

func NewJuniperValueUnknown() JuniperValue {
	return JuniperValue{
		state: attr.ValueStateUnknown,
	}
}

func NewJuniperValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (JuniperValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing JuniperValue Attribute Value",
				"While creating a JuniperValue value, a missing attribute value was detected. "+
					"A JuniperValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("JuniperValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid JuniperValue Attribute Type",
				"While creating a JuniperValue value, an invalid attribute value was detected. "+
					"A JuniperValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("JuniperValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("JuniperValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra JuniperValue Attribute Value",
				"While creating a JuniperValue value, an extra attribute value was detected. "+
					"A JuniperValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra JuniperValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewJuniperValueUnknown(), diags
	}

	accountsAttribute, ok := attributes["accounts"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`accounts is missing from object`)

		return NewJuniperValueUnknown(), diags
	}

	accountsVal, ok := accountsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`accounts expected to be basetypes.ListValue, was: %T`, accountsAttribute))
	}

	if diags.HasError() {
		return NewJuniperValueUnknown(), diags
	}

	return JuniperValue{
		Accounts: accountsVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewJuniperValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) JuniperValue {
	object, diags := NewJuniperValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewJuniperValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t JuniperType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewJuniperValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewJuniperValueUnknown(), nil
	}

	if in.IsNull() {
		return NewJuniperValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewJuniperValueMust(JuniperValue{}.AttributeTypes(ctx), attributes), nil
}

func (t JuniperType) ValueType(ctx context.Context) attr.Value {
	return JuniperValue{}
}

var _ basetypes.ObjectValuable = JuniperValue{}

type JuniperValue struct {
	Accounts basetypes.ListValue `tfsdk:"accounts"`
	state    attr.ValueState
}

func (v JuniperValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["accounts"] = basetypes.ListType{
		ElemType: AccountsValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Accounts.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["accounts"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v JuniperValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v JuniperValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v JuniperValue) String() string {
	return "JuniperValue"
}

func (v JuniperValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	accounts := types.ListValueMust(
		AccountsType{
			basetypes.ObjectType{
				AttrTypes: AccountsValue{}.AttributeTypes(ctx),
			},
		},
		v.Accounts.Elements(),
	)

	if v.Accounts.IsNull() {
		accounts = types.ListNull(
			AccountsType{
				basetypes.ObjectType{
					AttrTypes: AccountsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Accounts.IsUnknown() {
		accounts = types.ListUnknown(
			AccountsType{
				basetypes.ObjectType{
					AttrTypes: AccountsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"accounts": basetypes.ListType{
			ElemType: AccountsValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"accounts": accounts,
		})

	return objVal, diags
}

func (v JuniperValue) Equal(o attr.Value) bool {
	other, ok := o.(JuniperValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Accounts.Equal(other.Accounts) {
		return false
	}

	return true
}

func (v JuniperValue) Type(ctx context.Context) attr.Type {
	return JuniperType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v JuniperValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"accounts": basetypes.ListType{
			ElemType: AccountsValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = AccountsType{}

type AccountsType struct {
	basetypes.ObjectType
}

func (t AccountsType) Equal(o attr.Type) bool {
	other, ok := o.(AccountsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AccountsType) String() string {
	return "AccountsType"
}

func (t AccountsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	linkedByAttribute, ok := attributes["linked_by"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`linked_by is missing from object`)

		return nil, diags
	}

	linkedByVal, ok := linkedByAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`linked_by expected to be basetypes.StringValue, was: %T`, linkedByAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AccountsValue{
		LinkedBy: linkedByVal,
		Name:     nameVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewAccountsValueNull() AccountsValue {
	return AccountsValue{
		state: attr.ValueStateNull,
	}
}

func NewAccountsValueUnknown() AccountsValue {
	return AccountsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewAccountsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AccountsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AccountsValue Attribute Value",
				"While creating a AccountsValue value, a missing attribute value was detected. "+
					"A AccountsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AccountsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AccountsValue Attribute Type",
				"While creating a AccountsValue value, an invalid attribute value was detected. "+
					"A AccountsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AccountsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AccountsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AccountsValue Attribute Value",
				"While creating a AccountsValue value, an extra attribute value was detected. "+
					"A AccountsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AccountsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAccountsValueUnknown(), diags
	}

	linkedByAttribute, ok := attributes["linked_by"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`linked_by is missing from object`)

		return NewAccountsValueUnknown(), diags
	}

	linkedByVal, ok := linkedByAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`linked_by expected to be basetypes.StringValue, was: %T`, linkedByAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewAccountsValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	if diags.HasError() {
		return NewAccountsValueUnknown(), diags
	}

	return AccountsValue{
		LinkedBy: linkedByVal,
		Name:     nameVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewAccountsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AccountsValue {
	object, diags := NewAccountsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAccountsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AccountsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAccountsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAccountsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAccountsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAccountsValueMust(AccountsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t AccountsType) ValueType(ctx context.Context) attr.Value {
	return AccountsValue{}
}

var _ basetypes.ObjectValuable = AccountsValue{}

type AccountsValue struct {
	LinkedBy basetypes.StringValue `tfsdk:"linked_by"`
	Name     basetypes.StringValue `tfsdk:"name"`
	state    attr.ValueState
}

func (v AccountsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["linked_by"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.LinkedBy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["linked_by"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AccountsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AccountsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AccountsValue) String() string {
	return "AccountsValue"
}

func (v AccountsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"linked_by": basetypes.StringType{},
		"name":      basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"linked_by": v.LinkedBy,
			"name":      v.Name,
		})

	return objVal, diags
}

func (v AccountsValue) Equal(o attr.Value) bool {
	other, ok := o.(AccountsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.LinkedBy.Equal(other.LinkedBy) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	return true
}

func (v AccountsValue) Type(ctx context.Context) attr.Type {
	return AccountsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AccountsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"linked_by": basetypes.StringType{},
		"name":      basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = JuniperSrxType{}

type JuniperSrxType struct {
	basetypes.ObjectType
}

func (t JuniperSrxType) Equal(o attr.Type) bool {
	other, ok := o.(JuniperSrxType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t JuniperSrxType) String() string {
	return "JuniperSrxType"
}

func (t JuniperSrxType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	srxAutoUpgradeAttribute, ok := attributes["auto_upgrade"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auto_upgrade is missing from object`)

		return nil, diags
	}

	srxAutoUpgradeVal, ok := srxAutoUpgradeAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auto_upgrade expected to be basetypes.ObjectValue, was: %T`, srxAutoUpgradeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return JuniperSrxValue{
		SrxAutoUpgrade: srxAutoUpgradeVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewJuniperSrxValueNull() JuniperSrxValue {
	return JuniperSrxValue{
		state: attr.ValueStateNull,
	}
}

func NewJuniperSrxValueUnknown() JuniperSrxValue {
	return JuniperSrxValue{
		state: attr.ValueStateUnknown,
	}
}

func NewJuniperSrxValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (JuniperSrxValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing JuniperSrxValue Attribute Value",
				"While creating a JuniperSrxValue value, a missing attribute value was detected. "+
					"A JuniperSrxValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("JuniperSrxValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid JuniperSrxValue Attribute Type",
				"While creating a JuniperSrxValue value, an invalid attribute value was detected. "+
					"A JuniperSrxValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("JuniperSrxValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("JuniperSrxValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra JuniperSrxValue Attribute Value",
				"While creating a JuniperSrxValue value, an extra attribute value was detected. "+
					"A JuniperSrxValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra JuniperSrxValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewJuniperSrxValueUnknown(), diags
	}

	srxAutoUpgradeAttribute, ok := attributes["auto_upgrade"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auto_upgrade is missing from object`)

		return NewJuniperSrxValueUnknown(), diags
	}

	srxAutoUpgradeVal, ok := srxAutoUpgradeAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auto_upgrade expected to be basetypes.ObjectValue, was: %T`, srxAutoUpgradeAttribute))
	}

	if diags.HasError() {
		return NewJuniperSrxValueUnknown(), diags
	}

	return JuniperSrxValue{
		SrxAutoUpgrade: srxAutoUpgradeVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewJuniperSrxValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) JuniperSrxValue {
	object, diags := NewJuniperSrxValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewJuniperSrxValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t JuniperSrxType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewJuniperSrxValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewJuniperSrxValueUnknown(), nil
	}

	if in.IsNull() {
		return NewJuniperSrxValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewJuniperSrxValueMust(JuniperSrxValue{}.AttributeTypes(ctx), attributes), nil
}

func (t JuniperSrxType) ValueType(ctx context.Context) attr.Value {
	return JuniperSrxValue{}
}

var _ basetypes.ObjectValuable = JuniperSrxValue{}

type JuniperSrxValue struct {
	SrxAutoUpgrade basetypes.ObjectValue `tfsdk:"auto_upgrade"`
	state          attr.ValueState
}

func (v JuniperSrxValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["auto_upgrade"] = basetypes.ObjectType{
		AttrTypes: SrxAutoUpgradeValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.SrxAutoUpgrade.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["auto_upgrade"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v JuniperSrxValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v JuniperSrxValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v JuniperSrxValue) String() string {
	return "JuniperSrxValue"
}

func (v JuniperSrxValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var srxAutoUpgrade basetypes.ObjectValue

	if v.SrxAutoUpgrade.IsNull() {
		srxAutoUpgrade = types.ObjectNull(
			SrxAutoUpgradeValue{}.AttributeTypes(ctx),
		)
	}

	if v.SrxAutoUpgrade.IsUnknown() {
		srxAutoUpgrade = types.ObjectUnknown(
			SrxAutoUpgradeValue{}.AttributeTypes(ctx),
		)
	}

	if !v.SrxAutoUpgrade.IsNull() && !v.SrxAutoUpgrade.IsUnknown() {
		srxAutoUpgrade = types.ObjectValueMust(
			SrxAutoUpgradeValue{}.AttributeTypes(ctx),
			v.SrxAutoUpgrade.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"auto_upgrade": basetypes.ObjectType{
			AttrTypes: SrxAutoUpgradeValue{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"auto_upgrade": srxAutoUpgrade,
		})

	return objVal, diags
}

func (v JuniperSrxValue) Equal(o attr.Value) bool {
	other, ok := o.(JuniperSrxValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.SrxAutoUpgrade.Equal(other.SrxAutoUpgrade) {
		return false
	}

	return true
}

func (v JuniperSrxValue) Type(ctx context.Context) attr.Type {
	return JuniperSrxType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v JuniperSrxValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"auto_upgrade": basetypes.ObjectType{
			AttrTypes: SrxAutoUpgradeValue{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = SrxAutoUpgradeType{}

type SrxAutoUpgradeType struct {
	basetypes.ObjectType
}

func (t SrxAutoUpgradeType) Equal(o attr.Type) bool {
	other, ok := o.(SrxAutoUpgradeType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SrxAutoUpgradeType) String() string {
	return "SrxAutoUpgradeType"
}

func (t SrxAutoUpgradeType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	customVersionsAttribute, ok := attributes["custom_versions"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`custom_versions is missing from object`)

		return nil, diags
	}

	customVersionsVal, ok := customVersionsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`custom_versions expected to be basetypes.MapValue, was: %T`, customVersionsAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	snapshotAttribute, ok := attributes["snapshot"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`snapshot is missing from object`)

		return nil, diags
	}

	snapshotVal, ok := snapshotAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`snapshot expected to be basetypes.BoolValue, was: %T`, snapshotAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SrxAutoUpgradeValue{
		CustomVersions: customVersionsVal,
		Enabled:        enabledVal,
		Snapshot:       snapshotVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewSrxAutoUpgradeValueNull() SrxAutoUpgradeValue {
	return SrxAutoUpgradeValue{
		state: attr.ValueStateNull,
	}
}

func NewSrxAutoUpgradeValueUnknown() SrxAutoUpgradeValue {
	return SrxAutoUpgradeValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSrxAutoUpgradeValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SrxAutoUpgradeValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SrxAutoUpgradeValue Attribute Value",
				"While creating a SrxAutoUpgradeValue value, a missing attribute value was detected. "+
					"A SrxAutoUpgradeValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SrxAutoUpgradeValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SrxAutoUpgradeValue Attribute Type",
				"While creating a SrxAutoUpgradeValue value, an invalid attribute value was detected. "+
					"A SrxAutoUpgradeValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SrxAutoUpgradeValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SrxAutoUpgradeValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SrxAutoUpgradeValue Attribute Value",
				"While creating a SrxAutoUpgradeValue value, an extra attribute value was detected. "+
					"A SrxAutoUpgradeValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SrxAutoUpgradeValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSrxAutoUpgradeValueUnknown(), diags
	}

	customVersionsAttribute, ok := attributes["custom_versions"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`custom_versions is missing from object`)

		return NewSrxAutoUpgradeValueUnknown(), diags
	}

	customVersionsVal, ok := customVersionsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`custom_versions expected to be basetypes.MapValue, was: %T`, customVersionsAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewSrxAutoUpgradeValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	snapshotAttribute, ok := attributes["snapshot"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`snapshot is missing from object`)

		return NewSrxAutoUpgradeValueUnknown(), diags
	}

	snapshotVal, ok := snapshotAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`snapshot expected to be basetypes.BoolValue, was: %T`, snapshotAttribute))
	}

	if diags.HasError() {
		return NewSrxAutoUpgradeValueUnknown(), diags
	}

	return SrxAutoUpgradeValue{
		CustomVersions: customVersionsVal,
		Enabled:        enabledVal,
		Snapshot:       snapshotVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewSrxAutoUpgradeValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SrxAutoUpgradeValue {
	object, diags := NewSrxAutoUpgradeValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSrxAutoUpgradeValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SrxAutoUpgradeType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSrxAutoUpgradeValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSrxAutoUpgradeValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSrxAutoUpgradeValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSrxAutoUpgradeValueMust(SrxAutoUpgradeValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SrxAutoUpgradeType) ValueType(ctx context.Context) attr.Value {
	return SrxAutoUpgradeValue{}
}

var _ basetypes.ObjectValuable = SrxAutoUpgradeValue{}

type SrxAutoUpgradeValue struct {
	CustomVersions basetypes.MapValue  `tfsdk:"custom_versions"`
	Enabled        basetypes.BoolValue `tfsdk:"enabled"`
	Snapshot       basetypes.BoolValue `tfsdk:"snapshot"`
	state          attr.ValueState
}

func (v SrxAutoUpgradeValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["custom_versions"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["snapshot"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.CustomVersions.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["custom_versions"] = val

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.Snapshot.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["snapshot"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SrxAutoUpgradeValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SrxAutoUpgradeValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SrxAutoUpgradeValue) String() string {
	return "SrxAutoUpgradeValue"
}

func (v SrxAutoUpgradeValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var customVersionsVal basetypes.MapValue
	switch {
	case v.CustomVersions.IsUnknown():
		customVersionsVal = types.MapUnknown(types.StringType)
	case v.CustomVersions.IsNull():
		customVersionsVal = types.MapNull(types.StringType)
	default:
		var d diag.Diagnostics
		customVersionsVal, d = types.MapValue(types.StringType, v.CustomVersions.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"custom_versions": basetypes.MapType{
				ElemType: types.StringType,
			},
			"enabled":  basetypes.BoolType{},
			"snapshot": basetypes.BoolType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"custom_versions": basetypes.MapType{
			ElemType: types.StringType,
		},
		"enabled":  basetypes.BoolType{},
		"snapshot": basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"custom_versions": customVersionsVal,
			"enabled":         v.Enabled,
			"snapshot":        v.Snapshot,
		})

	return objVal, diags
}

func (v SrxAutoUpgradeValue) Equal(o attr.Value) bool {
	other, ok := o.(SrxAutoUpgradeValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.CustomVersions.Equal(other.CustomVersions) {
		return false
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.Snapshot.Equal(other.Snapshot) {
		return false
	}

	return true
}

func (v SrxAutoUpgradeValue) Type(ctx context.Context) attr.Type {
	return SrxAutoUpgradeType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SrxAutoUpgradeValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"custom_versions": basetypes.MapType{
			ElemType: types.StringType,
		},
		"enabled":  basetypes.BoolType{},
		"snapshot": basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = JunosShellAccessType{}

type JunosShellAccessType struct {
	basetypes.ObjectType
}

func (t JunosShellAccessType) Equal(o attr.Type) bool {
	other, ok := o.(JunosShellAccessType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t JunosShellAccessType) String() string {
	return "JunosShellAccessType"
}

func (t JunosShellAccessType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	adminAttribute, ok := attributes["admin"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`admin is missing from object`)

		return nil, diags
	}

	adminVal, ok := adminAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`admin expected to be basetypes.StringValue, was: %T`, adminAttribute))
	}

	helpdeskAttribute, ok := attributes["helpdesk"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`helpdesk is missing from object`)

		return nil, diags
	}

	helpdeskVal, ok := helpdeskAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`helpdesk expected to be basetypes.StringValue, was: %T`, helpdeskAttribute))
	}

	readAttribute, ok := attributes["read"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`read is missing from object`)

		return nil, diags
	}

	readVal, ok := readAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`read expected to be basetypes.StringValue, was: %T`, readAttribute))
	}

	writeAttribute, ok := attributes["write"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`write is missing from object`)

		return nil, diags
	}

	writeVal, ok := writeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`write expected to be basetypes.StringValue, was: %T`, writeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return JunosShellAccessValue{
		Admin:    adminVal,
		Helpdesk: helpdeskVal,
		Read:     readVal,
		Write:    writeVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewJunosShellAccessValueNull() JunosShellAccessValue {
	return JunosShellAccessValue{
		state: attr.ValueStateNull,
	}
}

func NewJunosShellAccessValueUnknown() JunosShellAccessValue {
	return JunosShellAccessValue{
		state: attr.ValueStateUnknown,
	}
}

func NewJunosShellAccessValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (JunosShellAccessValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing JunosShellAccessValue Attribute Value",
				"While creating a JunosShellAccessValue value, a missing attribute value was detected. "+
					"A JunosShellAccessValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("JunosShellAccessValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid JunosShellAccessValue Attribute Type",
				"While creating a JunosShellAccessValue value, an invalid attribute value was detected. "+
					"A JunosShellAccessValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("JunosShellAccessValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("JunosShellAccessValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra JunosShellAccessValue Attribute Value",
				"While creating a JunosShellAccessValue value, an extra attribute value was detected. "+
					"A JunosShellAccessValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra JunosShellAccessValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewJunosShellAccessValueUnknown(), diags
	}

	adminAttribute, ok := attributes["admin"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`admin is missing from object`)

		return NewJunosShellAccessValueUnknown(), diags
	}

	adminVal, ok := adminAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`admin expected to be basetypes.StringValue, was: %T`, adminAttribute))
	}

	helpdeskAttribute, ok := attributes["helpdesk"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`helpdesk is missing from object`)

		return NewJunosShellAccessValueUnknown(), diags
	}

	helpdeskVal, ok := helpdeskAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`helpdesk expected to be basetypes.StringValue, was: %T`, helpdeskAttribute))
	}

	readAttribute, ok := attributes["read"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`read is missing from object`)

		return NewJunosShellAccessValueUnknown(), diags
	}

	readVal, ok := readAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`read expected to be basetypes.StringValue, was: %T`, readAttribute))
	}

	writeAttribute, ok := attributes["write"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`write is missing from object`)

		return NewJunosShellAccessValueUnknown(), diags
	}

	writeVal, ok := writeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`write expected to be basetypes.StringValue, was: %T`, writeAttribute))
	}

	if diags.HasError() {
		return NewJunosShellAccessValueUnknown(), diags
	}

	return JunosShellAccessValue{
		Admin:    adminVal,
		Helpdesk: helpdeskVal,
		Read:     readVal,
		Write:    writeVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewJunosShellAccessValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) JunosShellAccessValue {
	object, diags := NewJunosShellAccessValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewJunosShellAccessValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t JunosShellAccessType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewJunosShellAccessValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewJunosShellAccessValueUnknown(), nil
	}

	if in.IsNull() {
		return NewJunosShellAccessValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewJunosShellAccessValueMust(JunosShellAccessValue{}.AttributeTypes(ctx), attributes), nil
}

func (t JunosShellAccessType) ValueType(ctx context.Context) attr.Value {
	return JunosShellAccessValue{}
}

var _ basetypes.ObjectValuable = JunosShellAccessValue{}

type JunosShellAccessValue struct {
	Admin    basetypes.StringValue `tfsdk:"admin"`
	Helpdesk basetypes.StringValue `tfsdk:"helpdesk"`
	Read     basetypes.StringValue `tfsdk:"read"`
	Write    basetypes.StringValue `tfsdk:"write"`
	state    attr.ValueState
}

func (v JunosShellAccessValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["admin"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["helpdesk"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["read"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["write"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Admin.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["admin"] = val

		val, err = v.Helpdesk.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["helpdesk"] = val

		val, err = v.Read.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["read"] = val

		val, err = v.Write.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["write"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v JunosShellAccessValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v JunosShellAccessValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v JunosShellAccessValue) String() string {
	return "JunosShellAccessValue"
}

func (v JunosShellAccessValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"admin":    basetypes.StringType{},
		"helpdesk": basetypes.StringType{},
		"read":     basetypes.StringType{},
		"write":    basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"admin":    v.Admin,
			"helpdesk": v.Helpdesk,
			"read":     v.Read,
			"write":    v.Write,
		})

	return objVal, diags
}

func (v JunosShellAccessValue) Equal(o attr.Value) bool {
	other, ok := o.(JunosShellAccessValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Admin.Equal(other.Admin) {
		return false
	}

	if !v.Helpdesk.Equal(other.Helpdesk) {
		return false
	}

	if !v.Read.Equal(other.Read) {
		return false
	}

	if !v.Write.Equal(other.Write) {
		return false
	}

	return true
}

func (v JunosShellAccessValue) Type(ctx context.Context) attr.Type {
	return JunosShellAccessType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v JunosShellAccessValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"admin":    basetypes.StringType{},
		"helpdesk": basetypes.StringType{},
		"read":     basetypes.StringType{},
		"write":    basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = MarvisType{}

type MarvisType struct {
	basetypes.ObjectType
}

func (t MarvisType) Equal(o attr.Type) bool {
	other, ok := o.(MarvisType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t MarvisType) String() string {
	return "MarvisType"
}

func (t MarvisType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	autoOperationsAttribute, ok := attributes["auto_operations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auto_operations is missing from object`)

		return nil, diags
	}

	autoOperationsVal, ok := autoOperationsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auto_operations expected to be basetypes.ObjectValue, was: %T`, autoOperationsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return MarvisValue{
		AutoOperations: autoOperationsVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewMarvisValueNull() MarvisValue {
	return MarvisValue{
		state: attr.ValueStateNull,
	}
}

func NewMarvisValueUnknown() MarvisValue {
	return MarvisValue{
		state: attr.ValueStateUnknown,
	}
}

func NewMarvisValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (MarvisValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing MarvisValue Attribute Value",
				"While creating a MarvisValue value, a missing attribute value was detected. "+
					"A MarvisValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MarvisValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid MarvisValue Attribute Type",
				"While creating a MarvisValue value, an invalid attribute value was detected. "+
					"A MarvisValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MarvisValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("MarvisValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra MarvisValue Attribute Value",
				"While creating a MarvisValue value, an extra attribute value was detected. "+
					"A MarvisValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra MarvisValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewMarvisValueUnknown(), diags
	}

	autoOperationsAttribute, ok := attributes["auto_operations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auto_operations is missing from object`)

		return NewMarvisValueUnknown(), diags
	}

	autoOperationsVal, ok := autoOperationsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auto_operations expected to be basetypes.ObjectValue, was: %T`, autoOperationsAttribute))
	}

	if diags.HasError() {
		return NewMarvisValueUnknown(), diags
	}

	return MarvisValue{
		AutoOperations: autoOperationsVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewMarvisValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) MarvisValue {
	object, diags := NewMarvisValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewMarvisValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t MarvisType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewMarvisValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewMarvisValueUnknown(), nil
	}

	if in.IsNull() {
		return NewMarvisValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewMarvisValueMust(MarvisValue{}.AttributeTypes(ctx), attributes), nil
}

func (t MarvisType) ValueType(ctx context.Context) attr.Value {
	return MarvisValue{}
}

var _ basetypes.ObjectValuable = MarvisValue{}

type MarvisValue struct {
	AutoOperations basetypes.ObjectValue `tfsdk:"auto_operations"`
	state          attr.ValueState
}

func (v MarvisValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["auto_operations"] = basetypes.ObjectType{
		AttrTypes: AutoOperationsValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.AutoOperations.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["auto_operations"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v MarvisValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v MarvisValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v MarvisValue) String() string {
	return "MarvisValue"
}

func (v MarvisValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var autoOperations basetypes.ObjectValue

	if v.AutoOperations.IsNull() {
		autoOperations = types.ObjectNull(
			AutoOperationsValue{}.AttributeTypes(ctx),
		)
	}

	if v.AutoOperations.IsUnknown() {
		autoOperations = types.ObjectUnknown(
			AutoOperationsValue{}.AttributeTypes(ctx),
		)
	}

	if !v.AutoOperations.IsNull() && !v.AutoOperations.IsUnknown() {
		autoOperations = types.ObjectValueMust(
			AutoOperationsValue{}.AttributeTypes(ctx),
			v.AutoOperations.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"auto_operations": basetypes.ObjectType{
			AttrTypes: AutoOperationsValue{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"auto_operations": autoOperations,
		})

	return objVal, diags
}

func (v MarvisValue) Equal(o attr.Value) bool {
	other, ok := o.(MarvisValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AutoOperations.Equal(other.AutoOperations) {
		return false
	}

	return true
}

func (v MarvisValue) Type(ctx context.Context) attr.Type {
	return MarvisType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v MarvisValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"auto_operations": basetypes.ObjectType{
			AttrTypes: AutoOperationsValue{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = AutoOperationsType{}

type AutoOperationsType struct {
	basetypes.ObjectType
}

func (t AutoOperationsType) Equal(o attr.Type) bool {
	other, ok := o.(AutoOperationsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AutoOperationsType) String() string {
	return "AutoOperationsType"
}

func (t AutoOperationsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	bouncePortForAbnormalPoeClientAttribute, ok := attributes["bounce_port_for_abnormal_poe_client"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bounce_port_for_abnormal_poe_client is missing from object`)

		return nil, diags
	}

	bouncePortForAbnormalPoeClientVal, ok := bouncePortForAbnormalPoeClientAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bounce_port_for_abnormal_poe_client expected to be basetypes.BoolValue, was: %T`, bouncePortForAbnormalPoeClientAttribute))
	}

	disablePortWhenDdosProtocolViolationAttribute, ok := attributes["disable_port_when_ddos_protocol_violation"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disable_port_when_ddos_protocol_violation is missing from object`)

		return nil, diags
	}

	disablePortWhenDdosProtocolViolationVal, ok := disablePortWhenDdosProtocolViolationAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disable_port_when_ddos_protocol_violation expected to be basetypes.BoolValue, was: %T`, disablePortWhenDdosProtocolViolationAttribute))
	}

	disablePortWhenRogueDhcpServerDetectedAttribute, ok := attributes["disable_port_when_rogue_dhcp_server_detected"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disable_port_when_rogue_dhcp_server_detected is missing from object`)

		return nil, diags
	}

	disablePortWhenRogueDhcpServerDetectedVal, ok := disablePortWhenRogueDhcpServerDetectedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disable_port_when_rogue_dhcp_server_detected expected to be basetypes.BoolValue, was: %T`, disablePortWhenRogueDhcpServerDetectedAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AutoOperationsValue{
		BouncePortForAbnormalPoeClient:         bouncePortForAbnormalPoeClientVal,
		DisablePortWhenDdosProtocolViolation:   disablePortWhenDdosProtocolViolationVal,
		DisablePortWhenRogueDhcpServerDetected: disablePortWhenRogueDhcpServerDetectedVal,
		state:                                  attr.ValueStateKnown,
	}, diags
}

func NewAutoOperationsValueNull() AutoOperationsValue {
	return AutoOperationsValue{
		state: attr.ValueStateNull,
	}
}

func NewAutoOperationsValueUnknown() AutoOperationsValue {
	return AutoOperationsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewAutoOperationsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AutoOperationsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AutoOperationsValue Attribute Value",
				"While creating a AutoOperationsValue value, a missing attribute value was detected. "+
					"A AutoOperationsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AutoOperationsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AutoOperationsValue Attribute Type",
				"While creating a AutoOperationsValue value, an invalid attribute value was detected. "+
					"A AutoOperationsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AutoOperationsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AutoOperationsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AutoOperationsValue Attribute Value",
				"While creating a AutoOperationsValue value, an extra attribute value was detected. "+
					"A AutoOperationsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AutoOperationsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAutoOperationsValueUnknown(), diags
	}

	bouncePortForAbnormalPoeClientAttribute, ok := attributes["bounce_port_for_abnormal_poe_client"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bounce_port_for_abnormal_poe_client is missing from object`)

		return NewAutoOperationsValueUnknown(), diags
	}

	bouncePortForAbnormalPoeClientVal, ok := bouncePortForAbnormalPoeClientAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bounce_port_for_abnormal_poe_client expected to be basetypes.BoolValue, was: %T`, bouncePortForAbnormalPoeClientAttribute))
	}

	disablePortWhenDdosProtocolViolationAttribute, ok := attributes["disable_port_when_ddos_protocol_violation"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disable_port_when_ddos_protocol_violation is missing from object`)

		return NewAutoOperationsValueUnknown(), diags
	}

	disablePortWhenDdosProtocolViolationVal, ok := disablePortWhenDdosProtocolViolationAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disable_port_when_ddos_protocol_violation expected to be basetypes.BoolValue, was: %T`, disablePortWhenDdosProtocolViolationAttribute))
	}

	disablePortWhenRogueDhcpServerDetectedAttribute, ok := attributes["disable_port_when_rogue_dhcp_server_detected"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disable_port_when_rogue_dhcp_server_detected is missing from object`)

		return NewAutoOperationsValueUnknown(), diags
	}

	disablePortWhenRogueDhcpServerDetectedVal, ok := disablePortWhenRogueDhcpServerDetectedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disable_port_when_rogue_dhcp_server_detected expected to be basetypes.BoolValue, was: %T`, disablePortWhenRogueDhcpServerDetectedAttribute))
	}

	if diags.HasError() {
		return NewAutoOperationsValueUnknown(), diags
	}

	return AutoOperationsValue{
		BouncePortForAbnormalPoeClient:         bouncePortForAbnormalPoeClientVal,
		DisablePortWhenDdosProtocolViolation:   disablePortWhenDdosProtocolViolationVal,
		DisablePortWhenRogueDhcpServerDetected: disablePortWhenRogueDhcpServerDetectedVal,
		state:                                  attr.ValueStateKnown,
	}, diags
}

func NewAutoOperationsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AutoOperationsValue {
	object, diags := NewAutoOperationsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAutoOperationsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AutoOperationsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAutoOperationsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAutoOperationsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAutoOperationsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAutoOperationsValueMust(AutoOperationsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t AutoOperationsType) ValueType(ctx context.Context) attr.Value {
	return AutoOperationsValue{}
}

var _ basetypes.ObjectValuable = AutoOperationsValue{}

type AutoOperationsValue struct {
	BouncePortForAbnormalPoeClient         basetypes.BoolValue `tfsdk:"bounce_port_for_abnormal_poe_client"`
	DisablePortWhenDdosProtocolViolation   basetypes.BoolValue `tfsdk:"disable_port_when_ddos_protocol_violation"`
	DisablePortWhenRogueDhcpServerDetected basetypes.BoolValue `tfsdk:"disable_port_when_rogue_dhcp_server_detected"`
	state                                  attr.ValueState
}

func (v AutoOperationsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["bounce_port_for_abnormal_poe_client"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["disable_port_when_ddos_protocol_violation"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["disable_port_when_rogue_dhcp_server_detected"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.BouncePortForAbnormalPoeClient.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bounce_port_for_abnormal_poe_client"] = val

		val, err = v.DisablePortWhenDdosProtocolViolation.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["disable_port_when_ddos_protocol_violation"] = val

		val, err = v.DisablePortWhenRogueDhcpServerDetected.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["disable_port_when_rogue_dhcp_server_detected"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AutoOperationsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AutoOperationsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AutoOperationsValue) String() string {
	return "AutoOperationsValue"
}

func (v AutoOperationsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"bounce_port_for_abnormal_poe_client":          basetypes.BoolType{},
		"disable_port_when_ddos_protocol_violation":    basetypes.BoolType{},
		"disable_port_when_rogue_dhcp_server_detected": basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"bounce_port_for_abnormal_poe_client":          v.BouncePortForAbnormalPoeClient,
			"disable_port_when_ddos_protocol_violation":    v.DisablePortWhenDdosProtocolViolation,
			"disable_port_when_rogue_dhcp_server_detected": v.DisablePortWhenRogueDhcpServerDetected,
		})

	return objVal, diags
}

func (v AutoOperationsValue) Equal(o attr.Value) bool {
	other, ok := o.(AutoOperationsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.BouncePortForAbnormalPoeClient.Equal(other.BouncePortForAbnormalPoeClient) {
		return false
	}

	if !v.DisablePortWhenDdosProtocolViolation.Equal(other.DisablePortWhenDdosProtocolViolation) {
		return false
	}

	if !v.DisablePortWhenRogueDhcpServerDetected.Equal(other.DisablePortWhenRogueDhcpServerDetected) {
		return false
	}

	return true
}

func (v AutoOperationsValue) Type(ctx context.Context) attr.Type {
	return AutoOperationsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AutoOperationsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"bounce_port_for_abnormal_poe_client":          basetypes.BoolType{},
		"disable_port_when_ddos_protocol_violation":    basetypes.BoolType{},
		"disable_port_when_rogue_dhcp_server_detected": basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = MgmtType{}

type MgmtType struct {
	basetypes.ObjectType
}

func (t MgmtType) Equal(o attr.Type) bool {
	other, ok := o.(MgmtType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t MgmtType) String() string {
	return "MgmtType"
}

func (t MgmtType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	mxtunnelIdsAttribute, ok := attributes["mxtunnel_ids"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mxtunnel_ids is missing from object`)

		return nil, diags
	}

	mxtunnelIdsVal, ok := mxtunnelIdsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mxtunnel_ids expected to be basetypes.ListValue, was: %T`, mxtunnelIdsAttribute))
	}

	useMxtunnelAttribute, ok := attributes["use_mxtunnel"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`use_mxtunnel is missing from object`)

		return nil, diags
	}

	useMxtunnelVal, ok := useMxtunnelAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`use_mxtunnel expected to be basetypes.BoolValue, was: %T`, useMxtunnelAttribute))
	}

	useWxtunnelAttribute, ok := attributes["use_wxtunnel"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`use_wxtunnel is missing from object`)

		return nil, diags
	}

	useWxtunnelVal, ok := useWxtunnelAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`use_wxtunnel expected to be basetypes.BoolValue, was: %T`, useWxtunnelAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return MgmtValue{
		MxtunnelIds: mxtunnelIdsVal,
		UseMxtunnel: useMxtunnelVal,
		UseWxtunnel: useWxtunnelVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewMgmtValueNull() MgmtValue {
	return MgmtValue{
		state: attr.ValueStateNull,
	}
}

func NewMgmtValueUnknown() MgmtValue {
	return MgmtValue{
		state: attr.ValueStateUnknown,
	}
}

func NewMgmtValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (MgmtValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing MgmtValue Attribute Value",
				"While creating a MgmtValue value, a missing attribute value was detected. "+
					"A MgmtValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MgmtValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid MgmtValue Attribute Type",
				"While creating a MgmtValue value, an invalid attribute value was detected. "+
					"A MgmtValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MgmtValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("MgmtValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra MgmtValue Attribute Value",
				"While creating a MgmtValue value, an extra attribute value was detected. "+
					"A MgmtValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra MgmtValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewMgmtValueUnknown(), diags
	}

	mxtunnelIdsAttribute, ok := attributes["mxtunnel_ids"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mxtunnel_ids is missing from object`)

		return NewMgmtValueUnknown(), diags
	}

	mxtunnelIdsVal, ok := mxtunnelIdsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mxtunnel_ids expected to be basetypes.ListValue, was: %T`, mxtunnelIdsAttribute))
	}

	useMxtunnelAttribute, ok := attributes["use_mxtunnel"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`use_mxtunnel is missing from object`)

		return NewMgmtValueUnknown(), diags
	}

	useMxtunnelVal, ok := useMxtunnelAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`use_mxtunnel expected to be basetypes.BoolValue, was: %T`, useMxtunnelAttribute))
	}

	useWxtunnelAttribute, ok := attributes["use_wxtunnel"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`use_wxtunnel is missing from object`)

		return NewMgmtValueUnknown(), diags
	}

	useWxtunnelVal, ok := useWxtunnelAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`use_wxtunnel expected to be basetypes.BoolValue, was: %T`, useWxtunnelAttribute))
	}

	if diags.HasError() {
		return NewMgmtValueUnknown(), diags
	}

	return MgmtValue{
		MxtunnelIds: mxtunnelIdsVal,
		UseMxtunnel: useMxtunnelVal,
		UseWxtunnel: useWxtunnelVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewMgmtValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) MgmtValue {
	object, diags := NewMgmtValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewMgmtValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t MgmtType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewMgmtValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewMgmtValueUnknown(), nil
	}

	if in.IsNull() {
		return NewMgmtValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewMgmtValueMust(MgmtValue{}.AttributeTypes(ctx), attributes), nil
}

func (t MgmtType) ValueType(ctx context.Context) attr.Value {
	return MgmtValue{}
}

var _ basetypes.ObjectValuable = MgmtValue{}

type MgmtValue struct {
	MxtunnelIds basetypes.ListValue `tfsdk:"mxtunnel_ids"`
	UseMxtunnel basetypes.BoolValue `tfsdk:"use_mxtunnel"`
	UseWxtunnel basetypes.BoolValue `tfsdk:"use_wxtunnel"`
	state       attr.ValueState
}

func (v MgmtValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["mxtunnel_ids"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["use_mxtunnel"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["use_wxtunnel"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.MxtunnelIds.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mxtunnel_ids"] = val

		val, err = v.UseMxtunnel.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["use_mxtunnel"] = val

		val, err = v.UseWxtunnel.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["use_wxtunnel"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v MgmtValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v MgmtValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v MgmtValue) String() string {
	return "MgmtValue"
}

func (v MgmtValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var mxtunnelIdsVal basetypes.ListValue
	switch {
	case v.MxtunnelIds.IsUnknown():
		mxtunnelIdsVal = types.ListUnknown(types.StringType)
	case v.MxtunnelIds.IsNull():
		mxtunnelIdsVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		mxtunnelIdsVal, d = types.ListValue(types.StringType, v.MxtunnelIds.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"mxtunnel_ids": basetypes.ListType{
				ElemType: types.StringType,
			},
			"use_mxtunnel": basetypes.BoolType{},
			"use_wxtunnel": basetypes.BoolType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"mxtunnel_ids": basetypes.ListType{
			ElemType: types.StringType,
		},
		"use_mxtunnel": basetypes.BoolType{},
		"use_wxtunnel": basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"mxtunnel_ids": mxtunnelIdsVal,
			"use_mxtunnel": v.UseMxtunnel,
			"use_wxtunnel": v.UseWxtunnel,
		})

	return objVal, diags
}

func (v MgmtValue) Equal(o attr.Value) bool {
	other, ok := o.(MgmtValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.MxtunnelIds.Equal(other.MxtunnelIds) {
		return false
	}

	if !v.UseMxtunnel.Equal(other.UseMxtunnel) {
		return false
	}

	if !v.UseWxtunnel.Equal(other.UseWxtunnel) {
		return false
	}

	return true
}

func (v MgmtValue) Type(ctx context.Context) attr.Type {
	return MgmtType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v MgmtValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"mxtunnel_ids": basetypes.ListType{
			ElemType: types.StringType,
		},
		"use_mxtunnel": basetypes.BoolType{},
		"use_wxtunnel": basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = MistNacType{}

type MistNacType struct {
	basetypes.ObjectType
}

func (t MistNacType) Equal(o attr.Type) bool {
	other, ok := o.(MistNacType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t MistNacType) String() string {
	return "MistNacType"
}

func (t MistNacType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	cacertsAttribute, ok := attributes["cacerts"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cacerts is missing from object`)

		return nil, diags
	}

	cacertsVal, ok := cacertsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cacerts expected to be basetypes.ListValue, was: %T`, cacertsAttribute))
	}

	defaultIdpIdAttribute, ok := attributes["default_idp_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`default_idp_id is missing from object`)

		return nil, diags
	}

	defaultIdpIdVal, ok := defaultIdpIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`default_idp_id expected to be basetypes.StringValue, was: %T`, defaultIdpIdAttribute))
	}

	disableRsaeAlgorithmsAttribute, ok := attributes["disable_rsae_algorithms"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disable_rsae_algorithms is missing from object`)

		return nil, diags
	}

	disableRsaeAlgorithmsVal, ok := disableRsaeAlgorithmsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disable_rsae_algorithms expected to be basetypes.BoolValue, was: %T`, disableRsaeAlgorithmsAttribute))
	}

	eapSslSecurityLevelAttribute, ok := attributes["eap_ssl_security_level"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`eap_ssl_security_level is missing from object`)

		return nil, diags
	}

	eapSslSecurityLevelVal, ok := eapSslSecurityLevelAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`eap_ssl_security_level expected to be basetypes.Int64Value, was: %T`, eapSslSecurityLevelAttribute))
	}

	euOnlyAttribute, ok := attributes["eu_only"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`eu_only is missing from object`)

		return nil, diags
	}

	euOnlyVal, ok := euOnlyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`eu_only expected to be basetypes.BoolValue, was: %T`, euOnlyAttribute))
	}

	idpMachineCertLookupFieldAttribute, ok := attributes["idp_machine_cert_lookup_field"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`idp_machine_cert_lookup_field is missing from object`)

		return nil, diags
	}

	idpMachineCertLookupFieldVal, ok := idpMachineCertLookupFieldAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`idp_machine_cert_lookup_field expected to be basetypes.StringValue, was: %T`, idpMachineCertLookupFieldAttribute))
	}

	idpUserCertLookupFieldAttribute, ok := attributes["idp_user_cert_lookup_field"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`idp_user_cert_lookup_field is missing from object`)

		return nil, diags
	}

	idpUserCertLookupFieldVal, ok := idpUserCertLookupFieldAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`idp_user_cert_lookup_field expected to be basetypes.StringValue, was: %T`, idpUserCertLookupFieldAttribute))
	}

	idpsAttribute, ok := attributes["idps"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`idps is missing from object`)

		return nil, diags
	}

	idpsVal, ok := idpsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`idps expected to be basetypes.ListValue, was: %T`, idpsAttribute))
	}

	serverCertAttribute, ok := attributes["server_cert"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`server_cert is missing from object`)

		return nil, diags
	}

	serverCertVal, ok := serverCertAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`server_cert expected to be basetypes.ObjectValue, was: %T`, serverCertAttribute))
	}

	useIpVersionAttribute, ok := attributes["use_ip_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`use_ip_version is missing from object`)

		return nil, diags
	}

	useIpVersionVal, ok := useIpVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`use_ip_version expected to be basetypes.StringValue, was: %T`, useIpVersionAttribute))
	}

	useSslPortAttribute, ok := attributes["use_ssl_port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`use_ssl_port is missing from object`)

		return nil, diags
	}

	useSslPortVal, ok := useSslPortAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`use_ssl_port expected to be basetypes.BoolValue, was: %T`, useSslPortAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return MistNacValue{
		Cacerts:                   cacertsVal,
		DefaultIdpId:              defaultIdpIdVal,
		DisableRsaeAlgorithms:     disableRsaeAlgorithmsVal,
		EapSslSecurityLevel:       eapSslSecurityLevelVal,
		EuOnly:                    euOnlyVal,
		IdpMachineCertLookupField: idpMachineCertLookupFieldVal,
		IdpUserCertLookupField:    idpUserCertLookupFieldVal,
		Idps:                      idpsVal,
		ServerCert:                serverCertVal,
		UseIpVersion:              useIpVersionVal,
		UseSslPort:                useSslPortVal,
		state:                     attr.ValueStateKnown,
	}, diags
}

func NewMistNacValueNull() MistNacValue {
	return MistNacValue{
		state: attr.ValueStateNull,
	}
}

func NewMistNacValueUnknown() MistNacValue {
	return MistNacValue{
		state: attr.ValueStateUnknown,
	}
}

func NewMistNacValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (MistNacValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing MistNacValue Attribute Value",
				"While creating a MistNacValue value, a missing attribute value was detected. "+
					"A MistNacValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MistNacValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid MistNacValue Attribute Type",
				"While creating a MistNacValue value, an invalid attribute value was detected. "+
					"A MistNacValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MistNacValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("MistNacValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra MistNacValue Attribute Value",
				"While creating a MistNacValue value, an extra attribute value was detected. "+
					"A MistNacValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra MistNacValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewMistNacValueUnknown(), diags
	}

	cacertsAttribute, ok := attributes["cacerts"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cacerts is missing from object`)

		return NewMistNacValueUnknown(), diags
	}

	cacertsVal, ok := cacertsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cacerts expected to be basetypes.ListValue, was: %T`, cacertsAttribute))
	}

	defaultIdpIdAttribute, ok := attributes["default_idp_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`default_idp_id is missing from object`)

		return NewMistNacValueUnknown(), diags
	}

	defaultIdpIdVal, ok := defaultIdpIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`default_idp_id expected to be basetypes.StringValue, was: %T`, defaultIdpIdAttribute))
	}

	disableRsaeAlgorithmsAttribute, ok := attributes["disable_rsae_algorithms"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disable_rsae_algorithms is missing from object`)

		return NewMistNacValueUnknown(), diags
	}

	disableRsaeAlgorithmsVal, ok := disableRsaeAlgorithmsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disable_rsae_algorithms expected to be basetypes.BoolValue, was: %T`, disableRsaeAlgorithmsAttribute))
	}

	eapSslSecurityLevelAttribute, ok := attributes["eap_ssl_security_level"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`eap_ssl_security_level is missing from object`)

		return NewMistNacValueUnknown(), diags
	}

	eapSslSecurityLevelVal, ok := eapSslSecurityLevelAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`eap_ssl_security_level expected to be basetypes.Int64Value, was: %T`, eapSslSecurityLevelAttribute))
	}

	euOnlyAttribute, ok := attributes["eu_only"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`eu_only is missing from object`)

		return NewMistNacValueUnknown(), diags
	}

	euOnlyVal, ok := euOnlyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`eu_only expected to be basetypes.BoolValue, was: %T`, euOnlyAttribute))
	}

	idpMachineCertLookupFieldAttribute, ok := attributes["idp_machine_cert_lookup_field"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`idp_machine_cert_lookup_field is missing from object`)

		return NewMistNacValueUnknown(), diags
	}

	idpMachineCertLookupFieldVal, ok := idpMachineCertLookupFieldAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`idp_machine_cert_lookup_field expected to be basetypes.StringValue, was: %T`, idpMachineCertLookupFieldAttribute))
	}

	idpUserCertLookupFieldAttribute, ok := attributes["idp_user_cert_lookup_field"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`idp_user_cert_lookup_field is missing from object`)

		return NewMistNacValueUnknown(), diags
	}

	idpUserCertLookupFieldVal, ok := idpUserCertLookupFieldAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`idp_user_cert_lookup_field expected to be basetypes.StringValue, was: %T`, idpUserCertLookupFieldAttribute))
	}

	idpsAttribute, ok := attributes["idps"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`idps is missing from object`)

		return NewMistNacValueUnknown(), diags
	}

	idpsVal, ok := idpsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`idps expected to be basetypes.ListValue, was: %T`, idpsAttribute))
	}

	serverCertAttribute, ok := attributes["server_cert"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`server_cert is missing from object`)

		return NewMistNacValueUnknown(), diags
	}

	serverCertVal, ok := serverCertAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`server_cert expected to be basetypes.ObjectValue, was: %T`, serverCertAttribute))
	}

	useIpVersionAttribute, ok := attributes["use_ip_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`use_ip_version is missing from object`)

		return NewMistNacValueUnknown(), diags
	}

	useIpVersionVal, ok := useIpVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`use_ip_version expected to be basetypes.StringValue, was: %T`, useIpVersionAttribute))
	}

	useSslPortAttribute, ok := attributes["use_ssl_port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`use_ssl_port is missing from object`)

		return NewMistNacValueUnknown(), diags
	}

	useSslPortVal, ok := useSslPortAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`use_ssl_port expected to be basetypes.BoolValue, was: %T`, useSslPortAttribute))
	}

	if diags.HasError() {
		return NewMistNacValueUnknown(), diags
	}

	return MistNacValue{
		Cacerts:                   cacertsVal,
		DefaultIdpId:              defaultIdpIdVal,
		DisableRsaeAlgorithms:     disableRsaeAlgorithmsVal,
		EapSslSecurityLevel:       eapSslSecurityLevelVal,
		EuOnly:                    euOnlyVal,
		IdpMachineCertLookupField: idpMachineCertLookupFieldVal,
		IdpUserCertLookupField:    idpUserCertLookupFieldVal,
		Idps:                      idpsVal,
		ServerCert:                serverCertVal,
		UseIpVersion:              useIpVersionVal,
		UseSslPort:                useSslPortVal,
		state:                     attr.ValueStateKnown,
	}, diags
}

func NewMistNacValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) MistNacValue {
	object, diags := NewMistNacValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewMistNacValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t MistNacType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewMistNacValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewMistNacValueUnknown(), nil
	}

	if in.IsNull() {
		return NewMistNacValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewMistNacValueMust(MistNacValue{}.AttributeTypes(ctx), attributes), nil
}

func (t MistNacType) ValueType(ctx context.Context) attr.Value {
	return MistNacValue{}
}

var _ basetypes.ObjectValuable = MistNacValue{}

type MistNacValue struct {
	Cacerts                   basetypes.ListValue   `tfsdk:"cacerts"`
	DefaultIdpId              basetypes.StringValue `tfsdk:"default_idp_id"`
	DisableRsaeAlgorithms     basetypes.BoolValue   `tfsdk:"disable_rsae_algorithms"`
	EapSslSecurityLevel       basetypes.Int64Value  `tfsdk:"eap_ssl_security_level"`
	EuOnly                    basetypes.BoolValue   `tfsdk:"eu_only"`
	IdpMachineCertLookupField basetypes.StringValue `tfsdk:"idp_machine_cert_lookup_field"`
	IdpUserCertLookupField    basetypes.StringValue `tfsdk:"idp_user_cert_lookup_field"`
	Idps                      basetypes.ListValue   `tfsdk:"idps"`
	ServerCert                basetypes.ObjectValue `tfsdk:"server_cert"`
	UseIpVersion              basetypes.StringValue `tfsdk:"use_ip_version"`
	UseSslPort                basetypes.BoolValue   `tfsdk:"use_ssl_port"`
	state                     attr.ValueState
}

func (v MistNacValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 11)

	var val tftypes.Value
	var err error

	attrTypes["cacerts"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["default_idp_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["disable_rsae_algorithms"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["eap_ssl_security_level"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["eu_only"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["idp_machine_cert_lookup_field"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["idp_user_cert_lookup_field"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["idps"] = basetypes.ListType{
		ElemType: IdpsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["server_cert"] = basetypes.ObjectType{
		AttrTypes: ServerCertValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["use_ip_version"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["use_ssl_port"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 11)

		val, err = v.Cacerts.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cacerts"] = val

		val, err = v.DefaultIdpId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["default_idp_id"] = val

		val, err = v.DisableRsaeAlgorithms.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["disable_rsae_algorithms"] = val

		val, err = v.EapSslSecurityLevel.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["eap_ssl_security_level"] = val

		val, err = v.EuOnly.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["eu_only"] = val

		val, err = v.IdpMachineCertLookupField.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["idp_machine_cert_lookup_field"] = val

		val, err = v.IdpUserCertLookupField.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["idp_user_cert_lookup_field"] = val

		val, err = v.Idps.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["idps"] = val

		val, err = v.ServerCert.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["server_cert"] = val

		val, err = v.UseIpVersion.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["use_ip_version"] = val

		val, err = v.UseSslPort.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["use_ssl_port"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v MistNacValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v MistNacValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v MistNacValue) String() string {
	return "MistNacValue"
}

func (v MistNacValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	idps := types.ListValueMust(
		IdpsType{
			basetypes.ObjectType{
				AttrTypes: IdpsValue{}.AttributeTypes(ctx),
			},
		},
		v.Idps.Elements(),
	)

	if v.Idps.IsNull() {
		idps = types.ListNull(
			IdpsType{
				basetypes.ObjectType{
					AttrTypes: IdpsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Idps.IsUnknown() {
		idps = types.ListUnknown(
			IdpsType{
				basetypes.ObjectType{
					AttrTypes: IdpsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var serverCert basetypes.ObjectValue

	if v.ServerCert.IsNull() {
		serverCert = types.ObjectNull(
			ServerCertValue{}.AttributeTypes(ctx),
		)
	}

	if v.ServerCert.IsUnknown() {
		serverCert = types.ObjectUnknown(
			ServerCertValue{}.AttributeTypes(ctx),
		)
	}

	if !v.ServerCert.IsNull() && !v.ServerCert.IsUnknown() {
		serverCert = types.ObjectValueMust(
			ServerCertValue{}.AttributeTypes(ctx),
			v.ServerCert.Attributes(),
		)
	}

	var cacertsVal basetypes.ListValue
	switch {
	case v.Cacerts.IsUnknown():
		cacertsVal = types.ListUnknown(types.StringType)
	case v.Cacerts.IsNull():
		cacertsVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		cacertsVal, d = types.ListValue(types.StringType, v.Cacerts.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"cacerts": basetypes.ListType{
				ElemType: types.StringType,
			},
			"default_idp_id":                basetypes.StringType{},
			"disable_rsae_algorithms":       basetypes.BoolType{},
			"eap_ssl_security_level":        basetypes.Int64Type{},
			"eu_only":                       basetypes.BoolType{},
			"idp_machine_cert_lookup_field": basetypes.StringType{},
			"idp_user_cert_lookup_field":    basetypes.StringType{},
			"idps": basetypes.ListType{
				ElemType: IdpsValue{}.Type(ctx),
			},
			"server_cert": basetypes.ObjectType{
				AttrTypes: ServerCertValue{}.AttributeTypes(ctx),
			},
			"use_ip_version": basetypes.StringType{},
			"use_ssl_port":   basetypes.BoolType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"cacerts": basetypes.ListType{
			ElemType: types.StringType,
		},
		"default_idp_id":                basetypes.StringType{},
		"disable_rsae_algorithms":       basetypes.BoolType{},
		"eap_ssl_security_level":        basetypes.Int64Type{},
		"eu_only":                       basetypes.BoolType{},
		"idp_machine_cert_lookup_field": basetypes.StringType{},
		"idp_user_cert_lookup_field":    basetypes.StringType{},
		"idps": basetypes.ListType{
			ElemType: IdpsValue{}.Type(ctx),
		},
		"server_cert": basetypes.ObjectType{
			AttrTypes: ServerCertValue{}.AttributeTypes(ctx),
		},
		"use_ip_version": basetypes.StringType{},
		"use_ssl_port":   basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"cacerts":                       cacertsVal,
			"default_idp_id":                v.DefaultIdpId,
			"disable_rsae_algorithms":       v.DisableRsaeAlgorithms,
			"eap_ssl_security_level":        v.EapSslSecurityLevel,
			"eu_only":                       v.EuOnly,
			"idp_machine_cert_lookup_field": v.IdpMachineCertLookupField,
			"idp_user_cert_lookup_field":    v.IdpUserCertLookupField,
			"idps":                          idps,
			"server_cert":                   serverCert,
			"use_ip_version":                v.UseIpVersion,
			"use_ssl_port":                  v.UseSslPort,
		})

	return objVal, diags
}

func (v MistNacValue) Equal(o attr.Value) bool {
	other, ok := o.(MistNacValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Cacerts.Equal(other.Cacerts) {
		return false
	}

	if !v.DefaultIdpId.Equal(other.DefaultIdpId) {
		return false
	}

	if !v.DisableRsaeAlgorithms.Equal(other.DisableRsaeAlgorithms) {
		return false
	}

	if !v.EapSslSecurityLevel.Equal(other.EapSslSecurityLevel) {
		return false
	}

	if !v.EuOnly.Equal(other.EuOnly) {
		return false
	}

	if !v.IdpMachineCertLookupField.Equal(other.IdpMachineCertLookupField) {
		return false
	}

	if !v.IdpUserCertLookupField.Equal(other.IdpUserCertLookupField) {
		return false
	}

	if !v.Idps.Equal(other.Idps) {
		return false
	}

	if !v.ServerCert.Equal(other.ServerCert) {
		return false
	}

	if !v.UseIpVersion.Equal(other.UseIpVersion) {
		return false
	}

	if !v.UseSslPort.Equal(other.UseSslPort) {
		return false
	}

	return true
}

func (v MistNacValue) Type(ctx context.Context) attr.Type {
	return MistNacType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v MistNacValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"cacerts": basetypes.ListType{
			ElemType: types.StringType,
		},
		"default_idp_id":                basetypes.StringType{},
		"disable_rsae_algorithms":       basetypes.BoolType{},
		"eap_ssl_security_level":        basetypes.Int64Type{},
		"eu_only":                       basetypes.BoolType{},
		"idp_machine_cert_lookup_field": basetypes.StringType{},
		"idp_user_cert_lookup_field":    basetypes.StringType{},
		"idps": basetypes.ListType{
			ElemType: IdpsValue{}.Type(ctx),
		},
		"server_cert": basetypes.ObjectType{
			AttrTypes: ServerCertValue{}.AttributeTypes(ctx),
		},
		"use_ip_version": basetypes.StringType{},
		"use_ssl_port":   basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = IdpsType{}

type IdpsType struct {
	basetypes.ObjectType
}

func (t IdpsType) Equal(o attr.Type) bool {
	other, ok := o.(IdpsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t IdpsType) String() string {
	return "IdpsType"
}

func (t IdpsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	excludeRealmsAttribute, ok := attributes["exclude_realms"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`exclude_realms is missing from object`)

		return nil, diags
	}

	excludeRealmsVal, ok := excludeRealmsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`exclude_realms expected to be basetypes.ListValue, was: %T`, excludeRealmsAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	userRealmsAttribute, ok := attributes["user_realms"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`user_realms is missing from object`)

		return nil, diags
	}

	userRealmsVal, ok := userRealmsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`user_realms expected to be basetypes.ListValue, was: %T`, userRealmsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return IdpsValue{
		ExcludeRealms: excludeRealmsVal,
		Id:            idVal,
		UserRealms:    userRealmsVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewIdpsValueNull() IdpsValue {
	return IdpsValue{
		state: attr.ValueStateNull,
	}
}

func NewIdpsValueUnknown() IdpsValue {
	return IdpsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewIdpsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (IdpsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing IdpsValue Attribute Value",
				"While creating a IdpsValue value, a missing attribute value was detected. "+
					"A IdpsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("IdpsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid IdpsValue Attribute Type",
				"While creating a IdpsValue value, an invalid attribute value was detected. "+
					"A IdpsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("IdpsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("IdpsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra IdpsValue Attribute Value",
				"While creating a IdpsValue value, an extra attribute value was detected. "+
					"A IdpsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra IdpsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewIdpsValueUnknown(), diags
	}

	excludeRealmsAttribute, ok := attributes["exclude_realms"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`exclude_realms is missing from object`)

		return NewIdpsValueUnknown(), diags
	}

	excludeRealmsVal, ok := excludeRealmsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`exclude_realms expected to be basetypes.ListValue, was: %T`, excludeRealmsAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewIdpsValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	userRealmsAttribute, ok := attributes["user_realms"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`user_realms is missing from object`)

		return NewIdpsValueUnknown(), diags
	}

	userRealmsVal, ok := userRealmsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`user_realms expected to be basetypes.ListValue, was: %T`, userRealmsAttribute))
	}

	if diags.HasError() {
		return NewIdpsValueUnknown(), diags
	}

	return IdpsValue{
		ExcludeRealms: excludeRealmsVal,
		Id:            idVal,
		UserRealms:    userRealmsVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewIdpsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) IdpsValue {
	object, diags := NewIdpsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewIdpsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t IdpsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewIdpsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewIdpsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewIdpsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewIdpsValueMust(IdpsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t IdpsType) ValueType(ctx context.Context) attr.Value {
	return IdpsValue{}
}

var _ basetypes.ObjectValuable = IdpsValue{}

type IdpsValue struct {
	ExcludeRealms basetypes.ListValue   `tfsdk:"exclude_realms"`
	Id            basetypes.StringValue `tfsdk:"id"`
	UserRealms    basetypes.ListValue   `tfsdk:"user_realms"`
	state         attr.ValueState
}

func (v IdpsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["exclude_realms"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["user_realms"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.ExcludeRealms.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["exclude_realms"] = val

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.UserRealms.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["user_realms"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v IdpsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v IdpsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v IdpsValue) String() string {
	return "IdpsValue"
}

func (v IdpsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var excludeRealmsVal basetypes.ListValue
	switch {
	case v.ExcludeRealms.IsUnknown():
		excludeRealmsVal = types.ListUnknown(types.StringType)
	case v.ExcludeRealms.IsNull():
		excludeRealmsVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		excludeRealmsVal, d = types.ListValue(types.StringType, v.ExcludeRealms.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"exclude_realms": basetypes.ListType{
				ElemType: types.StringType,
			},
			"id": basetypes.StringType{},
			"user_realms": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	var userRealmsVal basetypes.ListValue
	switch {
	case v.UserRealms.IsUnknown():
		userRealmsVal = types.ListUnknown(types.StringType)
	case v.UserRealms.IsNull():
		userRealmsVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		userRealmsVal, d = types.ListValue(types.StringType, v.UserRealms.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"exclude_realms": basetypes.ListType{
				ElemType: types.StringType,
			},
			"id": basetypes.StringType{},
			"user_realms": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"exclude_realms": basetypes.ListType{
			ElemType: types.StringType,
		},
		"id": basetypes.StringType{},
		"user_realms": basetypes.ListType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"exclude_realms": excludeRealmsVal,
			"id":             v.Id,
			"user_realms":    userRealmsVal,
		})

	return objVal, diags
}

func (v IdpsValue) Equal(o attr.Value) bool {
	other, ok := o.(IdpsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.ExcludeRealms.Equal(other.ExcludeRealms) {
		return false
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.UserRealms.Equal(other.UserRealms) {
		return false
	}

	return true
}

func (v IdpsValue) Type(ctx context.Context) attr.Type {
	return IdpsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v IdpsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"exclude_realms": basetypes.ListType{
			ElemType: types.StringType,
		},
		"id": basetypes.StringType{},
		"user_realms": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = ServerCertType{}

type ServerCertType struct {
	basetypes.ObjectType
}

func (t ServerCertType) Equal(o attr.Type) bool {
	other, ok := o.(ServerCertType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ServerCertType) String() string {
	return "ServerCertType"
}

func (t ServerCertType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	certAttribute, ok := attributes["cert"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cert is missing from object`)

		return nil, diags
	}

	certVal, ok := certAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cert expected to be basetypes.StringValue, was: %T`, certAttribute))
	}

	keyAttribute, ok := attributes["key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`key is missing from object`)

		return nil, diags
	}

	keyVal, ok := keyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`key expected to be basetypes.StringValue, was: %T`, keyAttribute))
	}

	passwordAttribute, ok := attributes["password"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`password is missing from object`)

		return nil, diags
	}

	passwordVal, ok := passwordAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`password expected to be basetypes.StringValue, was: %T`, passwordAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ServerCertValue{
		Cert:     certVal,
		Key:      keyVal,
		Password: passwordVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewServerCertValueNull() ServerCertValue {
	return ServerCertValue{
		state: attr.ValueStateNull,
	}
}

func NewServerCertValueUnknown() ServerCertValue {
	return ServerCertValue{
		state: attr.ValueStateUnknown,
	}
}

func NewServerCertValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ServerCertValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ServerCertValue Attribute Value",
				"While creating a ServerCertValue value, a missing attribute value was detected. "+
					"A ServerCertValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ServerCertValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ServerCertValue Attribute Type",
				"While creating a ServerCertValue value, an invalid attribute value was detected. "+
					"A ServerCertValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ServerCertValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ServerCertValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ServerCertValue Attribute Value",
				"While creating a ServerCertValue value, an extra attribute value was detected. "+
					"A ServerCertValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ServerCertValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewServerCertValueUnknown(), diags
	}

	certAttribute, ok := attributes["cert"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cert is missing from object`)

		return NewServerCertValueUnknown(), diags
	}

	certVal, ok := certAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cert expected to be basetypes.StringValue, was: %T`, certAttribute))
	}

	keyAttribute, ok := attributes["key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`key is missing from object`)

		return NewServerCertValueUnknown(), diags
	}

	keyVal, ok := keyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`key expected to be basetypes.StringValue, was: %T`, keyAttribute))
	}

	passwordAttribute, ok := attributes["password"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`password is missing from object`)

		return NewServerCertValueUnknown(), diags
	}

	passwordVal, ok := passwordAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`password expected to be basetypes.StringValue, was: %T`, passwordAttribute))
	}

	if diags.HasError() {
		return NewServerCertValueUnknown(), diags
	}

	return ServerCertValue{
		Cert:     certVal,
		Key:      keyVal,
		Password: passwordVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewServerCertValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ServerCertValue {
	object, diags := NewServerCertValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewServerCertValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ServerCertType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewServerCertValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewServerCertValueUnknown(), nil
	}

	if in.IsNull() {
		return NewServerCertValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewServerCertValueMust(ServerCertValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ServerCertType) ValueType(ctx context.Context) attr.Value {
	return ServerCertValue{}
}

var _ basetypes.ObjectValuable = ServerCertValue{}

type ServerCertValue struct {
	Cert     basetypes.StringValue `tfsdk:"cert"`
	Key      basetypes.StringValue `tfsdk:"key"`
	Password basetypes.StringValue `tfsdk:"password"`
	state    attr.ValueState
}

func (v ServerCertValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["cert"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["key"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["password"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Cert.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cert"] = val

		val, err = v.Key.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["key"] = val

		val, err = v.Password.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["password"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ServerCertValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ServerCertValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ServerCertValue) String() string {
	return "ServerCertValue"
}

func (v ServerCertValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"cert":     basetypes.StringType{},
		"key":      basetypes.StringType{},
		"password": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"cert":     v.Cert,
			"key":      v.Key,
			"password": v.Password,
		})

	return objVal, diags
}

func (v ServerCertValue) Equal(o attr.Value) bool {
	other, ok := o.(ServerCertValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Cert.Equal(other.Cert) {
		return false
	}

	if !v.Key.Equal(other.Key) {
		return false
	}

	if !v.Password.Equal(other.Password) {
		return false
	}

	return true
}

func (v ServerCertValue) Type(ctx context.Context) attr.Type {
	return ServerCertType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ServerCertValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"cert":     basetypes.StringType{},
		"key":      basetypes.StringType{},
		"password": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = MxedgeMgmtType{}

type MxedgeMgmtType struct {
	basetypes.ObjectType
}

func (t MxedgeMgmtType) Equal(o attr.Type) bool {
	other, ok := o.(MxedgeMgmtType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t MxedgeMgmtType) String() string {
	return "MxedgeMgmtType"
}

func (t MxedgeMgmtType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	configAutoRevertAttribute, ok := attributes["config_auto_revert"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`config_auto_revert is missing from object`)

		return nil, diags
	}

	configAutoRevertVal, ok := configAutoRevertAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`config_auto_revert expected to be basetypes.BoolValue, was: %T`, configAutoRevertAttribute))
	}

	fipsEnabledAttribute, ok := attributes["fips_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fips_enabled is missing from object`)

		return nil, diags
	}

	fipsEnabledVal, ok := fipsEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fips_enabled expected to be basetypes.BoolValue, was: %T`, fipsEnabledAttribute))
	}

	mistPasswordAttribute, ok := attributes["mist_password"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mist_password is missing from object`)

		return nil, diags
	}

	mistPasswordVal, ok := mistPasswordAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mist_password expected to be basetypes.StringValue, was: %T`, mistPasswordAttribute))
	}

	oobIpTypeAttribute, ok := attributes["oob_ip_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`oob_ip_type is missing from object`)

		return nil, diags
	}

	oobIpTypeVal, ok := oobIpTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`oob_ip_type expected to be basetypes.StringValue, was: %T`, oobIpTypeAttribute))
	}

	oobIpType6Attribute, ok := attributes["oob_ip_type6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`oob_ip_type6 is missing from object`)

		return nil, diags
	}

	oobIpType6Val, ok := oobIpType6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`oob_ip_type6 expected to be basetypes.StringValue, was: %T`, oobIpType6Attribute))
	}

	rootPasswordAttribute, ok := attributes["root_password"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`root_password is missing from object`)

		return nil, diags
	}

	rootPasswordVal, ok := rootPasswordAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`root_password expected to be basetypes.StringValue, was: %T`, rootPasswordAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return MxedgeMgmtValue{
		ConfigAutoRevert: configAutoRevertVal,
		FipsEnabled:      fipsEnabledVal,
		MistPassword:     mistPasswordVal,
		OobIpType:        oobIpTypeVal,
		OobIpType6:       oobIpType6Val,
		RootPassword:     rootPasswordVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewMxedgeMgmtValueNull() MxedgeMgmtValue {
	return MxedgeMgmtValue{
		state: attr.ValueStateNull,
	}
}

func NewMxedgeMgmtValueUnknown() MxedgeMgmtValue {
	return MxedgeMgmtValue{
		state: attr.ValueStateUnknown,
	}
}

func NewMxedgeMgmtValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (MxedgeMgmtValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing MxedgeMgmtValue Attribute Value",
				"While creating a MxedgeMgmtValue value, a missing attribute value was detected. "+
					"A MxedgeMgmtValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MxedgeMgmtValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid MxedgeMgmtValue Attribute Type",
				"While creating a MxedgeMgmtValue value, an invalid attribute value was detected. "+
					"A MxedgeMgmtValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MxedgeMgmtValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("MxedgeMgmtValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra MxedgeMgmtValue Attribute Value",
				"While creating a MxedgeMgmtValue value, an extra attribute value was detected. "+
					"A MxedgeMgmtValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra MxedgeMgmtValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewMxedgeMgmtValueUnknown(), diags
	}

	configAutoRevertAttribute, ok := attributes["config_auto_revert"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`config_auto_revert is missing from object`)

		return NewMxedgeMgmtValueUnknown(), diags
	}

	configAutoRevertVal, ok := configAutoRevertAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`config_auto_revert expected to be basetypes.BoolValue, was: %T`, configAutoRevertAttribute))
	}

	fipsEnabledAttribute, ok := attributes["fips_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fips_enabled is missing from object`)

		return NewMxedgeMgmtValueUnknown(), diags
	}

	fipsEnabledVal, ok := fipsEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fips_enabled expected to be basetypes.BoolValue, was: %T`, fipsEnabledAttribute))
	}

	mistPasswordAttribute, ok := attributes["mist_password"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mist_password is missing from object`)

		return NewMxedgeMgmtValueUnknown(), diags
	}

	mistPasswordVal, ok := mistPasswordAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mist_password expected to be basetypes.StringValue, was: %T`, mistPasswordAttribute))
	}

	oobIpTypeAttribute, ok := attributes["oob_ip_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`oob_ip_type is missing from object`)

		return NewMxedgeMgmtValueUnknown(), diags
	}

	oobIpTypeVal, ok := oobIpTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`oob_ip_type expected to be basetypes.StringValue, was: %T`, oobIpTypeAttribute))
	}

	oobIpType6Attribute, ok := attributes["oob_ip_type6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`oob_ip_type6 is missing from object`)

		return NewMxedgeMgmtValueUnknown(), diags
	}

	oobIpType6Val, ok := oobIpType6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`oob_ip_type6 expected to be basetypes.StringValue, was: %T`, oobIpType6Attribute))
	}

	rootPasswordAttribute, ok := attributes["root_password"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`root_password is missing from object`)

		return NewMxedgeMgmtValueUnknown(), diags
	}

	rootPasswordVal, ok := rootPasswordAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`root_password expected to be basetypes.StringValue, was: %T`, rootPasswordAttribute))
	}

	if diags.HasError() {
		return NewMxedgeMgmtValueUnknown(), diags
	}

	return MxedgeMgmtValue{
		ConfigAutoRevert: configAutoRevertVal,
		FipsEnabled:      fipsEnabledVal,
		MistPassword:     mistPasswordVal,
		OobIpType:        oobIpTypeVal,
		OobIpType6:       oobIpType6Val,
		RootPassword:     rootPasswordVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewMxedgeMgmtValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) MxedgeMgmtValue {
	object, diags := NewMxedgeMgmtValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewMxedgeMgmtValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t MxedgeMgmtType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewMxedgeMgmtValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewMxedgeMgmtValueUnknown(), nil
	}

	if in.IsNull() {
		return NewMxedgeMgmtValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewMxedgeMgmtValueMust(MxedgeMgmtValue{}.AttributeTypes(ctx), attributes), nil
}

func (t MxedgeMgmtType) ValueType(ctx context.Context) attr.Value {
	return MxedgeMgmtValue{}
}

var _ basetypes.ObjectValuable = MxedgeMgmtValue{}

type MxedgeMgmtValue struct {
	ConfigAutoRevert basetypes.BoolValue   `tfsdk:"config_auto_revert"`
	FipsEnabled      basetypes.BoolValue   `tfsdk:"fips_enabled"`
	MistPassword     basetypes.StringValue `tfsdk:"mist_password"`
	OobIpType        basetypes.StringValue `tfsdk:"oob_ip_type"`
	OobIpType6       basetypes.StringValue `tfsdk:"oob_ip_type6"`
	RootPassword     basetypes.StringValue `tfsdk:"root_password"`
	state            attr.ValueState
}

func (v MxedgeMgmtValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 6)

	var val tftypes.Value
	var err error

	attrTypes["config_auto_revert"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["fips_enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["mist_password"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["oob_ip_type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["oob_ip_type6"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["root_password"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 6)

		val, err = v.ConfigAutoRevert.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["config_auto_revert"] = val

		val, err = v.FipsEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["fips_enabled"] = val

		val, err = v.MistPassword.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mist_password"] = val

		val, err = v.OobIpType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["oob_ip_type"] = val

		val, err = v.OobIpType6.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["oob_ip_type6"] = val

		val, err = v.RootPassword.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["root_password"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v MxedgeMgmtValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v MxedgeMgmtValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v MxedgeMgmtValue) String() string {
	return "MxedgeMgmtValue"
}

func (v MxedgeMgmtValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"config_auto_revert": basetypes.BoolType{},
		"fips_enabled":       basetypes.BoolType{},
		"mist_password":      basetypes.StringType{},
		"oob_ip_type":        basetypes.StringType{},
		"oob_ip_type6":       basetypes.StringType{},
		"root_password":      basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"config_auto_revert": v.ConfigAutoRevert,
			"fips_enabled":       v.FipsEnabled,
			"mist_password":      v.MistPassword,
			"oob_ip_type":        v.OobIpType,
			"oob_ip_type6":       v.OobIpType6,
			"root_password":      v.RootPassword,
		})

	return objVal, diags
}

func (v MxedgeMgmtValue) Equal(o attr.Value) bool {
	other, ok := o.(MxedgeMgmtValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.ConfigAutoRevert.Equal(other.ConfigAutoRevert) {
		return false
	}

	if !v.FipsEnabled.Equal(other.FipsEnabled) {
		return false
	}

	if !v.MistPassword.Equal(other.MistPassword) {
		return false
	}

	if !v.OobIpType.Equal(other.OobIpType) {
		return false
	}

	if !v.OobIpType6.Equal(other.OobIpType6) {
		return false
	}

	if !v.RootPassword.Equal(other.RootPassword) {
		return false
	}

	return true
}

func (v MxedgeMgmtValue) Type(ctx context.Context) attr.Type {
	return MxedgeMgmtType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v MxedgeMgmtValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"config_auto_revert": basetypes.BoolType{},
		"fips_enabled":       basetypes.BoolType{},
		"mist_password":      basetypes.StringType{},
		"oob_ip_type":        basetypes.StringType{},
		"oob_ip_type6":       basetypes.StringType{},
		"root_password":      basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = OpticPortConfigType{}

type OpticPortConfigType struct {
	basetypes.ObjectType
}

func (t OpticPortConfigType) Equal(o attr.Type) bool {
	other, ok := o.(OpticPortConfigType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t OpticPortConfigType) String() string {
	return "OpticPortConfigType"
}

func (t OpticPortConfigType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	channelizedAttribute, ok := attributes["channelized"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`channelized is missing from object`)

		return nil, diags
	}

	channelizedVal, ok := channelizedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`channelized expected to be basetypes.BoolValue, was: %T`, channelizedAttribute))
	}

	speedAttribute, ok := attributes["speed"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`speed is missing from object`)

		return nil, diags
	}

	speedVal, ok := speedAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`speed expected to be basetypes.StringValue, was: %T`, speedAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return OpticPortConfigValue{
		Channelized: channelizedVal,
		Speed:       speedVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewOpticPortConfigValueNull() OpticPortConfigValue {
	return OpticPortConfigValue{
		state: attr.ValueStateNull,
	}
}

func NewOpticPortConfigValueUnknown() OpticPortConfigValue {
	return OpticPortConfigValue{
		state: attr.ValueStateUnknown,
	}
}

func NewOpticPortConfigValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (OpticPortConfigValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing OpticPortConfigValue Attribute Value",
				"While creating a OpticPortConfigValue value, a missing attribute value was detected. "+
					"A OpticPortConfigValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OpticPortConfigValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid OpticPortConfigValue Attribute Type",
				"While creating a OpticPortConfigValue value, an invalid attribute value was detected. "+
					"A OpticPortConfigValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OpticPortConfigValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("OpticPortConfigValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra OpticPortConfigValue Attribute Value",
				"While creating a OpticPortConfigValue value, an extra attribute value was detected. "+
					"A OpticPortConfigValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra OpticPortConfigValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewOpticPortConfigValueUnknown(), diags
	}

	channelizedAttribute, ok := attributes["channelized"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`channelized is missing from object`)

		return NewOpticPortConfigValueUnknown(), diags
	}

	channelizedVal, ok := channelizedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`channelized expected to be basetypes.BoolValue, was: %T`, channelizedAttribute))
	}

	speedAttribute, ok := attributes["speed"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`speed is missing from object`)

		return NewOpticPortConfigValueUnknown(), diags
	}

	speedVal, ok := speedAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`speed expected to be basetypes.StringValue, was: %T`, speedAttribute))
	}

	if diags.HasError() {
		return NewOpticPortConfigValueUnknown(), diags
	}

	return OpticPortConfigValue{
		Channelized: channelizedVal,
		Speed:       speedVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewOpticPortConfigValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) OpticPortConfigValue {
	object, diags := NewOpticPortConfigValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewOpticPortConfigValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t OpticPortConfigType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewOpticPortConfigValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewOpticPortConfigValueUnknown(), nil
	}

	if in.IsNull() {
		return NewOpticPortConfigValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewOpticPortConfigValueMust(OpticPortConfigValue{}.AttributeTypes(ctx), attributes), nil
}

func (t OpticPortConfigType) ValueType(ctx context.Context) attr.Value {
	return OpticPortConfigValue{}
}

var _ basetypes.ObjectValuable = OpticPortConfigValue{}

type OpticPortConfigValue struct {
	Channelized basetypes.BoolValue   `tfsdk:"channelized"`
	Speed       basetypes.StringValue `tfsdk:"speed"`
	state       attr.ValueState
}

func (v OpticPortConfigValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["channelized"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["speed"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Channelized.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["channelized"] = val

		val, err = v.Speed.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["speed"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v OpticPortConfigValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v OpticPortConfigValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v OpticPortConfigValue) String() string {
	return "OpticPortConfigValue"
}

func (v OpticPortConfigValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"channelized": basetypes.BoolType{},
		"speed":       basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"channelized": v.Channelized,
			"speed":       v.Speed,
		})

	return objVal, diags
}

func (v OpticPortConfigValue) Equal(o attr.Value) bool {
	other, ok := o.(OpticPortConfigValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Channelized.Equal(other.Channelized) {
		return false
	}

	if !v.Speed.Equal(other.Speed) {
		return false
	}

	return true
}

func (v OpticPortConfigValue) Type(ctx context.Context) attr.Type {
	return OpticPortConfigType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v OpticPortConfigValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"channelized": basetypes.BoolType{},
		"speed":       basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = PasswordPolicyType{}

type PasswordPolicyType struct {
	basetypes.ObjectType
}

func (t PasswordPolicyType) Equal(o attr.Type) bool {
	other, ok := o.(PasswordPolicyType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PasswordPolicyType) String() string {
	return "PasswordPolicyType"
}

func (t PasswordPolicyType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	expiryInDaysAttribute, ok := attributes["expiry_in_days"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`expiry_in_days is missing from object`)

		return nil, diags
	}

	expiryInDaysVal, ok := expiryInDaysAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`expiry_in_days expected to be basetypes.Int64Value, was: %T`, expiryInDaysAttribute))
	}

	minLengthAttribute, ok := attributes["min_length"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`min_length is missing from object`)

		return nil, diags
	}

	minLengthVal, ok := minLengthAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`min_length expected to be basetypes.Int64Value, was: %T`, minLengthAttribute))
	}

	requiresSpecialCharAttribute, ok := attributes["requires_special_char"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`requires_special_char is missing from object`)

		return nil, diags
	}

	requiresSpecialCharVal, ok := requiresSpecialCharAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`requires_special_char expected to be basetypes.BoolValue, was: %T`, requiresSpecialCharAttribute))
	}

	requiresTwoFactorAuthAttribute, ok := attributes["requires_two_factor_auth"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`requires_two_factor_auth is missing from object`)

		return nil, diags
	}

	requiresTwoFactorAuthVal, ok := requiresTwoFactorAuthAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`requires_two_factor_auth expected to be basetypes.BoolValue, was: %T`, requiresTwoFactorAuthAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PasswordPolicyValue{
		Enabled:               enabledVal,
		ExpiryInDays:          expiryInDaysVal,
		MinLength:             minLengthVal,
		RequiresSpecialChar:   requiresSpecialCharVal,
		RequiresTwoFactorAuth: requiresTwoFactorAuthVal,
		state:                 attr.ValueStateKnown,
	}, diags
}

func NewPasswordPolicyValueNull() PasswordPolicyValue {
	return PasswordPolicyValue{
		state: attr.ValueStateNull,
	}
}

func NewPasswordPolicyValueUnknown() PasswordPolicyValue {
	return PasswordPolicyValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPasswordPolicyValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PasswordPolicyValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PasswordPolicyValue Attribute Value",
				"While creating a PasswordPolicyValue value, a missing attribute value was detected. "+
					"A PasswordPolicyValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PasswordPolicyValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PasswordPolicyValue Attribute Type",
				"While creating a PasswordPolicyValue value, an invalid attribute value was detected. "+
					"A PasswordPolicyValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PasswordPolicyValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PasswordPolicyValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PasswordPolicyValue Attribute Value",
				"While creating a PasswordPolicyValue value, an extra attribute value was detected. "+
					"A PasswordPolicyValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PasswordPolicyValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPasswordPolicyValueUnknown(), diags
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewPasswordPolicyValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	expiryInDaysAttribute, ok := attributes["expiry_in_days"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`expiry_in_days is missing from object`)

		return NewPasswordPolicyValueUnknown(), diags
	}

	expiryInDaysVal, ok := expiryInDaysAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`expiry_in_days expected to be basetypes.Int64Value, was: %T`, expiryInDaysAttribute))
	}

	minLengthAttribute, ok := attributes["min_length"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`min_length is missing from object`)

		return NewPasswordPolicyValueUnknown(), diags
	}

	minLengthVal, ok := minLengthAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`min_length expected to be basetypes.Int64Value, was: %T`, minLengthAttribute))
	}

	requiresSpecialCharAttribute, ok := attributes["requires_special_char"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`requires_special_char is missing from object`)

		return NewPasswordPolicyValueUnknown(), diags
	}

	requiresSpecialCharVal, ok := requiresSpecialCharAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`requires_special_char expected to be basetypes.BoolValue, was: %T`, requiresSpecialCharAttribute))
	}

	requiresTwoFactorAuthAttribute, ok := attributes["requires_two_factor_auth"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`requires_two_factor_auth is missing from object`)

		return NewPasswordPolicyValueUnknown(), diags
	}

	requiresTwoFactorAuthVal, ok := requiresTwoFactorAuthAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`requires_two_factor_auth expected to be basetypes.BoolValue, was: %T`, requiresTwoFactorAuthAttribute))
	}

	if diags.HasError() {
		return NewPasswordPolicyValueUnknown(), diags
	}

	return PasswordPolicyValue{
		Enabled:               enabledVal,
		ExpiryInDays:          expiryInDaysVal,
		MinLength:             minLengthVal,
		RequiresSpecialChar:   requiresSpecialCharVal,
		RequiresTwoFactorAuth: requiresTwoFactorAuthVal,
		state:                 attr.ValueStateKnown,
	}, diags
}

func NewPasswordPolicyValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PasswordPolicyValue {
	object, diags := NewPasswordPolicyValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPasswordPolicyValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PasswordPolicyType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPasswordPolicyValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPasswordPolicyValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPasswordPolicyValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPasswordPolicyValueMust(PasswordPolicyValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PasswordPolicyType) ValueType(ctx context.Context) attr.Value {
	return PasswordPolicyValue{}
}

var _ basetypes.ObjectValuable = PasswordPolicyValue{}

type PasswordPolicyValue struct {
	Enabled               basetypes.BoolValue  `tfsdk:"enabled"`
	ExpiryInDays          basetypes.Int64Value `tfsdk:"expiry_in_days"`
	MinLength             basetypes.Int64Value `tfsdk:"min_length"`
	RequiresSpecialChar   basetypes.BoolValue  `tfsdk:"requires_special_char"`
	RequiresTwoFactorAuth basetypes.BoolValue  `tfsdk:"requires_two_factor_auth"`
	state                 attr.ValueState
}

func (v PasswordPolicyValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["expiry_in_days"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["min_length"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["requires_special_char"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["requires_two_factor_auth"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.ExpiryInDays.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["expiry_in_days"] = val

		val, err = v.MinLength.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["min_length"] = val

		val, err = v.RequiresSpecialChar.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["requires_special_char"] = val

		val, err = v.RequiresTwoFactorAuth.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["requires_two_factor_auth"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PasswordPolicyValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PasswordPolicyValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PasswordPolicyValue) String() string {
	return "PasswordPolicyValue"
}

func (v PasswordPolicyValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"enabled":                  basetypes.BoolType{},
		"expiry_in_days":           basetypes.Int64Type{},
		"min_length":               basetypes.Int64Type{},
		"requires_special_char":    basetypes.BoolType{},
		"requires_two_factor_auth": basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"enabled":                  v.Enabled,
			"expiry_in_days":           v.ExpiryInDays,
			"min_length":               v.MinLength,
			"requires_special_char":    v.RequiresSpecialChar,
			"requires_two_factor_auth": v.RequiresTwoFactorAuth,
		})

	return objVal, diags
}

func (v PasswordPolicyValue) Equal(o attr.Value) bool {
	other, ok := o.(PasswordPolicyValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.ExpiryInDays.Equal(other.ExpiryInDays) {
		return false
	}

	if !v.MinLength.Equal(other.MinLength) {
		return false
	}

	if !v.RequiresSpecialChar.Equal(other.RequiresSpecialChar) {
		return false
	}

	if !v.RequiresTwoFactorAuth.Equal(other.RequiresTwoFactorAuth) {
		return false
	}

	return true
}

func (v PasswordPolicyValue) Type(ctx context.Context) attr.Type {
	return PasswordPolicyType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PasswordPolicyValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"enabled":                  basetypes.BoolType{},
		"expiry_in_days":           basetypes.Int64Type{},
		"min_length":               basetypes.Int64Type{},
		"requires_special_char":    basetypes.BoolType{},
		"requires_two_factor_auth": basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = PcapType{}

type PcapType struct {
	basetypes.ObjectType
}

func (t PcapType) Equal(o attr.Type) bool {
	other, ok := o.(PcapType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PcapType) String() string {
	return "PcapType"
}

func (t PcapType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	bucketAttribute, ok := attributes["bucket"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bucket is missing from object`)

		return nil, diags
	}

	bucketVal, ok := bucketAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bucket expected to be basetypes.StringValue, was: %T`, bucketAttribute))
	}

	maxPktLenAttribute, ok := attributes["max_pkt_len"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_pkt_len is missing from object`)

		return nil, diags
	}

	maxPktLenVal, ok := maxPktLenAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_pkt_len expected to be basetypes.Int64Value, was: %T`, maxPktLenAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PcapValue{
		Bucket:    bucketVal,
		MaxPktLen: maxPktLenVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewPcapValueNull() PcapValue {
	return PcapValue{
		state: attr.ValueStateNull,
	}
}

func NewPcapValueUnknown() PcapValue {
	return PcapValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPcapValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PcapValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PcapValue Attribute Value",
				"While creating a PcapValue value, a missing attribute value was detected. "+
					"A PcapValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PcapValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PcapValue Attribute Type",
				"While creating a PcapValue value, an invalid attribute value was detected. "+
					"A PcapValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PcapValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PcapValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PcapValue Attribute Value",
				"While creating a PcapValue value, an extra attribute value was detected. "+
					"A PcapValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PcapValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPcapValueUnknown(), diags
	}

	bucketAttribute, ok := attributes["bucket"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bucket is missing from object`)

		return NewPcapValueUnknown(), diags
	}

	bucketVal, ok := bucketAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bucket expected to be basetypes.StringValue, was: %T`, bucketAttribute))
	}

	maxPktLenAttribute, ok := attributes["max_pkt_len"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_pkt_len is missing from object`)

		return NewPcapValueUnknown(), diags
	}

	maxPktLenVal, ok := maxPktLenAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_pkt_len expected to be basetypes.Int64Value, was: %T`, maxPktLenAttribute))
	}

	if diags.HasError() {
		return NewPcapValueUnknown(), diags
	}

	return PcapValue{
		Bucket:    bucketVal,
		MaxPktLen: maxPktLenVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewPcapValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PcapValue {
	object, diags := NewPcapValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPcapValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PcapType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPcapValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPcapValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPcapValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPcapValueMust(PcapValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PcapType) ValueType(ctx context.Context) attr.Value {
	return PcapValue{}
}

var _ basetypes.ObjectValuable = PcapValue{}

type PcapValue struct {
	Bucket    basetypes.StringValue `tfsdk:"bucket"`
	MaxPktLen basetypes.Int64Value  `tfsdk:"max_pkt_len"`
	state     attr.ValueState
}

func (v PcapValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["bucket"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["max_pkt_len"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Bucket.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bucket"] = val

		val, err = v.MaxPktLen.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_pkt_len"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PcapValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PcapValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PcapValue) String() string {
	return "PcapValue"
}

func (v PcapValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"bucket":      basetypes.StringType{},
		"max_pkt_len": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"bucket":      v.Bucket,
			"max_pkt_len": v.MaxPktLen,
		})

	return objVal, diags
}

func (v PcapValue) Equal(o attr.Value) bool {
	other, ok := o.(PcapValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Bucket.Equal(other.Bucket) {
		return false
	}

	if !v.MaxPktLen.Equal(other.MaxPktLen) {
		return false
	}

	return true
}

func (v PcapValue) Type(ctx context.Context) attr.Type {
	return PcapType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PcapValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"bucket":      basetypes.StringType{},
		"max_pkt_len": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = SecurityType{}

type SecurityType struct {
	basetypes.ObjectType
}

func (t SecurityType) Equal(o attr.Type) bool {
	other, ok := o.(SecurityType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SecurityType) String() string {
	return "SecurityType"
}

func (t SecurityType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	disableLocalSshAttribute, ok := attributes["disable_local_ssh"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disable_local_ssh is missing from object`)

		return nil, diags
	}

	disableLocalSshVal, ok := disableLocalSshAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disable_local_ssh expected to be basetypes.BoolValue, was: %T`, disableLocalSshAttribute))
	}

	fipsZeroizePasswordAttribute, ok := attributes["fips_zeroize_password"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fips_zeroize_password is missing from object`)

		return nil, diags
	}

	fipsZeroizePasswordVal, ok := fipsZeroizePasswordAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fips_zeroize_password expected to be basetypes.StringValue, was: %T`, fipsZeroizePasswordAttribute))
	}

	limitSshAccessAttribute, ok := attributes["limit_ssh_access"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`limit_ssh_access is missing from object`)

		return nil, diags
	}

	limitSshAccessVal, ok := limitSshAccessAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`limit_ssh_access expected to be basetypes.BoolValue, was: %T`, limitSshAccessAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SecurityValue{
		DisableLocalSsh:     disableLocalSshVal,
		FipsZeroizePassword: fipsZeroizePasswordVal,
		LimitSshAccess:      limitSshAccessVal,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewSecurityValueNull() SecurityValue {
	return SecurityValue{
		state: attr.ValueStateNull,
	}
}

func NewSecurityValueUnknown() SecurityValue {
	return SecurityValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSecurityValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SecurityValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SecurityValue Attribute Value",
				"While creating a SecurityValue value, a missing attribute value was detected. "+
					"A SecurityValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SecurityValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SecurityValue Attribute Type",
				"While creating a SecurityValue value, an invalid attribute value was detected. "+
					"A SecurityValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SecurityValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SecurityValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SecurityValue Attribute Value",
				"While creating a SecurityValue value, an extra attribute value was detected. "+
					"A SecurityValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SecurityValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSecurityValueUnknown(), diags
	}

	disableLocalSshAttribute, ok := attributes["disable_local_ssh"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disable_local_ssh is missing from object`)

		return NewSecurityValueUnknown(), diags
	}

	disableLocalSshVal, ok := disableLocalSshAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disable_local_ssh expected to be basetypes.BoolValue, was: %T`, disableLocalSshAttribute))
	}

	fipsZeroizePasswordAttribute, ok := attributes["fips_zeroize_password"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fips_zeroize_password is missing from object`)

		return NewSecurityValueUnknown(), diags
	}

	fipsZeroizePasswordVal, ok := fipsZeroizePasswordAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fips_zeroize_password expected to be basetypes.StringValue, was: %T`, fipsZeroizePasswordAttribute))
	}

	limitSshAccessAttribute, ok := attributes["limit_ssh_access"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`limit_ssh_access is missing from object`)

		return NewSecurityValueUnknown(), diags
	}

	limitSshAccessVal, ok := limitSshAccessAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`limit_ssh_access expected to be basetypes.BoolValue, was: %T`, limitSshAccessAttribute))
	}

	if diags.HasError() {
		return NewSecurityValueUnknown(), diags
	}

	return SecurityValue{
		DisableLocalSsh:     disableLocalSshVal,
		FipsZeroizePassword: fipsZeroizePasswordVal,
		LimitSshAccess:      limitSshAccessVal,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewSecurityValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SecurityValue {
	object, diags := NewSecurityValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSecurityValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SecurityType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSecurityValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSecurityValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSecurityValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSecurityValueMust(SecurityValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SecurityType) ValueType(ctx context.Context) attr.Value {
	return SecurityValue{}
}

var _ basetypes.ObjectValuable = SecurityValue{}

type SecurityValue struct {
	DisableLocalSsh     basetypes.BoolValue   `tfsdk:"disable_local_ssh"`
	FipsZeroizePassword basetypes.StringValue `tfsdk:"fips_zeroize_password"`
	LimitSshAccess      basetypes.BoolValue   `tfsdk:"limit_ssh_access"`
	state               attr.ValueState
}

func (v SecurityValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["disable_local_ssh"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["fips_zeroize_password"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["limit_ssh_access"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.DisableLocalSsh.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["disable_local_ssh"] = val

		val, err = v.FipsZeroizePassword.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["fips_zeroize_password"] = val

		val, err = v.LimitSshAccess.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["limit_ssh_access"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SecurityValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SecurityValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SecurityValue) String() string {
	return "SecurityValue"
}

func (v SecurityValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"disable_local_ssh":     basetypes.BoolType{},
		"fips_zeroize_password": basetypes.StringType{},
		"limit_ssh_access":      basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"disable_local_ssh":     v.DisableLocalSsh,
			"fips_zeroize_password": v.FipsZeroizePassword,
			"limit_ssh_access":      v.LimitSshAccess,
		})

	return objVal, diags
}

func (v SecurityValue) Equal(o attr.Value) bool {
	other, ok := o.(SecurityValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.DisableLocalSsh.Equal(other.DisableLocalSsh) {
		return false
	}

	if !v.FipsZeroizePassword.Equal(other.FipsZeroizePassword) {
		return false
	}

	if !v.LimitSshAccess.Equal(other.LimitSshAccess) {
		return false
	}

	return true
}

func (v SecurityValue) Type(ctx context.Context) attr.Type {
	return SecurityType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SecurityValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"disable_local_ssh":     basetypes.BoolType{},
		"fips_zeroize_password": basetypes.StringType{},
		"limit_ssh_access":      basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = SsrType{}

type SsrType struct {
	basetypes.ObjectType
}

func (t SsrType) Equal(o attr.Type) bool {
	other, ok := o.(SsrType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SsrType) String() string {
	return "SsrType"
}

func (t SsrType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	conductorHostsAttribute, ok := attributes["conductor_hosts"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`conductor_hosts is missing from object`)

		return nil, diags
	}

	conductorHostsVal, ok := conductorHostsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`conductor_hosts expected to be basetypes.ListValue, was: %T`, conductorHostsAttribute))
	}

	conductorTokenAttribute, ok := attributes["conductor_token"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`conductor_token is missing from object`)

		return nil, diags
	}

	conductorTokenVal, ok := conductorTokenAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`conductor_token expected to be basetypes.StringValue, was: %T`, conductorTokenAttribute))
	}

	disableStatsAttribute, ok := attributes["disable_stats"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disable_stats is missing from object`)

		return nil, diags
	}

	disableStatsVal, ok := disableStatsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disable_stats expected to be basetypes.BoolValue, was: %T`, disableStatsAttribute))
	}

	proxyAttribute, ok := attributes["proxy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`proxy is missing from object`)

		return nil, diags
	}

	proxyVal, ok := proxyAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`proxy expected to be basetypes.ObjectValue, was: %T`, proxyAttribute))
	}

	ssrAutoUpgradeAttribute, ok := attributes["auto_upgrade"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auto_upgrade is missing from object`)

		return nil, diags
	}

	ssrAutoUpgradeVal, ok := ssrAutoUpgradeAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auto_upgrade expected to be basetypes.ObjectValue, was: %T`, ssrAutoUpgradeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SsrValue{
		ConductorHosts: conductorHostsVal,
		ConductorToken: conductorTokenVal,
		DisableStats:   disableStatsVal,
		Proxy:          proxyVal,
		SsrAutoUpgrade: ssrAutoUpgradeVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewSsrValueNull() SsrValue {
	return SsrValue{
		state: attr.ValueStateNull,
	}
}

func NewSsrValueUnknown() SsrValue {
	return SsrValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSsrValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SsrValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SsrValue Attribute Value",
				"While creating a SsrValue value, a missing attribute value was detected. "+
					"A SsrValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SsrValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SsrValue Attribute Type",
				"While creating a SsrValue value, an invalid attribute value was detected. "+
					"A SsrValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SsrValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SsrValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SsrValue Attribute Value",
				"While creating a SsrValue value, an extra attribute value was detected. "+
					"A SsrValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SsrValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSsrValueUnknown(), diags
	}

	conductorHostsAttribute, ok := attributes["conductor_hosts"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`conductor_hosts is missing from object`)

		return NewSsrValueUnknown(), diags
	}

	conductorHostsVal, ok := conductorHostsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`conductor_hosts expected to be basetypes.ListValue, was: %T`, conductorHostsAttribute))
	}

	conductorTokenAttribute, ok := attributes["conductor_token"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`conductor_token is missing from object`)

		return NewSsrValueUnknown(), diags
	}

	conductorTokenVal, ok := conductorTokenAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`conductor_token expected to be basetypes.StringValue, was: %T`, conductorTokenAttribute))
	}

	disableStatsAttribute, ok := attributes["disable_stats"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disable_stats is missing from object`)

		return NewSsrValueUnknown(), diags
	}

	disableStatsVal, ok := disableStatsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disable_stats expected to be basetypes.BoolValue, was: %T`, disableStatsAttribute))
	}

	proxyAttribute, ok := attributes["proxy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`proxy is missing from object`)

		return NewSsrValueUnknown(), diags
	}

	proxyVal, ok := proxyAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`proxy expected to be basetypes.ObjectValue, was: %T`, proxyAttribute))
	}

	ssrAutoUpgradeAttribute, ok := attributes["auto_upgrade"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auto_upgrade is missing from object`)

		return NewSsrValueUnknown(), diags
	}

	ssrAutoUpgradeVal, ok := ssrAutoUpgradeAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auto_upgrade expected to be basetypes.ObjectValue, was: %T`, ssrAutoUpgradeAttribute))
	}

	if diags.HasError() {
		return NewSsrValueUnknown(), diags
	}

	return SsrValue{
		ConductorHosts: conductorHostsVal,
		ConductorToken: conductorTokenVal,
		DisableStats:   disableStatsVal,
		Proxy:          proxyVal,
		SsrAutoUpgrade: ssrAutoUpgradeVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewSsrValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SsrValue {
	object, diags := NewSsrValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSsrValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SsrType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSsrValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSsrValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSsrValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSsrValueMust(SsrValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SsrType) ValueType(ctx context.Context) attr.Value {
	return SsrValue{}
}

var _ basetypes.ObjectValuable = SsrValue{}

type SsrValue struct {
	ConductorHosts basetypes.ListValue   `tfsdk:"conductor_hosts"`
	ConductorToken basetypes.StringValue `tfsdk:"conductor_token"`
	DisableStats   basetypes.BoolValue   `tfsdk:"disable_stats"`
	Proxy          basetypes.ObjectValue `tfsdk:"proxy"`
	SsrAutoUpgrade basetypes.ObjectValue `tfsdk:"auto_upgrade"`
	state          attr.ValueState
}

func (v SsrValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["conductor_hosts"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["conductor_token"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["disable_stats"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["proxy"] = basetypes.ObjectType{
		AttrTypes: ProxyValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["auto_upgrade"] = basetypes.ObjectType{
		AttrTypes: SsrAutoUpgradeValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.ConductorHosts.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["conductor_hosts"] = val

		val, err = v.ConductorToken.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["conductor_token"] = val

		val, err = v.DisableStats.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["disable_stats"] = val

		val, err = v.Proxy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["proxy"] = val

		val, err = v.SsrAutoUpgrade.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["auto_upgrade"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SsrValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SsrValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SsrValue) String() string {
	return "SsrValue"
}

func (v SsrValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var proxy basetypes.ObjectValue

	if v.Proxy.IsNull() {
		proxy = types.ObjectNull(
			ProxyValue{}.AttributeTypes(ctx),
		)
	}

	if v.Proxy.IsUnknown() {
		proxy = types.ObjectUnknown(
			ProxyValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Proxy.IsNull() && !v.Proxy.IsUnknown() {
		proxy = types.ObjectValueMust(
			ProxyValue{}.AttributeTypes(ctx),
			v.Proxy.Attributes(),
		)
	}

	var ssrAutoUpgrade basetypes.ObjectValue

	if v.SsrAutoUpgrade.IsNull() {
		ssrAutoUpgrade = types.ObjectNull(
			SsrAutoUpgradeValue{}.AttributeTypes(ctx),
		)
	}

	if v.SsrAutoUpgrade.IsUnknown() {
		ssrAutoUpgrade = types.ObjectUnknown(
			SsrAutoUpgradeValue{}.AttributeTypes(ctx),
		)
	}

	if !v.SsrAutoUpgrade.IsNull() && !v.SsrAutoUpgrade.IsUnknown() {
		ssrAutoUpgrade = types.ObjectValueMust(
			SsrAutoUpgradeValue{}.AttributeTypes(ctx),
			v.SsrAutoUpgrade.Attributes(),
		)
	}

	var conductorHostsVal basetypes.ListValue
	switch {
	case v.ConductorHosts.IsUnknown():
		conductorHostsVal = types.ListUnknown(types.StringType)
	case v.ConductorHosts.IsNull():
		conductorHostsVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		conductorHostsVal, d = types.ListValue(types.StringType, v.ConductorHosts.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"conductor_hosts": basetypes.ListType{
				ElemType: types.StringType,
			},
			"conductor_token": basetypes.StringType{},
			"disable_stats":   basetypes.BoolType{},
			"proxy": basetypes.ObjectType{
				AttrTypes: ProxyValue{}.AttributeTypes(ctx),
			},
			"auto_upgrade": basetypes.ObjectType{
				AttrTypes: SsrAutoUpgradeValue{}.AttributeTypes(ctx),
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"conductor_hosts": basetypes.ListType{
			ElemType: types.StringType,
		},
		"conductor_token": basetypes.StringType{},
		"disable_stats":   basetypes.BoolType{},
		"proxy": basetypes.ObjectType{
			AttrTypes: ProxyValue{}.AttributeTypes(ctx),
		},
		"auto_upgrade": basetypes.ObjectType{
			AttrTypes: SsrAutoUpgradeValue{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"conductor_hosts": conductorHostsVal,
			"conductor_token": v.ConductorToken,
			"disable_stats":   v.DisableStats,
			"proxy":           proxy,
			"auto_upgrade":    ssrAutoUpgrade,
		})

	return objVal, diags
}

func (v SsrValue) Equal(o attr.Value) bool {
	other, ok := o.(SsrValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.ConductorHosts.Equal(other.ConductorHosts) {
		return false
	}

	if !v.ConductorToken.Equal(other.ConductorToken) {
		return false
	}

	if !v.DisableStats.Equal(other.DisableStats) {
		return false
	}

	if !v.Proxy.Equal(other.Proxy) {
		return false
	}

	if !v.SsrAutoUpgrade.Equal(other.SsrAutoUpgrade) {
		return false
	}

	return true
}

func (v SsrValue) Type(ctx context.Context) attr.Type {
	return SsrType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SsrValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"conductor_hosts": basetypes.ListType{
			ElemType: types.StringType,
		},
		"conductor_token": basetypes.StringType{},
		"disable_stats":   basetypes.BoolType{},
		"proxy": basetypes.ObjectType{
			AttrTypes: ProxyValue{}.AttributeTypes(ctx),
		},
		"auto_upgrade": basetypes.ObjectType{
			AttrTypes: SsrAutoUpgradeValue{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = ProxyType{}

type ProxyType struct {
	basetypes.ObjectType
}

func (t ProxyType) Equal(o attr.Type) bool {
	other, ok := o.(ProxyType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ProxyType) String() string {
	return "ProxyType"
}

func (t ProxyType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return nil, diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ProxyValue{
		Url:   urlVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewProxyValueNull() ProxyValue {
	return ProxyValue{
		state: attr.ValueStateNull,
	}
}

func NewProxyValueUnknown() ProxyValue {
	return ProxyValue{
		state: attr.ValueStateUnknown,
	}
}

func NewProxyValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ProxyValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ProxyValue Attribute Value",
				"While creating a ProxyValue value, a missing attribute value was detected. "+
					"A ProxyValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ProxyValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ProxyValue Attribute Type",
				"While creating a ProxyValue value, an invalid attribute value was detected. "+
					"A ProxyValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ProxyValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ProxyValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ProxyValue Attribute Value",
				"While creating a ProxyValue value, an extra attribute value was detected. "+
					"A ProxyValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ProxyValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewProxyValueUnknown(), diags
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return NewProxyValueUnknown(), diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	if diags.HasError() {
		return NewProxyValueUnknown(), diags
	}

	return ProxyValue{
		Url:   urlVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewProxyValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ProxyValue {
	object, diags := NewProxyValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewProxyValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ProxyType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewProxyValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewProxyValueUnknown(), nil
	}

	if in.IsNull() {
		return NewProxyValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewProxyValueMust(ProxyValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ProxyType) ValueType(ctx context.Context) attr.Value {
	return ProxyValue{}
}

var _ basetypes.ObjectValuable = ProxyValue{}

type ProxyValue struct {
	Url   basetypes.StringValue `tfsdk:"url"`
	state attr.ValueState
}

func (v ProxyValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["url"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Url.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["url"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ProxyValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ProxyValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ProxyValue) String() string {
	return "ProxyValue"
}

func (v ProxyValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"url": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"url": v.Url,
		})

	return objVal, diags
}

func (v ProxyValue) Equal(o attr.Value) bool {
	other, ok := o.(ProxyValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Url.Equal(other.Url) {
		return false
	}

	return true
}

func (v ProxyValue) Type(ctx context.Context) attr.Type {
	return ProxyType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ProxyValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"url": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = SsrAutoUpgradeType{}

type SsrAutoUpgradeType struct {
	basetypes.ObjectType
}

func (t SsrAutoUpgradeType) Equal(o attr.Type) bool {
	other, ok := o.(SsrAutoUpgradeType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SsrAutoUpgradeType) String() string {
	return "SsrAutoUpgradeType"
}

func (t SsrAutoUpgradeType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	channelAttribute, ok := attributes["channel"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`channel is missing from object`)

		return nil, diags
	}

	channelVal, ok := channelAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`channel expected to be basetypes.StringValue, was: %T`, channelAttribute))
	}

	customVersionsAttribute, ok := attributes["custom_versions"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`custom_versions is missing from object`)

		return nil, diags
	}

	customVersionsVal, ok := customVersionsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`custom_versions expected to be basetypes.MapValue, was: %T`, customVersionsAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SsrAutoUpgradeValue{
		Channel:        channelVal,
		CustomVersions: customVersionsVal,
		Enabled:        enabledVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewSsrAutoUpgradeValueNull() SsrAutoUpgradeValue {
	return SsrAutoUpgradeValue{
		state: attr.ValueStateNull,
	}
}

func NewSsrAutoUpgradeValueUnknown() SsrAutoUpgradeValue {
	return SsrAutoUpgradeValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSsrAutoUpgradeValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SsrAutoUpgradeValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SsrAutoUpgradeValue Attribute Value",
				"While creating a SsrAutoUpgradeValue value, a missing attribute value was detected. "+
					"A SsrAutoUpgradeValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SsrAutoUpgradeValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SsrAutoUpgradeValue Attribute Type",
				"While creating a SsrAutoUpgradeValue value, an invalid attribute value was detected. "+
					"A SsrAutoUpgradeValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SsrAutoUpgradeValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SsrAutoUpgradeValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SsrAutoUpgradeValue Attribute Value",
				"While creating a SsrAutoUpgradeValue value, an extra attribute value was detected. "+
					"A SsrAutoUpgradeValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SsrAutoUpgradeValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSsrAutoUpgradeValueUnknown(), diags
	}

	channelAttribute, ok := attributes["channel"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`channel is missing from object`)

		return NewSsrAutoUpgradeValueUnknown(), diags
	}

	channelVal, ok := channelAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`channel expected to be basetypes.StringValue, was: %T`, channelAttribute))
	}

	customVersionsAttribute, ok := attributes["custom_versions"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`custom_versions is missing from object`)

		return NewSsrAutoUpgradeValueUnknown(), diags
	}

	customVersionsVal, ok := customVersionsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`custom_versions expected to be basetypes.MapValue, was: %T`, customVersionsAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewSsrAutoUpgradeValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	if diags.HasError() {
		return NewSsrAutoUpgradeValueUnknown(), diags
	}

	return SsrAutoUpgradeValue{
		Channel:        channelVal,
		CustomVersions: customVersionsVal,
		Enabled:        enabledVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewSsrAutoUpgradeValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SsrAutoUpgradeValue {
	object, diags := NewSsrAutoUpgradeValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSsrAutoUpgradeValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SsrAutoUpgradeType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSsrAutoUpgradeValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSsrAutoUpgradeValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSsrAutoUpgradeValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSsrAutoUpgradeValueMust(SsrAutoUpgradeValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SsrAutoUpgradeType) ValueType(ctx context.Context) attr.Value {
	return SsrAutoUpgradeValue{}
}

var _ basetypes.ObjectValuable = SsrAutoUpgradeValue{}

type SsrAutoUpgradeValue struct {
	Channel        basetypes.StringValue `tfsdk:"channel"`
	CustomVersions basetypes.MapValue    `tfsdk:"custom_versions"`
	Enabled        basetypes.BoolValue   `tfsdk:"enabled"`
	state          attr.ValueState
}

func (v SsrAutoUpgradeValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["channel"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["custom_versions"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Channel.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["channel"] = val

		val, err = v.CustomVersions.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["custom_versions"] = val

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SsrAutoUpgradeValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SsrAutoUpgradeValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SsrAutoUpgradeValue) String() string {
	return "SsrAutoUpgradeValue"
}

func (v SsrAutoUpgradeValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var customVersionsVal basetypes.MapValue
	switch {
	case v.CustomVersions.IsUnknown():
		customVersionsVal = types.MapUnknown(types.StringType)
	case v.CustomVersions.IsNull():
		customVersionsVal = types.MapNull(types.StringType)
	default:
		var d diag.Diagnostics
		customVersionsVal, d = types.MapValue(types.StringType, v.CustomVersions.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"channel": basetypes.StringType{},
			"custom_versions": basetypes.MapType{
				ElemType: types.StringType,
			},
			"enabled": basetypes.BoolType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"channel": basetypes.StringType{},
		"custom_versions": basetypes.MapType{
			ElemType: types.StringType,
		},
		"enabled": basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"channel":         v.Channel,
			"custom_versions": customVersionsVal,
			"enabled":         v.Enabled,
		})

	return objVal, diags
}

func (v SsrAutoUpgradeValue) Equal(o attr.Value) bool {
	other, ok := o.(SsrAutoUpgradeValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Channel.Equal(other.Channel) {
		return false
	}

	if !v.CustomVersions.Equal(other.CustomVersions) {
		return false
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	return true
}

func (v SsrAutoUpgradeValue) Type(ctx context.Context) attr.Type {
	return SsrAutoUpgradeType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SsrAutoUpgradeValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"channel": basetypes.StringType{},
		"custom_versions": basetypes.MapType{
			ElemType: types.StringType,
		},
		"enabled": basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = SwitchType{}

type SwitchType struct {
	basetypes.ObjectType
}

func (t SwitchType) Equal(o attr.Type) bool {
	other, ok := o.(SwitchType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SwitchType) String() string {
	return "SwitchType"
}

func (t SwitchType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	autoUpgradeAttribute, ok := attributes["auto_upgrade"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auto_upgrade is missing from object`)

		return nil, diags
	}

	autoUpgradeVal, ok := autoUpgradeAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auto_upgrade expected to be basetypes.ObjectValue, was: %T`, autoUpgradeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SwitchValue{
		AutoUpgrade: autoUpgradeVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewSwitchValueNull() SwitchValue {
	return SwitchValue{
		state: attr.ValueStateNull,
	}
}

func NewSwitchValueUnknown() SwitchValue {
	return SwitchValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSwitchValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SwitchValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SwitchValue Attribute Value",
				"While creating a SwitchValue value, a missing attribute value was detected. "+
					"A SwitchValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SwitchValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SwitchValue Attribute Type",
				"While creating a SwitchValue value, an invalid attribute value was detected. "+
					"A SwitchValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SwitchValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SwitchValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SwitchValue Attribute Value",
				"While creating a SwitchValue value, an extra attribute value was detected. "+
					"A SwitchValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SwitchValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSwitchValueUnknown(), diags
	}

	autoUpgradeAttribute, ok := attributes["auto_upgrade"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auto_upgrade is missing from object`)

		return NewSwitchValueUnknown(), diags
	}

	autoUpgradeVal, ok := autoUpgradeAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auto_upgrade expected to be basetypes.ObjectValue, was: %T`, autoUpgradeAttribute))
	}

	if diags.HasError() {
		return NewSwitchValueUnknown(), diags
	}

	return SwitchValue{
		AutoUpgrade: autoUpgradeVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewSwitchValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SwitchValue {
	object, diags := NewSwitchValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSwitchValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SwitchType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSwitchValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSwitchValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSwitchValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSwitchValueMust(SwitchValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SwitchType) ValueType(ctx context.Context) attr.Value {
	return SwitchValue{}
}

var _ basetypes.ObjectValuable = SwitchValue{}

type SwitchValue struct {
	AutoUpgrade basetypes.ObjectValue `tfsdk:"auto_upgrade"`
	state       attr.ValueState
}

func (v SwitchValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["auto_upgrade"] = basetypes.ObjectType{
		AttrTypes: AutoUpgradeValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.AutoUpgrade.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["auto_upgrade"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SwitchValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SwitchValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SwitchValue) String() string {
	return "SwitchValue"
}

func (v SwitchValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var autoUpgrade basetypes.ObjectValue

	if v.AutoUpgrade.IsNull() {
		autoUpgrade = types.ObjectNull(
			AutoUpgradeValue{}.AttributeTypes(ctx),
		)
	}

	if v.AutoUpgrade.IsUnknown() {
		autoUpgrade = types.ObjectUnknown(
			AutoUpgradeValue{}.AttributeTypes(ctx),
		)
	}

	if !v.AutoUpgrade.IsNull() && !v.AutoUpgrade.IsUnknown() {
		autoUpgrade = types.ObjectValueMust(
			AutoUpgradeValue{}.AttributeTypes(ctx),
			v.AutoUpgrade.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"auto_upgrade": basetypes.ObjectType{
			AttrTypes: AutoUpgradeValue{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"auto_upgrade": autoUpgrade,
		})

	return objVal, diags
}

func (v SwitchValue) Equal(o attr.Value) bool {
	other, ok := o.(SwitchValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AutoUpgrade.Equal(other.AutoUpgrade) {
		return false
	}

	return true
}

func (v SwitchValue) Type(ctx context.Context) attr.Type {
	return SwitchType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SwitchValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"auto_upgrade": basetypes.ObjectType{
			AttrTypes: AutoUpgradeValue{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = AutoUpgradeType{}

type AutoUpgradeType struct {
	basetypes.ObjectType
}

func (t AutoUpgradeType) Equal(o attr.Type) bool {
	other, ok := o.(AutoUpgradeType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AutoUpgradeType) String() string {
	return "AutoUpgradeType"
}

func (t AutoUpgradeType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	customVersionsAttribute, ok := attributes["custom_versions"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`custom_versions is missing from object`)

		return nil, diags
	}

	customVersionsVal, ok := customVersionsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`custom_versions expected to be basetypes.MapValue, was: %T`, customVersionsAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	snapshotAttribute, ok := attributes["snapshot"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`snapshot is missing from object`)

		return nil, diags
	}

	snapshotVal, ok := snapshotAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`snapshot expected to be basetypes.BoolValue, was: %T`, snapshotAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AutoUpgradeValue{
		CustomVersions: customVersionsVal,
		Enabled:        enabledVal,
		Snapshot:       snapshotVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewAutoUpgradeValueNull() AutoUpgradeValue {
	return AutoUpgradeValue{
		state: attr.ValueStateNull,
	}
}

func NewAutoUpgradeValueUnknown() AutoUpgradeValue {
	return AutoUpgradeValue{
		state: attr.ValueStateUnknown,
	}
}

func NewAutoUpgradeValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AutoUpgradeValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AutoUpgradeValue Attribute Value",
				"While creating a AutoUpgradeValue value, a missing attribute value was detected. "+
					"A AutoUpgradeValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AutoUpgradeValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AutoUpgradeValue Attribute Type",
				"While creating a AutoUpgradeValue value, an invalid attribute value was detected. "+
					"A AutoUpgradeValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AutoUpgradeValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AutoUpgradeValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AutoUpgradeValue Attribute Value",
				"While creating a AutoUpgradeValue value, an extra attribute value was detected. "+
					"A AutoUpgradeValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AutoUpgradeValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAutoUpgradeValueUnknown(), diags
	}

	customVersionsAttribute, ok := attributes["custom_versions"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`custom_versions is missing from object`)

		return NewAutoUpgradeValueUnknown(), diags
	}

	customVersionsVal, ok := customVersionsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`custom_versions expected to be basetypes.MapValue, was: %T`, customVersionsAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewAutoUpgradeValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	snapshotAttribute, ok := attributes["snapshot"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`snapshot is missing from object`)

		return NewAutoUpgradeValueUnknown(), diags
	}

	snapshotVal, ok := snapshotAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`snapshot expected to be basetypes.BoolValue, was: %T`, snapshotAttribute))
	}

	if diags.HasError() {
		return NewAutoUpgradeValueUnknown(), diags
	}

	return AutoUpgradeValue{
		CustomVersions: customVersionsVal,
		Enabled:        enabledVal,
		Snapshot:       snapshotVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewAutoUpgradeValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AutoUpgradeValue {
	object, diags := NewAutoUpgradeValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAutoUpgradeValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AutoUpgradeType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAutoUpgradeValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAutoUpgradeValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAutoUpgradeValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAutoUpgradeValueMust(AutoUpgradeValue{}.AttributeTypes(ctx), attributes), nil
}

func (t AutoUpgradeType) ValueType(ctx context.Context) attr.Value {
	return AutoUpgradeValue{}
}

var _ basetypes.ObjectValuable = AutoUpgradeValue{}

type AutoUpgradeValue struct {
	CustomVersions basetypes.MapValue  `tfsdk:"custom_versions"`
	Enabled        basetypes.BoolValue `tfsdk:"enabled"`
	Snapshot       basetypes.BoolValue `tfsdk:"snapshot"`
	state          attr.ValueState
}

func (v AutoUpgradeValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["custom_versions"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["snapshot"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.CustomVersions.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["custom_versions"] = val

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.Snapshot.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["snapshot"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AutoUpgradeValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AutoUpgradeValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AutoUpgradeValue) String() string {
	return "AutoUpgradeValue"
}

func (v AutoUpgradeValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var customVersionsVal basetypes.MapValue
	switch {
	case v.CustomVersions.IsUnknown():
		customVersionsVal = types.MapUnknown(types.StringType)
	case v.CustomVersions.IsNull():
		customVersionsVal = types.MapNull(types.StringType)
	default:
		var d diag.Diagnostics
		customVersionsVal, d = types.MapValue(types.StringType, v.CustomVersions.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"custom_versions": basetypes.MapType{
				ElemType: types.StringType,
			},
			"enabled":  basetypes.BoolType{},
			"snapshot": basetypes.BoolType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"custom_versions": basetypes.MapType{
			ElemType: types.StringType,
		},
		"enabled":  basetypes.BoolType{},
		"snapshot": basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"custom_versions": customVersionsVal,
			"enabled":         v.Enabled,
			"snapshot":        v.Snapshot,
		})

	return objVal, diags
}

func (v AutoUpgradeValue) Equal(o attr.Value) bool {
	other, ok := o.(AutoUpgradeValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.CustomVersions.Equal(other.CustomVersions) {
		return false
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.Snapshot.Equal(other.Snapshot) {
		return false
	}

	return true
}

func (v AutoUpgradeValue) Type(ctx context.Context) attr.Type {
	return AutoUpgradeType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AutoUpgradeValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"custom_versions": basetypes.MapType{
			ElemType: types.StringType,
		},
		"enabled":  basetypes.BoolType{},
		"snapshot": basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = SwitchMgmtType{}

type SwitchMgmtType struct {
	basetypes.ObjectType
}

func (t SwitchMgmtType) Equal(o attr.Type) bool {
	other, ok := o.(SwitchMgmtType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SwitchMgmtType) String() string {
	return "SwitchMgmtType"
}

func (t SwitchMgmtType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	apAffinityThresholdAttribute, ok := attributes["ap_affinity_threshold"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ap_affinity_threshold is missing from object`)

		return nil, diags
	}

	apAffinityThresholdVal, ok := apAffinityThresholdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ap_affinity_threshold expected to be basetypes.Int64Value, was: %T`, apAffinityThresholdAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SwitchMgmtValue{
		ApAffinityThreshold: apAffinityThresholdVal,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewSwitchMgmtValueNull() SwitchMgmtValue {
	return SwitchMgmtValue{
		state: attr.ValueStateNull,
	}
}

func NewSwitchMgmtValueUnknown() SwitchMgmtValue {
	return SwitchMgmtValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSwitchMgmtValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SwitchMgmtValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SwitchMgmtValue Attribute Value",
				"While creating a SwitchMgmtValue value, a missing attribute value was detected. "+
					"A SwitchMgmtValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SwitchMgmtValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SwitchMgmtValue Attribute Type",
				"While creating a SwitchMgmtValue value, an invalid attribute value was detected. "+
					"A SwitchMgmtValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SwitchMgmtValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SwitchMgmtValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SwitchMgmtValue Attribute Value",
				"While creating a SwitchMgmtValue value, an extra attribute value was detected. "+
					"A SwitchMgmtValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SwitchMgmtValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSwitchMgmtValueUnknown(), diags
	}

	apAffinityThresholdAttribute, ok := attributes["ap_affinity_threshold"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ap_affinity_threshold is missing from object`)

		return NewSwitchMgmtValueUnknown(), diags
	}

	apAffinityThresholdVal, ok := apAffinityThresholdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ap_affinity_threshold expected to be basetypes.Int64Value, was: %T`, apAffinityThresholdAttribute))
	}

	if diags.HasError() {
		return NewSwitchMgmtValueUnknown(), diags
	}

	return SwitchMgmtValue{
		ApAffinityThreshold: apAffinityThresholdVal,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewSwitchMgmtValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SwitchMgmtValue {
	object, diags := NewSwitchMgmtValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSwitchMgmtValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SwitchMgmtType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSwitchMgmtValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSwitchMgmtValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSwitchMgmtValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSwitchMgmtValueMust(SwitchMgmtValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SwitchMgmtType) ValueType(ctx context.Context) attr.Value {
	return SwitchMgmtValue{}
}

var _ basetypes.ObjectValuable = SwitchMgmtValue{}

type SwitchMgmtValue struct {
	ApAffinityThreshold basetypes.Int64Value `tfsdk:"ap_affinity_threshold"`
	state               attr.ValueState
}

func (v SwitchMgmtValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["ap_affinity_threshold"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.ApAffinityThreshold.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ap_affinity_threshold"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SwitchMgmtValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SwitchMgmtValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SwitchMgmtValue) String() string {
	return "SwitchMgmtValue"
}

func (v SwitchMgmtValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"ap_affinity_threshold": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"ap_affinity_threshold": v.ApAffinityThreshold,
		})

	return objVal, diags
}

func (v SwitchMgmtValue) Equal(o attr.Value) bool {
	other, ok := o.(SwitchMgmtValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.ApAffinityThreshold.Equal(other.ApAffinityThreshold) {
		return false
	}

	return true
}

func (v SwitchMgmtValue) Type(ctx context.Context) attr.Type {
	return SwitchMgmtType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SwitchMgmtValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"ap_affinity_threshold": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = SyntheticTestType{}

type SyntheticTestType struct {
	basetypes.ObjectType
}

func (t SyntheticTestType) Equal(o attr.Type) bool {
	other, ok := o.(SyntheticTestType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SyntheticTestType) String() string {
	return "SyntheticTestType"
}

func (t SyntheticTestType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	aggressivenessAttribute, ok := attributes["aggressiveness"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`aggressiveness is missing from object`)

		return nil, diags
	}

	aggressivenessVal, ok := aggressivenessAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`aggressiveness expected to be basetypes.StringValue, was: %T`, aggressivenessAttribute))
	}

	customProbesAttribute, ok := attributes["custom_probes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`custom_probes is missing from object`)

		return nil, diags
	}

	customProbesVal, ok := customProbesAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`custom_probes expected to be basetypes.MapValue, was: %T`, customProbesAttribute))
	}

	disabledAttribute, ok := attributes["disabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disabled is missing from object`)

		return nil, diags
	}

	disabledVal, ok := disabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disabled expected to be basetypes.BoolValue, was: %T`, disabledAttribute))
	}

	lanNetworksAttribute, ok := attributes["lan_networks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lan_networks is missing from object`)

		return nil, diags
	}

	lanNetworksVal, ok := lanNetworksAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lan_networks expected to be basetypes.ListValue, was: %T`, lanNetworksAttribute))
	}

	vlansAttribute, ok := attributes["vlans"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlans is missing from object`)

		return nil, diags
	}

	vlansVal, ok := vlansAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlans expected to be basetypes.ListValue, was: %T`, vlansAttribute))
	}

	wanSpeedtestAttribute, ok := attributes["wan_speedtest"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wan_speedtest is missing from object`)

		return nil, diags
	}

	wanSpeedtestVal, ok := wanSpeedtestAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wan_speedtest expected to be basetypes.ObjectValue, was: %T`, wanSpeedtestAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SyntheticTestValue{
		Aggressiveness: aggressivenessVal,
		CustomProbes:   customProbesVal,
		Disabled:       disabledVal,
		LanNetworks:    lanNetworksVal,
		Vlans:          vlansVal,
		WanSpeedtest:   wanSpeedtestVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewSyntheticTestValueNull() SyntheticTestValue {
	return SyntheticTestValue{
		state: attr.ValueStateNull,
	}
}

func NewSyntheticTestValueUnknown() SyntheticTestValue {
	return SyntheticTestValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSyntheticTestValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SyntheticTestValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SyntheticTestValue Attribute Value",
				"While creating a SyntheticTestValue value, a missing attribute value was detected. "+
					"A SyntheticTestValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SyntheticTestValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SyntheticTestValue Attribute Type",
				"While creating a SyntheticTestValue value, an invalid attribute value was detected. "+
					"A SyntheticTestValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SyntheticTestValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SyntheticTestValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SyntheticTestValue Attribute Value",
				"While creating a SyntheticTestValue value, an extra attribute value was detected. "+
					"A SyntheticTestValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SyntheticTestValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSyntheticTestValueUnknown(), diags
	}

	aggressivenessAttribute, ok := attributes["aggressiveness"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`aggressiveness is missing from object`)

		return NewSyntheticTestValueUnknown(), diags
	}

	aggressivenessVal, ok := aggressivenessAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`aggressiveness expected to be basetypes.StringValue, was: %T`, aggressivenessAttribute))
	}

	customProbesAttribute, ok := attributes["custom_probes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`custom_probes is missing from object`)

		return NewSyntheticTestValueUnknown(), diags
	}

	customProbesVal, ok := customProbesAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`custom_probes expected to be basetypes.MapValue, was: %T`, customProbesAttribute))
	}

	disabledAttribute, ok := attributes["disabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disabled is missing from object`)

		return NewSyntheticTestValueUnknown(), diags
	}

	disabledVal, ok := disabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disabled expected to be basetypes.BoolValue, was: %T`, disabledAttribute))
	}

	lanNetworksAttribute, ok := attributes["lan_networks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lan_networks is missing from object`)

		return NewSyntheticTestValueUnknown(), diags
	}

	lanNetworksVal, ok := lanNetworksAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lan_networks expected to be basetypes.ListValue, was: %T`, lanNetworksAttribute))
	}

	vlansAttribute, ok := attributes["vlans"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlans is missing from object`)

		return NewSyntheticTestValueUnknown(), diags
	}

	vlansVal, ok := vlansAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlans expected to be basetypes.ListValue, was: %T`, vlansAttribute))
	}

	wanSpeedtestAttribute, ok := attributes["wan_speedtest"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wan_speedtest is missing from object`)

		return NewSyntheticTestValueUnknown(), diags
	}

	wanSpeedtestVal, ok := wanSpeedtestAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wan_speedtest expected to be basetypes.ObjectValue, was: %T`, wanSpeedtestAttribute))
	}

	if diags.HasError() {
		return NewSyntheticTestValueUnknown(), diags
	}

	return SyntheticTestValue{
		Aggressiveness: aggressivenessVal,
		CustomProbes:   customProbesVal,
		Disabled:       disabledVal,
		LanNetworks:    lanNetworksVal,
		Vlans:          vlansVal,
		WanSpeedtest:   wanSpeedtestVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewSyntheticTestValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SyntheticTestValue {
	object, diags := NewSyntheticTestValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSyntheticTestValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SyntheticTestType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSyntheticTestValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSyntheticTestValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSyntheticTestValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSyntheticTestValueMust(SyntheticTestValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SyntheticTestType) ValueType(ctx context.Context) attr.Value {
	return SyntheticTestValue{}
}

var _ basetypes.ObjectValuable = SyntheticTestValue{}

type SyntheticTestValue struct {
	Aggressiveness basetypes.StringValue `tfsdk:"aggressiveness"`
	CustomProbes   basetypes.MapValue    `tfsdk:"custom_probes"`
	Disabled       basetypes.BoolValue   `tfsdk:"disabled"`
	LanNetworks    basetypes.ListValue   `tfsdk:"lan_networks"`
	Vlans          basetypes.ListValue   `tfsdk:"vlans"`
	WanSpeedtest   basetypes.ObjectValue `tfsdk:"wan_speedtest"`
	state          attr.ValueState
}

func (v SyntheticTestValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 6)

	var val tftypes.Value
	var err error

	attrTypes["aggressiveness"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["custom_probes"] = basetypes.MapType{
		ElemType: CustomProbesValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["disabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["lan_networks"] = basetypes.ListType{
		ElemType: LanNetworksValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["vlans"] = basetypes.ListType{
		ElemType: VlansValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["wan_speedtest"] = basetypes.ObjectType{
		AttrTypes: WanSpeedtestValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 6)

		val, err = v.Aggressiveness.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["aggressiveness"] = val

		val, err = v.CustomProbes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["custom_probes"] = val

		val, err = v.Disabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["disabled"] = val

		val, err = v.LanNetworks.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["lan_networks"] = val

		val, err = v.Vlans.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vlans"] = val

		val, err = v.WanSpeedtest.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["wan_speedtest"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SyntheticTestValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SyntheticTestValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SyntheticTestValue) String() string {
	return "SyntheticTestValue"
}

func (v SyntheticTestValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	customProbes := types.MapValueMust(
		CustomProbesType{
			basetypes.ObjectType{
				AttrTypes: CustomProbesValue{}.AttributeTypes(ctx),
			},
		},
		v.CustomProbes.Elements(),
	)

	if v.CustomProbes.IsNull() {
		customProbes = types.MapNull(
			CustomProbesType{
				basetypes.ObjectType{
					AttrTypes: CustomProbesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.CustomProbes.IsUnknown() {
		customProbes = types.MapUnknown(
			CustomProbesType{
				basetypes.ObjectType{
					AttrTypes: CustomProbesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	lanNetworks := types.ListValueMust(
		LanNetworksType{
			basetypes.ObjectType{
				AttrTypes: LanNetworksValue{}.AttributeTypes(ctx),
			},
		},
		v.LanNetworks.Elements(),
	)

	if v.LanNetworks.IsNull() {
		lanNetworks = types.ListNull(
			LanNetworksType{
				basetypes.ObjectType{
					AttrTypes: LanNetworksValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.LanNetworks.IsUnknown() {
		lanNetworks = types.ListUnknown(
			LanNetworksType{
				basetypes.ObjectType{
					AttrTypes: LanNetworksValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	vlans := types.ListValueMust(
		VlansType{
			basetypes.ObjectType{
				AttrTypes: VlansValue{}.AttributeTypes(ctx),
			},
		},
		v.Vlans.Elements(),
	)

	if v.Vlans.IsNull() {
		vlans = types.ListNull(
			VlansType{
				basetypes.ObjectType{
					AttrTypes: VlansValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Vlans.IsUnknown() {
		vlans = types.ListUnknown(
			VlansType{
				basetypes.ObjectType{
					AttrTypes: VlansValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var wanSpeedtest basetypes.ObjectValue

	if v.WanSpeedtest.IsNull() {
		wanSpeedtest = types.ObjectNull(
			WanSpeedtestValue{}.AttributeTypes(ctx),
		)
	}

	if v.WanSpeedtest.IsUnknown() {
		wanSpeedtest = types.ObjectUnknown(
			WanSpeedtestValue{}.AttributeTypes(ctx),
		)
	}

	if !v.WanSpeedtest.IsNull() && !v.WanSpeedtest.IsUnknown() {
		wanSpeedtest = types.ObjectValueMust(
			WanSpeedtestValue{}.AttributeTypes(ctx),
			v.WanSpeedtest.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"aggressiveness": basetypes.StringType{},
		"custom_probes": basetypes.MapType{
			ElemType: CustomProbesValue{}.Type(ctx),
		},
		"disabled": basetypes.BoolType{},
		"lan_networks": basetypes.ListType{
			ElemType: LanNetworksValue{}.Type(ctx),
		},
		"vlans": basetypes.ListType{
			ElemType: VlansValue{}.Type(ctx),
		},
		"wan_speedtest": basetypes.ObjectType{
			AttrTypes: WanSpeedtestValue{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"aggressiveness": v.Aggressiveness,
			"custom_probes":  customProbes,
			"disabled":       v.Disabled,
			"lan_networks":   lanNetworks,
			"vlans":          vlans,
			"wan_speedtest":  wanSpeedtest,
		})

	return objVal, diags
}

func (v SyntheticTestValue) Equal(o attr.Value) bool {
	other, ok := o.(SyntheticTestValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Aggressiveness.Equal(other.Aggressiveness) {
		return false
	}

	if !v.CustomProbes.Equal(other.CustomProbes) {
		return false
	}

	if !v.Disabled.Equal(other.Disabled) {
		return false
	}

	if !v.LanNetworks.Equal(other.LanNetworks) {
		return false
	}

	if !v.Vlans.Equal(other.Vlans) {
		return false
	}

	if !v.WanSpeedtest.Equal(other.WanSpeedtest) {
		return false
	}

	return true
}

func (v SyntheticTestValue) Type(ctx context.Context) attr.Type {
	return SyntheticTestType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SyntheticTestValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"aggressiveness": basetypes.StringType{},
		"custom_probes": basetypes.MapType{
			ElemType: CustomProbesValue{}.Type(ctx),
		},
		"disabled": basetypes.BoolType{},
		"lan_networks": basetypes.ListType{
			ElemType: LanNetworksValue{}.Type(ctx),
		},
		"vlans": basetypes.ListType{
			ElemType: VlansValue{}.Type(ctx),
		},
		"wan_speedtest": basetypes.ObjectType{
			AttrTypes: WanSpeedtestValue{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = CustomProbesType{}

type CustomProbesType struct {
	basetypes.ObjectType
}

func (t CustomProbesType) Equal(o attr.Type) bool {
	other, ok := o.(CustomProbesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t CustomProbesType) String() string {
	return "CustomProbesType"
}

func (t CustomProbesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	aggressivenessAttribute, ok := attributes["aggressiveness"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`aggressiveness is missing from object`)

		return nil, diags
	}

	aggressivenessVal, ok := aggressivenessAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`aggressiveness expected to be basetypes.StringValue, was: %T`, aggressivenessAttribute))
	}

	hostAttribute, ok := attributes["host"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`host is missing from object`)

		return nil, diags
	}

	hostVal, ok := hostAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`host expected to be basetypes.StringValue, was: %T`, hostAttribute))
	}

	portAttribute, ok := attributes["port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port is missing from object`)

		return nil, diags
	}

	portVal, ok := portAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port expected to be basetypes.Int64Value, was: %T`, portAttribute))
	}

	thresholdAttribute, ok := attributes["threshold"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`threshold is missing from object`)

		return nil, diags
	}

	thresholdVal, ok := thresholdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`threshold expected to be basetypes.Int64Value, was: %T`, thresholdAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return nil, diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return CustomProbesValue{
		Aggressiveness:   aggressivenessVal,
		Host:             hostVal,
		Port:             portVal,
		Threshold:        thresholdVal,
		CustomProbesType: typeVal,
		Url:              urlVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewCustomProbesValueNull() CustomProbesValue {
	return CustomProbesValue{
		state: attr.ValueStateNull,
	}
}

func NewCustomProbesValueUnknown() CustomProbesValue {
	return CustomProbesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewCustomProbesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (CustomProbesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing CustomProbesValue Attribute Value",
				"While creating a CustomProbesValue value, a missing attribute value was detected. "+
					"A CustomProbesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CustomProbesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid CustomProbesValue Attribute Type",
				"While creating a CustomProbesValue value, an invalid attribute value was detected. "+
					"A CustomProbesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CustomProbesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("CustomProbesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra CustomProbesValue Attribute Value",
				"While creating a CustomProbesValue value, an extra attribute value was detected. "+
					"A CustomProbesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra CustomProbesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewCustomProbesValueUnknown(), diags
	}

	aggressivenessAttribute, ok := attributes["aggressiveness"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`aggressiveness is missing from object`)

		return NewCustomProbesValueUnknown(), diags
	}

	aggressivenessVal, ok := aggressivenessAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`aggressiveness expected to be basetypes.StringValue, was: %T`, aggressivenessAttribute))
	}

	hostAttribute, ok := attributes["host"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`host is missing from object`)

		return NewCustomProbesValueUnknown(), diags
	}

	hostVal, ok := hostAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`host expected to be basetypes.StringValue, was: %T`, hostAttribute))
	}

	portAttribute, ok := attributes["port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port is missing from object`)

		return NewCustomProbesValueUnknown(), diags
	}

	portVal, ok := portAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port expected to be basetypes.Int64Value, was: %T`, portAttribute))
	}

	thresholdAttribute, ok := attributes["threshold"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`threshold is missing from object`)

		return NewCustomProbesValueUnknown(), diags
	}

	thresholdVal, ok := thresholdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`threshold expected to be basetypes.Int64Value, was: %T`, thresholdAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewCustomProbesValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return NewCustomProbesValueUnknown(), diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	if diags.HasError() {
		return NewCustomProbesValueUnknown(), diags
	}

	return CustomProbesValue{
		Aggressiveness:   aggressivenessVal,
		Host:             hostVal,
		Port:             portVal,
		Threshold:        thresholdVal,
		CustomProbesType: typeVal,
		Url:              urlVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewCustomProbesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) CustomProbesValue {
	object, diags := NewCustomProbesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewCustomProbesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t CustomProbesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewCustomProbesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewCustomProbesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewCustomProbesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewCustomProbesValueMust(CustomProbesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t CustomProbesType) ValueType(ctx context.Context) attr.Value {
	return CustomProbesValue{}
}

var _ basetypes.ObjectValuable = CustomProbesValue{}

type CustomProbesValue struct {
	Aggressiveness   basetypes.StringValue `tfsdk:"aggressiveness"`
	Host             basetypes.StringValue `tfsdk:"host"`
	Port             basetypes.Int64Value  `tfsdk:"port"`
	Threshold        basetypes.Int64Value  `tfsdk:"threshold"`
	CustomProbesType basetypes.StringValue `tfsdk:"type"`
	Url              basetypes.StringValue `tfsdk:"url"`
	state            attr.ValueState
}

func (v CustomProbesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 6)

	var val tftypes.Value
	var err error

	attrTypes["aggressiveness"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["host"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["port"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["threshold"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["url"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 6)

		val, err = v.Aggressiveness.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["aggressiveness"] = val

		val, err = v.Host.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["host"] = val

		val, err = v.Port.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port"] = val

		val, err = v.Threshold.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["threshold"] = val

		val, err = v.CustomProbesType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		val, err = v.Url.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["url"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v CustomProbesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v CustomProbesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v CustomProbesValue) String() string {
	return "CustomProbesValue"
}

func (v CustomProbesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"aggressiveness": basetypes.StringType{},
		"host":           basetypes.StringType{},
		"port":           basetypes.Int64Type{},
		"threshold":      basetypes.Int64Type{},
		"type":           basetypes.StringType{},
		"url":            basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"aggressiveness": v.Aggressiveness,
			"host":           v.Host,
			"port":           v.Port,
			"threshold":      v.Threshold,
			"type":           v.CustomProbesType,
			"url":            v.Url,
		})

	return objVal, diags
}

func (v CustomProbesValue) Equal(o attr.Value) bool {
	other, ok := o.(CustomProbesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Aggressiveness.Equal(other.Aggressiveness) {
		return false
	}

	if !v.Host.Equal(other.Host) {
		return false
	}

	if !v.Port.Equal(other.Port) {
		return false
	}

	if !v.Threshold.Equal(other.Threshold) {
		return false
	}

	if !v.CustomProbesType.Equal(other.CustomProbesType) {
		return false
	}

	if !v.Url.Equal(other.Url) {
		return false
	}

	return true
}

func (v CustomProbesValue) Type(ctx context.Context) attr.Type {
	return CustomProbesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v CustomProbesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"aggressiveness": basetypes.StringType{},
		"host":           basetypes.StringType{},
		"port":           basetypes.Int64Type{},
		"threshold":      basetypes.Int64Type{},
		"type":           basetypes.StringType{},
		"url":            basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = LanNetworksType{}

type LanNetworksType struct {
	basetypes.ObjectType
}

func (t LanNetworksType) Equal(o attr.Type) bool {
	other, ok := o.(LanNetworksType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t LanNetworksType) String() string {
	return "LanNetworksType"
}

func (t LanNetworksType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	networksAttribute, ok := attributes["networks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`networks is missing from object`)

		return nil, diags
	}

	networksVal, ok := networksAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`networks expected to be basetypes.ListValue, was: %T`, networksAttribute))
	}

	probesAttribute, ok := attributes["probes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`probes is missing from object`)

		return nil, diags
	}

	probesVal, ok := probesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`probes expected to be basetypes.ListValue, was: %T`, probesAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return LanNetworksValue{
		Networks: networksVal,
		Probes:   probesVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewLanNetworksValueNull() LanNetworksValue {
	return LanNetworksValue{
		state: attr.ValueStateNull,
	}
}

func NewLanNetworksValueUnknown() LanNetworksValue {
	return LanNetworksValue{
		state: attr.ValueStateUnknown,
	}
}

func NewLanNetworksValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (LanNetworksValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing LanNetworksValue Attribute Value",
				"While creating a LanNetworksValue value, a missing attribute value was detected. "+
					"A LanNetworksValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("LanNetworksValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid LanNetworksValue Attribute Type",
				"While creating a LanNetworksValue value, an invalid attribute value was detected. "+
					"A LanNetworksValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("LanNetworksValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("LanNetworksValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra LanNetworksValue Attribute Value",
				"While creating a LanNetworksValue value, an extra attribute value was detected. "+
					"A LanNetworksValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra LanNetworksValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewLanNetworksValueUnknown(), diags
	}

	networksAttribute, ok := attributes["networks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`networks is missing from object`)

		return NewLanNetworksValueUnknown(), diags
	}

	networksVal, ok := networksAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`networks expected to be basetypes.ListValue, was: %T`, networksAttribute))
	}

	probesAttribute, ok := attributes["probes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`probes is missing from object`)

		return NewLanNetworksValueUnknown(), diags
	}

	probesVal, ok := probesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`probes expected to be basetypes.ListValue, was: %T`, probesAttribute))
	}

	if diags.HasError() {
		return NewLanNetworksValueUnknown(), diags
	}

	return LanNetworksValue{
		Networks: networksVal,
		Probes:   probesVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewLanNetworksValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) LanNetworksValue {
	object, diags := NewLanNetworksValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewLanNetworksValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t LanNetworksType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewLanNetworksValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewLanNetworksValueUnknown(), nil
	}

	if in.IsNull() {
		return NewLanNetworksValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewLanNetworksValueMust(LanNetworksValue{}.AttributeTypes(ctx), attributes), nil
}

func (t LanNetworksType) ValueType(ctx context.Context) attr.Value {
	return LanNetworksValue{}
}

var _ basetypes.ObjectValuable = LanNetworksValue{}

type LanNetworksValue struct {
	Networks basetypes.ListValue `tfsdk:"networks"`
	Probes   basetypes.ListValue `tfsdk:"probes"`
	state    attr.ValueState
}

func (v LanNetworksValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["networks"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["probes"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Networks.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["networks"] = val

		val, err = v.Probes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["probes"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v LanNetworksValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v LanNetworksValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v LanNetworksValue) String() string {
	return "LanNetworksValue"
}

func (v LanNetworksValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var networksVal basetypes.ListValue
	switch {
	case v.Networks.IsUnknown():
		networksVal = types.ListUnknown(types.StringType)
	case v.Networks.IsNull():
		networksVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		networksVal, d = types.ListValue(types.StringType, v.Networks.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"networks": basetypes.ListType{
				ElemType: types.StringType,
			},
			"probes": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	var probesVal basetypes.ListValue
	switch {
	case v.Probes.IsUnknown():
		probesVal = types.ListUnknown(types.StringType)
	case v.Probes.IsNull():
		probesVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		probesVal, d = types.ListValue(types.StringType, v.Probes.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"networks": basetypes.ListType{
				ElemType: types.StringType,
			},
			"probes": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"networks": basetypes.ListType{
			ElemType: types.StringType,
		},
		"probes": basetypes.ListType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"networks": networksVal,
			"probes":   probesVal,
		})

	return objVal, diags
}

func (v LanNetworksValue) Equal(o attr.Value) bool {
	other, ok := o.(LanNetworksValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Networks.Equal(other.Networks) {
		return false
	}

	if !v.Probes.Equal(other.Probes) {
		return false
	}

	return true
}

func (v LanNetworksValue) Type(ctx context.Context) attr.Type {
	return LanNetworksType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v LanNetworksValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"networks": basetypes.ListType{
			ElemType: types.StringType,
		},
		"probes": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = VlansType{}

type VlansType struct {
	basetypes.ObjectType
}

func (t VlansType) Equal(o attr.Type) bool {
	other, ok := o.(VlansType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t VlansType) String() string {
	return "VlansType"
}

func (t VlansType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	customTestUrlsAttribute, ok := attributes["custom_test_urls"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`custom_test_urls is missing from object`)

		return nil, diags
	}

	customTestUrlsVal, ok := customTestUrlsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`custom_test_urls expected to be basetypes.ListValue, was: %T`, customTestUrlsAttribute))
	}

	disabledAttribute, ok := attributes["disabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disabled is missing from object`)

		return nil, diags
	}

	disabledVal, ok := disabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disabled expected to be basetypes.BoolValue, was: %T`, disabledAttribute))
	}

	probesAttribute, ok := attributes["probes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`probes is missing from object`)

		return nil, diags
	}

	probesVal, ok := probesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`probes expected to be basetypes.ListValue, was: %T`, probesAttribute))
	}

	vlanIdsAttribute, ok := attributes["vlan_ids"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan_ids is missing from object`)

		return nil, diags
	}

	vlanIdsVal, ok := vlanIdsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan_ids expected to be basetypes.ListValue, was: %T`, vlanIdsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return VlansValue{
		CustomTestUrls: customTestUrlsVal,
		Disabled:       disabledVal,
		Probes:         probesVal,
		VlanIds:        vlanIdsVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewVlansValueNull() VlansValue {
	return VlansValue{
		state: attr.ValueStateNull,
	}
}

func NewVlansValueUnknown() VlansValue {
	return VlansValue{
		state: attr.ValueStateUnknown,
	}
}

func NewVlansValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (VlansValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing VlansValue Attribute Value",
				"While creating a VlansValue value, a missing attribute value was detected. "+
					"A VlansValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VlansValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid VlansValue Attribute Type",
				"While creating a VlansValue value, an invalid attribute value was detected. "+
					"A VlansValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VlansValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("VlansValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra VlansValue Attribute Value",
				"While creating a VlansValue value, an extra attribute value was detected. "+
					"A VlansValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra VlansValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewVlansValueUnknown(), diags
	}

	customTestUrlsAttribute, ok := attributes["custom_test_urls"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`custom_test_urls is missing from object`)

		return NewVlansValueUnknown(), diags
	}

	customTestUrlsVal, ok := customTestUrlsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`custom_test_urls expected to be basetypes.ListValue, was: %T`, customTestUrlsAttribute))
	}

	disabledAttribute, ok := attributes["disabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disabled is missing from object`)

		return NewVlansValueUnknown(), diags
	}

	disabledVal, ok := disabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disabled expected to be basetypes.BoolValue, was: %T`, disabledAttribute))
	}

	probesAttribute, ok := attributes["probes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`probes is missing from object`)

		return NewVlansValueUnknown(), diags
	}

	probesVal, ok := probesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`probes expected to be basetypes.ListValue, was: %T`, probesAttribute))
	}

	vlanIdsAttribute, ok := attributes["vlan_ids"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan_ids is missing from object`)

		return NewVlansValueUnknown(), diags
	}

	vlanIdsVal, ok := vlanIdsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan_ids expected to be basetypes.ListValue, was: %T`, vlanIdsAttribute))
	}

	if diags.HasError() {
		return NewVlansValueUnknown(), diags
	}

	return VlansValue{
		CustomTestUrls: customTestUrlsVal,
		Disabled:       disabledVal,
		Probes:         probesVal,
		VlanIds:        vlanIdsVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewVlansValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) VlansValue {
	object, diags := NewVlansValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewVlansValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t VlansType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewVlansValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewVlansValueUnknown(), nil
	}

	if in.IsNull() {
		return NewVlansValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewVlansValueMust(VlansValue{}.AttributeTypes(ctx), attributes), nil
}

func (t VlansType) ValueType(ctx context.Context) attr.Value {
	return VlansValue{}
}

var _ basetypes.ObjectValuable = VlansValue{}

type VlansValue struct {
	CustomTestUrls basetypes.ListValue `tfsdk:"custom_test_urls"`
	Disabled       basetypes.BoolValue `tfsdk:"disabled"`
	Probes         basetypes.ListValue `tfsdk:"probes"`
	VlanIds        basetypes.ListValue `tfsdk:"vlan_ids"`
	state          attr.ValueState
}

func (v VlansValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["custom_test_urls"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["disabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["probes"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["vlan_ids"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.CustomTestUrls.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["custom_test_urls"] = val

		val, err = v.Disabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["disabled"] = val

		val, err = v.Probes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["probes"] = val

		val, err = v.VlanIds.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vlan_ids"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v VlansValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v VlansValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v VlansValue) String() string {
	return "VlansValue"
}

func (v VlansValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var customTestUrlsVal basetypes.ListValue
	switch {
	case v.CustomTestUrls.IsUnknown():
		customTestUrlsVal = types.ListUnknown(types.StringType)
	case v.CustomTestUrls.IsNull():
		customTestUrlsVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		customTestUrlsVal, d = types.ListValue(types.StringType, v.CustomTestUrls.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"custom_test_urls": basetypes.ListType{
				ElemType: types.StringType,
			},
			"disabled": basetypes.BoolType{},
			"probes": basetypes.ListType{
				ElemType: types.StringType,
			},
			"vlan_ids": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	var probesVal basetypes.ListValue
	switch {
	case v.Probes.IsUnknown():
		probesVal = types.ListUnknown(types.StringType)
	case v.Probes.IsNull():
		probesVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		probesVal, d = types.ListValue(types.StringType, v.Probes.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"custom_test_urls": basetypes.ListType{
				ElemType: types.StringType,
			},
			"disabled": basetypes.BoolType{},
			"probes": basetypes.ListType{
				ElemType: types.StringType,
			},
			"vlan_ids": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	var vlanIdsVal basetypes.ListValue
	switch {
	case v.VlanIds.IsUnknown():
		vlanIdsVal = types.ListUnknown(types.StringType)
	case v.VlanIds.IsNull():
		vlanIdsVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		vlanIdsVal, d = types.ListValue(types.StringType, v.VlanIds.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"custom_test_urls": basetypes.ListType{
				ElemType: types.StringType,
			},
			"disabled": basetypes.BoolType{},
			"probes": basetypes.ListType{
				ElemType: types.StringType,
			},
			"vlan_ids": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"custom_test_urls": basetypes.ListType{
			ElemType: types.StringType,
		},
		"disabled": basetypes.BoolType{},
		"probes": basetypes.ListType{
			ElemType: types.StringType,
		},
		"vlan_ids": basetypes.ListType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"custom_test_urls": customTestUrlsVal,
			"disabled":         v.Disabled,
			"probes":           probesVal,
			"vlan_ids":         vlanIdsVal,
		})

	return objVal, diags
}

func (v VlansValue) Equal(o attr.Value) bool {
	other, ok := o.(VlansValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.CustomTestUrls.Equal(other.CustomTestUrls) {
		return false
	}

	if !v.Disabled.Equal(other.Disabled) {
		return false
	}

	if !v.Probes.Equal(other.Probes) {
		return false
	}

	if !v.VlanIds.Equal(other.VlanIds) {
		return false
	}

	return true
}

func (v VlansValue) Type(ctx context.Context) attr.Type {
	return VlansType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v VlansValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"custom_test_urls": basetypes.ListType{
			ElemType: types.StringType,
		},
		"disabled": basetypes.BoolType{},
		"probes": basetypes.ListType{
			ElemType: types.StringType,
		},
		"vlan_ids": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = WanSpeedtestType{}

type WanSpeedtestType struct {
	basetypes.ObjectType
}

func (t WanSpeedtestType) Equal(o attr.Type) bool {
	other, ok := o.(WanSpeedtestType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t WanSpeedtestType) String() string {
	return "WanSpeedtestType"
}

func (t WanSpeedtestType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	timeOfDayAttribute, ok := attributes["time_of_day"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`time_of_day is missing from object`)

		return nil, diags
	}

	timeOfDayVal, ok := timeOfDayAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`time_of_day expected to be basetypes.StringValue, was: %T`, timeOfDayAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return WanSpeedtestValue{
		Enabled:   enabledVal,
		TimeOfDay: timeOfDayVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewWanSpeedtestValueNull() WanSpeedtestValue {
	return WanSpeedtestValue{
		state: attr.ValueStateNull,
	}
}

func NewWanSpeedtestValueUnknown() WanSpeedtestValue {
	return WanSpeedtestValue{
		state: attr.ValueStateUnknown,
	}
}

func NewWanSpeedtestValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (WanSpeedtestValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing WanSpeedtestValue Attribute Value",
				"While creating a WanSpeedtestValue value, a missing attribute value was detected. "+
					"A WanSpeedtestValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("WanSpeedtestValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid WanSpeedtestValue Attribute Type",
				"While creating a WanSpeedtestValue value, an invalid attribute value was detected. "+
					"A WanSpeedtestValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("WanSpeedtestValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("WanSpeedtestValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra WanSpeedtestValue Attribute Value",
				"While creating a WanSpeedtestValue value, an extra attribute value was detected. "+
					"A WanSpeedtestValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra WanSpeedtestValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewWanSpeedtestValueUnknown(), diags
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewWanSpeedtestValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	timeOfDayAttribute, ok := attributes["time_of_day"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`time_of_day is missing from object`)

		return NewWanSpeedtestValueUnknown(), diags
	}

	timeOfDayVal, ok := timeOfDayAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`time_of_day expected to be basetypes.StringValue, was: %T`, timeOfDayAttribute))
	}

	if diags.HasError() {
		return NewWanSpeedtestValueUnknown(), diags
	}

	return WanSpeedtestValue{
		Enabled:   enabledVal,
		TimeOfDay: timeOfDayVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewWanSpeedtestValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) WanSpeedtestValue {
	object, diags := NewWanSpeedtestValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewWanSpeedtestValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t WanSpeedtestType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewWanSpeedtestValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewWanSpeedtestValueUnknown(), nil
	}

	if in.IsNull() {
		return NewWanSpeedtestValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewWanSpeedtestValueMust(WanSpeedtestValue{}.AttributeTypes(ctx), attributes), nil
}

func (t WanSpeedtestType) ValueType(ctx context.Context) attr.Value {
	return WanSpeedtestValue{}
}

var _ basetypes.ObjectValuable = WanSpeedtestValue{}

type WanSpeedtestValue struct {
	Enabled   basetypes.BoolValue   `tfsdk:"enabled"`
	TimeOfDay basetypes.StringValue `tfsdk:"time_of_day"`
	state     attr.ValueState
}

func (v WanSpeedtestValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["time_of_day"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.TimeOfDay.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["time_of_day"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v WanSpeedtestValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v WanSpeedtestValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v WanSpeedtestValue) String() string {
	return "WanSpeedtestValue"
}

func (v WanSpeedtestValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"enabled":     basetypes.BoolType{},
		"time_of_day": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"enabled":     v.Enabled,
			"time_of_day": v.TimeOfDay,
		})

	return objVal, diags
}

func (v WanSpeedtestValue) Equal(o attr.Value) bool {
	other, ok := o.(WanSpeedtestValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.TimeOfDay.Equal(other.TimeOfDay) {
		return false
	}

	return true
}

func (v WanSpeedtestValue) Type(ctx context.Context) attr.Type {
	return WanSpeedtestType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v WanSpeedtestValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"enabled":     basetypes.BoolType{},
		"time_of_day": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = VpnOptionsType{}

type VpnOptionsType struct {
	basetypes.ObjectType
}

func (t VpnOptionsType) Equal(o attr.Type) bool {
	other, ok := o.(VpnOptionsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t VpnOptionsType) String() string {
	return "VpnOptionsType"
}

func (t VpnOptionsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	asBaseAttribute, ok := attributes["as_base"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`as_base is missing from object`)

		return nil, diags
	}

	asBaseVal, ok := asBaseAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`as_base expected to be basetypes.Int64Value, was: %T`, asBaseAttribute))
	}

	enableIpv6Attribute, ok := attributes["enable_ipv6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable_ipv6 is missing from object`)

		return nil, diags
	}

	enableIpv6Val, ok := enableIpv6Attribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable_ipv6 expected to be basetypes.BoolValue, was: %T`, enableIpv6Attribute))
	}

	stSubnetAttribute, ok := attributes["st_subnet"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`st_subnet is missing from object`)

		return nil, diags
	}

	stSubnetVal, ok := stSubnetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`st_subnet expected to be basetypes.StringValue, was: %T`, stSubnetAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return VpnOptionsValue{
		AsBase:     asBaseVal,
		EnableIpv6: enableIpv6Val,
		StSubnet:   stSubnetVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewVpnOptionsValueNull() VpnOptionsValue {
	return VpnOptionsValue{
		state: attr.ValueStateNull,
	}
}

func NewVpnOptionsValueUnknown() VpnOptionsValue {
	return VpnOptionsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewVpnOptionsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (VpnOptionsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing VpnOptionsValue Attribute Value",
				"While creating a VpnOptionsValue value, a missing attribute value was detected. "+
					"A VpnOptionsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VpnOptionsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid VpnOptionsValue Attribute Type",
				"While creating a VpnOptionsValue value, an invalid attribute value was detected. "+
					"A VpnOptionsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VpnOptionsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("VpnOptionsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra VpnOptionsValue Attribute Value",
				"While creating a VpnOptionsValue value, an extra attribute value was detected. "+
					"A VpnOptionsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra VpnOptionsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewVpnOptionsValueUnknown(), diags
	}

	asBaseAttribute, ok := attributes["as_base"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`as_base is missing from object`)

		return NewVpnOptionsValueUnknown(), diags
	}

	asBaseVal, ok := asBaseAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`as_base expected to be basetypes.Int64Value, was: %T`, asBaseAttribute))
	}

	enableIpv6Attribute, ok := attributes["enable_ipv6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable_ipv6 is missing from object`)

		return NewVpnOptionsValueUnknown(), diags
	}

	enableIpv6Val, ok := enableIpv6Attribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable_ipv6 expected to be basetypes.BoolValue, was: %T`, enableIpv6Attribute))
	}

	stSubnetAttribute, ok := attributes["st_subnet"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`st_subnet is missing from object`)

		return NewVpnOptionsValueUnknown(), diags
	}

	stSubnetVal, ok := stSubnetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`st_subnet expected to be basetypes.StringValue, was: %T`, stSubnetAttribute))
	}

	if diags.HasError() {
		return NewVpnOptionsValueUnknown(), diags
	}

	return VpnOptionsValue{
		AsBase:     asBaseVal,
		EnableIpv6: enableIpv6Val,
		StSubnet:   stSubnetVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewVpnOptionsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) VpnOptionsValue {
	object, diags := NewVpnOptionsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewVpnOptionsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t VpnOptionsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewVpnOptionsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewVpnOptionsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewVpnOptionsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewVpnOptionsValueMust(VpnOptionsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t VpnOptionsType) ValueType(ctx context.Context) attr.Value {
	return VpnOptionsValue{}
}

var _ basetypes.ObjectValuable = VpnOptionsValue{}

type VpnOptionsValue struct {
	AsBase     basetypes.Int64Value  `tfsdk:"as_base"`
	EnableIpv6 basetypes.BoolValue   `tfsdk:"enable_ipv6"`
	StSubnet   basetypes.StringValue `tfsdk:"st_subnet"`
	state      attr.ValueState
}

func (v VpnOptionsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["as_base"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["enable_ipv6"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["st_subnet"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.AsBase.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["as_base"] = val

		val, err = v.EnableIpv6.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enable_ipv6"] = val

		val, err = v.StSubnet.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["st_subnet"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v VpnOptionsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v VpnOptionsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v VpnOptionsValue) String() string {
	return "VpnOptionsValue"
}

func (v VpnOptionsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"as_base":     basetypes.Int64Type{},
		"enable_ipv6": basetypes.BoolType{},
		"st_subnet":   basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"as_base":     v.AsBase,
			"enable_ipv6": v.EnableIpv6,
			"st_subnet":   v.StSubnet,
		})

	return objVal, diags
}

func (v VpnOptionsValue) Equal(o attr.Value) bool {
	other, ok := o.(VpnOptionsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AsBase.Equal(other.AsBase) {
		return false
	}

	if !v.EnableIpv6.Equal(other.EnableIpv6) {
		return false
	}

	if !v.StSubnet.Equal(other.StSubnet) {
		return false
	}

	return true
}

func (v VpnOptionsValue) Type(ctx context.Context) attr.Type {
	return VpnOptionsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v VpnOptionsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"as_base":     basetypes.Int64Type{},
		"enable_ipv6": basetypes.BoolType{},
		"st_subnet":   basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = WanPmaType{}

type WanPmaType struct {
	basetypes.ObjectType
}

func (t WanPmaType) Equal(o attr.Type) bool {
	other, ok := o.(WanPmaType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t WanPmaType) String() string {
	return "WanPmaType"
}

func (t WanPmaType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return WanPmaValue{
		Enabled: enabledVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewWanPmaValueNull() WanPmaValue {
	return WanPmaValue{
		state: attr.ValueStateNull,
	}
}

func NewWanPmaValueUnknown() WanPmaValue {
	return WanPmaValue{
		state: attr.ValueStateUnknown,
	}
}

func NewWanPmaValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (WanPmaValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing WanPmaValue Attribute Value",
				"While creating a WanPmaValue value, a missing attribute value was detected. "+
					"A WanPmaValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("WanPmaValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid WanPmaValue Attribute Type",
				"While creating a WanPmaValue value, an invalid attribute value was detected. "+
					"A WanPmaValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("WanPmaValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("WanPmaValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra WanPmaValue Attribute Value",
				"While creating a WanPmaValue value, an extra attribute value was detected. "+
					"A WanPmaValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra WanPmaValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewWanPmaValueUnknown(), diags
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewWanPmaValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	if diags.HasError() {
		return NewWanPmaValueUnknown(), diags
	}

	return WanPmaValue{
		Enabled: enabledVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewWanPmaValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) WanPmaValue {
	object, diags := NewWanPmaValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewWanPmaValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t WanPmaType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewWanPmaValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewWanPmaValueUnknown(), nil
	}

	if in.IsNull() {
		return NewWanPmaValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewWanPmaValueMust(WanPmaValue{}.AttributeTypes(ctx), attributes), nil
}

func (t WanPmaType) ValueType(ctx context.Context) attr.Value {
	return WanPmaValue{}
}

var _ basetypes.ObjectValuable = WanPmaValue{}

type WanPmaValue struct {
	Enabled basetypes.BoolValue `tfsdk:"enabled"`
	state   attr.ValueState
}

func (v WanPmaValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v WanPmaValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v WanPmaValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v WanPmaValue) String() string {
	return "WanPmaValue"
}

func (v WanPmaValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"enabled": basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"enabled": v.Enabled,
		})

	return objVal, diags
}

func (v WanPmaValue) Equal(o attr.Value) bool {
	other, ok := o.(WanPmaValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	return true
}

func (v WanPmaValue) Type(ctx context.Context) attr.Type {
	return WanPmaType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v WanPmaValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"enabled": basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = WiredPmaType{}

type WiredPmaType struct {
	basetypes.ObjectType
}

func (t WiredPmaType) Equal(o attr.Type) bool {
	other, ok := o.(WiredPmaType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t WiredPmaType) String() string {
	return "WiredPmaType"
}

func (t WiredPmaType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return WiredPmaValue{
		Enabled: enabledVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewWiredPmaValueNull() WiredPmaValue {
	return WiredPmaValue{
		state: attr.ValueStateNull,
	}
}

func NewWiredPmaValueUnknown() WiredPmaValue {
	return WiredPmaValue{
		state: attr.ValueStateUnknown,
	}
}

func NewWiredPmaValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (WiredPmaValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing WiredPmaValue Attribute Value",
				"While creating a WiredPmaValue value, a missing attribute value was detected. "+
					"A WiredPmaValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("WiredPmaValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid WiredPmaValue Attribute Type",
				"While creating a WiredPmaValue value, an invalid attribute value was detected. "+
					"A WiredPmaValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("WiredPmaValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("WiredPmaValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra WiredPmaValue Attribute Value",
				"While creating a WiredPmaValue value, an extra attribute value was detected. "+
					"A WiredPmaValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra WiredPmaValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewWiredPmaValueUnknown(), diags
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewWiredPmaValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	if diags.HasError() {
		return NewWiredPmaValueUnknown(), diags
	}

	return WiredPmaValue{
		Enabled: enabledVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewWiredPmaValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) WiredPmaValue {
	object, diags := NewWiredPmaValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewWiredPmaValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t WiredPmaType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewWiredPmaValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewWiredPmaValueUnknown(), nil
	}

	if in.IsNull() {
		return NewWiredPmaValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewWiredPmaValueMust(WiredPmaValue{}.AttributeTypes(ctx), attributes), nil
}

func (t WiredPmaType) ValueType(ctx context.Context) attr.Value {
	return WiredPmaValue{}
}

var _ basetypes.ObjectValuable = WiredPmaValue{}

type WiredPmaValue struct {
	Enabled basetypes.BoolValue `tfsdk:"enabled"`
	state   attr.ValueState
}

func (v WiredPmaValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v WiredPmaValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v WiredPmaValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v WiredPmaValue) String() string {
	return "WiredPmaValue"
}

func (v WiredPmaValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"enabled": basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"enabled": v.Enabled,
		})

	return objVal, diags
}

func (v WiredPmaValue) Equal(o attr.Value) bool {
	other, ok := o.(WiredPmaValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	return true
}

func (v WiredPmaValue) Type(ctx context.Context) attr.Type {
	return WiredPmaType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v WiredPmaValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"enabled": basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = WirelessPmaType{}

type WirelessPmaType struct {
	basetypes.ObjectType
}

func (t WirelessPmaType) Equal(o attr.Type) bool {
	other, ok := o.(WirelessPmaType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t WirelessPmaType) String() string {
	return "WirelessPmaType"
}

func (t WirelessPmaType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return WirelessPmaValue{
		Enabled: enabledVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewWirelessPmaValueNull() WirelessPmaValue {
	return WirelessPmaValue{
		state: attr.ValueStateNull,
	}
}

func NewWirelessPmaValueUnknown() WirelessPmaValue {
	return WirelessPmaValue{
		state: attr.ValueStateUnknown,
	}
}

func NewWirelessPmaValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (WirelessPmaValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing WirelessPmaValue Attribute Value",
				"While creating a WirelessPmaValue value, a missing attribute value was detected. "+
					"A WirelessPmaValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("WirelessPmaValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid WirelessPmaValue Attribute Type",
				"While creating a WirelessPmaValue value, an invalid attribute value was detected. "+
					"A WirelessPmaValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("WirelessPmaValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("WirelessPmaValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra WirelessPmaValue Attribute Value",
				"While creating a WirelessPmaValue value, an extra attribute value was detected. "+
					"A WirelessPmaValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra WirelessPmaValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewWirelessPmaValueUnknown(), diags
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewWirelessPmaValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	if diags.HasError() {
		return NewWirelessPmaValueUnknown(), diags
	}

	return WirelessPmaValue{
		Enabled: enabledVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewWirelessPmaValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) WirelessPmaValue {
	object, diags := NewWirelessPmaValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewWirelessPmaValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t WirelessPmaType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewWirelessPmaValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewWirelessPmaValueUnknown(), nil
	}

	if in.IsNull() {
		return NewWirelessPmaValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewWirelessPmaValueMust(WirelessPmaValue{}.AttributeTypes(ctx), attributes), nil
}

func (t WirelessPmaType) ValueType(ctx context.Context) attr.Value {
	return WirelessPmaValue{}
}

var _ basetypes.ObjectValuable = WirelessPmaValue{}

type WirelessPmaValue struct {
	Enabled basetypes.BoolValue `tfsdk:"enabled"`
	state   attr.ValueState
}

func (v WirelessPmaValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v WirelessPmaValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v WirelessPmaValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v WirelessPmaValue) String() string {
	return "WirelessPmaValue"
}

func (v WirelessPmaValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"enabled": basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"enabled": v.Enabled,
		})

	return objVal, diags
}

func (v WirelessPmaValue) Equal(o attr.Value) bool {
	other, ok := o.(WirelessPmaValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	return true
}

func (v WirelessPmaValue) Type(ctx context.Context) attr.Type {
	return WirelessPmaType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v WirelessPmaValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"enabled": basetypes.BoolType{},
	}
}
