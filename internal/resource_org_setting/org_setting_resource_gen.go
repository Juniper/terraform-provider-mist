// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package resource_org_setting

import (
	"context"
	"fmt"
	"github.com/Juniper/terraform-provider-mist/internal/validators"
	"github.com/hashicorp/terraform-plugin-framework-validators/int64validator"
	"github.com/hashicorp/terraform-plugin-framework-validators/listvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/booldefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/int64default"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
)

func OrgSettingResourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"ap_updown_threshold": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "enable threshold-based device down delivery for AP devices only. When configured it takes effect for AP devices and `device_updown_threshold` is ignored.",
				MarkdownDescription: "enable threshold-based device down delivery for AP devices only. When configured it takes effect for AP devices and `device_updown_threshold` is ignored.",
				Validators: []validator.Int64{
					int64validator.Between(0, 240),
				},
				Default: int64default.StaticInt64(0),
			},
			"api_policy": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"no_reveal": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "by default, API hides password/secrets when the user doesn't have write access\n  * `true`: API will hide passwords/secrets for all users\n  * `false`: API will hide passwords/secrets for read-only users",
						MarkdownDescription: "by default, API hides password/secrets when the user doesn't have write access\n  * `true`: API will hide passwords/secrets for all users\n  * `false`: API will hide passwords/secrets for read-only users",
						Default:             booldefault.StaticBool(false),
					},
				},
				CustomType: ApiPolicyType{
					ObjectType: types.ObjectType{
						AttrTypes: ApiPolicyValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
			},
			"cacerts": schema.ListAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Computed:            true,
				Description:         "list of PEM-encoded ca certs",
				MarkdownDescription: "list of PEM-encoded ca certs",
				Validators: []validator.List{
					listvalidator.SizeAtLeast(1),
				},
			},
			"celona": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"api_key": schema.StringAttribute{
						Required: true,
					},
					"api_prefix": schema.StringAttribute{
						Required: true,
					},
				},
				CustomType: CelonaType{
					ObjectType: types.ObjectType{
						AttrTypes: CelonaValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
			},
			"cloudshark": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"apitoken": schema.StringAttribute{
						Required:  true,
						Sensitive: true,
					},
					"url": schema.StringAttribute{
						Optional:            true,
						Description:         "if using CS Enteprise",
						MarkdownDescription: "if using CS Enteprise",
					},
				},
				CustomType: CloudsharkType{
					ObjectType: types.ObjectType{
						AttrTypes: CloudsharkValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
			},
			"cradlepoint": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"cp_api_id": schema.StringAttribute{
						Required: true,
					},
					"cp_api_key": schema.StringAttribute{
						Required:  true,
						Sensitive: true,
					},
					"ecm_api_id": schema.StringAttribute{
						Required: true,
					},
					"ecm_api_key": schema.StringAttribute{
						Required:  true,
						Sensitive: true,
					},
				},
				CustomType: CradlepointType{
					ObjectType: types.ObjectType{
						AttrTypes: CradlepointValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
			},
			"device_cert": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"cert": schema.StringAttribute{
						Required: true,
					},
					"key": schema.StringAttribute{
						Required:  true,
						Sensitive: true,
					},
				},
				CustomType: DeviceCertType{
					ObjectType: types.ObjectType{
						AttrTypes: DeviceCertValue{}.AttributeTypes(ctx),
					},
				},
				Optional:            true,
				Description:         "common device cert, optional",
				MarkdownDescription: "common device cert, optional",
			},
			"device_updown_threshold": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "enable threshold-based device down delivery via\n  * device-updowns webhooks topic, \n  * Mist Alert Framework; e.g. send AP/SW/GW down event only if AP/SW/GW Up is not seen within the threshold in minutes; 0 - 240, default is 0 (trigger immediate)",
				MarkdownDescription: "enable threshold-based device down delivery via\n  * device-updowns webhooks topic, \n  * Mist Alert Framework; e.g. send AP/SW/GW down event only if AP/SW/GW Up is not seen within the threshold in minutes; 0 - 240, default is 0 (trigger immediate)",
				Validators: []validator.Int64{
					int64validator.Between(0, 240),
				},
				Default: int64default.StaticInt64(0),
			},
			"disable_pcap": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "whether to disallow Mist to analyze pcap files (this is required for marvis pcap)",
				MarkdownDescription: "whether to disallow Mist to analyze pcap files (this is required for marvis pcap)",
				Default:             booldefault.StaticBool(false),
			},
			"disable_remote_shell": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "whether to disable remote shell access for an entire org",
				MarkdownDescription: "whether to disable remote shell access for an entire org",
				Default:             booldefault.StaticBool(false),
			},
			"gateway_updown_threshold": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "enable threshold-based device down delivery for Gateway devices only. When configured it takes effect for GW devices and `device_updown_threshold` is ignored.",
				MarkdownDescription: "enable threshold-based device down delivery for Gateway devices only. When configured it takes effect for GW devices and `device_updown_threshold` is ignored.",
				Validators: []validator.Int64{
					int64validator.Between(0, 240),
				},
				Default: int64default.StaticInt64(0),
			},
			"installer": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"allow_all_devices": schema.BoolAttribute{
						Optional: true,
					},
					"allow_all_sites": schema.BoolAttribute{
						Optional: true,
					},
					"extra_site_ids": schema.ListAttribute{
						ElementType: types.StringType,
						Optional:    true,
						Computed:    true,
						Validators: []validator.List{
							listvalidator.SizeAtLeast(1),
						},
					},
					"grace_period": schema.Int64Attribute{
						Optional: true,
					},
				},
				CustomType: InstallerType{
					ObjectType: types.ObjectType{
						AttrTypes: InstallerValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
			},
			"jcloud": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"org_apitoken": schema.StringAttribute{
						Required:            true,
						Description:         "JCloud Org Token",
						MarkdownDescription: "JCloud Org Token",
					},
					"org_apitoken_name": schema.StringAttribute{
						Required:            true,
						Description:         "JCloud Org Token Name",
						MarkdownDescription: "JCloud Org Token Name",
					},
					"org_id": schema.StringAttribute{
						Required:            true,
						Description:         "JCloud Org ID",
						MarkdownDescription: "JCloud Org ID",
					},
				},
				CustomType: JcloudType{
					ObjectType: types.ObjectType{
						AttrTypes: JcloudValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
			},
			"juniper": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"accounts": schema.ListNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"linked_by": schema.StringAttribute{
									Computed: true,
								},
								"name": schema.StringAttribute{
									Computed: true,
								},
							},
							CustomType: AccountsType{
								ObjectType: types.ObjectType{
									AttrTypes: AccountsValue{}.AttributeTypes(ctx),
								},
							},
						},
						Computed: true,
					},
				},
				CustomType: JuniperType{
					ObjectType: types.ObjectType{
						AttrTypes: JuniperValue{}.AttributeTypes(ctx),
					},
				},
				Computed: true,
			},
			"mgmt": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"mxtunnel_ids": schema.ListAttribute{
						ElementType:         types.StringType,
						Optional:            true,
						Computed:            true,
						Description:         "list of Mist Tunnels",
						MarkdownDescription: "list of Mist Tunnels",
						Validators: []validator.List{
							listvalidator.SizeAtLeast(1),
						},
					},
					"use_mxtunnel": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "whether to use Mist Tunnel for mgmt connectivity, this takes precedence over use_wxtunnel",
						MarkdownDescription: "whether to use Mist Tunnel for mgmt connectivity, this takes precedence over use_wxtunnel",
						Default:             booldefault.StaticBool(false),
					},
					"use_wxtunnel": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "whether to use wxtunnel for mgmt connectivity",
						MarkdownDescription: "whether to use wxtunnel for mgmt connectivity",
						Default:             booldefault.StaticBool(false),
					},
				},
				CustomType: MgmtType{
					ObjectType: types.ObjectType{
						AttrTypes: MgmtValue{}.AttributeTypes(ctx),
					},
				},
				Optional:            true,
				Description:         "management-related properties",
				MarkdownDescription: "management-related properties",
			},
			"mist_nac": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"cacerts": schema.ListAttribute{
						ElementType:         types.StringType,
						Optional:            true,
						Computed:            true,
						Description:         "list of PEM-encoded ca certs",
						MarkdownDescription: "list of PEM-encoded ca certs",
						Validators: []validator.List{
							listvalidator.SizeAtLeast(1),
						},
					},
					"default_idp_id": schema.StringAttribute{
						Optional:            true,
						Description:         "use this IDP when no explicit realm present in the incoming username/CN OR when no IDP is explicitly mapped to the incoming realm.",
						MarkdownDescription: "use this IDP when no explicit realm present in the incoming username/CN OR when no IDP is explicitly mapped to the incoming realm.",
					},
					"eap_ssl_security_level": schema.Int64Attribute{
						Optional:            true,
						Computed:            true,
						Description:         "eap ssl security level\nsee https://www.openssl.org/docs/man1.1.1/man3/SSL_CTX_set_security_level.html#DEFAULT-CALLBACK-BEHAVIOUR",
						MarkdownDescription: "eap ssl security level\nsee https://www.openssl.org/docs/man1.1.1/man3/SSL_CTX_set_security_level.html#DEFAULT-CALLBACK-BEHAVIOUR",
						Validators: []validator.Int64{
							int64validator.Between(1, 4),
						},
						Default: int64default.StaticInt64(2),
					},
					"eu_only": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "By default NAC POD failover considers all NAC pods available around the globe, i.e. EU, US, or APAC based, failover happens based on geo IP of the originating site.\nFor strict GDPR compliancy NAC POD failover would only happen between the PODs located within the EU environment, and no authentication would take place outside of EU. This is an org setting that is applicable to WLANs, switch templates, mxedge clusters that have mist_nac enabled",
						MarkdownDescription: "By default NAC POD failover considers all NAC pods available around the globe, i.e. EU, US, or APAC based, failover happens based on geo IP of the originating site.\nFor strict GDPR compliancy NAC POD failover would only happen between the PODs located within the EU environment, and no authentication would take place outside of EU. This is an org setting that is applicable to WLANs, switch templates, mxedge clusters that have mist_nac enabled",
						Default:             booldefault.StaticBool(false),
					},
					"idps": schema.ListNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"exclude_realms": schema.ListAttribute{
									ElementType:         types.StringType,
									Optional:            true,
									Computed:            true,
									Description:         "when the IDP of mxedge_proxy type, exclude the following realms from proxying in addition to other valid home realms in this org",
									MarkdownDescription: "when the IDP of mxedge_proxy type, exclude the following realms from proxying in addition to other valid home realms in this org",
									Validators: []validator.List{
										listvalidator.SizeAtLeast(1),
									},
								},
								"id": schema.StringAttribute{
									Optional: true,
								},
								"user_realms": schema.ListAttribute{
									ElementType:         types.StringType,
									Optional:            true,
									Computed:            true,
									Description:         "which realm should trigger this IDP. User Realm is extracted from:\n  * Username-AVP (`mist.com` from john@mist.com)\n  * Cert CN",
									MarkdownDescription: "which realm should trigger this IDP. User Realm is extracted from:\n  * Username-AVP (`mist.com` from john@mist.com)\n  * Cert CN",
									Validators: []validator.List{
										listvalidator.SizeAtLeast(1),
									},
								},
							},
							CustomType: IdpsType{
								ObjectType: types.ObjectType{
									AttrTypes: IdpsValue{}.AttributeTypes(ctx),
								},
							},
						},
						Optional: true,
						Computed: true,
						Validators: []validator.List{
							listvalidator.SizeAtLeast(1),
						},
					},
					"server_cert": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"cert": schema.StringAttribute{
								Optional: true,
							},
							"key": schema.StringAttribute{
								Optional:  true,
								Sensitive: true,
							},
							"password": schema.StringAttribute{
								Optional:            true,
								Sensitive:           true,
								Description:         "private key password (optional)",
								MarkdownDescription: "private key password (optional)",
							},
						},
						CustomType: ServerCertType{
							ObjectType: types.ObjectType{
								AttrTypes: ServerCertValue{}.AttributeTypes(ctx),
							},
						},
						Optional:            true,
						Description:         "radius server cert to be presented in EAP TLS",
						MarkdownDescription: "radius server cert to be presented in EAP TLS",
					},
					"use_ip_version": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "by default NAS devices(switches/aps) and proxies(mxedge) are configured to reach mist-nac via IPv4",
						MarkdownDescription: "by default NAS devices(switches/aps) and proxies(mxedge) are configured to reach mist-nac via IPv4",
						Validators: []validator.String{
							stringvalidator.OneOf(
								"",
								"v4",
								"v6",
							),
						},
						Default: stringdefault.StaticString("v4"),
					},
					"use_ssl_port": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "By default NAS devices (switches/aps) and proxies(mxedge) are configured to use port TCP2083(radsec) to reach mist-nac. \nSet `use_ssl_port`==`true` to override that port with TCP43 (ssl), \nThis is a org level setting that is applicable to wlans, switch_templates, and mxedge_clusters that have mist-nac enabled",
						MarkdownDescription: "By default NAS devices (switches/aps) and proxies(mxedge) are configured to use port TCP2083(radsec) to reach mist-nac. \nSet `use_ssl_port`==`true` to override that port with TCP43 (ssl), \nThis is a org level setting that is applicable to wlans, switch_templates, and mxedge_clusters that have mist-nac enabled",
						Default:             booldefault.StaticBool(false),
					},
				},
				CustomType: MistNacType{
					ObjectType: types.ObjectType{
						AttrTypes: MistNacValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
			},
			"mxedge_fips_enabled": schema.BoolAttribute{
				Optional: true,
				Computed: true,
				Default:  booldefault.StaticBool(false),
			},
			"mxedge_mgmt": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"fips_enabled": schema.BoolAttribute{
						Optional: true,
						Computed: true,
						Default:  booldefault.StaticBool(false),
					},
					"mist_password": schema.StringAttribute{
						Optional:  true,
						Sensitive: true,
					},
					"oob_ip_type": schema.StringAttribute{
						Optional: true,
						Computed: true,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"",
								"dhcp",
								"static",
								"disabled",
							),
						},
						Default: stringdefault.StaticString("dhcp"),
					},
					"oob_ip_type6": schema.StringAttribute{
						Optional: true,
						Computed: true,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"",
								"autoconf",
								"dhcp",
								"static",
								"disabled",
							),
						},
						Default: stringdefault.StaticString("autoconf"),
					},
					"root_password": schema.StringAttribute{
						Optional:  true,
						Sensitive: true,
					},
				},
				CustomType: MxedgeMgmtType{
					ObjectType: types.ObjectType{
						AttrTypes: MxedgeMgmtValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
			},
			"org_id": schema.StringAttribute{
				Required: true,
			},
			"password_policy": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"enabled": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "whether the policy is enabled",
						MarkdownDescription: "whether the policy is enabled",
						Default:             booldefault.StaticBool(false),
					},
					"freshness": schema.Int64Attribute{
						Optional:            true,
						Description:         "days, required if password policy is enabled",
						MarkdownDescription: "days, required if password policy is enabled",
					},
					"min_length": schema.Int64Attribute{
						Optional:            true,
						Computed:            true,
						Description:         "required password length",
						MarkdownDescription: "required password length",
						Default:             int64default.StaticInt64(8),
					},
					"requires_special_char": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "whether to require special character",
						MarkdownDescription: "whether to require special character",
						Default:             booldefault.StaticBool(false),
					},
					"requires_two_factor_auth": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "whether to require two-factor auth",
						MarkdownDescription: "whether to require two-factor auth",
						Default:             booldefault.StaticBool(false),
					},
				},
				CustomType: PasswordPolicyType{
					ObjectType: types.ObjectType{
						AttrTypes: PasswordPolicyValue{}.AttributeTypes(ctx),
					},
				},
				Optional:            true,
				Description:         "password policy",
				MarkdownDescription: "password policy",
			},
			"pcap": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"bucket": schema.StringAttribute{
						Optional: true,
					},
					"max_pkt_len": schema.Int64Attribute{
						Optional:            true,
						Computed:            true,
						Description:         "max_len of non-management packets to capture",
						MarkdownDescription: "max_len of non-management packets to capture",
						Validators: []validator.Int64{
							int64validator.AtMost(128),
						},
						Default: int64default.StaticInt64(128),
					},
				},
				CustomType: PcapType{
					ObjectType: types.ObjectType{
						AttrTypes: PcapValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
			},
			"security": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"disable_local_ssh": schema.BoolAttribute{
						Optional:            true,
						Description:         "whether to disable local SSH (by default, local SSH is enabled with allow_mist in Org is enabled",
						MarkdownDescription: "whether to disable local SSH (by default, local SSH is enabled with allow_mist in Org is enabled",
					},
					"fips_zeroize_password": schema.StringAttribute{
						Optional:            true,
						Sensitive:           true,
						Description:         "password required to zeroize devices (FIPS) on site level",
						MarkdownDescription: "password required to zeroize devices (FIPS) on site level",
					},
					"limit_ssh_access": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "whether to allow certain SSH keys to SSH into the AP (see Site:Setting)",
						MarkdownDescription: "whether to allow certain SSH keys to SSH into the AP (see Site:Setting)",
						Default:             booldefault.StaticBool(false),
					},
				},
				CustomType: SecurityType{
					ObjectType: types.ObjectType{
						AttrTypes: SecurityValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
			},
			"switch_mgmt": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"ap_affinity_threshold": schema.Int64Attribute{
						Optional:            true,
						Computed:            true,
						Description:         "If the field is set in both site/setting and org/setting, the value from site/setting will be used.",
						MarkdownDescription: "If the field is set in both site/setting and org/setting, the value from site/setting will be used.",
						Default:             int64default.StaticInt64(12),
					},
				},
				CustomType: SwitchMgmtType{
					ObjectType: types.ObjectType{
						AttrTypes: SwitchMgmtValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
			},
			"switch_updown_threshold": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "enable threshold-based device down delivery for Switch devices only. When configured it takes effect for SW devices and `device_updown_threshold` is ignored.",
				MarkdownDescription: "enable threshold-based device down delivery for Switch devices only. When configured it takes effect for SW devices and `device_updown_threshold` is ignored.",
				Validators: []validator.Int64{
					int64validator.Between(0, 240),
				},
				Default: int64default.StaticInt64(0),
			},
			"synthetic_test": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"disabled": schema.BoolAttribute{
						Optional: true,
						Computed: true,
						Default:  booldefault.StaticBool(false),
					},
					"vlans": schema.ListNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"custom_test_urls": schema.ListAttribute{
									ElementType: types.StringType,
									Optional:    true,
									Computed:    true,
									Validators: []validator.List{
										listvalidator.SizeAtLeast(1),
									},
								},
								"disabled": schema.BoolAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "for some vlans where we don't want this to run",
									MarkdownDescription: "for some vlans where we don't want this to run",
									Default:             booldefault.StaticBool(false),
								},
								"vlan_ids": schema.ListAttribute{
									ElementType: types.StringType,
									Optional:    true,
									Computed:    true,
									Validators: []validator.List{
										listvalidator.SizeAtLeast(1),
										listvalidator.ValueStringsAre(
											stringvalidator.Any(
												mistvalidator.ParseInt(1, 4094),
												mistvalidator.ParseVar(),
											),
										),
									},
								},
							},
							CustomType: VlansType{
								ObjectType: types.ObjectType{
									AttrTypes: VlansValue{}.AttributeTypes(ctx),
								},
							},
						},
						Optional: true,
						Validators: []validator.List{
							listvalidator.SizeAtLeast(1),
						},
					},
					"wan_speedtest": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"enabled": schema.BoolAttribute{
								Optional: true,
							},
							"time_od_fay": schema.StringAttribute{
								Optional:            true,
								Computed:            true,
								Description:         "any / HH:MM (24-hour format)",
								MarkdownDescription: "any / HH:MM (24-hour format)",
								Default:             stringdefault.StaticString("any"),
							},
						},
						CustomType: WanSpeedtestType{
							ObjectType: types.ObjectType{
								AttrTypes: WanSpeedtestValue{}.AttributeTypes(ctx),
							},
						},
						Optional: true,
					},
				},
				CustomType: SyntheticTestType{
					ObjectType: types.ObjectType{
						AttrTypes: SyntheticTestValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
			},
			"ui_idle_timeout": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "automatically logout the user when UI session is inactive. `0` means disabled",
				MarkdownDescription: "automatically logout the user when UI session is inactive. `0` means disabled",
				Validators: []validator.Int64{
					int64validator.Between(0, 480),
				},
				Default: int64default.StaticInt64(0),
			},
			"vpn_options": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"as_base": schema.Int64Attribute{
						Optional: true,
						Validators: []validator.Int64{
							int64validator.Between(1, 4294967295),
						},
					},
					"st_subnet": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "equiring /12 or bigger to support 16 private IPs for 65535 gateways",
						MarkdownDescription: "equiring /12 or bigger to support 16 private IPs for 65535 gateways",
						Default:             stringdefault.StaticString("10.224.0.0/12"),
					},
				},
				CustomType: VpnOptionsType{
					ObjectType: types.ObjectType{
						AttrTypes: VpnOptionsValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
			},
		},
	}
}

type OrgSettingModel struct {
	ApUpdownThreshold      types.Int64         `tfsdk:"ap_updown_threshold"`
	ApiPolicy              ApiPolicyValue      `tfsdk:"api_policy"`
	Cacerts                types.List          `tfsdk:"cacerts"`
	Celona                 CelonaValue         `tfsdk:"celona"`
	Cloudshark             CloudsharkValue     `tfsdk:"cloudshark"`
	Cradlepoint            CradlepointValue    `tfsdk:"cradlepoint"`
	DeviceCert             DeviceCertValue     `tfsdk:"device_cert"`
	DeviceUpdownThreshold  types.Int64         `tfsdk:"device_updown_threshold"`
	DisablePcap            types.Bool          `tfsdk:"disable_pcap"`
	DisableRemoteShell     types.Bool          `tfsdk:"disable_remote_shell"`
	GatewayUpdownThreshold types.Int64         `tfsdk:"gateway_updown_threshold"`
	Installer              InstallerValue      `tfsdk:"installer"`
	Jcloud                 JcloudValue         `tfsdk:"jcloud"`
	Juniper                JuniperValue        `tfsdk:"juniper"`
	Mgmt                   MgmtValue           `tfsdk:"mgmt"`
	MistNac                MistNacValue        `tfsdk:"mist_nac"`
	MxedgeFipsEnabled      types.Bool          `tfsdk:"mxedge_fips_enabled"`
	MxedgeMgmt             MxedgeMgmtValue     `tfsdk:"mxedge_mgmt"`
	OrgId                  types.String        `tfsdk:"org_id"`
	PasswordPolicy         PasswordPolicyValue `tfsdk:"password_policy"`
	Pcap                   PcapValue           `tfsdk:"pcap"`
	Security               SecurityValue       `tfsdk:"security"`
	SwitchMgmt             SwitchMgmtValue     `tfsdk:"switch_mgmt"`
	SwitchUpdownThreshold  types.Int64         `tfsdk:"switch_updown_threshold"`
	SyntheticTest          SyntheticTestValue  `tfsdk:"synthetic_test"`
	UiIdleTimeout          types.Int64         `tfsdk:"ui_idle_timeout"`
	VpnOptions             VpnOptionsValue     `tfsdk:"vpn_options"`
}

var _ basetypes.ObjectTypable = ApiPolicyType{}

type ApiPolicyType struct {
	basetypes.ObjectType
}

func (t ApiPolicyType) Equal(o attr.Type) bool {
	other, ok := o.(ApiPolicyType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ApiPolicyType) String() string {
	return "ApiPolicyType"
}

func (t ApiPolicyType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	noRevealAttribute, ok := attributes["no_reveal"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`no_reveal is missing from object`)

		return nil, diags
	}

	noRevealVal, ok := noRevealAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`no_reveal expected to be basetypes.BoolValue, was: %T`, noRevealAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ApiPolicyValue{
		NoReveal: noRevealVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewApiPolicyValueNull() ApiPolicyValue {
	return ApiPolicyValue{
		state: attr.ValueStateNull,
	}
}

func NewApiPolicyValueUnknown() ApiPolicyValue {
	return ApiPolicyValue{
		state: attr.ValueStateUnknown,
	}
}

func NewApiPolicyValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ApiPolicyValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ApiPolicyValue Attribute Value",
				"While creating a ApiPolicyValue value, a missing attribute value was detected. "+
					"A ApiPolicyValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ApiPolicyValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ApiPolicyValue Attribute Type",
				"While creating a ApiPolicyValue value, an invalid attribute value was detected. "+
					"A ApiPolicyValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ApiPolicyValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ApiPolicyValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ApiPolicyValue Attribute Value",
				"While creating a ApiPolicyValue value, an extra attribute value was detected. "+
					"A ApiPolicyValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ApiPolicyValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewApiPolicyValueUnknown(), diags
	}

	noRevealAttribute, ok := attributes["no_reveal"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`no_reveal is missing from object`)

		return NewApiPolicyValueUnknown(), diags
	}

	noRevealVal, ok := noRevealAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`no_reveal expected to be basetypes.BoolValue, was: %T`, noRevealAttribute))
	}

	if diags.HasError() {
		return NewApiPolicyValueUnknown(), diags
	}

	return ApiPolicyValue{
		NoReveal: noRevealVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewApiPolicyValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ApiPolicyValue {
	object, diags := NewApiPolicyValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewApiPolicyValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ApiPolicyType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewApiPolicyValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewApiPolicyValueUnknown(), nil
	}

	if in.IsNull() {
		return NewApiPolicyValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewApiPolicyValueMust(ApiPolicyValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ApiPolicyType) ValueType(ctx context.Context) attr.Value {
	return ApiPolicyValue{}
}

var _ basetypes.ObjectValuable = ApiPolicyValue{}

type ApiPolicyValue struct {
	NoReveal basetypes.BoolValue `tfsdk:"no_reveal"`
	state    attr.ValueState
}

func (v ApiPolicyValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["no_reveal"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.NoReveal.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["no_reveal"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ApiPolicyValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ApiPolicyValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ApiPolicyValue) String() string {
	return "ApiPolicyValue"
}

func (v ApiPolicyValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"no_reveal": basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"no_reveal": v.NoReveal,
		})

	return objVal, diags
}

func (v ApiPolicyValue) Equal(o attr.Value) bool {
	other, ok := o.(ApiPolicyValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.NoReveal.Equal(other.NoReveal) {
		return false
	}

	return true
}

func (v ApiPolicyValue) Type(ctx context.Context) attr.Type {
	return ApiPolicyType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ApiPolicyValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"no_reveal": basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = CelonaType{}

type CelonaType struct {
	basetypes.ObjectType
}

func (t CelonaType) Equal(o attr.Type) bool {
	other, ok := o.(CelonaType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t CelonaType) String() string {
	return "CelonaType"
}

func (t CelonaType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	apiKeyAttribute, ok := attributes["api_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`api_key is missing from object`)

		return nil, diags
	}

	apiKeyVal, ok := apiKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`api_key expected to be basetypes.StringValue, was: %T`, apiKeyAttribute))
	}

	apiPrefixAttribute, ok := attributes["api_prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`api_prefix is missing from object`)

		return nil, diags
	}

	apiPrefixVal, ok := apiPrefixAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`api_prefix expected to be basetypes.StringValue, was: %T`, apiPrefixAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return CelonaValue{
		ApiKey:    apiKeyVal,
		ApiPrefix: apiPrefixVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewCelonaValueNull() CelonaValue {
	return CelonaValue{
		state: attr.ValueStateNull,
	}
}

func NewCelonaValueUnknown() CelonaValue {
	return CelonaValue{
		state: attr.ValueStateUnknown,
	}
}

func NewCelonaValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (CelonaValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing CelonaValue Attribute Value",
				"While creating a CelonaValue value, a missing attribute value was detected. "+
					"A CelonaValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CelonaValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid CelonaValue Attribute Type",
				"While creating a CelonaValue value, an invalid attribute value was detected. "+
					"A CelonaValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CelonaValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("CelonaValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra CelonaValue Attribute Value",
				"While creating a CelonaValue value, an extra attribute value was detected. "+
					"A CelonaValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra CelonaValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewCelonaValueUnknown(), diags
	}

	apiKeyAttribute, ok := attributes["api_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`api_key is missing from object`)

		return NewCelonaValueUnknown(), diags
	}

	apiKeyVal, ok := apiKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`api_key expected to be basetypes.StringValue, was: %T`, apiKeyAttribute))
	}

	apiPrefixAttribute, ok := attributes["api_prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`api_prefix is missing from object`)

		return NewCelonaValueUnknown(), diags
	}

	apiPrefixVal, ok := apiPrefixAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`api_prefix expected to be basetypes.StringValue, was: %T`, apiPrefixAttribute))
	}

	if diags.HasError() {
		return NewCelonaValueUnknown(), diags
	}

	return CelonaValue{
		ApiKey:    apiKeyVal,
		ApiPrefix: apiPrefixVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewCelonaValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) CelonaValue {
	object, diags := NewCelonaValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewCelonaValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t CelonaType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewCelonaValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewCelonaValueUnknown(), nil
	}

	if in.IsNull() {
		return NewCelonaValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewCelonaValueMust(CelonaValue{}.AttributeTypes(ctx), attributes), nil
}

func (t CelonaType) ValueType(ctx context.Context) attr.Value {
	return CelonaValue{}
}

var _ basetypes.ObjectValuable = CelonaValue{}

type CelonaValue struct {
	ApiKey    basetypes.StringValue `tfsdk:"api_key"`
	ApiPrefix basetypes.StringValue `tfsdk:"api_prefix"`
	state     attr.ValueState
}

func (v CelonaValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["api_key"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["api_prefix"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.ApiKey.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["api_key"] = val

		val, err = v.ApiPrefix.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["api_prefix"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v CelonaValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v CelonaValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v CelonaValue) String() string {
	return "CelonaValue"
}

func (v CelonaValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"api_key":    basetypes.StringType{},
		"api_prefix": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"api_key":    v.ApiKey,
			"api_prefix": v.ApiPrefix,
		})

	return objVal, diags
}

func (v CelonaValue) Equal(o attr.Value) bool {
	other, ok := o.(CelonaValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.ApiKey.Equal(other.ApiKey) {
		return false
	}

	if !v.ApiPrefix.Equal(other.ApiPrefix) {
		return false
	}

	return true
}

func (v CelonaValue) Type(ctx context.Context) attr.Type {
	return CelonaType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v CelonaValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"api_key":    basetypes.StringType{},
		"api_prefix": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = CloudsharkType{}

type CloudsharkType struct {
	basetypes.ObjectType
}

func (t CloudsharkType) Equal(o attr.Type) bool {
	other, ok := o.(CloudsharkType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t CloudsharkType) String() string {
	return "CloudsharkType"
}

func (t CloudsharkType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	apitokenAttribute, ok := attributes["apitoken"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`apitoken is missing from object`)

		return nil, diags
	}

	apitokenVal, ok := apitokenAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`apitoken expected to be basetypes.StringValue, was: %T`, apitokenAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return nil, diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return CloudsharkValue{
		Apitoken: apitokenVal,
		Url:      urlVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewCloudsharkValueNull() CloudsharkValue {
	return CloudsharkValue{
		state: attr.ValueStateNull,
	}
}

func NewCloudsharkValueUnknown() CloudsharkValue {
	return CloudsharkValue{
		state: attr.ValueStateUnknown,
	}
}

func NewCloudsharkValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (CloudsharkValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing CloudsharkValue Attribute Value",
				"While creating a CloudsharkValue value, a missing attribute value was detected. "+
					"A CloudsharkValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CloudsharkValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid CloudsharkValue Attribute Type",
				"While creating a CloudsharkValue value, an invalid attribute value was detected. "+
					"A CloudsharkValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CloudsharkValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("CloudsharkValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra CloudsharkValue Attribute Value",
				"While creating a CloudsharkValue value, an extra attribute value was detected. "+
					"A CloudsharkValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra CloudsharkValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewCloudsharkValueUnknown(), diags
	}

	apitokenAttribute, ok := attributes["apitoken"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`apitoken is missing from object`)

		return NewCloudsharkValueUnknown(), diags
	}

	apitokenVal, ok := apitokenAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`apitoken expected to be basetypes.StringValue, was: %T`, apitokenAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return NewCloudsharkValueUnknown(), diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	if diags.HasError() {
		return NewCloudsharkValueUnknown(), diags
	}

	return CloudsharkValue{
		Apitoken: apitokenVal,
		Url:      urlVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewCloudsharkValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) CloudsharkValue {
	object, diags := NewCloudsharkValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewCloudsharkValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t CloudsharkType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewCloudsharkValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewCloudsharkValueUnknown(), nil
	}

	if in.IsNull() {
		return NewCloudsharkValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewCloudsharkValueMust(CloudsharkValue{}.AttributeTypes(ctx), attributes), nil
}

func (t CloudsharkType) ValueType(ctx context.Context) attr.Value {
	return CloudsharkValue{}
}

var _ basetypes.ObjectValuable = CloudsharkValue{}

type CloudsharkValue struct {
	Apitoken basetypes.StringValue `tfsdk:"apitoken"`
	Url      basetypes.StringValue `tfsdk:"url"`
	state    attr.ValueState
}

func (v CloudsharkValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["apitoken"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["url"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Apitoken.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["apitoken"] = val

		val, err = v.Url.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["url"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v CloudsharkValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v CloudsharkValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v CloudsharkValue) String() string {
	return "CloudsharkValue"
}

func (v CloudsharkValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"apitoken": basetypes.StringType{},
		"url":      basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"apitoken": v.Apitoken,
			"url":      v.Url,
		})

	return objVal, diags
}

func (v CloudsharkValue) Equal(o attr.Value) bool {
	other, ok := o.(CloudsharkValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Apitoken.Equal(other.Apitoken) {
		return false
	}

	if !v.Url.Equal(other.Url) {
		return false
	}

	return true
}

func (v CloudsharkValue) Type(ctx context.Context) attr.Type {
	return CloudsharkType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v CloudsharkValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"apitoken": basetypes.StringType{},
		"url":      basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = CradlepointType{}

type CradlepointType struct {
	basetypes.ObjectType
}

func (t CradlepointType) Equal(o attr.Type) bool {
	other, ok := o.(CradlepointType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t CradlepointType) String() string {
	return "CradlepointType"
}

func (t CradlepointType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	cpApiIdAttribute, ok := attributes["cp_api_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cp_api_id is missing from object`)

		return nil, diags
	}

	cpApiIdVal, ok := cpApiIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cp_api_id expected to be basetypes.StringValue, was: %T`, cpApiIdAttribute))
	}

	cpApiKeyAttribute, ok := attributes["cp_api_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cp_api_key is missing from object`)

		return nil, diags
	}

	cpApiKeyVal, ok := cpApiKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cp_api_key expected to be basetypes.StringValue, was: %T`, cpApiKeyAttribute))
	}

	ecmApiIdAttribute, ok := attributes["ecm_api_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ecm_api_id is missing from object`)

		return nil, diags
	}

	ecmApiIdVal, ok := ecmApiIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ecm_api_id expected to be basetypes.StringValue, was: %T`, ecmApiIdAttribute))
	}

	ecmApiKeyAttribute, ok := attributes["ecm_api_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ecm_api_key is missing from object`)

		return nil, diags
	}

	ecmApiKeyVal, ok := ecmApiKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ecm_api_key expected to be basetypes.StringValue, was: %T`, ecmApiKeyAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return CradlepointValue{
		CpApiId:   cpApiIdVal,
		CpApiKey:  cpApiKeyVal,
		EcmApiId:  ecmApiIdVal,
		EcmApiKey: ecmApiKeyVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewCradlepointValueNull() CradlepointValue {
	return CradlepointValue{
		state: attr.ValueStateNull,
	}
}

func NewCradlepointValueUnknown() CradlepointValue {
	return CradlepointValue{
		state: attr.ValueStateUnknown,
	}
}

func NewCradlepointValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (CradlepointValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing CradlepointValue Attribute Value",
				"While creating a CradlepointValue value, a missing attribute value was detected. "+
					"A CradlepointValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CradlepointValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid CradlepointValue Attribute Type",
				"While creating a CradlepointValue value, an invalid attribute value was detected. "+
					"A CradlepointValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CradlepointValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("CradlepointValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra CradlepointValue Attribute Value",
				"While creating a CradlepointValue value, an extra attribute value was detected. "+
					"A CradlepointValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra CradlepointValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewCradlepointValueUnknown(), diags
	}

	cpApiIdAttribute, ok := attributes["cp_api_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cp_api_id is missing from object`)

		return NewCradlepointValueUnknown(), diags
	}

	cpApiIdVal, ok := cpApiIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cp_api_id expected to be basetypes.StringValue, was: %T`, cpApiIdAttribute))
	}

	cpApiKeyAttribute, ok := attributes["cp_api_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cp_api_key is missing from object`)

		return NewCradlepointValueUnknown(), diags
	}

	cpApiKeyVal, ok := cpApiKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cp_api_key expected to be basetypes.StringValue, was: %T`, cpApiKeyAttribute))
	}

	ecmApiIdAttribute, ok := attributes["ecm_api_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ecm_api_id is missing from object`)

		return NewCradlepointValueUnknown(), diags
	}

	ecmApiIdVal, ok := ecmApiIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ecm_api_id expected to be basetypes.StringValue, was: %T`, ecmApiIdAttribute))
	}

	ecmApiKeyAttribute, ok := attributes["ecm_api_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ecm_api_key is missing from object`)

		return NewCradlepointValueUnknown(), diags
	}

	ecmApiKeyVal, ok := ecmApiKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ecm_api_key expected to be basetypes.StringValue, was: %T`, ecmApiKeyAttribute))
	}

	if diags.HasError() {
		return NewCradlepointValueUnknown(), diags
	}

	return CradlepointValue{
		CpApiId:   cpApiIdVal,
		CpApiKey:  cpApiKeyVal,
		EcmApiId:  ecmApiIdVal,
		EcmApiKey: ecmApiKeyVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewCradlepointValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) CradlepointValue {
	object, diags := NewCradlepointValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewCradlepointValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t CradlepointType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewCradlepointValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewCradlepointValueUnknown(), nil
	}

	if in.IsNull() {
		return NewCradlepointValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewCradlepointValueMust(CradlepointValue{}.AttributeTypes(ctx), attributes), nil
}

func (t CradlepointType) ValueType(ctx context.Context) attr.Value {
	return CradlepointValue{}
}

var _ basetypes.ObjectValuable = CradlepointValue{}

type CradlepointValue struct {
	CpApiId   basetypes.StringValue `tfsdk:"cp_api_id"`
	CpApiKey  basetypes.StringValue `tfsdk:"cp_api_key"`
	EcmApiId  basetypes.StringValue `tfsdk:"ecm_api_id"`
	EcmApiKey basetypes.StringValue `tfsdk:"ecm_api_key"`
	state     attr.ValueState
}

func (v CradlepointValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["cp_api_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["cp_api_key"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ecm_api_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ecm_api_key"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.CpApiId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cp_api_id"] = val

		val, err = v.CpApiKey.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cp_api_key"] = val

		val, err = v.EcmApiId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ecm_api_id"] = val

		val, err = v.EcmApiKey.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ecm_api_key"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v CradlepointValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v CradlepointValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v CradlepointValue) String() string {
	return "CradlepointValue"
}

func (v CradlepointValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"cp_api_id":   basetypes.StringType{},
		"cp_api_key":  basetypes.StringType{},
		"ecm_api_id":  basetypes.StringType{},
		"ecm_api_key": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"cp_api_id":   v.CpApiId,
			"cp_api_key":  v.CpApiKey,
			"ecm_api_id":  v.EcmApiId,
			"ecm_api_key": v.EcmApiKey,
		})

	return objVal, diags
}

func (v CradlepointValue) Equal(o attr.Value) bool {
	other, ok := o.(CradlepointValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.CpApiId.Equal(other.CpApiId) {
		return false
	}

	if !v.CpApiKey.Equal(other.CpApiKey) {
		return false
	}

	if !v.EcmApiId.Equal(other.EcmApiId) {
		return false
	}

	if !v.EcmApiKey.Equal(other.EcmApiKey) {
		return false
	}

	return true
}

func (v CradlepointValue) Type(ctx context.Context) attr.Type {
	return CradlepointType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v CradlepointValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"cp_api_id":   basetypes.StringType{},
		"cp_api_key":  basetypes.StringType{},
		"ecm_api_id":  basetypes.StringType{},
		"ecm_api_key": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = DeviceCertType{}

type DeviceCertType struct {
	basetypes.ObjectType
}

func (t DeviceCertType) Equal(o attr.Type) bool {
	other, ok := o.(DeviceCertType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t DeviceCertType) String() string {
	return "DeviceCertType"
}

func (t DeviceCertType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	certAttribute, ok := attributes["cert"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cert is missing from object`)

		return nil, diags
	}

	certVal, ok := certAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cert expected to be basetypes.StringValue, was: %T`, certAttribute))
	}

	keyAttribute, ok := attributes["key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`key is missing from object`)

		return nil, diags
	}

	keyVal, ok := keyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`key expected to be basetypes.StringValue, was: %T`, keyAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return DeviceCertValue{
		Cert:  certVal,
		Key:   keyVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewDeviceCertValueNull() DeviceCertValue {
	return DeviceCertValue{
		state: attr.ValueStateNull,
	}
}

func NewDeviceCertValueUnknown() DeviceCertValue {
	return DeviceCertValue{
		state: attr.ValueStateUnknown,
	}
}

func NewDeviceCertValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (DeviceCertValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing DeviceCertValue Attribute Value",
				"While creating a DeviceCertValue value, a missing attribute value was detected. "+
					"A DeviceCertValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DeviceCertValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid DeviceCertValue Attribute Type",
				"While creating a DeviceCertValue value, an invalid attribute value was detected. "+
					"A DeviceCertValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DeviceCertValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("DeviceCertValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra DeviceCertValue Attribute Value",
				"While creating a DeviceCertValue value, an extra attribute value was detected. "+
					"A DeviceCertValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra DeviceCertValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewDeviceCertValueUnknown(), diags
	}

	certAttribute, ok := attributes["cert"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cert is missing from object`)

		return NewDeviceCertValueUnknown(), diags
	}

	certVal, ok := certAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cert expected to be basetypes.StringValue, was: %T`, certAttribute))
	}

	keyAttribute, ok := attributes["key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`key is missing from object`)

		return NewDeviceCertValueUnknown(), diags
	}

	keyVal, ok := keyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`key expected to be basetypes.StringValue, was: %T`, keyAttribute))
	}

	if diags.HasError() {
		return NewDeviceCertValueUnknown(), diags
	}

	return DeviceCertValue{
		Cert:  certVal,
		Key:   keyVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewDeviceCertValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) DeviceCertValue {
	object, diags := NewDeviceCertValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewDeviceCertValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t DeviceCertType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewDeviceCertValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewDeviceCertValueUnknown(), nil
	}

	if in.IsNull() {
		return NewDeviceCertValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewDeviceCertValueMust(DeviceCertValue{}.AttributeTypes(ctx), attributes), nil
}

func (t DeviceCertType) ValueType(ctx context.Context) attr.Value {
	return DeviceCertValue{}
}

var _ basetypes.ObjectValuable = DeviceCertValue{}

type DeviceCertValue struct {
	Cert  basetypes.StringValue `tfsdk:"cert"`
	Key   basetypes.StringValue `tfsdk:"key"`
	state attr.ValueState
}

func (v DeviceCertValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["cert"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["key"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Cert.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cert"] = val

		val, err = v.Key.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["key"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v DeviceCertValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v DeviceCertValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v DeviceCertValue) String() string {
	return "DeviceCertValue"
}

func (v DeviceCertValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"cert": basetypes.StringType{},
		"key":  basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"cert": v.Cert,
			"key":  v.Key,
		})

	return objVal, diags
}

func (v DeviceCertValue) Equal(o attr.Value) bool {
	other, ok := o.(DeviceCertValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Cert.Equal(other.Cert) {
		return false
	}

	if !v.Key.Equal(other.Key) {
		return false
	}

	return true
}

func (v DeviceCertValue) Type(ctx context.Context) attr.Type {
	return DeviceCertType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v DeviceCertValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"cert": basetypes.StringType{},
		"key":  basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = InstallerType{}

type InstallerType struct {
	basetypes.ObjectType
}

func (t InstallerType) Equal(o attr.Type) bool {
	other, ok := o.(InstallerType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t InstallerType) String() string {
	return "InstallerType"
}

func (t InstallerType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	allowAllDevicesAttribute, ok := attributes["allow_all_devices"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allow_all_devices is missing from object`)

		return nil, diags
	}

	allowAllDevicesVal, ok := allowAllDevicesAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allow_all_devices expected to be basetypes.BoolValue, was: %T`, allowAllDevicesAttribute))
	}

	allowAllSitesAttribute, ok := attributes["allow_all_sites"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allow_all_sites is missing from object`)

		return nil, diags
	}

	allowAllSitesVal, ok := allowAllSitesAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allow_all_sites expected to be basetypes.BoolValue, was: %T`, allowAllSitesAttribute))
	}

	extraSiteIdsAttribute, ok := attributes["extra_site_ids"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`extra_site_ids is missing from object`)

		return nil, diags
	}

	extraSiteIdsVal, ok := extraSiteIdsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`extra_site_ids expected to be basetypes.ListValue, was: %T`, extraSiteIdsAttribute))
	}

	gracePeriodAttribute, ok := attributes["grace_period"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`grace_period is missing from object`)

		return nil, diags
	}

	gracePeriodVal, ok := gracePeriodAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`grace_period expected to be basetypes.Int64Value, was: %T`, gracePeriodAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return InstallerValue{
		AllowAllDevices: allowAllDevicesVal,
		AllowAllSites:   allowAllSitesVal,
		ExtraSiteIds:    extraSiteIdsVal,
		GracePeriod:     gracePeriodVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewInstallerValueNull() InstallerValue {
	return InstallerValue{
		state: attr.ValueStateNull,
	}
}

func NewInstallerValueUnknown() InstallerValue {
	return InstallerValue{
		state: attr.ValueStateUnknown,
	}
}

func NewInstallerValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (InstallerValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing InstallerValue Attribute Value",
				"While creating a InstallerValue value, a missing attribute value was detected. "+
					"A InstallerValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("InstallerValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid InstallerValue Attribute Type",
				"While creating a InstallerValue value, an invalid attribute value was detected. "+
					"A InstallerValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("InstallerValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("InstallerValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra InstallerValue Attribute Value",
				"While creating a InstallerValue value, an extra attribute value was detected. "+
					"A InstallerValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra InstallerValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewInstallerValueUnknown(), diags
	}

	allowAllDevicesAttribute, ok := attributes["allow_all_devices"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allow_all_devices is missing from object`)

		return NewInstallerValueUnknown(), diags
	}

	allowAllDevicesVal, ok := allowAllDevicesAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allow_all_devices expected to be basetypes.BoolValue, was: %T`, allowAllDevicesAttribute))
	}

	allowAllSitesAttribute, ok := attributes["allow_all_sites"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allow_all_sites is missing from object`)

		return NewInstallerValueUnknown(), diags
	}

	allowAllSitesVal, ok := allowAllSitesAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allow_all_sites expected to be basetypes.BoolValue, was: %T`, allowAllSitesAttribute))
	}

	extraSiteIdsAttribute, ok := attributes["extra_site_ids"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`extra_site_ids is missing from object`)

		return NewInstallerValueUnknown(), diags
	}

	extraSiteIdsVal, ok := extraSiteIdsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`extra_site_ids expected to be basetypes.ListValue, was: %T`, extraSiteIdsAttribute))
	}

	gracePeriodAttribute, ok := attributes["grace_period"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`grace_period is missing from object`)

		return NewInstallerValueUnknown(), diags
	}

	gracePeriodVal, ok := gracePeriodAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`grace_period expected to be basetypes.Int64Value, was: %T`, gracePeriodAttribute))
	}

	if diags.HasError() {
		return NewInstallerValueUnknown(), diags
	}

	return InstallerValue{
		AllowAllDevices: allowAllDevicesVal,
		AllowAllSites:   allowAllSitesVal,
		ExtraSiteIds:    extraSiteIdsVal,
		GracePeriod:     gracePeriodVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewInstallerValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) InstallerValue {
	object, diags := NewInstallerValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewInstallerValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t InstallerType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewInstallerValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewInstallerValueUnknown(), nil
	}

	if in.IsNull() {
		return NewInstallerValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewInstallerValueMust(InstallerValue{}.AttributeTypes(ctx), attributes), nil
}

func (t InstallerType) ValueType(ctx context.Context) attr.Value {
	return InstallerValue{}
}

var _ basetypes.ObjectValuable = InstallerValue{}

type InstallerValue struct {
	AllowAllDevices basetypes.BoolValue  `tfsdk:"allow_all_devices"`
	AllowAllSites   basetypes.BoolValue  `tfsdk:"allow_all_sites"`
	ExtraSiteIds    basetypes.ListValue  `tfsdk:"extra_site_ids"`
	GracePeriod     basetypes.Int64Value `tfsdk:"grace_period"`
	state           attr.ValueState
}

func (v InstallerValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["allow_all_devices"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["allow_all_sites"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["extra_site_ids"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["grace_period"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.AllowAllDevices.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["allow_all_devices"] = val

		val, err = v.AllowAllSites.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["allow_all_sites"] = val

		val, err = v.ExtraSiteIds.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["extra_site_ids"] = val

		val, err = v.GracePeriod.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["grace_period"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v InstallerValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v InstallerValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v InstallerValue) String() string {
	return "InstallerValue"
}

func (v InstallerValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	extraSiteIdsVal, d := types.ListValue(types.StringType, v.ExtraSiteIds.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"allow_all_devices": basetypes.BoolType{},
			"allow_all_sites":   basetypes.BoolType{},
			"extra_site_ids": basetypes.ListType{
				ElemType: types.StringType,
			},
			"grace_period": basetypes.Int64Type{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"allow_all_devices": basetypes.BoolType{},
		"allow_all_sites":   basetypes.BoolType{},
		"extra_site_ids": basetypes.ListType{
			ElemType: types.StringType,
		},
		"grace_period": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"allow_all_devices": v.AllowAllDevices,
			"allow_all_sites":   v.AllowAllSites,
			"extra_site_ids":    extraSiteIdsVal,
			"grace_period":      v.GracePeriod,
		})

	return objVal, diags
}

func (v InstallerValue) Equal(o attr.Value) bool {
	other, ok := o.(InstallerValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AllowAllDevices.Equal(other.AllowAllDevices) {
		return false
	}

	if !v.AllowAllSites.Equal(other.AllowAllSites) {
		return false
	}

	if !v.ExtraSiteIds.Equal(other.ExtraSiteIds) {
		return false
	}

	if !v.GracePeriod.Equal(other.GracePeriod) {
		return false
	}

	return true
}

func (v InstallerValue) Type(ctx context.Context) attr.Type {
	return InstallerType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v InstallerValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"allow_all_devices": basetypes.BoolType{},
		"allow_all_sites":   basetypes.BoolType{},
		"extra_site_ids": basetypes.ListType{
			ElemType: types.StringType,
		},
		"grace_period": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = JcloudType{}

type JcloudType struct {
	basetypes.ObjectType
}

func (t JcloudType) Equal(o attr.Type) bool {
	other, ok := o.(JcloudType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t JcloudType) String() string {
	return "JcloudType"
}

func (t JcloudType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	orgApitokenAttribute, ok := attributes["org_apitoken"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`org_apitoken is missing from object`)

		return nil, diags
	}

	orgApitokenVal, ok := orgApitokenAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`org_apitoken expected to be basetypes.StringValue, was: %T`, orgApitokenAttribute))
	}

	orgApitokenNameAttribute, ok := attributes["org_apitoken_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`org_apitoken_name is missing from object`)

		return nil, diags
	}

	orgApitokenNameVal, ok := orgApitokenNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`org_apitoken_name expected to be basetypes.StringValue, was: %T`, orgApitokenNameAttribute))
	}

	orgIdAttribute, ok := attributes["org_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`org_id is missing from object`)

		return nil, diags
	}

	orgIdVal, ok := orgIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`org_id expected to be basetypes.StringValue, was: %T`, orgIdAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return JcloudValue{
		OrgApitoken:     orgApitokenVal,
		OrgApitokenName: orgApitokenNameVal,
		OrgId:           orgIdVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewJcloudValueNull() JcloudValue {
	return JcloudValue{
		state: attr.ValueStateNull,
	}
}

func NewJcloudValueUnknown() JcloudValue {
	return JcloudValue{
		state: attr.ValueStateUnknown,
	}
}

func NewJcloudValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (JcloudValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing JcloudValue Attribute Value",
				"While creating a JcloudValue value, a missing attribute value was detected. "+
					"A JcloudValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("JcloudValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid JcloudValue Attribute Type",
				"While creating a JcloudValue value, an invalid attribute value was detected. "+
					"A JcloudValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("JcloudValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("JcloudValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra JcloudValue Attribute Value",
				"While creating a JcloudValue value, an extra attribute value was detected. "+
					"A JcloudValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra JcloudValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewJcloudValueUnknown(), diags
	}

	orgApitokenAttribute, ok := attributes["org_apitoken"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`org_apitoken is missing from object`)

		return NewJcloudValueUnknown(), diags
	}

	orgApitokenVal, ok := orgApitokenAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`org_apitoken expected to be basetypes.StringValue, was: %T`, orgApitokenAttribute))
	}

	orgApitokenNameAttribute, ok := attributes["org_apitoken_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`org_apitoken_name is missing from object`)

		return NewJcloudValueUnknown(), diags
	}

	orgApitokenNameVal, ok := orgApitokenNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`org_apitoken_name expected to be basetypes.StringValue, was: %T`, orgApitokenNameAttribute))
	}

	orgIdAttribute, ok := attributes["org_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`org_id is missing from object`)

		return NewJcloudValueUnknown(), diags
	}

	orgIdVal, ok := orgIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`org_id expected to be basetypes.StringValue, was: %T`, orgIdAttribute))
	}

	if diags.HasError() {
		return NewJcloudValueUnknown(), diags
	}

	return JcloudValue{
		OrgApitoken:     orgApitokenVal,
		OrgApitokenName: orgApitokenNameVal,
		OrgId:           orgIdVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewJcloudValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) JcloudValue {
	object, diags := NewJcloudValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewJcloudValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t JcloudType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewJcloudValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewJcloudValueUnknown(), nil
	}

	if in.IsNull() {
		return NewJcloudValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewJcloudValueMust(JcloudValue{}.AttributeTypes(ctx), attributes), nil
}

func (t JcloudType) ValueType(ctx context.Context) attr.Value {
	return JcloudValue{}
}

var _ basetypes.ObjectValuable = JcloudValue{}

type JcloudValue struct {
	OrgApitoken     basetypes.StringValue `tfsdk:"org_apitoken"`
	OrgApitokenName basetypes.StringValue `tfsdk:"org_apitoken_name"`
	OrgId           basetypes.StringValue `tfsdk:"org_id"`
	state           attr.ValueState
}

func (v JcloudValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["org_apitoken"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["org_apitoken_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["org_id"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.OrgApitoken.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["org_apitoken"] = val

		val, err = v.OrgApitokenName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["org_apitoken_name"] = val

		val, err = v.OrgId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["org_id"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v JcloudValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v JcloudValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v JcloudValue) String() string {
	return "JcloudValue"
}

func (v JcloudValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"org_apitoken":      basetypes.StringType{},
		"org_apitoken_name": basetypes.StringType{},
		"org_id":            basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"org_apitoken":      v.OrgApitoken,
			"org_apitoken_name": v.OrgApitokenName,
			"org_id":            v.OrgId,
		})

	return objVal, diags
}

func (v JcloudValue) Equal(o attr.Value) bool {
	other, ok := o.(JcloudValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.OrgApitoken.Equal(other.OrgApitoken) {
		return false
	}

	if !v.OrgApitokenName.Equal(other.OrgApitokenName) {
		return false
	}

	if !v.OrgId.Equal(other.OrgId) {
		return false
	}

	return true
}

func (v JcloudValue) Type(ctx context.Context) attr.Type {
	return JcloudType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v JcloudValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"org_apitoken":      basetypes.StringType{},
		"org_apitoken_name": basetypes.StringType{},
		"org_id":            basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = JuniperType{}

type JuniperType struct {
	basetypes.ObjectType
}

func (t JuniperType) Equal(o attr.Type) bool {
	other, ok := o.(JuniperType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t JuniperType) String() string {
	return "JuniperType"
}

func (t JuniperType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	accountsAttribute, ok := attributes["accounts"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`accounts is missing from object`)

		return nil, diags
	}

	accountsVal, ok := accountsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`accounts expected to be basetypes.ListValue, was: %T`, accountsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return JuniperValue{
		Accounts: accountsVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewJuniperValueNull() JuniperValue {
	return JuniperValue{
		state: attr.ValueStateNull,
	}
}

func NewJuniperValueUnknown() JuniperValue {
	return JuniperValue{
		state: attr.ValueStateUnknown,
	}
}

func NewJuniperValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (JuniperValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing JuniperValue Attribute Value",
				"While creating a JuniperValue value, a missing attribute value was detected. "+
					"A JuniperValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("JuniperValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid JuniperValue Attribute Type",
				"While creating a JuniperValue value, an invalid attribute value was detected. "+
					"A JuniperValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("JuniperValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("JuniperValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra JuniperValue Attribute Value",
				"While creating a JuniperValue value, an extra attribute value was detected. "+
					"A JuniperValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra JuniperValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewJuniperValueUnknown(), diags
	}

	accountsAttribute, ok := attributes["accounts"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`accounts is missing from object`)

		return NewJuniperValueUnknown(), diags
	}

	accountsVal, ok := accountsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`accounts expected to be basetypes.ListValue, was: %T`, accountsAttribute))
	}

	if diags.HasError() {
		return NewJuniperValueUnknown(), diags
	}

	return JuniperValue{
		Accounts: accountsVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewJuniperValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) JuniperValue {
	object, diags := NewJuniperValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewJuniperValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t JuniperType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewJuniperValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewJuniperValueUnknown(), nil
	}

	if in.IsNull() {
		return NewJuniperValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewJuniperValueMust(JuniperValue{}.AttributeTypes(ctx), attributes), nil
}

func (t JuniperType) ValueType(ctx context.Context) attr.Value {
	return JuniperValue{}
}

var _ basetypes.ObjectValuable = JuniperValue{}

type JuniperValue struct {
	Accounts basetypes.ListValue `tfsdk:"accounts"`
	state    attr.ValueState
}

func (v JuniperValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["accounts"] = basetypes.ListType{
		ElemType: AccountsValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Accounts.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["accounts"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v JuniperValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v JuniperValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v JuniperValue) String() string {
	return "JuniperValue"
}

func (v JuniperValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	accounts := types.ListValueMust(
		AccountsType{
			basetypes.ObjectType{
				AttrTypes: AccountsValue{}.AttributeTypes(ctx),
			},
		},
		v.Accounts.Elements(),
	)

	if v.Accounts.IsNull() {
		accounts = types.ListNull(
			AccountsType{
				basetypes.ObjectType{
					AttrTypes: AccountsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Accounts.IsUnknown() {
		accounts = types.ListUnknown(
			AccountsType{
				basetypes.ObjectType{
					AttrTypes: AccountsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"accounts": basetypes.ListType{
			ElemType: AccountsValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"accounts": accounts,
		})

	return objVal, diags
}

func (v JuniperValue) Equal(o attr.Value) bool {
	other, ok := o.(JuniperValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Accounts.Equal(other.Accounts) {
		return false
	}

	return true
}

func (v JuniperValue) Type(ctx context.Context) attr.Type {
	return JuniperType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v JuniperValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"accounts": basetypes.ListType{
			ElemType: AccountsValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = AccountsType{}

type AccountsType struct {
	basetypes.ObjectType
}

func (t AccountsType) Equal(o attr.Type) bool {
	other, ok := o.(AccountsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AccountsType) String() string {
	return "AccountsType"
}

func (t AccountsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	linkedByAttribute, ok := attributes["linked_by"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`linked_by is missing from object`)

		return nil, diags
	}

	linkedByVal, ok := linkedByAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`linked_by expected to be basetypes.StringValue, was: %T`, linkedByAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AccountsValue{
		LinkedBy: linkedByVal,
		Name:     nameVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewAccountsValueNull() AccountsValue {
	return AccountsValue{
		state: attr.ValueStateNull,
	}
}

func NewAccountsValueUnknown() AccountsValue {
	return AccountsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewAccountsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AccountsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AccountsValue Attribute Value",
				"While creating a AccountsValue value, a missing attribute value was detected. "+
					"A AccountsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AccountsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AccountsValue Attribute Type",
				"While creating a AccountsValue value, an invalid attribute value was detected. "+
					"A AccountsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AccountsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AccountsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AccountsValue Attribute Value",
				"While creating a AccountsValue value, an extra attribute value was detected. "+
					"A AccountsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AccountsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAccountsValueUnknown(), diags
	}

	linkedByAttribute, ok := attributes["linked_by"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`linked_by is missing from object`)

		return NewAccountsValueUnknown(), diags
	}

	linkedByVal, ok := linkedByAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`linked_by expected to be basetypes.StringValue, was: %T`, linkedByAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewAccountsValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	if diags.HasError() {
		return NewAccountsValueUnknown(), diags
	}

	return AccountsValue{
		LinkedBy: linkedByVal,
		Name:     nameVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewAccountsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AccountsValue {
	object, diags := NewAccountsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAccountsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AccountsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAccountsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAccountsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAccountsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAccountsValueMust(AccountsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t AccountsType) ValueType(ctx context.Context) attr.Value {
	return AccountsValue{}
}

var _ basetypes.ObjectValuable = AccountsValue{}

type AccountsValue struct {
	LinkedBy basetypes.StringValue `tfsdk:"linked_by"`
	Name     basetypes.StringValue `tfsdk:"name"`
	state    attr.ValueState
}

func (v AccountsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["linked_by"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.LinkedBy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["linked_by"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AccountsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AccountsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AccountsValue) String() string {
	return "AccountsValue"
}

func (v AccountsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"linked_by": basetypes.StringType{},
		"name":      basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"linked_by": v.LinkedBy,
			"name":      v.Name,
		})

	return objVal, diags
}

func (v AccountsValue) Equal(o attr.Value) bool {
	other, ok := o.(AccountsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.LinkedBy.Equal(other.LinkedBy) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	return true
}

func (v AccountsValue) Type(ctx context.Context) attr.Type {
	return AccountsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AccountsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"linked_by": basetypes.StringType{},
		"name":      basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = MgmtType{}

type MgmtType struct {
	basetypes.ObjectType
}

func (t MgmtType) Equal(o attr.Type) bool {
	other, ok := o.(MgmtType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t MgmtType) String() string {
	return "MgmtType"
}

func (t MgmtType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	mxtunnelIdsAttribute, ok := attributes["mxtunnel_ids"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mxtunnel_ids is missing from object`)

		return nil, diags
	}

	mxtunnelIdsVal, ok := mxtunnelIdsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mxtunnel_ids expected to be basetypes.ListValue, was: %T`, mxtunnelIdsAttribute))
	}

	useMxtunnelAttribute, ok := attributes["use_mxtunnel"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`use_mxtunnel is missing from object`)

		return nil, diags
	}

	useMxtunnelVal, ok := useMxtunnelAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`use_mxtunnel expected to be basetypes.BoolValue, was: %T`, useMxtunnelAttribute))
	}

	useWxtunnelAttribute, ok := attributes["use_wxtunnel"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`use_wxtunnel is missing from object`)

		return nil, diags
	}

	useWxtunnelVal, ok := useWxtunnelAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`use_wxtunnel expected to be basetypes.BoolValue, was: %T`, useWxtunnelAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return MgmtValue{
		MxtunnelIds: mxtunnelIdsVal,
		UseMxtunnel: useMxtunnelVal,
		UseWxtunnel: useWxtunnelVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewMgmtValueNull() MgmtValue {
	return MgmtValue{
		state: attr.ValueStateNull,
	}
}

func NewMgmtValueUnknown() MgmtValue {
	return MgmtValue{
		state: attr.ValueStateUnknown,
	}
}

func NewMgmtValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (MgmtValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing MgmtValue Attribute Value",
				"While creating a MgmtValue value, a missing attribute value was detected. "+
					"A MgmtValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MgmtValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid MgmtValue Attribute Type",
				"While creating a MgmtValue value, an invalid attribute value was detected. "+
					"A MgmtValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MgmtValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("MgmtValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra MgmtValue Attribute Value",
				"While creating a MgmtValue value, an extra attribute value was detected. "+
					"A MgmtValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra MgmtValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewMgmtValueUnknown(), diags
	}

	mxtunnelIdsAttribute, ok := attributes["mxtunnel_ids"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mxtunnel_ids is missing from object`)

		return NewMgmtValueUnknown(), diags
	}

	mxtunnelIdsVal, ok := mxtunnelIdsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mxtunnel_ids expected to be basetypes.ListValue, was: %T`, mxtunnelIdsAttribute))
	}

	useMxtunnelAttribute, ok := attributes["use_mxtunnel"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`use_mxtunnel is missing from object`)

		return NewMgmtValueUnknown(), diags
	}

	useMxtunnelVal, ok := useMxtunnelAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`use_mxtunnel expected to be basetypes.BoolValue, was: %T`, useMxtunnelAttribute))
	}

	useWxtunnelAttribute, ok := attributes["use_wxtunnel"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`use_wxtunnel is missing from object`)

		return NewMgmtValueUnknown(), diags
	}

	useWxtunnelVal, ok := useWxtunnelAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`use_wxtunnel expected to be basetypes.BoolValue, was: %T`, useWxtunnelAttribute))
	}

	if diags.HasError() {
		return NewMgmtValueUnknown(), diags
	}

	return MgmtValue{
		MxtunnelIds: mxtunnelIdsVal,
		UseMxtunnel: useMxtunnelVal,
		UseWxtunnel: useWxtunnelVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewMgmtValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) MgmtValue {
	object, diags := NewMgmtValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewMgmtValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t MgmtType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewMgmtValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewMgmtValueUnknown(), nil
	}

	if in.IsNull() {
		return NewMgmtValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewMgmtValueMust(MgmtValue{}.AttributeTypes(ctx), attributes), nil
}

func (t MgmtType) ValueType(ctx context.Context) attr.Value {
	return MgmtValue{}
}

var _ basetypes.ObjectValuable = MgmtValue{}

type MgmtValue struct {
	MxtunnelIds basetypes.ListValue `tfsdk:"mxtunnel_ids"`
	UseMxtunnel basetypes.BoolValue `tfsdk:"use_mxtunnel"`
	UseWxtunnel basetypes.BoolValue `tfsdk:"use_wxtunnel"`
	state       attr.ValueState
}

func (v MgmtValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["mxtunnel_ids"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["use_mxtunnel"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["use_wxtunnel"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.MxtunnelIds.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mxtunnel_ids"] = val

		val, err = v.UseMxtunnel.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["use_mxtunnel"] = val

		val, err = v.UseWxtunnel.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["use_wxtunnel"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v MgmtValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v MgmtValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v MgmtValue) String() string {
	return "MgmtValue"
}

func (v MgmtValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	mxtunnelIdsVal, d := types.ListValue(types.StringType, v.MxtunnelIds.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"mxtunnel_ids": basetypes.ListType{
				ElemType: types.StringType,
			},
			"use_mxtunnel": basetypes.BoolType{},
			"use_wxtunnel": basetypes.BoolType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"mxtunnel_ids": basetypes.ListType{
			ElemType: types.StringType,
		},
		"use_mxtunnel": basetypes.BoolType{},
		"use_wxtunnel": basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"mxtunnel_ids": mxtunnelIdsVal,
			"use_mxtunnel": v.UseMxtunnel,
			"use_wxtunnel": v.UseWxtunnel,
		})

	return objVal, diags
}

func (v MgmtValue) Equal(o attr.Value) bool {
	other, ok := o.(MgmtValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.MxtunnelIds.Equal(other.MxtunnelIds) {
		return false
	}

	if !v.UseMxtunnel.Equal(other.UseMxtunnel) {
		return false
	}

	if !v.UseWxtunnel.Equal(other.UseWxtunnel) {
		return false
	}

	return true
}

func (v MgmtValue) Type(ctx context.Context) attr.Type {
	return MgmtType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v MgmtValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"mxtunnel_ids": basetypes.ListType{
			ElemType: types.StringType,
		},
		"use_mxtunnel": basetypes.BoolType{},
		"use_wxtunnel": basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = MistNacType{}

type MistNacType struct {
	basetypes.ObjectType
}

func (t MistNacType) Equal(o attr.Type) bool {
	other, ok := o.(MistNacType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t MistNacType) String() string {
	return "MistNacType"
}

func (t MistNacType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	cacertsAttribute, ok := attributes["cacerts"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cacerts is missing from object`)

		return nil, diags
	}

	cacertsVal, ok := cacertsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cacerts expected to be basetypes.ListValue, was: %T`, cacertsAttribute))
	}

	defaultIdpIdAttribute, ok := attributes["default_idp_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`default_idp_id is missing from object`)

		return nil, diags
	}

	defaultIdpIdVal, ok := defaultIdpIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`default_idp_id expected to be basetypes.StringValue, was: %T`, defaultIdpIdAttribute))
	}

	eapSslSecurityLevelAttribute, ok := attributes["eap_ssl_security_level"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`eap_ssl_security_level is missing from object`)

		return nil, diags
	}

	eapSslSecurityLevelVal, ok := eapSslSecurityLevelAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`eap_ssl_security_level expected to be basetypes.Int64Value, was: %T`, eapSslSecurityLevelAttribute))
	}

	euOnlyAttribute, ok := attributes["eu_only"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`eu_only is missing from object`)

		return nil, diags
	}

	euOnlyVal, ok := euOnlyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`eu_only expected to be basetypes.BoolValue, was: %T`, euOnlyAttribute))
	}

	idpsAttribute, ok := attributes["idps"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`idps is missing from object`)

		return nil, diags
	}

	idpsVal, ok := idpsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`idps expected to be basetypes.ListValue, was: %T`, idpsAttribute))
	}

	serverCertAttribute, ok := attributes["server_cert"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`server_cert is missing from object`)

		return nil, diags
	}

	serverCertVal, ok := serverCertAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`server_cert expected to be basetypes.ObjectValue, was: %T`, serverCertAttribute))
	}

	useIpVersionAttribute, ok := attributes["use_ip_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`use_ip_version is missing from object`)

		return nil, diags
	}

	useIpVersionVal, ok := useIpVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`use_ip_version expected to be basetypes.StringValue, was: %T`, useIpVersionAttribute))
	}

	useSslPortAttribute, ok := attributes["use_ssl_port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`use_ssl_port is missing from object`)

		return nil, diags
	}

	useSslPortVal, ok := useSslPortAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`use_ssl_port expected to be basetypes.BoolValue, was: %T`, useSslPortAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return MistNacValue{
		Cacerts:             cacertsVal,
		DefaultIdpId:        defaultIdpIdVal,
		EapSslSecurityLevel: eapSslSecurityLevelVal,
		EuOnly:              euOnlyVal,
		Idps:                idpsVal,
		ServerCert:          serverCertVal,
		UseIpVersion:        useIpVersionVal,
		UseSslPort:          useSslPortVal,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewMistNacValueNull() MistNacValue {
	return MistNacValue{
		state: attr.ValueStateNull,
	}
}

func NewMistNacValueUnknown() MistNacValue {
	return MistNacValue{
		state: attr.ValueStateUnknown,
	}
}

func NewMistNacValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (MistNacValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing MistNacValue Attribute Value",
				"While creating a MistNacValue value, a missing attribute value was detected. "+
					"A MistNacValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MistNacValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid MistNacValue Attribute Type",
				"While creating a MistNacValue value, an invalid attribute value was detected. "+
					"A MistNacValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MistNacValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("MistNacValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra MistNacValue Attribute Value",
				"While creating a MistNacValue value, an extra attribute value was detected. "+
					"A MistNacValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra MistNacValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewMistNacValueUnknown(), diags
	}

	cacertsAttribute, ok := attributes["cacerts"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cacerts is missing from object`)

		return NewMistNacValueUnknown(), diags
	}

	cacertsVal, ok := cacertsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cacerts expected to be basetypes.ListValue, was: %T`, cacertsAttribute))
	}

	defaultIdpIdAttribute, ok := attributes["default_idp_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`default_idp_id is missing from object`)

		return NewMistNacValueUnknown(), diags
	}

	defaultIdpIdVal, ok := defaultIdpIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`default_idp_id expected to be basetypes.StringValue, was: %T`, defaultIdpIdAttribute))
	}

	eapSslSecurityLevelAttribute, ok := attributes["eap_ssl_security_level"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`eap_ssl_security_level is missing from object`)

		return NewMistNacValueUnknown(), diags
	}

	eapSslSecurityLevelVal, ok := eapSslSecurityLevelAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`eap_ssl_security_level expected to be basetypes.Int64Value, was: %T`, eapSslSecurityLevelAttribute))
	}

	euOnlyAttribute, ok := attributes["eu_only"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`eu_only is missing from object`)

		return NewMistNacValueUnknown(), diags
	}

	euOnlyVal, ok := euOnlyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`eu_only expected to be basetypes.BoolValue, was: %T`, euOnlyAttribute))
	}

	idpsAttribute, ok := attributes["idps"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`idps is missing from object`)

		return NewMistNacValueUnknown(), diags
	}

	idpsVal, ok := idpsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`idps expected to be basetypes.ListValue, was: %T`, idpsAttribute))
	}

	serverCertAttribute, ok := attributes["server_cert"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`server_cert is missing from object`)

		return NewMistNacValueUnknown(), diags
	}

	serverCertVal, ok := serverCertAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`server_cert expected to be basetypes.ObjectValue, was: %T`, serverCertAttribute))
	}

	useIpVersionAttribute, ok := attributes["use_ip_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`use_ip_version is missing from object`)

		return NewMistNacValueUnknown(), diags
	}

	useIpVersionVal, ok := useIpVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`use_ip_version expected to be basetypes.StringValue, was: %T`, useIpVersionAttribute))
	}

	useSslPortAttribute, ok := attributes["use_ssl_port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`use_ssl_port is missing from object`)

		return NewMistNacValueUnknown(), diags
	}

	useSslPortVal, ok := useSslPortAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`use_ssl_port expected to be basetypes.BoolValue, was: %T`, useSslPortAttribute))
	}

	if diags.HasError() {
		return NewMistNacValueUnknown(), diags
	}

	return MistNacValue{
		Cacerts:             cacertsVal,
		DefaultIdpId:        defaultIdpIdVal,
		EapSslSecurityLevel: eapSslSecurityLevelVal,
		EuOnly:              euOnlyVal,
		Idps:                idpsVal,
		ServerCert:          serverCertVal,
		UseIpVersion:        useIpVersionVal,
		UseSslPort:          useSslPortVal,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewMistNacValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) MistNacValue {
	object, diags := NewMistNacValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewMistNacValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t MistNacType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewMistNacValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewMistNacValueUnknown(), nil
	}

	if in.IsNull() {
		return NewMistNacValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewMistNacValueMust(MistNacValue{}.AttributeTypes(ctx), attributes), nil
}

func (t MistNacType) ValueType(ctx context.Context) attr.Value {
	return MistNacValue{}
}

var _ basetypes.ObjectValuable = MistNacValue{}

type MistNacValue struct {
	Cacerts             basetypes.ListValue   `tfsdk:"cacerts"`
	DefaultIdpId        basetypes.StringValue `tfsdk:"default_idp_id"`
	EapSslSecurityLevel basetypes.Int64Value  `tfsdk:"eap_ssl_security_level"`
	EuOnly              basetypes.BoolValue   `tfsdk:"eu_only"`
	Idps                basetypes.ListValue   `tfsdk:"idps"`
	ServerCert          basetypes.ObjectValue `tfsdk:"server_cert"`
	UseIpVersion        basetypes.StringValue `tfsdk:"use_ip_version"`
	UseSslPort          basetypes.BoolValue   `tfsdk:"use_ssl_port"`
	state               attr.ValueState
}

func (v MistNacValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 8)

	var val tftypes.Value
	var err error

	attrTypes["cacerts"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["default_idp_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["eap_ssl_security_level"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["eu_only"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["idps"] = basetypes.ListType{
		ElemType: IdpsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["server_cert"] = basetypes.ObjectType{
		AttrTypes: ServerCertValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["use_ip_version"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["use_ssl_port"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 8)

		val, err = v.Cacerts.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cacerts"] = val

		val, err = v.DefaultIdpId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["default_idp_id"] = val

		val, err = v.EapSslSecurityLevel.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["eap_ssl_security_level"] = val

		val, err = v.EuOnly.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["eu_only"] = val

		val, err = v.Idps.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["idps"] = val

		val, err = v.ServerCert.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["server_cert"] = val

		val, err = v.UseIpVersion.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["use_ip_version"] = val

		val, err = v.UseSslPort.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["use_ssl_port"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v MistNacValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v MistNacValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v MistNacValue) String() string {
	return "MistNacValue"
}

func (v MistNacValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	idps := types.ListValueMust(
		IdpsType{
			basetypes.ObjectType{
				AttrTypes: IdpsValue{}.AttributeTypes(ctx),
			},
		},
		v.Idps.Elements(),
	)

	if v.Idps.IsNull() {
		idps = types.ListNull(
			IdpsType{
				basetypes.ObjectType{
					AttrTypes: IdpsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Idps.IsUnknown() {
		idps = types.ListUnknown(
			IdpsType{
				basetypes.ObjectType{
					AttrTypes: IdpsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var serverCert basetypes.ObjectValue

	if v.ServerCert.IsNull() {
		serverCert = types.ObjectNull(
			ServerCertValue{}.AttributeTypes(ctx),
		)
	}

	if v.ServerCert.IsUnknown() {
		serverCert = types.ObjectUnknown(
			ServerCertValue{}.AttributeTypes(ctx),
		)
	}

	if !v.ServerCert.IsNull() && !v.ServerCert.IsUnknown() {
		serverCert = types.ObjectValueMust(
			ServerCertValue{}.AttributeTypes(ctx),
			v.ServerCert.Attributes(),
		)
	}

	cacertsVal, d := types.ListValue(types.StringType, v.Cacerts.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"cacerts": basetypes.ListType{
				ElemType: types.StringType,
			},
			"default_idp_id":         basetypes.StringType{},
			"eap_ssl_security_level": basetypes.Int64Type{},
			"eu_only":                basetypes.BoolType{},
			"idps": basetypes.ListType{
				ElemType: IdpsValue{}.Type(ctx),
			},
			"server_cert": basetypes.ObjectType{
				AttrTypes: ServerCertValue{}.AttributeTypes(ctx),
			},
			"use_ip_version": basetypes.StringType{},
			"use_ssl_port":   basetypes.BoolType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"cacerts": basetypes.ListType{
			ElemType: types.StringType,
		},
		"default_idp_id":         basetypes.StringType{},
		"eap_ssl_security_level": basetypes.Int64Type{},
		"eu_only":                basetypes.BoolType{},
		"idps": basetypes.ListType{
			ElemType: IdpsValue{}.Type(ctx),
		},
		"server_cert": basetypes.ObjectType{
			AttrTypes: ServerCertValue{}.AttributeTypes(ctx),
		},
		"use_ip_version": basetypes.StringType{},
		"use_ssl_port":   basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"cacerts":                cacertsVal,
			"default_idp_id":         v.DefaultIdpId,
			"eap_ssl_security_level": v.EapSslSecurityLevel,
			"eu_only":                v.EuOnly,
			"idps":                   idps,
			"server_cert":            serverCert,
			"use_ip_version":         v.UseIpVersion,
			"use_ssl_port":           v.UseSslPort,
		})

	return objVal, diags
}

func (v MistNacValue) Equal(o attr.Value) bool {
	other, ok := o.(MistNacValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Cacerts.Equal(other.Cacerts) {
		return false
	}

	if !v.DefaultIdpId.Equal(other.DefaultIdpId) {
		return false
	}

	if !v.EapSslSecurityLevel.Equal(other.EapSslSecurityLevel) {
		return false
	}

	if !v.EuOnly.Equal(other.EuOnly) {
		return false
	}

	if !v.Idps.Equal(other.Idps) {
		return false
	}

	if !v.ServerCert.Equal(other.ServerCert) {
		return false
	}

	if !v.UseIpVersion.Equal(other.UseIpVersion) {
		return false
	}

	if !v.UseSslPort.Equal(other.UseSslPort) {
		return false
	}

	return true
}

func (v MistNacValue) Type(ctx context.Context) attr.Type {
	return MistNacType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v MistNacValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"cacerts": basetypes.ListType{
			ElemType: types.StringType,
		},
		"default_idp_id":         basetypes.StringType{},
		"eap_ssl_security_level": basetypes.Int64Type{},
		"eu_only":                basetypes.BoolType{},
		"idps": basetypes.ListType{
			ElemType: IdpsValue{}.Type(ctx),
		},
		"server_cert": basetypes.ObjectType{
			AttrTypes: ServerCertValue{}.AttributeTypes(ctx),
		},
		"use_ip_version": basetypes.StringType{},
		"use_ssl_port":   basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = IdpsType{}

type IdpsType struct {
	basetypes.ObjectType
}

func (t IdpsType) Equal(o attr.Type) bool {
	other, ok := o.(IdpsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t IdpsType) String() string {
	return "IdpsType"
}

func (t IdpsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	excludeRealmsAttribute, ok := attributes["exclude_realms"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`exclude_realms is missing from object`)

		return nil, diags
	}

	excludeRealmsVal, ok := excludeRealmsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`exclude_realms expected to be basetypes.ListValue, was: %T`, excludeRealmsAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	userRealmsAttribute, ok := attributes["user_realms"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`user_realms is missing from object`)

		return nil, diags
	}

	userRealmsVal, ok := userRealmsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`user_realms expected to be basetypes.ListValue, was: %T`, userRealmsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return IdpsValue{
		ExcludeRealms: excludeRealmsVal,
		Id:            idVal,
		UserRealms:    userRealmsVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewIdpsValueNull() IdpsValue {
	return IdpsValue{
		state: attr.ValueStateNull,
	}
}

func NewIdpsValueUnknown() IdpsValue {
	return IdpsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewIdpsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (IdpsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing IdpsValue Attribute Value",
				"While creating a IdpsValue value, a missing attribute value was detected. "+
					"A IdpsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("IdpsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid IdpsValue Attribute Type",
				"While creating a IdpsValue value, an invalid attribute value was detected. "+
					"A IdpsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("IdpsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("IdpsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra IdpsValue Attribute Value",
				"While creating a IdpsValue value, an extra attribute value was detected. "+
					"A IdpsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra IdpsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewIdpsValueUnknown(), diags
	}

	excludeRealmsAttribute, ok := attributes["exclude_realms"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`exclude_realms is missing from object`)

		return NewIdpsValueUnknown(), diags
	}

	excludeRealmsVal, ok := excludeRealmsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`exclude_realms expected to be basetypes.ListValue, was: %T`, excludeRealmsAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewIdpsValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.StringValue, was: %T`, idAttribute))
	}

	userRealmsAttribute, ok := attributes["user_realms"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`user_realms is missing from object`)

		return NewIdpsValueUnknown(), diags
	}

	userRealmsVal, ok := userRealmsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`user_realms expected to be basetypes.ListValue, was: %T`, userRealmsAttribute))
	}

	if diags.HasError() {
		return NewIdpsValueUnknown(), diags
	}

	return IdpsValue{
		ExcludeRealms: excludeRealmsVal,
		Id:            idVal,
		UserRealms:    userRealmsVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewIdpsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) IdpsValue {
	object, diags := NewIdpsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewIdpsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t IdpsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewIdpsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewIdpsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewIdpsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewIdpsValueMust(IdpsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t IdpsType) ValueType(ctx context.Context) attr.Value {
	return IdpsValue{}
}

var _ basetypes.ObjectValuable = IdpsValue{}

type IdpsValue struct {
	ExcludeRealms basetypes.ListValue   `tfsdk:"exclude_realms"`
	Id            basetypes.StringValue `tfsdk:"id"`
	UserRealms    basetypes.ListValue   `tfsdk:"user_realms"`
	state         attr.ValueState
}

func (v IdpsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["exclude_realms"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["user_realms"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.ExcludeRealms.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["exclude_realms"] = val

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.UserRealms.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["user_realms"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v IdpsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v IdpsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v IdpsValue) String() string {
	return "IdpsValue"
}

func (v IdpsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	excludeRealmsVal, d := types.ListValue(types.StringType, v.ExcludeRealms.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"exclude_realms": basetypes.ListType{
				ElemType: types.StringType,
			},
			"id": basetypes.StringType{},
			"user_realms": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	userRealmsVal, d := types.ListValue(types.StringType, v.UserRealms.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"exclude_realms": basetypes.ListType{
				ElemType: types.StringType,
			},
			"id": basetypes.StringType{},
			"user_realms": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"exclude_realms": basetypes.ListType{
			ElemType: types.StringType,
		},
		"id": basetypes.StringType{},
		"user_realms": basetypes.ListType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"exclude_realms": excludeRealmsVal,
			"id":             v.Id,
			"user_realms":    userRealmsVal,
		})

	return objVal, diags
}

func (v IdpsValue) Equal(o attr.Value) bool {
	other, ok := o.(IdpsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.ExcludeRealms.Equal(other.ExcludeRealms) {
		return false
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.UserRealms.Equal(other.UserRealms) {
		return false
	}

	return true
}

func (v IdpsValue) Type(ctx context.Context) attr.Type {
	return IdpsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v IdpsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"exclude_realms": basetypes.ListType{
			ElemType: types.StringType,
		},
		"id": basetypes.StringType{},
		"user_realms": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = ServerCertType{}

type ServerCertType struct {
	basetypes.ObjectType
}

func (t ServerCertType) Equal(o attr.Type) bool {
	other, ok := o.(ServerCertType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ServerCertType) String() string {
	return "ServerCertType"
}

func (t ServerCertType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	certAttribute, ok := attributes["cert"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cert is missing from object`)

		return nil, diags
	}

	certVal, ok := certAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cert expected to be basetypes.StringValue, was: %T`, certAttribute))
	}

	keyAttribute, ok := attributes["key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`key is missing from object`)

		return nil, diags
	}

	keyVal, ok := keyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`key expected to be basetypes.StringValue, was: %T`, keyAttribute))
	}

	passwordAttribute, ok := attributes["password"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`password is missing from object`)

		return nil, diags
	}

	passwordVal, ok := passwordAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`password expected to be basetypes.StringValue, was: %T`, passwordAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ServerCertValue{
		Cert:     certVal,
		Key:      keyVal,
		Password: passwordVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewServerCertValueNull() ServerCertValue {
	return ServerCertValue{
		state: attr.ValueStateNull,
	}
}

func NewServerCertValueUnknown() ServerCertValue {
	return ServerCertValue{
		state: attr.ValueStateUnknown,
	}
}

func NewServerCertValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ServerCertValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ServerCertValue Attribute Value",
				"While creating a ServerCertValue value, a missing attribute value was detected. "+
					"A ServerCertValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ServerCertValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ServerCertValue Attribute Type",
				"While creating a ServerCertValue value, an invalid attribute value was detected. "+
					"A ServerCertValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ServerCertValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ServerCertValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ServerCertValue Attribute Value",
				"While creating a ServerCertValue value, an extra attribute value was detected. "+
					"A ServerCertValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ServerCertValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewServerCertValueUnknown(), diags
	}

	certAttribute, ok := attributes["cert"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cert is missing from object`)

		return NewServerCertValueUnknown(), diags
	}

	certVal, ok := certAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cert expected to be basetypes.StringValue, was: %T`, certAttribute))
	}

	keyAttribute, ok := attributes["key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`key is missing from object`)

		return NewServerCertValueUnknown(), diags
	}

	keyVal, ok := keyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`key expected to be basetypes.StringValue, was: %T`, keyAttribute))
	}

	passwordAttribute, ok := attributes["password"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`password is missing from object`)

		return NewServerCertValueUnknown(), diags
	}

	passwordVal, ok := passwordAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`password expected to be basetypes.StringValue, was: %T`, passwordAttribute))
	}

	if diags.HasError() {
		return NewServerCertValueUnknown(), diags
	}

	return ServerCertValue{
		Cert:     certVal,
		Key:      keyVal,
		Password: passwordVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewServerCertValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ServerCertValue {
	object, diags := NewServerCertValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewServerCertValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ServerCertType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewServerCertValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewServerCertValueUnknown(), nil
	}

	if in.IsNull() {
		return NewServerCertValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewServerCertValueMust(ServerCertValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ServerCertType) ValueType(ctx context.Context) attr.Value {
	return ServerCertValue{}
}

var _ basetypes.ObjectValuable = ServerCertValue{}

type ServerCertValue struct {
	Cert     basetypes.StringValue `tfsdk:"cert"`
	Key      basetypes.StringValue `tfsdk:"key"`
	Password basetypes.StringValue `tfsdk:"password"`
	state    attr.ValueState
}

func (v ServerCertValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["cert"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["key"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["password"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Cert.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cert"] = val

		val, err = v.Key.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["key"] = val

		val, err = v.Password.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["password"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ServerCertValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ServerCertValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ServerCertValue) String() string {
	return "ServerCertValue"
}

func (v ServerCertValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"cert":     basetypes.StringType{},
		"key":      basetypes.StringType{},
		"password": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"cert":     v.Cert,
			"key":      v.Key,
			"password": v.Password,
		})

	return objVal, diags
}

func (v ServerCertValue) Equal(o attr.Value) bool {
	other, ok := o.(ServerCertValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Cert.Equal(other.Cert) {
		return false
	}

	if !v.Key.Equal(other.Key) {
		return false
	}

	if !v.Password.Equal(other.Password) {
		return false
	}

	return true
}

func (v ServerCertValue) Type(ctx context.Context) attr.Type {
	return ServerCertType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ServerCertValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"cert":     basetypes.StringType{},
		"key":      basetypes.StringType{},
		"password": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = MxedgeMgmtType{}

type MxedgeMgmtType struct {
	basetypes.ObjectType
}

func (t MxedgeMgmtType) Equal(o attr.Type) bool {
	other, ok := o.(MxedgeMgmtType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t MxedgeMgmtType) String() string {
	return "MxedgeMgmtType"
}

func (t MxedgeMgmtType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	fipsEnabledAttribute, ok := attributes["fips_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fips_enabled is missing from object`)

		return nil, diags
	}

	fipsEnabledVal, ok := fipsEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fips_enabled expected to be basetypes.BoolValue, was: %T`, fipsEnabledAttribute))
	}

	mistPasswordAttribute, ok := attributes["mist_password"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mist_password is missing from object`)

		return nil, diags
	}

	mistPasswordVal, ok := mistPasswordAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mist_password expected to be basetypes.StringValue, was: %T`, mistPasswordAttribute))
	}

	oobIpTypeAttribute, ok := attributes["oob_ip_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`oob_ip_type is missing from object`)

		return nil, diags
	}

	oobIpTypeVal, ok := oobIpTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`oob_ip_type expected to be basetypes.StringValue, was: %T`, oobIpTypeAttribute))
	}

	oobIpType6Attribute, ok := attributes["oob_ip_type6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`oob_ip_type6 is missing from object`)

		return nil, diags
	}

	oobIpType6Val, ok := oobIpType6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`oob_ip_type6 expected to be basetypes.StringValue, was: %T`, oobIpType6Attribute))
	}

	rootPasswordAttribute, ok := attributes["root_password"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`root_password is missing from object`)

		return nil, diags
	}

	rootPasswordVal, ok := rootPasswordAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`root_password expected to be basetypes.StringValue, was: %T`, rootPasswordAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return MxedgeMgmtValue{
		FipsEnabled:  fipsEnabledVal,
		MistPassword: mistPasswordVal,
		OobIpType:    oobIpTypeVal,
		OobIpType6:   oobIpType6Val,
		RootPassword: rootPasswordVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewMxedgeMgmtValueNull() MxedgeMgmtValue {
	return MxedgeMgmtValue{
		state: attr.ValueStateNull,
	}
}

func NewMxedgeMgmtValueUnknown() MxedgeMgmtValue {
	return MxedgeMgmtValue{
		state: attr.ValueStateUnknown,
	}
}

func NewMxedgeMgmtValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (MxedgeMgmtValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing MxedgeMgmtValue Attribute Value",
				"While creating a MxedgeMgmtValue value, a missing attribute value was detected. "+
					"A MxedgeMgmtValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MxedgeMgmtValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid MxedgeMgmtValue Attribute Type",
				"While creating a MxedgeMgmtValue value, an invalid attribute value was detected. "+
					"A MxedgeMgmtValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MxedgeMgmtValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("MxedgeMgmtValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra MxedgeMgmtValue Attribute Value",
				"While creating a MxedgeMgmtValue value, an extra attribute value was detected. "+
					"A MxedgeMgmtValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra MxedgeMgmtValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewMxedgeMgmtValueUnknown(), diags
	}

	fipsEnabledAttribute, ok := attributes["fips_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fips_enabled is missing from object`)

		return NewMxedgeMgmtValueUnknown(), diags
	}

	fipsEnabledVal, ok := fipsEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fips_enabled expected to be basetypes.BoolValue, was: %T`, fipsEnabledAttribute))
	}

	mistPasswordAttribute, ok := attributes["mist_password"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mist_password is missing from object`)

		return NewMxedgeMgmtValueUnknown(), diags
	}

	mistPasswordVal, ok := mistPasswordAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mist_password expected to be basetypes.StringValue, was: %T`, mistPasswordAttribute))
	}

	oobIpTypeAttribute, ok := attributes["oob_ip_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`oob_ip_type is missing from object`)

		return NewMxedgeMgmtValueUnknown(), diags
	}

	oobIpTypeVal, ok := oobIpTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`oob_ip_type expected to be basetypes.StringValue, was: %T`, oobIpTypeAttribute))
	}

	oobIpType6Attribute, ok := attributes["oob_ip_type6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`oob_ip_type6 is missing from object`)

		return NewMxedgeMgmtValueUnknown(), diags
	}

	oobIpType6Val, ok := oobIpType6Attribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`oob_ip_type6 expected to be basetypes.StringValue, was: %T`, oobIpType6Attribute))
	}

	rootPasswordAttribute, ok := attributes["root_password"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`root_password is missing from object`)

		return NewMxedgeMgmtValueUnknown(), diags
	}

	rootPasswordVal, ok := rootPasswordAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`root_password expected to be basetypes.StringValue, was: %T`, rootPasswordAttribute))
	}

	if diags.HasError() {
		return NewMxedgeMgmtValueUnknown(), diags
	}

	return MxedgeMgmtValue{
		FipsEnabled:  fipsEnabledVal,
		MistPassword: mistPasswordVal,
		OobIpType:    oobIpTypeVal,
		OobIpType6:   oobIpType6Val,
		RootPassword: rootPasswordVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewMxedgeMgmtValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) MxedgeMgmtValue {
	object, diags := NewMxedgeMgmtValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewMxedgeMgmtValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t MxedgeMgmtType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewMxedgeMgmtValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewMxedgeMgmtValueUnknown(), nil
	}

	if in.IsNull() {
		return NewMxedgeMgmtValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewMxedgeMgmtValueMust(MxedgeMgmtValue{}.AttributeTypes(ctx), attributes), nil
}

func (t MxedgeMgmtType) ValueType(ctx context.Context) attr.Value {
	return MxedgeMgmtValue{}
}

var _ basetypes.ObjectValuable = MxedgeMgmtValue{}

type MxedgeMgmtValue struct {
	FipsEnabled  basetypes.BoolValue   `tfsdk:"fips_enabled"`
	MistPassword basetypes.StringValue `tfsdk:"mist_password"`
	OobIpType    basetypes.StringValue `tfsdk:"oob_ip_type"`
	OobIpType6   basetypes.StringValue `tfsdk:"oob_ip_type6"`
	RootPassword basetypes.StringValue `tfsdk:"root_password"`
	state        attr.ValueState
}

func (v MxedgeMgmtValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["fips_enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["mist_password"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["oob_ip_type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["oob_ip_type6"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["root_password"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.FipsEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["fips_enabled"] = val

		val, err = v.MistPassword.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mist_password"] = val

		val, err = v.OobIpType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["oob_ip_type"] = val

		val, err = v.OobIpType6.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["oob_ip_type6"] = val

		val, err = v.RootPassword.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["root_password"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v MxedgeMgmtValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v MxedgeMgmtValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v MxedgeMgmtValue) String() string {
	return "MxedgeMgmtValue"
}

func (v MxedgeMgmtValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"fips_enabled":  basetypes.BoolType{},
		"mist_password": basetypes.StringType{},
		"oob_ip_type":   basetypes.StringType{},
		"oob_ip_type6":  basetypes.StringType{},
		"root_password": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"fips_enabled":  v.FipsEnabled,
			"mist_password": v.MistPassword,
			"oob_ip_type":   v.OobIpType,
			"oob_ip_type6":  v.OobIpType6,
			"root_password": v.RootPassword,
		})

	return objVal, diags
}

func (v MxedgeMgmtValue) Equal(o attr.Value) bool {
	other, ok := o.(MxedgeMgmtValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.FipsEnabled.Equal(other.FipsEnabled) {
		return false
	}

	if !v.MistPassword.Equal(other.MistPassword) {
		return false
	}

	if !v.OobIpType.Equal(other.OobIpType) {
		return false
	}

	if !v.OobIpType6.Equal(other.OobIpType6) {
		return false
	}

	if !v.RootPassword.Equal(other.RootPassword) {
		return false
	}

	return true
}

func (v MxedgeMgmtValue) Type(ctx context.Context) attr.Type {
	return MxedgeMgmtType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v MxedgeMgmtValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"fips_enabled":  basetypes.BoolType{},
		"mist_password": basetypes.StringType{},
		"oob_ip_type":   basetypes.StringType{},
		"oob_ip_type6":  basetypes.StringType{},
		"root_password": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = PasswordPolicyType{}

type PasswordPolicyType struct {
	basetypes.ObjectType
}

func (t PasswordPolicyType) Equal(o attr.Type) bool {
	other, ok := o.(PasswordPolicyType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PasswordPolicyType) String() string {
	return "PasswordPolicyType"
}

func (t PasswordPolicyType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	freshnessAttribute, ok := attributes["freshness"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`freshness is missing from object`)

		return nil, diags
	}

	freshnessVal, ok := freshnessAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`freshness expected to be basetypes.Int64Value, was: %T`, freshnessAttribute))
	}

	minLengthAttribute, ok := attributes["min_length"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`min_length is missing from object`)

		return nil, diags
	}

	minLengthVal, ok := minLengthAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`min_length expected to be basetypes.Int64Value, was: %T`, minLengthAttribute))
	}

	requiresSpecialCharAttribute, ok := attributes["requires_special_char"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`requires_special_char is missing from object`)

		return nil, diags
	}

	requiresSpecialCharVal, ok := requiresSpecialCharAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`requires_special_char expected to be basetypes.BoolValue, was: %T`, requiresSpecialCharAttribute))
	}

	requiresTwoFactorAuthAttribute, ok := attributes["requires_two_factor_auth"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`requires_two_factor_auth is missing from object`)

		return nil, diags
	}

	requiresTwoFactorAuthVal, ok := requiresTwoFactorAuthAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`requires_two_factor_auth expected to be basetypes.BoolValue, was: %T`, requiresTwoFactorAuthAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PasswordPolicyValue{
		Enabled:               enabledVal,
		Freshness:             freshnessVal,
		MinLength:             minLengthVal,
		RequiresSpecialChar:   requiresSpecialCharVal,
		RequiresTwoFactorAuth: requiresTwoFactorAuthVal,
		state:                 attr.ValueStateKnown,
	}, diags
}

func NewPasswordPolicyValueNull() PasswordPolicyValue {
	return PasswordPolicyValue{
		state: attr.ValueStateNull,
	}
}

func NewPasswordPolicyValueUnknown() PasswordPolicyValue {
	return PasswordPolicyValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPasswordPolicyValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PasswordPolicyValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PasswordPolicyValue Attribute Value",
				"While creating a PasswordPolicyValue value, a missing attribute value was detected. "+
					"A PasswordPolicyValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PasswordPolicyValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PasswordPolicyValue Attribute Type",
				"While creating a PasswordPolicyValue value, an invalid attribute value was detected. "+
					"A PasswordPolicyValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PasswordPolicyValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PasswordPolicyValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PasswordPolicyValue Attribute Value",
				"While creating a PasswordPolicyValue value, an extra attribute value was detected. "+
					"A PasswordPolicyValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PasswordPolicyValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPasswordPolicyValueUnknown(), diags
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewPasswordPolicyValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	freshnessAttribute, ok := attributes["freshness"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`freshness is missing from object`)

		return NewPasswordPolicyValueUnknown(), diags
	}

	freshnessVal, ok := freshnessAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`freshness expected to be basetypes.Int64Value, was: %T`, freshnessAttribute))
	}

	minLengthAttribute, ok := attributes["min_length"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`min_length is missing from object`)

		return NewPasswordPolicyValueUnknown(), diags
	}

	minLengthVal, ok := minLengthAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`min_length expected to be basetypes.Int64Value, was: %T`, minLengthAttribute))
	}

	requiresSpecialCharAttribute, ok := attributes["requires_special_char"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`requires_special_char is missing from object`)

		return NewPasswordPolicyValueUnknown(), diags
	}

	requiresSpecialCharVal, ok := requiresSpecialCharAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`requires_special_char expected to be basetypes.BoolValue, was: %T`, requiresSpecialCharAttribute))
	}

	requiresTwoFactorAuthAttribute, ok := attributes["requires_two_factor_auth"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`requires_two_factor_auth is missing from object`)

		return NewPasswordPolicyValueUnknown(), diags
	}

	requiresTwoFactorAuthVal, ok := requiresTwoFactorAuthAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`requires_two_factor_auth expected to be basetypes.BoolValue, was: %T`, requiresTwoFactorAuthAttribute))
	}

	if diags.HasError() {
		return NewPasswordPolicyValueUnknown(), diags
	}

	return PasswordPolicyValue{
		Enabled:               enabledVal,
		Freshness:             freshnessVal,
		MinLength:             minLengthVal,
		RequiresSpecialChar:   requiresSpecialCharVal,
		RequiresTwoFactorAuth: requiresTwoFactorAuthVal,
		state:                 attr.ValueStateKnown,
	}, diags
}

func NewPasswordPolicyValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PasswordPolicyValue {
	object, diags := NewPasswordPolicyValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPasswordPolicyValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PasswordPolicyType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPasswordPolicyValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPasswordPolicyValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPasswordPolicyValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPasswordPolicyValueMust(PasswordPolicyValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PasswordPolicyType) ValueType(ctx context.Context) attr.Value {
	return PasswordPolicyValue{}
}

var _ basetypes.ObjectValuable = PasswordPolicyValue{}

type PasswordPolicyValue struct {
	Enabled               basetypes.BoolValue  `tfsdk:"enabled"`
	Freshness             basetypes.Int64Value `tfsdk:"freshness"`
	MinLength             basetypes.Int64Value `tfsdk:"min_length"`
	RequiresSpecialChar   basetypes.BoolValue  `tfsdk:"requires_special_char"`
	RequiresTwoFactorAuth basetypes.BoolValue  `tfsdk:"requires_two_factor_auth"`
	state                 attr.ValueState
}

func (v PasswordPolicyValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["freshness"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["min_length"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["requires_special_char"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["requires_two_factor_auth"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.Freshness.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["freshness"] = val

		val, err = v.MinLength.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["min_length"] = val

		val, err = v.RequiresSpecialChar.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["requires_special_char"] = val

		val, err = v.RequiresTwoFactorAuth.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["requires_two_factor_auth"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PasswordPolicyValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PasswordPolicyValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PasswordPolicyValue) String() string {
	return "PasswordPolicyValue"
}

func (v PasswordPolicyValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"enabled":                  basetypes.BoolType{},
		"freshness":                basetypes.Int64Type{},
		"min_length":               basetypes.Int64Type{},
		"requires_special_char":    basetypes.BoolType{},
		"requires_two_factor_auth": basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"enabled":                  v.Enabled,
			"freshness":                v.Freshness,
			"min_length":               v.MinLength,
			"requires_special_char":    v.RequiresSpecialChar,
			"requires_two_factor_auth": v.RequiresTwoFactorAuth,
		})

	return objVal, diags
}

func (v PasswordPolicyValue) Equal(o attr.Value) bool {
	other, ok := o.(PasswordPolicyValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.Freshness.Equal(other.Freshness) {
		return false
	}

	if !v.MinLength.Equal(other.MinLength) {
		return false
	}

	if !v.RequiresSpecialChar.Equal(other.RequiresSpecialChar) {
		return false
	}

	if !v.RequiresTwoFactorAuth.Equal(other.RequiresTwoFactorAuth) {
		return false
	}

	return true
}

func (v PasswordPolicyValue) Type(ctx context.Context) attr.Type {
	return PasswordPolicyType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PasswordPolicyValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"enabled":                  basetypes.BoolType{},
		"freshness":                basetypes.Int64Type{},
		"min_length":               basetypes.Int64Type{},
		"requires_special_char":    basetypes.BoolType{},
		"requires_two_factor_auth": basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = PcapType{}

type PcapType struct {
	basetypes.ObjectType
}

func (t PcapType) Equal(o attr.Type) bool {
	other, ok := o.(PcapType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PcapType) String() string {
	return "PcapType"
}

func (t PcapType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	bucketAttribute, ok := attributes["bucket"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bucket is missing from object`)

		return nil, diags
	}

	bucketVal, ok := bucketAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bucket expected to be basetypes.StringValue, was: %T`, bucketAttribute))
	}

	maxPktLenAttribute, ok := attributes["max_pkt_len"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_pkt_len is missing from object`)

		return nil, diags
	}

	maxPktLenVal, ok := maxPktLenAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_pkt_len expected to be basetypes.Int64Value, was: %T`, maxPktLenAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PcapValue{
		Bucket:    bucketVal,
		MaxPktLen: maxPktLenVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewPcapValueNull() PcapValue {
	return PcapValue{
		state: attr.ValueStateNull,
	}
}

func NewPcapValueUnknown() PcapValue {
	return PcapValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPcapValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PcapValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PcapValue Attribute Value",
				"While creating a PcapValue value, a missing attribute value was detected. "+
					"A PcapValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PcapValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PcapValue Attribute Type",
				"While creating a PcapValue value, an invalid attribute value was detected. "+
					"A PcapValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PcapValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PcapValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PcapValue Attribute Value",
				"While creating a PcapValue value, an extra attribute value was detected. "+
					"A PcapValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PcapValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPcapValueUnknown(), diags
	}

	bucketAttribute, ok := attributes["bucket"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bucket is missing from object`)

		return NewPcapValueUnknown(), diags
	}

	bucketVal, ok := bucketAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bucket expected to be basetypes.StringValue, was: %T`, bucketAttribute))
	}

	maxPktLenAttribute, ok := attributes["max_pkt_len"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_pkt_len is missing from object`)

		return NewPcapValueUnknown(), diags
	}

	maxPktLenVal, ok := maxPktLenAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_pkt_len expected to be basetypes.Int64Value, was: %T`, maxPktLenAttribute))
	}

	if diags.HasError() {
		return NewPcapValueUnknown(), diags
	}

	return PcapValue{
		Bucket:    bucketVal,
		MaxPktLen: maxPktLenVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewPcapValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PcapValue {
	object, diags := NewPcapValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPcapValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PcapType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPcapValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPcapValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPcapValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPcapValueMust(PcapValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PcapType) ValueType(ctx context.Context) attr.Value {
	return PcapValue{}
}

var _ basetypes.ObjectValuable = PcapValue{}

type PcapValue struct {
	Bucket    basetypes.StringValue `tfsdk:"bucket"`
	MaxPktLen basetypes.Int64Value  `tfsdk:"max_pkt_len"`
	state     attr.ValueState
}

func (v PcapValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["bucket"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["max_pkt_len"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Bucket.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bucket"] = val

		val, err = v.MaxPktLen.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_pkt_len"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PcapValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PcapValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PcapValue) String() string {
	return "PcapValue"
}

func (v PcapValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"bucket":      basetypes.StringType{},
		"max_pkt_len": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"bucket":      v.Bucket,
			"max_pkt_len": v.MaxPktLen,
		})

	return objVal, diags
}

func (v PcapValue) Equal(o attr.Value) bool {
	other, ok := o.(PcapValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Bucket.Equal(other.Bucket) {
		return false
	}

	if !v.MaxPktLen.Equal(other.MaxPktLen) {
		return false
	}

	return true
}

func (v PcapValue) Type(ctx context.Context) attr.Type {
	return PcapType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PcapValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"bucket":      basetypes.StringType{},
		"max_pkt_len": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = SecurityType{}

type SecurityType struct {
	basetypes.ObjectType
}

func (t SecurityType) Equal(o attr.Type) bool {
	other, ok := o.(SecurityType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SecurityType) String() string {
	return "SecurityType"
}

func (t SecurityType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	disableLocalSshAttribute, ok := attributes["disable_local_ssh"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disable_local_ssh is missing from object`)

		return nil, diags
	}

	disableLocalSshVal, ok := disableLocalSshAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disable_local_ssh expected to be basetypes.BoolValue, was: %T`, disableLocalSshAttribute))
	}

	fipsZeroizePasswordAttribute, ok := attributes["fips_zeroize_password"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fips_zeroize_password is missing from object`)

		return nil, diags
	}

	fipsZeroizePasswordVal, ok := fipsZeroizePasswordAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fips_zeroize_password expected to be basetypes.StringValue, was: %T`, fipsZeroizePasswordAttribute))
	}

	limitSshAccessAttribute, ok := attributes["limit_ssh_access"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`limit_ssh_access is missing from object`)

		return nil, diags
	}

	limitSshAccessVal, ok := limitSshAccessAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`limit_ssh_access expected to be basetypes.BoolValue, was: %T`, limitSshAccessAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SecurityValue{
		DisableLocalSsh:     disableLocalSshVal,
		FipsZeroizePassword: fipsZeroizePasswordVal,
		LimitSshAccess:      limitSshAccessVal,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewSecurityValueNull() SecurityValue {
	return SecurityValue{
		state: attr.ValueStateNull,
	}
}

func NewSecurityValueUnknown() SecurityValue {
	return SecurityValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSecurityValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SecurityValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SecurityValue Attribute Value",
				"While creating a SecurityValue value, a missing attribute value was detected. "+
					"A SecurityValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SecurityValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SecurityValue Attribute Type",
				"While creating a SecurityValue value, an invalid attribute value was detected. "+
					"A SecurityValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SecurityValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SecurityValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SecurityValue Attribute Value",
				"While creating a SecurityValue value, an extra attribute value was detected. "+
					"A SecurityValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SecurityValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSecurityValueUnknown(), diags
	}

	disableLocalSshAttribute, ok := attributes["disable_local_ssh"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disable_local_ssh is missing from object`)

		return NewSecurityValueUnknown(), diags
	}

	disableLocalSshVal, ok := disableLocalSshAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disable_local_ssh expected to be basetypes.BoolValue, was: %T`, disableLocalSshAttribute))
	}

	fipsZeroizePasswordAttribute, ok := attributes["fips_zeroize_password"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fips_zeroize_password is missing from object`)

		return NewSecurityValueUnknown(), diags
	}

	fipsZeroizePasswordVal, ok := fipsZeroizePasswordAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fips_zeroize_password expected to be basetypes.StringValue, was: %T`, fipsZeroizePasswordAttribute))
	}

	limitSshAccessAttribute, ok := attributes["limit_ssh_access"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`limit_ssh_access is missing from object`)

		return NewSecurityValueUnknown(), diags
	}

	limitSshAccessVal, ok := limitSshAccessAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`limit_ssh_access expected to be basetypes.BoolValue, was: %T`, limitSshAccessAttribute))
	}

	if diags.HasError() {
		return NewSecurityValueUnknown(), diags
	}

	return SecurityValue{
		DisableLocalSsh:     disableLocalSshVal,
		FipsZeroizePassword: fipsZeroizePasswordVal,
		LimitSshAccess:      limitSshAccessVal,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewSecurityValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SecurityValue {
	object, diags := NewSecurityValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSecurityValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SecurityType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSecurityValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSecurityValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSecurityValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSecurityValueMust(SecurityValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SecurityType) ValueType(ctx context.Context) attr.Value {
	return SecurityValue{}
}

var _ basetypes.ObjectValuable = SecurityValue{}

type SecurityValue struct {
	DisableLocalSsh     basetypes.BoolValue   `tfsdk:"disable_local_ssh"`
	FipsZeroizePassword basetypes.StringValue `tfsdk:"fips_zeroize_password"`
	LimitSshAccess      basetypes.BoolValue   `tfsdk:"limit_ssh_access"`
	state               attr.ValueState
}

func (v SecurityValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["disable_local_ssh"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["fips_zeroize_password"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["limit_ssh_access"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.DisableLocalSsh.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["disable_local_ssh"] = val

		val, err = v.FipsZeroizePassword.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["fips_zeroize_password"] = val

		val, err = v.LimitSshAccess.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["limit_ssh_access"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SecurityValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SecurityValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SecurityValue) String() string {
	return "SecurityValue"
}

func (v SecurityValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"disable_local_ssh":     basetypes.BoolType{},
		"fips_zeroize_password": basetypes.StringType{},
		"limit_ssh_access":      basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"disable_local_ssh":     v.DisableLocalSsh,
			"fips_zeroize_password": v.FipsZeroizePassword,
			"limit_ssh_access":      v.LimitSshAccess,
		})

	return objVal, diags
}

func (v SecurityValue) Equal(o attr.Value) bool {
	other, ok := o.(SecurityValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.DisableLocalSsh.Equal(other.DisableLocalSsh) {
		return false
	}

	if !v.FipsZeroizePassword.Equal(other.FipsZeroizePassword) {
		return false
	}

	if !v.LimitSshAccess.Equal(other.LimitSshAccess) {
		return false
	}

	return true
}

func (v SecurityValue) Type(ctx context.Context) attr.Type {
	return SecurityType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SecurityValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"disable_local_ssh":     basetypes.BoolType{},
		"fips_zeroize_password": basetypes.StringType{},
		"limit_ssh_access":      basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = SwitchMgmtType{}

type SwitchMgmtType struct {
	basetypes.ObjectType
}

func (t SwitchMgmtType) Equal(o attr.Type) bool {
	other, ok := o.(SwitchMgmtType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SwitchMgmtType) String() string {
	return "SwitchMgmtType"
}

func (t SwitchMgmtType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	apAffinityThresholdAttribute, ok := attributes["ap_affinity_threshold"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ap_affinity_threshold is missing from object`)

		return nil, diags
	}

	apAffinityThresholdVal, ok := apAffinityThresholdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ap_affinity_threshold expected to be basetypes.Int64Value, was: %T`, apAffinityThresholdAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SwitchMgmtValue{
		ApAffinityThreshold: apAffinityThresholdVal,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewSwitchMgmtValueNull() SwitchMgmtValue {
	return SwitchMgmtValue{
		state: attr.ValueStateNull,
	}
}

func NewSwitchMgmtValueUnknown() SwitchMgmtValue {
	return SwitchMgmtValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSwitchMgmtValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SwitchMgmtValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SwitchMgmtValue Attribute Value",
				"While creating a SwitchMgmtValue value, a missing attribute value was detected. "+
					"A SwitchMgmtValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SwitchMgmtValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SwitchMgmtValue Attribute Type",
				"While creating a SwitchMgmtValue value, an invalid attribute value was detected. "+
					"A SwitchMgmtValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SwitchMgmtValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SwitchMgmtValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SwitchMgmtValue Attribute Value",
				"While creating a SwitchMgmtValue value, an extra attribute value was detected. "+
					"A SwitchMgmtValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SwitchMgmtValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSwitchMgmtValueUnknown(), diags
	}

	apAffinityThresholdAttribute, ok := attributes["ap_affinity_threshold"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ap_affinity_threshold is missing from object`)

		return NewSwitchMgmtValueUnknown(), diags
	}

	apAffinityThresholdVal, ok := apAffinityThresholdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ap_affinity_threshold expected to be basetypes.Int64Value, was: %T`, apAffinityThresholdAttribute))
	}

	if diags.HasError() {
		return NewSwitchMgmtValueUnknown(), diags
	}

	return SwitchMgmtValue{
		ApAffinityThreshold: apAffinityThresholdVal,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewSwitchMgmtValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SwitchMgmtValue {
	object, diags := NewSwitchMgmtValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSwitchMgmtValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SwitchMgmtType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSwitchMgmtValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSwitchMgmtValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSwitchMgmtValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSwitchMgmtValueMust(SwitchMgmtValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SwitchMgmtType) ValueType(ctx context.Context) attr.Value {
	return SwitchMgmtValue{}
}

var _ basetypes.ObjectValuable = SwitchMgmtValue{}

type SwitchMgmtValue struct {
	ApAffinityThreshold basetypes.Int64Value `tfsdk:"ap_affinity_threshold"`
	state               attr.ValueState
}

func (v SwitchMgmtValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["ap_affinity_threshold"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.ApAffinityThreshold.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ap_affinity_threshold"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SwitchMgmtValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SwitchMgmtValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SwitchMgmtValue) String() string {
	return "SwitchMgmtValue"
}

func (v SwitchMgmtValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"ap_affinity_threshold": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"ap_affinity_threshold": v.ApAffinityThreshold,
		})

	return objVal, diags
}

func (v SwitchMgmtValue) Equal(o attr.Value) bool {
	other, ok := o.(SwitchMgmtValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.ApAffinityThreshold.Equal(other.ApAffinityThreshold) {
		return false
	}

	return true
}

func (v SwitchMgmtValue) Type(ctx context.Context) attr.Type {
	return SwitchMgmtType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SwitchMgmtValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"ap_affinity_threshold": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = SyntheticTestType{}

type SyntheticTestType struct {
	basetypes.ObjectType
}

func (t SyntheticTestType) Equal(o attr.Type) bool {
	other, ok := o.(SyntheticTestType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SyntheticTestType) String() string {
	return "SyntheticTestType"
}

func (t SyntheticTestType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	disabledAttribute, ok := attributes["disabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disabled is missing from object`)

		return nil, diags
	}

	disabledVal, ok := disabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disabled expected to be basetypes.BoolValue, was: %T`, disabledAttribute))
	}

	vlansAttribute, ok := attributes["vlans"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlans is missing from object`)

		return nil, diags
	}

	vlansVal, ok := vlansAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlans expected to be basetypes.ListValue, was: %T`, vlansAttribute))
	}

	wanSpeedtestAttribute, ok := attributes["wan_speedtest"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wan_speedtest is missing from object`)

		return nil, diags
	}

	wanSpeedtestVal, ok := wanSpeedtestAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wan_speedtest expected to be basetypes.ObjectValue, was: %T`, wanSpeedtestAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SyntheticTestValue{
		Disabled:     disabledVal,
		Vlans:        vlansVal,
		WanSpeedtest: wanSpeedtestVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewSyntheticTestValueNull() SyntheticTestValue {
	return SyntheticTestValue{
		state: attr.ValueStateNull,
	}
}

func NewSyntheticTestValueUnknown() SyntheticTestValue {
	return SyntheticTestValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSyntheticTestValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SyntheticTestValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SyntheticTestValue Attribute Value",
				"While creating a SyntheticTestValue value, a missing attribute value was detected. "+
					"A SyntheticTestValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SyntheticTestValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SyntheticTestValue Attribute Type",
				"While creating a SyntheticTestValue value, an invalid attribute value was detected. "+
					"A SyntheticTestValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SyntheticTestValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SyntheticTestValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SyntheticTestValue Attribute Value",
				"While creating a SyntheticTestValue value, an extra attribute value was detected. "+
					"A SyntheticTestValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SyntheticTestValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSyntheticTestValueUnknown(), diags
	}

	disabledAttribute, ok := attributes["disabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disabled is missing from object`)

		return NewSyntheticTestValueUnknown(), diags
	}

	disabledVal, ok := disabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disabled expected to be basetypes.BoolValue, was: %T`, disabledAttribute))
	}

	vlansAttribute, ok := attributes["vlans"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlans is missing from object`)

		return NewSyntheticTestValueUnknown(), diags
	}

	vlansVal, ok := vlansAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlans expected to be basetypes.ListValue, was: %T`, vlansAttribute))
	}

	wanSpeedtestAttribute, ok := attributes["wan_speedtest"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wan_speedtest is missing from object`)

		return NewSyntheticTestValueUnknown(), diags
	}

	wanSpeedtestVal, ok := wanSpeedtestAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wan_speedtest expected to be basetypes.ObjectValue, was: %T`, wanSpeedtestAttribute))
	}

	if diags.HasError() {
		return NewSyntheticTestValueUnknown(), diags
	}

	return SyntheticTestValue{
		Disabled:     disabledVal,
		Vlans:        vlansVal,
		WanSpeedtest: wanSpeedtestVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewSyntheticTestValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SyntheticTestValue {
	object, diags := NewSyntheticTestValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSyntheticTestValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SyntheticTestType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSyntheticTestValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSyntheticTestValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSyntheticTestValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSyntheticTestValueMust(SyntheticTestValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SyntheticTestType) ValueType(ctx context.Context) attr.Value {
	return SyntheticTestValue{}
}

var _ basetypes.ObjectValuable = SyntheticTestValue{}

type SyntheticTestValue struct {
	Disabled     basetypes.BoolValue   `tfsdk:"disabled"`
	Vlans        basetypes.ListValue   `tfsdk:"vlans"`
	WanSpeedtest basetypes.ObjectValue `tfsdk:"wan_speedtest"`
	state        attr.ValueState
}

func (v SyntheticTestValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["disabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["vlans"] = basetypes.ListType{
		ElemType: VlansValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["wan_speedtest"] = basetypes.ObjectType{
		AttrTypes: WanSpeedtestValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Disabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["disabled"] = val

		val, err = v.Vlans.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vlans"] = val

		val, err = v.WanSpeedtest.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["wan_speedtest"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SyntheticTestValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SyntheticTestValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SyntheticTestValue) String() string {
	return "SyntheticTestValue"
}

func (v SyntheticTestValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	vlans := types.ListValueMust(
		VlansType{
			basetypes.ObjectType{
				AttrTypes: VlansValue{}.AttributeTypes(ctx),
			},
		},
		v.Vlans.Elements(),
	)

	if v.Vlans.IsNull() {
		vlans = types.ListNull(
			VlansType{
				basetypes.ObjectType{
					AttrTypes: VlansValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Vlans.IsUnknown() {
		vlans = types.ListUnknown(
			VlansType{
				basetypes.ObjectType{
					AttrTypes: VlansValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var wanSpeedtest basetypes.ObjectValue

	if v.WanSpeedtest.IsNull() {
		wanSpeedtest = types.ObjectNull(
			WanSpeedtestValue{}.AttributeTypes(ctx),
		)
	}

	if v.WanSpeedtest.IsUnknown() {
		wanSpeedtest = types.ObjectUnknown(
			WanSpeedtestValue{}.AttributeTypes(ctx),
		)
	}

	if !v.WanSpeedtest.IsNull() && !v.WanSpeedtest.IsUnknown() {
		wanSpeedtest = types.ObjectValueMust(
			WanSpeedtestValue{}.AttributeTypes(ctx),
			v.WanSpeedtest.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"disabled": basetypes.BoolType{},
		"vlans": basetypes.ListType{
			ElemType: VlansValue{}.Type(ctx),
		},
		"wan_speedtest": basetypes.ObjectType{
			AttrTypes: WanSpeedtestValue{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"disabled":      v.Disabled,
			"vlans":         vlans,
			"wan_speedtest": wanSpeedtest,
		})

	return objVal, diags
}

func (v SyntheticTestValue) Equal(o attr.Value) bool {
	other, ok := o.(SyntheticTestValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Disabled.Equal(other.Disabled) {
		return false
	}

	if !v.Vlans.Equal(other.Vlans) {
		return false
	}

	if !v.WanSpeedtest.Equal(other.WanSpeedtest) {
		return false
	}

	return true
}

func (v SyntheticTestValue) Type(ctx context.Context) attr.Type {
	return SyntheticTestType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SyntheticTestValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"disabled": basetypes.BoolType{},
		"vlans": basetypes.ListType{
			ElemType: VlansValue{}.Type(ctx),
		},
		"wan_speedtest": basetypes.ObjectType{
			AttrTypes: WanSpeedtestValue{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = VlansType{}

type VlansType struct {
	basetypes.ObjectType
}

func (t VlansType) Equal(o attr.Type) bool {
	other, ok := o.(VlansType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t VlansType) String() string {
	return "VlansType"
}

func (t VlansType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	customTestUrlsAttribute, ok := attributes["custom_test_urls"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`custom_test_urls is missing from object`)

		return nil, diags
	}

	customTestUrlsVal, ok := customTestUrlsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`custom_test_urls expected to be basetypes.ListValue, was: %T`, customTestUrlsAttribute))
	}

	disabledAttribute, ok := attributes["disabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disabled is missing from object`)

		return nil, diags
	}

	disabledVal, ok := disabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disabled expected to be basetypes.BoolValue, was: %T`, disabledAttribute))
	}

	vlanIdsAttribute, ok := attributes["vlan_ids"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan_ids is missing from object`)

		return nil, diags
	}

	vlanIdsVal, ok := vlanIdsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan_ids expected to be basetypes.ListValue, was: %T`, vlanIdsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return VlansValue{
		CustomTestUrls: customTestUrlsVal,
		Disabled:       disabledVal,
		VlanIds:        vlanIdsVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewVlansValueNull() VlansValue {
	return VlansValue{
		state: attr.ValueStateNull,
	}
}

func NewVlansValueUnknown() VlansValue {
	return VlansValue{
		state: attr.ValueStateUnknown,
	}
}

func NewVlansValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (VlansValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing VlansValue Attribute Value",
				"While creating a VlansValue value, a missing attribute value was detected. "+
					"A VlansValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VlansValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid VlansValue Attribute Type",
				"While creating a VlansValue value, an invalid attribute value was detected. "+
					"A VlansValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VlansValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("VlansValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra VlansValue Attribute Value",
				"While creating a VlansValue value, an extra attribute value was detected. "+
					"A VlansValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra VlansValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewVlansValueUnknown(), diags
	}

	customTestUrlsAttribute, ok := attributes["custom_test_urls"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`custom_test_urls is missing from object`)

		return NewVlansValueUnknown(), diags
	}

	customTestUrlsVal, ok := customTestUrlsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`custom_test_urls expected to be basetypes.ListValue, was: %T`, customTestUrlsAttribute))
	}

	disabledAttribute, ok := attributes["disabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disabled is missing from object`)

		return NewVlansValueUnknown(), diags
	}

	disabledVal, ok := disabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disabled expected to be basetypes.BoolValue, was: %T`, disabledAttribute))
	}

	vlanIdsAttribute, ok := attributes["vlan_ids"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan_ids is missing from object`)

		return NewVlansValueUnknown(), diags
	}

	vlanIdsVal, ok := vlanIdsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan_ids expected to be basetypes.ListValue, was: %T`, vlanIdsAttribute))
	}

	if diags.HasError() {
		return NewVlansValueUnknown(), diags
	}

	return VlansValue{
		CustomTestUrls: customTestUrlsVal,
		Disabled:       disabledVal,
		VlanIds:        vlanIdsVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewVlansValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) VlansValue {
	object, diags := NewVlansValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewVlansValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t VlansType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewVlansValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewVlansValueUnknown(), nil
	}

	if in.IsNull() {
		return NewVlansValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewVlansValueMust(VlansValue{}.AttributeTypes(ctx), attributes), nil
}

func (t VlansType) ValueType(ctx context.Context) attr.Value {
	return VlansValue{}
}

var _ basetypes.ObjectValuable = VlansValue{}

type VlansValue struct {
	CustomTestUrls basetypes.ListValue `tfsdk:"custom_test_urls"`
	Disabled       basetypes.BoolValue `tfsdk:"disabled"`
	VlanIds        basetypes.ListValue `tfsdk:"vlan_ids"`
	state          attr.ValueState
}

func (v VlansValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["custom_test_urls"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["disabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["vlan_ids"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.CustomTestUrls.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["custom_test_urls"] = val

		val, err = v.Disabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["disabled"] = val

		val, err = v.VlanIds.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vlan_ids"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v VlansValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v VlansValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v VlansValue) String() string {
	return "VlansValue"
}

func (v VlansValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	customTestUrlsVal, d := types.ListValue(types.StringType, v.CustomTestUrls.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"custom_test_urls": basetypes.ListType{
				ElemType: types.StringType,
			},
			"disabled": basetypes.BoolType{},
			"vlan_ids": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	vlanIdsVal, d := types.ListValue(types.StringType, v.VlanIds.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"custom_test_urls": basetypes.ListType{
				ElemType: types.StringType,
			},
			"disabled": basetypes.BoolType{},
			"vlan_ids": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"custom_test_urls": basetypes.ListType{
			ElemType: types.StringType,
		},
		"disabled": basetypes.BoolType{},
		"vlan_ids": basetypes.ListType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"custom_test_urls": customTestUrlsVal,
			"disabled":         v.Disabled,
			"vlan_ids":         vlanIdsVal,
		})

	return objVal, diags
}

func (v VlansValue) Equal(o attr.Value) bool {
	other, ok := o.(VlansValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.CustomTestUrls.Equal(other.CustomTestUrls) {
		return false
	}

	if !v.Disabled.Equal(other.Disabled) {
		return false
	}

	if !v.VlanIds.Equal(other.VlanIds) {
		return false
	}

	return true
}

func (v VlansValue) Type(ctx context.Context) attr.Type {
	return VlansType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v VlansValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"custom_test_urls": basetypes.ListType{
			ElemType: types.StringType,
		},
		"disabled": basetypes.BoolType{},
		"vlan_ids": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = WanSpeedtestType{}

type WanSpeedtestType struct {
	basetypes.ObjectType
}

func (t WanSpeedtestType) Equal(o attr.Type) bool {
	other, ok := o.(WanSpeedtestType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t WanSpeedtestType) String() string {
	return "WanSpeedtestType"
}

func (t WanSpeedtestType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	timeOdFayAttribute, ok := attributes["time_od_fay"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`time_od_fay is missing from object`)

		return nil, diags
	}

	timeOdFayVal, ok := timeOdFayAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`time_od_fay expected to be basetypes.StringValue, was: %T`, timeOdFayAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return WanSpeedtestValue{
		Enabled:   enabledVal,
		TimeOdFay: timeOdFayVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewWanSpeedtestValueNull() WanSpeedtestValue {
	return WanSpeedtestValue{
		state: attr.ValueStateNull,
	}
}

func NewWanSpeedtestValueUnknown() WanSpeedtestValue {
	return WanSpeedtestValue{
		state: attr.ValueStateUnknown,
	}
}

func NewWanSpeedtestValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (WanSpeedtestValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing WanSpeedtestValue Attribute Value",
				"While creating a WanSpeedtestValue value, a missing attribute value was detected. "+
					"A WanSpeedtestValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("WanSpeedtestValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid WanSpeedtestValue Attribute Type",
				"While creating a WanSpeedtestValue value, an invalid attribute value was detected. "+
					"A WanSpeedtestValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("WanSpeedtestValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("WanSpeedtestValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra WanSpeedtestValue Attribute Value",
				"While creating a WanSpeedtestValue value, an extra attribute value was detected. "+
					"A WanSpeedtestValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra WanSpeedtestValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewWanSpeedtestValueUnknown(), diags
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewWanSpeedtestValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	timeOdFayAttribute, ok := attributes["time_od_fay"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`time_od_fay is missing from object`)

		return NewWanSpeedtestValueUnknown(), diags
	}

	timeOdFayVal, ok := timeOdFayAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`time_od_fay expected to be basetypes.StringValue, was: %T`, timeOdFayAttribute))
	}

	if diags.HasError() {
		return NewWanSpeedtestValueUnknown(), diags
	}

	return WanSpeedtestValue{
		Enabled:   enabledVal,
		TimeOdFay: timeOdFayVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewWanSpeedtestValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) WanSpeedtestValue {
	object, diags := NewWanSpeedtestValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewWanSpeedtestValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t WanSpeedtestType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewWanSpeedtestValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewWanSpeedtestValueUnknown(), nil
	}

	if in.IsNull() {
		return NewWanSpeedtestValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewWanSpeedtestValueMust(WanSpeedtestValue{}.AttributeTypes(ctx), attributes), nil
}

func (t WanSpeedtestType) ValueType(ctx context.Context) attr.Value {
	return WanSpeedtestValue{}
}

var _ basetypes.ObjectValuable = WanSpeedtestValue{}

type WanSpeedtestValue struct {
	Enabled   basetypes.BoolValue   `tfsdk:"enabled"`
	TimeOdFay basetypes.StringValue `tfsdk:"time_od_fay"`
	state     attr.ValueState
}

func (v WanSpeedtestValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["time_od_fay"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.TimeOdFay.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["time_od_fay"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v WanSpeedtestValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v WanSpeedtestValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v WanSpeedtestValue) String() string {
	return "WanSpeedtestValue"
}

func (v WanSpeedtestValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"enabled":     basetypes.BoolType{},
		"time_od_fay": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"enabled":     v.Enabled,
			"time_od_fay": v.TimeOdFay,
		})

	return objVal, diags
}

func (v WanSpeedtestValue) Equal(o attr.Value) bool {
	other, ok := o.(WanSpeedtestValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.TimeOdFay.Equal(other.TimeOdFay) {
		return false
	}

	return true
}

func (v WanSpeedtestValue) Type(ctx context.Context) attr.Type {
	return WanSpeedtestType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v WanSpeedtestValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"enabled":     basetypes.BoolType{},
		"time_od_fay": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = VpnOptionsType{}

type VpnOptionsType struct {
	basetypes.ObjectType
}

func (t VpnOptionsType) Equal(o attr.Type) bool {
	other, ok := o.(VpnOptionsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t VpnOptionsType) String() string {
	return "VpnOptionsType"
}

func (t VpnOptionsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	asBaseAttribute, ok := attributes["as_base"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`as_base is missing from object`)

		return nil, diags
	}

	asBaseVal, ok := asBaseAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`as_base expected to be basetypes.Int64Value, was: %T`, asBaseAttribute))
	}

	stSubnetAttribute, ok := attributes["st_subnet"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`st_subnet is missing from object`)

		return nil, diags
	}

	stSubnetVal, ok := stSubnetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`st_subnet expected to be basetypes.StringValue, was: %T`, stSubnetAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return VpnOptionsValue{
		AsBase:   asBaseVal,
		StSubnet: stSubnetVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewVpnOptionsValueNull() VpnOptionsValue {
	return VpnOptionsValue{
		state: attr.ValueStateNull,
	}
}

func NewVpnOptionsValueUnknown() VpnOptionsValue {
	return VpnOptionsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewVpnOptionsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (VpnOptionsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing VpnOptionsValue Attribute Value",
				"While creating a VpnOptionsValue value, a missing attribute value was detected. "+
					"A VpnOptionsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VpnOptionsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid VpnOptionsValue Attribute Type",
				"While creating a VpnOptionsValue value, an invalid attribute value was detected. "+
					"A VpnOptionsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VpnOptionsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("VpnOptionsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra VpnOptionsValue Attribute Value",
				"While creating a VpnOptionsValue value, an extra attribute value was detected. "+
					"A VpnOptionsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra VpnOptionsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewVpnOptionsValueUnknown(), diags
	}

	asBaseAttribute, ok := attributes["as_base"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`as_base is missing from object`)

		return NewVpnOptionsValueUnknown(), diags
	}

	asBaseVal, ok := asBaseAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`as_base expected to be basetypes.Int64Value, was: %T`, asBaseAttribute))
	}

	stSubnetAttribute, ok := attributes["st_subnet"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`st_subnet is missing from object`)

		return NewVpnOptionsValueUnknown(), diags
	}

	stSubnetVal, ok := stSubnetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`st_subnet expected to be basetypes.StringValue, was: %T`, stSubnetAttribute))
	}

	if diags.HasError() {
		return NewVpnOptionsValueUnknown(), diags
	}

	return VpnOptionsValue{
		AsBase:   asBaseVal,
		StSubnet: stSubnetVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewVpnOptionsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) VpnOptionsValue {
	object, diags := NewVpnOptionsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewVpnOptionsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t VpnOptionsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewVpnOptionsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewVpnOptionsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewVpnOptionsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewVpnOptionsValueMust(VpnOptionsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t VpnOptionsType) ValueType(ctx context.Context) attr.Value {
	return VpnOptionsValue{}
}

var _ basetypes.ObjectValuable = VpnOptionsValue{}

type VpnOptionsValue struct {
	AsBase   basetypes.Int64Value  `tfsdk:"as_base"`
	StSubnet basetypes.StringValue `tfsdk:"st_subnet"`
	state    attr.ValueState
}

func (v VpnOptionsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["as_base"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["st_subnet"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.AsBase.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["as_base"] = val

		val, err = v.StSubnet.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["st_subnet"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v VpnOptionsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v VpnOptionsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v VpnOptionsValue) String() string {
	return "VpnOptionsValue"
}

func (v VpnOptionsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"as_base":   basetypes.Int64Type{},
		"st_subnet": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"as_base":   v.AsBase,
			"st_subnet": v.StSubnet,
		})

	return objVal, diags
}

func (v VpnOptionsValue) Equal(o attr.Value) bool {
	other, ok := o.(VpnOptionsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AsBase.Equal(other.AsBase) {
		return false
	}

	if !v.StSubnet.Equal(other.StSubnet) {
		return false
	}

	return true
}

func (v VpnOptionsValue) Type(ctx context.Context) attr.Type {
	return VpnOptionsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v VpnOptionsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"as_base":   basetypes.Int64Type{},
		"st_subnet": basetypes.StringType{},
	}
}
