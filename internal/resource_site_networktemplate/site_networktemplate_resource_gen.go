// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package resource_site_networktemplate

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework-validators/int64validator"
	"github.com/hashicorp/terraform-plugin-framework-validators/listvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/booldefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/int64default"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/listdefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
)

func SiteNetworktemplateResourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"acl_policies": schema.ListNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"actions": schema.ListNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"action": schema.StringAttribute{
										Optional: true,
										Computed: true,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"",
												"allow",
												"deny",
											),
										},
										Default: stringdefault.StaticString("allow"),
									},
									"dst_tag": schema.StringAttribute{
										Optional: true,
									},
								},
								CustomType: ActionsType{
									ObjectType: types.ObjectType{
										AttrTypes: ActionsValue{}.AttributeTypes(ctx),
									},
								},
							},
							Optional:            true,
							Description:         "- for GBP-based policy, all src_tags and dst_tags have to be gbp-based\n- for ACL-based policy, `network` is required in either the source or destination so that we know where to attach the policy to",
							MarkdownDescription: "- for GBP-based policy, all src_tags and dst_tags have to be gbp-based\n- for ACL-based policy, `network` is required in either the source or destination so that we know where to attach the policy to",
						},
						"name": schema.StringAttribute{
							Optional: true,
						},
						"src_tags": schema.ListAttribute{
							ElementType:         types.StringType,
							Optional:            true,
							Description:         "- for GBP-based policy, all src_tags and dst_tags have to be gbp-based\n- for ACL-based policy, `network` is required in either the source or destination so that we know where to attach the policy to",
							MarkdownDescription: "- for GBP-based policy, all src_tags and dst_tags have to be gbp-based\n- for ACL-based policy, `network` is required in either the source or destination so that we know where to attach the policy to",
						},
					},
					CustomType: AclPoliciesType{
						ObjectType: types.ObjectType{
							AttrTypes: AclPoliciesValue{}.AttributeTypes(ctx),
						},
					},
				},
				Optional: true,
			},
			"acl_tags": schema.MapNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"gbp_tag": schema.Int64Attribute{
							Optional:            true,
							Description:         "required if\n- `type`==`dynamic_gbp` (gbp_tag received from RADIUS)\n- `type`==`static_gbp` (applying gbp tag against matching conditions)",
							MarkdownDescription: "required if\n- `type`==`dynamic_gbp` (gbp_tag received from RADIUS)\n- `type`==`static_gbp` (applying gbp tag against matching conditions)",
						},
						"macs": schema.ListAttribute{
							ElementType:         types.StringType,
							Optional:            true,
							Description:         "required if \n- `type`==`mac`\n- `type`==`static_gbp` if from matching mac",
							MarkdownDescription: "required if \n- `type`==`mac`\n- `type`==`static_gbp` if from matching mac",
						},
						"network": schema.StringAttribute{
							Optional:            true,
							Description:         "if:\n- `type`==`mac` (optional. default is `any`)\n- `type`==`subnet` (optional. default is `any`)\n- `type`==`network`\n- `type`==`resource` (optional. default is `any`)\n- `type`==`static_gbp` if from matching network (vlan)",
							MarkdownDescription: "if:\n- `type`==`mac` (optional. default is `any`)\n- `type`==`subnet` (optional. default is `any`)\n- `type`==`network`\n- `type`==`resource` (optional. default is `any`)\n- `type`==`static_gbp` if from matching network (vlan)",
						},
						"radius_group": schema.StringAttribute{
							Optional:            true,
							Description:         "required if \n- `type`==`radius_group` \n- `type`==`static_gbp` if from matching radius_group",
							MarkdownDescription: "required if \n- `type`==`radius_group` \n- `type`==`static_gbp` if from matching radius_group",
						},
						"specs": schema.ListNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"port_range": schema.StringAttribute{
										Optional:            true,
										Computed:            true,
										Description:         "matched dst port, \"0\" means any",
										MarkdownDescription: "matched dst port, \"0\" means any",
										Default:             stringdefault.StaticString("80"),
									},
									"protocol": schema.StringAttribute{
										Optional:            true,
										Computed:            true,
										Description:         "`tcp` / `udp` / `icmp` / `gre` / `any` / `:protocol_number`. `protocol_number` is between 1-254",
										MarkdownDescription: "`tcp` / `udp` / `icmp` / `gre` / `any` / `:protocol_number`. `protocol_number` is between 1-254",
										Default:             stringdefault.StaticString("any"),
									},
								},
								CustomType: SpecsType{
									ObjectType: types.ObjectType{
										AttrTypes: SpecsValue{}.AttributeTypes(ctx),
									},
								},
							},
							Optional:            true,
							Description:         "if `type`==`resource`\nempty means unrestricted, i.e. any",
							MarkdownDescription: "if `type`==`resource`\nempty means unrestricted, i.e. any",
						},
						"subnets": schema.ListAttribute{
							ElementType:         types.StringType,
							Optional:            true,
							Description:         "if \n- `type`==`subnet` \n- `type`==`resource` (optional. default is `any`)\n- `type`==`static_gbp` if from matching subnet",
							MarkdownDescription: "if \n- `type`==`subnet` \n- `type`==`resource` (optional. default is `any`)\n- `type`==`static_gbp` if from matching subnet",
						},
						"type": schema.StringAttribute{
							Required: true,
							Validators: []validator.String{
								stringvalidator.OneOf(
									"",
									"mac",
									"subnet",
									"network",
									"radius_group",
									"any",
									"resource",
									"dynamic_gbp",
									"static_gbp",
								),
							},
						},
					},
					CustomType: AclTagsType{
						ObjectType: types.ObjectType{
							AttrTypes: AclTagsValue{}.AttributeTypes(ctx),
						},
					},
				},
				Optional:            true,
				Description:         "ACL Tags to identify traffic source or destination. Key name is the tag name",
				MarkdownDescription: "ACL Tags to identify traffic source or destination. Key name is the tag name",
			},
			"additional_config_cmds": schema.ListAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Description:         "additional CLI commands to append to the generated Junos config\n\n**Note**: no check is done",
				MarkdownDescription: "additional CLI commands to append to the generated Junos config\n\n**Note**: no check is done",
			},
			"dhcp_snooping": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"all_networks": schema.BoolAttribute{
						Optional: true,
					},
					"enable_arp_spoof_check": schema.BoolAttribute{
						Optional:            true,
						Description:         "Enable for dynamic ARP inspection check",
						MarkdownDescription: "Enable for dynamic ARP inspection check",
					},
					"enable_ip_source_guard": schema.BoolAttribute{
						Optional:            true,
						Description:         "Enable for check for forging source IP address",
						MarkdownDescription: "Enable for check for forging source IP address",
					},
					"enabled": schema.BoolAttribute{
						Optional: true,
					},
					"networks": schema.ListAttribute{
						ElementType:         types.StringType,
						Optional:            true,
						Description:         "if `all_networks`==`false`, list of network with DHCP snooping enabled",
						MarkdownDescription: "if `all_networks`==`false`, list of network with DHCP snooping enabled",
					},
				},
				CustomType: DhcpSnoopingType{
					ObjectType: types.ObjectType{
						AttrTypes: DhcpSnoopingValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
			},
			"dns_servers": schema.ListAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Description:         "Global dns settings. To keep compatibility, dns settings in `ip_config` and `oob_ip_config` will overwrite this setting",
				MarkdownDescription: "Global dns settings. To keep compatibility, dns settings in `ip_config` and `oob_ip_config` will overwrite this setting",
			},
			"dns_suffix": schema.ListAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Description:         "Global dns settings. To keep compatibility, dns settings in `ip_config` and `oob_ip_config` will overwrite this setting",
				MarkdownDescription: "Global dns settings. To keep compatibility, dns settings in `ip_config` and `oob_ip_config` will overwrite this setting",
			},
			"extra_routes": schema.MapNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"discard": schema.BoolAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "this takes precedence",
							MarkdownDescription: "this takes precedence",
							Default:             booldefault.StaticBool(false),
						},
						"metric": schema.Int64Attribute{
							Optional: true,
							Validators: []validator.Int64{
								int64validator.Between(0, 4294967295),
							},
						},
						"next_qualified": schema.MapNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"metric": schema.Int64Attribute{
										Optional: true,
									},
									"preference": schema.Int64Attribute{
										Optional: true,
									},
								},
								CustomType: NextQualifiedType{
									ObjectType: types.ObjectType{
										AttrTypes: NextQualifiedValue{}.AttributeTypes(ctx),
									},
								},
							},
							Optional: true,
						},
						"no_resolve": schema.BoolAttribute{
							Optional: true,
							Computed: true,
							Default:  booldefault.StaticBool(false),
						},
						"preference": schema.Int64Attribute{
							Optional: true,
							Validators: []validator.Int64{
								int64validator.Between(0, 4294967295),
							},
						},
						"via": schema.StringAttribute{
							Optional:            true,
							Description:         "next-hop IP Address",
							MarkdownDescription: "next-hop IP Address",
						},
					},
					CustomType: ExtraRoutesType{
						ObjectType: types.ObjectType{
							AttrTypes: ExtraRoutesValue{}.AttributeTypes(ctx),
						},
					},
				},
				Optional: true,
			},
			"extra_routes6": schema.MapNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"discard": schema.BoolAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "this takes precedence",
							MarkdownDescription: "this takes precedence",
							Default:             booldefault.StaticBool(false),
						},
						"metric": schema.Int64Attribute{
							Optional: true,
							Validators: []validator.Int64{
								int64validator.Between(0, 4294967295),
							},
						},
						"next_qualified": schema.MapNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"metric": schema.Int64Attribute{
										Optional: true,
									},
									"preference": schema.Int64Attribute{
										Optional: true,
									},
								},
								CustomType: NextQualifiedType{
									ObjectType: types.ObjectType{
										AttrTypes: NextQualifiedValue{}.AttributeTypes(ctx),
									},
								},
							},
							Optional: true,
						},
						"no_resolve": schema.BoolAttribute{
							Optional: true,
							Computed: true,
							Default:  booldefault.StaticBool(false),
						},
						"preference": schema.Int64Attribute{
							Optional: true,
							Validators: []validator.Int64{
								int64validator.Between(0, 4294967295),
							},
						},
						"via": schema.StringAttribute{
							Optional:            true,
							Description:         "next-hop IP Address",
							MarkdownDescription: "next-hop IP Address",
						},
					},
					CustomType: ExtraRoutes6Type{
						ObjectType: types.ObjectType{
							AttrTypes: ExtraRoutes6Value{}.AttributeTypes(ctx),
						},
					},
				},
				Optional:            true,
				Description:         "Property key is the destination CIDR (e.g. \"2a02:1234:420a:10c9::/64\")",
				MarkdownDescription: "Property key is the destination CIDR (e.g. \"2a02:1234:420a:10c9::/64\")",
			},
			"mist_nac": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"enabled": schema.BoolAttribute{
						Optional: true,
					},
					"network": schema.StringAttribute{
						Optional: true,
					},
				},
				CustomType: MistNacType{
					ObjectType: types.ObjectType{
						AttrTypes: MistNacValue{}.AttributeTypes(ctx),
					},
				},
				Optional:            true,
				Description:         "enable mist_nac to use radsec",
				MarkdownDescription: "enable mist_nac to use radsec",
			},
			"networks": schema.MapNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"isolation": schema.BoolAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "whether to stop clients to talk to each other, default is false (when enabled, a unique isolation_vlan_id is required)\nNOTE: this features requires uplink device to also a be Juniper device and `inter_switch_link` to be set",
							MarkdownDescription: "whether to stop clients to talk to each other, default is false (when enabled, a unique isolation_vlan_id is required)\nNOTE: this features requires uplink device to also a be Juniper device and `inter_switch_link` to be set",
							Default:             booldefault.StaticBool(false),
						},
						"isolation_vlan_id": schema.StringAttribute{
							Optional: true,
						},
						"subnet": schema.StringAttribute{
							Optional:            true,
							Description:         "optional for pure switching, required when L3 / routing features are used",
							MarkdownDescription: "optional for pure switching, required when L3 / routing features are used",
						},
						"vlan_id": schema.Int64Attribute{
							Required: true,
						},
					},
					CustomType: NetworksType{
						ObjectType: types.ObjectType{
							AttrTypes: NetworksValue{}.AttributeTypes(ctx),
						},
					},
				},
				Optional:            true,
				Description:         "Property key is network name",
				MarkdownDescription: "Property key is network name",
			},
			"ntp_servers": schema.ListAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Description:         "list of NTP servers",
				MarkdownDescription: "list of NTP servers",
			},
			"port_mirroring": schema.MapNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"input_networks_ingress": schema.ListAttribute{
							ElementType:         types.StringType,
							Optional:            true,
							Description:         "at least one of the `ingress_port_ids`, `egress_port_ids` or `ingress_networks ` should be specified",
							MarkdownDescription: "at least one of the `ingress_port_ids`, `egress_port_ids` or `ingress_networks ` should be specified",
						},
						"input_port_ids_egress": schema.ListAttribute{
							ElementType:         types.StringType,
							Optional:            true,
							Description:         "at least one of the `ingress_port_ids`, `egress_port_ids` or `ingress_networks ` should be specified",
							MarkdownDescription: "at least one of the `ingress_port_ids`, `egress_port_ids` or `ingress_networks ` should be specified",
						},
						"input_port_ids_ingress": schema.ListAttribute{
							ElementType:         types.StringType,
							Optional:            true,
							Description:         "at least one of the `ingress_port_ids`, `egress_port_ids` or `ingress_networks ` should be specified",
							MarkdownDescription: "at least one of the `ingress_port_ids`, `egress_port_ids` or `ingress_networks ` should be specified",
						},
						"output_network": schema.StringAttribute{
							Optional: true,
						},
						"output_port_id": schema.StringAttribute{
							Optional:            true,
							Description:         "exaclty on of the `output_port_id` or `output_network` should be provided",
							MarkdownDescription: "exaclty on of the `output_port_id` or `output_network` should be provided",
						},
					},
					CustomType: PortMirroringType{
						ObjectType: types.ObjectType{
							AttrTypes: PortMirroringValue{}.AttributeTypes(ctx),
						},
					},
				},
				Optional:            true,
				Description:         "Property key is the port mirroring instance name\nport_mirroring can be added under device/site settings. It takes interface and ports as input for ingress, interface as input for egress and can take interface and port as output.",
				MarkdownDescription: "Property key is the port mirroring instance name\nport_mirroring can be added under device/site settings. It takes interface and ports as input for ingress, interface as input for egress and can take interface and port as output.",
			},
			"port_usages": schema.MapNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"all_networks": schema.BoolAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "Only if `mode`==`trunk` whether to trunk all network/vlans",
							MarkdownDescription: "Only if `mode`==`trunk` whether to trunk all network/vlans",
							Default:             booldefault.StaticBool(false),
						},
						"allow_dhcpd": schema.BoolAttribute{
							Optional:            true,
							Description:         "Only if `mode`!=`dynamic` if DHCP snooping is enabled, whether DHCP server is allowed on the interfaces with. All the interfaces from port configs using this port usage are effected. Please notice that allow_dhcpd is a tri_state.\n\nWhen it is not defined, it means using the system’s default setting which depends on whether the port is a access or trunk port.",
							MarkdownDescription: "Only if `mode`!=`dynamic` if DHCP snooping is enabled, whether DHCP server is allowed on the interfaces with. All the interfaces from port configs using this port usage are effected. Please notice that allow_dhcpd is a tri_state.\n\nWhen it is not defined, it means using the system’s default setting which depends on whether the port is a access or trunk port.",
						},
						"allow_multiple_supplicants": schema.BoolAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "Only if `mode`!=`dynamic`",
							MarkdownDescription: "Only if `mode`!=`dynamic`",
							Default:             booldefault.StaticBool(false),
						},
						"bypass_auth_when_server_down": schema.BoolAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "Only if `mode`!=`dynamic` and `port_auth`==`dot1x` bypass auth for known clients if set to true when RADIUS server is down",
							MarkdownDescription: "Only if `mode`!=`dynamic` and `port_auth`==`dot1x` bypass auth for known clients if set to true when RADIUS server is down",
							Default:             booldefault.StaticBool(false),
						},
						"bypass_auth_when_server_down_for_unkonwn_client": schema.BoolAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "Only if `mode`!=`dynamic` and `port_auth`=`dot1x` bypass auth for all (including unknown clients) if set to true when RADIUS server is down",
							MarkdownDescription: "Only if `mode`!=`dynamic` and `port_auth`=`dot1x` bypass auth for all (including unknown clients) if set to true when RADIUS server is down",
							Default:             booldefault.StaticBool(false),
						},
						"description": schema.StringAttribute{
							Optional:            true,
							Description:         "Only if `mode`!=`dynamic`",
							MarkdownDescription: "Only if `mode`!=`dynamic`",
						},
						"disable_autoneg": schema.BoolAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "Only if `mode`!=`dynamic` if speed and duplex are specified, whether to disable autonegotiation",
							MarkdownDescription: "Only if `mode`!=`dynamic` if speed and duplex are specified, whether to disable autonegotiation",
							Default:             booldefault.StaticBool(false),
						},
						"disabled": schema.BoolAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "Only if `mode`!=`dynamic` whether the port is disabled",
							MarkdownDescription: "Only if `mode`!=`dynamic` whether the port is disabled",
							Default:             booldefault.StaticBool(false),
						},
						"duplex": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "Only if `mode`!=`dynamic` link connection mode",
							MarkdownDescription: "Only if `mode`!=`dynamic` link connection mode",
							Validators: []validator.String{
								stringvalidator.OneOf(
									"",
									"half",
									"full",
									"auto",
								),
							},
							Default: stringdefault.StaticString("auto"),
						},
						"dynamic_vlan_networks": schema.ListAttribute{
							ElementType:         types.StringType,
							Optional:            true,
							Computed:            true,
							Description:         "Only if `mode`!=`dynamic` if dynamic vlan is used, specify the possible networks/vlans RADIUS can return",
							MarkdownDescription: "Only if `mode`!=`dynamic` if dynamic vlan is used, specify the possible networks/vlans RADIUS can return",
							Default:             listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						},
						"enable_mac_auth": schema.BoolAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "Only if `mode`!=`dynamic` and `port_auth`==`dot1x` whether to enable MAC Auth",
							MarkdownDescription: "Only if `mode`!=`dynamic` and `port_auth`==`dot1x` whether to enable MAC Auth",
							Default:             booldefault.StaticBool(false),
						},
						"enable_qos": schema.BoolAttribute{
							Optional: true,
							Computed: true,
							Default:  booldefault.StaticBool(false),
						},
						"guest_network": schema.StringAttribute{
							Optional:            true,
							Description:         "Only if `mode`!=`dynamic` and `port_auth`==`dot1x` which network to put the device into if the device cannot do dot1x. default is null (i.e. not allowed)",
							MarkdownDescription: "Only if `mode`!=`dynamic` and `port_auth`==`dot1x` which network to put the device into if the device cannot do dot1x. default is null (i.e. not allowed)",
						},
						"inter_switch_link": schema.BoolAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "Only if `mode`!=`dynamic` inter_switch_link is used together with \"isolation\" under networks\nNOTE: inter_switch_link works only between Juniper device. This has to be applied to both ports connected together",
							MarkdownDescription: "Only if `mode`!=`dynamic` inter_switch_link is used together with \"isolation\" under networks\nNOTE: inter_switch_link works only between Juniper device. This has to be applied to both ports connected together",
							Default:             booldefault.StaticBool(false),
						},
						"mac_auth_only": schema.BoolAttribute{
							Optional:            true,
							Description:         "Only if `mode`!=`dynamic` and `enable_mac_auth`==`true`",
							MarkdownDescription: "Only if `mode`!=`dynamic` and `enable_mac_auth`==`true`",
						},
						"mac_auth_protocol": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "if `enable_mac_auth` ==`true`. This type is ignored if mist_nac is enabled.",
							MarkdownDescription: "if `enable_mac_auth` ==`true`. This type is ignored if mist_nac is enabled.",
							Validators: []validator.String{
								stringvalidator.OneOf(
									"",
									"pap",
									"eap-peap",
									"eap-md5",
								),
							},
							Default: stringdefault.StaticString("eap-md5"),
						},
						"mac_limit": schema.Int64Attribute{
							Optional:            true,
							Computed:            true,
							Description:         "Only if `mode`!=`dynamic` max number of mac addresses, default is 0 for unlimited, otherwise range is 1 or higher, with upper bound constrained by platform",
							MarkdownDescription: "Only if `mode`!=`dynamic` max number of mac addresses, default is 0 for unlimited, otherwise range is 1 or higher, with upper bound constrained by platform",
							Validators: []validator.Int64{
								int64validator.AtLeast(0),
							},
							Default: int64default.StaticInt64(0),
						},
						"mode": schema.StringAttribute{
							Optional:            true,
							Description:         "`mode`==`dynamic` must only be used with the port usage with the name `dynamic`",
							MarkdownDescription: "`mode`==`dynamic` must only be used with the port usage with the name `dynamic`",
							Validators: []validator.String{
								stringvalidator.OneOf(
									"",
									"access",
									"trunk",
									"inet",
									"dynamic",
								),
							},
						},
						"mtu": schema.Int64Attribute{
							Optional:            true,
							Description:         "Only if `mode`!=`dynamic` media maximum transmission unit (MTU) is the largest data unit that can be forwarded without fragmentation. The default value is 1514.",
							MarkdownDescription: "Only if `mode`!=`dynamic` media maximum transmission unit (MTU) is the largest data unit that can be forwarded without fragmentation. The default value is 1514.",
						},
						"networks": schema.ListAttribute{
							ElementType:         types.StringType,
							Optional:            true,
							Computed:            true,
							Description:         "Only if `mode`==`trunk`, the list of network/vlans",
							MarkdownDescription: "Only if `mode`==`trunk`, the list of network/vlans",
							Default:             listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
						},
						"persist_mac": schema.BoolAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "Only if `mode`!=`dynamic` and `mode`==`access` and `port_auth`!=`dot1x` whether the port should retain dynamically learned MAC addresses",
							MarkdownDescription: "Only if `mode`!=`dynamic` and `mode`==`access` and `port_auth`!=`dot1x` whether the port should retain dynamically learned MAC addresses",
							Default:             booldefault.StaticBool(false),
						},
						"poe_disabled": schema.BoolAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "Only if `mode`!=`dynamic` whether PoE capabilities are disabled for a port",
							MarkdownDescription: "Only if `mode`!=`dynamic` whether PoE capabilities are disabled for a port",
							Default:             booldefault.StaticBool(false),
						},
						"port_auth": schema.StringAttribute{
							Optional:            true,
							Description:         "Only if `mode`!=`dynamic` if dot1x is desired, set to dot1x",
							MarkdownDescription: "Only if `mode`!=`dynamic` if dot1x is desired, set to dot1x",
						},
						"port_network": schema.StringAttribute{
							Optional:            true,
							Description:         "Only if `mode`!=`dynamic` native network/vlan for untagged traffic",
							MarkdownDescription: "Only if `mode`!=`dynamic` native network/vlan for untagged traffic",
						},
						"reauth_interval": schema.Int64Attribute{
							Optional:            true,
							Computed:            true,
							Description:         "Only if `mode`!=`dynamic` and `port_auth`=`dot1x` reauthentication interval range",
							MarkdownDescription: "Only if `mode`!=`dynamic` and `port_auth`=`dot1x` reauthentication interval range",
							Validators: []validator.Int64{
								int64validator.Between(10, 65535),
							},
							Default: int64default.StaticInt64(3600),
						},
						"rejected_network": schema.StringAttribute{
							Optional:            true,
							Description:         "Only if `mode`!=`dynamic` and `port_auth`==`dot1x` when radius server reject / fails",
							MarkdownDescription: "Only if `mode`!=`dynamic` and `port_auth`==`dot1x` when radius server reject / fails",
						},
						"reset_default_when": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "Only if `mode`==`dynamic` Control when the DPC port should be changed to the default port usage\nConfiguring to none will let the DPC port keep at the current port usage.",
							MarkdownDescription: "Only if `mode`==`dynamic` Control when the DPC port should be changed to the default port usage\nConfiguring to none will let the DPC port keep at the current port usage.",
							Validators: []validator.String{
								stringvalidator.OneOf(
									"",
									"none",
									"link_down",
								),
							},
							Default: stringdefault.StaticString("link_down"),
						},
						"rules": schema.ListNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"equals": schema.StringAttribute{
										Optional: true,
									},
									"equals_any": schema.ListAttribute{
										ElementType:         types.StringType,
										Optional:            true,
										Description:         "use `equals_any` to match any item in a list",
										MarkdownDescription: "use `equals_any` to match any item in a list",
									},
									"expression": schema.StringAttribute{
										Optional:            true,
										Description:         "\"[0:3]\":\"abcdef\" -> \"abc\"\n\"split(.)[1]\": \"a.b.c\" -> \"b\"\n\"split(-)[1][0:3]: \"a1234-b5678-c90\" -> \"b56\"",
										MarkdownDescription: "\"[0:3]\":\"abcdef\" -> \"abc\"\n\"split(.)[1]\": \"a.b.c\" -> \"b\"\n\"split(-)[1][0:3]: \"a1234-b5678-c90\" -> \"b56\"",
									},
									"src": schema.StringAttribute{
										Required: true,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"",
												"lldp_chassis_id",
												"lldp_system_name",
												"lldp_serial_number",
												"lldp_hardware_revision",
												"lldp_manufacturer_name",
												"lldp_oui",
												"radius_username",
												"radius_usermac",
												"radius_dynamicfilter",
												"link_peermac",
											),
										},
									},
									"usage": schema.StringAttribute{
										Optional:            true,
										Description:         "`port_usage` name",
										MarkdownDescription: "`port_usage` name",
									},
								},
								CustomType: RulesType{
									ObjectType: types.ObjectType{
										AttrTypes: RulesValue{}.AttributeTypes(ctx),
									},
								},
							},
							Optional:            true,
							Description:         "Only if `mode`==`dynamic`",
							MarkdownDescription: "Only if `mode`==`dynamic`",
						},
						"speed": schema.StringAttribute{
							Optional:            true,
							Description:         "Only if `mode`!=`dynamic` speed, default is auto to automatically negotiate speed",
							MarkdownDescription: "Only if `mode`!=`dynamic` speed, default is auto to automatically negotiate speed",
						},
						"storm_control": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"no_broadcast": schema.BoolAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "whether to disable storm control on broadcast traffic",
									MarkdownDescription: "whether to disable storm control on broadcast traffic",
									Default:             booldefault.StaticBool(false),
								},
								"no_multicast": schema.BoolAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "whether to disable storm control on multicast traffic",
									MarkdownDescription: "whether to disable storm control on multicast traffic",
									Default:             booldefault.StaticBool(false),
								},
								"no_registered_multicast": schema.BoolAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "whether to disable storm control on registered multicast traffic",
									MarkdownDescription: "whether to disable storm control on registered multicast traffic",
									Default:             booldefault.StaticBool(false),
								},
								"no_unknown_unicast": schema.BoolAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "whether to disable storm control on unknown unicast traffic",
									MarkdownDescription: "whether to disable storm control on unknown unicast traffic",
									Default:             booldefault.StaticBool(false),
								},
								"percentage": schema.Int64Attribute{
									Optional:            true,
									Computed:            true,
									Description:         "bandwidth-percentage, configures the storm control level as a percentage of the available bandwidth",
									MarkdownDescription: "bandwidth-percentage, configures the storm control level as a percentage of the available bandwidth",
									Validators: []validator.Int64{
										int64validator.Between(0, 100),
									},
									Default: int64default.StaticInt64(80),
								},
							},
							CustomType: StormControlType{
								ObjectType: types.ObjectType{
									AttrTypes: StormControlValue{}.AttributeTypes(ctx),
								},
							},
							Optional:            true,
							Description:         "Switch storm control\nOnly if `mode`!=`dynamic`",
							MarkdownDescription: "Switch storm control\nOnly if `mode`!=`dynamic`",
						},
						"stp_edge": schema.BoolAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "Only if `mode`!=`dynamic` when enabled, the port is not expected to receive BPDU frames",
							MarkdownDescription: "Only if `mode`!=`dynamic` when enabled, the port is not expected to receive BPDU frames",
							Default:             booldefault.StaticBool(false),
						},
						"voip_network": schema.StringAttribute{
							Optional:            true,
							Description:         "Only if `mode`!=`dynamic` network/vlan for voip traffic, must also set port_network. to authenticate device, set port_auth",
							MarkdownDescription: "Only if `mode`!=`dynamic` network/vlan for voip traffic, must also set port_network. to authenticate device, set port_auth",
						},
					},
					CustomType: PortUsagesType{
						ObjectType: types.ObjectType{
							AttrTypes: PortUsagesValue{}.AttributeTypes(ctx),
						},
					},
				},
				Optional: true,
			},
			"radius_config": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"acct_interim_interval": schema.Int64Attribute{
						Optional:            true,
						Computed:            true,
						Description:         "how frequently should interim accounting be reported, 60-65535. default is 0 (use one specified in Access-Accept request from RADIUS Server). Very frequent messages can affect the performance of the radius server, 600 and up is recommended when enabled",
						MarkdownDescription: "how frequently should interim accounting be reported, 60-65535. default is 0 (use one specified in Access-Accept request from RADIUS Server). Very frequent messages can affect the performance of the radius server, 600 and up is recommended when enabled",
						Validators: []validator.Int64{
							int64validator.Between(0, 65535),
						},
						Default: int64default.StaticInt64(0),
					},
					"acct_servers": schema.ListNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"host": schema.StringAttribute{
									Required:            true,
									Description:         "ip / hostname of RADIUS server",
									MarkdownDescription: "ip / hostname of RADIUS server",
								},
								"keywrap_enabled": schema.BoolAttribute{
									Optional: true,
								},
								"keywrap_format": schema.StringAttribute{
									Optional: true,
									Validators: []validator.String{
										stringvalidator.OneOf(
											"",
											"hex",
											"ascii",
										),
									},
								},
								"keywrap_kek": schema.StringAttribute{
									Optional: true,
								},
								"keywrap_mack": schema.StringAttribute{
									Optional: true,
								},
								"port": schema.Int64Attribute{
									Optional:            true,
									Computed:            true,
									Description:         "Acct port of RADIUS server",
									MarkdownDescription: "Acct port of RADIUS server",
									Default:             int64default.StaticInt64(1813),
								},
								"secret": schema.StringAttribute{
									Required:            true,
									Sensitive:           true,
									Description:         "secret of RADIUS server",
									MarkdownDescription: "secret of RADIUS server",
								},
							},
							CustomType: AcctServersType{
								ObjectType: types.ObjectType{
									AttrTypes: AcctServersValue{}.AttributeTypes(ctx),
								},
							},
						},
						Optional: true,
						Validators: []validator.List{
							listvalidator.UniqueValues(),
						},
					},
					"auth_servers": schema.ListNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"host": schema.StringAttribute{
									Required:            true,
									Description:         "ip / hostname of RADIUS server",
									MarkdownDescription: "ip / hostname of RADIUS server",
								},
								"keywrap_enabled": schema.BoolAttribute{
									Optional: true,
								},
								"keywrap_format": schema.StringAttribute{
									Optional: true,
									Validators: []validator.String{
										stringvalidator.OneOf(
											"",
											"hex",
											"ascii",
										),
									},
								},
								"keywrap_kek": schema.StringAttribute{
									Optional: true,
								},
								"keywrap_mack": schema.StringAttribute{
									Optional: true,
								},
								"port": schema.Int64Attribute{
									Optional:            true,
									Computed:            true,
									Description:         "Auth port of RADIUS server",
									MarkdownDescription: "Auth port of RADIUS server",
									Default:             int64default.StaticInt64(1812),
								},
								"secret": schema.StringAttribute{
									Required:            true,
									Sensitive:           true,
									Description:         "secret of RADIUS server",
									MarkdownDescription: "secret of RADIUS server",
								},
							},
							CustomType: AuthServersType{
								ObjectType: types.ObjectType{
									AttrTypes: AuthServersValue{}.AttributeTypes(ctx),
								},
							},
						},
						Optional: true,
						Validators: []validator.List{
							listvalidator.SizeAtLeast(1),
							listvalidator.UniqueValues(),
						},
					},
					"auth_servers_retries": schema.Int64Attribute{
						Optional:            true,
						Computed:            true,
						Description:         "radius auth session retries",
						MarkdownDescription: "radius auth session retries",
						Default:             int64default.StaticInt64(3),
					},
					"auth_servers_timeout": schema.Int64Attribute{
						Optional:            true,
						Computed:            true,
						Description:         "radius auth session timeout",
						MarkdownDescription: "radius auth session timeout",
						Default:             int64default.StaticInt64(5),
					},
					"coa_enabled": schema.BoolAttribute{
						Optional: true,
						Computed: true,
						Default:  booldefault.StaticBool(false),
					},
					"coa_port": schema.Int64Attribute{
						Optional: true,
						Computed: true,
						Default:  int64default.StaticInt64(3799),
					},
					"network": schema.StringAttribute{
						Optional:            true,
						Description:         "use `network`or `source_ip`\nwhich network the RADIUS server resides, if there's static IP for this network, we'd use it as source-ip",
						MarkdownDescription: "use `network`or `source_ip`\nwhich network the RADIUS server resides, if there's static IP for this network, we'd use it as source-ip",
					},
					"source_ip": schema.StringAttribute{
						Optional:            true,
						Description:         "use `network`or `source_ip`",
						MarkdownDescription: "use `network`or `source_ip`",
					},
				},
				CustomType: RadiusConfigType{
					ObjectType: types.ObjectType{
						AttrTypes: RadiusConfigValue{}.AttributeTypes(ctx),
					},
				},
				Optional:            true,
				Description:         "Junos Radius config",
				MarkdownDescription: "Junos Radius config",
			},
			"remote_syslog": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"archive": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"files": schema.Int64Attribute{
								Optional: true,
							},
							"size": schema.StringAttribute{
								Optional: true,
							},
						},
						CustomType: ArchiveType{
							ObjectType: types.ObjectType{
								AttrTypes: ArchiveValue{}.AttributeTypes(ctx),
							},
						},
						Optional: true,
					},
					"console": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"contents": schema.ListNestedAttribute{
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"facility": schema.StringAttribute{
											Optional: true,
											Computed: true,
											Validators: []validator.String{
												stringvalidator.OneOf(
													"",
													"any",
													"authorization",
													"conflict-log",
													"change-log",
													"config",
													"daemon",
													"dfc",
													"kernel",
													"interactive-commands",
													"ftp",
													"firewall",
													"external",
													"pfe",
													"ntp",
													"security",
													"user",
												),
											},
											Default: stringdefault.StaticString("any"),
										},
										"severity": schema.StringAttribute{
											Optional: true,
											Computed: true,
											Validators: []validator.String{
												stringvalidator.OneOf(
													"",
													"any",
													"alert",
													"emergency",
													"critical",
													"warning",
													"info",
													"notice",
													"error",
												),
											},
											Default: stringdefault.StaticString("any"),
										},
									},
									CustomType: ContentsType{
										ObjectType: types.ObjectType{
											AttrTypes: ContentsValue{}.AttributeTypes(ctx),
										},
									},
								},
								Optional: true,
							},
						},
						CustomType: ConsoleType{
							ObjectType: types.ObjectType{
								AttrTypes: ConsoleValue{}.AttributeTypes(ctx),
							},
						},
						Optional: true,
					},
					"enabled": schema.BoolAttribute{
						Optional: true,
						Computed: true,
						Default:  booldefault.StaticBool(false),
					},
					"files": schema.ListNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"archive": schema.SingleNestedAttribute{
									Attributes: map[string]schema.Attribute{
										"files": schema.Int64Attribute{
											Optional: true,
										},
										"size": schema.StringAttribute{
											Optional: true,
										},
									},
									CustomType: ArchiveType{
										ObjectType: types.ObjectType{
											AttrTypes: ArchiveValue{}.AttributeTypes(ctx),
										},
									},
									Optional: true,
								},
								"contents": schema.ListNestedAttribute{
									NestedObject: schema.NestedAttributeObject{
										Attributes: map[string]schema.Attribute{
											"facility": schema.StringAttribute{
												Optional: true,
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"",
														"any",
														"authorization",
														"conflict-log",
														"change-log",
														"config",
														"daemon",
														"dfc",
														"kernel",
														"interactive-commands",
														"ftp",
														"firewall",
														"external",
														"pfe",
														"ntp",
														"security",
														"user",
													),
												},
												Default: stringdefault.StaticString("any"),
											},
											"severity": schema.StringAttribute{
												Optional: true,
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"",
														"any",
														"alert",
														"emergency",
														"critical",
														"warning",
														"info",
														"notice",
														"error",
													),
												},
												Default: stringdefault.StaticString("any"),
											},
										},
										CustomType: ContentsType{
											ObjectType: types.ObjectType{
												AttrTypes: ContentsValue{}.AttributeTypes(ctx),
											},
										},
									},
									Optional: true,
								},
								"explicit_priority": schema.BoolAttribute{
									Optional: true,
								},
								"file": schema.StringAttribute{
									Optional: true,
								},
								"match": schema.StringAttribute{
									Optional: true,
								},
								"structured_data": schema.BoolAttribute{
									Optional: true,
								},
							},
							CustomType: FilesType{
								ObjectType: types.ObjectType{
									AttrTypes: FilesValue{}.AttributeTypes(ctx),
								},
							},
						},
						Optional: true,
					},
					"network": schema.StringAttribute{
						Optional:            true,
						Description:         "if source_address is configured, will use the vlan firstly otherwise use source_ip",
						MarkdownDescription: "if source_address is configured, will use the vlan firstly otherwise use source_ip",
					},
					"send_to_all_servers": schema.BoolAttribute{
						Optional: true,
						Computed: true,
						Default:  booldefault.StaticBool(false),
					},
					"servers": schema.ListNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"contents": schema.ListNestedAttribute{
									NestedObject: schema.NestedAttributeObject{
										Attributes: map[string]schema.Attribute{
											"facility": schema.StringAttribute{
												Optional: true,
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"",
														"any",
														"authorization",
														"conflict-log",
														"change-log",
														"config",
														"daemon",
														"dfc",
														"kernel",
														"interactive-commands",
														"ftp",
														"firewall",
														"external",
														"pfe",
														"ntp",
														"security",
														"user",
													),
												},
												Default: stringdefault.StaticString("any"),
											},
											"severity": schema.StringAttribute{
												Optional: true,
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"",
														"any",
														"alert",
														"emergency",
														"critical",
														"warning",
														"info",
														"notice",
														"error",
													),
												},
												Default: stringdefault.StaticString("any"),
											},
										},
										CustomType: ContentsType{
											ObjectType: types.ObjectType{
												AttrTypes: ContentsValue{}.AttributeTypes(ctx),
											},
										},
									},
									Optional: true,
								},
								"explicit_priority": schema.BoolAttribute{
									Optional: true,
								},
								"facility": schema.StringAttribute{
									Optional: true,
									Computed: true,
									Validators: []validator.String{
										stringvalidator.OneOf(
											"",
											"any",
											"authorization",
											"conflict-log",
											"change-log",
											"config",
											"daemon",
											"dfc",
											"kernel",
											"interactive-commands",
											"ftp",
											"firewall",
											"external",
											"pfe",
											"ntp",
											"security",
											"user",
										),
									},
									Default: stringdefault.StaticString("any"),
								},
								"host": schema.StringAttribute{
									Optional: true,
								},
								"match": schema.StringAttribute{
									Optional: true,
								},
								"port": schema.Int64Attribute{
									Optional: true,
									Computed: true,
									Default:  int64default.StaticInt64(514),
								},
								"protocol": schema.StringAttribute{
									Optional: true,
									Computed: true,
									Validators: []validator.String{
										stringvalidator.OneOf(
											"",
											"udp",
											"tcp",
										),
									},
									Default: stringdefault.StaticString("udp"),
								},
								"routing_instance": schema.StringAttribute{
									Optional: true,
								},
								"severity": schema.StringAttribute{
									Optional: true,
									Computed: true,
									Validators: []validator.String{
										stringvalidator.OneOf(
											"",
											"any",
											"alert",
											"emergency",
											"critical",
											"warning",
											"info",
											"notice",
											"error",
										),
									},
									Default: stringdefault.StaticString("any"),
								},
								"source_address": schema.StringAttribute{
									Optional:            true,
									Description:         "if source_address is configured, will use the vlan firstly otherwise use source_ip",
									MarkdownDescription: "if source_address is configured, will use the vlan firstly otherwise use source_ip",
								},
								"structured_data": schema.BoolAttribute{
									Optional: true,
								},
								"tag": schema.StringAttribute{
									Optional: true,
								},
							},
							CustomType: ServersType{
								ObjectType: types.ObjectType{
									AttrTypes: ServersValue{}.AttributeTypes(ctx),
								},
							},
						},
						Optional: true,
					},
					"time_format": schema.StringAttribute{
						Optional: true,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"",
								"millisecond",
								"year",
								"year millisecond",
							),
						},
					},
					"users": schema.ListNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"contents": schema.ListNestedAttribute{
									NestedObject: schema.NestedAttributeObject{
										Attributes: map[string]schema.Attribute{
											"facility": schema.StringAttribute{
												Optional: true,
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"",
														"any",
														"authorization",
														"conflict-log",
														"change-log",
														"config",
														"daemon",
														"dfc",
														"kernel",
														"interactive-commands",
														"ftp",
														"firewall",
														"external",
														"pfe",
														"ntp",
														"security",
														"user",
													),
												},
												Default: stringdefault.StaticString("any"),
											},
											"severity": schema.StringAttribute{
												Optional: true,
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"",
														"any",
														"alert",
														"emergency",
														"critical",
														"warning",
														"info",
														"notice",
														"error",
													),
												},
												Default: stringdefault.StaticString("any"),
											},
										},
										CustomType: ContentsType{
											ObjectType: types.ObjectType{
												AttrTypes: ContentsValue{}.AttributeTypes(ctx),
											},
										},
									},
									Optional: true,
								},
								"match": schema.StringAttribute{
									Optional: true,
								},
								"user": schema.StringAttribute{
									Optional: true,
								},
							},
							CustomType: UsersType{
								ObjectType: types.ObjectType{
									AttrTypes: UsersValue{}.AttributeTypes(ctx),
								},
							},
						},
						Optional: true,
					},
				},
				CustomType: RemoteSyslogType{
					ObjectType: types.ObjectType{
						AttrTypes: RemoteSyslogValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
			},
			"site_id": schema.StringAttribute{
				Optional: true,
				Computed: true,
			},
			"snmp_config": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"client_list": schema.ListNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"client_list_name": schema.StringAttribute{
									Optional: true,
								},
								"clients": schema.ListAttribute{
									ElementType: types.StringType,
									Optional:    true,
								},
							},
							CustomType: ClientListType{
								ObjectType: types.ObjectType{
									AttrTypes: ClientListValue{}.AttributeTypes(ctx),
								},
							},
						},
						Optional: true,
					},
					"contact": schema.StringAttribute{
						Optional: true,
					},
					"description": schema.StringAttribute{
						Optional: true,
					},
					"enabled": schema.BoolAttribute{
						Optional: true,
						Computed: true,
						Default:  booldefault.StaticBool(true),
					},
					"engine_id": schema.StringAttribute{
						Optional: true,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"",
								"local",
								"engine-id-suffix",
								"use-default-ip-address",
								"use_mac-address",
							),
						},
					},
					"location": schema.StringAttribute{
						Optional: true,
					},
					"name": schema.StringAttribute{
						Optional: true,
					},
					"network": schema.StringAttribute{
						Optional: true,
						Computed: true,
						Default:  stringdefault.StaticString("default"),
					},
					"trap_groups": schema.ListNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"categories": schema.ListAttribute{
									ElementType: types.StringType,
									Optional:    true,
								},
								"group_name": schema.StringAttribute{
									Optional:            true,
									Description:         "Categories list can refer to https://www.juniper.net/documentation/software/topics/task/configuration/snmp_trap-groups-configuring-junos-nm.html",
									MarkdownDescription: "Categories list can refer to https://www.juniper.net/documentation/software/topics/task/configuration/snmp_trap-groups-configuring-junos-nm.html",
								},
								"targets": schema.ListAttribute{
									ElementType: types.StringType,
									Optional:    true,
								},
								"version": schema.StringAttribute{
									Optional: true,
									Computed: true,
									Validators: []validator.String{
										stringvalidator.OneOf(
											"",
											"v1",
											"v2",
											"all",
										),
									},
									Default: stringdefault.StaticString("v2"),
								},
							},
							CustomType: TrapGroupsType{
								ObjectType: types.ObjectType{
									AttrTypes: TrapGroupsValue{}.AttributeTypes(ctx),
								},
							},
						},
						Optional: true,
					},
					"v2c_config": schema.ListNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"authorization": schema.StringAttribute{
									Optional: true,
								},
								"client_list_name": schema.StringAttribute{
									Optional:            true,
									Description:         "client_list_name here should refer to client_list above",
									MarkdownDescription: "client_list_name here should refer to client_list above",
								},
								"community_name": schema.StringAttribute{
									Optional: true,
								},
								"view": schema.StringAttribute{
									Optional:            true,
									Description:         "view name here should be defined in views above",
									MarkdownDescription: "view name here should be defined in views above",
								},
							},
							CustomType: V2cConfigType{
								ObjectType: types.ObjectType{
									AttrTypes: V2cConfigValue{}.AttributeTypes(ctx),
								},
							},
						},
						Optional: true,
					},
					"v3_config": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"notify": schema.ListNestedAttribute{
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											Optional: true,
										},
										"tag": schema.StringAttribute{
											Optional: true,
										},
										"type": schema.StringAttribute{
											Optional: true,
											Validators: []validator.String{
												stringvalidator.OneOf(
													"",
													"trap",
													"inform",
												),
											},
										},
									},
									CustomType: NotifyType{
										ObjectType: types.ObjectType{
											AttrTypes: NotifyValue{}.AttributeTypes(ctx),
										},
									},
								},
								Optional: true,
							},
							"notify_filter": schema.ListNestedAttribute{
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"profile_name": schema.StringAttribute{
											Optional: true,
										},
										"contents": schema.ListNestedAttribute{
											NestedObject: schema.NestedAttributeObject{
												Attributes: map[string]schema.Attribute{
													"include": schema.BoolAttribute{
														Optional: true,
													},
													"oid": schema.StringAttribute{
														Optional: true,
													},
												},
												CustomType: Snmpv3ContentsType{
													ObjectType: types.ObjectType{
														AttrTypes: Snmpv3ContentsValue{}.AttributeTypes(ctx),
													},
												},
											},
											Optional: true,
										},
									},
									CustomType: NotifyFilterType{
										ObjectType: types.ObjectType{
											AttrTypes: NotifyFilterValue{}.AttributeTypes(ctx),
										},
									},
								},
								Optional: true,
							},
							"target_address": schema.ListNestedAttribute{
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"address": schema.StringAttribute{
											Optional: true,
										},
										"address_mask": schema.StringAttribute{
											Optional: true,
										},
										"port": schema.Int64Attribute{
											Optional: true,
											Computed: true,
											Default:  int64default.StaticInt64(161),
										},
										"tag_list": schema.StringAttribute{
											Optional:            true,
											Description:         "<refer to notify tag, can be multiple with blank",
											MarkdownDescription: "<refer to notify tag, can be multiple with blank",
										},
										"target_address_name": schema.StringAttribute{
											Optional: true,
										},
										"target_parameters": schema.StringAttribute{
											Optional:            true,
											Description:         "refer to notify target parameters name",
											MarkdownDescription: "refer to notify target parameters name",
										},
									},
									CustomType: TargetAddressType{
										ObjectType: types.ObjectType{
											AttrTypes: TargetAddressValue{}.AttributeTypes(ctx),
										},
									},
								},
								Optional: true,
							},
							"target_parameters": schema.ListNestedAttribute{
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"message_processing_model": schema.StringAttribute{
											Optional: true,
											Validators: []validator.String{
												stringvalidator.OneOf(
													"",
													"v1",
													"v2c",
													"v3",
												),
											},
										},
										"name": schema.StringAttribute{
											Optional: true,
										},
										"notify_filter": schema.StringAttribute{
											Optional:            true,
											Description:         "refer to profile-name in notify_filter",
											MarkdownDescription: "refer to profile-name in notify_filter",
										},
										"security_level": schema.StringAttribute{
											Optional: true,
											Validators: []validator.String{
												stringvalidator.OneOf(
													"",
													"authentication",
													"none",
													"privacy",
												),
											},
										},
										"security_model": schema.StringAttribute{
											Optional: true,
											Validators: []validator.String{
												stringvalidator.OneOf(
													"",
													"usm",
													"v1",
													"v2c",
												),
											},
										},
										"security_name": schema.StringAttribute{
											Optional:            true,
											Description:         "refer to security_name in usm",
											MarkdownDescription: "refer to security_name in usm",
										},
									},
									CustomType: TargetParametersType{
										ObjectType: types.ObjectType{
											AttrTypes: TargetParametersValue{}.AttributeTypes(ctx),
										},
									},
								},
								Optional: true,
							},
							"usm": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{
									"engine_type": schema.StringAttribute{
										Optional: true,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"",
												"remote_engine",
												"local_engine",
											),
										},
									},
									"engineid": schema.StringAttribute{
										Optional:            true,
										Description:         "required only if `engine_type`==`remote_engine`",
										MarkdownDescription: "required only if `engine_type`==`remote_engine`",
									},
									"users": schema.ListNestedAttribute{
										NestedObject: schema.NestedAttributeObject{
											Attributes: map[string]schema.Attribute{
												"authentication_password": schema.StringAttribute{
													Optional:            true,
													Sensitive:           true,
													Description:         "Not required if `authentication_type`==`authentication_none`\ninclude alphabetic, numeric, and special characters, but it cannot include control characters.",
													MarkdownDescription: "Not required if `authentication_type`==`authentication_none`\ninclude alphabetic, numeric, and special characters, but it cannot include control characters.",
													Validators: []validator.String{
														stringvalidator.LengthAtLeast(7),
													},
												},
												"authentication_type": schema.StringAttribute{
													Optional:            true,
													Description:         "sha224, sha256, sha384, sha512 are supported in 21.1 and newer release",
													MarkdownDescription: "sha224, sha256, sha384, sha512 are supported in 21.1 and newer release",
													Validators: []validator.String{
														stringvalidator.OneOf(
															"",
															"authentication_md5",
															"authentication_sha",
															"authentication_sha224",
															"authentication_sha256",
															"authentication_sha384",
															"authentication_sha512",
															"authentication_none",
														),
													},
												},
												"encryption_password": schema.StringAttribute{
													Optional:            true,
													Sensitive:           true,
													Description:         "Not required if `encryption_type`==`privacy-none`\ninclude alphabetic, numeric, and special characters, but it cannot include control characters",
													MarkdownDescription: "Not required if `encryption_type`==`privacy-none`\ninclude alphabetic, numeric, and special characters, but it cannot include control characters",
													Validators: []validator.String{
														stringvalidator.LengthAtLeast(8),
													},
												},
												"encryption_type": schema.StringAttribute{
													Optional: true,
													Validators: []validator.String{
														stringvalidator.OneOf(
															"",
															"privacy-aes128",
															"privacy-des",
															"privacy-3des",
															"privacy-none",
														),
													},
												},
												"name": schema.StringAttribute{
													Optional: true,
												},
											},
											CustomType: Snmpv3UsersType{
												ObjectType: types.ObjectType{
													AttrTypes: Snmpv3UsersValue{}.AttributeTypes(ctx),
												},
											},
										},
										Optional: true,
									},
								},
								CustomType: UsmType{
									ObjectType: types.ObjectType{
										AttrTypes: UsmValue{}.AttributeTypes(ctx),
									},
								},
								Optional: true,
							},
							"vacm": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{
									"access": schema.ListNestedAttribute{
										NestedObject: schema.NestedAttributeObject{
											Attributes: map[string]schema.Attribute{
												"group_name": schema.StringAttribute{
													Optional: true,
												},
												"prefix_list": schema.ListNestedAttribute{
													NestedObject: schema.NestedAttributeObject{
														Attributes: map[string]schema.Attribute{
															"context_prefix": schema.StringAttribute{
																Optional:            true,
																Description:         "only required if `type`==`context_prefix`",
																MarkdownDescription: "only required if `type`==`context_prefix`",
															},
															"notify_view": schema.StringAttribute{
																Optional:            true,
																Description:         "refer to view name",
																MarkdownDescription: "refer to view name",
															},
															"read_view": schema.StringAttribute{
																Optional:            true,
																Description:         "refer to view name",
																MarkdownDescription: "refer to view name",
															},
															"security_level": schema.StringAttribute{
																Optional: true,
																Validators: []validator.String{
																	stringvalidator.OneOf(
																		"",
																		"privacy",
																		"authentication",
																		"none",
																	),
																},
															},
															"security_model": schema.StringAttribute{
																Optional: true,
																Validators: []validator.String{
																	stringvalidator.OneOf(
																		"",
																		"any",
																		"usm",
																		"v1",
																		"v2c",
																	),
																},
															},
															"type": schema.StringAttribute{
																Optional: true,
																Validators: []validator.String{
																	stringvalidator.OneOf(
																		"",
																		"default_context_prefix",
																	),
																},
															},
															"write_view": schema.StringAttribute{
																Optional:            true,
																Description:         "refer to view name",
																MarkdownDescription: "refer to view name",
															},
														},
														CustomType: PrefixListType{
															ObjectType: types.ObjectType{
																AttrTypes: PrefixListValue{}.AttributeTypes(ctx),
															},
														},
													},
													Optional: true,
												},
											},
											CustomType: AccessType{
												ObjectType: types.ObjectType{
													AttrTypes: AccessValue{}.AttributeTypes(ctx),
												},
											},
										},
										Optional: true,
									},
									"security_to_group": schema.SingleNestedAttribute{
										Attributes: map[string]schema.Attribute{
											"security_model": schema.StringAttribute{
												Optional: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"",
														"usm",
														"v1",
														"v2c",
													),
												},
											},
											"content": schema.ListNestedAttribute{
												NestedObject: schema.NestedAttributeObject{
													Attributes: map[string]schema.Attribute{
														"group": schema.StringAttribute{
															Optional:            true,
															Description:         "refer to group_name under access",
															MarkdownDescription: "refer to group_name under access",
														},
														"security_name": schema.StringAttribute{
															Optional: true,
														},
													},
													CustomType: Snmpv3VacmContentType{
														ObjectType: types.ObjectType{
															AttrTypes: Snmpv3VacmContentValue{}.AttributeTypes(ctx),
														},
													},
												},
												Optional: true,
											},
										},
										CustomType: SecurityToGroupType{
											ObjectType: types.ObjectType{
												AttrTypes: SecurityToGroupValue{}.AttributeTypes(ctx),
											},
										},
										Optional: true,
									},
								},
								CustomType: VacmType{
									ObjectType: types.ObjectType{
										AttrTypes: VacmValue{}.AttributeTypes(ctx),
									},
								},
								Optional: true,
							},
						},
						CustomType: V3ConfigType{
							ObjectType: types.ObjectType{
								AttrTypes: V3ConfigValue{}.AttributeTypes(ctx),
							},
						},
						Optional: true,
					},
					"views": schema.ListNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"include": schema.BoolAttribute{
									Optional:            true,
									Description:         "if the root oid configured is included",
									MarkdownDescription: "if the root oid configured is included",
								},
								"oid": schema.StringAttribute{
									Optional: true,
								},
								"view_name": schema.StringAttribute{
									Optional: true,
								},
							},
							CustomType: ViewsType{
								ObjectType: types.ObjectType{
									AttrTypes: ViewsValue{}.AttributeTypes(ctx),
								},
							},
						},
						Optional: true,
					},
				},
				CustomType: SnmpConfigType{
					ObjectType: types.ObjectType{
						AttrTypes: SnmpConfigValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
			},
			"switch_matching": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"enable": schema.BoolAttribute{
						Optional: true,
					},
					"rules": schema.ListNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"additional_config_cmds": schema.ListAttribute{
									ElementType:         types.StringType,
									Optional:            true,
									Description:         "additional CLI commands to append to the generated Junos config\n\n**Note**: no check is done",
									MarkdownDescription: "additional CLI commands to append to the generated Junos config\n\n**Note**: no check is done",
								},
								"match_role": schema.StringAttribute{
									Optional:            true,
									Description:         "role to match",
									MarkdownDescription: "role to match",
								},
								"match_type": schema.StringAttribute{
									Optional:            true,
									Description:         "'property key define the type of matching, value is the string to match. e.g: `match_name[0:3]`, `match_name[2:6]`, `match_model`,  `match_model[0-6]`",
									MarkdownDescription: "'property key define the type of matching, value is the string to match. e.g: `match_name[0:3]`, `match_name[2:6]`, `match_model`,  `match_model[0-6]`",
								},
								"match_value": schema.StringAttribute{
									Optional: true,
								},
								"name": schema.StringAttribute{
									Optional: true,
								},
								"port_config": schema.MapNestedAttribute{
									NestedObject: schema.NestedAttributeObject{
										Attributes: map[string]schema.Attribute{
											"ae_disable_lacp": schema.BoolAttribute{
												Optional:            true,
												Description:         "To disable LACP support for the AE interface",
												MarkdownDescription: "To disable LACP support for the AE interface",
											},
											"ae_idx": schema.Int64Attribute{
												Optional:            true,
												Description:         "Users could force to use the designated AE name",
												MarkdownDescription: "Users could force to use the designated AE name",
											},
											"ae_lacp_slow": schema.BoolAttribute{
												Optional:            true,
												Computed:            true,
												Description:         "to use fast timeout",
												MarkdownDescription: "to use fast timeout",
												Default:             booldefault.StaticBool(true),
											},
											"aggregated": schema.BoolAttribute{
												Optional: true,
												Computed: true,
												Default:  booldefault.StaticBool(false),
											},
											"critical": schema.BoolAttribute{
												Optional:            true,
												Description:         "if want to generate port up/down alarm",
												MarkdownDescription: "if want to generate port up/down alarm",
											},
											"description": schema.StringAttribute{
												Optional: true,
											},
											"disable_autoneg": schema.BoolAttribute{
												Optional:            true,
												Computed:            true,
												Description:         "if `speed` and `duplex` are specified, whether to disable autonegotiation",
												MarkdownDescription: "if `speed` and `duplex` are specified, whether to disable autonegotiation",
												Default:             booldefault.StaticBool(false),
											},
											"duplex": schema.StringAttribute{
												Optional: true,
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"",
														"auto",
														"full",
														"half",
													),
												},
												Default: stringdefault.StaticString("auto"),
											},
											"dynamic_usage": schema.StringAttribute{
												Optional:            true,
												Description:         "Enable dynamic usage for this port. Set to `dynamic` to enable.",
												MarkdownDescription: "Enable dynamic usage for this port. Set to `dynamic` to enable.",
											},
											"esilag": schema.BoolAttribute{
												Optional: true,
											},
											"mtu": schema.Int64Attribute{
												Optional:            true,
												Computed:            true,
												Description:         "media maximum transmission unit (MTU) is the largest data unit that can be forwarded without fragmentation",
												MarkdownDescription: "media maximum transmission unit (MTU) is the largest data unit that can be forwarded without fragmentation",
												Default:             int64default.StaticInt64(1514),
											},
											"no_local_overwrite": schema.BoolAttribute{
												Optional:            true,
												Description:         "prevent helpdesk to override the port config",
												MarkdownDescription: "prevent helpdesk to override the port config",
											},
											"poe_disabled": schema.BoolAttribute{
												Optional: true,
												Computed: true,
												Default:  booldefault.StaticBool(false),
											},
											"speed": schema.StringAttribute{
												Optional: true,
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"",
														"auto",
														"10m",
														"100m",
														"1g",
														"2.5g",
														"5g",
													),
												},
												Default: stringdefault.StaticString("auto"),
											},
											"usage": schema.StringAttribute{
												Required:            true,
												Description:         "port usage name. \n\nIf EVPN is used, use `evpn_uplink`or `evpn_downlink`",
												MarkdownDescription: "port usage name. \n\nIf EVPN is used, use `evpn_uplink`or `evpn_downlink`",
											},
										},
										CustomType: PortConfigType{
											ObjectType: types.ObjectType{
												AttrTypes: PortConfigValue{}.AttributeTypes(ctx),
											},
										},
									},
									Optional:            true,
									Description:         "Propery key is the interface name or interface range",
									MarkdownDescription: "Propery key is the interface name or interface range",
								},
								"port_mirroring": schema.MapNestedAttribute{
									NestedObject: schema.NestedAttributeObject{
										Attributes: map[string]schema.Attribute{
											"input_networks_ingress": schema.ListAttribute{
												ElementType:         types.StringType,
												Optional:            true,
												Description:         "at least one of the `ingress_port_ids`, `egress_port_ids` or `ingress_networks ` should be specified",
												MarkdownDescription: "at least one of the `ingress_port_ids`, `egress_port_ids` or `ingress_networks ` should be specified",
											},
											"input_port_ids_egress": schema.ListAttribute{
												ElementType:         types.StringType,
												Optional:            true,
												Description:         "at least one of the `ingress_port_ids`, `egress_port_ids` or `ingress_networks ` should be specified",
												MarkdownDescription: "at least one of the `ingress_port_ids`, `egress_port_ids` or `ingress_networks ` should be specified",
											},
											"input_port_ids_ingress": schema.ListAttribute{
												ElementType:         types.StringType,
												Optional:            true,
												Description:         "at least one of the `ingress_port_ids`, `egress_port_ids` or `ingress_networks ` should be specified",
												MarkdownDescription: "at least one of the `ingress_port_ids`, `egress_port_ids` or `ingress_networks ` should be specified",
											},
											"output_network": schema.StringAttribute{
												Optional: true,
											},
											"output_port_id": schema.StringAttribute{
												Optional:            true,
												Description:         "exaclty on of the `output_port_id` or `output_network` should be provided",
												MarkdownDescription: "exaclty on of the `output_port_id` or `output_network` should be provided",
											},
										},
										CustomType: PortMirroringType{
											ObjectType: types.ObjectType{
												AttrTypes: PortMirroringValue{}.AttributeTypes(ctx),
											},
										},
									},
									Optional:            true,
									Description:         "Property key is the port mirroring instance name\nport_mirroring can be added under device/site settings. It takes interface and ports as input for ingress, interface as input for egress and can take interface and port as output.",
									MarkdownDescription: "Property key is the port mirroring instance name\nport_mirroring can be added under device/site settings. It takes interface and ports as input for ingress, interface as input for egress and can take interface and port as output.",
								},
							},
							CustomType: MatchingRulesType{
								ObjectType: types.ObjectType{
									AttrTypes: MatchingRulesValue{}.AttributeTypes(ctx),
								},
							},
						},
						Optional: true,
						Validators: []validator.List{
							listvalidator.UniqueValues(),
						},
					},
				},
				CustomType: SwitchMatchingType{
					ObjectType: types.ObjectType{
						AttrTypes: SwitchMatchingValue{}.AttributeTypes(ctx),
					},
				},
				Optional:            true,
				Description:         "Switch template",
				MarkdownDescription: "Switch template",
			},
			"switch_mgmt": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"config_revert": schema.Int64Attribute{
						Optional: true,
						Computed: true,
						Default:  int64default.StaticInt64(10),
					},
					"protect_re": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"allowed_services": schema.ListAttribute{
								ElementType:         types.StringType,
								Optional:            true,
								Computed:            true,
								Description:         "optionally, services we'll allow",
								MarkdownDescription: "optionally, services we'll allow",
								Default:             listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
							},
							"custom": schema.ListNestedAttribute{
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"port_range": schema.StringAttribute{
											Optional:            true,
											Computed:            true,
											Description:         "matched dst port, \"0\" means any",
											MarkdownDescription: "matched dst port, \"0\" means any",
											Default:             stringdefault.StaticString("0"),
										},
										"protocol": schema.StringAttribute{
											Optional: true,
											Computed: true,
											Validators: []validator.String{
												stringvalidator.OneOf(
													"",
													"tcp",
													"udp",
													"icmp",
													"any",
												),
											},
											Default: stringdefault.StaticString("any"),
										},
										"subnet": schema.ListAttribute{
											ElementType: types.StringType,
											Optional:    true,
										},
									},
									CustomType: CustomType{
										ObjectType: types.ObjectType{
											AttrTypes: CustomValue{}.AttributeTypes(ctx),
										},
									},
								},
								Optional: true,
							},
							"enabled": schema.BoolAttribute{
								Optional:            true,
								Computed:            true,
								Description:         "when enabled, all traffic that is not essential to our operation will be dropped\ne.g. ntp / dns / traffic to mist will be allowed by default\n     if dhcpd is enabled, we'll make sure it works",
								MarkdownDescription: "when enabled, all traffic that is not essential to our operation will be dropped\ne.g. ntp / dns / traffic to mist will be allowed by default\n     if dhcpd is enabled, we'll make sure it works",
								Default:             booldefault.StaticBool(false),
							},
							"trusted_hosts": schema.ListAttribute{
								ElementType:         types.StringType,
								Optional:            true,
								Computed:            true,
								Description:         "host/subnets we'll allow traffic to/from",
								MarkdownDescription: "host/subnets we'll allow traffic to/from",
								Default:             listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
							},
						},
						CustomType: ProtectReType{
							ObjectType: types.ObjectType{
								AttrTypes: ProtectReValue{}.AttributeTypes(ctx),
							},
						},
						Optional:            true,
						Description:         "restrict inbound-traffic to host\nwhen enabled, all traffic that is not essential to our operation will be dropped \ne.g. ntp / dns / traffic to mist will be allowed by default, if dhcpd is enabled, we'll make sure it works",
						MarkdownDescription: "restrict inbound-traffic to host\nwhen enabled, all traffic that is not essential to our operation will be dropped \ne.g. ntp / dns / traffic to mist will be allowed by default, if dhcpd is enabled, we'll make sure it works",
					},
					"root_password": schema.StringAttribute{
						Optional:  true,
						Sensitive: true,
					},
					"tacacs": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"default_role": schema.StringAttribute{
								Optional: true,
								Computed: true,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"",
										"admin",
										"none",
										"read",
										"helpdesk",
									),
								},
								Default: stringdefault.StaticString("none"),
							},
							"enabled": schema.BoolAttribute{
								Optional: true,
							},
							"network": schema.StringAttribute{
								Optional:            true,
								Description:         "which network the TACACS server resides",
								MarkdownDescription: "which network the TACACS server resides",
							},
							"acct_servers": schema.ListNestedAttribute{
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"host": schema.StringAttribute{
											Optional: true,
										},
										"port": schema.StringAttribute{
											Optional: true,
										},
										"secret": schema.StringAttribute{
											Optional:  true,
											Sensitive: true,
										},
										"timeout": schema.Int64Attribute{
											Optional: true,
											Computed: true,
											Default:  int64default.StaticInt64(10),
										},
									},
									CustomType: TacacctServersType{
										ObjectType: types.ObjectType{
											AttrTypes: TacacctServersValue{}.AttributeTypes(ctx),
										},
									},
								},
								Optional: true,
							},
							"tacplus_servers": schema.ListNestedAttribute{
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"host": schema.StringAttribute{
											Optional: true,
										},
										"port": schema.StringAttribute{
											Optional: true,
										},
										"secret": schema.StringAttribute{
											Optional:  true,
											Sensitive: true,
										},
										"timeout": schema.Int64Attribute{
											Optional: true,
											Computed: true,
											Default:  int64default.StaticInt64(10),
										},
									},
									CustomType: TacplusServersType{
										ObjectType: types.ObjectType{
											AttrTypes: TacplusServersValue{}.AttributeTypes(ctx),
										},
									},
								},
								Optional: true,
							},
						},
						CustomType: TacacsType{
							ObjectType: types.ObjectType{
								AttrTypes: TacacsValue{}.AttributeTypes(ctx),
							},
						},
						Optional: true,
					},
				},
				CustomType: SwitchMgmtType{
					ObjectType: types.ObjectType{
						AttrTypes: SwitchMgmtValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
			},
			"vrf_config": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"enabled": schema.BoolAttribute{
						Optional:            true,
						Description:         "whether to enable VRF (when supported on the device)",
						MarkdownDescription: "whether to enable VRF (when supported on the device)",
					},
				},
				CustomType: VrfConfigType{
					ObjectType: types.ObjectType{
						AttrTypes: VrfConfigValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
			},
			"vrf_instances": schema.MapNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"networks": schema.ListAttribute{
							ElementType: types.StringType,
							Optional:    true,
							Validators: []validator.List{
								listvalidator.UniqueValues(),
							},
						},
						"vrf_extra_routes": schema.MapNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"via": schema.StringAttribute{
										Optional:            true,
										Description:         "Next-hop address",
										MarkdownDescription: "Next-hop address",
									},
								},
								CustomType: VrfExtraRoutesType{
									ObjectType: types.ObjectType{
										AttrTypes: VrfExtraRoutesValue{}.AttributeTypes(ctx),
									},
								},
							},
							Optional:            true,
							Description:         "Property key is the destination CIDR (e.g. \"10.0.0.0/8\")",
							MarkdownDescription: "Property key is the destination CIDR (e.g. \"10.0.0.0/8\")",
						},
					},
					CustomType: VrfInstancesType{
						ObjectType: types.ObjectType{
							AttrTypes: VrfInstancesValue{}.AttributeTypes(ctx),
						},
					},
				},
				Optional:            true,
				Description:         "Property key is the network name",
				MarkdownDescription: "Property key is the network name",
			},
			"vs_instance": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"networks": schema.ListAttribute{
						ElementType: types.StringType,
						Optional:    true,
					},
				},
				CustomType: VsInstanceType{
					ObjectType: types.ObjectType{
						AttrTypes: VsInstanceValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
			},
		},
	}
}

type SiteNetworktemplateModel struct {
	AclPolicies          types.List          `tfsdk:"acl_policies"`
	AclTags              types.Map           `tfsdk:"acl_tags"`
	AdditionalConfigCmds types.List          `tfsdk:"additional_config_cmds"`
	DhcpSnooping         DhcpSnoopingValue   `tfsdk:"dhcp_snooping"`
	DnsServers           types.List          `tfsdk:"dns_servers"`
	DnsSuffix            types.List          `tfsdk:"dns_suffix"`
	ExtraRoutes          types.Map           `tfsdk:"extra_routes"`
	ExtraRoutes6         types.Map           `tfsdk:"extra_routes6"`
	MistNac              MistNacValue        `tfsdk:"mist_nac"`
	Networks             types.Map           `tfsdk:"networks"`
	NtpServers           types.List          `tfsdk:"ntp_servers"`
	PortMirroring        types.Map           `tfsdk:"port_mirroring"`
	PortUsages           types.Map           `tfsdk:"port_usages"`
	RadiusConfig         RadiusConfigValue   `tfsdk:"radius_config"`
	RemoteSyslog         RemoteSyslogValue   `tfsdk:"remote_syslog"`
	SiteId               types.String        `tfsdk:"site_id"`
	SnmpConfig           SnmpConfigValue     `tfsdk:"snmp_config"`
	SwitchMatching       SwitchMatchingValue `tfsdk:"switch_matching"`
	SwitchMgmt           SwitchMgmtValue     `tfsdk:"switch_mgmt"`
	VrfConfig            VrfConfigValue      `tfsdk:"vrf_config"`
	VrfInstances         types.Map           `tfsdk:"vrf_instances"`
	VsInstance           VsInstanceValue     `tfsdk:"vs_instance"`
}

var _ basetypes.ObjectTypable = AclPoliciesType{}

type AclPoliciesType struct {
	basetypes.ObjectType
}

func (t AclPoliciesType) Equal(o attr.Type) bool {
	other, ok := o.(AclPoliciesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AclPoliciesType) String() string {
	return "AclPoliciesType"
}

func (t AclPoliciesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	actionsAttribute, ok := attributes["actions"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`actions is missing from object`)

		return nil, diags
	}

	actionsVal, ok := actionsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`actions expected to be basetypes.ListValue, was: %T`, actionsAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	srcTagsAttribute, ok := attributes["src_tags"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`src_tags is missing from object`)

		return nil, diags
	}

	srcTagsVal, ok := srcTagsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`src_tags expected to be basetypes.ListValue, was: %T`, srcTagsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AclPoliciesValue{
		Actions: actionsVal,
		Name:    nameVal,
		SrcTags: srcTagsVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewAclPoliciesValueNull() AclPoliciesValue {
	return AclPoliciesValue{
		state: attr.ValueStateNull,
	}
}

func NewAclPoliciesValueUnknown() AclPoliciesValue {
	return AclPoliciesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewAclPoliciesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AclPoliciesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AclPoliciesValue Attribute Value",
				"While creating a AclPoliciesValue value, a missing attribute value was detected. "+
					"A AclPoliciesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AclPoliciesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AclPoliciesValue Attribute Type",
				"While creating a AclPoliciesValue value, an invalid attribute value was detected. "+
					"A AclPoliciesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AclPoliciesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AclPoliciesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AclPoliciesValue Attribute Value",
				"While creating a AclPoliciesValue value, an extra attribute value was detected. "+
					"A AclPoliciesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AclPoliciesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAclPoliciesValueUnknown(), diags
	}

	actionsAttribute, ok := attributes["actions"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`actions is missing from object`)

		return NewAclPoliciesValueUnknown(), diags
	}

	actionsVal, ok := actionsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`actions expected to be basetypes.ListValue, was: %T`, actionsAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewAclPoliciesValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	srcTagsAttribute, ok := attributes["src_tags"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`src_tags is missing from object`)

		return NewAclPoliciesValueUnknown(), diags
	}

	srcTagsVal, ok := srcTagsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`src_tags expected to be basetypes.ListValue, was: %T`, srcTagsAttribute))
	}

	if diags.HasError() {
		return NewAclPoliciesValueUnknown(), diags
	}

	return AclPoliciesValue{
		Actions: actionsVal,
		Name:    nameVal,
		SrcTags: srcTagsVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewAclPoliciesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AclPoliciesValue {
	object, diags := NewAclPoliciesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAclPoliciesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AclPoliciesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAclPoliciesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAclPoliciesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAclPoliciesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAclPoliciesValueMust(AclPoliciesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t AclPoliciesType) ValueType(ctx context.Context) attr.Value {
	return AclPoliciesValue{}
}

var _ basetypes.ObjectValuable = AclPoliciesValue{}

type AclPoliciesValue struct {
	Actions basetypes.ListValue   `tfsdk:"actions"`
	Name    basetypes.StringValue `tfsdk:"name"`
	SrcTags basetypes.ListValue   `tfsdk:"src_tags"`
	state   attr.ValueState
}

func (v AclPoliciesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["actions"] = basetypes.ListType{
		ElemType: ActionsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["src_tags"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Actions.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["actions"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.SrcTags.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["src_tags"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AclPoliciesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AclPoliciesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AclPoliciesValue) String() string {
	return "AclPoliciesValue"
}

func (v AclPoliciesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	actions := types.ListValueMust(
		ActionsType{
			basetypes.ObjectType{
				AttrTypes: ActionsValue{}.AttributeTypes(ctx),
			},
		},
		v.Actions.Elements(),
	)

	if v.Actions.IsNull() {
		actions = types.ListNull(
			ActionsType{
				basetypes.ObjectType{
					AttrTypes: ActionsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Actions.IsUnknown() {
		actions = types.ListUnknown(
			ActionsType{
				basetypes.ObjectType{
					AttrTypes: ActionsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	srcTagsVal, d := types.ListValue(types.StringType, v.SrcTags.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"actions": basetypes.ListType{
				ElemType: ActionsValue{}.Type(ctx),
			},
			"name": basetypes.StringType{},
			"src_tags": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"actions": basetypes.ListType{
			ElemType: ActionsValue{}.Type(ctx),
		},
		"name": basetypes.StringType{},
		"src_tags": basetypes.ListType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"actions":  actions,
			"name":     v.Name,
			"src_tags": srcTagsVal,
		})

	return objVal, diags
}

func (v AclPoliciesValue) Equal(o attr.Value) bool {
	other, ok := o.(AclPoliciesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Actions.Equal(other.Actions) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.SrcTags.Equal(other.SrcTags) {
		return false
	}

	return true
}

func (v AclPoliciesValue) Type(ctx context.Context) attr.Type {
	return AclPoliciesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AclPoliciesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"actions": basetypes.ListType{
			ElemType: ActionsValue{}.Type(ctx),
		},
		"name": basetypes.StringType{},
		"src_tags": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = ActionsType{}

type ActionsType struct {
	basetypes.ObjectType
}

func (t ActionsType) Equal(o attr.Type) bool {
	other, ok := o.(ActionsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ActionsType) String() string {
	return "ActionsType"
}

func (t ActionsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	actionAttribute, ok := attributes["action"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`action is missing from object`)

		return nil, diags
	}

	actionVal, ok := actionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`action expected to be basetypes.StringValue, was: %T`, actionAttribute))
	}

	dstTagAttribute, ok := attributes["dst_tag"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dst_tag is missing from object`)

		return nil, diags
	}

	dstTagVal, ok := dstTagAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dst_tag expected to be basetypes.StringValue, was: %T`, dstTagAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ActionsValue{
		Action: actionVal,
		DstTag: dstTagVal,
		state:  attr.ValueStateKnown,
	}, diags
}

func NewActionsValueNull() ActionsValue {
	return ActionsValue{
		state: attr.ValueStateNull,
	}
}

func NewActionsValueUnknown() ActionsValue {
	return ActionsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewActionsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ActionsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ActionsValue Attribute Value",
				"While creating a ActionsValue value, a missing attribute value was detected. "+
					"A ActionsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ActionsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ActionsValue Attribute Type",
				"While creating a ActionsValue value, an invalid attribute value was detected. "+
					"A ActionsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ActionsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ActionsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ActionsValue Attribute Value",
				"While creating a ActionsValue value, an extra attribute value was detected. "+
					"A ActionsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ActionsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewActionsValueUnknown(), diags
	}

	actionAttribute, ok := attributes["action"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`action is missing from object`)

		return NewActionsValueUnknown(), diags
	}

	actionVal, ok := actionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`action expected to be basetypes.StringValue, was: %T`, actionAttribute))
	}

	dstTagAttribute, ok := attributes["dst_tag"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dst_tag is missing from object`)

		return NewActionsValueUnknown(), diags
	}

	dstTagVal, ok := dstTagAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dst_tag expected to be basetypes.StringValue, was: %T`, dstTagAttribute))
	}

	if diags.HasError() {
		return NewActionsValueUnknown(), diags
	}

	return ActionsValue{
		Action: actionVal,
		DstTag: dstTagVal,
		state:  attr.ValueStateKnown,
	}, diags
}

func NewActionsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ActionsValue {
	object, diags := NewActionsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewActionsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ActionsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewActionsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewActionsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewActionsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewActionsValueMust(ActionsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ActionsType) ValueType(ctx context.Context) attr.Value {
	return ActionsValue{}
}

var _ basetypes.ObjectValuable = ActionsValue{}

type ActionsValue struct {
	Action basetypes.StringValue `tfsdk:"action"`
	DstTag basetypes.StringValue `tfsdk:"dst_tag"`
	state  attr.ValueState
}

func (v ActionsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["action"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["dst_tag"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Action.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["action"] = val

		val, err = v.DstTag.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dst_tag"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ActionsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ActionsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ActionsValue) String() string {
	return "ActionsValue"
}

func (v ActionsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"action":  basetypes.StringType{},
		"dst_tag": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"action":  v.Action,
			"dst_tag": v.DstTag,
		})

	return objVal, diags
}

func (v ActionsValue) Equal(o attr.Value) bool {
	other, ok := o.(ActionsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Action.Equal(other.Action) {
		return false
	}

	if !v.DstTag.Equal(other.DstTag) {
		return false
	}

	return true
}

func (v ActionsValue) Type(ctx context.Context) attr.Type {
	return ActionsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ActionsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"action":  basetypes.StringType{},
		"dst_tag": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = AclTagsType{}

type AclTagsType struct {
	basetypes.ObjectType
}

func (t AclTagsType) Equal(o attr.Type) bool {
	other, ok := o.(AclTagsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AclTagsType) String() string {
	return "AclTagsType"
}

func (t AclTagsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	gbpTagAttribute, ok := attributes["gbp_tag"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gbp_tag is missing from object`)

		return nil, diags
	}

	gbpTagVal, ok := gbpTagAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gbp_tag expected to be basetypes.Int64Value, was: %T`, gbpTagAttribute))
	}

	macsAttribute, ok := attributes["macs"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`macs is missing from object`)

		return nil, diags
	}

	macsVal, ok := macsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`macs expected to be basetypes.ListValue, was: %T`, macsAttribute))
	}

	networkAttribute, ok := attributes["network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`network is missing from object`)

		return nil, diags
	}

	networkVal, ok := networkAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`network expected to be basetypes.StringValue, was: %T`, networkAttribute))
	}

	radiusGroupAttribute, ok := attributes["radius_group"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`radius_group is missing from object`)

		return nil, diags
	}

	radiusGroupVal, ok := radiusGroupAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`radius_group expected to be basetypes.StringValue, was: %T`, radiusGroupAttribute))
	}

	specsAttribute, ok := attributes["specs"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`specs is missing from object`)

		return nil, diags
	}

	specsVal, ok := specsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`specs expected to be basetypes.ListValue, was: %T`, specsAttribute))
	}

	subnetsAttribute, ok := attributes["subnets"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnets is missing from object`)

		return nil, diags
	}

	subnetsVal, ok := subnetsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnets expected to be basetypes.ListValue, was: %T`, subnetsAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AclTagsValue{
		GbpTag:      gbpTagVal,
		Macs:        macsVal,
		Network:     networkVal,
		RadiusGroup: radiusGroupVal,
		Specs:       specsVal,
		Subnets:     subnetsVal,
		AclTagsType: typeVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewAclTagsValueNull() AclTagsValue {
	return AclTagsValue{
		state: attr.ValueStateNull,
	}
}

func NewAclTagsValueUnknown() AclTagsValue {
	return AclTagsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewAclTagsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AclTagsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AclTagsValue Attribute Value",
				"While creating a AclTagsValue value, a missing attribute value was detected. "+
					"A AclTagsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AclTagsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AclTagsValue Attribute Type",
				"While creating a AclTagsValue value, an invalid attribute value was detected. "+
					"A AclTagsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AclTagsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AclTagsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AclTagsValue Attribute Value",
				"While creating a AclTagsValue value, an extra attribute value was detected. "+
					"A AclTagsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AclTagsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAclTagsValueUnknown(), diags
	}

	gbpTagAttribute, ok := attributes["gbp_tag"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gbp_tag is missing from object`)

		return NewAclTagsValueUnknown(), diags
	}

	gbpTagVal, ok := gbpTagAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gbp_tag expected to be basetypes.Int64Value, was: %T`, gbpTagAttribute))
	}

	macsAttribute, ok := attributes["macs"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`macs is missing from object`)

		return NewAclTagsValueUnknown(), diags
	}

	macsVal, ok := macsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`macs expected to be basetypes.ListValue, was: %T`, macsAttribute))
	}

	networkAttribute, ok := attributes["network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`network is missing from object`)

		return NewAclTagsValueUnknown(), diags
	}

	networkVal, ok := networkAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`network expected to be basetypes.StringValue, was: %T`, networkAttribute))
	}

	radiusGroupAttribute, ok := attributes["radius_group"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`radius_group is missing from object`)

		return NewAclTagsValueUnknown(), diags
	}

	radiusGroupVal, ok := radiusGroupAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`radius_group expected to be basetypes.StringValue, was: %T`, radiusGroupAttribute))
	}

	specsAttribute, ok := attributes["specs"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`specs is missing from object`)

		return NewAclTagsValueUnknown(), diags
	}

	specsVal, ok := specsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`specs expected to be basetypes.ListValue, was: %T`, specsAttribute))
	}

	subnetsAttribute, ok := attributes["subnets"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnets is missing from object`)

		return NewAclTagsValueUnknown(), diags
	}

	subnetsVal, ok := subnetsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnets expected to be basetypes.ListValue, was: %T`, subnetsAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewAclTagsValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return NewAclTagsValueUnknown(), diags
	}

	return AclTagsValue{
		GbpTag:      gbpTagVal,
		Macs:        macsVal,
		Network:     networkVal,
		RadiusGroup: radiusGroupVal,
		Specs:       specsVal,
		Subnets:     subnetsVal,
		AclTagsType: typeVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewAclTagsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AclTagsValue {
	object, diags := NewAclTagsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAclTagsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AclTagsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAclTagsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAclTagsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAclTagsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAclTagsValueMust(AclTagsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t AclTagsType) ValueType(ctx context.Context) attr.Value {
	return AclTagsValue{}
}

var _ basetypes.ObjectValuable = AclTagsValue{}

type AclTagsValue struct {
	GbpTag      basetypes.Int64Value  `tfsdk:"gbp_tag"`
	Macs        basetypes.ListValue   `tfsdk:"macs"`
	Network     basetypes.StringValue `tfsdk:"network"`
	RadiusGroup basetypes.StringValue `tfsdk:"radius_group"`
	Specs       basetypes.ListValue   `tfsdk:"specs"`
	Subnets     basetypes.ListValue   `tfsdk:"subnets"`
	AclTagsType basetypes.StringValue `tfsdk:"type"`
	state       attr.ValueState
}

func (v AclTagsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 7)

	var val tftypes.Value
	var err error

	attrTypes["gbp_tag"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["macs"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["network"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["radius_group"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["specs"] = basetypes.ListType{
		ElemType: SpecsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["subnets"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 7)

		val, err = v.GbpTag.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["gbp_tag"] = val

		val, err = v.Macs.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["macs"] = val

		val, err = v.Network.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["network"] = val

		val, err = v.RadiusGroup.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["radius_group"] = val

		val, err = v.Specs.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["specs"] = val

		val, err = v.Subnets.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["subnets"] = val

		val, err = v.AclTagsType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AclTagsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AclTagsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AclTagsValue) String() string {
	return "AclTagsValue"
}

func (v AclTagsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	specs := types.ListValueMust(
		SpecsType{
			basetypes.ObjectType{
				AttrTypes: SpecsValue{}.AttributeTypes(ctx),
			},
		},
		v.Specs.Elements(),
	)

	if v.Specs.IsNull() {
		specs = types.ListNull(
			SpecsType{
				basetypes.ObjectType{
					AttrTypes: SpecsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Specs.IsUnknown() {
		specs = types.ListUnknown(
			SpecsType{
				basetypes.ObjectType{
					AttrTypes: SpecsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	macsVal, d := types.ListValue(types.StringType, v.Macs.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"gbp_tag": basetypes.Int64Type{},
			"macs": basetypes.ListType{
				ElemType: types.StringType,
			},
			"network":      basetypes.StringType{},
			"radius_group": basetypes.StringType{},
			"specs": basetypes.ListType{
				ElemType: SpecsValue{}.Type(ctx),
			},
			"subnets": basetypes.ListType{
				ElemType: types.StringType,
			},
			"type": basetypes.StringType{},
		}), diags
	}

	subnetsVal, d := types.ListValue(types.StringType, v.Subnets.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"gbp_tag": basetypes.Int64Type{},
			"macs": basetypes.ListType{
				ElemType: types.StringType,
			},
			"network":      basetypes.StringType{},
			"radius_group": basetypes.StringType{},
			"specs": basetypes.ListType{
				ElemType: SpecsValue{}.Type(ctx),
			},
			"subnets": basetypes.ListType{
				ElemType: types.StringType,
			},
			"type": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"gbp_tag": basetypes.Int64Type{},
		"macs": basetypes.ListType{
			ElemType: types.StringType,
		},
		"network":      basetypes.StringType{},
		"radius_group": basetypes.StringType{},
		"specs": basetypes.ListType{
			ElemType: SpecsValue{}.Type(ctx),
		},
		"subnets": basetypes.ListType{
			ElemType: types.StringType,
		},
		"type": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"gbp_tag":      v.GbpTag,
			"macs":         macsVal,
			"network":      v.Network,
			"radius_group": v.RadiusGroup,
			"specs":        specs,
			"subnets":      subnetsVal,
			"type":         v.AclTagsType,
		})

	return objVal, diags
}

func (v AclTagsValue) Equal(o attr.Value) bool {
	other, ok := o.(AclTagsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.GbpTag.Equal(other.GbpTag) {
		return false
	}

	if !v.Macs.Equal(other.Macs) {
		return false
	}

	if !v.Network.Equal(other.Network) {
		return false
	}

	if !v.RadiusGroup.Equal(other.RadiusGroup) {
		return false
	}

	if !v.Specs.Equal(other.Specs) {
		return false
	}

	if !v.Subnets.Equal(other.Subnets) {
		return false
	}

	if !v.AclTagsType.Equal(other.AclTagsType) {
		return false
	}

	return true
}

func (v AclTagsValue) Type(ctx context.Context) attr.Type {
	return AclTagsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AclTagsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"gbp_tag": basetypes.Int64Type{},
		"macs": basetypes.ListType{
			ElemType: types.StringType,
		},
		"network":      basetypes.StringType{},
		"radius_group": basetypes.StringType{},
		"specs": basetypes.ListType{
			ElemType: SpecsValue{}.Type(ctx),
		},
		"subnets": basetypes.ListType{
			ElemType: types.StringType,
		},
		"type": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = SpecsType{}

type SpecsType struct {
	basetypes.ObjectType
}

func (t SpecsType) Equal(o attr.Type) bool {
	other, ok := o.(SpecsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SpecsType) String() string {
	return "SpecsType"
}

func (t SpecsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	portRangeAttribute, ok := attributes["port_range"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_range is missing from object`)

		return nil, diags
	}

	portRangeVal, ok := portRangeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_range expected to be basetypes.StringValue, was: %T`, portRangeAttribute))
	}

	protocolAttribute, ok := attributes["protocol"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`protocol is missing from object`)

		return nil, diags
	}

	protocolVal, ok := protocolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`protocol expected to be basetypes.StringValue, was: %T`, protocolAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SpecsValue{
		PortRange: portRangeVal,
		Protocol:  protocolVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewSpecsValueNull() SpecsValue {
	return SpecsValue{
		state: attr.ValueStateNull,
	}
}

func NewSpecsValueUnknown() SpecsValue {
	return SpecsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSpecsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SpecsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SpecsValue Attribute Value",
				"While creating a SpecsValue value, a missing attribute value was detected. "+
					"A SpecsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpecsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SpecsValue Attribute Type",
				"While creating a SpecsValue value, an invalid attribute value was detected. "+
					"A SpecsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpecsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SpecsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SpecsValue Attribute Value",
				"While creating a SpecsValue value, an extra attribute value was detected. "+
					"A SpecsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SpecsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSpecsValueUnknown(), diags
	}

	portRangeAttribute, ok := attributes["port_range"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_range is missing from object`)

		return NewSpecsValueUnknown(), diags
	}

	portRangeVal, ok := portRangeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_range expected to be basetypes.StringValue, was: %T`, portRangeAttribute))
	}

	protocolAttribute, ok := attributes["protocol"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`protocol is missing from object`)

		return NewSpecsValueUnknown(), diags
	}

	protocolVal, ok := protocolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`protocol expected to be basetypes.StringValue, was: %T`, protocolAttribute))
	}

	if diags.HasError() {
		return NewSpecsValueUnknown(), diags
	}

	return SpecsValue{
		PortRange: portRangeVal,
		Protocol:  protocolVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewSpecsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SpecsValue {
	object, diags := NewSpecsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSpecsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SpecsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSpecsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSpecsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSpecsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSpecsValueMust(SpecsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SpecsType) ValueType(ctx context.Context) attr.Value {
	return SpecsValue{}
}

var _ basetypes.ObjectValuable = SpecsValue{}

type SpecsValue struct {
	PortRange basetypes.StringValue `tfsdk:"port_range"`
	Protocol  basetypes.StringValue `tfsdk:"protocol"`
	state     attr.ValueState
}

func (v SpecsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["port_range"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["protocol"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.PortRange.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port_range"] = val

		val, err = v.Protocol.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["protocol"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SpecsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SpecsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SpecsValue) String() string {
	return "SpecsValue"
}

func (v SpecsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"port_range": basetypes.StringType{},
		"protocol":   basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"port_range": v.PortRange,
			"protocol":   v.Protocol,
		})

	return objVal, diags
}

func (v SpecsValue) Equal(o attr.Value) bool {
	other, ok := o.(SpecsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.PortRange.Equal(other.PortRange) {
		return false
	}

	if !v.Protocol.Equal(other.Protocol) {
		return false
	}

	return true
}

func (v SpecsValue) Type(ctx context.Context) attr.Type {
	return SpecsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SpecsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"port_range": basetypes.StringType{},
		"protocol":   basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = DhcpSnoopingType{}

type DhcpSnoopingType struct {
	basetypes.ObjectType
}

func (t DhcpSnoopingType) Equal(o attr.Type) bool {
	other, ok := o.(DhcpSnoopingType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t DhcpSnoopingType) String() string {
	return "DhcpSnoopingType"
}

func (t DhcpSnoopingType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	allNetworksAttribute, ok := attributes["all_networks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`all_networks is missing from object`)

		return nil, diags
	}

	allNetworksVal, ok := allNetworksAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`all_networks expected to be basetypes.BoolValue, was: %T`, allNetworksAttribute))
	}

	enableArpSpoofCheckAttribute, ok := attributes["enable_arp_spoof_check"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable_arp_spoof_check is missing from object`)

		return nil, diags
	}

	enableArpSpoofCheckVal, ok := enableArpSpoofCheckAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable_arp_spoof_check expected to be basetypes.BoolValue, was: %T`, enableArpSpoofCheckAttribute))
	}

	enableIpSourceGuardAttribute, ok := attributes["enable_ip_source_guard"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable_ip_source_guard is missing from object`)

		return nil, diags
	}

	enableIpSourceGuardVal, ok := enableIpSourceGuardAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable_ip_source_guard expected to be basetypes.BoolValue, was: %T`, enableIpSourceGuardAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	networksAttribute, ok := attributes["networks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`networks is missing from object`)

		return nil, diags
	}

	networksVal, ok := networksAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`networks expected to be basetypes.ListValue, was: %T`, networksAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return DhcpSnoopingValue{
		AllNetworks:         allNetworksVal,
		EnableArpSpoofCheck: enableArpSpoofCheckVal,
		EnableIpSourceGuard: enableIpSourceGuardVal,
		Enabled:             enabledVal,
		Networks:            networksVal,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewDhcpSnoopingValueNull() DhcpSnoopingValue {
	return DhcpSnoopingValue{
		state: attr.ValueStateNull,
	}
}

func NewDhcpSnoopingValueUnknown() DhcpSnoopingValue {
	return DhcpSnoopingValue{
		state: attr.ValueStateUnknown,
	}
}

func NewDhcpSnoopingValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (DhcpSnoopingValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing DhcpSnoopingValue Attribute Value",
				"While creating a DhcpSnoopingValue value, a missing attribute value was detected. "+
					"A DhcpSnoopingValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DhcpSnoopingValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid DhcpSnoopingValue Attribute Type",
				"While creating a DhcpSnoopingValue value, an invalid attribute value was detected. "+
					"A DhcpSnoopingValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DhcpSnoopingValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("DhcpSnoopingValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra DhcpSnoopingValue Attribute Value",
				"While creating a DhcpSnoopingValue value, an extra attribute value was detected. "+
					"A DhcpSnoopingValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra DhcpSnoopingValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewDhcpSnoopingValueUnknown(), diags
	}

	allNetworksAttribute, ok := attributes["all_networks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`all_networks is missing from object`)

		return NewDhcpSnoopingValueUnknown(), diags
	}

	allNetworksVal, ok := allNetworksAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`all_networks expected to be basetypes.BoolValue, was: %T`, allNetworksAttribute))
	}

	enableArpSpoofCheckAttribute, ok := attributes["enable_arp_spoof_check"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable_arp_spoof_check is missing from object`)

		return NewDhcpSnoopingValueUnknown(), diags
	}

	enableArpSpoofCheckVal, ok := enableArpSpoofCheckAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable_arp_spoof_check expected to be basetypes.BoolValue, was: %T`, enableArpSpoofCheckAttribute))
	}

	enableIpSourceGuardAttribute, ok := attributes["enable_ip_source_guard"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable_ip_source_guard is missing from object`)

		return NewDhcpSnoopingValueUnknown(), diags
	}

	enableIpSourceGuardVal, ok := enableIpSourceGuardAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable_ip_source_guard expected to be basetypes.BoolValue, was: %T`, enableIpSourceGuardAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewDhcpSnoopingValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	networksAttribute, ok := attributes["networks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`networks is missing from object`)

		return NewDhcpSnoopingValueUnknown(), diags
	}

	networksVal, ok := networksAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`networks expected to be basetypes.ListValue, was: %T`, networksAttribute))
	}

	if diags.HasError() {
		return NewDhcpSnoopingValueUnknown(), diags
	}

	return DhcpSnoopingValue{
		AllNetworks:         allNetworksVal,
		EnableArpSpoofCheck: enableArpSpoofCheckVal,
		EnableIpSourceGuard: enableIpSourceGuardVal,
		Enabled:             enabledVal,
		Networks:            networksVal,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewDhcpSnoopingValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) DhcpSnoopingValue {
	object, diags := NewDhcpSnoopingValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewDhcpSnoopingValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t DhcpSnoopingType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewDhcpSnoopingValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewDhcpSnoopingValueUnknown(), nil
	}

	if in.IsNull() {
		return NewDhcpSnoopingValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewDhcpSnoopingValueMust(DhcpSnoopingValue{}.AttributeTypes(ctx), attributes), nil
}

func (t DhcpSnoopingType) ValueType(ctx context.Context) attr.Value {
	return DhcpSnoopingValue{}
}

var _ basetypes.ObjectValuable = DhcpSnoopingValue{}

type DhcpSnoopingValue struct {
	AllNetworks         basetypes.BoolValue `tfsdk:"all_networks"`
	EnableArpSpoofCheck basetypes.BoolValue `tfsdk:"enable_arp_spoof_check"`
	EnableIpSourceGuard basetypes.BoolValue `tfsdk:"enable_ip_source_guard"`
	Enabled             basetypes.BoolValue `tfsdk:"enabled"`
	Networks            basetypes.ListValue `tfsdk:"networks"`
	state               attr.ValueState
}

func (v DhcpSnoopingValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["all_networks"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["enable_arp_spoof_check"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["enable_ip_source_guard"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["networks"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.AllNetworks.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["all_networks"] = val

		val, err = v.EnableArpSpoofCheck.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enable_arp_spoof_check"] = val

		val, err = v.EnableIpSourceGuard.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enable_ip_source_guard"] = val

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.Networks.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["networks"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v DhcpSnoopingValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v DhcpSnoopingValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v DhcpSnoopingValue) String() string {
	return "DhcpSnoopingValue"
}

func (v DhcpSnoopingValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	networksVal, d := types.ListValue(types.StringType, v.Networks.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"all_networks":           basetypes.BoolType{},
			"enable_arp_spoof_check": basetypes.BoolType{},
			"enable_ip_source_guard": basetypes.BoolType{},
			"enabled":                basetypes.BoolType{},
			"networks": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"all_networks":           basetypes.BoolType{},
		"enable_arp_spoof_check": basetypes.BoolType{},
		"enable_ip_source_guard": basetypes.BoolType{},
		"enabled":                basetypes.BoolType{},
		"networks": basetypes.ListType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"all_networks":           v.AllNetworks,
			"enable_arp_spoof_check": v.EnableArpSpoofCheck,
			"enable_ip_source_guard": v.EnableIpSourceGuard,
			"enabled":                v.Enabled,
			"networks":               networksVal,
		})

	return objVal, diags
}

func (v DhcpSnoopingValue) Equal(o attr.Value) bool {
	other, ok := o.(DhcpSnoopingValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AllNetworks.Equal(other.AllNetworks) {
		return false
	}

	if !v.EnableArpSpoofCheck.Equal(other.EnableArpSpoofCheck) {
		return false
	}

	if !v.EnableIpSourceGuard.Equal(other.EnableIpSourceGuard) {
		return false
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.Networks.Equal(other.Networks) {
		return false
	}

	return true
}

func (v DhcpSnoopingValue) Type(ctx context.Context) attr.Type {
	return DhcpSnoopingType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v DhcpSnoopingValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"all_networks":           basetypes.BoolType{},
		"enable_arp_spoof_check": basetypes.BoolType{},
		"enable_ip_source_guard": basetypes.BoolType{},
		"enabled":                basetypes.BoolType{},
		"networks": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = ExtraRoutesType{}

type ExtraRoutesType struct {
	basetypes.ObjectType
}

func (t ExtraRoutesType) Equal(o attr.Type) bool {
	other, ok := o.(ExtraRoutesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ExtraRoutesType) String() string {
	return "ExtraRoutesType"
}

func (t ExtraRoutesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	discardAttribute, ok := attributes["discard"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`discard is missing from object`)

		return nil, diags
	}

	discardVal, ok := discardAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`discard expected to be basetypes.BoolValue, was: %T`, discardAttribute))
	}

	metricAttribute, ok := attributes["metric"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`metric is missing from object`)

		return nil, diags
	}

	metricVal, ok := metricAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`metric expected to be basetypes.Int64Value, was: %T`, metricAttribute))
	}

	nextQualifiedAttribute, ok := attributes["next_qualified"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`next_qualified is missing from object`)

		return nil, diags
	}

	nextQualifiedVal, ok := nextQualifiedAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`next_qualified expected to be basetypes.MapValue, was: %T`, nextQualifiedAttribute))
	}

	noResolveAttribute, ok := attributes["no_resolve"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`no_resolve is missing from object`)

		return nil, diags
	}

	noResolveVal, ok := noResolveAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`no_resolve expected to be basetypes.BoolValue, was: %T`, noResolveAttribute))
	}

	preferenceAttribute, ok := attributes["preference"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`preference is missing from object`)

		return nil, diags
	}

	preferenceVal, ok := preferenceAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`preference expected to be basetypes.Int64Value, was: %T`, preferenceAttribute))
	}

	viaAttribute, ok := attributes["via"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`via is missing from object`)

		return nil, diags
	}

	viaVal, ok := viaAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`via expected to be basetypes.StringValue, was: %T`, viaAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ExtraRoutesValue{
		Discard:       discardVal,
		Metric:        metricVal,
		NextQualified: nextQualifiedVal,
		NoResolve:     noResolveVal,
		Preference:    preferenceVal,
		Via:           viaVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewExtraRoutesValueNull() ExtraRoutesValue {
	return ExtraRoutesValue{
		state: attr.ValueStateNull,
	}
}

func NewExtraRoutesValueUnknown() ExtraRoutesValue {
	return ExtraRoutesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewExtraRoutesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ExtraRoutesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ExtraRoutesValue Attribute Value",
				"While creating a ExtraRoutesValue value, a missing attribute value was detected. "+
					"A ExtraRoutesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ExtraRoutesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ExtraRoutesValue Attribute Type",
				"While creating a ExtraRoutesValue value, an invalid attribute value was detected. "+
					"A ExtraRoutesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ExtraRoutesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ExtraRoutesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ExtraRoutesValue Attribute Value",
				"While creating a ExtraRoutesValue value, an extra attribute value was detected. "+
					"A ExtraRoutesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ExtraRoutesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewExtraRoutesValueUnknown(), diags
	}

	discardAttribute, ok := attributes["discard"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`discard is missing from object`)

		return NewExtraRoutesValueUnknown(), diags
	}

	discardVal, ok := discardAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`discard expected to be basetypes.BoolValue, was: %T`, discardAttribute))
	}

	metricAttribute, ok := attributes["metric"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`metric is missing from object`)

		return NewExtraRoutesValueUnknown(), diags
	}

	metricVal, ok := metricAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`metric expected to be basetypes.Int64Value, was: %T`, metricAttribute))
	}

	nextQualifiedAttribute, ok := attributes["next_qualified"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`next_qualified is missing from object`)

		return NewExtraRoutesValueUnknown(), diags
	}

	nextQualifiedVal, ok := nextQualifiedAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`next_qualified expected to be basetypes.MapValue, was: %T`, nextQualifiedAttribute))
	}

	noResolveAttribute, ok := attributes["no_resolve"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`no_resolve is missing from object`)

		return NewExtraRoutesValueUnknown(), diags
	}

	noResolveVal, ok := noResolveAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`no_resolve expected to be basetypes.BoolValue, was: %T`, noResolveAttribute))
	}

	preferenceAttribute, ok := attributes["preference"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`preference is missing from object`)

		return NewExtraRoutesValueUnknown(), diags
	}

	preferenceVal, ok := preferenceAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`preference expected to be basetypes.Int64Value, was: %T`, preferenceAttribute))
	}

	viaAttribute, ok := attributes["via"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`via is missing from object`)

		return NewExtraRoutesValueUnknown(), diags
	}

	viaVal, ok := viaAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`via expected to be basetypes.StringValue, was: %T`, viaAttribute))
	}

	if diags.HasError() {
		return NewExtraRoutesValueUnknown(), diags
	}

	return ExtraRoutesValue{
		Discard:       discardVal,
		Metric:        metricVal,
		NextQualified: nextQualifiedVal,
		NoResolve:     noResolveVal,
		Preference:    preferenceVal,
		Via:           viaVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewExtraRoutesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ExtraRoutesValue {
	object, diags := NewExtraRoutesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewExtraRoutesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ExtraRoutesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewExtraRoutesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewExtraRoutesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewExtraRoutesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewExtraRoutesValueMust(ExtraRoutesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ExtraRoutesType) ValueType(ctx context.Context) attr.Value {
	return ExtraRoutesValue{}
}

var _ basetypes.ObjectValuable = ExtraRoutesValue{}

type ExtraRoutesValue struct {
	Discard       basetypes.BoolValue   `tfsdk:"discard"`
	Metric        basetypes.Int64Value  `tfsdk:"metric"`
	NextQualified basetypes.MapValue    `tfsdk:"next_qualified"`
	NoResolve     basetypes.BoolValue   `tfsdk:"no_resolve"`
	Preference    basetypes.Int64Value  `tfsdk:"preference"`
	Via           basetypes.StringValue `tfsdk:"via"`
	state         attr.ValueState
}

func (v ExtraRoutesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 6)

	var val tftypes.Value
	var err error

	attrTypes["discard"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["metric"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["next_qualified"] = basetypes.MapType{
		ElemType: NextQualifiedValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["no_resolve"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["preference"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["via"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 6)

		val, err = v.Discard.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["discard"] = val

		val, err = v.Metric.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["metric"] = val

		val, err = v.NextQualified.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["next_qualified"] = val

		val, err = v.NoResolve.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["no_resolve"] = val

		val, err = v.Preference.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["preference"] = val

		val, err = v.Via.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["via"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ExtraRoutesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ExtraRoutesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ExtraRoutesValue) String() string {
	return "ExtraRoutesValue"
}

func (v ExtraRoutesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	nextQualified := types.MapValueMust(
		NextQualifiedType{
			basetypes.ObjectType{
				AttrTypes: NextQualifiedValue{}.AttributeTypes(ctx),
			},
		},
		v.NextQualified.Elements(),
	)

	if v.NextQualified.IsNull() {
		nextQualified = types.MapNull(
			NextQualifiedType{
				basetypes.ObjectType{
					AttrTypes: NextQualifiedValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.NextQualified.IsUnknown() {
		nextQualified = types.MapUnknown(
			NextQualifiedType{
				basetypes.ObjectType{
					AttrTypes: NextQualifiedValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"discard": basetypes.BoolType{},
		"metric":  basetypes.Int64Type{},
		"next_qualified": basetypes.MapType{
			ElemType: NextQualifiedValue{}.Type(ctx),
		},
		"no_resolve": basetypes.BoolType{},
		"preference": basetypes.Int64Type{},
		"via":        basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"discard":        v.Discard,
			"metric":         v.Metric,
			"next_qualified": nextQualified,
			"no_resolve":     v.NoResolve,
			"preference":     v.Preference,
			"via":            v.Via,
		})

	return objVal, diags
}

func (v ExtraRoutesValue) Equal(o attr.Value) bool {
	other, ok := o.(ExtraRoutesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Discard.Equal(other.Discard) {
		return false
	}

	if !v.Metric.Equal(other.Metric) {
		return false
	}

	if !v.NextQualified.Equal(other.NextQualified) {
		return false
	}

	if !v.NoResolve.Equal(other.NoResolve) {
		return false
	}

	if !v.Preference.Equal(other.Preference) {
		return false
	}

	if !v.Via.Equal(other.Via) {
		return false
	}

	return true
}

func (v ExtraRoutesValue) Type(ctx context.Context) attr.Type {
	return ExtraRoutesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ExtraRoutesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"discard": basetypes.BoolType{},
		"metric":  basetypes.Int64Type{},
		"next_qualified": basetypes.MapType{
			ElemType: NextQualifiedValue{}.Type(ctx),
		},
		"no_resolve": basetypes.BoolType{},
		"preference": basetypes.Int64Type{},
		"via":        basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = NextQualifiedType{}

type NextQualifiedType struct {
	basetypes.ObjectType
}

func (t NextQualifiedType) Equal(o attr.Type) bool {
	other, ok := o.(NextQualifiedType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t NextQualifiedType) String() string {
	return "NextQualifiedType"
}

func (t NextQualifiedType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	metricAttribute, ok := attributes["metric"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`metric is missing from object`)

		return nil, diags
	}

	metricVal, ok := metricAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`metric expected to be basetypes.Int64Value, was: %T`, metricAttribute))
	}

	preferenceAttribute, ok := attributes["preference"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`preference is missing from object`)

		return nil, diags
	}

	preferenceVal, ok := preferenceAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`preference expected to be basetypes.Int64Value, was: %T`, preferenceAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return NextQualifiedValue{
		Metric:     metricVal,
		Preference: preferenceVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewNextQualifiedValueNull() NextQualifiedValue {
	return NextQualifiedValue{
		state: attr.ValueStateNull,
	}
}

func NewNextQualifiedValueUnknown() NextQualifiedValue {
	return NextQualifiedValue{
		state: attr.ValueStateUnknown,
	}
}

func NewNextQualifiedValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (NextQualifiedValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing NextQualifiedValue Attribute Value",
				"While creating a NextQualifiedValue value, a missing attribute value was detected. "+
					"A NextQualifiedValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NextQualifiedValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid NextQualifiedValue Attribute Type",
				"While creating a NextQualifiedValue value, an invalid attribute value was detected. "+
					"A NextQualifiedValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NextQualifiedValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("NextQualifiedValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra NextQualifiedValue Attribute Value",
				"While creating a NextQualifiedValue value, an extra attribute value was detected. "+
					"A NextQualifiedValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra NextQualifiedValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewNextQualifiedValueUnknown(), diags
	}

	metricAttribute, ok := attributes["metric"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`metric is missing from object`)

		return NewNextQualifiedValueUnknown(), diags
	}

	metricVal, ok := metricAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`metric expected to be basetypes.Int64Value, was: %T`, metricAttribute))
	}

	preferenceAttribute, ok := attributes["preference"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`preference is missing from object`)

		return NewNextQualifiedValueUnknown(), diags
	}

	preferenceVal, ok := preferenceAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`preference expected to be basetypes.Int64Value, was: %T`, preferenceAttribute))
	}

	if diags.HasError() {
		return NewNextQualifiedValueUnknown(), diags
	}

	return NextQualifiedValue{
		Metric:     metricVal,
		Preference: preferenceVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewNextQualifiedValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) NextQualifiedValue {
	object, diags := NewNextQualifiedValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewNextQualifiedValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t NextQualifiedType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewNextQualifiedValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewNextQualifiedValueUnknown(), nil
	}

	if in.IsNull() {
		return NewNextQualifiedValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewNextQualifiedValueMust(NextQualifiedValue{}.AttributeTypes(ctx), attributes), nil
}

func (t NextQualifiedType) ValueType(ctx context.Context) attr.Value {
	return NextQualifiedValue{}
}

var _ basetypes.ObjectValuable = NextQualifiedValue{}

type NextQualifiedValue struct {
	Metric     basetypes.Int64Value `tfsdk:"metric"`
	Preference basetypes.Int64Value `tfsdk:"preference"`
	state      attr.ValueState
}

func (v NextQualifiedValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["metric"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["preference"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Metric.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["metric"] = val

		val, err = v.Preference.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["preference"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v NextQualifiedValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v NextQualifiedValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v NextQualifiedValue) String() string {
	return "NextQualifiedValue"
}

func (v NextQualifiedValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"metric":     basetypes.Int64Type{},
		"preference": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"metric":     v.Metric,
			"preference": v.Preference,
		})

	return objVal, diags
}

func (v NextQualifiedValue) Equal(o attr.Value) bool {
	other, ok := o.(NextQualifiedValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Metric.Equal(other.Metric) {
		return false
	}

	if !v.Preference.Equal(other.Preference) {
		return false
	}

	return true
}

func (v NextQualifiedValue) Type(ctx context.Context) attr.Type {
	return NextQualifiedType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v NextQualifiedValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"metric":     basetypes.Int64Type{},
		"preference": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = ExtraRoutes6Type{}

type ExtraRoutes6Type struct {
	basetypes.ObjectType
}

func (t ExtraRoutes6Type) Equal(o attr.Type) bool {
	other, ok := o.(ExtraRoutes6Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ExtraRoutes6Type) String() string {
	return "ExtraRoutes6Type"
}

func (t ExtraRoutes6Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	discardAttribute, ok := attributes["discard"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`discard is missing from object`)

		return nil, diags
	}

	discardVal, ok := discardAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`discard expected to be basetypes.BoolValue, was: %T`, discardAttribute))
	}

	metricAttribute, ok := attributes["metric"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`metric is missing from object`)

		return nil, diags
	}

	metricVal, ok := metricAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`metric expected to be basetypes.Int64Value, was: %T`, metricAttribute))
	}

	nextQualifiedAttribute, ok := attributes["next_qualified"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`next_qualified is missing from object`)

		return nil, diags
	}

	nextQualifiedVal, ok := nextQualifiedAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`next_qualified expected to be basetypes.MapValue, was: %T`, nextQualifiedAttribute))
	}

	noResolveAttribute, ok := attributes["no_resolve"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`no_resolve is missing from object`)

		return nil, diags
	}

	noResolveVal, ok := noResolveAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`no_resolve expected to be basetypes.BoolValue, was: %T`, noResolveAttribute))
	}

	preferenceAttribute, ok := attributes["preference"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`preference is missing from object`)

		return nil, diags
	}

	preferenceVal, ok := preferenceAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`preference expected to be basetypes.Int64Value, was: %T`, preferenceAttribute))
	}

	viaAttribute, ok := attributes["via"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`via is missing from object`)

		return nil, diags
	}

	viaVal, ok := viaAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`via expected to be basetypes.StringValue, was: %T`, viaAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ExtraRoutes6Value{
		Discard:       discardVal,
		Metric:        metricVal,
		NextQualified: nextQualifiedVal,
		NoResolve:     noResolveVal,
		Preference:    preferenceVal,
		Via:           viaVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewExtraRoutes6ValueNull() ExtraRoutes6Value {
	return ExtraRoutes6Value{
		state: attr.ValueStateNull,
	}
}

func NewExtraRoutes6ValueUnknown() ExtraRoutes6Value {
	return ExtraRoutes6Value{
		state: attr.ValueStateUnknown,
	}
}

func NewExtraRoutes6Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ExtraRoutes6Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ExtraRoutes6Value Attribute Value",
				"While creating a ExtraRoutes6Value value, a missing attribute value was detected. "+
					"A ExtraRoutes6Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ExtraRoutes6Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ExtraRoutes6Value Attribute Type",
				"While creating a ExtraRoutes6Value value, an invalid attribute value was detected. "+
					"A ExtraRoutes6Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ExtraRoutes6Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ExtraRoutes6Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ExtraRoutes6Value Attribute Value",
				"While creating a ExtraRoutes6Value value, an extra attribute value was detected. "+
					"A ExtraRoutes6Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ExtraRoutes6Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewExtraRoutes6ValueUnknown(), diags
	}

	discardAttribute, ok := attributes["discard"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`discard is missing from object`)

		return NewExtraRoutes6ValueUnknown(), diags
	}

	discardVal, ok := discardAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`discard expected to be basetypes.BoolValue, was: %T`, discardAttribute))
	}

	metricAttribute, ok := attributes["metric"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`metric is missing from object`)

		return NewExtraRoutes6ValueUnknown(), diags
	}

	metricVal, ok := metricAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`metric expected to be basetypes.Int64Value, was: %T`, metricAttribute))
	}

	nextQualifiedAttribute, ok := attributes["next_qualified"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`next_qualified is missing from object`)

		return NewExtraRoutes6ValueUnknown(), diags
	}

	nextQualifiedVal, ok := nextQualifiedAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`next_qualified expected to be basetypes.MapValue, was: %T`, nextQualifiedAttribute))
	}

	noResolveAttribute, ok := attributes["no_resolve"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`no_resolve is missing from object`)

		return NewExtraRoutes6ValueUnknown(), diags
	}

	noResolveVal, ok := noResolveAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`no_resolve expected to be basetypes.BoolValue, was: %T`, noResolveAttribute))
	}

	preferenceAttribute, ok := attributes["preference"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`preference is missing from object`)

		return NewExtraRoutes6ValueUnknown(), diags
	}

	preferenceVal, ok := preferenceAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`preference expected to be basetypes.Int64Value, was: %T`, preferenceAttribute))
	}

	viaAttribute, ok := attributes["via"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`via is missing from object`)

		return NewExtraRoutes6ValueUnknown(), diags
	}

	viaVal, ok := viaAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`via expected to be basetypes.StringValue, was: %T`, viaAttribute))
	}

	if diags.HasError() {
		return NewExtraRoutes6ValueUnknown(), diags
	}

	return ExtraRoutes6Value{
		Discard:       discardVal,
		Metric:        metricVal,
		NextQualified: nextQualifiedVal,
		NoResolve:     noResolveVal,
		Preference:    preferenceVal,
		Via:           viaVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewExtraRoutes6ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ExtraRoutes6Value {
	object, diags := NewExtraRoutes6Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewExtraRoutes6ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ExtraRoutes6Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewExtraRoutes6ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewExtraRoutes6ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewExtraRoutes6ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewExtraRoutes6ValueMust(ExtraRoutes6Value{}.AttributeTypes(ctx), attributes), nil
}

func (t ExtraRoutes6Type) ValueType(ctx context.Context) attr.Value {
	return ExtraRoutes6Value{}
}

var _ basetypes.ObjectValuable = ExtraRoutes6Value{}

type ExtraRoutes6Value struct {
	Discard       basetypes.BoolValue   `tfsdk:"discard"`
	Metric        basetypes.Int64Value  `tfsdk:"metric"`
	NextQualified basetypes.MapValue    `tfsdk:"next_qualified"`
	NoResolve     basetypes.BoolValue   `tfsdk:"no_resolve"`
	Preference    basetypes.Int64Value  `tfsdk:"preference"`
	Via           basetypes.StringValue `tfsdk:"via"`
	state         attr.ValueState
}

func (v ExtraRoutes6Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 6)

	var val tftypes.Value
	var err error

	attrTypes["discard"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["metric"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["next_qualified"] = basetypes.MapType{
		ElemType: NextQualifiedValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["no_resolve"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["preference"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["via"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 6)

		val, err = v.Discard.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["discard"] = val

		val, err = v.Metric.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["metric"] = val

		val, err = v.NextQualified.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["next_qualified"] = val

		val, err = v.NoResolve.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["no_resolve"] = val

		val, err = v.Preference.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["preference"] = val

		val, err = v.Via.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["via"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ExtraRoutes6Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ExtraRoutes6Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ExtraRoutes6Value) String() string {
	return "ExtraRoutes6Value"
}

func (v ExtraRoutes6Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	nextQualified := types.MapValueMust(
		NextQualifiedType{
			basetypes.ObjectType{
				AttrTypes: NextQualifiedValue{}.AttributeTypes(ctx),
			},
		},
		v.NextQualified.Elements(),
	)

	if v.NextQualified.IsNull() {
		nextQualified = types.MapNull(
			NextQualifiedType{
				basetypes.ObjectType{
					AttrTypes: NextQualifiedValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.NextQualified.IsUnknown() {
		nextQualified = types.MapUnknown(
			NextQualifiedType{
				basetypes.ObjectType{
					AttrTypes: NextQualifiedValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"discard": basetypes.BoolType{},
		"metric":  basetypes.Int64Type{},
		"next_qualified": basetypes.MapType{
			ElemType: NextQualifiedValue{}.Type(ctx),
		},
		"no_resolve": basetypes.BoolType{},
		"preference": basetypes.Int64Type{},
		"via":        basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"discard":        v.Discard,
			"metric":         v.Metric,
			"next_qualified": nextQualified,
			"no_resolve":     v.NoResolve,
			"preference":     v.Preference,
			"via":            v.Via,
		})

	return objVal, diags
}

func (v ExtraRoutes6Value) Equal(o attr.Value) bool {
	other, ok := o.(ExtraRoutes6Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Discard.Equal(other.Discard) {
		return false
	}

	if !v.Metric.Equal(other.Metric) {
		return false
	}

	if !v.NextQualified.Equal(other.NextQualified) {
		return false
	}

	if !v.NoResolve.Equal(other.NoResolve) {
		return false
	}

	if !v.Preference.Equal(other.Preference) {
		return false
	}

	if !v.Via.Equal(other.Via) {
		return false
	}

	return true
}

func (v ExtraRoutes6Value) Type(ctx context.Context) attr.Type {
	return ExtraRoutes6Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ExtraRoutes6Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"discard": basetypes.BoolType{},
		"metric":  basetypes.Int64Type{},
		"next_qualified": basetypes.MapType{
			ElemType: NextQualifiedValue{}.Type(ctx),
		},
		"no_resolve": basetypes.BoolType{},
		"preference": basetypes.Int64Type{},
		"via":        basetypes.StringType{},
	}
}






















var _ basetypes.ObjectTypable = MistNacType{}

type MistNacType struct {
	basetypes.ObjectType
}

func (t MistNacType) Equal(o attr.Type) bool {
	other, ok := o.(MistNacType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t MistNacType) String() string {
	return "MistNacType"
}

func (t MistNacType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	networkAttribute, ok := attributes["network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`network is missing from object`)

		return nil, diags
	}

	networkVal, ok := networkAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`network expected to be basetypes.StringValue, was: %T`, networkAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return MistNacValue{
		Enabled: enabledVal,
		Network: networkVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewMistNacValueNull() MistNacValue {
	return MistNacValue{
		state: attr.ValueStateNull,
	}
}

func NewMistNacValueUnknown() MistNacValue {
	return MistNacValue{
		state: attr.ValueStateUnknown,
	}
}

func NewMistNacValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (MistNacValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing MistNacValue Attribute Value",
				"While creating a MistNacValue value, a missing attribute value was detected. "+
					"A MistNacValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MistNacValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid MistNacValue Attribute Type",
				"While creating a MistNacValue value, an invalid attribute value was detected. "+
					"A MistNacValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MistNacValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("MistNacValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra MistNacValue Attribute Value",
				"While creating a MistNacValue value, an extra attribute value was detected. "+
					"A MistNacValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra MistNacValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewMistNacValueUnknown(), diags
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewMistNacValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	networkAttribute, ok := attributes["network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`network is missing from object`)

		return NewMistNacValueUnknown(), diags
	}

	networkVal, ok := networkAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`network expected to be basetypes.StringValue, was: %T`, networkAttribute))
	}

	if diags.HasError() {
		return NewMistNacValueUnknown(), diags
	}

	return MistNacValue{
		Enabled: enabledVal,
		Network: networkVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewMistNacValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) MistNacValue {
	object, diags := NewMistNacValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewMistNacValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t MistNacType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewMistNacValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewMistNacValueUnknown(), nil
	}

	if in.IsNull() {
		return NewMistNacValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewMistNacValueMust(MistNacValue{}.AttributeTypes(ctx), attributes), nil
}

func (t MistNacType) ValueType(ctx context.Context) attr.Value {
	return MistNacValue{}
}

var _ basetypes.ObjectValuable = MistNacValue{}

type MistNacValue struct {
	Enabled basetypes.BoolValue   `tfsdk:"enabled"`
	Network basetypes.StringValue `tfsdk:"network"`
	state   attr.ValueState
}

func (v MistNacValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["network"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.Network.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["network"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v MistNacValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v MistNacValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v MistNacValue) String() string {
	return "MistNacValue"
}

func (v MistNacValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"enabled": basetypes.BoolType{},
		"network": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"enabled": v.Enabled,
			"network": v.Network,
		})

	return objVal, diags
}

func (v MistNacValue) Equal(o attr.Value) bool {
	other, ok := o.(MistNacValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.Network.Equal(other.Network) {
		return false
	}

	return true
}

func (v MistNacValue) Type(ctx context.Context) attr.Type {
	return MistNacType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v MistNacValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"enabled": basetypes.BoolType{},
		"network": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = NetworksType{}

type NetworksType struct {
	basetypes.ObjectType
}

func (t NetworksType) Equal(o attr.Type) bool {
	other, ok := o.(NetworksType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t NetworksType) String() string {
	return "NetworksType"
}

func (t NetworksType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	isolationAttribute, ok := attributes["isolation"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`isolation is missing from object`)

		return nil, diags
	}

	isolationVal, ok := isolationAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`isolation expected to be basetypes.BoolValue, was: %T`, isolationAttribute))
	}

	isolationVlanIdAttribute, ok := attributes["isolation_vlan_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`isolation_vlan_id is missing from object`)

		return nil, diags
	}

	isolationVlanIdVal, ok := isolationVlanIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`isolation_vlan_id expected to be basetypes.StringValue, was: %T`, isolationVlanIdAttribute))
	}

	subnetAttribute, ok := attributes["subnet"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet is missing from object`)

		return nil, diags
	}

	subnetVal, ok := subnetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet expected to be basetypes.StringValue, was: %T`, subnetAttribute))
	}

	vlanIdAttribute, ok := attributes["vlan_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan_id is missing from object`)

		return nil, diags
	}

	vlanIdVal, ok := vlanIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan_id expected to be basetypes.Int64Value, was: %T`, vlanIdAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return NetworksValue{
		Isolation:       isolationVal,
		IsolationVlanId: isolationVlanIdVal,
		Subnet:          subnetVal,
		VlanId:          vlanIdVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewNetworksValueNull() NetworksValue {
	return NetworksValue{
		state: attr.ValueStateNull,
	}
}

func NewNetworksValueUnknown() NetworksValue {
	return NetworksValue{
		state: attr.ValueStateUnknown,
	}
}

func NewNetworksValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (NetworksValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing NetworksValue Attribute Value",
				"While creating a NetworksValue value, a missing attribute value was detected. "+
					"A NetworksValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NetworksValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid NetworksValue Attribute Type",
				"While creating a NetworksValue value, an invalid attribute value was detected. "+
					"A NetworksValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NetworksValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("NetworksValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra NetworksValue Attribute Value",
				"While creating a NetworksValue value, an extra attribute value was detected. "+
					"A NetworksValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra NetworksValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewNetworksValueUnknown(), diags
	}

	isolationAttribute, ok := attributes["isolation"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`isolation is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	isolationVal, ok := isolationAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`isolation expected to be basetypes.BoolValue, was: %T`, isolationAttribute))
	}

	isolationVlanIdAttribute, ok := attributes["isolation_vlan_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`isolation_vlan_id is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	isolationVlanIdVal, ok := isolationVlanIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`isolation_vlan_id expected to be basetypes.StringValue, was: %T`, isolationVlanIdAttribute))
	}

	subnetAttribute, ok := attributes["subnet"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	subnetVal, ok := subnetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet expected to be basetypes.StringValue, was: %T`, subnetAttribute))
	}

	vlanIdAttribute, ok := attributes["vlan_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan_id is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	vlanIdVal, ok := vlanIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan_id expected to be basetypes.Int64Value, was: %T`, vlanIdAttribute))
	}

	if diags.HasError() {
		return NewNetworksValueUnknown(), diags
	}

	return NetworksValue{
		Isolation:       isolationVal,
		IsolationVlanId: isolationVlanIdVal,
		Subnet:          subnetVal,
		VlanId:          vlanIdVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewNetworksValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) NetworksValue {
	object, diags := NewNetworksValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewNetworksValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t NetworksType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewNetworksValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewNetworksValueUnknown(), nil
	}

	if in.IsNull() {
		return NewNetworksValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewNetworksValueMust(NetworksValue{}.AttributeTypes(ctx), attributes), nil
}

func (t NetworksType) ValueType(ctx context.Context) attr.Value {
	return NetworksValue{}
}

var _ basetypes.ObjectValuable = NetworksValue{}

type NetworksValue struct {
	Isolation       basetypes.BoolValue   `tfsdk:"isolation"`
	IsolationVlanId basetypes.StringValue `tfsdk:"isolation_vlan_id"`
	Subnet          basetypes.StringValue `tfsdk:"subnet"`
	VlanId          basetypes.Int64Value  `tfsdk:"vlan_id"`
	state           attr.ValueState
}

func (v NetworksValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["isolation"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["isolation_vlan_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["subnet"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["vlan_id"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Isolation.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["isolation"] = val

		val, err = v.IsolationVlanId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["isolation_vlan_id"] = val

		val, err = v.Subnet.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["subnet"] = val

		val, err = v.VlanId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vlan_id"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v NetworksValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v NetworksValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v NetworksValue) String() string {
	return "NetworksValue"
}

func (v NetworksValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"isolation":         basetypes.BoolType{},
		"isolation_vlan_id": basetypes.StringType{},
		"subnet":            basetypes.StringType{},
		"vlan_id":           basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"isolation":         v.Isolation,
			"isolation_vlan_id": v.IsolationVlanId,
			"subnet":            v.Subnet,
			"vlan_id":           v.VlanId,
		})

	return objVal, diags
}

func (v NetworksValue) Equal(o attr.Value) bool {
	other, ok := o.(NetworksValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Isolation.Equal(other.Isolation) {
		return false
	}

	if !v.IsolationVlanId.Equal(other.IsolationVlanId) {
		return false
	}

	if !v.Subnet.Equal(other.Subnet) {
		return false
	}

	if !v.VlanId.Equal(other.VlanId) {
		return false
	}

	return true
}

func (v NetworksValue) Type(ctx context.Context) attr.Type {
	return NetworksType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v NetworksValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"isolation":         basetypes.BoolType{},
		"isolation_vlan_id": basetypes.StringType{},
		"subnet":            basetypes.StringType{},
		"vlan_id":           basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = PortMirroringType{}

type PortMirroringType struct {
	basetypes.ObjectType
}

func (t PortMirroringType) Equal(o attr.Type) bool {
	other, ok := o.(PortMirroringType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PortMirroringType) String() string {
	return "PortMirroringType"
}

func (t PortMirroringType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	inputNetworksIngressAttribute, ok := attributes["input_networks_ingress"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`input_networks_ingress is missing from object`)

		return nil, diags
	}

	inputNetworksIngressVal, ok := inputNetworksIngressAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`input_networks_ingress expected to be basetypes.ListValue, was: %T`, inputNetworksIngressAttribute))
	}

	inputPortIdsEgressAttribute, ok := attributes["input_port_ids_egress"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`input_port_ids_egress is missing from object`)

		return nil, diags
	}

	inputPortIdsEgressVal, ok := inputPortIdsEgressAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`input_port_ids_egress expected to be basetypes.ListValue, was: %T`, inputPortIdsEgressAttribute))
	}

	inputPortIdsIngressAttribute, ok := attributes["input_port_ids_ingress"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`input_port_ids_ingress is missing from object`)

		return nil, diags
	}

	inputPortIdsIngressVal, ok := inputPortIdsIngressAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`input_port_ids_ingress expected to be basetypes.ListValue, was: %T`, inputPortIdsIngressAttribute))
	}

	outputNetworkAttribute, ok := attributes["output_network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`output_network is missing from object`)

		return nil, diags
	}

	outputNetworkVal, ok := outputNetworkAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`output_network expected to be basetypes.StringValue, was: %T`, outputNetworkAttribute))
	}

	outputPortIdAttribute, ok := attributes["output_port_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`output_port_id is missing from object`)

		return nil, diags
	}

	outputPortIdVal, ok := outputPortIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`output_port_id expected to be basetypes.StringValue, was: %T`, outputPortIdAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PortMirroringValue{
		InputNetworksIngress: inputNetworksIngressVal,
		InputPortIdsEgress:   inputPortIdsEgressVal,
		InputPortIdsIngress:  inputPortIdsIngressVal,
		OutputNetwork:        outputNetworkVal,
		OutputPortId:         outputPortIdVal,
		state:                attr.ValueStateKnown,
	}, diags
}

func NewPortMirroringValueNull() PortMirroringValue {
	return PortMirroringValue{
		state: attr.ValueStateNull,
	}
}

func NewPortMirroringValueUnknown() PortMirroringValue {
	return PortMirroringValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPortMirroringValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PortMirroringValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PortMirroringValue Attribute Value",
				"While creating a PortMirroringValue value, a missing attribute value was detected. "+
					"A PortMirroringValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PortMirroringValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PortMirroringValue Attribute Type",
				"While creating a PortMirroringValue value, an invalid attribute value was detected. "+
					"A PortMirroringValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PortMirroringValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PortMirroringValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PortMirroringValue Attribute Value",
				"While creating a PortMirroringValue value, an extra attribute value was detected. "+
					"A PortMirroringValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PortMirroringValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPortMirroringValueUnknown(), diags
	}

	inputNetworksIngressAttribute, ok := attributes["input_networks_ingress"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`input_networks_ingress is missing from object`)

		return NewPortMirroringValueUnknown(), diags
	}

	inputNetworksIngressVal, ok := inputNetworksIngressAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`input_networks_ingress expected to be basetypes.ListValue, was: %T`, inputNetworksIngressAttribute))
	}

	inputPortIdsEgressAttribute, ok := attributes["input_port_ids_egress"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`input_port_ids_egress is missing from object`)

		return NewPortMirroringValueUnknown(), diags
	}

	inputPortIdsEgressVal, ok := inputPortIdsEgressAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`input_port_ids_egress expected to be basetypes.ListValue, was: %T`, inputPortIdsEgressAttribute))
	}

	inputPortIdsIngressAttribute, ok := attributes["input_port_ids_ingress"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`input_port_ids_ingress is missing from object`)

		return NewPortMirroringValueUnknown(), diags
	}

	inputPortIdsIngressVal, ok := inputPortIdsIngressAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`input_port_ids_ingress expected to be basetypes.ListValue, was: %T`, inputPortIdsIngressAttribute))
	}

	outputNetworkAttribute, ok := attributes["output_network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`output_network is missing from object`)

		return NewPortMirroringValueUnknown(), diags
	}

	outputNetworkVal, ok := outputNetworkAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`output_network expected to be basetypes.StringValue, was: %T`, outputNetworkAttribute))
	}

	outputPortIdAttribute, ok := attributes["output_port_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`output_port_id is missing from object`)

		return NewPortMirroringValueUnknown(), diags
	}

	outputPortIdVal, ok := outputPortIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`output_port_id expected to be basetypes.StringValue, was: %T`, outputPortIdAttribute))
	}

	if diags.HasError() {
		return NewPortMirroringValueUnknown(), diags
	}

	return PortMirroringValue{
		InputNetworksIngress: inputNetworksIngressVal,
		InputPortIdsEgress:   inputPortIdsEgressVal,
		InputPortIdsIngress:  inputPortIdsIngressVal,
		OutputNetwork:        outputNetworkVal,
		OutputPortId:         outputPortIdVal,
		state:                attr.ValueStateKnown,
	}, diags
}

func NewPortMirroringValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PortMirroringValue {
	object, diags := NewPortMirroringValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPortMirroringValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PortMirroringType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPortMirroringValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPortMirroringValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPortMirroringValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPortMirroringValueMust(PortMirroringValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PortMirroringType) ValueType(ctx context.Context) attr.Value {
	return PortMirroringValue{}
}

var _ basetypes.ObjectValuable = PortMirroringValue{}

type PortMirroringValue struct {
	InputNetworksIngress basetypes.ListValue   `tfsdk:"input_networks_ingress"`
	InputPortIdsEgress   basetypes.ListValue   `tfsdk:"input_port_ids_egress"`
	InputPortIdsIngress  basetypes.ListValue   `tfsdk:"input_port_ids_ingress"`
	OutputNetwork        basetypes.StringValue `tfsdk:"output_network"`
	OutputPortId         basetypes.StringValue `tfsdk:"output_port_id"`
	state                attr.ValueState
}

func (v PortMirroringValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["input_networks_ingress"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["input_port_ids_egress"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["input_port_ids_ingress"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["output_network"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["output_port_id"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.InputNetworksIngress.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["input_networks_ingress"] = val

		val, err = v.InputPortIdsEgress.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["input_port_ids_egress"] = val

		val, err = v.InputPortIdsIngress.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["input_port_ids_ingress"] = val

		val, err = v.OutputNetwork.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["output_network"] = val

		val, err = v.OutputPortId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["output_port_id"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PortMirroringValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PortMirroringValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PortMirroringValue) String() string {
	return "PortMirroringValue"
}

func (v PortMirroringValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	inputNetworksIngressVal, d := types.ListValue(types.StringType, v.InputNetworksIngress.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"input_networks_ingress": basetypes.ListType{
				ElemType: types.StringType,
			},
			"input_port_ids_egress": basetypes.ListType{
				ElemType: types.StringType,
			},
			"input_port_ids_ingress": basetypes.ListType{
				ElemType: types.StringType,
			},
			"output_network": basetypes.StringType{},
			"output_port_id": basetypes.StringType{},
		}), diags
	}

	inputPortIdsEgressVal, d := types.ListValue(types.StringType, v.InputPortIdsEgress.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"input_networks_ingress": basetypes.ListType{
				ElemType: types.StringType,
			},
			"input_port_ids_egress": basetypes.ListType{
				ElemType: types.StringType,
			},
			"input_port_ids_ingress": basetypes.ListType{
				ElemType: types.StringType,
			},
			"output_network": basetypes.StringType{},
			"output_port_id": basetypes.StringType{},
		}), diags
	}

	inputPortIdsIngressVal, d := types.ListValue(types.StringType, v.InputPortIdsIngress.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"input_networks_ingress": basetypes.ListType{
				ElemType: types.StringType,
			},
			"input_port_ids_egress": basetypes.ListType{
				ElemType: types.StringType,
			},
			"input_port_ids_ingress": basetypes.ListType{
				ElemType: types.StringType,
			},
			"output_network": basetypes.StringType{},
			"output_port_id": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"input_networks_ingress": basetypes.ListType{
			ElemType: types.StringType,
		},
		"input_port_ids_egress": basetypes.ListType{
			ElemType: types.StringType,
		},
		"input_port_ids_ingress": basetypes.ListType{
			ElemType: types.StringType,
		},
		"output_network": basetypes.StringType{},
		"output_port_id": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"input_networks_ingress": inputNetworksIngressVal,
			"input_port_ids_egress":  inputPortIdsEgressVal,
			"input_port_ids_ingress": inputPortIdsIngressVal,
			"output_network":         v.OutputNetwork,
			"output_port_id":         v.OutputPortId,
		})

	return objVal, diags
}

func (v PortMirroringValue) Equal(o attr.Value) bool {
	other, ok := o.(PortMirroringValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.InputNetworksIngress.Equal(other.InputNetworksIngress) {
		return false
	}

	if !v.InputPortIdsEgress.Equal(other.InputPortIdsEgress) {
		return false
	}

	if !v.InputPortIdsIngress.Equal(other.InputPortIdsIngress) {
		return false
	}

	if !v.OutputNetwork.Equal(other.OutputNetwork) {
		return false
	}

	if !v.OutputPortId.Equal(other.OutputPortId) {
		return false
	}

	return true
}

func (v PortMirroringValue) Type(ctx context.Context) attr.Type {
	return PortMirroringType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PortMirroringValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"input_networks_ingress": basetypes.ListType{
			ElemType: types.StringType,
		},
		"input_port_ids_egress": basetypes.ListType{
			ElemType: types.StringType,
		},
		"input_port_ids_ingress": basetypes.ListType{
			ElemType: types.StringType,
		},
		"output_network": basetypes.StringType{},
		"output_port_id": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = PortUsagesType{}

type PortUsagesType struct {
	basetypes.ObjectType
}

func (t PortUsagesType) Equal(o attr.Type) bool {
	other, ok := o.(PortUsagesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PortUsagesType) String() string {
	return "PortUsagesType"
}

func (t PortUsagesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	allNetworksAttribute, ok := attributes["all_networks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`all_networks is missing from object`)

		return nil, diags
	}

	allNetworksVal, ok := allNetworksAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`all_networks expected to be basetypes.BoolValue, was: %T`, allNetworksAttribute))
	}

	allowDhcpdAttribute, ok := attributes["allow_dhcpd"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allow_dhcpd is missing from object`)

		return nil, diags
	}

	allowDhcpdVal, ok := allowDhcpdAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allow_dhcpd expected to be basetypes.BoolValue, was: %T`, allowDhcpdAttribute))
	}

	allowMultipleSupplicantsAttribute, ok := attributes["allow_multiple_supplicants"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allow_multiple_supplicants is missing from object`)

		return nil, diags
	}

	allowMultipleSupplicantsVal, ok := allowMultipleSupplicantsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allow_multiple_supplicants expected to be basetypes.BoolValue, was: %T`, allowMultipleSupplicantsAttribute))
	}

	bypassAuthWhenServerDownAttribute, ok := attributes["bypass_auth_when_server_down"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bypass_auth_when_server_down is missing from object`)

		return nil, diags
	}

	bypassAuthWhenServerDownVal, ok := bypassAuthWhenServerDownAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bypass_auth_when_server_down expected to be basetypes.BoolValue, was: %T`, bypassAuthWhenServerDownAttribute))
	}

	bypassAuthWhenServerDownForUnkonwnClientAttribute, ok := attributes["bypass_auth_when_server_down_for_unkonwn_client"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bypass_auth_when_server_down_for_unkonwn_client is missing from object`)

		return nil, diags
	}

	bypassAuthWhenServerDownForUnkonwnClientVal, ok := bypassAuthWhenServerDownForUnkonwnClientAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bypass_auth_when_server_down_for_unkonwn_client expected to be basetypes.BoolValue, was: %T`, bypassAuthWhenServerDownForUnkonwnClientAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return nil, diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	disableAutonegAttribute, ok := attributes["disable_autoneg"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disable_autoneg is missing from object`)

		return nil, diags
	}

	disableAutonegVal, ok := disableAutonegAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disable_autoneg expected to be basetypes.BoolValue, was: %T`, disableAutonegAttribute))
	}

	disabledAttribute, ok := attributes["disabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disabled is missing from object`)

		return nil, diags
	}

	disabledVal, ok := disabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disabled expected to be basetypes.BoolValue, was: %T`, disabledAttribute))
	}

	duplexAttribute, ok := attributes["duplex"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`duplex is missing from object`)

		return nil, diags
	}

	duplexVal, ok := duplexAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`duplex expected to be basetypes.StringValue, was: %T`, duplexAttribute))
	}

	dynamicVlanNetworksAttribute, ok := attributes["dynamic_vlan_networks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dynamic_vlan_networks is missing from object`)

		return nil, diags
	}

	dynamicVlanNetworksVal, ok := dynamicVlanNetworksAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dynamic_vlan_networks expected to be basetypes.ListValue, was: %T`, dynamicVlanNetworksAttribute))
	}

	enableMacAuthAttribute, ok := attributes["enable_mac_auth"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable_mac_auth is missing from object`)

		return nil, diags
	}

	enableMacAuthVal, ok := enableMacAuthAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable_mac_auth expected to be basetypes.BoolValue, was: %T`, enableMacAuthAttribute))
	}

	enableQosAttribute, ok := attributes["enable_qos"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable_qos is missing from object`)

		return nil, diags
	}

	enableQosVal, ok := enableQosAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable_qos expected to be basetypes.BoolValue, was: %T`, enableQosAttribute))
	}

	guestNetworkAttribute, ok := attributes["guest_network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`guest_network is missing from object`)

		return nil, diags
	}

	guestNetworkVal, ok := guestNetworkAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`guest_network expected to be basetypes.StringValue, was: %T`, guestNetworkAttribute))
	}

	interSwitchLinkAttribute, ok := attributes["inter_switch_link"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`inter_switch_link is missing from object`)

		return nil, diags
	}

	interSwitchLinkVal, ok := interSwitchLinkAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`inter_switch_link expected to be basetypes.BoolValue, was: %T`, interSwitchLinkAttribute))
	}

	macAuthOnlyAttribute, ok := attributes["mac_auth_only"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mac_auth_only is missing from object`)

		return nil, diags
	}

	macAuthOnlyVal, ok := macAuthOnlyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mac_auth_only expected to be basetypes.BoolValue, was: %T`, macAuthOnlyAttribute))
	}

	macAuthProtocolAttribute, ok := attributes["mac_auth_protocol"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mac_auth_protocol is missing from object`)

		return nil, diags
	}

	macAuthProtocolVal, ok := macAuthProtocolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mac_auth_protocol expected to be basetypes.StringValue, was: %T`, macAuthProtocolAttribute))
	}

	macLimitAttribute, ok := attributes["mac_limit"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mac_limit is missing from object`)

		return nil, diags
	}

	macLimitVal, ok := macLimitAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mac_limit expected to be basetypes.Int64Value, was: %T`, macLimitAttribute))
	}

	modeAttribute, ok := attributes["mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mode is missing from object`)

		return nil, diags
	}

	modeVal, ok := modeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mode expected to be basetypes.StringValue, was: %T`, modeAttribute))
	}

	mtuAttribute, ok := attributes["mtu"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mtu is missing from object`)

		return nil, diags
	}

	mtuVal, ok := mtuAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mtu expected to be basetypes.Int64Value, was: %T`, mtuAttribute))
	}

	networksAttribute, ok := attributes["networks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`networks is missing from object`)

		return nil, diags
	}

	networksVal, ok := networksAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`networks expected to be basetypes.ListValue, was: %T`, networksAttribute))
	}

	persistMacAttribute, ok := attributes["persist_mac"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`persist_mac is missing from object`)

		return nil, diags
	}

	persistMacVal, ok := persistMacAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`persist_mac expected to be basetypes.BoolValue, was: %T`, persistMacAttribute))
	}

	poeDisabledAttribute, ok := attributes["poe_disabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`poe_disabled is missing from object`)

		return nil, diags
	}

	poeDisabledVal, ok := poeDisabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`poe_disabled expected to be basetypes.BoolValue, was: %T`, poeDisabledAttribute))
	}

	portAuthAttribute, ok := attributes["port_auth"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_auth is missing from object`)

		return nil, diags
	}

	portAuthVal, ok := portAuthAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_auth expected to be basetypes.StringValue, was: %T`, portAuthAttribute))
	}

	portNetworkAttribute, ok := attributes["port_network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_network is missing from object`)

		return nil, diags
	}

	portNetworkVal, ok := portNetworkAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_network expected to be basetypes.StringValue, was: %T`, portNetworkAttribute))
	}

	reauthIntervalAttribute, ok := attributes["reauth_interval"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`reauth_interval is missing from object`)

		return nil, diags
	}

	reauthIntervalVal, ok := reauthIntervalAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`reauth_interval expected to be basetypes.Int64Value, was: %T`, reauthIntervalAttribute))
	}

	rejectedNetworkAttribute, ok := attributes["rejected_network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rejected_network is missing from object`)

		return nil, diags
	}

	rejectedNetworkVal, ok := rejectedNetworkAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rejected_network expected to be basetypes.StringValue, was: %T`, rejectedNetworkAttribute))
	}

	resetDefaultWhenAttribute, ok := attributes["reset_default_when"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`reset_default_when is missing from object`)

		return nil, diags
	}

	resetDefaultWhenVal, ok := resetDefaultWhenAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`reset_default_when expected to be basetypes.StringValue, was: %T`, resetDefaultWhenAttribute))
	}

	rulesAttribute, ok := attributes["rules"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rules is missing from object`)

		return nil, diags
	}

	rulesVal, ok := rulesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rules expected to be basetypes.ListValue, was: %T`, rulesAttribute))
	}

	speedAttribute, ok := attributes["speed"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`speed is missing from object`)

		return nil, diags
	}

	speedVal, ok := speedAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`speed expected to be basetypes.StringValue, was: %T`, speedAttribute))
	}

	stormControlAttribute, ok := attributes["storm_control"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`storm_control is missing from object`)

		return nil, diags
	}

	stormControlVal, ok := stormControlAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`storm_control expected to be basetypes.ObjectValue, was: %T`, stormControlAttribute))
	}

	stpEdgeAttribute, ok := attributes["stp_edge"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`stp_edge is missing from object`)

		return nil, diags
	}

	stpEdgeVal, ok := stpEdgeAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`stp_edge expected to be basetypes.BoolValue, was: %T`, stpEdgeAttribute))
	}

	voipNetworkAttribute, ok := attributes["voip_network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`voip_network is missing from object`)

		return nil, diags
	}

	voipNetworkVal, ok := voipNetworkAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`voip_network expected to be basetypes.StringValue, was: %T`, voipNetworkAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PortUsagesValue{
		AllNetworks:                              allNetworksVal,
		AllowDhcpd:                               allowDhcpdVal,
		AllowMultipleSupplicants:                 allowMultipleSupplicantsVal,
		BypassAuthWhenServerDown:                 bypassAuthWhenServerDownVal,
		BypassAuthWhenServerDownForUnkonwnClient: bypassAuthWhenServerDownForUnkonwnClientVal,
		Description:                              descriptionVal,
		DisableAutoneg:                           disableAutonegVal,
		Disabled:                                 disabledVal,
		Duplex:                                   duplexVal,
		DynamicVlanNetworks:                      dynamicVlanNetworksVal,
		EnableMacAuth:                            enableMacAuthVal,
		EnableQos:                                enableQosVal,
		GuestNetwork:                             guestNetworkVal,
		InterSwitchLink:                          interSwitchLinkVal,
		MacAuthOnly:                              macAuthOnlyVal,
		MacAuthProtocol:                          macAuthProtocolVal,
		MacLimit:                                 macLimitVal,
		Mode:                                     modeVal,
		Mtu:                                      mtuVal,
		Networks:                                 networksVal,
		PersistMac:                               persistMacVal,
		PoeDisabled:                              poeDisabledVal,
		PortAuth:                                 portAuthVal,
		PortNetwork:                              portNetworkVal,
		ReauthInterval:                           reauthIntervalVal,
		RejectedNetwork:                          rejectedNetworkVal,
		ResetDefaultWhen:                         resetDefaultWhenVal,
		Rules:                                    rulesVal,
		Speed:                                    speedVal,
		StormControl:                             stormControlVal,
		StpEdge:                                  stpEdgeVal,
		VoipNetwork:                              voipNetworkVal,
		state:                                    attr.ValueStateKnown,
	}, diags
}

func NewPortUsagesValueNull() PortUsagesValue {
	return PortUsagesValue{
		state: attr.ValueStateNull,
	}
}

func NewPortUsagesValueUnknown() PortUsagesValue {
	return PortUsagesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPortUsagesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PortUsagesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PortUsagesValue Attribute Value",
				"While creating a PortUsagesValue value, a missing attribute value was detected. "+
					"A PortUsagesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PortUsagesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PortUsagesValue Attribute Type",
				"While creating a PortUsagesValue value, an invalid attribute value was detected. "+
					"A PortUsagesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PortUsagesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PortUsagesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PortUsagesValue Attribute Value",
				"While creating a PortUsagesValue value, an extra attribute value was detected. "+
					"A PortUsagesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PortUsagesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPortUsagesValueUnknown(), diags
	}

	allNetworksAttribute, ok := attributes["all_networks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`all_networks is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	allNetworksVal, ok := allNetworksAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`all_networks expected to be basetypes.BoolValue, was: %T`, allNetworksAttribute))
	}

	allowDhcpdAttribute, ok := attributes["allow_dhcpd"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allow_dhcpd is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	allowDhcpdVal, ok := allowDhcpdAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allow_dhcpd expected to be basetypes.BoolValue, was: %T`, allowDhcpdAttribute))
	}

	allowMultipleSupplicantsAttribute, ok := attributes["allow_multiple_supplicants"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allow_multiple_supplicants is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	allowMultipleSupplicantsVal, ok := allowMultipleSupplicantsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allow_multiple_supplicants expected to be basetypes.BoolValue, was: %T`, allowMultipleSupplicantsAttribute))
	}

	bypassAuthWhenServerDownAttribute, ok := attributes["bypass_auth_when_server_down"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bypass_auth_when_server_down is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	bypassAuthWhenServerDownVal, ok := bypassAuthWhenServerDownAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bypass_auth_when_server_down expected to be basetypes.BoolValue, was: %T`, bypassAuthWhenServerDownAttribute))
	}

	bypassAuthWhenServerDownForUnkonwnClientAttribute, ok := attributes["bypass_auth_when_server_down_for_unkonwn_client"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bypass_auth_when_server_down_for_unkonwn_client is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	bypassAuthWhenServerDownForUnkonwnClientVal, ok := bypassAuthWhenServerDownForUnkonwnClientAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bypass_auth_when_server_down_for_unkonwn_client expected to be basetypes.BoolValue, was: %T`, bypassAuthWhenServerDownForUnkonwnClientAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	disableAutonegAttribute, ok := attributes["disable_autoneg"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disable_autoneg is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	disableAutonegVal, ok := disableAutonegAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disable_autoneg expected to be basetypes.BoolValue, was: %T`, disableAutonegAttribute))
	}

	disabledAttribute, ok := attributes["disabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disabled is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	disabledVal, ok := disabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disabled expected to be basetypes.BoolValue, was: %T`, disabledAttribute))
	}

	duplexAttribute, ok := attributes["duplex"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`duplex is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	duplexVal, ok := duplexAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`duplex expected to be basetypes.StringValue, was: %T`, duplexAttribute))
	}

	dynamicVlanNetworksAttribute, ok := attributes["dynamic_vlan_networks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dynamic_vlan_networks is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	dynamicVlanNetworksVal, ok := dynamicVlanNetworksAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dynamic_vlan_networks expected to be basetypes.ListValue, was: %T`, dynamicVlanNetworksAttribute))
	}

	enableMacAuthAttribute, ok := attributes["enable_mac_auth"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable_mac_auth is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	enableMacAuthVal, ok := enableMacAuthAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable_mac_auth expected to be basetypes.BoolValue, was: %T`, enableMacAuthAttribute))
	}

	enableQosAttribute, ok := attributes["enable_qos"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable_qos is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	enableQosVal, ok := enableQosAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable_qos expected to be basetypes.BoolValue, was: %T`, enableQosAttribute))
	}

	guestNetworkAttribute, ok := attributes["guest_network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`guest_network is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	guestNetworkVal, ok := guestNetworkAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`guest_network expected to be basetypes.StringValue, was: %T`, guestNetworkAttribute))
	}

	interSwitchLinkAttribute, ok := attributes["inter_switch_link"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`inter_switch_link is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	interSwitchLinkVal, ok := interSwitchLinkAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`inter_switch_link expected to be basetypes.BoolValue, was: %T`, interSwitchLinkAttribute))
	}

	macAuthOnlyAttribute, ok := attributes["mac_auth_only"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mac_auth_only is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	macAuthOnlyVal, ok := macAuthOnlyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mac_auth_only expected to be basetypes.BoolValue, was: %T`, macAuthOnlyAttribute))
	}

	macAuthProtocolAttribute, ok := attributes["mac_auth_protocol"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mac_auth_protocol is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	macAuthProtocolVal, ok := macAuthProtocolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mac_auth_protocol expected to be basetypes.StringValue, was: %T`, macAuthProtocolAttribute))
	}

	macLimitAttribute, ok := attributes["mac_limit"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mac_limit is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	macLimitVal, ok := macLimitAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mac_limit expected to be basetypes.Int64Value, was: %T`, macLimitAttribute))
	}

	modeAttribute, ok := attributes["mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mode is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	modeVal, ok := modeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mode expected to be basetypes.StringValue, was: %T`, modeAttribute))
	}

	mtuAttribute, ok := attributes["mtu"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mtu is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	mtuVal, ok := mtuAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mtu expected to be basetypes.Int64Value, was: %T`, mtuAttribute))
	}

	networksAttribute, ok := attributes["networks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`networks is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	networksVal, ok := networksAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`networks expected to be basetypes.ListValue, was: %T`, networksAttribute))
	}

	persistMacAttribute, ok := attributes["persist_mac"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`persist_mac is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	persistMacVal, ok := persistMacAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`persist_mac expected to be basetypes.BoolValue, was: %T`, persistMacAttribute))
	}

	poeDisabledAttribute, ok := attributes["poe_disabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`poe_disabled is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	poeDisabledVal, ok := poeDisabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`poe_disabled expected to be basetypes.BoolValue, was: %T`, poeDisabledAttribute))
	}

	portAuthAttribute, ok := attributes["port_auth"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_auth is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	portAuthVal, ok := portAuthAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_auth expected to be basetypes.StringValue, was: %T`, portAuthAttribute))
	}

	portNetworkAttribute, ok := attributes["port_network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_network is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	portNetworkVal, ok := portNetworkAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_network expected to be basetypes.StringValue, was: %T`, portNetworkAttribute))
	}

	reauthIntervalAttribute, ok := attributes["reauth_interval"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`reauth_interval is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	reauthIntervalVal, ok := reauthIntervalAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`reauth_interval expected to be basetypes.Int64Value, was: %T`, reauthIntervalAttribute))
	}

	rejectedNetworkAttribute, ok := attributes["rejected_network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rejected_network is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	rejectedNetworkVal, ok := rejectedNetworkAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rejected_network expected to be basetypes.StringValue, was: %T`, rejectedNetworkAttribute))
	}

	resetDefaultWhenAttribute, ok := attributes["reset_default_when"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`reset_default_when is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	resetDefaultWhenVal, ok := resetDefaultWhenAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`reset_default_when expected to be basetypes.StringValue, was: %T`, resetDefaultWhenAttribute))
	}

	rulesAttribute, ok := attributes["rules"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rules is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	rulesVal, ok := rulesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rules expected to be basetypes.ListValue, was: %T`, rulesAttribute))
	}

	speedAttribute, ok := attributes["speed"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`speed is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	speedVal, ok := speedAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`speed expected to be basetypes.StringValue, was: %T`, speedAttribute))
	}

	stormControlAttribute, ok := attributes["storm_control"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`storm_control is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	stormControlVal, ok := stormControlAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`storm_control expected to be basetypes.ObjectValue, was: %T`, stormControlAttribute))
	}

	stpEdgeAttribute, ok := attributes["stp_edge"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`stp_edge is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	stpEdgeVal, ok := stpEdgeAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`stp_edge expected to be basetypes.BoolValue, was: %T`, stpEdgeAttribute))
	}

	voipNetworkAttribute, ok := attributes["voip_network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`voip_network is missing from object`)

		return NewPortUsagesValueUnknown(), diags
	}

	voipNetworkVal, ok := voipNetworkAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`voip_network expected to be basetypes.StringValue, was: %T`, voipNetworkAttribute))
	}

	if diags.HasError() {
		return NewPortUsagesValueUnknown(), diags
	}

	return PortUsagesValue{
		AllNetworks:                              allNetworksVal,
		AllowDhcpd:                               allowDhcpdVal,
		AllowMultipleSupplicants:                 allowMultipleSupplicantsVal,
		BypassAuthWhenServerDown:                 bypassAuthWhenServerDownVal,
		BypassAuthWhenServerDownForUnkonwnClient: bypassAuthWhenServerDownForUnkonwnClientVal,
		Description:                              descriptionVal,
		DisableAutoneg:                           disableAutonegVal,
		Disabled:                                 disabledVal,
		Duplex:                                   duplexVal,
		DynamicVlanNetworks:                      dynamicVlanNetworksVal,
		EnableMacAuth:                            enableMacAuthVal,
		EnableQos:                                enableQosVal,
		GuestNetwork:                             guestNetworkVal,
		InterSwitchLink:                          interSwitchLinkVal,
		MacAuthOnly:                              macAuthOnlyVal,
		MacAuthProtocol:                          macAuthProtocolVal,
		MacLimit:                                 macLimitVal,
		Mode:                                     modeVal,
		Mtu:                                      mtuVal,
		Networks:                                 networksVal,
		PersistMac:                               persistMacVal,
		PoeDisabled:                              poeDisabledVal,
		PortAuth:                                 portAuthVal,
		PortNetwork:                              portNetworkVal,
		ReauthInterval:                           reauthIntervalVal,
		RejectedNetwork:                          rejectedNetworkVal,
		ResetDefaultWhen:                         resetDefaultWhenVal,
		Rules:                                    rulesVal,
		Speed:                                    speedVal,
		StormControl:                             stormControlVal,
		StpEdge:                                  stpEdgeVal,
		VoipNetwork:                              voipNetworkVal,
		state:                                    attr.ValueStateKnown,
	}, diags
}

func NewPortUsagesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PortUsagesValue {
	object, diags := NewPortUsagesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPortUsagesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PortUsagesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPortUsagesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPortUsagesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPortUsagesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPortUsagesValueMust(PortUsagesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PortUsagesType) ValueType(ctx context.Context) attr.Value {
	return PortUsagesValue{}
}

var _ basetypes.ObjectValuable = PortUsagesValue{}

type PortUsagesValue struct {
	AllNetworks                              basetypes.BoolValue   `tfsdk:"all_networks"`
	AllowDhcpd                               basetypes.BoolValue   `tfsdk:"allow_dhcpd"`
	AllowMultipleSupplicants                 basetypes.BoolValue   `tfsdk:"allow_multiple_supplicants"`
	BypassAuthWhenServerDown                 basetypes.BoolValue   `tfsdk:"bypass_auth_when_server_down"`
	BypassAuthWhenServerDownForUnkonwnClient basetypes.BoolValue   `tfsdk:"bypass_auth_when_server_down_for_unkonwn_client"`
	Description                              basetypes.StringValue `tfsdk:"description"`
	DisableAutoneg                           basetypes.BoolValue   `tfsdk:"disable_autoneg"`
	Disabled                                 basetypes.BoolValue   `tfsdk:"disabled"`
	Duplex                                   basetypes.StringValue `tfsdk:"duplex"`
	DynamicVlanNetworks                      basetypes.ListValue   `tfsdk:"dynamic_vlan_networks"`
	EnableMacAuth                            basetypes.BoolValue   `tfsdk:"enable_mac_auth"`
	EnableQos                                basetypes.BoolValue   `tfsdk:"enable_qos"`
	GuestNetwork                             basetypes.StringValue `tfsdk:"guest_network"`
	InterSwitchLink                          basetypes.BoolValue   `tfsdk:"inter_switch_link"`
	MacAuthOnly                              basetypes.BoolValue   `tfsdk:"mac_auth_only"`
	MacAuthProtocol                          basetypes.StringValue `tfsdk:"mac_auth_protocol"`
	MacLimit                                 basetypes.Int64Value  `tfsdk:"mac_limit"`
	Mode                                     basetypes.StringValue `tfsdk:"mode"`
	Mtu                                      basetypes.Int64Value  `tfsdk:"mtu"`
	Networks                                 basetypes.ListValue   `tfsdk:"networks"`
	PersistMac                               basetypes.BoolValue   `tfsdk:"persist_mac"`
	PoeDisabled                              basetypes.BoolValue   `tfsdk:"poe_disabled"`
	PortAuth                                 basetypes.StringValue `tfsdk:"port_auth"`
	PortNetwork                              basetypes.StringValue `tfsdk:"port_network"`
	ReauthInterval                           basetypes.Int64Value  `tfsdk:"reauth_interval"`
	RejectedNetwork                          basetypes.StringValue `tfsdk:"rejected_network"`
	ResetDefaultWhen                         basetypes.StringValue `tfsdk:"reset_default_when"`
	Rules                                    basetypes.ListValue   `tfsdk:"rules"`
	Speed                                    basetypes.StringValue `tfsdk:"speed"`
	StormControl                             basetypes.ObjectValue `tfsdk:"storm_control"`
	StpEdge                                  basetypes.BoolValue   `tfsdk:"stp_edge"`
	VoipNetwork                              basetypes.StringValue `tfsdk:"voip_network"`
	state                                    attr.ValueState
}

func (v PortUsagesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 32)

	var val tftypes.Value
	var err error

	attrTypes["all_networks"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["allow_dhcpd"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["allow_multiple_supplicants"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["bypass_auth_when_server_down"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["bypass_auth_when_server_down_for_unkonwn_client"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["disable_autoneg"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["disabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["duplex"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["dynamic_vlan_networks"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["enable_mac_auth"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["enable_qos"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["guest_network"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["inter_switch_link"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["mac_auth_only"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["mac_auth_protocol"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["mac_limit"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["mode"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["mtu"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["networks"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["persist_mac"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["poe_disabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["port_auth"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["port_network"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["reauth_interval"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["rejected_network"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["reset_default_when"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["rules"] = basetypes.ListType{
		ElemType: RulesValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["speed"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["storm_control"] = basetypes.ObjectType{
		AttrTypes: StormControlValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["stp_edge"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["voip_network"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 32)

		val, err = v.AllNetworks.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["all_networks"] = val

		val, err = v.AllowDhcpd.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["allow_dhcpd"] = val

		val, err = v.AllowMultipleSupplicants.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["allow_multiple_supplicants"] = val

		val, err = v.BypassAuthWhenServerDown.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bypass_auth_when_server_down"] = val

		val, err = v.BypassAuthWhenServerDownForUnkonwnClient.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bypass_auth_when_server_down_for_unkonwn_client"] = val

		val, err = v.Description.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["description"] = val

		val, err = v.DisableAutoneg.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["disable_autoneg"] = val

		val, err = v.Disabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["disabled"] = val

		val, err = v.Duplex.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["duplex"] = val

		val, err = v.DynamicVlanNetworks.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dynamic_vlan_networks"] = val

		val, err = v.EnableMacAuth.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enable_mac_auth"] = val

		val, err = v.EnableQos.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enable_qos"] = val

		val, err = v.GuestNetwork.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["guest_network"] = val

		val, err = v.InterSwitchLink.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["inter_switch_link"] = val

		val, err = v.MacAuthOnly.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mac_auth_only"] = val

		val, err = v.MacAuthProtocol.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mac_auth_protocol"] = val

		val, err = v.MacLimit.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mac_limit"] = val

		val, err = v.Mode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mode"] = val

		val, err = v.Mtu.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mtu"] = val

		val, err = v.Networks.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["networks"] = val

		val, err = v.PersistMac.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["persist_mac"] = val

		val, err = v.PoeDisabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["poe_disabled"] = val

		val, err = v.PortAuth.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port_auth"] = val

		val, err = v.PortNetwork.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port_network"] = val

		val, err = v.ReauthInterval.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["reauth_interval"] = val

		val, err = v.RejectedNetwork.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["rejected_network"] = val

		val, err = v.ResetDefaultWhen.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["reset_default_when"] = val

		val, err = v.Rules.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["rules"] = val

		val, err = v.Speed.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["speed"] = val

		val, err = v.StormControl.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["storm_control"] = val

		val, err = v.StpEdge.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["stp_edge"] = val

		val, err = v.VoipNetwork.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["voip_network"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PortUsagesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PortUsagesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PortUsagesValue) String() string {
	return "PortUsagesValue"
}

func (v PortUsagesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	rules := types.ListValueMust(
		RulesType{
			basetypes.ObjectType{
				AttrTypes: RulesValue{}.AttributeTypes(ctx),
			},
		},
		v.Rules.Elements(),
	)

	if v.Rules.IsNull() {
		rules = types.ListNull(
			RulesType{
				basetypes.ObjectType{
					AttrTypes: RulesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Rules.IsUnknown() {
		rules = types.ListUnknown(
			RulesType{
				basetypes.ObjectType{
					AttrTypes: RulesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var stormControl basetypes.ObjectValue

	if v.StormControl.IsNull() {
		stormControl = types.ObjectNull(
			StormControlValue{}.AttributeTypes(ctx),
		)
	}

	if v.StormControl.IsUnknown() {
		stormControl = types.ObjectUnknown(
			StormControlValue{}.AttributeTypes(ctx),
		)
	}

	if !v.StormControl.IsNull() && !v.StormControl.IsUnknown() {
		stormControl = types.ObjectValueMust(
			StormControlValue{}.AttributeTypes(ctx),
			v.StormControl.Attributes(),
		)
	}

	dynamicVlanNetworksVal, d := types.ListValue(types.StringType, v.DynamicVlanNetworks.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"all_networks":                                    basetypes.BoolType{},
			"allow_dhcpd":                                     basetypes.BoolType{},
			"allow_multiple_supplicants":                      basetypes.BoolType{},
			"bypass_auth_when_server_down":                    basetypes.BoolType{},
			"bypass_auth_when_server_down_for_unkonwn_client": basetypes.BoolType{},
			"description":                                     basetypes.StringType{},
			"disable_autoneg":                                 basetypes.BoolType{},
			"disabled":                                        basetypes.BoolType{},
			"duplex":                                          basetypes.StringType{},
			"dynamic_vlan_networks": basetypes.ListType{
				ElemType: types.StringType,
			},
			"enable_mac_auth":   basetypes.BoolType{},
			"enable_qos":        basetypes.BoolType{},
			"guest_network":     basetypes.StringType{},
			"inter_switch_link": basetypes.BoolType{},
			"mac_auth_only":     basetypes.BoolType{},
			"mac_auth_protocol": basetypes.StringType{},
			"mac_limit":         basetypes.Int64Type{},
			"mode":              basetypes.StringType{},
			"mtu":               basetypes.Int64Type{},
			"networks": basetypes.ListType{
				ElemType: types.StringType,
			},
			"persist_mac":        basetypes.BoolType{},
			"poe_disabled":       basetypes.BoolType{},
			"port_auth":          basetypes.StringType{},
			"port_network":       basetypes.StringType{},
			"reauth_interval":    basetypes.Int64Type{},
			"rejected_network":   basetypes.StringType{},
			"reset_default_when": basetypes.StringType{},
			"rules": basetypes.ListType{
				ElemType: RulesValue{}.Type(ctx),
			},
			"speed": basetypes.StringType{},
			"storm_control": basetypes.ObjectType{
				AttrTypes: StormControlValue{}.AttributeTypes(ctx),
			},
			"stp_edge":     basetypes.BoolType{},
			"voip_network": basetypes.StringType{},
		}), diags
	}

	networksVal, d := types.ListValue(types.StringType, v.Networks.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"all_networks":                                    basetypes.BoolType{},
			"allow_dhcpd":                                     basetypes.BoolType{},
			"allow_multiple_supplicants":                      basetypes.BoolType{},
			"bypass_auth_when_server_down":                    basetypes.BoolType{},
			"bypass_auth_when_server_down_for_unkonwn_client": basetypes.BoolType{},
			"description":                                     basetypes.StringType{},
			"disable_autoneg":                                 basetypes.BoolType{},
			"disabled":                                        basetypes.BoolType{},
			"duplex":                                          basetypes.StringType{},
			"dynamic_vlan_networks": basetypes.ListType{
				ElemType: types.StringType,
			},
			"enable_mac_auth":   basetypes.BoolType{},
			"enable_qos":        basetypes.BoolType{},
			"guest_network":     basetypes.StringType{},
			"inter_switch_link": basetypes.BoolType{},
			"mac_auth_only":     basetypes.BoolType{},
			"mac_auth_protocol": basetypes.StringType{},
			"mac_limit":         basetypes.Int64Type{},
			"mode":              basetypes.StringType{},
			"mtu":               basetypes.Int64Type{},
			"networks": basetypes.ListType{
				ElemType: types.StringType,
			},
			"persist_mac":        basetypes.BoolType{},
			"poe_disabled":       basetypes.BoolType{},
			"port_auth":          basetypes.StringType{},
			"port_network":       basetypes.StringType{},
			"reauth_interval":    basetypes.Int64Type{},
			"rejected_network":   basetypes.StringType{},
			"reset_default_when": basetypes.StringType{},
			"rules": basetypes.ListType{
				ElemType: RulesValue{}.Type(ctx),
			},
			"speed": basetypes.StringType{},
			"storm_control": basetypes.ObjectType{
				AttrTypes: StormControlValue{}.AttributeTypes(ctx),
			},
			"stp_edge":     basetypes.BoolType{},
			"voip_network": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"all_networks":                                    basetypes.BoolType{},
		"allow_dhcpd":                                     basetypes.BoolType{},
		"allow_multiple_supplicants":                      basetypes.BoolType{},
		"bypass_auth_when_server_down":                    basetypes.BoolType{},
		"bypass_auth_when_server_down_for_unkonwn_client": basetypes.BoolType{},
		"description":                                     basetypes.StringType{},
		"disable_autoneg":                                 basetypes.BoolType{},
		"disabled":                                        basetypes.BoolType{},
		"duplex":                                          basetypes.StringType{},
		"dynamic_vlan_networks": basetypes.ListType{
			ElemType: types.StringType,
		},
		"enable_mac_auth":   basetypes.BoolType{},
		"enable_qos":        basetypes.BoolType{},
		"guest_network":     basetypes.StringType{},
		"inter_switch_link": basetypes.BoolType{},
		"mac_auth_only":     basetypes.BoolType{},
		"mac_auth_protocol": basetypes.StringType{},
		"mac_limit":         basetypes.Int64Type{},
		"mode":              basetypes.StringType{},
		"mtu":               basetypes.Int64Type{},
		"networks": basetypes.ListType{
			ElemType: types.StringType,
		},
		"persist_mac":        basetypes.BoolType{},
		"poe_disabled":       basetypes.BoolType{},
		"port_auth":          basetypes.StringType{},
		"port_network":       basetypes.StringType{},
		"reauth_interval":    basetypes.Int64Type{},
		"rejected_network":   basetypes.StringType{},
		"reset_default_when": basetypes.StringType{},
		"rules": basetypes.ListType{
			ElemType: RulesValue{}.Type(ctx),
		},
		"speed": basetypes.StringType{},
		"storm_control": basetypes.ObjectType{
			AttrTypes: StormControlValue{}.AttributeTypes(ctx),
		},
		"stp_edge":     basetypes.BoolType{},
		"voip_network": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"all_networks":                                    v.AllNetworks,
			"allow_dhcpd":                                     v.AllowDhcpd,
			"allow_multiple_supplicants":                      v.AllowMultipleSupplicants,
			"bypass_auth_when_server_down":                    v.BypassAuthWhenServerDown,
			"bypass_auth_when_server_down_for_unkonwn_client": v.BypassAuthWhenServerDownForUnkonwnClient,
			"description":                                     v.Description,
			"disable_autoneg":                                 v.DisableAutoneg,
			"disabled":                                        v.Disabled,
			"duplex":                                          v.Duplex,
			"dynamic_vlan_networks":                           dynamicVlanNetworksVal,
			"enable_mac_auth":                                 v.EnableMacAuth,
			"enable_qos":                                      v.EnableQos,
			"guest_network":                                   v.GuestNetwork,
			"inter_switch_link":                               v.InterSwitchLink,
			"mac_auth_only":                                   v.MacAuthOnly,
			"mac_auth_protocol":                               v.MacAuthProtocol,
			"mac_limit":                                       v.MacLimit,
			"mode":                                            v.Mode,
			"mtu":                                             v.Mtu,
			"networks":                                        networksVal,
			"persist_mac":                                     v.PersistMac,
			"poe_disabled":                                    v.PoeDisabled,
			"port_auth":                                       v.PortAuth,
			"port_network":                                    v.PortNetwork,
			"reauth_interval":                                 v.ReauthInterval,
			"rejected_network":                                v.RejectedNetwork,
			"reset_default_when":                              v.ResetDefaultWhen,
			"rules":                                           rules,
			"speed":                                           v.Speed,
			"storm_control":                                   stormControl,
			"stp_edge":                                        v.StpEdge,
			"voip_network":                                    v.VoipNetwork,
		})

	return objVal, diags
}

func (v PortUsagesValue) Equal(o attr.Value) bool {
	other, ok := o.(PortUsagesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AllNetworks.Equal(other.AllNetworks) {
		return false
	}

	if !v.AllowDhcpd.Equal(other.AllowDhcpd) {
		return false
	}

	if !v.AllowMultipleSupplicants.Equal(other.AllowMultipleSupplicants) {
		return false
	}

	if !v.BypassAuthWhenServerDown.Equal(other.BypassAuthWhenServerDown) {
		return false
	}

	if !v.BypassAuthWhenServerDownForUnkonwnClient.Equal(other.BypassAuthWhenServerDownForUnkonwnClient) {
		return false
	}

	if !v.Description.Equal(other.Description) {
		return false
	}

	if !v.DisableAutoneg.Equal(other.DisableAutoneg) {
		return false
	}

	if !v.Disabled.Equal(other.Disabled) {
		return false
	}

	if !v.Duplex.Equal(other.Duplex) {
		return false
	}

	if !v.DynamicVlanNetworks.Equal(other.DynamicVlanNetworks) {
		return false
	}

	if !v.EnableMacAuth.Equal(other.EnableMacAuth) {
		return false
	}

	if !v.EnableQos.Equal(other.EnableQos) {
		return false
	}

	if !v.GuestNetwork.Equal(other.GuestNetwork) {
		return false
	}

	if !v.InterSwitchLink.Equal(other.InterSwitchLink) {
		return false
	}

	if !v.MacAuthOnly.Equal(other.MacAuthOnly) {
		return false
	}

	if !v.MacAuthProtocol.Equal(other.MacAuthProtocol) {
		return false
	}

	if !v.MacLimit.Equal(other.MacLimit) {
		return false
	}

	if !v.Mode.Equal(other.Mode) {
		return false
	}

	if !v.Mtu.Equal(other.Mtu) {
		return false
	}

	if !v.Networks.Equal(other.Networks) {
		return false
	}

	if !v.PersistMac.Equal(other.PersistMac) {
		return false
	}

	if !v.PoeDisabled.Equal(other.PoeDisabled) {
		return false
	}

	if !v.PortAuth.Equal(other.PortAuth) {
		return false
	}

	if !v.PortNetwork.Equal(other.PortNetwork) {
		return false
	}

	if !v.ReauthInterval.Equal(other.ReauthInterval) {
		return false
	}

	if !v.RejectedNetwork.Equal(other.RejectedNetwork) {
		return false
	}

	if !v.ResetDefaultWhen.Equal(other.ResetDefaultWhen) {
		return false
	}

	if !v.Rules.Equal(other.Rules) {
		return false
	}

	if !v.Speed.Equal(other.Speed) {
		return false
	}

	if !v.StormControl.Equal(other.StormControl) {
		return false
	}

	if !v.StpEdge.Equal(other.StpEdge) {
		return false
	}

	if !v.VoipNetwork.Equal(other.VoipNetwork) {
		return false
	}

	return true
}

func (v PortUsagesValue) Type(ctx context.Context) attr.Type {
	return PortUsagesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PortUsagesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"all_networks":                                    basetypes.BoolType{},
		"allow_dhcpd":                                     basetypes.BoolType{},
		"allow_multiple_supplicants":                      basetypes.BoolType{},
		"bypass_auth_when_server_down":                    basetypes.BoolType{},
		"bypass_auth_when_server_down_for_unkonwn_client": basetypes.BoolType{},
		"description":                                     basetypes.StringType{},
		"disable_autoneg":                                 basetypes.BoolType{},
		"disabled":                                        basetypes.BoolType{},
		"duplex":                                          basetypes.StringType{},
		"dynamic_vlan_networks": basetypes.ListType{
			ElemType: types.StringType,
		},
		"enable_mac_auth":   basetypes.BoolType{},
		"enable_qos":        basetypes.BoolType{},
		"guest_network":     basetypes.StringType{},
		"inter_switch_link": basetypes.BoolType{},
		"mac_auth_only":     basetypes.BoolType{},
		"mac_auth_protocol": basetypes.StringType{},
		"mac_limit":         basetypes.Int64Type{},
		"mode":              basetypes.StringType{},
		"mtu":               basetypes.Int64Type{},
		"networks": basetypes.ListType{
			ElemType: types.StringType,
		},
		"persist_mac":        basetypes.BoolType{},
		"poe_disabled":       basetypes.BoolType{},
		"port_auth":          basetypes.StringType{},
		"port_network":       basetypes.StringType{},
		"reauth_interval":    basetypes.Int64Type{},
		"rejected_network":   basetypes.StringType{},
		"reset_default_when": basetypes.StringType{},
		"rules": basetypes.ListType{
			ElemType: RulesValue{}.Type(ctx),
		},
		"speed": basetypes.StringType{},
		"storm_control": basetypes.ObjectType{
			AttrTypes: StormControlValue{}.AttributeTypes(ctx),
		},
		"stp_edge":     basetypes.BoolType{},
		"voip_network": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = RulesType{}

type RulesType struct {
	basetypes.ObjectType
}

func (t RulesType) Equal(o attr.Type) bool {
	other, ok := o.(RulesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t RulesType) String() string {
	return "RulesType"
}

func (t RulesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	equalsAttribute, ok := attributes["equals"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`equals is missing from object`)

		return nil, diags
	}

	equalsVal, ok := equalsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`equals expected to be basetypes.StringValue, was: %T`, equalsAttribute))
	}

	equalsAnyAttribute, ok := attributes["equals_any"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`equals_any is missing from object`)

		return nil, diags
	}

	equalsAnyVal, ok := equalsAnyAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`equals_any expected to be basetypes.ListValue, was: %T`, equalsAnyAttribute))
	}

	expressionAttribute, ok := attributes["expression"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`expression is missing from object`)

		return nil, diags
	}

	expressionVal, ok := expressionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`expression expected to be basetypes.StringValue, was: %T`, expressionAttribute))
	}

	srcAttribute, ok := attributes["src"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`src is missing from object`)

		return nil, diags
	}

	srcVal, ok := srcAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`src expected to be basetypes.StringValue, was: %T`, srcAttribute))
	}

	usageAttribute, ok := attributes["usage"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`usage is missing from object`)

		return nil, diags
	}

	usageVal, ok := usageAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`usage expected to be basetypes.StringValue, was: %T`, usageAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return RulesValue{
		Equals:     equalsVal,
		EqualsAny:  equalsAnyVal,
		Expression: expressionVal,
		Src:        srcVal,
		Usage:      usageVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewRulesValueNull() RulesValue {
	return RulesValue{
		state: attr.ValueStateNull,
	}
}

func NewRulesValueUnknown() RulesValue {
	return RulesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewRulesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (RulesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing RulesValue Attribute Value",
				"While creating a RulesValue value, a missing attribute value was detected. "+
					"A RulesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RulesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid RulesValue Attribute Type",
				"While creating a RulesValue value, an invalid attribute value was detected. "+
					"A RulesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RulesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("RulesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra RulesValue Attribute Value",
				"While creating a RulesValue value, an extra attribute value was detected. "+
					"A RulesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra RulesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewRulesValueUnknown(), diags
	}

	equalsAttribute, ok := attributes["equals"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`equals is missing from object`)

		return NewRulesValueUnknown(), diags
	}

	equalsVal, ok := equalsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`equals expected to be basetypes.StringValue, was: %T`, equalsAttribute))
	}

	equalsAnyAttribute, ok := attributes["equals_any"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`equals_any is missing from object`)

		return NewRulesValueUnknown(), diags
	}

	equalsAnyVal, ok := equalsAnyAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`equals_any expected to be basetypes.ListValue, was: %T`, equalsAnyAttribute))
	}

	expressionAttribute, ok := attributes["expression"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`expression is missing from object`)

		return NewRulesValueUnknown(), diags
	}

	expressionVal, ok := expressionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`expression expected to be basetypes.StringValue, was: %T`, expressionAttribute))
	}

	srcAttribute, ok := attributes["src"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`src is missing from object`)

		return NewRulesValueUnknown(), diags
	}

	srcVal, ok := srcAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`src expected to be basetypes.StringValue, was: %T`, srcAttribute))
	}

	usageAttribute, ok := attributes["usage"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`usage is missing from object`)

		return NewRulesValueUnknown(), diags
	}

	usageVal, ok := usageAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`usage expected to be basetypes.StringValue, was: %T`, usageAttribute))
	}

	if diags.HasError() {
		return NewRulesValueUnknown(), diags
	}

	return RulesValue{
		Equals:     equalsVal,
		EqualsAny:  equalsAnyVal,
		Expression: expressionVal,
		Src:        srcVal,
		Usage:      usageVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewRulesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) RulesValue {
	object, diags := NewRulesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewRulesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t RulesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewRulesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewRulesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewRulesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewRulesValueMust(RulesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t RulesType) ValueType(ctx context.Context) attr.Value {
	return RulesValue{}
}

var _ basetypes.ObjectValuable = RulesValue{}

type RulesValue struct {
	Equals     basetypes.StringValue `tfsdk:"equals"`
	EqualsAny  basetypes.ListValue   `tfsdk:"equals_any"`
	Expression basetypes.StringValue `tfsdk:"expression"`
	Src        basetypes.StringValue `tfsdk:"src"`
	Usage      basetypes.StringValue `tfsdk:"usage"`
	state      attr.ValueState
}

func (v RulesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["equals"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["equals_any"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["expression"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["src"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["usage"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.Equals.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["equals"] = val

		val, err = v.EqualsAny.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["equals_any"] = val

		val, err = v.Expression.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["expression"] = val

		val, err = v.Src.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["src"] = val

		val, err = v.Usage.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["usage"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v RulesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v RulesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v RulesValue) String() string {
	return "RulesValue"
}

func (v RulesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	equalsAnyVal, d := types.ListValue(types.StringType, v.EqualsAny.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"equals": basetypes.StringType{},
			"equals_any": basetypes.ListType{
				ElemType: types.StringType,
			},
			"expression": basetypes.StringType{},
			"src":        basetypes.StringType{},
			"usage":      basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"equals": basetypes.StringType{},
		"equals_any": basetypes.ListType{
			ElemType: types.StringType,
		},
		"expression": basetypes.StringType{},
		"src":        basetypes.StringType{},
		"usage":      basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"equals":     v.Equals,
			"equals_any": equalsAnyVal,
			"expression": v.Expression,
			"src":        v.Src,
			"usage":      v.Usage,
		})

	return objVal, diags
}

func (v RulesValue) Equal(o attr.Value) bool {
	other, ok := o.(RulesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Equals.Equal(other.Equals) {
		return false
	}

	if !v.EqualsAny.Equal(other.EqualsAny) {
		return false
	}

	if !v.Expression.Equal(other.Expression) {
		return false
	}

	if !v.Src.Equal(other.Src) {
		return false
	}

	if !v.Usage.Equal(other.Usage) {
		return false
	}

	return true
}

func (v RulesValue) Type(ctx context.Context) attr.Type {
	return RulesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v RulesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"equals": basetypes.StringType{},
		"equals_any": basetypes.ListType{
			ElemType: types.StringType,
		},
		"expression": basetypes.StringType{},
		"src":        basetypes.StringType{},
		"usage":      basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = StormControlType{}

type StormControlType struct {
	basetypes.ObjectType
}

func (t StormControlType) Equal(o attr.Type) bool {
	other, ok := o.(StormControlType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t StormControlType) String() string {
	return "StormControlType"
}

func (t StormControlType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	noBroadcastAttribute, ok := attributes["no_broadcast"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`no_broadcast is missing from object`)

		return nil, diags
	}

	noBroadcastVal, ok := noBroadcastAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`no_broadcast expected to be basetypes.BoolValue, was: %T`, noBroadcastAttribute))
	}

	noMulticastAttribute, ok := attributes["no_multicast"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`no_multicast is missing from object`)

		return nil, diags
	}

	noMulticastVal, ok := noMulticastAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`no_multicast expected to be basetypes.BoolValue, was: %T`, noMulticastAttribute))
	}

	noRegisteredMulticastAttribute, ok := attributes["no_registered_multicast"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`no_registered_multicast is missing from object`)

		return nil, diags
	}

	noRegisteredMulticastVal, ok := noRegisteredMulticastAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`no_registered_multicast expected to be basetypes.BoolValue, was: %T`, noRegisteredMulticastAttribute))
	}

	noUnknownUnicastAttribute, ok := attributes["no_unknown_unicast"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`no_unknown_unicast is missing from object`)

		return nil, diags
	}

	noUnknownUnicastVal, ok := noUnknownUnicastAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`no_unknown_unicast expected to be basetypes.BoolValue, was: %T`, noUnknownUnicastAttribute))
	}

	percentageAttribute, ok := attributes["percentage"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`percentage is missing from object`)

		return nil, diags
	}

	percentageVal, ok := percentageAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`percentage expected to be basetypes.Int64Value, was: %T`, percentageAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return StormControlValue{
		NoBroadcast:           noBroadcastVal,
		NoMulticast:           noMulticastVal,
		NoRegisteredMulticast: noRegisteredMulticastVal,
		NoUnknownUnicast:      noUnknownUnicastVal,
		Percentage:            percentageVal,
		state:                 attr.ValueStateKnown,
	}, diags
}

func NewStormControlValueNull() StormControlValue {
	return StormControlValue{
		state: attr.ValueStateNull,
	}
}

func NewStormControlValueUnknown() StormControlValue {
	return StormControlValue{
		state: attr.ValueStateUnknown,
	}
}

func NewStormControlValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (StormControlValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing StormControlValue Attribute Value",
				"While creating a StormControlValue value, a missing attribute value was detected. "+
					"A StormControlValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StormControlValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid StormControlValue Attribute Type",
				"While creating a StormControlValue value, an invalid attribute value was detected. "+
					"A StormControlValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StormControlValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("StormControlValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra StormControlValue Attribute Value",
				"While creating a StormControlValue value, an extra attribute value was detected. "+
					"A StormControlValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra StormControlValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewStormControlValueUnknown(), diags
	}

	noBroadcastAttribute, ok := attributes["no_broadcast"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`no_broadcast is missing from object`)

		return NewStormControlValueUnknown(), diags
	}

	noBroadcastVal, ok := noBroadcastAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`no_broadcast expected to be basetypes.BoolValue, was: %T`, noBroadcastAttribute))
	}

	noMulticastAttribute, ok := attributes["no_multicast"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`no_multicast is missing from object`)

		return NewStormControlValueUnknown(), diags
	}

	noMulticastVal, ok := noMulticastAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`no_multicast expected to be basetypes.BoolValue, was: %T`, noMulticastAttribute))
	}

	noRegisteredMulticastAttribute, ok := attributes["no_registered_multicast"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`no_registered_multicast is missing from object`)

		return NewStormControlValueUnknown(), diags
	}

	noRegisteredMulticastVal, ok := noRegisteredMulticastAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`no_registered_multicast expected to be basetypes.BoolValue, was: %T`, noRegisteredMulticastAttribute))
	}

	noUnknownUnicastAttribute, ok := attributes["no_unknown_unicast"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`no_unknown_unicast is missing from object`)

		return NewStormControlValueUnknown(), diags
	}

	noUnknownUnicastVal, ok := noUnknownUnicastAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`no_unknown_unicast expected to be basetypes.BoolValue, was: %T`, noUnknownUnicastAttribute))
	}

	percentageAttribute, ok := attributes["percentage"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`percentage is missing from object`)

		return NewStormControlValueUnknown(), diags
	}

	percentageVal, ok := percentageAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`percentage expected to be basetypes.Int64Value, was: %T`, percentageAttribute))
	}

	if diags.HasError() {
		return NewStormControlValueUnknown(), diags
	}

	return StormControlValue{
		NoBroadcast:           noBroadcastVal,
		NoMulticast:           noMulticastVal,
		NoRegisteredMulticast: noRegisteredMulticastVal,
		NoUnknownUnicast:      noUnknownUnicastVal,
		Percentage:            percentageVal,
		state:                 attr.ValueStateKnown,
	}, diags
}

func NewStormControlValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) StormControlValue {
	object, diags := NewStormControlValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewStormControlValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t StormControlType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewStormControlValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewStormControlValueUnknown(), nil
	}

	if in.IsNull() {
		return NewStormControlValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewStormControlValueMust(StormControlValue{}.AttributeTypes(ctx), attributes), nil
}

func (t StormControlType) ValueType(ctx context.Context) attr.Value {
	return StormControlValue{}
}

var _ basetypes.ObjectValuable = StormControlValue{}

type StormControlValue struct {
	NoBroadcast           basetypes.BoolValue  `tfsdk:"no_broadcast"`
	NoMulticast           basetypes.BoolValue  `tfsdk:"no_multicast"`
	NoRegisteredMulticast basetypes.BoolValue  `tfsdk:"no_registered_multicast"`
	NoUnknownUnicast      basetypes.BoolValue  `tfsdk:"no_unknown_unicast"`
	Percentage            basetypes.Int64Value `tfsdk:"percentage"`
	state                 attr.ValueState
}

func (v StormControlValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["no_broadcast"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["no_multicast"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["no_registered_multicast"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["no_unknown_unicast"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["percentage"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.NoBroadcast.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["no_broadcast"] = val

		val, err = v.NoMulticast.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["no_multicast"] = val

		val, err = v.NoRegisteredMulticast.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["no_registered_multicast"] = val

		val, err = v.NoUnknownUnicast.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["no_unknown_unicast"] = val

		val, err = v.Percentage.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["percentage"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v StormControlValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v StormControlValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v StormControlValue) String() string {
	return "StormControlValue"
}

func (v StormControlValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"no_broadcast":            basetypes.BoolType{},
		"no_multicast":            basetypes.BoolType{},
		"no_registered_multicast": basetypes.BoolType{},
		"no_unknown_unicast":      basetypes.BoolType{},
		"percentage":              basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"no_broadcast":            v.NoBroadcast,
			"no_multicast":            v.NoMulticast,
			"no_registered_multicast": v.NoRegisteredMulticast,
			"no_unknown_unicast":      v.NoUnknownUnicast,
			"percentage":              v.Percentage,
		})

	return objVal, diags
}

func (v StormControlValue) Equal(o attr.Value) bool {
	other, ok := o.(StormControlValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.NoBroadcast.Equal(other.NoBroadcast) {
		return false
	}

	if !v.NoMulticast.Equal(other.NoMulticast) {
		return false
	}

	if !v.NoRegisteredMulticast.Equal(other.NoRegisteredMulticast) {
		return false
	}

	if !v.NoUnknownUnicast.Equal(other.NoUnknownUnicast) {
		return false
	}

	if !v.Percentage.Equal(other.Percentage) {
		return false
	}

	return true
}

func (v StormControlValue) Type(ctx context.Context) attr.Type {
	return StormControlType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v StormControlValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"no_broadcast":            basetypes.BoolType{},
		"no_multicast":            basetypes.BoolType{},
		"no_registered_multicast": basetypes.BoolType{},
		"no_unknown_unicast":      basetypes.BoolType{},
		"percentage":              basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = RadiusConfigType{}

type RadiusConfigType struct {
	basetypes.ObjectType
}

func (t RadiusConfigType) Equal(o attr.Type) bool {
	other, ok := o.(RadiusConfigType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t RadiusConfigType) String() string {
	return "RadiusConfigType"
}

func (t RadiusConfigType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	acctInterimIntervalAttribute, ok := attributes["acct_interim_interval"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`acct_interim_interval is missing from object`)

		return nil, diags
	}

	acctInterimIntervalVal, ok := acctInterimIntervalAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`acct_interim_interval expected to be basetypes.Int64Value, was: %T`, acctInterimIntervalAttribute))
	}

	acctServersAttribute, ok := attributes["acct_servers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`acct_servers is missing from object`)

		return nil, diags
	}

	acctServersVal, ok := acctServersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`acct_servers expected to be basetypes.ListValue, was: %T`, acctServersAttribute))
	}

	authServersAttribute, ok := attributes["auth_servers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auth_servers is missing from object`)

		return nil, diags
	}

	authServersVal, ok := authServersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auth_servers expected to be basetypes.ListValue, was: %T`, authServersAttribute))
	}

	authServersRetriesAttribute, ok := attributes["auth_servers_retries"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auth_servers_retries is missing from object`)

		return nil, diags
	}

	authServersRetriesVal, ok := authServersRetriesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auth_servers_retries expected to be basetypes.Int64Value, was: %T`, authServersRetriesAttribute))
	}

	authServersTimeoutAttribute, ok := attributes["auth_servers_timeout"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auth_servers_timeout is missing from object`)

		return nil, diags
	}

	authServersTimeoutVal, ok := authServersTimeoutAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auth_servers_timeout expected to be basetypes.Int64Value, was: %T`, authServersTimeoutAttribute))
	}

	coaEnabledAttribute, ok := attributes["coa_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`coa_enabled is missing from object`)

		return nil, diags
	}

	coaEnabledVal, ok := coaEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`coa_enabled expected to be basetypes.BoolValue, was: %T`, coaEnabledAttribute))
	}

	coaPortAttribute, ok := attributes["coa_port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`coa_port is missing from object`)

		return nil, diags
	}

	coaPortVal, ok := coaPortAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`coa_port expected to be basetypes.Int64Value, was: %T`, coaPortAttribute))
	}

	networkAttribute, ok := attributes["network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`network is missing from object`)

		return nil, diags
	}

	networkVal, ok := networkAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`network expected to be basetypes.StringValue, was: %T`, networkAttribute))
	}

	sourceIpAttribute, ok := attributes["source_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`source_ip is missing from object`)

		return nil, diags
	}

	sourceIpVal, ok := sourceIpAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`source_ip expected to be basetypes.StringValue, was: %T`, sourceIpAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return RadiusConfigValue{
		AcctInterimInterval: acctInterimIntervalVal,
		AcctServers:         acctServersVal,
		AuthServers:         authServersVal,
		AuthServersRetries:  authServersRetriesVal,
		AuthServersTimeout:  authServersTimeoutVal,
		CoaEnabled:          coaEnabledVal,
		CoaPort:             coaPortVal,
		Network:             networkVal,
		SourceIp:            sourceIpVal,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewRadiusConfigValueNull() RadiusConfigValue {
	return RadiusConfigValue{
		state: attr.ValueStateNull,
	}
}

func NewRadiusConfigValueUnknown() RadiusConfigValue {
	return RadiusConfigValue{
		state: attr.ValueStateUnknown,
	}
}

func NewRadiusConfigValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (RadiusConfigValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing RadiusConfigValue Attribute Value",
				"While creating a RadiusConfigValue value, a missing attribute value was detected. "+
					"A RadiusConfigValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RadiusConfigValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid RadiusConfigValue Attribute Type",
				"While creating a RadiusConfigValue value, an invalid attribute value was detected. "+
					"A RadiusConfigValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RadiusConfigValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("RadiusConfigValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra RadiusConfigValue Attribute Value",
				"While creating a RadiusConfigValue value, an extra attribute value was detected. "+
					"A RadiusConfigValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra RadiusConfigValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewRadiusConfigValueUnknown(), diags
	}

	acctInterimIntervalAttribute, ok := attributes["acct_interim_interval"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`acct_interim_interval is missing from object`)

		return NewRadiusConfigValueUnknown(), diags
	}

	acctInterimIntervalVal, ok := acctInterimIntervalAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`acct_interim_interval expected to be basetypes.Int64Value, was: %T`, acctInterimIntervalAttribute))
	}

	acctServersAttribute, ok := attributes["acct_servers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`acct_servers is missing from object`)

		return NewRadiusConfigValueUnknown(), diags
	}

	acctServersVal, ok := acctServersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`acct_servers expected to be basetypes.ListValue, was: %T`, acctServersAttribute))
	}

	authServersAttribute, ok := attributes["auth_servers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auth_servers is missing from object`)

		return NewRadiusConfigValueUnknown(), diags
	}

	authServersVal, ok := authServersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auth_servers expected to be basetypes.ListValue, was: %T`, authServersAttribute))
	}

	authServersRetriesAttribute, ok := attributes["auth_servers_retries"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auth_servers_retries is missing from object`)

		return NewRadiusConfigValueUnknown(), diags
	}

	authServersRetriesVal, ok := authServersRetriesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auth_servers_retries expected to be basetypes.Int64Value, was: %T`, authServersRetriesAttribute))
	}

	authServersTimeoutAttribute, ok := attributes["auth_servers_timeout"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auth_servers_timeout is missing from object`)

		return NewRadiusConfigValueUnknown(), diags
	}

	authServersTimeoutVal, ok := authServersTimeoutAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auth_servers_timeout expected to be basetypes.Int64Value, was: %T`, authServersTimeoutAttribute))
	}

	coaEnabledAttribute, ok := attributes["coa_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`coa_enabled is missing from object`)

		return NewRadiusConfigValueUnknown(), diags
	}

	coaEnabledVal, ok := coaEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`coa_enabled expected to be basetypes.BoolValue, was: %T`, coaEnabledAttribute))
	}

	coaPortAttribute, ok := attributes["coa_port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`coa_port is missing from object`)

		return NewRadiusConfigValueUnknown(), diags
	}

	coaPortVal, ok := coaPortAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`coa_port expected to be basetypes.Int64Value, was: %T`, coaPortAttribute))
	}

	networkAttribute, ok := attributes["network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`network is missing from object`)

		return NewRadiusConfigValueUnknown(), diags
	}

	networkVal, ok := networkAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`network expected to be basetypes.StringValue, was: %T`, networkAttribute))
	}

	sourceIpAttribute, ok := attributes["source_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`source_ip is missing from object`)

		return NewRadiusConfigValueUnknown(), diags
	}

	sourceIpVal, ok := sourceIpAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`source_ip expected to be basetypes.StringValue, was: %T`, sourceIpAttribute))
	}

	if diags.HasError() {
		return NewRadiusConfigValueUnknown(), diags
	}

	return RadiusConfigValue{
		AcctInterimInterval: acctInterimIntervalVal,
		AcctServers:         acctServersVal,
		AuthServers:         authServersVal,
		AuthServersRetries:  authServersRetriesVal,
		AuthServersTimeout:  authServersTimeoutVal,
		CoaEnabled:          coaEnabledVal,
		CoaPort:             coaPortVal,
		Network:             networkVal,
		SourceIp:            sourceIpVal,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewRadiusConfigValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) RadiusConfigValue {
	object, diags := NewRadiusConfigValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewRadiusConfigValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t RadiusConfigType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewRadiusConfigValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewRadiusConfigValueUnknown(), nil
	}

	if in.IsNull() {
		return NewRadiusConfigValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewRadiusConfigValueMust(RadiusConfigValue{}.AttributeTypes(ctx), attributes), nil
}

func (t RadiusConfigType) ValueType(ctx context.Context) attr.Value {
	return RadiusConfigValue{}
}

var _ basetypes.ObjectValuable = RadiusConfigValue{}

type RadiusConfigValue struct {
	AcctInterimInterval basetypes.Int64Value  `tfsdk:"acct_interim_interval"`
	AcctServers         basetypes.ListValue   `tfsdk:"acct_servers"`
	AuthServers         basetypes.ListValue   `tfsdk:"auth_servers"`
	AuthServersRetries  basetypes.Int64Value  `tfsdk:"auth_servers_retries"`
	AuthServersTimeout  basetypes.Int64Value  `tfsdk:"auth_servers_timeout"`
	CoaEnabled          basetypes.BoolValue   `tfsdk:"coa_enabled"`
	CoaPort             basetypes.Int64Value  `tfsdk:"coa_port"`
	Network             basetypes.StringValue `tfsdk:"network"`
	SourceIp            basetypes.StringValue `tfsdk:"source_ip"`
	state               attr.ValueState
}

func (v RadiusConfigValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 9)

	var val tftypes.Value
	var err error

	attrTypes["acct_interim_interval"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["acct_servers"] = basetypes.ListType{
		ElemType: AcctServersValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["auth_servers"] = basetypes.ListType{
		ElemType: AuthServersValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["auth_servers_retries"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["auth_servers_timeout"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["coa_enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["coa_port"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["network"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["source_ip"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 9)

		val, err = v.AcctInterimInterval.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["acct_interim_interval"] = val

		val, err = v.AcctServers.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["acct_servers"] = val

		val, err = v.AuthServers.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["auth_servers"] = val

		val, err = v.AuthServersRetries.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["auth_servers_retries"] = val

		val, err = v.AuthServersTimeout.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["auth_servers_timeout"] = val

		val, err = v.CoaEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["coa_enabled"] = val

		val, err = v.CoaPort.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["coa_port"] = val

		val, err = v.Network.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["network"] = val

		val, err = v.SourceIp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["source_ip"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v RadiusConfigValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v RadiusConfigValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v RadiusConfigValue) String() string {
	return "RadiusConfigValue"
}

func (v RadiusConfigValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	acctServers := types.ListValueMust(
		AcctServersType{
			basetypes.ObjectType{
				AttrTypes: AcctServersValue{}.AttributeTypes(ctx),
			},
		},
		v.AcctServers.Elements(),
	)

	if v.AcctServers.IsNull() {
		acctServers = types.ListNull(
			AcctServersType{
				basetypes.ObjectType{
					AttrTypes: AcctServersValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.AcctServers.IsUnknown() {
		acctServers = types.ListUnknown(
			AcctServersType{
				basetypes.ObjectType{
					AttrTypes: AcctServersValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	authServers := types.ListValueMust(
		AuthServersType{
			basetypes.ObjectType{
				AttrTypes: AuthServersValue{}.AttributeTypes(ctx),
			},
		},
		v.AuthServers.Elements(),
	)

	if v.AuthServers.IsNull() {
		authServers = types.ListNull(
			AuthServersType{
				basetypes.ObjectType{
					AttrTypes: AuthServersValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.AuthServers.IsUnknown() {
		authServers = types.ListUnknown(
			AuthServersType{
				basetypes.ObjectType{
					AttrTypes: AuthServersValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"acct_interim_interval": basetypes.Int64Type{},
		"acct_servers": basetypes.ListType{
			ElemType: AcctServersValue{}.Type(ctx),
		},
		"auth_servers": basetypes.ListType{
			ElemType: AuthServersValue{}.Type(ctx),
		},
		"auth_servers_retries": basetypes.Int64Type{},
		"auth_servers_timeout": basetypes.Int64Type{},
		"coa_enabled":          basetypes.BoolType{},
		"coa_port":             basetypes.Int64Type{},
		"network":              basetypes.StringType{},
		"source_ip":            basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"acct_interim_interval": v.AcctInterimInterval,
			"acct_servers":          acctServers,
			"auth_servers":          authServers,
			"auth_servers_retries":  v.AuthServersRetries,
			"auth_servers_timeout":  v.AuthServersTimeout,
			"coa_enabled":           v.CoaEnabled,
			"coa_port":              v.CoaPort,
			"network":               v.Network,
			"source_ip":             v.SourceIp,
		})

	return objVal, diags
}

func (v RadiusConfigValue) Equal(o attr.Value) bool {
	other, ok := o.(RadiusConfigValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AcctInterimInterval.Equal(other.AcctInterimInterval) {
		return false
	}

	if !v.AcctServers.Equal(other.AcctServers) {
		return false
	}

	if !v.AuthServers.Equal(other.AuthServers) {
		return false
	}

	if !v.AuthServersRetries.Equal(other.AuthServersRetries) {
		return false
	}

	if !v.AuthServersTimeout.Equal(other.AuthServersTimeout) {
		return false
	}

	if !v.CoaEnabled.Equal(other.CoaEnabled) {
		return false
	}

	if !v.CoaPort.Equal(other.CoaPort) {
		return false
	}

	if !v.Network.Equal(other.Network) {
		return false
	}

	if !v.SourceIp.Equal(other.SourceIp) {
		return false
	}

	return true
}

func (v RadiusConfigValue) Type(ctx context.Context) attr.Type {
	return RadiusConfigType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v RadiusConfigValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"acct_interim_interval": basetypes.Int64Type{},
		"acct_servers": basetypes.ListType{
			ElemType: AcctServersValue{}.Type(ctx),
		},
		"auth_servers": basetypes.ListType{
			ElemType: AuthServersValue{}.Type(ctx),
		},
		"auth_servers_retries": basetypes.Int64Type{},
		"auth_servers_timeout": basetypes.Int64Type{},
		"coa_enabled":          basetypes.BoolType{},
		"coa_port":             basetypes.Int64Type{},
		"network":              basetypes.StringType{},
		"source_ip":            basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = AcctServersType{}

type AcctServersType struct {
	basetypes.ObjectType
}

func (t AcctServersType) Equal(o attr.Type) bool {
	other, ok := o.(AcctServersType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AcctServersType) String() string {
	return "AcctServersType"
}

func (t AcctServersType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	hostAttribute, ok := attributes["host"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`host is missing from object`)

		return nil, diags
	}

	hostVal, ok := hostAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`host expected to be basetypes.StringValue, was: %T`, hostAttribute))
	}

	keywrapEnabledAttribute, ok := attributes["keywrap_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywrap_enabled is missing from object`)

		return nil, diags
	}

	keywrapEnabledVal, ok := keywrapEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywrap_enabled expected to be basetypes.BoolValue, was: %T`, keywrapEnabledAttribute))
	}

	keywrapFormatAttribute, ok := attributes["keywrap_format"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywrap_format is missing from object`)

		return nil, diags
	}

	keywrapFormatVal, ok := keywrapFormatAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywrap_format expected to be basetypes.StringValue, was: %T`, keywrapFormatAttribute))
	}

	keywrapKekAttribute, ok := attributes["keywrap_kek"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywrap_kek is missing from object`)

		return nil, diags
	}

	keywrapKekVal, ok := keywrapKekAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywrap_kek expected to be basetypes.StringValue, was: %T`, keywrapKekAttribute))
	}

	keywrapMackAttribute, ok := attributes["keywrap_mack"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywrap_mack is missing from object`)

		return nil, diags
	}

	keywrapMackVal, ok := keywrapMackAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywrap_mack expected to be basetypes.StringValue, was: %T`, keywrapMackAttribute))
	}

	portAttribute, ok := attributes["port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port is missing from object`)

		return nil, diags
	}

	portVal, ok := portAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port expected to be basetypes.Int64Value, was: %T`, portAttribute))
	}

	secretAttribute, ok := attributes["secret"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`secret is missing from object`)

		return nil, diags
	}

	secretVal, ok := secretAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`secret expected to be basetypes.StringValue, was: %T`, secretAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AcctServersValue{
		Host:           hostVal,
		KeywrapEnabled: keywrapEnabledVal,
		KeywrapFormat:  keywrapFormatVal,
		KeywrapKek:     keywrapKekVal,
		KeywrapMack:    keywrapMackVal,
		Port:           portVal,
		Secret:         secretVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewAcctServersValueNull() AcctServersValue {
	return AcctServersValue{
		state: attr.ValueStateNull,
	}
}

func NewAcctServersValueUnknown() AcctServersValue {
	return AcctServersValue{
		state: attr.ValueStateUnknown,
	}
}

func NewAcctServersValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AcctServersValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AcctServersValue Attribute Value",
				"While creating a AcctServersValue value, a missing attribute value was detected. "+
					"A AcctServersValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AcctServersValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AcctServersValue Attribute Type",
				"While creating a AcctServersValue value, an invalid attribute value was detected. "+
					"A AcctServersValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AcctServersValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AcctServersValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AcctServersValue Attribute Value",
				"While creating a AcctServersValue value, an extra attribute value was detected. "+
					"A AcctServersValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AcctServersValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAcctServersValueUnknown(), diags
	}

	hostAttribute, ok := attributes["host"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`host is missing from object`)

		return NewAcctServersValueUnknown(), diags
	}

	hostVal, ok := hostAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`host expected to be basetypes.StringValue, was: %T`, hostAttribute))
	}

	keywrapEnabledAttribute, ok := attributes["keywrap_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywrap_enabled is missing from object`)

		return NewAcctServersValueUnknown(), diags
	}

	keywrapEnabledVal, ok := keywrapEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywrap_enabled expected to be basetypes.BoolValue, was: %T`, keywrapEnabledAttribute))
	}

	keywrapFormatAttribute, ok := attributes["keywrap_format"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywrap_format is missing from object`)

		return NewAcctServersValueUnknown(), diags
	}

	keywrapFormatVal, ok := keywrapFormatAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywrap_format expected to be basetypes.StringValue, was: %T`, keywrapFormatAttribute))
	}

	keywrapKekAttribute, ok := attributes["keywrap_kek"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywrap_kek is missing from object`)

		return NewAcctServersValueUnknown(), diags
	}

	keywrapKekVal, ok := keywrapKekAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywrap_kek expected to be basetypes.StringValue, was: %T`, keywrapKekAttribute))
	}

	keywrapMackAttribute, ok := attributes["keywrap_mack"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywrap_mack is missing from object`)

		return NewAcctServersValueUnknown(), diags
	}

	keywrapMackVal, ok := keywrapMackAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywrap_mack expected to be basetypes.StringValue, was: %T`, keywrapMackAttribute))
	}

	portAttribute, ok := attributes["port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port is missing from object`)

		return NewAcctServersValueUnknown(), diags
	}

	portVal, ok := portAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port expected to be basetypes.Int64Value, was: %T`, portAttribute))
	}

	secretAttribute, ok := attributes["secret"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`secret is missing from object`)

		return NewAcctServersValueUnknown(), diags
	}

	secretVal, ok := secretAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`secret expected to be basetypes.StringValue, was: %T`, secretAttribute))
	}

	if diags.HasError() {
		return NewAcctServersValueUnknown(), diags
	}

	return AcctServersValue{
		Host:           hostVal,
		KeywrapEnabled: keywrapEnabledVal,
		KeywrapFormat:  keywrapFormatVal,
		KeywrapKek:     keywrapKekVal,
		KeywrapMack:    keywrapMackVal,
		Port:           portVal,
		Secret:         secretVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewAcctServersValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AcctServersValue {
	object, diags := NewAcctServersValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAcctServersValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AcctServersType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAcctServersValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAcctServersValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAcctServersValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAcctServersValueMust(AcctServersValue{}.AttributeTypes(ctx), attributes), nil
}

func (t AcctServersType) ValueType(ctx context.Context) attr.Value {
	return AcctServersValue{}
}

var _ basetypes.ObjectValuable = AcctServersValue{}

type AcctServersValue struct {
	Host           basetypes.StringValue `tfsdk:"host"`
	KeywrapEnabled basetypes.BoolValue   `tfsdk:"keywrap_enabled"`
	KeywrapFormat  basetypes.StringValue `tfsdk:"keywrap_format"`
	KeywrapKek     basetypes.StringValue `tfsdk:"keywrap_kek"`
	KeywrapMack    basetypes.StringValue `tfsdk:"keywrap_mack"`
	Port           basetypes.Int64Value  `tfsdk:"port"`
	Secret         basetypes.StringValue `tfsdk:"secret"`
	state          attr.ValueState
}

func (v AcctServersValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 7)

	var val tftypes.Value
	var err error

	attrTypes["host"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["keywrap_enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["keywrap_format"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["keywrap_kek"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["keywrap_mack"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["port"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["secret"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 7)

		val, err = v.Host.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["host"] = val

		val, err = v.KeywrapEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["keywrap_enabled"] = val

		val, err = v.KeywrapFormat.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["keywrap_format"] = val

		val, err = v.KeywrapKek.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["keywrap_kek"] = val

		val, err = v.KeywrapMack.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["keywrap_mack"] = val

		val, err = v.Port.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port"] = val

		val, err = v.Secret.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["secret"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AcctServersValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AcctServersValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AcctServersValue) String() string {
	return "AcctServersValue"
}

func (v AcctServersValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"host":            basetypes.StringType{},
		"keywrap_enabled": basetypes.BoolType{},
		"keywrap_format":  basetypes.StringType{},
		"keywrap_kek":     basetypes.StringType{},
		"keywrap_mack":    basetypes.StringType{},
		"port":            basetypes.Int64Type{},
		"secret":          basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"host":            v.Host,
			"keywrap_enabled": v.KeywrapEnabled,
			"keywrap_format":  v.KeywrapFormat,
			"keywrap_kek":     v.KeywrapKek,
			"keywrap_mack":    v.KeywrapMack,
			"port":            v.Port,
			"secret":          v.Secret,
		})

	return objVal, diags
}

func (v AcctServersValue) Equal(o attr.Value) bool {
	other, ok := o.(AcctServersValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Host.Equal(other.Host) {
		return false
	}

	if !v.KeywrapEnabled.Equal(other.KeywrapEnabled) {
		return false
	}

	if !v.KeywrapFormat.Equal(other.KeywrapFormat) {
		return false
	}

	if !v.KeywrapKek.Equal(other.KeywrapKek) {
		return false
	}

	if !v.KeywrapMack.Equal(other.KeywrapMack) {
		return false
	}

	if !v.Port.Equal(other.Port) {
		return false
	}

	if !v.Secret.Equal(other.Secret) {
		return false
	}

	return true
}

func (v AcctServersValue) Type(ctx context.Context) attr.Type {
	return AcctServersType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AcctServersValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"host":            basetypes.StringType{},
		"keywrap_enabled": basetypes.BoolType{},
		"keywrap_format":  basetypes.StringType{},
		"keywrap_kek":     basetypes.StringType{},
		"keywrap_mack":    basetypes.StringType{},
		"port":            basetypes.Int64Type{},
		"secret":          basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = AuthServersType{}

type AuthServersType struct {
	basetypes.ObjectType
}

func (t AuthServersType) Equal(o attr.Type) bool {
	other, ok := o.(AuthServersType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AuthServersType) String() string {
	return "AuthServersType"
}

func (t AuthServersType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	hostAttribute, ok := attributes["host"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`host is missing from object`)

		return nil, diags
	}

	hostVal, ok := hostAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`host expected to be basetypes.StringValue, was: %T`, hostAttribute))
	}

	keywrapEnabledAttribute, ok := attributes["keywrap_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywrap_enabled is missing from object`)

		return nil, diags
	}

	keywrapEnabledVal, ok := keywrapEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywrap_enabled expected to be basetypes.BoolValue, was: %T`, keywrapEnabledAttribute))
	}

	keywrapFormatAttribute, ok := attributes["keywrap_format"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywrap_format is missing from object`)

		return nil, diags
	}

	keywrapFormatVal, ok := keywrapFormatAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywrap_format expected to be basetypes.StringValue, was: %T`, keywrapFormatAttribute))
	}

	keywrapKekAttribute, ok := attributes["keywrap_kek"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywrap_kek is missing from object`)

		return nil, diags
	}

	keywrapKekVal, ok := keywrapKekAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywrap_kek expected to be basetypes.StringValue, was: %T`, keywrapKekAttribute))
	}

	keywrapMackAttribute, ok := attributes["keywrap_mack"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywrap_mack is missing from object`)

		return nil, diags
	}

	keywrapMackVal, ok := keywrapMackAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywrap_mack expected to be basetypes.StringValue, was: %T`, keywrapMackAttribute))
	}

	portAttribute, ok := attributes["port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port is missing from object`)

		return nil, diags
	}

	portVal, ok := portAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port expected to be basetypes.Int64Value, was: %T`, portAttribute))
	}

	secretAttribute, ok := attributes["secret"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`secret is missing from object`)

		return nil, diags
	}

	secretVal, ok := secretAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`secret expected to be basetypes.StringValue, was: %T`, secretAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AuthServersValue{
		Host:           hostVal,
		KeywrapEnabled: keywrapEnabledVal,
		KeywrapFormat:  keywrapFormatVal,
		KeywrapKek:     keywrapKekVal,
		KeywrapMack:    keywrapMackVal,
		Port:           portVal,
		Secret:         secretVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewAuthServersValueNull() AuthServersValue {
	return AuthServersValue{
		state: attr.ValueStateNull,
	}
}

func NewAuthServersValueUnknown() AuthServersValue {
	return AuthServersValue{
		state: attr.ValueStateUnknown,
	}
}

func NewAuthServersValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AuthServersValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AuthServersValue Attribute Value",
				"While creating a AuthServersValue value, a missing attribute value was detected. "+
					"A AuthServersValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AuthServersValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AuthServersValue Attribute Type",
				"While creating a AuthServersValue value, an invalid attribute value was detected. "+
					"A AuthServersValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AuthServersValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AuthServersValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AuthServersValue Attribute Value",
				"While creating a AuthServersValue value, an extra attribute value was detected. "+
					"A AuthServersValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AuthServersValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAuthServersValueUnknown(), diags
	}

	hostAttribute, ok := attributes["host"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`host is missing from object`)

		return NewAuthServersValueUnknown(), diags
	}

	hostVal, ok := hostAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`host expected to be basetypes.StringValue, was: %T`, hostAttribute))
	}

	keywrapEnabledAttribute, ok := attributes["keywrap_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywrap_enabled is missing from object`)

		return NewAuthServersValueUnknown(), diags
	}

	keywrapEnabledVal, ok := keywrapEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywrap_enabled expected to be basetypes.BoolValue, was: %T`, keywrapEnabledAttribute))
	}

	keywrapFormatAttribute, ok := attributes["keywrap_format"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywrap_format is missing from object`)

		return NewAuthServersValueUnknown(), diags
	}

	keywrapFormatVal, ok := keywrapFormatAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywrap_format expected to be basetypes.StringValue, was: %T`, keywrapFormatAttribute))
	}

	keywrapKekAttribute, ok := attributes["keywrap_kek"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywrap_kek is missing from object`)

		return NewAuthServersValueUnknown(), diags
	}

	keywrapKekVal, ok := keywrapKekAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywrap_kek expected to be basetypes.StringValue, was: %T`, keywrapKekAttribute))
	}

	keywrapMackAttribute, ok := attributes["keywrap_mack"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keywrap_mack is missing from object`)

		return NewAuthServersValueUnknown(), diags
	}

	keywrapMackVal, ok := keywrapMackAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keywrap_mack expected to be basetypes.StringValue, was: %T`, keywrapMackAttribute))
	}

	portAttribute, ok := attributes["port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port is missing from object`)

		return NewAuthServersValueUnknown(), diags
	}

	portVal, ok := portAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port expected to be basetypes.Int64Value, was: %T`, portAttribute))
	}

	secretAttribute, ok := attributes["secret"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`secret is missing from object`)

		return NewAuthServersValueUnknown(), diags
	}

	secretVal, ok := secretAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`secret expected to be basetypes.StringValue, was: %T`, secretAttribute))
	}

	if diags.HasError() {
		return NewAuthServersValueUnknown(), diags
	}

	return AuthServersValue{
		Host:           hostVal,
		KeywrapEnabled: keywrapEnabledVal,
		KeywrapFormat:  keywrapFormatVal,
		KeywrapKek:     keywrapKekVal,
		KeywrapMack:    keywrapMackVal,
		Port:           portVal,
		Secret:         secretVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewAuthServersValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AuthServersValue {
	object, diags := NewAuthServersValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAuthServersValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AuthServersType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAuthServersValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAuthServersValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAuthServersValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAuthServersValueMust(AuthServersValue{}.AttributeTypes(ctx), attributes), nil
}

func (t AuthServersType) ValueType(ctx context.Context) attr.Value {
	return AuthServersValue{}
}

var _ basetypes.ObjectValuable = AuthServersValue{}

type AuthServersValue struct {
	Host           basetypes.StringValue `tfsdk:"host"`
	KeywrapEnabled basetypes.BoolValue   `tfsdk:"keywrap_enabled"`
	KeywrapFormat  basetypes.StringValue `tfsdk:"keywrap_format"`
	KeywrapKek     basetypes.StringValue `tfsdk:"keywrap_kek"`
	KeywrapMack    basetypes.StringValue `tfsdk:"keywrap_mack"`
	Port           basetypes.Int64Value  `tfsdk:"port"`
	Secret         basetypes.StringValue `tfsdk:"secret"`
	state          attr.ValueState
}

func (v AuthServersValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 7)

	var val tftypes.Value
	var err error

	attrTypes["host"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["keywrap_enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["keywrap_format"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["keywrap_kek"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["keywrap_mack"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["port"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["secret"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 7)

		val, err = v.Host.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["host"] = val

		val, err = v.KeywrapEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["keywrap_enabled"] = val

		val, err = v.KeywrapFormat.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["keywrap_format"] = val

		val, err = v.KeywrapKek.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["keywrap_kek"] = val

		val, err = v.KeywrapMack.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["keywrap_mack"] = val

		val, err = v.Port.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port"] = val

		val, err = v.Secret.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["secret"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AuthServersValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AuthServersValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AuthServersValue) String() string {
	return "AuthServersValue"
}

func (v AuthServersValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"host":            basetypes.StringType{},
		"keywrap_enabled": basetypes.BoolType{},
		"keywrap_format":  basetypes.StringType{},
		"keywrap_kek":     basetypes.StringType{},
		"keywrap_mack":    basetypes.StringType{},
		"port":            basetypes.Int64Type{},
		"secret":          basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"host":            v.Host,
			"keywrap_enabled": v.KeywrapEnabled,
			"keywrap_format":  v.KeywrapFormat,
			"keywrap_kek":     v.KeywrapKek,
			"keywrap_mack":    v.KeywrapMack,
			"port":            v.Port,
			"secret":          v.Secret,
		})

	return objVal, diags
}

func (v AuthServersValue) Equal(o attr.Value) bool {
	other, ok := o.(AuthServersValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Host.Equal(other.Host) {
		return false
	}

	if !v.KeywrapEnabled.Equal(other.KeywrapEnabled) {
		return false
	}

	if !v.KeywrapFormat.Equal(other.KeywrapFormat) {
		return false
	}

	if !v.KeywrapKek.Equal(other.KeywrapKek) {
		return false
	}

	if !v.KeywrapMack.Equal(other.KeywrapMack) {
		return false
	}

	if !v.Port.Equal(other.Port) {
		return false
	}

	if !v.Secret.Equal(other.Secret) {
		return false
	}

	return true
}

func (v AuthServersValue) Type(ctx context.Context) attr.Type {
	return AuthServersType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AuthServersValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"host":            basetypes.StringType{},
		"keywrap_enabled": basetypes.BoolType{},
		"keywrap_format":  basetypes.StringType{},
		"keywrap_kek":     basetypes.StringType{},
		"keywrap_mack":    basetypes.StringType{},
		"port":            basetypes.Int64Type{},
		"secret":          basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = RemoteSyslogType{}

type RemoteSyslogType struct {
	basetypes.ObjectType
}

func (t RemoteSyslogType) Equal(o attr.Type) bool {
	other, ok := o.(RemoteSyslogType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t RemoteSyslogType) String() string {
	return "RemoteSyslogType"
}

func (t RemoteSyslogType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	archiveAttribute, ok := attributes["archive"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`archive is missing from object`)

		return nil, diags
	}

	archiveVal, ok := archiveAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`archive expected to be basetypes.ObjectValue, was: %T`, archiveAttribute))
	}

	consoleAttribute, ok := attributes["console"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`console is missing from object`)

		return nil, diags
	}

	consoleVal, ok := consoleAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`console expected to be basetypes.ObjectValue, was: %T`, consoleAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	filesAttribute, ok := attributes["files"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`files is missing from object`)

		return nil, diags
	}

	filesVal, ok := filesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`files expected to be basetypes.ListValue, was: %T`, filesAttribute))
	}

	networkAttribute, ok := attributes["network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`network is missing from object`)

		return nil, diags
	}

	networkVal, ok := networkAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`network expected to be basetypes.StringValue, was: %T`, networkAttribute))
	}

	sendToAllServersAttribute, ok := attributes["send_to_all_servers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`send_to_all_servers is missing from object`)

		return nil, diags
	}

	sendToAllServersVal, ok := sendToAllServersAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`send_to_all_servers expected to be basetypes.BoolValue, was: %T`, sendToAllServersAttribute))
	}

	serversAttribute, ok := attributes["servers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`servers is missing from object`)

		return nil, diags
	}

	serversVal, ok := serversAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`servers expected to be basetypes.ListValue, was: %T`, serversAttribute))
	}

	timeFormatAttribute, ok := attributes["time_format"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`time_format is missing from object`)

		return nil, diags
	}

	timeFormatVal, ok := timeFormatAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`time_format expected to be basetypes.StringValue, was: %T`, timeFormatAttribute))
	}

	usersAttribute, ok := attributes["users"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`users is missing from object`)

		return nil, diags
	}

	usersVal, ok := usersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`users expected to be basetypes.ListValue, was: %T`, usersAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return RemoteSyslogValue{
		Archive:          archiveVal,
		Console:          consoleVal,
		Enabled:          enabledVal,
		Files:            filesVal,
		Network:          networkVal,
		SendToAllServers: sendToAllServersVal,
		Servers:          serversVal,
		TimeFormat:       timeFormatVal,
		Users:            usersVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewRemoteSyslogValueNull() RemoteSyslogValue {
	return RemoteSyslogValue{
		state: attr.ValueStateNull,
	}
}

func NewRemoteSyslogValueUnknown() RemoteSyslogValue {
	return RemoteSyslogValue{
		state: attr.ValueStateUnknown,
	}
}

func NewRemoteSyslogValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (RemoteSyslogValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing RemoteSyslogValue Attribute Value",
				"While creating a RemoteSyslogValue value, a missing attribute value was detected. "+
					"A RemoteSyslogValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RemoteSyslogValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid RemoteSyslogValue Attribute Type",
				"While creating a RemoteSyslogValue value, an invalid attribute value was detected. "+
					"A RemoteSyslogValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RemoteSyslogValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("RemoteSyslogValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra RemoteSyslogValue Attribute Value",
				"While creating a RemoteSyslogValue value, an extra attribute value was detected. "+
					"A RemoteSyslogValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra RemoteSyslogValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewRemoteSyslogValueUnknown(), diags
	}

	archiveAttribute, ok := attributes["archive"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`archive is missing from object`)

		return NewRemoteSyslogValueUnknown(), diags
	}

	archiveVal, ok := archiveAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`archive expected to be basetypes.ObjectValue, was: %T`, archiveAttribute))
	}

	consoleAttribute, ok := attributes["console"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`console is missing from object`)

		return NewRemoteSyslogValueUnknown(), diags
	}

	consoleVal, ok := consoleAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`console expected to be basetypes.ObjectValue, was: %T`, consoleAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewRemoteSyslogValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	filesAttribute, ok := attributes["files"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`files is missing from object`)

		return NewRemoteSyslogValueUnknown(), diags
	}

	filesVal, ok := filesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`files expected to be basetypes.ListValue, was: %T`, filesAttribute))
	}

	networkAttribute, ok := attributes["network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`network is missing from object`)

		return NewRemoteSyslogValueUnknown(), diags
	}

	networkVal, ok := networkAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`network expected to be basetypes.StringValue, was: %T`, networkAttribute))
	}

	sendToAllServersAttribute, ok := attributes["send_to_all_servers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`send_to_all_servers is missing from object`)

		return NewRemoteSyslogValueUnknown(), diags
	}

	sendToAllServersVal, ok := sendToAllServersAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`send_to_all_servers expected to be basetypes.BoolValue, was: %T`, sendToAllServersAttribute))
	}

	serversAttribute, ok := attributes["servers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`servers is missing from object`)

		return NewRemoteSyslogValueUnknown(), diags
	}

	serversVal, ok := serversAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`servers expected to be basetypes.ListValue, was: %T`, serversAttribute))
	}

	timeFormatAttribute, ok := attributes["time_format"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`time_format is missing from object`)

		return NewRemoteSyslogValueUnknown(), diags
	}

	timeFormatVal, ok := timeFormatAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`time_format expected to be basetypes.StringValue, was: %T`, timeFormatAttribute))
	}

	usersAttribute, ok := attributes["users"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`users is missing from object`)

		return NewRemoteSyslogValueUnknown(), diags
	}

	usersVal, ok := usersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`users expected to be basetypes.ListValue, was: %T`, usersAttribute))
	}

	if diags.HasError() {
		return NewRemoteSyslogValueUnknown(), diags
	}

	return RemoteSyslogValue{
		Archive:          archiveVal,
		Console:          consoleVal,
		Enabled:          enabledVal,
		Files:            filesVal,
		Network:          networkVal,
		SendToAllServers: sendToAllServersVal,
		Servers:          serversVal,
		TimeFormat:       timeFormatVal,
		Users:            usersVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewRemoteSyslogValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) RemoteSyslogValue {
	object, diags := NewRemoteSyslogValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewRemoteSyslogValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t RemoteSyslogType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewRemoteSyslogValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewRemoteSyslogValueUnknown(), nil
	}

	if in.IsNull() {
		return NewRemoteSyslogValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewRemoteSyslogValueMust(RemoteSyslogValue{}.AttributeTypes(ctx), attributes), nil
}

func (t RemoteSyslogType) ValueType(ctx context.Context) attr.Value {
	return RemoteSyslogValue{}
}

var _ basetypes.ObjectValuable = RemoteSyslogValue{}

type RemoteSyslogValue struct {
	Archive          basetypes.ObjectValue `tfsdk:"archive"`
	Console          basetypes.ObjectValue `tfsdk:"console"`
	Enabled          basetypes.BoolValue   `tfsdk:"enabled"`
	Files            basetypes.ListValue   `tfsdk:"files"`
	Network          basetypes.StringValue `tfsdk:"network"`
	SendToAllServers basetypes.BoolValue   `tfsdk:"send_to_all_servers"`
	Servers          basetypes.ListValue   `tfsdk:"servers"`
	TimeFormat       basetypes.StringValue `tfsdk:"time_format"`
	Users            basetypes.ListValue   `tfsdk:"users"`
	state            attr.ValueState
}

func (v RemoteSyslogValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 9)

	var val tftypes.Value
	var err error

	attrTypes["archive"] = basetypes.ObjectType{
		AttrTypes: ArchiveValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["console"] = basetypes.ObjectType{
		AttrTypes: ConsoleValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["files"] = basetypes.ListType{
		ElemType: FilesValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["network"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["send_to_all_servers"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["servers"] = basetypes.ListType{
		ElemType: ServersValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["time_format"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["users"] = basetypes.ListType{
		ElemType: UsersValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 9)

		val, err = v.Archive.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["archive"] = val

		val, err = v.Console.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["console"] = val

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.Files.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["files"] = val

		val, err = v.Network.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["network"] = val

		val, err = v.SendToAllServers.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["send_to_all_servers"] = val

		val, err = v.Servers.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["servers"] = val

		val, err = v.TimeFormat.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["time_format"] = val

		val, err = v.Users.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["users"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v RemoteSyslogValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v RemoteSyslogValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v RemoteSyslogValue) String() string {
	return "RemoteSyslogValue"
}

func (v RemoteSyslogValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var archive basetypes.ObjectValue

	if v.Archive.IsNull() {
		archive = types.ObjectNull(
			ArchiveValue{}.AttributeTypes(ctx),
		)
	}

	if v.Archive.IsUnknown() {
		archive = types.ObjectUnknown(
			ArchiveValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Archive.IsNull() && !v.Archive.IsUnknown() {
		archive = types.ObjectValueMust(
			ArchiveValue{}.AttributeTypes(ctx),
			v.Archive.Attributes(),
		)
	}

	var console basetypes.ObjectValue

	if v.Console.IsNull() {
		console = types.ObjectNull(
			ConsoleValue{}.AttributeTypes(ctx),
		)
	}

	if v.Console.IsUnknown() {
		console = types.ObjectUnknown(
			ConsoleValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Console.IsNull() && !v.Console.IsUnknown() {
		console = types.ObjectValueMust(
			ConsoleValue{}.AttributeTypes(ctx),
			v.Console.Attributes(),
		)
	}

	files := types.ListValueMust(
		FilesType{
			basetypes.ObjectType{
				AttrTypes: FilesValue{}.AttributeTypes(ctx),
			},
		},
		v.Files.Elements(),
	)

	if v.Files.IsNull() {
		files = types.ListNull(
			FilesType{
				basetypes.ObjectType{
					AttrTypes: FilesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Files.IsUnknown() {
		files = types.ListUnknown(
			FilesType{
				basetypes.ObjectType{
					AttrTypes: FilesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	servers := types.ListValueMust(
		ServersType{
			basetypes.ObjectType{
				AttrTypes: ServersValue{}.AttributeTypes(ctx),
			},
		},
		v.Servers.Elements(),
	)

	if v.Servers.IsNull() {
		servers = types.ListNull(
			ServersType{
				basetypes.ObjectType{
					AttrTypes: ServersValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Servers.IsUnknown() {
		servers = types.ListUnknown(
			ServersType{
				basetypes.ObjectType{
					AttrTypes: ServersValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	users := types.ListValueMust(
		UsersType{
			basetypes.ObjectType{
				AttrTypes: UsersValue{}.AttributeTypes(ctx),
			},
		},
		v.Users.Elements(),
	)

	if v.Users.IsNull() {
		users = types.ListNull(
			UsersType{
				basetypes.ObjectType{
					AttrTypes: UsersValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Users.IsUnknown() {
		users = types.ListUnknown(
			UsersType{
				basetypes.ObjectType{
					AttrTypes: UsersValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"archive": basetypes.ObjectType{
			AttrTypes: ArchiveValue{}.AttributeTypes(ctx),
		},
		"console": basetypes.ObjectType{
			AttrTypes: ConsoleValue{}.AttributeTypes(ctx),
		},
		"enabled": basetypes.BoolType{},
		"files": basetypes.ListType{
			ElemType: FilesValue{}.Type(ctx),
		},
		"network":             basetypes.StringType{},
		"send_to_all_servers": basetypes.BoolType{},
		"servers": basetypes.ListType{
			ElemType: ServersValue{}.Type(ctx),
		},
		"time_format": basetypes.StringType{},
		"users": basetypes.ListType{
			ElemType: UsersValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"archive":             archive,
			"console":             console,
			"enabled":             v.Enabled,
			"files":               files,
			"network":             v.Network,
			"send_to_all_servers": v.SendToAllServers,
			"servers":             servers,
			"time_format":         v.TimeFormat,
			"users":               users,
		})

	return objVal, diags
}

func (v RemoteSyslogValue) Equal(o attr.Value) bool {
	other, ok := o.(RemoteSyslogValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Archive.Equal(other.Archive) {
		return false
	}

	if !v.Console.Equal(other.Console) {
		return false
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.Files.Equal(other.Files) {
		return false
	}

	if !v.Network.Equal(other.Network) {
		return false
	}

	if !v.SendToAllServers.Equal(other.SendToAllServers) {
		return false
	}

	if !v.Servers.Equal(other.Servers) {
		return false
	}

	if !v.TimeFormat.Equal(other.TimeFormat) {
		return false
	}

	if !v.Users.Equal(other.Users) {
		return false
	}

	return true
}

func (v RemoteSyslogValue) Type(ctx context.Context) attr.Type {
	return RemoteSyslogType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v RemoteSyslogValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"archive": basetypes.ObjectType{
			AttrTypes: ArchiveValue{}.AttributeTypes(ctx),
		},
		"console": basetypes.ObjectType{
			AttrTypes: ConsoleValue{}.AttributeTypes(ctx),
		},
		"enabled": basetypes.BoolType{},
		"files": basetypes.ListType{
			ElemType: FilesValue{}.Type(ctx),
		},
		"network":             basetypes.StringType{},
		"send_to_all_servers": basetypes.BoolType{},
		"servers": basetypes.ListType{
			ElemType: ServersValue{}.Type(ctx),
		},
		"time_format": basetypes.StringType{},
		"users": basetypes.ListType{
			ElemType: UsersValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = ArchiveType{}

type ArchiveType struct {
	basetypes.ObjectType
}

func (t ArchiveType) Equal(o attr.Type) bool {
	other, ok := o.(ArchiveType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ArchiveType) String() string {
	return "ArchiveType"
}

func (t ArchiveType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	filesAttribute, ok := attributes["files"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`files is missing from object`)

		return nil, diags
	}

	filesVal, ok := filesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`files expected to be basetypes.Int64Value, was: %T`, filesAttribute))
	}

	sizeAttribute, ok := attributes["size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`size is missing from object`)

		return nil, diags
	}

	sizeVal, ok := sizeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`size expected to be basetypes.StringValue, was: %T`, sizeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ArchiveValue{
		Files: filesVal,
		Size:  sizeVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewArchiveValueNull() ArchiveValue {
	return ArchiveValue{
		state: attr.ValueStateNull,
	}
}

func NewArchiveValueUnknown() ArchiveValue {
	return ArchiveValue{
		state: attr.ValueStateUnknown,
	}
}

func NewArchiveValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ArchiveValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ArchiveValue Attribute Value",
				"While creating a ArchiveValue value, a missing attribute value was detected. "+
					"A ArchiveValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ArchiveValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ArchiveValue Attribute Type",
				"While creating a ArchiveValue value, an invalid attribute value was detected. "+
					"A ArchiveValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ArchiveValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ArchiveValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ArchiveValue Attribute Value",
				"While creating a ArchiveValue value, an extra attribute value was detected. "+
					"A ArchiveValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ArchiveValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewArchiveValueUnknown(), diags
	}

	filesAttribute, ok := attributes["files"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`files is missing from object`)

		return NewArchiveValueUnknown(), diags
	}

	filesVal, ok := filesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`files expected to be basetypes.Int64Value, was: %T`, filesAttribute))
	}

	sizeAttribute, ok := attributes["size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`size is missing from object`)

		return NewArchiveValueUnknown(), diags
	}

	sizeVal, ok := sizeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`size expected to be basetypes.StringValue, was: %T`, sizeAttribute))
	}

	if diags.HasError() {
		return NewArchiveValueUnknown(), diags
	}

	return ArchiveValue{
		Files: filesVal,
		Size:  sizeVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewArchiveValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ArchiveValue {
	object, diags := NewArchiveValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewArchiveValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ArchiveType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewArchiveValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewArchiveValueUnknown(), nil
	}

	if in.IsNull() {
		return NewArchiveValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewArchiveValueMust(ArchiveValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ArchiveType) ValueType(ctx context.Context) attr.Value {
	return ArchiveValue{}
}

var _ basetypes.ObjectValuable = ArchiveValue{}

type ArchiveValue struct {
	Files basetypes.Int64Value  `tfsdk:"files"`
	Size  basetypes.StringValue `tfsdk:"size"`
	state attr.ValueState
}

func (v ArchiveValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["files"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["size"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Files.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["files"] = val

		val, err = v.Size.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["size"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ArchiveValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ArchiveValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ArchiveValue) String() string {
	return "ArchiveValue"
}

func (v ArchiveValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"files": basetypes.Int64Type{},
		"size":  basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"files": v.Files,
			"size":  v.Size,
		})

	return objVal, diags
}

func (v ArchiveValue) Equal(o attr.Value) bool {
	other, ok := o.(ArchiveValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Files.Equal(other.Files) {
		return false
	}

	if !v.Size.Equal(other.Size) {
		return false
	}

	return true
}

func (v ArchiveValue) Type(ctx context.Context) attr.Type {
	return ArchiveType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ArchiveValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"files": basetypes.Int64Type{},
		"size":  basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = ConsoleType{}

type ConsoleType struct {
	basetypes.ObjectType
}

func (t ConsoleType) Equal(o attr.Type) bool {
	other, ok := o.(ConsoleType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ConsoleType) String() string {
	return "ConsoleType"
}

func (t ConsoleType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	contentsAttribute, ok := attributes["contents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`contents is missing from object`)

		return nil, diags
	}

	contentsVal, ok := contentsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`contents expected to be basetypes.ListValue, was: %T`, contentsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ConsoleValue{
		Contents: contentsVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewConsoleValueNull() ConsoleValue {
	return ConsoleValue{
		state: attr.ValueStateNull,
	}
}

func NewConsoleValueUnknown() ConsoleValue {
	return ConsoleValue{
		state: attr.ValueStateUnknown,
	}
}

func NewConsoleValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ConsoleValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ConsoleValue Attribute Value",
				"While creating a ConsoleValue value, a missing attribute value was detected. "+
					"A ConsoleValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ConsoleValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ConsoleValue Attribute Type",
				"While creating a ConsoleValue value, an invalid attribute value was detected. "+
					"A ConsoleValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ConsoleValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ConsoleValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ConsoleValue Attribute Value",
				"While creating a ConsoleValue value, an extra attribute value was detected. "+
					"A ConsoleValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ConsoleValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewConsoleValueUnknown(), diags
	}

	contentsAttribute, ok := attributes["contents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`contents is missing from object`)

		return NewConsoleValueUnknown(), diags
	}

	contentsVal, ok := contentsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`contents expected to be basetypes.ListValue, was: %T`, contentsAttribute))
	}

	if diags.HasError() {
		return NewConsoleValueUnknown(), diags
	}

	return ConsoleValue{
		Contents: contentsVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewConsoleValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ConsoleValue {
	object, diags := NewConsoleValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewConsoleValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ConsoleType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewConsoleValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewConsoleValueUnknown(), nil
	}

	if in.IsNull() {
		return NewConsoleValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewConsoleValueMust(ConsoleValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ConsoleType) ValueType(ctx context.Context) attr.Value {
	return ConsoleValue{}
}

var _ basetypes.ObjectValuable = ConsoleValue{}

type ConsoleValue struct {
	Contents basetypes.ListValue `tfsdk:"contents"`
	state    attr.ValueState
}

func (v ConsoleValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["contents"] = basetypes.ListType{
		ElemType: ContentsValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Contents.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["contents"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ConsoleValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ConsoleValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ConsoleValue) String() string {
	return "ConsoleValue"
}

func (v ConsoleValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	contents := types.ListValueMust(
		ContentsType{
			basetypes.ObjectType{
				AttrTypes: ContentsValue{}.AttributeTypes(ctx),
			},
		},
		v.Contents.Elements(),
	)

	if v.Contents.IsNull() {
		contents = types.ListNull(
			ContentsType{
				basetypes.ObjectType{
					AttrTypes: ContentsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Contents.IsUnknown() {
		contents = types.ListUnknown(
			ContentsType{
				basetypes.ObjectType{
					AttrTypes: ContentsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"contents": basetypes.ListType{
			ElemType: ContentsValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"contents": contents,
		})

	return objVal, diags
}

func (v ConsoleValue) Equal(o attr.Value) bool {
	other, ok := o.(ConsoleValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Contents.Equal(other.Contents) {
		return false
	}

	return true
}

func (v ConsoleValue) Type(ctx context.Context) attr.Type {
	return ConsoleType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ConsoleValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"contents": basetypes.ListType{
			ElemType: ContentsValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = ContentsType{}

type ContentsType struct {
	basetypes.ObjectType
}

func (t ContentsType) Equal(o attr.Type) bool {
	other, ok := o.(ContentsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ContentsType) String() string {
	return "ContentsType"
}

func (t ContentsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	facilityAttribute, ok := attributes["facility"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`facility is missing from object`)

		return nil, diags
	}

	facilityVal, ok := facilityAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`facility expected to be basetypes.StringValue, was: %T`, facilityAttribute))
	}

	severityAttribute, ok := attributes["severity"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`severity is missing from object`)

		return nil, diags
	}

	severityVal, ok := severityAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`severity expected to be basetypes.StringValue, was: %T`, severityAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ContentsValue{
		Facility: facilityVal,
		Severity: severityVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewContentsValueNull() ContentsValue {
	return ContentsValue{
		state: attr.ValueStateNull,
	}
}

func NewContentsValueUnknown() ContentsValue {
	return ContentsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewContentsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ContentsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ContentsValue Attribute Value",
				"While creating a ContentsValue value, a missing attribute value was detected. "+
					"A ContentsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ContentsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ContentsValue Attribute Type",
				"While creating a ContentsValue value, an invalid attribute value was detected. "+
					"A ContentsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ContentsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ContentsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ContentsValue Attribute Value",
				"While creating a ContentsValue value, an extra attribute value was detected. "+
					"A ContentsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ContentsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewContentsValueUnknown(), diags
	}

	facilityAttribute, ok := attributes["facility"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`facility is missing from object`)

		return NewContentsValueUnknown(), diags
	}

	facilityVal, ok := facilityAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`facility expected to be basetypes.StringValue, was: %T`, facilityAttribute))
	}

	severityAttribute, ok := attributes["severity"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`severity is missing from object`)

		return NewContentsValueUnknown(), diags
	}

	severityVal, ok := severityAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`severity expected to be basetypes.StringValue, was: %T`, severityAttribute))
	}

	if diags.HasError() {
		return NewContentsValueUnknown(), diags
	}

	return ContentsValue{
		Facility: facilityVal,
		Severity: severityVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewContentsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ContentsValue {
	object, diags := NewContentsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewContentsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ContentsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewContentsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewContentsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewContentsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewContentsValueMust(ContentsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ContentsType) ValueType(ctx context.Context) attr.Value {
	return ContentsValue{}
}

var _ basetypes.ObjectValuable = ContentsValue{}

type ContentsValue struct {
	Facility basetypes.StringValue `tfsdk:"facility"`
	Severity basetypes.StringValue `tfsdk:"severity"`
	state    attr.ValueState
}

func (v ContentsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["facility"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["severity"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Facility.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["facility"] = val

		val, err = v.Severity.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["severity"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ContentsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ContentsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ContentsValue) String() string {
	return "ContentsValue"
}

func (v ContentsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"facility": basetypes.StringType{},
		"severity": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"facility": v.Facility,
			"severity": v.Severity,
		})

	return objVal, diags
}

func (v ContentsValue) Equal(o attr.Value) bool {
	other, ok := o.(ContentsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Facility.Equal(other.Facility) {
		return false
	}

	if !v.Severity.Equal(other.Severity) {
		return false
	}

	return true
}

func (v ContentsValue) Type(ctx context.Context) attr.Type {
	return ContentsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ContentsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"facility": basetypes.StringType{},
		"severity": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = FilesType{}

type FilesType struct {
	basetypes.ObjectType
}

func (t FilesType) Equal(o attr.Type) bool {
	other, ok := o.(FilesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t FilesType) String() string {
	return "FilesType"
}

func (t FilesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	archiveAttribute, ok := attributes["archive"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`archive is missing from object`)

		return nil, diags
	}

	archiveVal, ok := archiveAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`archive expected to be basetypes.ObjectValue, was: %T`, archiveAttribute))
	}

	contentsAttribute, ok := attributes["contents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`contents is missing from object`)

		return nil, diags
	}

	contentsVal, ok := contentsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`contents expected to be basetypes.ListValue, was: %T`, contentsAttribute))
	}

	explicitPriorityAttribute, ok := attributes["explicit_priority"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`explicit_priority is missing from object`)

		return nil, diags
	}

	explicitPriorityVal, ok := explicitPriorityAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`explicit_priority expected to be basetypes.BoolValue, was: %T`, explicitPriorityAttribute))
	}

	fileAttribute, ok := attributes["file"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`file is missing from object`)

		return nil, diags
	}

	fileVal, ok := fileAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`file expected to be basetypes.StringValue, was: %T`, fileAttribute))
	}

	matchAttribute, ok := attributes["match"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`match is missing from object`)

		return nil, diags
	}

	matchVal, ok := matchAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`match expected to be basetypes.StringValue, was: %T`, matchAttribute))
	}

	structuredDataAttribute, ok := attributes["structured_data"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`structured_data is missing from object`)

		return nil, diags
	}

	structuredDataVal, ok := structuredDataAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`structured_data expected to be basetypes.BoolValue, was: %T`, structuredDataAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return FilesValue{
		Archive:          archiveVal,
		Contents:         contentsVal,
		ExplicitPriority: explicitPriorityVal,
		File:             fileVal,
		Match:            matchVal,
		StructuredData:   structuredDataVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewFilesValueNull() FilesValue {
	return FilesValue{
		state: attr.ValueStateNull,
	}
}

func NewFilesValueUnknown() FilesValue {
	return FilesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewFilesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (FilesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing FilesValue Attribute Value",
				"While creating a FilesValue value, a missing attribute value was detected. "+
					"A FilesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("FilesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid FilesValue Attribute Type",
				"While creating a FilesValue value, an invalid attribute value was detected. "+
					"A FilesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("FilesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("FilesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra FilesValue Attribute Value",
				"While creating a FilesValue value, an extra attribute value was detected. "+
					"A FilesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra FilesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewFilesValueUnknown(), diags
	}

	archiveAttribute, ok := attributes["archive"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`archive is missing from object`)

		return NewFilesValueUnknown(), diags
	}

	archiveVal, ok := archiveAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`archive expected to be basetypes.ObjectValue, was: %T`, archiveAttribute))
	}

	contentsAttribute, ok := attributes["contents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`contents is missing from object`)

		return NewFilesValueUnknown(), diags
	}

	contentsVal, ok := contentsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`contents expected to be basetypes.ListValue, was: %T`, contentsAttribute))
	}

	explicitPriorityAttribute, ok := attributes["explicit_priority"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`explicit_priority is missing from object`)

		return NewFilesValueUnknown(), diags
	}

	explicitPriorityVal, ok := explicitPriorityAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`explicit_priority expected to be basetypes.BoolValue, was: %T`, explicitPriorityAttribute))
	}

	fileAttribute, ok := attributes["file"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`file is missing from object`)

		return NewFilesValueUnknown(), diags
	}

	fileVal, ok := fileAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`file expected to be basetypes.StringValue, was: %T`, fileAttribute))
	}

	matchAttribute, ok := attributes["match"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`match is missing from object`)

		return NewFilesValueUnknown(), diags
	}

	matchVal, ok := matchAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`match expected to be basetypes.StringValue, was: %T`, matchAttribute))
	}

	structuredDataAttribute, ok := attributes["structured_data"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`structured_data is missing from object`)

		return NewFilesValueUnknown(), diags
	}

	structuredDataVal, ok := structuredDataAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`structured_data expected to be basetypes.BoolValue, was: %T`, structuredDataAttribute))
	}

	if diags.HasError() {
		return NewFilesValueUnknown(), diags
	}

	return FilesValue{
		Archive:          archiveVal,
		Contents:         contentsVal,
		ExplicitPriority: explicitPriorityVal,
		File:             fileVal,
		Match:            matchVal,
		StructuredData:   structuredDataVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewFilesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) FilesValue {
	object, diags := NewFilesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewFilesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t FilesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewFilesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewFilesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewFilesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewFilesValueMust(FilesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t FilesType) ValueType(ctx context.Context) attr.Value {
	return FilesValue{}
}

var _ basetypes.ObjectValuable = FilesValue{}

type FilesValue struct {
	Archive          basetypes.ObjectValue `tfsdk:"archive"`
	Contents         basetypes.ListValue   `tfsdk:"contents"`
	ExplicitPriority basetypes.BoolValue   `tfsdk:"explicit_priority"`
	File             basetypes.StringValue `tfsdk:"file"`
	Match            basetypes.StringValue `tfsdk:"match"`
	StructuredData   basetypes.BoolValue   `tfsdk:"structured_data"`
	state            attr.ValueState
}

func (v FilesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 6)

	var val tftypes.Value
	var err error

	attrTypes["archive"] = basetypes.ObjectType{
		AttrTypes: ArchiveValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["contents"] = basetypes.ListType{
		ElemType: ContentsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["explicit_priority"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["file"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["match"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["structured_data"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 6)

		val, err = v.Archive.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["archive"] = val

		val, err = v.Contents.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["contents"] = val

		val, err = v.ExplicitPriority.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["explicit_priority"] = val

		val, err = v.File.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["file"] = val

		val, err = v.Match.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["match"] = val

		val, err = v.StructuredData.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["structured_data"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v FilesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v FilesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v FilesValue) String() string {
	return "FilesValue"
}

func (v FilesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var archive basetypes.ObjectValue

	if v.Archive.IsNull() {
		archive = types.ObjectNull(
			ArchiveValue{}.AttributeTypes(ctx),
		)
	}

	if v.Archive.IsUnknown() {
		archive = types.ObjectUnknown(
			ArchiveValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Archive.IsNull() && !v.Archive.IsUnknown() {
		archive = types.ObjectValueMust(
			ArchiveValue{}.AttributeTypes(ctx),
			v.Archive.Attributes(),
		)
	}

	contents := types.ListValueMust(
		ContentsType{
			basetypes.ObjectType{
				AttrTypes: ContentsValue{}.AttributeTypes(ctx),
			},
		},
		v.Contents.Elements(),
	)

	if v.Contents.IsNull() {
		contents = types.ListNull(
			ContentsType{
				basetypes.ObjectType{
					AttrTypes: ContentsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Contents.IsUnknown() {
		contents = types.ListUnknown(
			ContentsType{
				basetypes.ObjectType{
					AttrTypes: ContentsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"archive": basetypes.ObjectType{
			AttrTypes: ArchiveValue{}.AttributeTypes(ctx),
		},
		"contents": basetypes.ListType{
			ElemType: ContentsValue{}.Type(ctx),
		},
		"explicit_priority": basetypes.BoolType{},
		"file":              basetypes.StringType{},
		"match":             basetypes.StringType{},
		"structured_data":   basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"archive":           archive,
			"contents":          contents,
			"explicit_priority": v.ExplicitPriority,
			"file":              v.File,
			"match":             v.Match,
			"structured_data":   v.StructuredData,
		})

	return objVal, diags
}

func (v FilesValue) Equal(o attr.Value) bool {
	other, ok := o.(FilesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Archive.Equal(other.Archive) {
		return false
	}

	if !v.Contents.Equal(other.Contents) {
		return false
	}

	if !v.ExplicitPriority.Equal(other.ExplicitPriority) {
		return false
	}

	if !v.File.Equal(other.File) {
		return false
	}

	if !v.Match.Equal(other.Match) {
		return false
	}

	if !v.StructuredData.Equal(other.StructuredData) {
		return false
	}

	return true
}

func (v FilesValue) Type(ctx context.Context) attr.Type {
	return FilesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v FilesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"archive": basetypes.ObjectType{
			AttrTypes: ArchiveValue{}.AttributeTypes(ctx),
		},
		"contents": basetypes.ListType{
			ElemType: ContentsValue{}.Type(ctx),
		},
		"explicit_priority": basetypes.BoolType{},
		"file":              basetypes.StringType{},
		"match":             basetypes.StringType{},
		"structured_data":   basetypes.BoolType{},
	}
}











































var _ basetypes.ObjectTypable = ServersType{}

type ServersType struct {
	basetypes.ObjectType
}

func (t ServersType) Equal(o attr.Type) bool {
	other, ok := o.(ServersType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ServersType) String() string {
	return "ServersType"
}

func (t ServersType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	contentsAttribute, ok := attributes["contents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`contents is missing from object`)

		return nil, diags
	}

	contentsVal, ok := contentsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`contents expected to be basetypes.ListValue, was: %T`, contentsAttribute))
	}

	explicitPriorityAttribute, ok := attributes["explicit_priority"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`explicit_priority is missing from object`)

		return nil, diags
	}

	explicitPriorityVal, ok := explicitPriorityAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`explicit_priority expected to be basetypes.BoolValue, was: %T`, explicitPriorityAttribute))
	}

	facilityAttribute, ok := attributes["facility"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`facility is missing from object`)

		return nil, diags
	}

	facilityVal, ok := facilityAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`facility expected to be basetypes.StringValue, was: %T`, facilityAttribute))
	}

	hostAttribute, ok := attributes["host"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`host is missing from object`)

		return nil, diags
	}

	hostVal, ok := hostAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`host expected to be basetypes.StringValue, was: %T`, hostAttribute))
	}

	matchAttribute, ok := attributes["match"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`match is missing from object`)

		return nil, diags
	}

	matchVal, ok := matchAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`match expected to be basetypes.StringValue, was: %T`, matchAttribute))
	}

	portAttribute, ok := attributes["port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port is missing from object`)

		return nil, diags
	}

	portVal, ok := portAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port expected to be basetypes.Int64Value, was: %T`, portAttribute))
	}

	protocolAttribute, ok := attributes["protocol"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`protocol is missing from object`)

		return nil, diags
	}

	protocolVal, ok := protocolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`protocol expected to be basetypes.StringValue, was: %T`, protocolAttribute))
	}

	routingInstanceAttribute, ok := attributes["routing_instance"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`routing_instance is missing from object`)

		return nil, diags
	}

	routingInstanceVal, ok := routingInstanceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`routing_instance expected to be basetypes.StringValue, was: %T`, routingInstanceAttribute))
	}

	severityAttribute, ok := attributes["severity"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`severity is missing from object`)

		return nil, diags
	}

	severityVal, ok := severityAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`severity expected to be basetypes.StringValue, was: %T`, severityAttribute))
	}

	sourceAddressAttribute, ok := attributes["source_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`source_address is missing from object`)

		return nil, diags
	}

	sourceAddressVal, ok := sourceAddressAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`source_address expected to be basetypes.StringValue, was: %T`, sourceAddressAttribute))
	}

	structuredDataAttribute, ok := attributes["structured_data"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`structured_data is missing from object`)

		return nil, diags
	}

	structuredDataVal, ok := structuredDataAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`structured_data expected to be basetypes.BoolValue, was: %T`, structuredDataAttribute))
	}

	tagAttribute, ok := attributes["tag"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tag is missing from object`)

		return nil, diags
	}

	tagVal, ok := tagAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tag expected to be basetypes.StringValue, was: %T`, tagAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ServersValue{
		Contents:         contentsVal,
		ExplicitPriority: explicitPriorityVal,
		Facility:         facilityVal,
		Host:             hostVal,
		Match:            matchVal,
		Port:             portVal,
		Protocol:         protocolVal,
		RoutingInstance:  routingInstanceVal,
		Severity:         severityVal,
		SourceAddress:    sourceAddressVal,
		StructuredData:   structuredDataVal,
		Tag:              tagVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewServersValueNull() ServersValue {
	return ServersValue{
		state: attr.ValueStateNull,
	}
}

func NewServersValueUnknown() ServersValue {
	return ServersValue{
		state: attr.ValueStateUnknown,
	}
}

func NewServersValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ServersValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ServersValue Attribute Value",
				"While creating a ServersValue value, a missing attribute value was detected. "+
					"A ServersValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ServersValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ServersValue Attribute Type",
				"While creating a ServersValue value, an invalid attribute value was detected. "+
					"A ServersValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ServersValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ServersValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ServersValue Attribute Value",
				"While creating a ServersValue value, an extra attribute value was detected. "+
					"A ServersValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ServersValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewServersValueUnknown(), diags
	}

	contentsAttribute, ok := attributes["contents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`contents is missing from object`)

		return NewServersValueUnknown(), diags
	}

	contentsVal, ok := contentsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`contents expected to be basetypes.ListValue, was: %T`, contentsAttribute))
	}

	explicitPriorityAttribute, ok := attributes["explicit_priority"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`explicit_priority is missing from object`)

		return NewServersValueUnknown(), diags
	}

	explicitPriorityVal, ok := explicitPriorityAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`explicit_priority expected to be basetypes.BoolValue, was: %T`, explicitPriorityAttribute))
	}

	facilityAttribute, ok := attributes["facility"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`facility is missing from object`)

		return NewServersValueUnknown(), diags
	}

	facilityVal, ok := facilityAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`facility expected to be basetypes.StringValue, was: %T`, facilityAttribute))
	}

	hostAttribute, ok := attributes["host"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`host is missing from object`)

		return NewServersValueUnknown(), diags
	}

	hostVal, ok := hostAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`host expected to be basetypes.StringValue, was: %T`, hostAttribute))
	}

	matchAttribute, ok := attributes["match"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`match is missing from object`)

		return NewServersValueUnknown(), diags
	}

	matchVal, ok := matchAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`match expected to be basetypes.StringValue, was: %T`, matchAttribute))
	}

	portAttribute, ok := attributes["port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port is missing from object`)

		return NewServersValueUnknown(), diags
	}

	portVal, ok := portAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port expected to be basetypes.Int64Value, was: %T`, portAttribute))
	}

	protocolAttribute, ok := attributes["protocol"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`protocol is missing from object`)

		return NewServersValueUnknown(), diags
	}

	protocolVal, ok := protocolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`protocol expected to be basetypes.StringValue, was: %T`, protocolAttribute))
	}

	routingInstanceAttribute, ok := attributes["routing_instance"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`routing_instance is missing from object`)

		return NewServersValueUnknown(), diags
	}

	routingInstanceVal, ok := routingInstanceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`routing_instance expected to be basetypes.StringValue, was: %T`, routingInstanceAttribute))
	}

	severityAttribute, ok := attributes["severity"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`severity is missing from object`)

		return NewServersValueUnknown(), diags
	}

	severityVal, ok := severityAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`severity expected to be basetypes.StringValue, was: %T`, severityAttribute))
	}

	sourceAddressAttribute, ok := attributes["source_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`source_address is missing from object`)

		return NewServersValueUnknown(), diags
	}

	sourceAddressVal, ok := sourceAddressAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`source_address expected to be basetypes.StringValue, was: %T`, sourceAddressAttribute))
	}

	structuredDataAttribute, ok := attributes["structured_data"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`structured_data is missing from object`)

		return NewServersValueUnknown(), diags
	}

	structuredDataVal, ok := structuredDataAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`structured_data expected to be basetypes.BoolValue, was: %T`, structuredDataAttribute))
	}

	tagAttribute, ok := attributes["tag"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tag is missing from object`)

		return NewServersValueUnknown(), diags
	}

	tagVal, ok := tagAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tag expected to be basetypes.StringValue, was: %T`, tagAttribute))
	}

	if diags.HasError() {
		return NewServersValueUnknown(), diags
	}

	return ServersValue{
		Contents:         contentsVal,
		ExplicitPriority: explicitPriorityVal,
		Facility:         facilityVal,
		Host:             hostVal,
		Match:            matchVal,
		Port:             portVal,
		Protocol:         protocolVal,
		RoutingInstance:  routingInstanceVal,
		Severity:         severityVal,
		SourceAddress:    sourceAddressVal,
		StructuredData:   structuredDataVal,
		Tag:              tagVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewServersValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ServersValue {
	object, diags := NewServersValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewServersValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ServersType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewServersValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewServersValueUnknown(), nil
	}

	if in.IsNull() {
		return NewServersValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewServersValueMust(ServersValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ServersType) ValueType(ctx context.Context) attr.Value {
	return ServersValue{}
}

var _ basetypes.ObjectValuable = ServersValue{}

type ServersValue struct {
	Contents         basetypes.ListValue   `tfsdk:"contents"`
	ExplicitPriority basetypes.BoolValue   `tfsdk:"explicit_priority"`
	Facility         basetypes.StringValue `tfsdk:"facility"`
	Host             basetypes.StringValue `tfsdk:"host"`
	Match            basetypes.StringValue `tfsdk:"match"`
	Port             basetypes.Int64Value  `tfsdk:"port"`
	Protocol         basetypes.StringValue `tfsdk:"protocol"`
	RoutingInstance  basetypes.StringValue `tfsdk:"routing_instance"`
	Severity         basetypes.StringValue `tfsdk:"severity"`
	SourceAddress    basetypes.StringValue `tfsdk:"source_address"`
	StructuredData   basetypes.BoolValue   `tfsdk:"structured_data"`
	Tag              basetypes.StringValue `tfsdk:"tag"`
	state            attr.ValueState
}

func (v ServersValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 12)

	var val tftypes.Value
	var err error

	attrTypes["contents"] = basetypes.ListType{
		ElemType: ContentsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["explicit_priority"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["facility"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["host"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["match"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["port"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["protocol"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["routing_instance"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["severity"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["source_address"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["structured_data"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["tag"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 12)

		val, err = v.Contents.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["contents"] = val

		val, err = v.ExplicitPriority.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["explicit_priority"] = val

		val, err = v.Facility.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["facility"] = val

		val, err = v.Host.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["host"] = val

		val, err = v.Match.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["match"] = val

		val, err = v.Port.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port"] = val

		val, err = v.Protocol.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["protocol"] = val

		val, err = v.RoutingInstance.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["routing_instance"] = val

		val, err = v.Severity.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["severity"] = val

		val, err = v.SourceAddress.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["source_address"] = val

		val, err = v.StructuredData.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["structured_data"] = val

		val, err = v.Tag.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tag"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ServersValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ServersValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ServersValue) String() string {
	return "ServersValue"
}

func (v ServersValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	contents := types.ListValueMust(
		ContentsType{
			basetypes.ObjectType{
				AttrTypes: ContentsValue{}.AttributeTypes(ctx),
			},
		},
		v.Contents.Elements(),
	)

	if v.Contents.IsNull() {
		contents = types.ListNull(
			ContentsType{
				basetypes.ObjectType{
					AttrTypes: ContentsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Contents.IsUnknown() {
		contents = types.ListUnknown(
			ContentsType{
				basetypes.ObjectType{
					AttrTypes: ContentsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"contents": basetypes.ListType{
			ElemType: ContentsValue{}.Type(ctx),
		},
		"explicit_priority": basetypes.BoolType{},
		"facility":          basetypes.StringType{},
		"host":              basetypes.StringType{},
		"match":             basetypes.StringType{},
		"port":              basetypes.Int64Type{},
		"protocol":          basetypes.StringType{},
		"routing_instance":  basetypes.StringType{},
		"severity":          basetypes.StringType{},
		"source_address":    basetypes.StringType{},
		"structured_data":   basetypes.BoolType{},
		"tag":               basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"contents":          contents,
			"explicit_priority": v.ExplicitPriority,
			"facility":          v.Facility,
			"host":              v.Host,
			"match":             v.Match,
			"port":              v.Port,
			"protocol":          v.Protocol,
			"routing_instance":  v.RoutingInstance,
			"severity":          v.Severity,
			"source_address":    v.SourceAddress,
			"structured_data":   v.StructuredData,
			"tag":               v.Tag,
		})

	return objVal, diags
}

func (v ServersValue) Equal(o attr.Value) bool {
	other, ok := o.(ServersValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Contents.Equal(other.Contents) {
		return false
	}

	if !v.ExplicitPriority.Equal(other.ExplicitPriority) {
		return false
	}

	if !v.Facility.Equal(other.Facility) {
		return false
	}

	if !v.Host.Equal(other.Host) {
		return false
	}

	if !v.Match.Equal(other.Match) {
		return false
	}

	if !v.Port.Equal(other.Port) {
		return false
	}

	if !v.Protocol.Equal(other.Protocol) {
		return false
	}

	if !v.RoutingInstance.Equal(other.RoutingInstance) {
		return false
	}

	if !v.Severity.Equal(other.Severity) {
		return false
	}

	if !v.SourceAddress.Equal(other.SourceAddress) {
		return false
	}

	if !v.StructuredData.Equal(other.StructuredData) {
		return false
	}

	if !v.Tag.Equal(other.Tag) {
		return false
	}

	return true
}

func (v ServersValue) Type(ctx context.Context) attr.Type {
	return ServersType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ServersValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"contents": basetypes.ListType{
			ElemType: ContentsValue{}.Type(ctx),
		},
		"explicit_priority": basetypes.BoolType{},
		"facility":          basetypes.StringType{},
		"host":              basetypes.StringType{},
		"match":             basetypes.StringType{},
		"port":              basetypes.Int64Type{},
		"protocol":          basetypes.StringType{},
		"routing_instance":  basetypes.StringType{},
		"severity":          basetypes.StringType{},
		"source_address":    basetypes.StringType{},
		"structured_data":   basetypes.BoolType{},
		"tag":               basetypes.StringType{},
	}
}






















var _ basetypes.ObjectTypable = UsersType{}

type UsersType struct {
	basetypes.ObjectType
}

func (t UsersType) Equal(o attr.Type) bool {
	other, ok := o.(UsersType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t UsersType) String() string {
	return "UsersType"
}

func (t UsersType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	contentsAttribute, ok := attributes["contents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`contents is missing from object`)

		return nil, diags
	}

	contentsVal, ok := contentsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`contents expected to be basetypes.ListValue, was: %T`, contentsAttribute))
	}

	matchAttribute, ok := attributes["match"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`match is missing from object`)

		return nil, diags
	}

	matchVal, ok := matchAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`match expected to be basetypes.StringValue, was: %T`, matchAttribute))
	}

	userAttribute, ok := attributes["user"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`user is missing from object`)

		return nil, diags
	}

	userVal, ok := userAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`user expected to be basetypes.StringValue, was: %T`, userAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return UsersValue{
		Contents: contentsVal,
		Match:    matchVal,
		User:     userVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewUsersValueNull() UsersValue {
	return UsersValue{
		state: attr.ValueStateNull,
	}
}

func NewUsersValueUnknown() UsersValue {
	return UsersValue{
		state: attr.ValueStateUnknown,
	}
}

func NewUsersValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (UsersValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing UsersValue Attribute Value",
				"While creating a UsersValue value, a missing attribute value was detected. "+
					"A UsersValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("UsersValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid UsersValue Attribute Type",
				"While creating a UsersValue value, an invalid attribute value was detected. "+
					"A UsersValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("UsersValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("UsersValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra UsersValue Attribute Value",
				"While creating a UsersValue value, an extra attribute value was detected. "+
					"A UsersValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra UsersValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewUsersValueUnknown(), diags
	}

	contentsAttribute, ok := attributes["contents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`contents is missing from object`)

		return NewUsersValueUnknown(), diags
	}

	contentsVal, ok := contentsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`contents expected to be basetypes.ListValue, was: %T`, contentsAttribute))
	}

	matchAttribute, ok := attributes["match"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`match is missing from object`)

		return NewUsersValueUnknown(), diags
	}

	matchVal, ok := matchAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`match expected to be basetypes.StringValue, was: %T`, matchAttribute))
	}

	userAttribute, ok := attributes["user"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`user is missing from object`)

		return NewUsersValueUnknown(), diags
	}

	userVal, ok := userAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`user expected to be basetypes.StringValue, was: %T`, userAttribute))
	}

	if diags.HasError() {
		return NewUsersValueUnknown(), diags
	}

	return UsersValue{
		Contents: contentsVal,
		Match:    matchVal,
		User:     userVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewUsersValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) UsersValue {
	object, diags := NewUsersValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewUsersValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t UsersType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewUsersValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewUsersValueUnknown(), nil
	}

	if in.IsNull() {
		return NewUsersValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewUsersValueMust(UsersValue{}.AttributeTypes(ctx), attributes), nil
}

func (t UsersType) ValueType(ctx context.Context) attr.Value {
	return UsersValue{}
}

var _ basetypes.ObjectValuable = UsersValue{}

type UsersValue struct {
	Contents basetypes.ListValue   `tfsdk:"contents"`
	Match    basetypes.StringValue `tfsdk:"match"`
	User     basetypes.StringValue `tfsdk:"user"`
	state    attr.ValueState
}

func (v UsersValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["contents"] = basetypes.ListType{
		ElemType: ContentsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["match"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["user"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Contents.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["contents"] = val

		val, err = v.Match.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["match"] = val

		val, err = v.User.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["user"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v UsersValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v UsersValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v UsersValue) String() string {
	return "UsersValue"
}

func (v UsersValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	contents := types.ListValueMust(
		ContentsType{
			basetypes.ObjectType{
				AttrTypes: ContentsValue{}.AttributeTypes(ctx),
			},
		},
		v.Contents.Elements(),
	)

	if v.Contents.IsNull() {
		contents = types.ListNull(
			ContentsType{
				basetypes.ObjectType{
					AttrTypes: ContentsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Contents.IsUnknown() {
		contents = types.ListUnknown(
			ContentsType{
				basetypes.ObjectType{
					AttrTypes: ContentsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"contents": basetypes.ListType{
			ElemType: ContentsValue{}.Type(ctx),
		},
		"match": basetypes.StringType{},
		"user":  basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"contents": contents,
			"match":    v.Match,
			"user":     v.User,
		})

	return objVal, diags
}

func (v UsersValue) Equal(o attr.Value) bool {
	other, ok := o.(UsersValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Contents.Equal(other.Contents) {
		return false
	}

	if !v.Match.Equal(other.Match) {
		return false
	}

	if !v.User.Equal(other.User) {
		return false
	}

	return true
}

func (v UsersValue) Type(ctx context.Context) attr.Type {
	return UsersType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v UsersValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"contents": basetypes.ListType{
			ElemType: ContentsValue{}.Type(ctx),
		},
		"match": basetypes.StringType{},
		"user":  basetypes.StringType{},
	}
}






















var _ basetypes.ObjectTypable = SnmpConfigType{}

type SnmpConfigType struct {
	basetypes.ObjectType
}

func (t SnmpConfigType) Equal(o attr.Type) bool {
	other, ok := o.(SnmpConfigType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SnmpConfigType) String() string {
	return "SnmpConfigType"
}

func (t SnmpConfigType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	clientListAttribute, ok := attributes["client_list"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`client_list is missing from object`)

		return nil, diags
	}

	clientListVal, ok := clientListAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`client_list expected to be basetypes.ListValue, was: %T`, clientListAttribute))
	}

	contactAttribute, ok := attributes["contact"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`contact is missing from object`)

		return nil, diags
	}

	contactVal, ok := contactAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`contact expected to be basetypes.StringValue, was: %T`, contactAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return nil, diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	engineIdAttribute, ok := attributes["engine_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`engine_id is missing from object`)

		return nil, diags
	}

	engineIdVal, ok := engineIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`engine_id expected to be basetypes.StringValue, was: %T`, engineIdAttribute))
	}

	locationAttribute, ok := attributes["location"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`location is missing from object`)

		return nil, diags
	}

	locationVal, ok := locationAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`location expected to be basetypes.StringValue, was: %T`, locationAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	networkAttribute, ok := attributes["network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`network is missing from object`)

		return nil, diags
	}

	networkVal, ok := networkAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`network expected to be basetypes.StringValue, was: %T`, networkAttribute))
	}

	trapGroupsAttribute, ok := attributes["trap_groups"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`trap_groups is missing from object`)

		return nil, diags
	}

	trapGroupsVal, ok := trapGroupsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`trap_groups expected to be basetypes.ListValue, was: %T`, trapGroupsAttribute))
	}

	v2cConfigAttribute, ok := attributes["v2c_config"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`v2c_config is missing from object`)

		return nil, diags
	}

	v2cConfigVal, ok := v2cConfigAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`v2c_config expected to be basetypes.ListValue, was: %T`, v2cConfigAttribute))
	}

	v3ConfigAttribute, ok := attributes["v3_config"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`v3_config is missing from object`)

		return nil, diags
	}

	v3ConfigVal, ok := v3ConfigAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`v3_config expected to be basetypes.ObjectValue, was: %T`, v3ConfigAttribute))
	}

	viewsAttribute, ok := attributes["views"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`views is missing from object`)

		return nil, diags
	}

	viewsVal, ok := viewsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`views expected to be basetypes.ListValue, was: %T`, viewsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SnmpConfigValue{
		ClientList:  clientListVal,
		Contact:     contactVal,
		Description: descriptionVal,
		Enabled:     enabledVal,
		EngineId:    engineIdVal,
		Location:    locationVal,
		Name:        nameVal,
		Network:     networkVal,
		TrapGroups:  trapGroupsVal,
		V2cConfig:   v2cConfigVal,
		V3Config:    v3ConfigVal,
		Views:       viewsVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewSnmpConfigValueNull() SnmpConfigValue {
	return SnmpConfigValue{
		state: attr.ValueStateNull,
	}
}

func NewSnmpConfigValueUnknown() SnmpConfigValue {
	return SnmpConfigValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSnmpConfigValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SnmpConfigValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SnmpConfigValue Attribute Value",
				"While creating a SnmpConfigValue value, a missing attribute value was detected. "+
					"A SnmpConfigValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SnmpConfigValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SnmpConfigValue Attribute Type",
				"While creating a SnmpConfigValue value, an invalid attribute value was detected. "+
					"A SnmpConfigValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SnmpConfigValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SnmpConfigValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SnmpConfigValue Attribute Value",
				"While creating a SnmpConfigValue value, an extra attribute value was detected. "+
					"A SnmpConfigValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SnmpConfigValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSnmpConfigValueUnknown(), diags
	}

	clientListAttribute, ok := attributes["client_list"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`client_list is missing from object`)

		return NewSnmpConfigValueUnknown(), diags
	}

	clientListVal, ok := clientListAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`client_list expected to be basetypes.ListValue, was: %T`, clientListAttribute))
	}

	contactAttribute, ok := attributes["contact"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`contact is missing from object`)

		return NewSnmpConfigValueUnknown(), diags
	}

	contactVal, ok := contactAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`contact expected to be basetypes.StringValue, was: %T`, contactAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return NewSnmpConfigValueUnknown(), diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewSnmpConfigValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	engineIdAttribute, ok := attributes["engine_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`engine_id is missing from object`)

		return NewSnmpConfigValueUnknown(), diags
	}

	engineIdVal, ok := engineIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`engine_id expected to be basetypes.StringValue, was: %T`, engineIdAttribute))
	}

	locationAttribute, ok := attributes["location"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`location is missing from object`)

		return NewSnmpConfigValueUnknown(), diags
	}

	locationVal, ok := locationAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`location expected to be basetypes.StringValue, was: %T`, locationAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewSnmpConfigValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	networkAttribute, ok := attributes["network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`network is missing from object`)

		return NewSnmpConfigValueUnknown(), diags
	}

	networkVal, ok := networkAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`network expected to be basetypes.StringValue, was: %T`, networkAttribute))
	}

	trapGroupsAttribute, ok := attributes["trap_groups"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`trap_groups is missing from object`)

		return NewSnmpConfigValueUnknown(), diags
	}

	trapGroupsVal, ok := trapGroupsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`trap_groups expected to be basetypes.ListValue, was: %T`, trapGroupsAttribute))
	}

	v2cConfigAttribute, ok := attributes["v2c_config"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`v2c_config is missing from object`)

		return NewSnmpConfigValueUnknown(), diags
	}

	v2cConfigVal, ok := v2cConfigAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`v2c_config expected to be basetypes.ListValue, was: %T`, v2cConfigAttribute))
	}

	v3ConfigAttribute, ok := attributes["v3_config"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`v3_config is missing from object`)

		return NewSnmpConfigValueUnknown(), diags
	}

	v3ConfigVal, ok := v3ConfigAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`v3_config expected to be basetypes.ObjectValue, was: %T`, v3ConfigAttribute))
	}

	viewsAttribute, ok := attributes["views"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`views is missing from object`)

		return NewSnmpConfigValueUnknown(), diags
	}

	viewsVal, ok := viewsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`views expected to be basetypes.ListValue, was: %T`, viewsAttribute))
	}

	if diags.HasError() {
		return NewSnmpConfigValueUnknown(), diags
	}

	return SnmpConfigValue{
		ClientList:  clientListVal,
		Contact:     contactVal,
		Description: descriptionVal,
		Enabled:     enabledVal,
		EngineId:    engineIdVal,
		Location:    locationVal,
		Name:        nameVal,
		Network:     networkVal,
		TrapGroups:  trapGroupsVal,
		V2cConfig:   v2cConfigVal,
		V3Config:    v3ConfigVal,
		Views:       viewsVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewSnmpConfigValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SnmpConfigValue {
	object, diags := NewSnmpConfigValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSnmpConfigValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SnmpConfigType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSnmpConfigValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSnmpConfigValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSnmpConfigValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSnmpConfigValueMust(SnmpConfigValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SnmpConfigType) ValueType(ctx context.Context) attr.Value {
	return SnmpConfigValue{}
}

var _ basetypes.ObjectValuable = SnmpConfigValue{}

type SnmpConfigValue struct {
	ClientList  basetypes.ListValue   `tfsdk:"client_list"`
	Contact     basetypes.StringValue `tfsdk:"contact"`
	Description basetypes.StringValue `tfsdk:"description"`
	Enabled     basetypes.BoolValue   `tfsdk:"enabled"`
	EngineId    basetypes.StringValue `tfsdk:"engine_id"`
	Location    basetypes.StringValue `tfsdk:"location"`
	Name        basetypes.StringValue `tfsdk:"name"`
	Network     basetypes.StringValue `tfsdk:"network"`
	TrapGroups  basetypes.ListValue   `tfsdk:"trap_groups"`
	V2cConfig   basetypes.ListValue   `tfsdk:"v2c_config"`
	V3Config    basetypes.ObjectValue `tfsdk:"v3_config"`
	Views       basetypes.ListValue   `tfsdk:"views"`
	state       attr.ValueState
}

func (v SnmpConfigValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 12)

	var val tftypes.Value
	var err error

	attrTypes["client_list"] = basetypes.ListType{
		ElemType: ClientListValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["contact"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["engine_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["location"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["network"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["trap_groups"] = basetypes.ListType{
		ElemType: TrapGroupsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["v2c_config"] = basetypes.ListType{
		ElemType: V2cConfigValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["v3_config"] = basetypes.ObjectType{
		AttrTypes: V3ConfigValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["views"] = basetypes.ListType{
		ElemType: ViewsValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 12)

		val, err = v.ClientList.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["client_list"] = val

		val, err = v.Contact.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["contact"] = val

		val, err = v.Description.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["description"] = val

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.EngineId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["engine_id"] = val

		val, err = v.Location.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["location"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Network.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["network"] = val

		val, err = v.TrapGroups.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["trap_groups"] = val

		val, err = v.V2cConfig.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["v2c_config"] = val

		val, err = v.V3Config.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["v3_config"] = val

		val, err = v.Views.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["views"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SnmpConfigValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SnmpConfigValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SnmpConfigValue) String() string {
	return "SnmpConfigValue"
}

func (v SnmpConfigValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	clientList := types.ListValueMust(
		ClientListType{
			basetypes.ObjectType{
				AttrTypes: ClientListValue{}.AttributeTypes(ctx),
			},
		},
		v.ClientList.Elements(),
	)

	if v.ClientList.IsNull() {
		clientList = types.ListNull(
			ClientListType{
				basetypes.ObjectType{
					AttrTypes: ClientListValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.ClientList.IsUnknown() {
		clientList = types.ListUnknown(
			ClientListType{
				basetypes.ObjectType{
					AttrTypes: ClientListValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	trapGroups := types.ListValueMust(
		TrapGroupsType{
			basetypes.ObjectType{
				AttrTypes: TrapGroupsValue{}.AttributeTypes(ctx),
			},
		},
		v.TrapGroups.Elements(),
	)

	if v.TrapGroups.IsNull() {
		trapGroups = types.ListNull(
			TrapGroupsType{
				basetypes.ObjectType{
					AttrTypes: TrapGroupsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.TrapGroups.IsUnknown() {
		trapGroups = types.ListUnknown(
			TrapGroupsType{
				basetypes.ObjectType{
					AttrTypes: TrapGroupsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	v2cConfig := types.ListValueMust(
		V2cConfigType{
			basetypes.ObjectType{
				AttrTypes: V2cConfigValue{}.AttributeTypes(ctx),
			},
		},
		v.V2cConfig.Elements(),
	)

	if v.V2cConfig.IsNull() {
		v2cConfig = types.ListNull(
			V2cConfigType{
				basetypes.ObjectType{
					AttrTypes: V2cConfigValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.V2cConfig.IsUnknown() {
		v2cConfig = types.ListUnknown(
			V2cConfigType{
				basetypes.ObjectType{
					AttrTypes: V2cConfigValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var v3Config basetypes.ObjectValue

	if v.V3Config.IsNull() {
		v3Config = types.ObjectNull(
			V3ConfigValue{}.AttributeTypes(ctx),
		)
	}

	if v.V3Config.IsUnknown() {
		v3Config = types.ObjectUnknown(
			V3ConfigValue{}.AttributeTypes(ctx),
		)
	}

	if !v.V3Config.IsNull() && !v.V3Config.IsUnknown() {
		v3Config = types.ObjectValueMust(
			V3ConfigValue{}.AttributeTypes(ctx),
			v.V3Config.Attributes(),
		)
	}

	views := types.ListValueMust(
		ViewsType{
			basetypes.ObjectType{
				AttrTypes: ViewsValue{}.AttributeTypes(ctx),
			},
		},
		v.Views.Elements(),
	)

	if v.Views.IsNull() {
		views = types.ListNull(
			ViewsType{
				basetypes.ObjectType{
					AttrTypes: ViewsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Views.IsUnknown() {
		views = types.ListUnknown(
			ViewsType{
				basetypes.ObjectType{
					AttrTypes: ViewsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"client_list": basetypes.ListType{
			ElemType: ClientListValue{}.Type(ctx),
		},
		"contact":     basetypes.StringType{},
		"description": basetypes.StringType{},
		"enabled":     basetypes.BoolType{},
		"engine_id":   basetypes.StringType{},
		"location":    basetypes.StringType{},
		"name":        basetypes.StringType{},
		"network":     basetypes.StringType{},
		"trap_groups": basetypes.ListType{
			ElemType: TrapGroupsValue{}.Type(ctx),
		},
		"v2c_config": basetypes.ListType{
			ElemType: V2cConfigValue{}.Type(ctx),
		},
		"v3_config": basetypes.ObjectType{
			AttrTypes: V3ConfigValue{}.AttributeTypes(ctx),
		},
		"views": basetypes.ListType{
			ElemType: ViewsValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"client_list": clientList,
			"contact":     v.Contact,
			"description": v.Description,
			"enabled":     v.Enabled,
			"engine_id":   v.EngineId,
			"location":    v.Location,
			"name":        v.Name,
			"network":     v.Network,
			"trap_groups": trapGroups,
			"v2c_config":  v2cConfig,
			"v3_config":   v3Config,
			"views":       views,
		})

	return objVal, diags
}

func (v SnmpConfigValue) Equal(o attr.Value) bool {
	other, ok := o.(SnmpConfigValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.ClientList.Equal(other.ClientList) {
		return false
	}

	if !v.Contact.Equal(other.Contact) {
		return false
	}

	if !v.Description.Equal(other.Description) {
		return false
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.EngineId.Equal(other.EngineId) {
		return false
	}

	if !v.Location.Equal(other.Location) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Network.Equal(other.Network) {
		return false
	}

	if !v.TrapGroups.Equal(other.TrapGroups) {
		return false
	}

	if !v.V2cConfig.Equal(other.V2cConfig) {
		return false
	}

	if !v.V3Config.Equal(other.V3Config) {
		return false
	}

	if !v.Views.Equal(other.Views) {
		return false
	}

	return true
}

func (v SnmpConfigValue) Type(ctx context.Context) attr.Type {
	return SnmpConfigType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SnmpConfigValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"client_list": basetypes.ListType{
			ElemType: ClientListValue{}.Type(ctx),
		},
		"contact":     basetypes.StringType{},
		"description": basetypes.StringType{},
		"enabled":     basetypes.BoolType{},
		"engine_id":   basetypes.StringType{},
		"location":    basetypes.StringType{},
		"name":        basetypes.StringType{},
		"network":     basetypes.StringType{},
		"trap_groups": basetypes.ListType{
			ElemType: TrapGroupsValue{}.Type(ctx),
		},
		"v2c_config": basetypes.ListType{
			ElemType: V2cConfigValue{}.Type(ctx),
		},
		"v3_config": basetypes.ObjectType{
			AttrTypes: V3ConfigValue{}.AttributeTypes(ctx),
		},
		"views": basetypes.ListType{
			ElemType: ViewsValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = ClientListType{}

type ClientListType struct {
	basetypes.ObjectType
}

func (t ClientListType) Equal(o attr.Type) bool {
	other, ok := o.(ClientListType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ClientListType) String() string {
	return "ClientListType"
}

func (t ClientListType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	clientListNameAttribute, ok := attributes["client_list_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`client_list_name is missing from object`)

		return nil, diags
	}

	clientListNameVal, ok := clientListNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`client_list_name expected to be basetypes.StringValue, was: %T`, clientListNameAttribute))
	}

	clientsAttribute, ok := attributes["clients"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`clients is missing from object`)

		return nil, diags
	}

	clientsVal, ok := clientsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`clients expected to be basetypes.ListValue, was: %T`, clientsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ClientListValue{
		ClientListName: clientListNameVal,
		Clients:        clientsVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewClientListValueNull() ClientListValue {
	return ClientListValue{
		state: attr.ValueStateNull,
	}
}

func NewClientListValueUnknown() ClientListValue {
	return ClientListValue{
		state: attr.ValueStateUnknown,
	}
}

func NewClientListValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ClientListValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ClientListValue Attribute Value",
				"While creating a ClientListValue value, a missing attribute value was detected. "+
					"A ClientListValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ClientListValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ClientListValue Attribute Type",
				"While creating a ClientListValue value, an invalid attribute value was detected. "+
					"A ClientListValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ClientListValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ClientListValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ClientListValue Attribute Value",
				"While creating a ClientListValue value, an extra attribute value was detected. "+
					"A ClientListValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ClientListValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewClientListValueUnknown(), diags
	}

	clientListNameAttribute, ok := attributes["client_list_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`client_list_name is missing from object`)

		return NewClientListValueUnknown(), diags
	}

	clientListNameVal, ok := clientListNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`client_list_name expected to be basetypes.StringValue, was: %T`, clientListNameAttribute))
	}

	clientsAttribute, ok := attributes["clients"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`clients is missing from object`)

		return NewClientListValueUnknown(), diags
	}

	clientsVal, ok := clientsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`clients expected to be basetypes.ListValue, was: %T`, clientsAttribute))
	}

	if diags.HasError() {
		return NewClientListValueUnknown(), diags
	}

	return ClientListValue{
		ClientListName: clientListNameVal,
		Clients:        clientsVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewClientListValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ClientListValue {
	object, diags := NewClientListValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewClientListValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ClientListType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewClientListValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewClientListValueUnknown(), nil
	}

	if in.IsNull() {
		return NewClientListValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewClientListValueMust(ClientListValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ClientListType) ValueType(ctx context.Context) attr.Value {
	return ClientListValue{}
}

var _ basetypes.ObjectValuable = ClientListValue{}

type ClientListValue struct {
	ClientListName basetypes.StringValue `tfsdk:"client_list_name"`
	Clients        basetypes.ListValue   `tfsdk:"clients"`
	state          attr.ValueState
}

func (v ClientListValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["client_list_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["clients"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.ClientListName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["client_list_name"] = val

		val, err = v.Clients.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["clients"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ClientListValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ClientListValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ClientListValue) String() string {
	return "ClientListValue"
}

func (v ClientListValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	clientsVal, d := types.ListValue(types.StringType, v.Clients.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"client_list_name": basetypes.StringType{},
			"clients": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"client_list_name": basetypes.StringType{},
		"clients": basetypes.ListType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"client_list_name": v.ClientListName,
			"clients":          clientsVal,
		})

	return objVal, diags
}

func (v ClientListValue) Equal(o attr.Value) bool {
	other, ok := o.(ClientListValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.ClientListName.Equal(other.ClientListName) {
		return false
	}

	if !v.Clients.Equal(other.Clients) {
		return false
	}

	return true
}

func (v ClientListValue) Type(ctx context.Context) attr.Type {
	return ClientListType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ClientListValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"client_list_name": basetypes.StringType{},
		"clients": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = TrapGroupsType{}

type TrapGroupsType struct {
	basetypes.ObjectType
}

func (t TrapGroupsType) Equal(o attr.Type) bool {
	other, ok := o.(TrapGroupsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t TrapGroupsType) String() string {
	return "TrapGroupsType"
}

func (t TrapGroupsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	categoriesAttribute, ok := attributes["categories"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`categories is missing from object`)

		return nil, diags
	}

	categoriesVal, ok := categoriesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`categories expected to be basetypes.ListValue, was: %T`, categoriesAttribute))
	}

	groupNameAttribute, ok := attributes["group_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`group_name is missing from object`)

		return nil, diags
	}

	groupNameVal, ok := groupNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`group_name expected to be basetypes.StringValue, was: %T`, groupNameAttribute))
	}

	targetsAttribute, ok := attributes["targets"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`targets is missing from object`)

		return nil, diags
	}

	targetsVal, ok := targetsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`targets expected to be basetypes.ListValue, was: %T`, targetsAttribute))
	}

	versionAttribute, ok := attributes["version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`version is missing from object`)

		return nil, diags
	}

	versionVal, ok := versionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`version expected to be basetypes.StringValue, was: %T`, versionAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return TrapGroupsValue{
		Categories: categoriesVal,
		GroupName:  groupNameVal,
		Targets:    targetsVal,
		Version:    versionVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewTrapGroupsValueNull() TrapGroupsValue {
	return TrapGroupsValue{
		state: attr.ValueStateNull,
	}
}

func NewTrapGroupsValueUnknown() TrapGroupsValue {
	return TrapGroupsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewTrapGroupsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (TrapGroupsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing TrapGroupsValue Attribute Value",
				"While creating a TrapGroupsValue value, a missing attribute value was detected. "+
					"A TrapGroupsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TrapGroupsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid TrapGroupsValue Attribute Type",
				"While creating a TrapGroupsValue value, an invalid attribute value was detected. "+
					"A TrapGroupsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TrapGroupsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("TrapGroupsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra TrapGroupsValue Attribute Value",
				"While creating a TrapGroupsValue value, an extra attribute value was detected. "+
					"A TrapGroupsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra TrapGroupsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewTrapGroupsValueUnknown(), diags
	}

	categoriesAttribute, ok := attributes["categories"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`categories is missing from object`)

		return NewTrapGroupsValueUnknown(), diags
	}

	categoriesVal, ok := categoriesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`categories expected to be basetypes.ListValue, was: %T`, categoriesAttribute))
	}

	groupNameAttribute, ok := attributes["group_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`group_name is missing from object`)

		return NewTrapGroupsValueUnknown(), diags
	}

	groupNameVal, ok := groupNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`group_name expected to be basetypes.StringValue, was: %T`, groupNameAttribute))
	}

	targetsAttribute, ok := attributes["targets"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`targets is missing from object`)

		return NewTrapGroupsValueUnknown(), diags
	}

	targetsVal, ok := targetsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`targets expected to be basetypes.ListValue, was: %T`, targetsAttribute))
	}

	versionAttribute, ok := attributes["version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`version is missing from object`)

		return NewTrapGroupsValueUnknown(), diags
	}

	versionVal, ok := versionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`version expected to be basetypes.StringValue, was: %T`, versionAttribute))
	}

	if diags.HasError() {
		return NewTrapGroupsValueUnknown(), diags
	}

	return TrapGroupsValue{
		Categories: categoriesVal,
		GroupName:  groupNameVal,
		Targets:    targetsVal,
		Version:    versionVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewTrapGroupsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) TrapGroupsValue {
	object, diags := NewTrapGroupsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewTrapGroupsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t TrapGroupsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewTrapGroupsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewTrapGroupsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewTrapGroupsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewTrapGroupsValueMust(TrapGroupsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t TrapGroupsType) ValueType(ctx context.Context) attr.Value {
	return TrapGroupsValue{}
}

var _ basetypes.ObjectValuable = TrapGroupsValue{}

type TrapGroupsValue struct {
	Categories basetypes.ListValue   `tfsdk:"categories"`
	GroupName  basetypes.StringValue `tfsdk:"group_name"`
	Targets    basetypes.ListValue   `tfsdk:"targets"`
	Version    basetypes.StringValue `tfsdk:"version"`
	state      attr.ValueState
}

func (v TrapGroupsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["categories"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["group_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["targets"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["version"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Categories.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["categories"] = val

		val, err = v.GroupName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["group_name"] = val

		val, err = v.Targets.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["targets"] = val

		val, err = v.Version.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["version"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v TrapGroupsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v TrapGroupsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v TrapGroupsValue) String() string {
	return "TrapGroupsValue"
}

func (v TrapGroupsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	categoriesVal, d := types.ListValue(types.StringType, v.Categories.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"categories": basetypes.ListType{
				ElemType: types.StringType,
			},
			"group_name": basetypes.StringType{},
			"targets": basetypes.ListType{
				ElemType: types.StringType,
			},
			"version": basetypes.StringType{},
		}), diags
	}

	targetsVal, d := types.ListValue(types.StringType, v.Targets.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"categories": basetypes.ListType{
				ElemType: types.StringType,
			},
			"group_name": basetypes.StringType{},
			"targets": basetypes.ListType{
				ElemType: types.StringType,
			},
			"version": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"categories": basetypes.ListType{
			ElemType: types.StringType,
		},
		"group_name": basetypes.StringType{},
		"targets": basetypes.ListType{
			ElemType: types.StringType,
		},
		"version": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"categories": categoriesVal,
			"group_name": v.GroupName,
			"targets":    targetsVal,
			"version":    v.Version,
		})

	return objVal, diags
}

func (v TrapGroupsValue) Equal(o attr.Value) bool {
	other, ok := o.(TrapGroupsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Categories.Equal(other.Categories) {
		return false
	}

	if !v.GroupName.Equal(other.GroupName) {
		return false
	}

	if !v.Targets.Equal(other.Targets) {
		return false
	}

	if !v.Version.Equal(other.Version) {
		return false
	}

	return true
}

func (v TrapGroupsValue) Type(ctx context.Context) attr.Type {
	return TrapGroupsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v TrapGroupsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"categories": basetypes.ListType{
			ElemType: types.StringType,
		},
		"group_name": basetypes.StringType{},
		"targets": basetypes.ListType{
			ElemType: types.StringType,
		},
		"version": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = V2cConfigType{}

type V2cConfigType struct {
	basetypes.ObjectType
}

func (t V2cConfigType) Equal(o attr.Type) bool {
	other, ok := o.(V2cConfigType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t V2cConfigType) String() string {
	return "V2cConfigType"
}

func (t V2cConfigType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	authorizationAttribute, ok := attributes["authorization"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`authorization is missing from object`)

		return nil, diags
	}

	authorizationVal, ok := authorizationAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`authorization expected to be basetypes.StringValue, was: %T`, authorizationAttribute))
	}

	clientListNameAttribute, ok := attributes["client_list_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`client_list_name is missing from object`)

		return nil, diags
	}

	clientListNameVal, ok := clientListNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`client_list_name expected to be basetypes.StringValue, was: %T`, clientListNameAttribute))
	}

	communityNameAttribute, ok := attributes["community_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`community_name is missing from object`)

		return nil, diags
	}

	communityNameVal, ok := communityNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`community_name expected to be basetypes.StringValue, was: %T`, communityNameAttribute))
	}

	viewAttribute, ok := attributes["view"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`view is missing from object`)

		return nil, diags
	}

	viewVal, ok := viewAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`view expected to be basetypes.StringValue, was: %T`, viewAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return V2cConfigValue{
		Authorization:  authorizationVal,
		ClientListName: clientListNameVal,
		CommunityName:  communityNameVal,
		View:           viewVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewV2cConfigValueNull() V2cConfigValue {
	return V2cConfigValue{
		state: attr.ValueStateNull,
	}
}

func NewV2cConfigValueUnknown() V2cConfigValue {
	return V2cConfigValue{
		state: attr.ValueStateUnknown,
	}
}

func NewV2cConfigValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (V2cConfigValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing V2cConfigValue Attribute Value",
				"While creating a V2cConfigValue value, a missing attribute value was detected. "+
					"A V2cConfigValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("V2cConfigValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid V2cConfigValue Attribute Type",
				"While creating a V2cConfigValue value, an invalid attribute value was detected. "+
					"A V2cConfigValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("V2cConfigValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("V2cConfigValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra V2cConfigValue Attribute Value",
				"While creating a V2cConfigValue value, an extra attribute value was detected. "+
					"A V2cConfigValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra V2cConfigValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewV2cConfigValueUnknown(), diags
	}

	authorizationAttribute, ok := attributes["authorization"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`authorization is missing from object`)

		return NewV2cConfigValueUnknown(), diags
	}

	authorizationVal, ok := authorizationAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`authorization expected to be basetypes.StringValue, was: %T`, authorizationAttribute))
	}

	clientListNameAttribute, ok := attributes["client_list_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`client_list_name is missing from object`)

		return NewV2cConfigValueUnknown(), diags
	}

	clientListNameVal, ok := clientListNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`client_list_name expected to be basetypes.StringValue, was: %T`, clientListNameAttribute))
	}

	communityNameAttribute, ok := attributes["community_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`community_name is missing from object`)

		return NewV2cConfigValueUnknown(), diags
	}

	communityNameVal, ok := communityNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`community_name expected to be basetypes.StringValue, was: %T`, communityNameAttribute))
	}

	viewAttribute, ok := attributes["view"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`view is missing from object`)

		return NewV2cConfigValueUnknown(), diags
	}

	viewVal, ok := viewAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`view expected to be basetypes.StringValue, was: %T`, viewAttribute))
	}

	if diags.HasError() {
		return NewV2cConfigValueUnknown(), diags
	}

	return V2cConfigValue{
		Authorization:  authorizationVal,
		ClientListName: clientListNameVal,
		CommunityName:  communityNameVal,
		View:           viewVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewV2cConfigValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) V2cConfigValue {
	object, diags := NewV2cConfigValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewV2cConfigValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t V2cConfigType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewV2cConfigValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewV2cConfigValueUnknown(), nil
	}

	if in.IsNull() {
		return NewV2cConfigValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewV2cConfigValueMust(V2cConfigValue{}.AttributeTypes(ctx), attributes), nil
}

func (t V2cConfigType) ValueType(ctx context.Context) attr.Value {
	return V2cConfigValue{}
}

var _ basetypes.ObjectValuable = V2cConfigValue{}

type V2cConfigValue struct {
	Authorization  basetypes.StringValue `tfsdk:"authorization"`
	ClientListName basetypes.StringValue `tfsdk:"client_list_name"`
	CommunityName  basetypes.StringValue `tfsdk:"community_name"`
	View           basetypes.StringValue `tfsdk:"view"`
	state          attr.ValueState
}

func (v V2cConfigValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["authorization"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["client_list_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["community_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["view"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Authorization.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["authorization"] = val

		val, err = v.ClientListName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["client_list_name"] = val

		val, err = v.CommunityName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["community_name"] = val

		val, err = v.View.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["view"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v V2cConfigValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v V2cConfigValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v V2cConfigValue) String() string {
	return "V2cConfigValue"
}

func (v V2cConfigValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"authorization":    basetypes.StringType{},
		"client_list_name": basetypes.StringType{},
		"community_name":   basetypes.StringType{},
		"view":             basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"authorization":    v.Authorization,
			"client_list_name": v.ClientListName,
			"community_name":   v.CommunityName,
			"view":             v.View,
		})

	return objVal, diags
}

func (v V2cConfigValue) Equal(o attr.Value) bool {
	other, ok := o.(V2cConfigValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Authorization.Equal(other.Authorization) {
		return false
	}

	if !v.ClientListName.Equal(other.ClientListName) {
		return false
	}

	if !v.CommunityName.Equal(other.CommunityName) {
		return false
	}

	if !v.View.Equal(other.View) {
		return false
	}

	return true
}

func (v V2cConfigValue) Type(ctx context.Context) attr.Type {
	return V2cConfigType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v V2cConfigValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"authorization":    basetypes.StringType{},
		"client_list_name": basetypes.StringType{},
		"community_name":   basetypes.StringType{},
		"view":             basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = V3ConfigType{}

type V3ConfigType struct {
	basetypes.ObjectType
}

func (t V3ConfigType) Equal(o attr.Type) bool {
	other, ok := o.(V3ConfigType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t V3ConfigType) String() string {
	return "V3ConfigType"
}

func (t V3ConfigType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	notifyAttribute, ok := attributes["notify"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`notify is missing from object`)

		return nil, diags
	}

	notifyVal, ok := notifyAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`notify expected to be basetypes.ListValue, was: %T`, notifyAttribute))
	}

	notifyFilterAttribute, ok := attributes["notify_filter"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`notify_filter is missing from object`)

		return nil, diags
	}

	notifyFilterVal, ok := notifyFilterAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`notify_filter expected to be basetypes.ListValue, was: %T`, notifyFilterAttribute))
	}

	targetAddressAttribute, ok := attributes["target_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`target_address is missing from object`)

		return nil, diags
	}

	targetAddressVal, ok := targetAddressAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`target_address expected to be basetypes.ListValue, was: %T`, targetAddressAttribute))
	}

	targetParametersAttribute, ok := attributes["target_parameters"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`target_parameters is missing from object`)

		return nil, diags
	}

	targetParametersVal, ok := targetParametersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`target_parameters expected to be basetypes.ListValue, was: %T`, targetParametersAttribute))
	}

	usmAttribute, ok := attributes["usm"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`usm is missing from object`)

		return nil, diags
	}

	usmVal, ok := usmAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`usm expected to be basetypes.ObjectValue, was: %T`, usmAttribute))
	}

	vacmAttribute, ok := attributes["vacm"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vacm is missing from object`)

		return nil, diags
	}

	vacmVal, ok := vacmAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vacm expected to be basetypes.ObjectValue, was: %T`, vacmAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return V3ConfigValue{
		Notify:           notifyVal,
		NotifyFilter:     notifyFilterVal,
		TargetAddress:    targetAddressVal,
		TargetParameters: targetParametersVal,
		Usm:              usmVal,
		Vacm:             vacmVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewV3ConfigValueNull() V3ConfigValue {
	return V3ConfigValue{
		state: attr.ValueStateNull,
	}
}

func NewV3ConfigValueUnknown() V3ConfigValue {
	return V3ConfigValue{
		state: attr.ValueStateUnknown,
	}
}

func NewV3ConfigValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (V3ConfigValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing V3ConfigValue Attribute Value",
				"While creating a V3ConfigValue value, a missing attribute value was detected. "+
					"A V3ConfigValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("V3ConfigValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid V3ConfigValue Attribute Type",
				"While creating a V3ConfigValue value, an invalid attribute value was detected. "+
					"A V3ConfigValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("V3ConfigValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("V3ConfigValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra V3ConfigValue Attribute Value",
				"While creating a V3ConfigValue value, an extra attribute value was detected. "+
					"A V3ConfigValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra V3ConfigValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewV3ConfigValueUnknown(), diags
	}

	notifyAttribute, ok := attributes["notify"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`notify is missing from object`)

		return NewV3ConfigValueUnknown(), diags
	}

	notifyVal, ok := notifyAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`notify expected to be basetypes.ListValue, was: %T`, notifyAttribute))
	}

	notifyFilterAttribute, ok := attributes["notify_filter"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`notify_filter is missing from object`)

		return NewV3ConfigValueUnknown(), diags
	}

	notifyFilterVal, ok := notifyFilterAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`notify_filter expected to be basetypes.ListValue, was: %T`, notifyFilterAttribute))
	}

	targetAddressAttribute, ok := attributes["target_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`target_address is missing from object`)

		return NewV3ConfigValueUnknown(), diags
	}

	targetAddressVal, ok := targetAddressAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`target_address expected to be basetypes.ListValue, was: %T`, targetAddressAttribute))
	}

	targetParametersAttribute, ok := attributes["target_parameters"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`target_parameters is missing from object`)

		return NewV3ConfigValueUnknown(), diags
	}

	targetParametersVal, ok := targetParametersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`target_parameters expected to be basetypes.ListValue, was: %T`, targetParametersAttribute))
	}

	usmAttribute, ok := attributes["usm"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`usm is missing from object`)

		return NewV3ConfigValueUnknown(), diags
	}

	usmVal, ok := usmAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`usm expected to be basetypes.ObjectValue, was: %T`, usmAttribute))
	}

	vacmAttribute, ok := attributes["vacm"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vacm is missing from object`)

		return NewV3ConfigValueUnknown(), diags
	}

	vacmVal, ok := vacmAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vacm expected to be basetypes.ObjectValue, was: %T`, vacmAttribute))
	}

	if diags.HasError() {
		return NewV3ConfigValueUnknown(), diags
	}

	return V3ConfigValue{
		Notify:           notifyVal,
		NotifyFilter:     notifyFilterVal,
		TargetAddress:    targetAddressVal,
		TargetParameters: targetParametersVal,
		Usm:              usmVal,
		Vacm:             vacmVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewV3ConfigValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) V3ConfigValue {
	object, diags := NewV3ConfigValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewV3ConfigValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t V3ConfigType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewV3ConfigValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewV3ConfigValueUnknown(), nil
	}

	if in.IsNull() {
		return NewV3ConfigValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewV3ConfigValueMust(V3ConfigValue{}.AttributeTypes(ctx), attributes), nil
}

func (t V3ConfigType) ValueType(ctx context.Context) attr.Value {
	return V3ConfigValue{}
}

var _ basetypes.ObjectValuable = V3ConfigValue{}

type V3ConfigValue struct {
	Notify           basetypes.ListValue   `tfsdk:"notify"`
	NotifyFilter     basetypes.ListValue   `tfsdk:"notify_filter"`
	TargetAddress    basetypes.ListValue   `tfsdk:"target_address"`
	TargetParameters basetypes.ListValue   `tfsdk:"target_parameters"`
	Usm              basetypes.ObjectValue `tfsdk:"usm"`
	Vacm             basetypes.ObjectValue `tfsdk:"vacm"`
	state            attr.ValueState
}

func (v V3ConfigValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 6)

	var val tftypes.Value
	var err error

	attrTypes["notify"] = basetypes.ListType{
		ElemType: NotifyValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["notify_filter"] = basetypes.ListType{
		ElemType: NotifyFilterValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["target_address"] = basetypes.ListType{
		ElemType: TargetAddressValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["target_parameters"] = basetypes.ListType{
		ElemType: TargetParametersValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["usm"] = basetypes.ObjectType{
		AttrTypes: UsmValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["vacm"] = basetypes.ObjectType{
		AttrTypes: VacmValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 6)

		val, err = v.Notify.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["notify"] = val

		val, err = v.NotifyFilter.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["notify_filter"] = val

		val, err = v.TargetAddress.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["target_address"] = val

		val, err = v.TargetParameters.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["target_parameters"] = val

		val, err = v.Usm.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["usm"] = val

		val, err = v.Vacm.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vacm"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v V3ConfigValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v V3ConfigValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v V3ConfigValue) String() string {
	return "V3ConfigValue"
}

func (v V3ConfigValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	notify := types.ListValueMust(
		NotifyType{
			basetypes.ObjectType{
				AttrTypes: NotifyValue{}.AttributeTypes(ctx),
			},
		},
		v.Notify.Elements(),
	)

	if v.Notify.IsNull() {
		notify = types.ListNull(
			NotifyType{
				basetypes.ObjectType{
					AttrTypes: NotifyValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Notify.IsUnknown() {
		notify = types.ListUnknown(
			NotifyType{
				basetypes.ObjectType{
					AttrTypes: NotifyValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	notifyFilter := types.ListValueMust(
		NotifyFilterType{
			basetypes.ObjectType{
				AttrTypes: NotifyFilterValue{}.AttributeTypes(ctx),
			},
		},
		v.NotifyFilter.Elements(),
	)

	if v.NotifyFilter.IsNull() {
		notifyFilter = types.ListNull(
			NotifyFilterType{
				basetypes.ObjectType{
					AttrTypes: NotifyFilterValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.NotifyFilter.IsUnknown() {
		notifyFilter = types.ListUnknown(
			NotifyFilterType{
				basetypes.ObjectType{
					AttrTypes: NotifyFilterValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	targetAddress := types.ListValueMust(
		TargetAddressType{
			basetypes.ObjectType{
				AttrTypes: TargetAddressValue{}.AttributeTypes(ctx),
			},
		},
		v.TargetAddress.Elements(),
	)

	if v.TargetAddress.IsNull() {
		targetAddress = types.ListNull(
			TargetAddressType{
				basetypes.ObjectType{
					AttrTypes: TargetAddressValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.TargetAddress.IsUnknown() {
		targetAddress = types.ListUnknown(
			TargetAddressType{
				basetypes.ObjectType{
					AttrTypes: TargetAddressValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	targetParameters := types.ListValueMust(
		TargetParametersType{
			basetypes.ObjectType{
				AttrTypes: TargetParametersValue{}.AttributeTypes(ctx),
			},
		},
		v.TargetParameters.Elements(),
	)

	if v.TargetParameters.IsNull() {
		targetParameters = types.ListNull(
			TargetParametersType{
				basetypes.ObjectType{
					AttrTypes: TargetParametersValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.TargetParameters.IsUnknown() {
		targetParameters = types.ListUnknown(
			TargetParametersType{
				basetypes.ObjectType{
					AttrTypes: TargetParametersValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var usm basetypes.ObjectValue

	if v.Usm.IsNull() {
		usm = types.ObjectNull(
			UsmValue{}.AttributeTypes(ctx),
		)
	}

	if v.Usm.IsUnknown() {
		usm = types.ObjectUnknown(
			UsmValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Usm.IsNull() && !v.Usm.IsUnknown() {
		usm = types.ObjectValueMust(
			UsmValue{}.AttributeTypes(ctx),
			v.Usm.Attributes(),
		)
	}

	var vacm basetypes.ObjectValue

	if v.Vacm.IsNull() {
		vacm = types.ObjectNull(
			VacmValue{}.AttributeTypes(ctx),
		)
	}

	if v.Vacm.IsUnknown() {
		vacm = types.ObjectUnknown(
			VacmValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Vacm.IsNull() && !v.Vacm.IsUnknown() {
		vacm = types.ObjectValueMust(
			VacmValue{}.AttributeTypes(ctx),
			v.Vacm.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"notify": basetypes.ListType{
			ElemType: NotifyValue{}.Type(ctx),
		},
		"notify_filter": basetypes.ListType{
			ElemType: NotifyFilterValue{}.Type(ctx),
		},
		"target_address": basetypes.ListType{
			ElemType: TargetAddressValue{}.Type(ctx),
		},
		"target_parameters": basetypes.ListType{
			ElemType: TargetParametersValue{}.Type(ctx),
		},
		"usm": basetypes.ObjectType{
			AttrTypes: UsmValue{}.AttributeTypes(ctx),
		},
		"vacm": basetypes.ObjectType{
			AttrTypes: VacmValue{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"notify":            notify,
			"notify_filter":     notifyFilter,
			"target_address":    targetAddress,
			"target_parameters": targetParameters,
			"usm":               usm,
			"vacm":              vacm,
		})

	return objVal, diags
}

func (v V3ConfigValue) Equal(o attr.Value) bool {
	other, ok := o.(V3ConfigValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Notify.Equal(other.Notify) {
		return false
	}

	if !v.NotifyFilter.Equal(other.NotifyFilter) {
		return false
	}

	if !v.TargetAddress.Equal(other.TargetAddress) {
		return false
	}

	if !v.TargetParameters.Equal(other.TargetParameters) {
		return false
	}

	if !v.Usm.Equal(other.Usm) {
		return false
	}

	if !v.Vacm.Equal(other.Vacm) {
		return false
	}

	return true
}

func (v V3ConfigValue) Type(ctx context.Context) attr.Type {
	return V3ConfigType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v V3ConfigValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"notify": basetypes.ListType{
			ElemType: NotifyValue{}.Type(ctx),
		},
		"notify_filter": basetypes.ListType{
			ElemType: NotifyFilterValue{}.Type(ctx),
		},
		"target_address": basetypes.ListType{
			ElemType: TargetAddressValue{}.Type(ctx),
		},
		"target_parameters": basetypes.ListType{
			ElemType: TargetParametersValue{}.Type(ctx),
		},
		"usm": basetypes.ObjectType{
			AttrTypes: UsmValue{}.AttributeTypes(ctx),
		},
		"vacm": basetypes.ObjectType{
			AttrTypes: VacmValue{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = NotifyType{}

type NotifyType struct {
	basetypes.ObjectType
}

func (t NotifyType) Equal(o attr.Type) bool {
	other, ok := o.(NotifyType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t NotifyType) String() string {
	return "NotifyType"
}

func (t NotifyType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	tagAttribute, ok := attributes["tag"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tag is missing from object`)

		return nil, diags
	}

	tagVal, ok := tagAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tag expected to be basetypes.StringValue, was: %T`, tagAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return NotifyValue{
		Name:       nameVal,
		Tag:        tagVal,
		NotifyType: typeVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewNotifyValueNull() NotifyValue {
	return NotifyValue{
		state: attr.ValueStateNull,
	}
}

func NewNotifyValueUnknown() NotifyValue {
	return NotifyValue{
		state: attr.ValueStateUnknown,
	}
}

func NewNotifyValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (NotifyValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing NotifyValue Attribute Value",
				"While creating a NotifyValue value, a missing attribute value was detected. "+
					"A NotifyValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NotifyValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid NotifyValue Attribute Type",
				"While creating a NotifyValue value, an invalid attribute value was detected. "+
					"A NotifyValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NotifyValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("NotifyValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra NotifyValue Attribute Value",
				"While creating a NotifyValue value, an extra attribute value was detected. "+
					"A NotifyValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra NotifyValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewNotifyValueUnknown(), diags
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewNotifyValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	tagAttribute, ok := attributes["tag"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tag is missing from object`)

		return NewNotifyValueUnknown(), diags
	}

	tagVal, ok := tagAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tag expected to be basetypes.StringValue, was: %T`, tagAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewNotifyValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return NewNotifyValueUnknown(), diags
	}

	return NotifyValue{
		Name:       nameVal,
		Tag:        tagVal,
		NotifyType: typeVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewNotifyValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) NotifyValue {
	object, diags := NewNotifyValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewNotifyValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t NotifyType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewNotifyValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewNotifyValueUnknown(), nil
	}

	if in.IsNull() {
		return NewNotifyValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewNotifyValueMust(NotifyValue{}.AttributeTypes(ctx), attributes), nil
}

func (t NotifyType) ValueType(ctx context.Context) attr.Value {
	return NotifyValue{}
}

var _ basetypes.ObjectValuable = NotifyValue{}

type NotifyValue struct {
	Name       basetypes.StringValue `tfsdk:"name"`
	Tag        basetypes.StringValue `tfsdk:"tag"`
	NotifyType basetypes.StringValue `tfsdk:"type"`
	state      attr.ValueState
}

func (v NotifyValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["tag"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Tag.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tag"] = val

		val, err = v.NotifyType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v NotifyValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v NotifyValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v NotifyValue) String() string {
	return "NotifyValue"
}

func (v NotifyValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"name": basetypes.StringType{},
		"tag":  basetypes.StringType{},
		"type": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"name": v.Name,
			"tag":  v.Tag,
			"type": v.NotifyType,
		})

	return objVal, diags
}

func (v NotifyValue) Equal(o attr.Value) bool {
	other, ok := o.(NotifyValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Tag.Equal(other.Tag) {
		return false
	}

	if !v.NotifyType.Equal(other.NotifyType) {
		return false
	}

	return true
}

func (v NotifyValue) Type(ctx context.Context) attr.Type {
	return NotifyType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v NotifyValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"name": basetypes.StringType{},
		"tag":  basetypes.StringType{},
		"type": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = NotifyFilterType{}

type NotifyFilterType struct {
	basetypes.ObjectType
}

func (t NotifyFilterType) Equal(o attr.Type) bool {
	other, ok := o.(NotifyFilterType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t NotifyFilterType) String() string {
	return "NotifyFilterType"
}

func (t NotifyFilterType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	profileNameAttribute, ok := attributes["profile_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`profile_name is missing from object`)

		return nil, diags
	}

	profileNameVal, ok := profileNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`profile_name expected to be basetypes.StringValue, was: %T`, profileNameAttribute))
	}

	snmpv3ContentsAttribute, ok := attributes["contents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`contents is missing from object`)

		return nil, diags
	}

	snmpv3ContentsVal, ok := snmpv3ContentsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`contents expected to be basetypes.ListValue, was: %T`, snmpv3ContentsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return NotifyFilterValue{
		ProfileName:    profileNameVal,
		Snmpv3Contents: snmpv3ContentsVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewNotifyFilterValueNull() NotifyFilterValue {
	return NotifyFilterValue{
		state: attr.ValueStateNull,
	}
}

func NewNotifyFilterValueUnknown() NotifyFilterValue {
	return NotifyFilterValue{
		state: attr.ValueStateUnknown,
	}
}

func NewNotifyFilterValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (NotifyFilterValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing NotifyFilterValue Attribute Value",
				"While creating a NotifyFilterValue value, a missing attribute value was detected. "+
					"A NotifyFilterValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NotifyFilterValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid NotifyFilterValue Attribute Type",
				"While creating a NotifyFilterValue value, an invalid attribute value was detected. "+
					"A NotifyFilterValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NotifyFilterValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("NotifyFilterValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra NotifyFilterValue Attribute Value",
				"While creating a NotifyFilterValue value, an extra attribute value was detected. "+
					"A NotifyFilterValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra NotifyFilterValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewNotifyFilterValueUnknown(), diags
	}

	profileNameAttribute, ok := attributes["profile_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`profile_name is missing from object`)

		return NewNotifyFilterValueUnknown(), diags
	}

	profileNameVal, ok := profileNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`profile_name expected to be basetypes.StringValue, was: %T`, profileNameAttribute))
	}

	snmpv3ContentsAttribute, ok := attributes["contents"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`contents is missing from object`)

		return NewNotifyFilterValueUnknown(), diags
	}

	snmpv3ContentsVal, ok := snmpv3ContentsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`contents expected to be basetypes.ListValue, was: %T`, snmpv3ContentsAttribute))
	}

	if diags.HasError() {
		return NewNotifyFilterValueUnknown(), diags
	}

	return NotifyFilterValue{
		ProfileName:    profileNameVal,
		Snmpv3Contents: snmpv3ContentsVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewNotifyFilterValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) NotifyFilterValue {
	object, diags := NewNotifyFilterValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewNotifyFilterValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t NotifyFilterType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewNotifyFilterValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewNotifyFilterValueUnknown(), nil
	}

	if in.IsNull() {
		return NewNotifyFilterValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewNotifyFilterValueMust(NotifyFilterValue{}.AttributeTypes(ctx), attributes), nil
}

func (t NotifyFilterType) ValueType(ctx context.Context) attr.Value {
	return NotifyFilterValue{}
}

var _ basetypes.ObjectValuable = NotifyFilterValue{}

type NotifyFilterValue struct {
	ProfileName    basetypes.StringValue `tfsdk:"profile_name"`
	Snmpv3Contents basetypes.ListValue   `tfsdk:"contents"`
	state          attr.ValueState
}

func (v NotifyFilterValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["profile_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["contents"] = basetypes.ListType{
		ElemType: Snmpv3ContentsValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.ProfileName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["profile_name"] = val

		val, err = v.Snmpv3Contents.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["contents"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v NotifyFilterValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v NotifyFilterValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v NotifyFilterValue) String() string {
	return "NotifyFilterValue"
}

func (v NotifyFilterValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	snmpv3Contents := types.ListValueMust(
		Snmpv3ContentsType{
			basetypes.ObjectType{
				AttrTypes: Snmpv3ContentsValue{}.AttributeTypes(ctx),
			},
		},
		v.Snmpv3Contents.Elements(),
	)

	if v.Snmpv3Contents.IsNull() {
		snmpv3Contents = types.ListNull(
			Snmpv3ContentsType{
				basetypes.ObjectType{
					AttrTypes: Snmpv3ContentsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Snmpv3Contents.IsUnknown() {
		snmpv3Contents = types.ListUnknown(
			Snmpv3ContentsType{
				basetypes.ObjectType{
					AttrTypes: Snmpv3ContentsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"profile_name": basetypes.StringType{},
		"contents": basetypes.ListType{
			ElemType: Snmpv3ContentsValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"profile_name":    v.ProfileName,
			"contents": snmpv3Contents,
		})

	return objVal, diags
}

func (v NotifyFilterValue) Equal(o attr.Value) bool {
	other, ok := o.(NotifyFilterValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.ProfileName.Equal(other.ProfileName) {
		return false
	}

	if !v.Snmpv3Contents.Equal(other.Snmpv3Contents) {
		return false
	}

	return true
}

func (v NotifyFilterValue) Type(ctx context.Context) attr.Type {
	return NotifyFilterType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v NotifyFilterValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"profile_name": basetypes.StringType{},
		"contents": basetypes.ListType{
			ElemType: Snmpv3ContentsValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = Snmpv3ContentsType{}

type Snmpv3ContentsType struct {
	basetypes.ObjectType
}

func (t Snmpv3ContentsType) Equal(o attr.Type) bool {
	other, ok := o.(Snmpv3ContentsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Snmpv3ContentsType) String() string {
	return "Snmpv3ContentsType"
}

func (t Snmpv3ContentsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	includeAttribute, ok := attributes["include"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`include is missing from object`)

		return nil, diags
	}

	includeVal, ok := includeAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`include expected to be basetypes.BoolValue, was: %T`, includeAttribute))
	}

	oidAttribute, ok := attributes["oid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`oid is missing from object`)

		return nil, diags
	}

	oidVal, ok := oidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`oid expected to be basetypes.StringValue, was: %T`, oidAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Snmpv3ContentsValue{
		Include: includeVal,
		Oid:     oidVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewSnmpv3ContentsValueNull() Snmpv3ContentsValue {
	return Snmpv3ContentsValue{
		state: attr.ValueStateNull,
	}
}

func NewSnmpv3ContentsValueUnknown() Snmpv3ContentsValue {
	return Snmpv3ContentsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSnmpv3ContentsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Snmpv3ContentsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Snmpv3ContentsValue Attribute Value",
				"While creating a Snmpv3ContentsValue value, a missing attribute value was detected. "+
					"A Snmpv3ContentsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Snmpv3ContentsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Snmpv3ContentsValue Attribute Type",
				"While creating a Snmpv3ContentsValue value, an invalid attribute value was detected. "+
					"A Snmpv3ContentsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Snmpv3ContentsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Snmpv3ContentsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Snmpv3ContentsValue Attribute Value",
				"While creating a Snmpv3ContentsValue value, an extra attribute value was detected. "+
					"A Snmpv3ContentsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Snmpv3ContentsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSnmpv3ContentsValueUnknown(), diags
	}

	includeAttribute, ok := attributes["include"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`include is missing from object`)

		return NewSnmpv3ContentsValueUnknown(), diags
	}

	includeVal, ok := includeAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`include expected to be basetypes.BoolValue, was: %T`, includeAttribute))
	}

	oidAttribute, ok := attributes["oid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`oid is missing from object`)

		return NewSnmpv3ContentsValueUnknown(), diags
	}

	oidVal, ok := oidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`oid expected to be basetypes.StringValue, was: %T`, oidAttribute))
	}

	if diags.HasError() {
		return NewSnmpv3ContentsValueUnknown(), diags
	}

	return Snmpv3ContentsValue{
		Include: includeVal,
		Oid:     oidVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewSnmpv3ContentsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Snmpv3ContentsValue {
	object, diags := NewSnmpv3ContentsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSnmpv3ContentsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Snmpv3ContentsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSnmpv3ContentsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSnmpv3ContentsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSnmpv3ContentsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSnmpv3ContentsValueMust(Snmpv3ContentsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t Snmpv3ContentsType) ValueType(ctx context.Context) attr.Value {
	return Snmpv3ContentsValue{}
}

var _ basetypes.ObjectValuable = Snmpv3ContentsValue{}

type Snmpv3ContentsValue struct {
	Include basetypes.BoolValue   `tfsdk:"include"`
	Oid     basetypes.StringValue `tfsdk:"oid"`
	state   attr.ValueState
}

func (v Snmpv3ContentsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["include"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["oid"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Include.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["include"] = val

		val, err = v.Oid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["oid"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Snmpv3ContentsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Snmpv3ContentsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Snmpv3ContentsValue) String() string {
	return "Snmpv3ContentsValue"
}

func (v Snmpv3ContentsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"include": basetypes.BoolType{},
		"oid":     basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"include": v.Include,
			"oid":     v.Oid,
		})

	return objVal, diags
}

func (v Snmpv3ContentsValue) Equal(o attr.Value) bool {
	other, ok := o.(Snmpv3ContentsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Include.Equal(other.Include) {
		return false
	}

	if !v.Oid.Equal(other.Oid) {
		return false
	}

	return true
}

func (v Snmpv3ContentsValue) Type(ctx context.Context) attr.Type {
	return Snmpv3ContentsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Snmpv3ContentsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"include": basetypes.BoolType{},
		"oid":     basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = TargetAddressType{}

type TargetAddressType struct {
	basetypes.ObjectType
}

func (t TargetAddressType) Equal(o attr.Type) bool {
	other, ok := o.(TargetAddressType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t TargetAddressType) String() string {
	return "TargetAddressType"
}

func (t TargetAddressType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	addressAttribute, ok := attributes["address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`address is missing from object`)

		return nil, diags
	}

	addressVal, ok := addressAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`address expected to be basetypes.StringValue, was: %T`, addressAttribute))
	}

	addressMaskAttribute, ok := attributes["address_mask"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`address_mask is missing from object`)

		return nil, diags
	}

	addressMaskVal, ok := addressMaskAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`address_mask expected to be basetypes.StringValue, was: %T`, addressMaskAttribute))
	}

	portAttribute, ok := attributes["port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port is missing from object`)

		return nil, diags
	}

	portVal, ok := portAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port expected to be basetypes.Int64Value, was: %T`, portAttribute))
	}

	tagListAttribute, ok := attributes["tag_list"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tag_list is missing from object`)

		return nil, diags
	}

	tagListVal, ok := tagListAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tag_list expected to be basetypes.StringValue, was: %T`, tagListAttribute))
	}

	targetAddressNameAttribute, ok := attributes["target_address_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`target_address_name is missing from object`)

		return nil, diags
	}

	targetAddressNameVal, ok := targetAddressNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`target_address_name expected to be basetypes.StringValue, was: %T`, targetAddressNameAttribute))
	}

	targetParametersAttribute, ok := attributes["target_parameters"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`target_parameters is missing from object`)

		return nil, diags
	}

	targetParametersVal, ok := targetParametersAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`target_parameters expected to be basetypes.StringValue, was: %T`, targetParametersAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return TargetAddressValue{
		Address:           addressVal,
		AddressMask:       addressMaskVal,
		Port:              portVal,
		TagList:           tagListVal,
		TargetAddressName: targetAddressNameVal,
		TargetParameters:  targetParametersVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewTargetAddressValueNull() TargetAddressValue {
	return TargetAddressValue{
		state: attr.ValueStateNull,
	}
}

func NewTargetAddressValueUnknown() TargetAddressValue {
	return TargetAddressValue{
		state: attr.ValueStateUnknown,
	}
}

func NewTargetAddressValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (TargetAddressValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing TargetAddressValue Attribute Value",
				"While creating a TargetAddressValue value, a missing attribute value was detected. "+
					"A TargetAddressValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TargetAddressValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid TargetAddressValue Attribute Type",
				"While creating a TargetAddressValue value, an invalid attribute value was detected. "+
					"A TargetAddressValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TargetAddressValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("TargetAddressValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra TargetAddressValue Attribute Value",
				"While creating a TargetAddressValue value, an extra attribute value was detected. "+
					"A TargetAddressValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra TargetAddressValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewTargetAddressValueUnknown(), diags
	}

	addressAttribute, ok := attributes["address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`address is missing from object`)

		return NewTargetAddressValueUnknown(), diags
	}

	addressVal, ok := addressAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`address expected to be basetypes.StringValue, was: %T`, addressAttribute))
	}

	addressMaskAttribute, ok := attributes["address_mask"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`address_mask is missing from object`)

		return NewTargetAddressValueUnknown(), diags
	}

	addressMaskVal, ok := addressMaskAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`address_mask expected to be basetypes.StringValue, was: %T`, addressMaskAttribute))
	}

	portAttribute, ok := attributes["port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port is missing from object`)

		return NewTargetAddressValueUnknown(), diags
	}

	portVal, ok := portAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port expected to be basetypes.Int64Value, was: %T`, portAttribute))
	}

	tagListAttribute, ok := attributes["tag_list"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tag_list is missing from object`)

		return NewTargetAddressValueUnknown(), diags
	}

	tagListVal, ok := tagListAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tag_list expected to be basetypes.StringValue, was: %T`, tagListAttribute))
	}

	targetAddressNameAttribute, ok := attributes["target_address_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`target_address_name is missing from object`)

		return NewTargetAddressValueUnknown(), diags
	}

	targetAddressNameVal, ok := targetAddressNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`target_address_name expected to be basetypes.StringValue, was: %T`, targetAddressNameAttribute))
	}

	targetParametersAttribute, ok := attributes["target_parameters"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`target_parameters is missing from object`)

		return NewTargetAddressValueUnknown(), diags
	}

	targetParametersVal, ok := targetParametersAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`target_parameters expected to be basetypes.StringValue, was: %T`, targetParametersAttribute))
	}

	if diags.HasError() {
		return NewTargetAddressValueUnknown(), diags
	}

	return TargetAddressValue{
		Address:           addressVal,
		AddressMask:       addressMaskVal,
		Port:              portVal,
		TagList:           tagListVal,
		TargetAddressName: targetAddressNameVal,
		TargetParameters:  targetParametersVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewTargetAddressValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) TargetAddressValue {
	object, diags := NewTargetAddressValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewTargetAddressValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t TargetAddressType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewTargetAddressValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewTargetAddressValueUnknown(), nil
	}

	if in.IsNull() {
		return NewTargetAddressValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewTargetAddressValueMust(TargetAddressValue{}.AttributeTypes(ctx), attributes), nil
}

func (t TargetAddressType) ValueType(ctx context.Context) attr.Value {
	return TargetAddressValue{}
}

var _ basetypes.ObjectValuable = TargetAddressValue{}

type TargetAddressValue struct {
	Address           basetypes.StringValue `tfsdk:"address"`
	AddressMask       basetypes.StringValue `tfsdk:"address_mask"`
	Port              basetypes.Int64Value  `tfsdk:"port"`
	TagList           basetypes.StringValue `tfsdk:"tag_list"`
	TargetAddressName basetypes.StringValue `tfsdk:"target_address_name"`
	TargetParameters  basetypes.StringValue `tfsdk:"target_parameters"`
	state             attr.ValueState
}

func (v TargetAddressValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 6)

	var val tftypes.Value
	var err error

	attrTypes["address"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["address_mask"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["port"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["tag_list"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["target_address_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["target_parameters"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 6)

		val, err = v.Address.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["address"] = val

		val, err = v.AddressMask.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["address_mask"] = val

		val, err = v.Port.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port"] = val

		val, err = v.TagList.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tag_list"] = val

		val, err = v.TargetAddressName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["target_address_name"] = val

		val, err = v.TargetParameters.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["target_parameters"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v TargetAddressValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v TargetAddressValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v TargetAddressValue) String() string {
	return "TargetAddressValue"
}

func (v TargetAddressValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"address":             basetypes.StringType{},
		"address_mask":        basetypes.StringType{},
		"port":                basetypes.Int64Type{},
		"tag_list":            basetypes.StringType{},
		"target_address_name": basetypes.StringType{},
		"target_parameters":   basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"address":             v.Address,
			"address_mask":        v.AddressMask,
			"port":                v.Port,
			"tag_list":            v.TagList,
			"target_address_name": v.TargetAddressName,
			"target_parameters":   v.TargetParameters,
		})

	return objVal, diags
}

func (v TargetAddressValue) Equal(o attr.Value) bool {
	other, ok := o.(TargetAddressValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Address.Equal(other.Address) {
		return false
	}

	if !v.AddressMask.Equal(other.AddressMask) {
		return false
	}

	if !v.Port.Equal(other.Port) {
		return false
	}

	if !v.TagList.Equal(other.TagList) {
		return false
	}

	if !v.TargetAddressName.Equal(other.TargetAddressName) {
		return false
	}

	if !v.TargetParameters.Equal(other.TargetParameters) {
		return false
	}

	return true
}

func (v TargetAddressValue) Type(ctx context.Context) attr.Type {
	return TargetAddressType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v TargetAddressValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"address":             basetypes.StringType{},
		"address_mask":        basetypes.StringType{},
		"port":                basetypes.Int64Type{},
		"tag_list":            basetypes.StringType{},
		"target_address_name": basetypes.StringType{},
		"target_parameters":   basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = TargetParametersType{}

type TargetParametersType struct {
	basetypes.ObjectType
}

func (t TargetParametersType) Equal(o attr.Type) bool {
	other, ok := o.(TargetParametersType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t TargetParametersType) String() string {
	return "TargetParametersType"
}

func (t TargetParametersType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	messageProcessingModelAttribute, ok := attributes["message_processing_model"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`message_processing_model is missing from object`)

		return nil, diags
	}

	messageProcessingModelVal, ok := messageProcessingModelAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`message_processing_model expected to be basetypes.StringValue, was: %T`, messageProcessingModelAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	notifyFilterAttribute, ok := attributes["notify_filter"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`notify_filter is missing from object`)

		return nil, diags
	}

	notifyFilterVal, ok := notifyFilterAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`notify_filter expected to be basetypes.StringValue, was: %T`, notifyFilterAttribute))
	}

	securityLevelAttribute, ok := attributes["security_level"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`security_level is missing from object`)

		return nil, diags
	}

	securityLevelVal, ok := securityLevelAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`security_level expected to be basetypes.StringValue, was: %T`, securityLevelAttribute))
	}

	securityModelAttribute, ok := attributes["security_model"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`security_model is missing from object`)

		return nil, diags
	}

	securityModelVal, ok := securityModelAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`security_model expected to be basetypes.StringValue, was: %T`, securityModelAttribute))
	}

	securityNameAttribute, ok := attributes["security_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`security_name is missing from object`)

		return nil, diags
	}

	securityNameVal, ok := securityNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`security_name expected to be basetypes.StringValue, was: %T`, securityNameAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return TargetParametersValue{
		MessageProcessingModel: messageProcessingModelVal,
		Name:                   nameVal,
		NotifyFilter:           notifyFilterVal,
		SecurityLevel:          securityLevelVal,
		SecurityModel:          securityModelVal,
		SecurityName:           securityNameVal,
		state:                  attr.ValueStateKnown,
	}, diags
}

func NewTargetParametersValueNull() TargetParametersValue {
	return TargetParametersValue{
		state: attr.ValueStateNull,
	}
}

func NewTargetParametersValueUnknown() TargetParametersValue {
	return TargetParametersValue{
		state: attr.ValueStateUnknown,
	}
}

func NewTargetParametersValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (TargetParametersValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing TargetParametersValue Attribute Value",
				"While creating a TargetParametersValue value, a missing attribute value was detected. "+
					"A TargetParametersValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TargetParametersValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid TargetParametersValue Attribute Type",
				"While creating a TargetParametersValue value, an invalid attribute value was detected. "+
					"A TargetParametersValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TargetParametersValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("TargetParametersValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra TargetParametersValue Attribute Value",
				"While creating a TargetParametersValue value, an extra attribute value was detected. "+
					"A TargetParametersValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra TargetParametersValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewTargetParametersValueUnknown(), diags
	}

	messageProcessingModelAttribute, ok := attributes["message_processing_model"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`message_processing_model is missing from object`)

		return NewTargetParametersValueUnknown(), diags
	}

	messageProcessingModelVal, ok := messageProcessingModelAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`message_processing_model expected to be basetypes.StringValue, was: %T`, messageProcessingModelAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewTargetParametersValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	notifyFilterAttribute, ok := attributes["notify_filter"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`notify_filter is missing from object`)

		return NewTargetParametersValueUnknown(), diags
	}

	notifyFilterVal, ok := notifyFilterAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`notify_filter expected to be basetypes.StringValue, was: %T`, notifyFilterAttribute))
	}

	securityLevelAttribute, ok := attributes["security_level"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`security_level is missing from object`)

		return NewTargetParametersValueUnknown(), diags
	}

	securityLevelVal, ok := securityLevelAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`security_level expected to be basetypes.StringValue, was: %T`, securityLevelAttribute))
	}

	securityModelAttribute, ok := attributes["security_model"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`security_model is missing from object`)

		return NewTargetParametersValueUnknown(), diags
	}

	securityModelVal, ok := securityModelAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`security_model expected to be basetypes.StringValue, was: %T`, securityModelAttribute))
	}

	securityNameAttribute, ok := attributes["security_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`security_name is missing from object`)

		return NewTargetParametersValueUnknown(), diags
	}

	securityNameVal, ok := securityNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`security_name expected to be basetypes.StringValue, was: %T`, securityNameAttribute))
	}

	if diags.HasError() {
		return NewTargetParametersValueUnknown(), diags
	}

	return TargetParametersValue{
		MessageProcessingModel: messageProcessingModelVal,
		Name:                   nameVal,
		NotifyFilter:           notifyFilterVal,
		SecurityLevel:          securityLevelVal,
		SecurityModel:          securityModelVal,
		SecurityName:           securityNameVal,
		state:                  attr.ValueStateKnown,
	}, diags
}

func NewTargetParametersValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) TargetParametersValue {
	object, diags := NewTargetParametersValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewTargetParametersValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t TargetParametersType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewTargetParametersValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewTargetParametersValueUnknown(), nil
	}

	if in.IsNull() {
		return NewTargetParametersValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewTargetParametersValueMust(TargetParametersValue{}.AttributeTypes(ctx), attributes), nil
}

func (t TargetParametersType) ValueType(ctx context.Context) attr.Value {
	return TargetParametersValue{}
}

var _ basetypes.ObjectValuable = TargetParametersValue{}

type TargetParametersValue struct {
	MessageProcessingModel basetypes.StringValue `tfsdk:"message_processing_model"`
	Name                   basetypes.StringValue `tfsdk:"name"`
	NotifyFilter           basetypes.StringValue `tfsdk:"notify_filter"`
	SecurityLevel          basetypes.StringValue `tfsdk:"security_level"`
	SecurityModel          basetypes.StringValue `tfsdk:"security_model"`
	SecurityName           basetypes.StringValue `tfsdk:"security_name"`
	state                  attr.ValueState
}

func (v TargetParametersValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 6)

	var val tftypes.Value
	var err error

	attrTypes["message_processing_model"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["notify_filter"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["security_level"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["security_model"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["security_name"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 6)

		val, err = v.MessageProcessingModel.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["message_processing_model"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.NotifyFilter.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["notify_filter"] = val

		val, err = v.SecurityLevel.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["security_level"] = val

		val, err = v.SecurityModel.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["security_model"] = val

		val, err = v.SecurityName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["security_name"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v TargetParametersValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v TargetParametersValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v TargetParametersValue) String() string {
	return "TargetParametersValue"
}

func (v TargetParametersValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"message_processing_model": basetypes.StringType{},
		"name":                     basetypes.StringType{},
		"notify_filter":            basetypes.StringType{},
		"security_level":           basetypes.StringType{},
		"security_model":           basetypes.StringType{},
		"security_name":            basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"message_processing_model": v.MessageProcessingModel,
			"name":                     v.Name,
			"notify_filter":            v.NotifyFilter,
			"security_level":           v.SecurityLevel,
			"security_model":           v.SecurityModel,
			"security_name":            v.SecurityName,
		})

	return objVal, diags
}

func (v TargetParametersValue) Equal(o attr.Value) bool {
	other, ok := o.(TargetParametersValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.MessageProcessingModel.Equal(other.MessageProcessingModel) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.NotifyFilter.Equal(other.NotifyFilter) {
		return false
	}

	if !v.SecurityLevel.Equal(other.SecurityLevel) {
		return false
	}

	if !v.SecurityModel.Equal(other.SecurityModel) {
		return false
	}

	if !v.SecurityName.Equal(other.SecurityName) {
		return false
	}

	return true
}

func (v TargetParametersValue) Type(ctx context.Context) attr.Type {
	return TargetParametersType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v TargetParametersValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"message_processing_model": basetypes.StringType{},
		"name":                     basetypes.StringType{},
		"notify_filter":            basetypes.StringType{},
		"security_level":           basetypes.StringType{},
		"security_model":           basetypes.StringType{},
		"security_name":            basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = UsmType{}

type UsmType struct {
	basetypes.ObjectType
}

func (t UsmType) Equal(o attr.Type) bool {
	other, ok := o.(UsmType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t UsmType) String() string {
	return "UsmType"
}

func (t UsmType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	engineTypeAttribute, ok := attributes["engine_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`engine_type is missing from object`)

		return nil, diags
	}

	engineTypeVal, ok := engineTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`engine_type expected to be basetypes.StringValue, was: %T`, engineTypeAttribute))
	}

	engineidAttribute, ok := attributes["engineid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`engineid is missing from object`)

		return nil, diags
	}

	engineidVal, ok := engineidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`engineid expected to be basetypes.StringValue, was: %T`, engineidAttribute))
	}

	snmpv3UsersAttribute, ok := attributes["users"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`users is missing from object`)

		return nil, diags
	}

	snmpv3UsersVal, ok := snmpv3UsersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`users expected to be basetypes.ListValue, was: %T`, snmpv3UsersAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return UsmValue{
		EngineType:  engineTypeVal,
		Engineid:    engineidVal,
		Snmpv3Users: snmpv3UsersVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewUsmValueNull() UsmValue {
	return UsmValue{
		state: attr.ValueStateNull,
	}
}

func NewUsmValueUnknown() UsmValue {
	return UsmValue{
		state: attr.ValueStateUnknown,
	}
}

func NewUsmValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (UsmValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing UsmValue Attribute Value",
				"While creating a UsmValue value, a missing attribute value was detected. "+
					"A UsmValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("UsmValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid UsmValue Attribute Type",
				"While creating a UsmValue value, an invalid attribute value was detected. "+
					"A UsmValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("UsmValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("UsmValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra UsmValue Attribute Value",
				"While creating a UsmValue value, an extra attribute value was detected. "+
					"A UsmValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra UsmValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewUsmValueUnknown(), diags
	}

	engineTypeAttribute, ok := attributes["engine_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`engine_type is missing from object`)

		return NewUsmValueUnknown(), diags
	}

	engineTypeVal, ok := engineTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`engine_type expected to be basetypes.StringValue, was: %T`, engineTypeAttribute))
	}

	engineidAttribute, ok := attributes["engineid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`engineid is missing from object`)

		return NewUsmValueUnknown(), diags
	}

	engineidVal, ok := engineidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`engineid expected to be basetypes.StringValue, was: %T`, engineidAttribute))
	}

	snmpv3UsersAttribute, ok := attributes["users"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`users is missing from object`)

		return NewUsmValueUnknown(), diags
	}

	snmpv3UsersVal, ok := snmpv3UsersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`users expected to be basetypes.ListValue, was: %T`, snmpv3UsersAttribute))
	}

	if diags.HasError() {
		return NewUsmValueUnknown(), diags
	}

	return UsmValue{
		EngineType:  engineTypeVal,
		Engineid:    engineidVal,
		Snmpv3Users: snmpv3UsersVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewUsmValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) UsmValue {
	object, diags := NewUsmValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewUsmValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t UsmType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewUsmValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewUsmValueUnknown(), nil
	}

	if in.IsNull() {
		return NewUsmValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewUsmValueMust(UsmValue{}.AttributeTypes(ctx), attributes), nil
}

func (t UsmType) ValueType(ctx context.Context) attr.Value {
	return UsmValue{}
}

var _ basetypes.ObjectValuable = UsmValue{}

type UsmValue struct {
	EngineType  basetypes.StringValue `tfsdk:"engine_type"`
	Engineid    basetypes.StringValue `tfsdk:"engineid"`
	Snmpv3Users basetypes.ListValue   `tfsdk:"users"`
	state       attr.ValueState
}

func (v UsmValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["engine_type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["engineid"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["users"] = basetypes.ListType{
		ElemType: Snmpv3UsersValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.EngineType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["engine_type"] = val

		val, err = v.Engineid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["engineid"] = val

		val, err = v.Snmpv3Users.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["users"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v UsmValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v UsmValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v UsmValue) String() string {
	return "UsmValue"
}

func (v UsmValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	snmpv3Users := types.ListValueMust(
		Snmpv3UsersType{
			basetypes.ObjectType{
				AttrTypes: Snmpv3UsersValue{}.AttributeTypes(ctx),
			},
		},
		v.Snmpv3Users.Elements(),
	)

	if v.Snmpv3Users.IsNull() {
		snmpv3Users = types.ListNull(
			Snmpv3UsersType{
				basetypes.ObjectType{
					AttrTypes: Snmpv3UsersValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Snmpv3Users.IsUnknown() {
		snmpv3Users = types.ListUnknown(
			Snmpv3UsersType{
				basetypes.ObjectType{
					AttrTypes: Snmpv3UsersValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"engine_type": basetypes.StringType{},
		"engineid":    basetypes.StringType{},
		"users": basetypes.ListType{
			ElemType: Snmpv3UsersValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"engine_type":  v.EngineType,
			"engineid":     v.Engineid,
			"users": snmpv3Users,
		})

	return objVal, diags
}

func (v UsmValue) Equal(o attr.Value) bool {
	other, ok := o.(UsmValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.EngineType.Equal(other.EngineType) {
		return false
	}

	if !v.Engineid.Equal(other.Engineid) {
		return false
	}

	if !v.Snmpv3Users.Equal(other.Snmpv3Users) {
		return false
	}

	return true
}

func (v UsmValue) Type(ctx context.Context) attr.Type {
	return UsmType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v UsmValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"engine_type": basetypes.StringType{},
		"engineid":    basetypes.StringType{},
		"users": basetypes.ListType{
			ElemType: Snmpv3UsersValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = Snmpv3UsersType{}

type Snmpv3UsersType struct {
	basetypes.ObjectType
}

func (t Snmpv3UsersType) Equal(o attr.Type) bool {
	other, ok := o.(Snmpv3UsersType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Snmpv3UsersType) String() string {
	return "Snmpv3UsersType"
}

func (t Snmpv3UsersType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	authenticationPasswordAttribute, ok := attributes["authentication_password"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`authentication_password is missing from object`)

		return nil, diags
	}

	authenticationPasswordVal, ok := authenticationPasswordAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`authentication_password expected to be basetypes.StringValue, was: %T`, authenticationPasswordAttribute))
	}

	authenticationTypeAttribute, ok := attributes["authentication_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`authentication_type is missing from object`)

		return nil, diags
	}

	authenticationTypeVal, ok := authenticationTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`authentication_type expected to be basetypes.StringValue, was: %T`, authenticationTypeAttribute))
	}

	encryptionPasswordAttribute, ok := attributes["encryption_password"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`encryption_password is missing from object`)

		return nil, diags
	}

	encryptionPasswordVal, ok := encryptionPasswordAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`encryption_password expected to be basetypes.StringValue, was: %T`, encryptionPasswordAttribute))
	}

	encryptionTypeAttribute, ok := attributes["encryption_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`encryption_type is missing from object`)

		return nil, diags
	}

	encryptionTypeVal, ok := encryptionTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`encryption_type expected to be basetypes.StringValue, was: %T`, encryptionTypeAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Snmpv3UsersValue{
		AuthenticationPassword: authenticationPasswordVal,
		AuthenticationType:     authenticationTypeVal,
		EncryptionPassword:     encryptionPasswordVal,
		EncryptionType:         encryptionTypeVal,
		Name:                   nameVal,
		state:                  attr.ValueStateKnown,
	}, diags
}

func NewSnmpv3UsersValueNull() Snmpv3UsersValue {
	return Snmpv3UsersValue{
		state: attr.ValueStateNull,
	}
}

func NewSnmpv3UsersValueUnknown() Snmpv3UsersValue {
	return Snmpv3UsersValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSnmpv3UsersValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Snmpv3UsersValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Snmpv3UsersValue Attribute Value",
				"While creating a Snmpv3UsersValue value, a missing attribute value was detected. "+
					"A Snmpv3UsersValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Snmpv3UsersValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Snmpv3UsersValue Attribute Type",
				"While creating a Snmpv3UsersValue value, an invalid attribute value was detected. "+
					"A Snmpv3UsersValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Snmpv3UsersValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Snmpv3UsersValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Snmpv3UsersValue Attribute Value",
				"While creating a Snmpv3UsersValue value, an extra attribute value was detected. "+
					"A Snmpv3UsersValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Snmpv3UsersValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSnmpv3UsersValueUnknown(), diags
	}

	authenticationPasswordAttribute, ok := attributes["authentication_password"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`authentication_password is missing from object`)

		return NewSnmpv3UsersValueUnknown(), diags
	}

	authenticationPasswordVal, ok := authenticationPasswordAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`authentication_password expected to be basetypes.StringValue, was: %T`, authenticationPasswordAttribute))
	}

	authenticationTypeAttribute, ok := attributes["authentication_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`authentication_type is missing from object`)

		return NewSnmpv3UsersValueUnknown(), diags
	}

	authenticationTypeVal, ok := authenticationTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`authentication_type expected to be basetypes.StringValue, was: %T`, authenticationTypeAttribute))
	}

	encryptionPasswordAttribute, ok := attributes["encryption_password"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`encryption_password is missing from object`)

		return NewSnmpv3UsersValueUnknown(), diags
	}

	encryptionPasswordVal, ok := encryptionPasswordAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`encryption_password expected to be basetypes.StringValue, was: %T`, encryptionPasswordAttribute))
	}

	encryptionTypeAttribute, ok := attributes["encryption_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`encryption_type is missing from object`)

		return NewSnmpv3UsersValueUnknown(), diags
	}

	encryptionTypeVal, ok := encryptionTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`encryption_type expected to be basetypes.StringValue, was: %T`, encryptionTypeAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewSnmpv3UsersValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	if diags.HasError() {
		return NewSnmpv3UsersValueUnknown(), diags
	}

	return Snmpv3UsersValue{
		AuthenticationPassword: authenticationPasswordVal,
		AuthenticationType:     authenticationTypeVal,
		EncryptionPassword:     encryptionPasswordVal,
		EncryptionType:         encryptionTypeVal,
		Name:                   nameVal,
		state:                  attr.ValueStateKnown,
	}, diags
}

func NewSnmpv3UsersValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Snmpv3UsersValue {
	object, diags := NewSnmpv3UsersValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSnmpv3UsersValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Snmpv3UsersType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSnmpv3UsersValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSnmpv3UsersValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSnmpv3UsersValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSnmpv3UsersValueMust(Snmpv3UsersValue{}.AttributeTypes(ctx), attributes), nil
}

func (t Snmpv3UsersType) ValueType(ctx context.Context) attr.Value {
	return Snmpv3UsersValue{}
}

var _ basetypes.ObjectValuable = Snmpv3UsersValue{}

type Snmpv3UsersValue struct {
	AuthenticationPassword basetypes.StringValue `tfsdk:"authentication_password"`
	AuthenticationType     basetypes.StringValue `tfsdk:"authentication_type"`
	EncryptionPassword     basetypes.StringValue `tfsdk:"encryption_password"`
	EncryptionType         basetypes.StringValue `tfsdk:"encryption_type"`
	Name                   basetypes.StringValue `tfsdk:"name"`
	state                  attr.ValueState
}

func (v Snmpv3UsersValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["authentication_password"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["authentication_type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["encryption_password"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["encryption_type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.AuthenticationPassword.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["authentication_password"] = val

		val, err = v.AuthenticationType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["authentication_type"] = val

		val, err = v.EncryptionPassword.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["encryption_password"] = val

		val, err = v.EncryptionType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["encryption_type"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Snmpv3UsersValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Snmpv3UsersValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Snmpv3UsersValue) String() string {
	return "Snmpv3UsersValue"
}

func (v Snmpv3UsersValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"authentication_password": basetypes.StringType{},
		"authentication_type":     basetypes.StringType{},
		"encryption_password":     basetypes.StringType{},
		"encryption_type":         basetypes.StringType{},
		"name":                    basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"authentication_password": v.AuthenticationPassword,
			"authentication_type":     v.AuthenticationType,
			"encryption_password":     v.EncryptionPassword,
			"encryption_type":         v.EncryptionType,
			"name":                    v.Name,
		})

	return objVal, diags
}

func (v Snmpv3UsersValue) Equal(o attr.Value) bool {
	other, ok := o.(Snmpv3UsersValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AuthenticationPassword.Equal(other.AuthenticationPassword) {
		return false
	}

	if !v.AuthenticationType.Equal(other.AuthenticationType) {
		return false
	}

	if !v.EncryptionPassword.Equal(other.EncryptionPassword) {
		return false
	}

	if !v.EncryptionType.Equal(other.EncryptionType) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	return true
}

func (v Snmpv3UsersValue) Type(ctx context.Context) attr.Type {
	return Snmpv3UsersType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Snmpv3UsersValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"authentication_password": basetypes.StringType{},
		"authentication_type":     basetypes.StringType{},
		"encryption_password":     basetypes.StringType{},
		"encryption_type":         basetypes.StringType{},
		"name":                    basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = VacmType{}

type VacmType struct {
	basetypes.ObjectType
}

func (t VacmType) Equal(o attr.Type) bool {
	other, ok := o.(VacmType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t VacmType) String() string {
	return "VacmType"
}

func (t VacmType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	accessAttribute, ok := attributes["access"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`access is missing from object`)

		return nil, diags
	}

	accessVal, ok := accessAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`access expected to be basetypes.ListValue, was: %T`, accessAttribute))
	}

	securityToGroupAttribute, ok := attributes["security_to_group"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`security_to_group is missing from object`)

		return nil, diags
	}

	securityToGroupVal, ok := securityToGroupAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`security_to_group expected to be basetypes.ObjectValue, was: %T`, securityToGroupAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return VacmValue{
		Access:          accessVal,
		SecurityToGroup: securityToGroupVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewVacmValueNull() VacmValue {
	return VacmValue{
		state: attr.ValueStateNull,
	}
}

func NewVacmValueUnknown() VacmValue {
	return VacmValue{
		state: attr.ValueStateUnknown,
	}
}

func NewVacmValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (VacmValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing VacmValue Attribute Value",
				"While creating a VacmValue value, a missing attribute value was detected. "+
					"A VacmValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VacmValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid VacmValue Attribute Type",
				"While creating a VacmValue value, an invalid attribute value was detected. "+
					"A VacmValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VacmValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("VacmValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra VacmValue Attribute Value",
				"While creating a VacmValue value, an extra attribute value was detected. "+
					"A VacmValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra VacmValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewVacmValueUnknown(), diags
	}

	accessAttribute, ok := attributes["access"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`access is missing from object`)

		return NewVacmValueUnknown(), diags
	}

	accessVal, ok := accessAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`access expected to be basetypes.ListValue, was: %T`, accessAttribute))
	}

	securityToGroupAttribute, ok := attributes["security_to_group"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`security_to_group is missing from object`)

		return NewVacmValueUnknown(), diags
	}

	securityToGroupVal, ok := securityToGroupAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`security_to_group expected to be basetypes.ObjectValue, was: %T`, securityToGroupAttribute))
	}

	if diags.HasError() {
		return NewVacmValueUnknown(), diags
	}

	return VacmValue{
		Access:          accessVal,
		SecurityToGroup: securityToGroupVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewVacmValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) VacmValue {
	object, diags := NewVacmValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewVacmValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t VacmType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewVacmValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewVacmValueUnknown(), nil
	}

	if in.IsNull() {
		return NewVacmValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewVacmValueMust(VacmValue{}.AttributeTypes(ctx), attributes), nil
}

func (t VacmType) ValueType(ctx context.Context) attr.Value {
	return VacmValue{}
}

var _ basetypes.ObjectValuable = VacmValue{}

type VacmValue struct {
	Access          basetypes.ListValue   `tfsdk:"access"`
	SecurityToGroup basetypes.ObjectValue `tfsdk:"security_to_group"`
	state           attr.ValueState
}

func (v VacmValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["access"] = basetypes.ListType{
		ElemType: AccessValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["security_to_group"] = basetypes.ObjectType{
		AttrTypes: SecurityToGroupValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Access.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["access"] = val

		val, err = v.SecurityToGroup.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["security_to_group"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v VacmValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v VacmValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v VacmValue) String() string {
	return "VacmValue"
}

func (v VacmValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	access := types.ListValueMust(
		AccessType{
			basetypes.ObjectType{
				AttrTypes: AccessValue{}.AttributeTypes(ctx),
			},
		},
		v.Access.Elements(),
	)

	if v.Access.IsNull() {
		access = types.ListNull(
			AccessType{
				basetypes.ObjectType{
					AttrTypes: AccessValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Access.IsUnknown() {
		access = types.ListUnknown(
			AccessType{
				basetypes.ObjectType{
					AttrTypes: AccessValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var securityToGroup basetypes.ObjectValue

	if v.SecurityToGroup.IsNull() {
		securityToGroup = types.ObjectNull(
			SecurityToGroupValue{}.AttributeTypes(ctx),
		)
	}

	if v.SecurityToGroup.IsUnknown() {
		securityToGroup = types.ObjectUnknown(
			SecurityToGroupValue{}.AttributeTypes(ctx),
		)
	}

	if !v.SecurityToGroup.IsNull() && !v.SecurityToGroup.IsUnknown() {
		securityToGroup = types.ObjectValueMust(
			SecurityToGroupValue{}.AttributeTypes(ctx),
			v.SecurityToGroup.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"access": basetypes.ListType{
			ElemType: AccessValue{}.Type(ctx),
		},
		"security_to_group": basetypes.ObjectType{
			AttrTypes: SecurityToGroupValue{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"access":            access,
			"security_to_group": securityToGroup,
		})

	return objVal, diags
}

func (v VacmValue) Equal(o attr.Value) bool {
	other, ok := o.(VacmValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Access.Equal(other.Access) {
		return false
	}

	if !v.SecurityToGroup.Equal(other.SecurityToGroup) {
		return false
	}

	return true
}

func (v VacmValue) Type(ctx context.Context) attr.Type {
	return VacmType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v VacmValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"access": basetypes.ListType{
			ElemType: AccessValue{}.Type(ctx),
		},
		"security_to_group": basetypes.ObjectType{
			AttrTypes: SecurityToGroupValue{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = AccessType{}

type AccessType struct {
	basetypes.ObjectType
}

func (t AccessType) Equal(o attr.Type) bool {
	other, ok := o.(AccessType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AccessType) String() string {
	return "AccessType"
}

func (t AccessType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	groupNameAttribute, ok := attributes["group_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`group_name is missing from object`)

		return nil, diags
	}

	groupNameVal, ok := groupNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`group_name expected to be basetypes.StringValue, was: %T`, groupNameAttribute))
	}

	prefixListAttribute, ok := attributes["prefix_list"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix_list is missing from object`)

		return nil, diags
	}

	prefixListVal, ok := prefixListAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix_list expected to be basetypes.ListValue, was: %T`, prefixListAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AccessValue{
		GroupName:  groupNameVal,
		PrefixList: prefixListVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewAccessValueNull() AccessValue {
	return AccessValue{
		state: attr.ValueStateNull,
	}
}

func NewAccessValueUnknown() AccessValue {
	return AccessValue{
		state: attr.ValueStateUnknown,
	}
}

func NewAccessValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AccessValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AccessValue Attribute Value",
				"While creating a AccessValue value, a missing attribute value was detected. "+
					"A AccessValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AccessValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AccessValue Attribute Type",
				"While creating a AccessValue value, an invalid attribute value was detected. "+
					"A AccessValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AccessValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AccessValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AccessValue Attribute Value",
				"While creating a AccessValue value, an extra attribute value was detected. "+
					"A AccessValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AccessValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAccessValueUnknown(), diags
	}

	groupNameAttribute, ok := attributes["group_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`group_name is missing from object`)

		return NewAccessValueUnknown(), diags
	}

	groupNameVal, ok := groupNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`group_name expected to be basetypes.StringValue, was: %T`, groupNameAttribute))
	}

	prefixListAttribute, ok := attributes["prefix_list"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix_list is missing from object`)

		return NewAccessValueUnknown(), diags
	}

	prefixListVal, ok := prefixListAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix_list expected to be basetypes.ListValue, was: %T`, prefixListAttribute))
	}

	if diags.HasError() {
		return NewAccessValueUnknown(), diags
	}

	return AccessValue{
		GroupName:  groupNameVal,
		PrefixList: prefixListVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewAccessValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AccessValue {
	object, diags := NewAccessValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAccessValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AccessType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAccessValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAccessValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAccessValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAccessValueMust(AccessValue{}.AttributeTypes(ctx), attributes), nil
}

func (t AccessType) ValueType(ctx context.Context) attr.Value {
	return AccessValue{}
}

var _ basetypes.ObjectValuable = AccessValue{}

type AccessValue struct {
	GroupName  basetypes.StringValue `tfsdk:"group_name"`
	PrefixList basetypes.ListValue   `tfsdk:"prefix_list"`
	state      attr.ValueState
}

func (v AccessValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["group_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["prefix_list"] = basetypes.ListType{
		ElemType: PrefixListValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.GroupName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["group_name"] = val

		val, err = v.PrefixList.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["prefix_list"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AccessValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AccessValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AccessValue) String() string {
	return "AccessValue"
}

func (v AccessValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	prefixList := types.ListValueMust(
		PrefixListType{
			basetypes.ObjectType{
				AttrTypes: PrefixListValue{}.AttributeTypes(ctx),
			},
		},
		v.PrefixList.Elements(),
	)

	if v.PrefixList.IsNull() {
		prefixList = types.ListNull(
			PrefixListType{
				basetypes.ObjectType{
					AttrTypes: PrefixListValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.PrefixList.IsUnknown() {
		prefixList = types.ListUnknown(
			PrefixListType{
				basetypes.ObjectType{
					AttrTypes: PrefixListValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"group_name": basetypes.StringType{},
		"prefix_list": basetypes.ListType{
			ElemType: PrefixListValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"group_name":  v.GroupName,
			"prefix_list": prefixList,
		})

	return objVal, diags
}

func (v AccessValue) Equal(o attr.Value) bool {
	other, ok := o.(AccessValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.GroupName.Equal(other.GroupName) {
		return false
	}

	if !v.PrefixList.Equal(other.PrefixList) {
		return false
	}

	return true
}

func (v AccessValue) Type(ctx context.Context) attr.Type {
	return AccessType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AccessValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"group_name": basetypes.StringType{},
		"prefix_list": basetypes.ListType{
			ElemType: PrefixListValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = PrefixListType{}

type PrefixListType struct {
	basetypes.ObjectType
}

func (t PrefixListType) Equal(o attr.Type) bool {
	other, ok := o.(PrefixListType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PrefixListType) String() string {
	return "PrefixListType"
}

func (t PrefixListType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	contextPrefixAttribute, ok := attributes["context_prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`context_prefix is missing from object`)

		return nil, diags
	}

	contextPrefixVal, ok := contextPrefixAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`context_prefix expected to be basetypes.StringValue, was: %T`, contextPrefixAttribute))
	}

	notifyViewAttribute, ok := attributes["notify_view"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`notify_view is missing from object`)

		return nil, diags
	}

	notifyViewVal, ok := notifyViewAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`notify_view expected to be basetypes.StringValue, was: %T`, notifyViewAttribute))
	}

	readViewAttribute, ok := attributes["read_view"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`read_view is missing from object`)

		return nil, diags
	}

	readViewVal, ok := readViewAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`read_view expected to be basetypes.StringValue, was: %T`, readViewAttribute))
	}

	securityLevelAttribute, ok := attributes["security_level"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`security_level is missing from object`)

		return nil, diags
	}

	securityLevelVal, ok := securityLevelAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`security_level expected to be basetypes.StringValue, was: %T`, securityLevelAttribute))
	}

	securityModelAttribute, ok := attributes["security_model"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`security_model is missing from object`)

		return nil, diags
	}

	securityModelVal, ok := securityModelAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`security_model expected to be basetypes.StringValue, was: %T`, securityModelAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	writeViewAttribute, ok := attributes["write_view"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`write_view is missing from object`)

		return nil, diags
	}

	writeViewVal, ok := writeViewAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`write_view expected to be basetypes.StringValue, was: %T`, writeViewAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PrefixListValue{
		ContextPrefix:  contextPrefixVal,
		NotifyView:     notifyViewVal,
		ReadView:       readViewVal,
		SecurityLevel:  securityLevelVal,
		SecurityModel:  securityModelVal,
		PrefixListType: typeVal,
		WriteView:      writeViewVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewPrefixListValueNull() PrefixListValue {
	return PrefixListValue{
		state: attr.ValueStateNull,
	}
}

func NewPrefixListValueUnknown() PrefixListValue {
	return PrefixListValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPrefixListValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PrefixListValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PrefixListValue Attribute Value",
				"While creating a PrefixListValue value, a missing attribute value was detected. "+
					"A PrefixListValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PrefixListValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PrefixListValue Attribute Type",
				"While creating a PrefixListValue value, an invalid attribute value was detected. "+
					"A PrefixListValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PrefixListValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PrefixListValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PrefixListValue Attribute Value",
				"While creating a PrefixListValue value, an extra attribute value was detected. "+
					"A PrefixListValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PrefixListValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPrefixListValueUnknown(), diags
	}

	contextPrefixAttribute, ok := attributes["context_prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`context_prefix is missing from object`)

		return NewPrefixListValueUnknown(), diags
	}

	contextPrefixVal, ok := contextPrefixAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`context_prefix expected to be basetypes.StringValue, was: %T`, contextPrefixAttribute))
	}

	notifyViewAttribute, ok := attributes["notify_view"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`notify_view is missing from object`)

		return NewPrefixListValueUnknown(), diags
	}

	notifyViewVal, ok := notifyViewAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`notify_view expected to be basetypes.StringValue, was: %T`, notifyViewAttribute))
	}

	readViewAttribute, ok := attributes["read_view"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`read_view is missing from object`)

		return NewPrefixListValueUnknown(), diags
	}

	readViewVal, ok := readViewAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`read_view expected to be basetypes.StringValue, was: %T`, readViewAttribute))
	}

	securityLevelAttribute, ok := attributes["security_level"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`security_level is missing from object`)

		return NewPrefixListValueUnknown(), diags
	}

	securityLevelVal, ok := securityLevelAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`security_level expected to be basetypes.StringValue, was: %T`, securityLevelAttribute))
	}

	securityModelAttribute, ok := attributes["security_model"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`security_model is missing from object`)

		return NewPrefixListValueUnknown(), diags
	}

	securityModelVal, ok := securityModelAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`security_model expected to be basetypes.StringValue, was: %T`, securityModelAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewPrefixListValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	writeViewAttribute, ok := attributes["write_view"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`write_view is missing from object`)

		return NewPrefixListValueUnknown(), diags
	}

	writeViewVal, ok := writeViewAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`write_view expected to be basetypes.StringValue, was: %T`, writeViewAttribute))
	}

	if diags.HasError() {
		return NewPrefixListValueUnknown(), diags
	}

	return PrefixListValue{
		ContextPrefix:  contextPrefixVal,
		NotifyView:     notifyViewVal,
		ReadView:       readViewVal,
		SecurityLevel:  securityLevelVal,
		SecurityModel:  securityModelVal,
		PrefixListType: typeVal,
		WriteView:      writeViewVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewPrefixListValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PrefixListValue {
	object, diags := NewPrefixListValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPrefixListValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PrefixListType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPrefixListValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPrefixListValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPrefixListValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPrefixListValueMust(PrefixListValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PrefixListType) ValueType(ctx context.Context) attr.Value {
	return PrefixListValue{}
}

var _ basetypes.ObjectValuable = PrefixListValue{}

type PrefixListValue struct {
	ContextPrefix  basetypes.StringValue `tfsdk:"context_prefix"`
	NotifyView     basetypes.StringValue `tfsdk:"notify_view"`
	ReadView       basetypes.StringValue `tfsdk:"read_view"`
	SecurityLevel  basetypes.StringValue `tfsdk:"security_level"`
	SecurityModel  basetypes.StringValue `tfsdk:"security_model"`
	PrefixListType basetypes.StringValue `tfsdk:"type"`
	WriteView      basetypes.StringValue `tfsdk:"write_view"`
	state          attr.ValueState
}

func (v PrefixListValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 7)

	var val tftypes.Value
	var err error

	attrTypes["context_prefix"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["notify_view"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["read_view"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["security_level"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["security_model"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["write_view"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 7)

		val, err = v.ContextPrefix.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["context_prefix"] = val

		val, err = v.NotifyView.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["notify_view"] = val

		val, err = v.ReadView.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["read_view"] = val

		val, err = v.SecurityLevel.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["security_level"] = val

		val, err = v.SecurityModel.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["security_model"] = val

		val, err = v.PrefixListType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		val, err = v.WriteView.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["write_view"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PrefixListValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PrefixListValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PrefixListValue) String() string {
	return "PrefixListValue"
}

func (v PrefixListValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"context_prefix": basetypes.StringType{},
		"notify_view":    basetypes.StringType{},
		"read_view":      basetypes.StringType{},
		"security_level": basetypes.StringType{},
		"security_model": basetypes.StringType{},
		"type":           basetypes.StringType{},
		"write_view":     basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"context_prefix": v.ContextPrefix,
			"notify_view":    v.NotifyView,
			"read_view":      v.ReadView,
			"security_level": v.SecurityLevel,
			"security_model": v.SecurityModel,
			"type":           v.PrefixListType,
			"write_view":     v.WriteView,
		})

	return objVal, diags
}

func (v PrefixListValue) Equal(o attr.Value) bool {
	other, ok := o.(PrefixListValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.ContextPrefix.Equal(other.ContextPrefix) {
		return false
	}

	if !v.NotifyView.Equal(other.NotifyView) {
		return false
	}

	if !v.ReadView.Equal(other.ReadView) {
		return false
	}

	if !v.SecurityLevel.Equal(other.SecurityLevel) {
		return false
	}

	if !v.SecurityModel.Equal(other.SecurityModel) {
		return false
	}

	if !v.PrefixListType.Equal(other.PrefixListType) {
		return false
	}

	if !v.WriteView.Equal(other.WriteView) {
		return false
	}

	return true
}

func (v PrefixListValue) Type(ctx context.Context) attr.Type {
	return PrefixListType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PrefixListValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"context_prefix": basetypes.StringType{},
		"notify_view":    basetypes.StringType{},
		"read_view":      basetypes.StringType{},
		"security_level": basetypes.StringType{},
		"security_model": basetypes.StringType{},
		"type":           basetypes.StringType{},
		"write_view":     basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = SecurityToGroupType{}

type SecurityToGroupType struct {
	basetypes.ObjectType
}

func (t SecurityToGroupType) Equal(o attr.Type) bool {
	other, ok := o.(SecurityToGroupType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SecurityToGroupType) String() string {
	return "SecurityToGroupType"
}

func (t SecurityToGroupType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	securityModelAttribute, ok := attributes["security_model"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`security_model is missing from object`)

		return nil, diags
	}

	securityModelVal, ok := securityModelAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`security_model expected to be basetypes.StringValue, was: %T`, securityModelAttribute))
	}

	snmpv3VacmContentAttribute, ok := attributes["content"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`content is missing from object`)

		return nil, diags
	}

	snmpv3VacmContentVal, ok := snmpv3VacmContentAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`content expected to be basetypes.ListValue, was: %T`, snmpv3VacmContentAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SecurityToGroupValue{
		SecurityModel:     securityModelVal,
		Snmpv3VacmContent: snmpv3VacmContentVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewSecurityToGroupValueNull() SecurityToGroupValue {
	return SecurityToGroupValue{
		state: attr.ValueStateNull,
	}
}

func NewSecurityToGroupValueUnknown() SecurityToGroupValue {
	return SecurityToGroupValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSecurityToGroupValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SecurityToGroupValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SecurityToGroupValue Attribute Value",
				"While creating a SecurityToGroupValue value, a missing attribute value was detected. "+
					"A SecurityToGroupValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SecurityToGroupValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SecurityToGroupValue Attribute Type",
				"While creating a SecurityToGroupValue value, an invalid attribute value was detected. "+
					"A SecurityToGroupValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SecurityToGroupValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SecurityToGroupValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SecurityToGroupValue Attribute Value",
				"While creating a SecurityToGroupValue value, an extra attribute value was detected. "+
					"A SecurityToGroupValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SecurityToGroupValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSecurityToGroupValueUnknown(), diags
	}

	securityModelAttribute, ok := attributes["security_model"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`security_model is missing from object`)

		return NewSecurityToGroupValueUnknown(), diags
	}

	securityModelVal, ok := securityModelAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`security_model expected to be basetypes.StringValue, was: %T`, securityModelAttribute))
	}

	snmpv3VacmContentAttribute, ok := attributes["content"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`content is missing from object`)

		return NewSecurityToGroupValueUnknown(), diags
	}

	snmpv3VacmContentVal, ok := snmpv3VacmContentAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`content expected to be basetypes.ListValue, was: %T`, snmpv3VacmContentAttribute))
	}

	if diags.HasError() {
		return NewSecurityToGroupValueUnknown(), diags
	}

	return SecurityToGroupValue{
		SecurityModel:     securityModelVal,
		Snmpv3VacmContent: snmpv3VacmContentVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewSecurityToGroupValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SecurityToGroupValue {
	object, diags := NewSecurityToGroupValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSecurityToGroupValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SecurityToGroupType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSecurityToGroupValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSecurityToGroupValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSecurityToGroupValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSecurityToGroupValueMust(SecurityToGroupValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SecurityToGroupType) ValueType(ctx context.Context) attr.Value {
	return SecurityToGroupValue{}
}

var _ basetypes.ObjectValuable = SecurityToGroupValue{}

type SecurityToGroupValue struct {
	SecurityModel     basetypes.StringValue `tfsdk:"security_model"`
	Snmpv3VacmContent basetypes.ListValue   `tfsdk:"content"`
	state             attr.ValueState
}

func (v SecurityToGroupValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["security_model"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["content"] = basetypes.ListType{
		ElemType: Snmpv3VacmContentValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.SecurityModel.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["security_model"] = val

		val, err = v.Snmpv3VacmContent.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["content"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SecurityToGroupValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SecurityToGroupValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SecurityToGroupValue) String() string {
	return "SecurityToGroupValue"
}

func (v SecurityToGroupValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	snmpv3VacmContent := types.ListValueMust(
		Snmpv3VacmContentType{
			basetypes.ObjectType{
				AttrTypes: Snmpv3VacmContentValue{}.AttributeTypes(ctx),
			},
		},
		v.Snmpv3VacmContent.Elements(),
	)

	if v.Snmpv3VacmContent.IsNull() {
		snmpv3VacmContent = types.ListNull(
			Snmpv3VacmContentType{
				basetypes.ObjectType{
					AttrTypes: Snmpv3VacmContentValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Snmpv3VacmContent.IsUnknown() {
		snmpv3VacmContent = types.ListUnknown(
			Snmpv3VacmContentType{
				basetypes.ObjectType{
					AttrTypes: Snmpv3VacmContentValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"security_model": basetypes.StringType{},
		"content": basetypes.ListType{
			ElemType: Snmpv3VacmContentValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"security_model":      v.SecurityModel,
			"content": snmpv3VacmContent,
		})

	return objVal, diags
}

func (v SecurityToGroupValue) Equal(o attr.Value) bool {
	other, ok := o.(SecurityToGroupValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.SecurityModel.Equal(other.SecurityModel) {
		return false
	}

	if !v.Snmpv3VacmContent.Equal(other.Snmpv3VacmContent) {
		return false
	}

	return true
}

func (v SecurityToGroupValue) Type(ctx context.Context) attr.Type {
	return SecurityToGroupType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SecurityToGroupValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"security_model": basetypes.StringType{},
		"content": basetypes.ListType{
			ElemType: Snmpv3VacmContentValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = Snmpv3VacmContentType{}

type Snmpv3VacmContentType struct {
	basetypes.ObjectType
}

func (t Snmpv3VacmContentType) Equal(o attr.Type) bool {
	other, ok := o.(Snmpv3VacmContentType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Snmpv3VacmContentType) String() string {
	return "Snmpv3VacmContentType"
}

func (t Snmpv3VacmContentType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	groupAttribute, ok := attributes["group"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`group is missing from object`)

		return nil, diags
	}

	groupVal, ok := groupAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`group expected to be basetypes.StringValue, was: %T`, groupAttribute))
	}

	securityNameAttribute, ok := attributes["security_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`security_name is missing from object`)

		return nil, diags
	}

	securityNameVal, ok := securityNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`security_name expected to be basetypes.StringValue, was: %T`, securityNameAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Snmpv3VacmContentValue{
		Group:        groupVal,
		SecurityName: securityNameVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewSnmpv3VacmContentValueNull() Snmpv3VacmContentValue {
	return Snmpv3VacmContentValue{
		state: attr.ValueStateNull,
	}
}

func NewSnmpv3VacmContentValueUnknown() Snmpv3VacmContentValue {
	return Snmpv3VacmContentValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSnmpv3VacmContentValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Snmpv3VacmContentValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Snmpv3VacmContentValue Attribute Value",
				"While creating a Snmpv3VacmContentValue value, a missing attribute value was detected. "+
					"A Snmpv3VacmContentValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Snmpv3VacmContentValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Snmpv3VacmContentValue Attribute Type",
				"While creating a Snmpv3VacmContentValue value, an invalid attribute value was detected. "+
					"A Snmpv3VacmContentValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Snmpv3VacmContentValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Snmpv3VacmContentValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Snmpv3VacmContentValue Attribute Value",
				"While creating a Snmpv3VacmContentValue value, an extra attribute value was detected. "+
					"A Snmpv3VacmContentValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Snmpv3VacmContentValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSnmpv3VacmContentValueUnknown(), diags
	}

	groupAttribute, ok := attributes["group"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`group is missing from object`)

		return NewSnmpv3VacmContentValueUnknown(), diags
	}

	groupVal, ok := groupAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`group expected to be basetypes.StringValue, was: %T`, groupAttribute))
	}

	securityNameAttribute, ok := attributes["security_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`security_name is missing from object`)

		return NewSnmpv3VacmContentValueUnknown(), diags
	}

	securityNameVal, ok := securityNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`security_name expected to be basetypes.StringValue, was: %T`, securityNameAttribute))
	}

	if diags.HasError() {
		return NewSnmpv3VacmContentValueUnknown(), diags
	}

	return Snmpv3VacmContentValue{
		Group:        groupVal,
		SecurityName: securityNameVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewSnmpv3VacmContentValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Snmpv3VacmContentValue {
	object, diags := NewSnmpv3VacmContentValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSnmpv3VacmContentValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Snmpv3VacmContentType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSnmpv3VacmContentValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSnmpv3VacmContentValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSnmpv3VacmContentValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSnmpv3VacmContentValueMust(Snmpv3VacmContentValue{}.AttributeTypes(ctx), attributes), nil
}

func (t Snmpv3VacmContentType) ValueType(ctx context.Context) attr.Value {
	return Snmpv3VacmContentValue{}
}

var _ basetypes.ObjectValuable = Snmpv3VacmContentValue{}

type Snmpv3VacmContentValue struct {
	Group        basetypes.StringValue `tfsdk:"group"`
	SecurityName basetypes.StringValue `tfsdk:"security_name"`
	state        attr.ValueState
}

func (v Snmpv3VacmContentValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["group"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["security_name"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Group.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["group"] = val

		val, err = v.SecurityName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["security_name"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Snmpv3VacmContentValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Snmpv3VacmContentValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Snmpv3VacmContentValue) String() string {
	return "Snmpv3VacmContentValue"
}

func (v Snmpv3VacmContentValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"group":         basetypes.StringType{},
		"security_name": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"group":         v.Group,
			"security_name": v.SecurityName,
		})

	return objVal, diags
}

func (v Snmpv3VacmContentValue) Equal(o attr.Value) bool {
	other, ok := o.(Snmpv3VacmContentValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Group.Equal(other.Group) {
		return false
	}

	if !v.SecurityName.Equal(other.SecurityName) {
		return false
	}

	return true
}

func (v Snmpv3VacmContentValue) Type(ctx context.Context) attr.Type {
	return Snmpv3VacmContentType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Snmpv3VacmContentValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"group":         basetypes.StringType{},
		"security_name": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = ViewsType{}

type ViewsType struct {
	basetypes.ObjectType
}

func (t ViewsType) Equal(o attr.Type) bool {
	other, ok := o.(ViewsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ViewsType) String() string {
	return "ViewsType"
}

func (t ViewsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	includeAttribute, ok := attributes["include"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`include is missing from object`)

		return nil, diags
	}

	includeVal, ok := includeAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`include expected to be basetypes.BoolValue, was: %T`, includeAttribute))
	}

	oidAttribute, ok := attributes["oid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`oid is missing from object`)

		return nil, diags
	}

	oidVal, ok := oidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`oid expected to be basetypes.StringValue, was: %T`, oidAttribute))
	}

	viewNameAttribute, ok := attributes["view_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`view_name is missing from object`)

		return nil, diags
	}

	viewNameVal, ok := viewNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`view_name expected to be basetypes.StringValue, was: %T`, viewNameAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ViewsValue{
		Include:  includeVal,
		Oid:      oidVal,
		ViewName: viewNameVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewViewsValueNull() ViewsValue {
	return ViewsValue{
		state: attr.ValueStateNull,
	}
}

func NewViewsValueUnknown() ViewsValue {
	return ViewsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewViewsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ViewsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ViewsValue Attribute Value",
				"While creating a ViewsValue value, a missing attribute value was detected. "+
					"A ViewsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ViewsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ViewsValue Attribute Type",
				"While creating a ViewsValue value, an invalid attribute value was detected. "+
					"A ViewsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ViewsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ViewsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ViewsValue Attribute Value",
				"While creating a ViewsValue value, an extra attribute value was detected. "+
					"A ViewsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ViewsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewViewsValueUnknown(), diags
	}

	includeAttribute, ok := attributes["include"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`include is missing from object`)

		return NewViewsValueUnknown(), diags
	}

	includeVal, ok := includeAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`include expected to be basetypes.BoolValue, was: %T`, includeAttribute))
	}

	oidAttribute, ok := attributes["oid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`oid is missing from object`)

		return NewViewsValueUnknown(), diags
	}

	oidVal, ok := oidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`oid expected to be basetypes.StringValue, was: %T`, oidAttribute))
	}

	viewNameAttribute, ok := attributes["view_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`view_name is missing from object`)

		return NewViewsValueUnknown(), diags
	}

	viewNameVal, ok := viewNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`view_name expected to be basetypes.StringValue, was: %T`, viewNameAttribute))
	}

	if diags.HasError() {
		return NewViewsValueUnknown(), diags
	}

	return ViewsValue{
		Include:  includeVal,
		Oid:      oidVal,
		ViewName: viewNameVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewViewsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ViewsValue {
	object, diags := NewViewsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewViewsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ViewsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewViewsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewViewsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewViewsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewViewsValueMust(ViewsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ViewsType) ValueType(ctx context.Context) attr.Value {
	return ViewsValue{}
}

var _ basetypes.ObjectValuable = ViewsValue{}

type ViewsValue struct {
	Include  basetypes.BoolValue   `tfsdk:"include"`
	Oid      basetypes.StringValue `tfsdk:"oid"`
	ViewName basetypes.StringValue `tfsdk:"view_name"`
	state    attr.ValueState
}

func (v ViewsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["include"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["oid"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["view_name"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Include.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["include"] = val

		val, err = v.Oid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["oid"] = val

		val, err = v.ViewName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["view_name"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ViewsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ViewsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ViewsValue) String() string {
	return "ViewsValue"
}

func (v ViewsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"include":   basetypes.BoolType{},
		"oid":       basetypes.StringType{},
		"view_name": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"include":   v.Include,
			"oid":       v.Oid,
			"view_name": v.ViewName,
		})

	return objVal, diags
}

func (v ViewsValue) Equal(o attr.Value) bool {
	other, ok := o.(ViewsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Include.Equal(other.Include) {
		return false
	}

	if !v.Oid.Equal(other.Oid) {
		return false
	}

	if !v.ViewName.Equal(other.ViewName) {
		return false
	}

	return true
}

func (v ViewsValue) Type(ctx context.Context) attr.Type {
	return ViewsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ViewsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"include":   basetypes.BoolType{},
		"oid":       basetypes.StringType{},
		"view_name": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = SwitchMatchingType{}

type SwitchMatchingType struct {
	basetypes.ObjectType
}

func (t SwitchMatchingType) Equal(o attr.Type) bool {
	other, ok := o.(SwitchMatchingType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SwitchMatchingType) String() string {
	return "SwitchMatchingType"
}

func (t SwitchMatchingType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	enableAttribute, ok := attributes["enable"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable is missing from object`)

		return nil, diags
	}

	enableVal, ok := enableAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable expected to be basetypes.BoolValue, was: %T`, enableAttribute))
	}

	matchingRulesAttribute, ok := attributes["rules"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rules is missing from object`)

		return nil, diags
	}

	matchingRulesVal, ok := matchingRulesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rules expected to be basetypes.ListValue, was: %T`, matchingRulesAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SwitchMatchingValue{
		Enable:        enableVal,
		MatchingRules: matchingRulesVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewSwitchMatchingValueNull() SwitchMatchingValue {
	return SwitchMatchingValue{
		state: attr.ValueStateNull,
	}
}

func NewSwitchMatchingValueUnknown() SwitchMatchingValue {
	return SwitchMatchingValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSwitchMatchingValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SwitchMatchingValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SwitchMatchingValue Attribute Value",
				"While creating a SwitchMatchingValue value, a missing attribute value was detected. "+
					"A SwitchMatchingValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SwitchMatchingValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SwitchMatchingValue Attribute Type",
				"While creating a SwitchMatchingValue value, an invalid attribute value was detected. "+
					"A SwitchMatchingValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SwitchMatchingValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SwitchMatchingValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SwitchMatchingValue Attribute Value",
				"While creating a SwitchMatchingValue value, an extra attribute value was detected. "+
					"A SwitchMatchingValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SwitchMatchingValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSwitchMatchingValueUnknown(), diags
	}

	enableAttribute, ok := attributes["enable"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable is missing from object`)

		return NewSwitchMatchingValueUnknown(), diags
	}

	enableVal, ok := enableAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable expected to be basetypes.BoolValue, was: %T`, enableAttribute))
	}

	matchingRulesAttribute, ok := attributes["rules"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rules is missing from object`)

		return NewSwitchMatchingValueUnknown(), diags
	}

	matchingRulesVal, ok := matchingRulesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rules expected to be basetypes.ListValue, was: %T`, matchingRulesAttribute))
	}

	if diags.HasError() {
		return NewSwitchMatchingValueUnknown(), diags
	}

	return SwitchMatchingValue{
		Enable:        enableVal,
		MatchingRules: matchingRulesVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewSwitchMatchingValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SwitchMatchingValue {
	object, diags := NewSwitchMatchingValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSwitchMatchingValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SwitchMatchingType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSwitchMatchingValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSwitchMatchingValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSwitchMatchingValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSwitchMatchingValueMust(SwitchMatchingValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SwitchMatchingType) ValueType(ctx context.Context) attr.Value {
	return SwitchMatchingValue{}
}

var _ basetypes.ObjectValuable = SwitchMatchingValue{}

type SwitchMatchingValue struct {
	Enable        basetypes.BoolValue `tfsdk:"enable"`
	MatchingRules basetypes.ListValue `tfsdk:"rules"`
	state         attr.ValueState
}

func (v SwitchMatchingValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["enable"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["rules"] = basetypes.ListType{
		ElemType: MatchingRulesValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Enable.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enable"] = val

		val, err = v.MatchingRules.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["rules"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SwitchMatchingValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SwitchMatchingValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SwitchMatchingValue) String() string {
	return "SwitchMatchingValue"
}

func (v SwitchMatchingValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	matchingRules := types.ListValueMust(
		MatchingRulesType{
			basetypes.ObjectType{
				AttrTypes: MatchingRulesValue{}.AttributeTypes(ctx),
			},
		},
		v.MatchingRules.Elements(),
	)

	if v.MatchingRules.IsNull() {
		matchingRules = types.ListNull(
			MatchingRulesType{
				basetypes.ObjectType{
					AttrTypes: MatchingRulesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.MatchingRules.IsUnknown() {
		matchingRules = types.ListUnknown(
			MatchingRulesType{
				basetypes.ObjectType{
					AttrTypes: MatchingRulesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"enable": basetypes.BoolType{},
		"rules": basetypes.ListType{
			ElemType: MatchingRulesValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"enable":         v.Enable,
			"rules": matchingRules,
		})

	return objVal, diags
}

func (v SwitchMatchingValue) Equal(o attr.Value) bool {
	other, ok := o.(SwitchMatchingValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Enable.Equal(other.Enable) {
		return false
	}

	if !v.MatchingRules.Equal(other.MatchingRules) {
		return false
	}

	return true
}

func (v SwitchMatchingValue) Type(ctx context.Context) attr.Type {
	return SwitchMatchingType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SwitchMatchingValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"enable": basetypes.BoolType{},
		"rules": basetypes.ListType{
			ElemType: MatchingRulesValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = MatchingRulesType{}

type MatchingRulesType struct {
	basetypes.ObjectType
}

func (t MatchingRulesType) Equal(o attr.Type) bool {
	other, ok := o.(MatchingRulesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t MatchingRulesType) String() string {
	return "MatchingRulesType"
}

func (t MatchingRulesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	additionalConfigCmdsAttribute, ok := attributes["additional_config_cmds"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`additional_config_cmds is missing from object`)

		return nil, diags
	}

	additionalConfigCmdsVal, ok := additionalConfigCmdsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`additional_config_cmds expected to be basetypes.ListValue, was: %T`, additionalConfigCmdsAttribute))
	}

	matchRoleAttribute, ok := attributes["match_role"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`match_role is missing from object`)

		return nil, diags
	}

	matchRoleVal, ok := matchRoleAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`match_role expected to be basetypes.StringValue, was: %T`, matchRoleAttribute))
	}

	matchTypeAttribute, ok := attributes["match_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`match_type is missing from object`)

		return nil, diags
	}

	matchTypeVal, ok := matchTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`match_type expected to be basetypes.StringValue, was: %T`, matchTypeAttribute))
	}

	matchValueAttribute, ok := attributes["match_value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`match_value is missing from object`)

		return nil, diags
	}

	matchValueVal, ok := matchValueAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`match_value expected to be basetypes.StringValue, was: %T`, matchValueAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	portConfigAttribute, ok := attributes["port_config"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_config is missing from object`)

		return nil, diags
	}

	portConfigVal, ok := portConfigAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_config expected to be basetypes.MapValue, was: %T`, portConfigAttribute))
	}

	portMirroringAttribute, ok := attributes["port_mirroring"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_mirroring is missing from object`)

		return nil, diags
	}

	portMirroringVal, ok := portMirroringAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_mirroring expected to be basetypes.MapValue, was: %T`, portMirroringAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return MatchingRulesValue{
		AdditionalConfigCmds: additionalConfigCmdsVal,
		MatchRole:            matchRoleVal,
		MatchType:            matchTypeVal,
		MatchValue:           matchValueVal,
		Name:                 nameVal,
		PortConfig:           portConfigVal,
		PortMirroring:        portMirroringVal,
		state:                attr.ValueStateKnown,
	}, diags
}

func NewMatchingRulesValueNull() MatchingRulesValue {
	return MatchingRulesValue{
		state: attr.ValueStateNull,
	}
}

func NewMatchingRulesValueUnknown() MatchingRulesValue {
	return MatchingRulesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewMatchingRulesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (MatchingRulesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing MatchingRulesValue Attribute Value",
				"While creating a MatchingRulesValue value, a missing attribute value was detected. "+
					"A MatchingRulesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MatchingRulesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid MatchingRulesValue Attribute Type",
				"While creating a MatchingRulesValue value, an invalid attribute value was detected. "+
					"A MatchingRulesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MatchingRulesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("MatchingRulesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra MatchingRulesValue Attribute Value",
				"While creating a MatchingRulesValue value, an extra attribute value was detected. "+
					"A MatchingRulesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra MatchingRulesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewMatchingRulesValueUnknown(), diags
	}

	additionalConfigCmdsAttribute, ok := attributes["additional_config_cmds"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`additional_config_cmds is missing from object`)

		return NewMatchingRulesValueUnknown(), diags
	}

	additionalConfigCmdsVal, ok := additionalConfigCmdsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`additional_config_cmds expected to be basetypes.ListValue, was: %T`, additionalConfigCmdsAttribute))
	}

	matchRoleAttribute, ok := attributes["match_role"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`match_role is missing from object`)

		return NewMatchingRulesValueUnknown(), diags
	}

	matchRoleVal, ok := matchRoleAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`match_role expected to be basetypes.StringValue, was: %T`, matchRoleAttribute))
	}

	matchTypeAttribute, ok := attributes["match_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`match_type is missing from object`)

		return NewMatchingRulesValueUnknown(), diags
	}

	matchTypeVal, ok := matchTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`match_type expected to be basetypes.StringValue, was: %T`, matchTypeAttribute))
	}

	matchValueAttribute, ok := attributes["match_value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`match_value is missing from object`)

		return NewMatchingRulesValueUnknown(), diags
	}

	matchValueVal, ok := matchValueAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`match_value expected to be basetypes.StringValue, was: %T`, matchValueAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewMatchingRulesValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	portConfigAttribute, ok := attributes["port_config"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_config is missing from object`)

		return NewMatchingRulesValueUnknown(), diags
	}

	portConfigVal, ok := portConfigAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_config expected to be basetypes.MapValue, was: %T`, portConfigAttribute))
	}

	portMirroringAttribute, ok := attributes["port_mirroring"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_mirroring is missing from object`)

		return NewMatchingRulesValueUnknown(), diags
	}

	portMirroringVal, ok := portMirroringAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_mirroring expected to be basetypes.MapValue, was: %T`, portMirroringAttribute))
	}

	if diags.HasError() {
		return NewMatchingRulesValueUnknown(), diags
	}

	return MatchingRulesValue{
		AdditionalConfigCmds: additionalConfigCmdsVal,
		MatchRole:            matchRoleVal,
		MatchType:            matchTypeVal,
		MatchValue:           matchValueVal,
		Name:                 nameVal,
		PortConfig:           portConfigVal,
		PortMirroring:        portMirroringVal,
		state:                attr.ValueStateKnown,
	}, diags
}

func NewMatchingRulesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) MatchingRulesValue {
	object, diags := NewMatchingRulesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewMatchingRulesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t MatchingRulesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewMatchingRulesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewMatchingRulesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewMatchingRulesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewMatchingRulesValueMust(MatchingRulesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t MatchingRulesType) ValueType(ctx context.Context) attr.Value {
	return MatchingRulesValue{}
}

var _ basetypes.ObjectValuable = MatchingRulesValue{}

type MatchingRulesValue struct {
	AdditionalConfigCmds basetypes.ListValue   `tfsdk:"additional_config_cmds"`
	MatchRole            basetypes.StringValue `tfsdk:"match_role"`
	MatchType            basetypes.StringValue `tfsdk:"match_type"`
	MatchValue           basetypes.StringValue `tfsdk:"match_value"`
	Name                 basetypes.StringValue `tfsdk:"name"`
	PortConfig           basetypes.MapValue    `tfsdk:"port_config"`
	PortMirroring        basetypes.MapValue    `tfsdk:"port_mirroring"`
	state                attr.ValueState
}

func (v MatchingRulesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 7)

	var val tftypes.Value
	var err error

	attrTypes["additional_config_cmds"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["match_role"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["match_type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["match_value"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["port_config"] = basetypes.MapType{
		ElemType: PortConfigValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["port_mirroring"] = basetypes.MapType{
		ElemType: PortMirroringValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 7)

		val, err = v.AdditionalConfigCmds.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["additional_config_cmds"] = val

		val, err = v.MatchRole.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["match_role"] = val

		val, err = v.MatchType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["match_type"] = val

		val, err = v.MatchValue.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["match_value"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.PortConfig.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port_config"] = val

		val, err = v.PortMirroring.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port_mirroring"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v MatchingRulesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v MatchingRulesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v MatchingRulesValue) String() string {
	return "MatchingRulesValue"
}

func (v MatchingRulesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	portConfig := types.MapValueMust(
		PortConfigType{
			basetypes.ObjectType{
				AttrTypes: PortConfigValue{}.AttributeTypes(ctx),
			},
		},
		v.PortConfig.Elements(),
	)

	if v.PortConfig.IsNull() {
		portConfig = types.MapNull(
			PortConfigType{
				basetypes.ObjectType{
					AttrTypes: PortConfigValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.PortConfig.IsUnknown() {
		portConfig = types.MapUnknown(
			PortConfigType{
				basetypes.ObjectType{
					AttrTypes: PortConfigValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	portMirroring := types.MapValueMust(
		PortMirroringType{
			basetypes.ObjectType{
				AttrTypes: PortMirroringValue{}.AttributeTypes(ctx),
			},
		},
		v.PortMirroring.Elements(),
	)

	if v.PortMirroring.IsNull() {
		portMirroring = types.MapNull(
			PortMirroringType{
				basetypes.ObjectType{
					AttrTypes: PortMirroringValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.PortMirroring.IsUnknown() {
		portMirroring = types.MapUnknown(
			PortMirroringType{
				basetypes.ObjectType{
					AttrTypes: PortMirroringValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	additionalConfigCmdsVal, d := types.ListValue(types.StringType, v.AdditionalConfigCmds.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"additional_config_cmds": basetypes.ListType{
				ElemType: types.StringType,
			},
			"match_role":  basetypes.StringType{},
			"match_type":  basetypes.StringType{},
			"match_value": basetypes.StringType{},
			"name":        basetypes.StringType{},
			"port_config": basetypes.MapType{
				ElemType: PortConfigValue{}.Type(ctx),
			},
			"port_mirroring": basetypes.MapType{
				ElemType: PortMirroringValue{}.Type(ctx),
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"additional_config_cmds": basetypes.ListType{
			ElemType: types.StringType,
		},
		"match_role":  basetypes.StringType{},
		"match_type":  basetypes.StringType{},
		"match_value": basetypes.StringType{},
		"name":        basetypes.StringType{},
		"port_config": basetypes.MapType{
			ElemType: PortConfigValue{}.Type(ctx),
		},
		"port_mirroring": basetypes.MapType{
			ElemType: PortMirroringValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"additional_config_cmds": additionalConfigCmdsVal,
			"match_role":             v.MatchRole,
			"match_type":             v.MatchType,
			"match_value":            v.MatchValue,
			"name":                   v.Name,
			"port_config":            portConfig,
			"port_mirroring":         portMirroring,
		})

	return objVal, diags
}

func (v MatchingRulesValue) Equal(o attr.Value) bool {
	other, ok := o.(MatchingRulesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AdditionalConfigCmds.Equal(other.AdditionalConfigCmds) {
		return false
	}

	if !v.MatchRole.Equal(other.MatchRole) {
		return false
	}

	if !v.MatchType.Equal(other.MatchType) {
		return false
	}

	if !v.MatchValue.Equal(other.MatchValue) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.PortConfig.Equal(other.PortConfig) {
		return false
	}

	if !v.PortMirroring.Equal(other.PortMirroring) {
		return false
	}

	return true
}

func (v MatchingRulesValue) Type(ctx context.Context) attr.Type {
	return MatchingRulesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v MatchingRulesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"additional_config_cmds": basetypes.ListType{
			ElemType: types.StringType,
		},
		"match_role":  basetypes.StringType{},
		"match_type":  basetypes.StringType{},
		"match_value": basetypes.StringType{},
		"name":        basetypes.StringType{},
		"port_config": basetypes.MapType{
			ElemType: PortConfigValue{}.Type(ctx),
		},
		"port_mirroring": basetypes.MapType{
			ElemType: PortMirroringValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = PortConfigType{}

type PortConfigType struct {
	basetypes.ObjectType
}

func (t PortConfigType) Equal(o attr.Type) bool {
	other, ok := o.(PortConfigType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PortConfigType) String() string {
	return "PortConfigType"
}

func (t PortConfigType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	aeDisableLacpAttribute, ok := attributes["ae_disable_lacp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ae_disable_lacp is missing from object`)

		return nil, diags
	}

	aeDisableLacpVal, ok := aeDisableLacpAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ae_disable_lacp expected to be basetypes.BoolValue, was: %T`, aeDisableLacpAttribute))
	}

	aeIdxAttribute, ok := attributes["ae_idx"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ae_idx is missing from object`)

		return nil, diags
	}

	aeIdxVal, ok := aeIdxAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ae_idx expected to be basetypes.Int64Value, was: %T`, aeIdxAttribute))
	}

	aeLacpSlowAttribute, ok := attributes["ae_lacp_slow"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ae_lacp_slow is missing from object`)

		return nil, diags
	}

	aeLacpSlowVal, ok := aeLacpSlowAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ae_lacp_slow expected to be basetypes.BoolValue, was: %T`, aeLacpSlowAttribute))
	}

	aggregatedAttribute, ok := attributes["aggregated"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`aggregated is missing from object`)

		return nil, diags
	}

	aggregatedVal, ok := aggregatedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`aggregated expected to be basetypes.BoolValue, was: %T`, aggregatedAttribute))
	}

	criticalAttribute, ok := attributes["critical"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`critical is missing from object`)

		return nil, diags
	}

	criticalVal, ok := criticalAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`critical expected to be basetypes.BoolValue, was: %T`, criticalAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return nil, diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	disableAutonegAttribute, ok := attributes["disable_autoneg"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disable_autoneg is missing from object`)

		return nil, diags
	}

	disableAutonegVal, ok := disableAutonegAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disable_autoneg expected to be basetypes.BoolValue, was: %T`, disableAutonegAttribute))
	}

	duplexAttribute, ok := attributes["duplex"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`duplex is missing from object`)

		return nil, diags
	}

	duplexVal, ok := duplexAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`duplex expected to be basetypes.StringValue, was: %T`, duplexAttribute))
	}

	dynamicUsageAttribute, ok := attributes["dynamic_usage"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dynamic_usage is missing from object`)

		return nil, diags
	}

	dynamicUsageVal, ok := dynamicUsageAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dynamic_usage expected to be basetypes.StringValue, was: %T`, dynamicUsageAttribute))
	}

	esilagAttribute, ok := attributes["esilag"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`esilag is missing from object`)

		return nil, diags
	}

	esilagVal, ok := esilagAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`esilag expected to be basetypes.BoolValue, was: %T`, esilagAttribute))
	}

	mtuAttribute, ok := attributes["mtu"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mtu is missing from object`)

		return nil, diags
	}

	mtuVal, ok := mtuAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mtu expected to be basetypes.Int64Value, was: %T`, mtuAttribute))
	}

	noLocalOverwriteAttribute, ok := attributes["no_local_overwrite"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`no_local_overwrite is missing from object`)

		return nil, diags
	}

	noLocalOverwriteVal, ok := noLocalOverwriteAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`no_local_overwrite expected to be basetypes.BoolValue, was: %T`, noLocalOverwriteAttribute))
	}

	poeDisabledAttribute, ok := attributes["poe_disabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`poe_disabled is missing from object`)

		return nil, diags
	}

	poeDisabledVal, ok := poeDisabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`poe_disabled expected to be basetypes.BoolValue, was: %T`, poeDisabledAttribute))
	}

	speedAttribute, ok := attributes["speed"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`speed is missing from object`)

		return nil, diags
	}

	speedVal, ok := speedAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`speed expected to be basetypes.StringValue, was: %T`, speedAttribute))
	}

	usageAttribute, ok := attributes["usage"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`usage is missing from object`)

		return nil, diags
	}

	usageVal, ok := usageAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`usage expected to be basetypes.StringValue, was: %T`, usageAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PortConfigValue{
		AeDisableLacp:    aeDisableLacpVal,
		AeIdx:            aeIdxVal,
		AeLacpSlow:       aeLacpSlowVal,
		Aggregated:       aggregatedVal,
		Critical:         criticalVal,
		Description:      descriptionVal,
		DisableAutoneg:   disableAutonegVal,
		Duplex:           duplexVal,
		DynamicUsage:     dynamicUsageVal,
		Esilag:           esilagVal,
		Mtu:              mtuVal,
		NoLocalOverwrite: noLocalOverwriteVal,
		PoeDisabled:      poeDisabledVal,
		Speed:            speedVal,
		Usage:            usageVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewPortConfigValueNull() PortConfigValue {
	return PortConfigValue{
		state: attr.ValueStateNull,
	}
}

func NewPortConfigValueUnknown() PortConfigValue {
	return PortConfigValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPortConfigValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PortConfigValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PortConfigValue Attribute Value",
				"While creating a PortConfigValue value, a missing attribute value was detected. "+
					"A PortConfigValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PortConfigValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PortConfigValue Attribute Type",
				"While creating a PortConfigValue value, an invalid attribute value was detected. "+
					"A PortConfigValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PortConfigValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PortConfigValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PortConfigValue Attribute Value",
				"While creating a PortConfigValue value, an extra attribute value was detected. "+
					"A PortConfigValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PortConfigValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPortConfigValueUnknown(), diags
	}

	aeDisableLacpAttribute, ok := attributes["ae_disable_lacp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ae_disable_lacp is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	aeDisableLacpVal, ok := aeDisableLacpAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ae_disable_lacp expected to be basetypes.BoolValue, was: %T`, aeDisableLacpAttribute))
	}

	aeIdxAttribute, ok := attributes["ae_idx"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ae_idx is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	aeIdxVal, ok := aeIdxAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ae_idx expected to be basetypes.Int64Value, was: %T`, aeIdxAttribute))
	}

	aeLacpSlowAttribute, ok := attributes["ae_lacp_slow"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ae_lacp_slow is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	aeLacpSlowVal, ok := aeLacpSlowAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ae_lacp_slow expected to be basetypes.BoolValue, was: %T`, aeLacpSlowAttribute))
	}

	aggregatedAttribute, ok := attributes["aggregated"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`aggregated is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	aggregatedVal, ok := aggregatedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`aggregated expected to be basetypes.BoolValue, was: %T`, aggregatedAttribute))
	}

	criticalAttribute, ok := attributes["critical"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`critical is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	criticalVal, ok := criticalAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`critical expected to be basetypes.BoolValue, was: %T`, criticalAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	disableAutonegAttribute, ok := attributes["disable_autoneg"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disable_autoneg is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	disableAutonegVal, ok := disableAutonegAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disable_autoneg expected to be basetypes.BoolValue, was: %T`, disableAutonegAttribute))
	}

	duplexAttribute, ok := attributes["duplex"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`duplex is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	duplexVal, ok := duplexAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`duplex expected to be basetypes.StringValue, was: %T`, duplexAttribute))
	}

	dynamicUsageAttribute, ok := attributes["dynamic_usage"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dynamic_usage is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	dynamicUsageVal, ok := dynamicUsageAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dynamic_usage expected to be basetypes.StringValue, was: %T`, dynamicUsageAttribute))
	}

	esilagAttribute, ok := attributes["esilag"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`esilag is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	esilagVal, ok := esilagAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`esilag expected to be basetypes.BoolValue, was: %T`, esilagAttribute))
	}

	mtuAttribute, ok := attributes["mtu"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mtu is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	mtuVal, ok := mtuAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mtu expected to be basetypes.Int64Value, was: %T`, mtuAttribute))
	}

	noLocalOverwriteAttribute, ok := attributes["no_local_overwrite"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`no_local_overwrite is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	noLocalOverwriteVal, ok := noLocalOverwriteAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`no_local_overwrite expected to be basetypes.BoolValue, was: %T`, noLocalOverwriteAttribute))
	}

	poeDisabledAttribute, ok := attributes["poe_disabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`poe_disabled is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	poeDisabledVal, ok := poeDisabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`poe_disabled expected to be basetypes.BoolValue, was: %T`, poeDisabledAttribute))
	}

	speedAttribute, ok := attributes["speed"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`speed is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	speedVal, ok := speedAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`speed expected to be basetypes.StringValue, was: %T`, speedAttribute))
	}

	usageAttribute, ok := attributes["usage"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`usage is missing from object`)

		return NewPortConfigValueUnknown(), diags
	}

	usageVal, ok := usageAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`usage expected to be basetypes.StringValue, was: %T`, usageAttribute))
	}

	if diags.HasError() {
		return NewPortConfigValueUnknown(), diags
	}

	return PortConfigValue{
		AeDisableLacp:    aeDisableLacpVal,
		AeIdx:            aeIdxVal,
		AeLacpSlow:       aeLacpSlowVal,
		Aggregated:       aggregatedVal,
		Critical:         criticalVal,
		Description:      descriptionVal,
		DisableAutoneg:   disableAutonegVal,
		Duplex:           duplexVal,
		DynamicUsage:     dynamicUsageVal,
		Esilag:           esilagVal,
		Mtu:              mtuVal,
		NoLocalOverwrite: noLocalOverwriteVal,
		PoeDisabled:      poeDisabledVal,
		Speed:            speedVal,
		Usage:            usageVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewPortConfigValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PortConfigValue {
	object, diags := NewPortConfigValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPortConfigValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PortConfigType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPortConfigValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPortConfigValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPortConfigValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPortConfigValueMust(PortConfigValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PortConfigType) ValueType(ctx context.Context) attr.Value {
	return PortConfigValue{}
}

var _ basetypes.ObjectValuable = PortConfigValue{}

type PortConfigValue struct {
	AeDisableLacp    basetypes.BoolValue   `tfsdk:"ae_disable_lacp"`
	AeIdx            basetypes.Int64Value  `tfsdk:"ae_idx"`
	AeLacpSlow       basetypes.BoolValue   `tfsdk:"ae_lacp_slow"`
	Aggregated       basetypes.BoolValue   `tfsdk:"aggregated"`
	Critical         basetypes.BoolValue   `tfsdk:"critical"`
	Description      basetypes.StringValue `tfsdk:"description"`
	DisableAutoneg   basetypes.BoolValue   `tfsdk:"disable_autoneg"`
	Duplex           basetypes.StringValue `tfsdk:"duplex"`
	DynamicUsage     basetypes.StringValue `tfsdk:"dynamic_usage"`
	Esilag           basetypes.BoolValue   `tfsdk:"esilag"`
	Mtu              basetypes.Int64Value  `tfsdk:"mtu"`
	NoLocalOverwrite basetypes.BoolValue   `tfsdk:"no_local_overwrite"`
	PoeDisabled      basetypes.BoolValue   `tfsdk:"poe_disabled"`
	Speed            basetypes.StringValue `tfsdk:"speed"`
	Usage            basetypes.StringValue `tfsdk:"usage"`
	state            attr.ValueState
}

func (v PortConfigValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 15)

	var val tftypes.Value
	var err error

	attrTypes["ae_disable_lacp"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["ae_idx"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["ae_lacp_slow"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["aggregated"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["critical"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["disable_autoneg"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["duplex"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["dynamic_usage"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["esilag"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["mtu"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["no_local_overwrite"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["poe_disabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["speed"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["usage"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 15)

		val, err = v.AeDisableLacp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ae_disable_lacp"] = val

		val, err = v.AeIdx.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ae_idx"] = val

		val, err = v.AeLacpSlow.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ae_lacp_slow"] = val

		val, err = v.Aggregated.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["aggregated"] = val

		val, err = v.Critical.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["critical"] = val

		val, err = v.Description.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["description"] = val

		val, err = v.DisableAutoneg.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["disable_autoneg"] = val

		val, err = v.Duplex.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["duplex"] = val

		val, err = v.DynamicUsage.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dynamic_usage"] = val

		val, err = v.Esilag.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["esilag"] = val

		val, err = v.Mtu.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mtu"] = val

		val, err = v.NoLocalOverwrite.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["no_local_overwrite"] = val

		val, err = v.PoeDisabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["poe_disabled"] = val

		val, err = v.Speed.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["speed"] = val

		val, err = v.Usage.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["usage"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PortConfigValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PortConfigValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PortConfigValue) String() string {
	return "PortConfigValue"
}

func (v PortConfigValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"ae_disable_lacp":    basetypes.BoolType{},
		"ae_idx":             basetypes.Int64Type{},
		"ae_lacp_slow":       basetypes.BoolType{},
		"aggregated":         basetypes.BoolType{},
		"critical":           basetypes.BoolType{},
		"description":        basetypes.StringType{},
		"disable_autoneg":    basetypes.BoolType{},
		"duplex":             basetypes.StringType{},
		"dynamic_usage":      basetypes.StringType{},
		"esilag":             basetypes.BoolType{},
		"mtu":                basetypes.Int64Type{},
		"no_local_overwrite": basetypes.BoolType{},
		"poe_disabled":       basetypes.BoolType{},
		"speed":              basetypes.StringType{},
		"usage":              basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"ae_disable_lacp":    v.AeDisableLacp,
			"ae_idx":             v.AeIdx,
			"ae_lacp_slow":       v.AeLacpSlow,
			"aggregated":         v.Aggregated,
			"critical":           v.Critical,
			"description":        v.Description,
			"disable_autoneg":    v.DisableAutoneg,
			"duplex":             v.Duplex,
			"dynamic_usage":      v.DynamicUsage,
			"esilag":             v.Esilag,
			"mtu":                v.Mtu,
			"no_local_overwrite": v.NoLocalOverwrite,
			"poe_disabled":       v.PoeDisabled,
			"speed":              v.Speed,
			"usage":              v.Usage,
		})

	return objVal, diags
}

func (v PortConfigValue) Equal(o attr.Value) bool {
	other, ok := o.(PortConfigValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AeDisableLacp.Equal(other.AeDisableLacp) {
		return false
	}

	if !v.AeIdx.Equal(other.AeIdx) {
		return false
	}

	if !v.AeLacpSlow.Equal(other.AeLacpSlow) {
		return false
	}

	if !v.Aggregated.Equal(other.Aggregated) {
		return false
	}

	if !v.Critical.Equal(other.Critical) {
		return false
	}

	if !v.Description.Equal(other.Description) {
		return false
	}

	if !v.DisableAutoneg.Equal(other.DisableAutoneg) {
		return false
	}

	if !v.Duplex.Equal(other.Duplex) {
		return false
	}

	if !v.DynamicUsage.Equal(other.DynamicUsage) {
		return false
	}

	if !v.Esilag.Equal(other.Esilag) {
		return false
	}

	if !v.Mtu.Equal(other.Mtu) {
		return false
	}

	if !v.NoLocalOverwrite.Equal(other.NoLocalOverwrite) {
		return false
	}

	if !v.PoeDisabled.Equal(other.PoeDisabled) {
		return false
	}

	if !v.Speed.Equal(other.Speed) {
		return false
	}

	if !v.Usage.Equal(other.Usage) {
		return false
	}

	return true
}

func (v PortConfigValue) Type(ctx context.Context) attr.Type {
	return PortConfigType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PortConfigValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"ae_disable_lacp":    basetypes.BoolType{},
		"ae_idx":             basetypes.Int64Type{},
		"ae_lacp_slow":       basetypes.BoolType{},
		"aggregated":         basetypes.BoolType{},
		"critical":           basetypes.BoolType{},
		"description":        basetypes.StringType{},
		"disable_autoneg":    basetypes.BoolType{},
		"duplex":             basetypes.StringType{},
		"dynamic_usage":      basetypes.StringType{},
		"esilag":             basetypes.BoolType{},
		"mtu":                basetypes.Int64Type{},
		"no_local_overwrite": basetypes.BoolType{},
		"poe_disabled":       basetypes.BoolType{},
		"speed":              basetypes.StringType{},
		"usage":              basetypes.StringType{},
	}
}






















var _ basetypes.ObjectTypable = SwitchMgmtType{}

type SwitchMgmtType struct {
	basetypes.ObjectType
}

func (t SwitchMgmtType) Equal(o attr.Type) bool {
	other, ok := o.(SwitchMgmtType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SwitchMgmtType) String() string {
	return "SwitchMgmtType"
}

func (t SwitchMgmtType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	configRevertAttribute, ok := attributes["config_revert"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`config_revert is missing from object`)

		return nil, diags
	}

	configRevertVal, ok := configRevertAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`config_revert expected to be basetypes.Int64Value, was: %T`, configRevertAttribute))
	}

	protectReAttribute, ok := attributes["protect_re"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`protect_re is missing from object`)

		return nil, diags
	}

	protectReVal, ok := protectReAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`protect_re expected to be basetypes.ObjectValue, was: %T`, protectReAttribute))
	}

	rootPasswordAttribute, ok := attributes["root_password"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`root_password is missing from object`)

		return nil, diags
	}

	rootPasswordVal, ok := rootPasswordAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`root_password expected to be basetypes.StringValue, was: %T`, rootPasswordAttribute))
	}

	tacacsAttribute, ok := attributes["tacacs"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tacacs is missing from object`)

		return nil, diags
	}

	tacacsVal, ok := tacacsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tacacs expected to be basetypes.ObjectValue, was: %T`, tacacsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SwitchMgmtValue{
		ConfigRevert: configRevertVal,
		ProtectRe:    protectReVal,
		RootPassword: rootPasswordVal,
		Tacacs:       tacacsVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewSwitchMgmtValueNull() SwitchMgmtValue {
	return SwitchMgmtValue{
		state: attr.ValueStateNull,
	}
}

func NewSwitchMgmtValueUnknown() SwitchMgmtValue {
	return SwitchMgmtValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSwitchMgmtValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SwitchMgmtValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SwitchMgmtValue Attribute Value",
				"While creating a SwitchMgmtValue value, a missing attribute value was detected. "+
					"A SwitchMgmtValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SwitchMgmtValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SwitchMgmtValue Attribute Type",
				"While creating a SwitchMgmtValue value, an invalid attribute value was detected. "+
					"A SwitchMgmtValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SwitchMgmtValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SwitchMgmtValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SwitchMgmtValue Attribute Value",
				"While creating a SwitchMgmtValue value, an extra attribute value was detected. "+
					"A SwitchMgmtValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SwitchMgmtValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSwitchMgmtValueUnknown(), diags
	}

	configRevertAttribute, ok := attributes["config_revert"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`config_revert is missing from object`)

		return NewSwitchMgmtValueUnknown(), diags
	}

	configRevertVal, ok := configRevertAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`config_revert expected to be basetypes.Int64Value, was: %T`, configRevertAttribute))
	}

	protectReAttribute, ok := attributes["protect_re"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`protect_re is missing from object`)

		return NewSwitchMgmtValueUnknown(), diags
	}

	protectReVal, ok := protectReAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`protect_re expected to be basetypes.ObjectValue, was: %T`, protectReAttribute))
	}

	rootPasswordAttribute, ok := attributes["root_password"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`root_password is missing from object`)

		return NewSwitchMgmtValueUnknown(), diags
	}

	rootPasswordVal, ok := rootPasswordAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`root_password expected to be basetypes.StringValue, was: %T`, rootPasswordAttribute))
	}

	tacacsAttribute, ok := attributes["tacacs"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tacacs is missing from object`)

		return NewSwitchMgmtValueUnknown(), diags
	}

	tacacsVal, ok := tacacsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tacacs expected to be basetypes.ObjectValue, was: %T`, tacacsAttribute))
	}

	if diags.HasError() {
		return NewSwitchMgmtValueUnknown(), diags
	}

	return SwitchMgmtValue{
		ConfigRevert: configRevertVal,
		ProtectRe:    protectReVal,
		RootPassword: rootPasswordVal,
		Tacacs:       tacacsVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewSwitchMgmtValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SwitchMgmtValue {
	object, diags := NewSwitchMgmtValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSwitchMgmtValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SwitchMgmtType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSwitchMgmtValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSwitchMgmtValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSwitchMgmtValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSwitchMgmtValueMust(SwitchMgmtValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SwitchMgmtType) ValueType(ctx context.Context) attr.Value {
	return SwitchMgmtValue{}
}

var _ basetypes.ObjectValuable = SwitchMgmtValue{}

type SwitchMgmtValue struct {
	ConfigRevert basetypes.Int64Value  `tfsdk:"config_revert"`
	ProtectRe    basetypes.ObjectValue `tfsdk:"protect_re"`
	RootPassword basetypes.StringValue `tfsdk:"root_password"`
	Tacacs       basetypes.ObjectValue `tfsdk:"tacacs"`
	state        attr.ValueState
}

func (v SwitchMgmtValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["config_revert"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["protect_re"] = basetypes.ObjectType{
		AttrTypes: ProtectReValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["root_password"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["tacacs"] = basetypes.ObjectType{
		AttrTypes: TacacsValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.ConfigRevert.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["config_revert"] = val

		val, err = v.ProtectRe.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["protect_re"] = val

		val, err = v.RootPassword.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["root_password"] = val

		val, err = v.Tacacs.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tacacs"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SwitchMgmtValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SwitchMgmtValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SwitchMgmtValue) String() string {
	return "SwitchMgmtValue"
}

func (v SwitchMgmtValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var protectRe basetypes.ObjectValue

	if v.ProtectRe.IsNull() {
		protectRe = types.ObjectNull(
			ProtectReValue{}.AttributeTypes(ctx),
		)
	}

	if v.ProtectRe.IsUnknown() {
		protectRe = types.ObjectUnknown(
			ProtectReValue{}.AttributeTypes(ctx),
		)
	}

	if !v.ProtectRe.IsNull() && !v.ProtectRe.IsUnknown() {
		protectRe = types.ObjectValueMust(
			ProtectReValue{}.AttributeTypes(ctx),
			v.ProtectRe.Attributes(),
		)
	}

	var tacacs basetypes.ObjectValue

	if v.Tacacs.IsNull() {
		tacacs = types.ObjectNull(
			TacacsValue{}.AttributeTypes(ctx),
		)
	}

	if v.Tacacs.IsUnknown() {
		tacacs = types.ObjectUnknown(
			TacacsValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Tacacs.IsNull() && !v.Tacacs.IsUnknown() {
		tacacs = types.ObjectValueMust(
			TacacsValue{}.AttributeTypes(ctx),
			v.Tacacs.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"config_revert": basetypes.Int64Type{},
		"protect_re": basetypes.ObjectType{
			AttrTypes: ProtectReValue{}.AttributeTypes(ctx),
		},
		"root_password": basetypes.StringType{},
		"tacacs": basetypes.ObjectType{
			AttrTypes: TacacsValue{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"config_revert": v.ConfigRevert,
			"protect_re":    protectRe,
			"root_password": v.RootPassword,
			"tacacs":        tacacs,
		})

	return objVal, diags
}

func (v SwitchMgmtValue) Equal(o attr.Value) bool {
	other, ok := o.(SwitchMgmtValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.ConfigRevert.Equal(other.ConfigRevert) {
		return false
	}

	if !v.ProtectRe.Equal(other.ProtectRe) {
		return false
	}

	if !v.RootPassword.Equal(other.RootPassword) {
		return false
	}

	if !v.Tacacs.Equal(other.Tacacs) {
		return false
	}

	return true
}

func (v SwitchMgmtValue) Type(ctx context.Context) attr.Type {
	return SwitchMgmtType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SwitchMgmtValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"config_revert": basetypes.Int64Type{},
		"protect_re": basetypes.ObjectType{
			AttrTypes: ProtectReValue{}.AttributeTypes(ctx),
		},
		"root_password": basetypes.StringType{},
		"tacacs": basetypes.ObjectType{
			AttrTypes: TacacsValue{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = ProtectReType{}

type ProtectReType struct {
	basetypes.ObjectType
}

func (t ProtectReType) Equal(o attr.Type) bool {
	other, ok := o.(ProtectReType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ProtectReType) String() string {
	return "ProtectReType"
}

func (t ProtectReType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	allowedServicesAttribute, ok := attributes["allowed_services"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allowed_services is missing from object`)

		return nil, diags
	}

	allowedServicesVal, ok := allowedServicesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allowed_services expected to be basetypes.ListValue, was: %T`, allowedServicesAttribute))
	}

	customAttribute, ok := attributes["custom"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`custom is missing from object`)

		return nil, diags
	}

	customVal, ok := customAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`custom expected to be basetypes.ListValue, was: %T`, customAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	trustedHostsAttribute, ok := attributes["trusted_hosts"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`trusted_hosts is missing from object`)

		return nil, diags
	}

	trustedHostsVal, ok := trustedHostsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`trusted_hosts expected to be basetypes.ListValue, was: %T`, trustedHostsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ProtectReValue{
		AllowedServices: allowedServicesVal,
		Custom:          customVal,
		Enabled:         enabledVal,
		TrustedHosts:    trustedHostsVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewProtectReValueNull() ProtectReValue {
	return ProtectReValue{
		state: attr.ValueStateNull,
	}
}

func NewProtectReValueUnknown() ProtectReValue {
	return ProtectReValue{
		state: attr.ValueStateUnknown,
	}
}

func NewProtectReValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ProtectReValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ProtectReValue Attribute Value",
				"While creating a ProtectReValue value, a missing attribute value was detected. "+
					"A ProtectReValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ProtectReValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ProtectReValue Attribute Type",
				"While creating a ProtectReValue value, an invalid attribute value was detected. "+
					"A ProtectReValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ProtectReValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ProtectReValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ProtectReValue Attribute Value",
				"While creating a ProtectReValue value, an extra attribute value was detected. "+
					"A ProtectReValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ProtectReValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewProtectReValueUnknown(), diags
	}

	allowedServicesAttribute, ok := attributes["allowed_services"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allowed_services is missing from object`)

		return NewProtectReValueUnknown(), diags
	}

	allowedServicesVal, ok := allowedServicesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allowed_services expected to be basetypes.ListValue, was: %T`, allowedServicesAttribute))
	}

	customAttribute, ok := attributes["custom"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`custom is missing from object`)

		return NewProtectReValueUnknown(), diags
	}

	customVal, ok := customAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`custom expected to be basetypes.ListValue, was: %T`, customAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewProtectReValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	trustedHostsAttribute, ok := attributes["trusted_hosts"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`trusted_hosts is missing from object`)

		return NewProtectReValueUnknown(), diags
	}

	trustedHostsVal, ok := trustedHostsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`trusted_hosts expected to be basetypes.ListValue, was: %T`, trustedHostsAttribute))
	}

	if diags.HasError() {
		return NewProtectReValueUnknown(), diags
	}

	return ProtectReValue{
		AllowedServices: allowedServicesVal,
		Custom:          customVal,
		Enabled:         enabledVal,
		TrustedHosts:    trustedHostsVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewProtectReValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ProtectReValue {
	object, diags := NewProtectReValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewProtectReValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ProtectReType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewProtectReValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewProtectReValueUnknown(), nil
	}

	if in.IsNull() {
		return NewProtectReValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewProtectReValueMust(ProtectReValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ProtectReType) ValueType(ctx context.Context) attr.Value {
	return ProtectReValue{}
}

var _ basetypes.ObjectValuable = ProtectReValue{}

type ProtectReValue struct {
	AllowedServices basetypes.ListValue `tfsdk:"allowed_services"`
	Custom          basetypes.ListValue `tfsdk:"custom"`
	Enabled         basetypes.BoolValue `tfsdk:"enabled"`
	TrustedHosts    basetypes.ListValue `tfsdk:"trusted_hosts"`
	state           attr.ValueState
}

func (v ProtectReValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["allowed_services"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["custom"] = basetypes.ListType{
		ElemType: CustomValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["trusted_hosts"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.AllowedServices.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["allowed_services"] = val

		val, err = v.Custom.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["custom"] = val

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.TrustedHosts.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["trusted_hosts"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ProtectReValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ProtectReValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ProtectReValue) String() string {
	return "ProtectReValue"
}

func (v ProtectReValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	custom := types.ListValueMust(
		CustomType{
			basetypes.ObjectType{
				AttrTypes: CustomValue{}.AttributeTypes(ctx),
			},
		},
		v.Custom.Elements(),
	)

	if v.Custom.IsNull() {
		custom = types.ListNull(
			CustomType{
				basetypes.ObjectType{
					AttrTypes: CustomValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Custom.IsUnknown() {
		custom = types.ListUnknown(
			CustomType{
				basetypes.ObjectType{
					AttrTypes: CustomValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	allowedServicesVal, d := types.ListValue(types.StringType, v.AllowedServices.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"allowed_services": basetypes.ListType{
				ElemType: types.StringType,
			},
			"custom": basetypes.ListType{
				ElemType: CustomValue{}.Type(ctx),
			},
			"enabled": basetypes.BoolType{},
			"trusted_hosts": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	trustedHostsVal, d := types.ListValue(types.StringType, v.TrustedHosts.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"allowed_services": basetypes.ListType{
				ElemType: types.StringType,
			},
			"custom": basetypes.ListType{
				ElemType: CustomValue{}.Type(ctx),
			},
			"enabled": basetypes.BoolType{},
			"trusted_hosts": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"allowed_services": basetypes.ListType{
			ElemType: types.StringType,
		},
		"custom": basetypes.ListType{
			ElemType: CustomValue{}.Type(ctx),
		},
		"enabled": basetypes.BoolType{},
		"trusted_hosts": basetypes.ListType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"allowed_services": allowedServicesVal,
			"custom":           custom,
			"enabled":          v.Enabled,
			"trusted_hosts":    trustedHostsVal,
		})

	return objVal, diags
}

func (v ProtectReValue) Equal(o attr.Value) bool {
	other, ok := o.(ProtectReValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AllowedServices.Equal(other.AllowedServices) {
		return false
	}

	if !v.Custom.Equal(other.Custom) {
		return false
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.TrustedHosts.Equal(other.TrustedHosts) {
		return false
	}

	return true
}

func (v ProtectReValue) Type(ctx context.Context) attr.Type {
	return ProtectReType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ProtectReValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"allowed_services": basetypes.ListType{
			ElemType: types.StringType,
		},
		"custom": basetypes.ListType{
			ElemType: CustomValue{}.Type(ctx),
		},
		"enabled": basetypes.BoolType{},
		"trusted_hosts": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = CustomType{}

type CustomType struct {
	basetypes.ObjectType
}

func (t CustomType) Equal(o attr.Type) bool {
	other, ok := o.(CustomType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t CustomType) String() string {
	return "CustomType"
}

func (t CustomType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	portRangeAttribute, ok := attributes["port_range"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_range is missing from object`)

		return nil, diags
	}

	portRangeVal, ok := portRangeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_range expected to be basetypes.StringValue, was: %T`, portRangeAttribute))
	}

	protocolAttribute, ok := attributes["protocol"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`protocol is missing from object`)

		return nil, diags
	}

	protocolVal, ok := protocolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`protocol expected to be basetypes.StringValue, was: %T`, protocolAttribute))
	}

	subnetAttribute, ok := attributes["subnet"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet is missing from object`)

		return nil, diags
	}

	subnetVal, ok := subnetAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet expected to be basetypes.ListValue, was: %T`, subnetAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return CustomValue{
		PortRange: portRangeVal,
		Protocol:  protocolVal,
		Subnet:    subnetVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewCustomValueNull() CustomValue {
	return CustomValue{
		state: attr.ValueStateNull,
	}
}

func NewCustomValueUnknown() CustomValue {
	return CustomValue{
		state: attr.ValueStateUnknown,
	}
}

func NewCustomValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (CustomValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing CustomValue Attribute Value",
				"While creating a CustomValue value, a missing attribute value was detected. "+
					"A CustomValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CustomValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid CustomValue Attribute Type",
				"While creating a CustomValue value, an invalid attribute value was detected. "+
					"A CustomValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CustomValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("CustomValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra CustomValue Attribute Value",
				"While creating a CustomValue value, an extra attribute value was detected. "+
					"A CustomValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra CustomValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewCustomValueUnknown(), diags
	}

	portRangeAttribute, ok := attributes["port_range"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_range is missing from object`)

		return NewCustomValueUnknown(), diags
	}

	portRangeVal, ok := portRangeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_range expected to be basetypes.StringValue, was: %T`, portRangeAttribute))
	}

	protocolAttribute, ok := attributes["protocol"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`protocol is missing from object`)

		return NewCustomValueUnknown(), diags
	}

	protocolVal, ok := protocolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`protocol expected to be basetypes.StringValue, was: %T`, protocolAttribute))
	}

	subnetAttribute, ok := attributes["subnet"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet is missing from object`)

		return NewCustomValueUnknown(), diags
	}

	subnetVal, ok := subnetAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet expected to be basetypes.ListValue, was: %T`, subnetAttribute))
	}

	if diags.HasError() {
		return NewCustomValueUnknown(), diags
	}

	return CustomValue{
		PortRange: portRangeVal,
		Protocol:  protocolVal,
		Subnet:    subnetVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewCustomValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) CustomValue {
	object, diags := NewCustomValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewCustomValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t CustomType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewCustomValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewCustomValueUnknown(), nil
	}

	if in.IsNull() {
		return NewCustomValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewCustomValueMust(CustomValue{}.AttributeTypes(ctx), attributes), nil
}

func (t CustomType) ValueType(ctx context.Context) attr.Value {
	return CustomValue{}
}

var _ basetypes.ObjectValuable = CustomValue{}

type CustomValue struct {
	PortRange basetypes.StringValue `tfsdk:"port_range"`
	Protocol  basetypes.StringValue `tfsdk:"protocol"`
	Subnet    basetypes.ListValue   `tfsdk:"subnet"`
	state     attr.ValueState
}

func (v CustomValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["port_range"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["protocol"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["subnet"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.PortRange.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port_range"] = val

		val, err = v.Protocol.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["protocol"] = val

		val, err = v.Subnet.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["subnet"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v CustomValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v CustomValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v CustomValue) String() string {
	return "CustomValue"
}

func (v CustomValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	subnetVal, d := types.ListValue(types.StringType, v.Subnet.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"port_range": basetypes.StringType{},
			"protocol":   basetypes.StringType{},
			"subnet": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"port_range": basetypes.StringType{},
		"protocol":   basetypes.StringType{},
		"subnet": basetypes.ListType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"port_range": v.PortRange,
			"protocol":   v.Protocol,
			"subnet":     subnetVal,
		})

	return objVal, diags
}

func (v CustomValue) Equal(o attr.Value) bool {
	other, ok := o.(CustomValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.PortRange.Equal(other.PortRange) {
		return false
	}

	if !v.Protocol.Equal(other.Protocol) {
		return false
	}

	if !v.Subnet.Equal(other.Subnet) {
		return false
	}

	return true
}

func (v CustomValue) Type(ctx context.Context) attr.Type {
	return CustomType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v CustomValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"port_range": basetypes.StringType{},
		"protocol":   basetypes.StringType{},
		"subnet": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = TacacsType{}

type TacacsType struct {
	basetypes.ObjectType
}

func (t TacacsType) Equal(o attr.Type) bool {
	other, ok := o.(TacacsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t TacacsType) String() string {
	return "TacacsType"
}

func (t TacacsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	defaultRoleAttribute, ok := attributes["default_role"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`default_role is missing from object`)

		return nil, diags
	}

	defaultRoleVal, ok := defaultRoleAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`default_role expected to be basetypes.StringValue, was: %T`, defaultRoleAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	networkAttribute, ok := attributes["network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`network is missing from object`)

		return nil, diags
	}

	networkVal, ok := networkAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`network expected to be basetypes.StringValue, was: %T`, networkAttribute))
	}

	tacacctServersAttribute, ok := attributes["acct_servers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`acct_servers is missing from object`)

		return nil, diags
	}

	tacacctServersVal, ok := tacacctServersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`acct_servers expected to be basetypes.ListValue, was: %T`, tacacctServersAttribute))
	}

	tacplusServersAttribute, ok := attributes["tacplus_servers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tacplus_servers is missing from object`)

		return nil, diags
	}

	tacplusServersVal, ok := tacplusServersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tacplus_servers expected to be basetypes.ListValue, was: %T`, tacplusServersAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return TacacsValue{
		DefaultRole:    defaultRoleVal,
		Enabled:        enabledVal,
		Network:        networkVal,
		TacacctServers: tacacctServersVal,
		TacplusServers: tacplusServersVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewTacacsValueNull() TacacsValue {
	return TacacsValue{
		state: attr.ValueStateNull,
	}
}

func NewTacacsValueUnknown() TacacsValue {
	return TacacsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewTacacsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (TacacsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing TacacsValue Attribute Value",
				"While creating a TacacsValue value, a missing attribute value was detected. "+
					"A TacacsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TacacsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid TacacsValue Attribute Type",
				"While creating a TacacsValue value, an invalid attribute value was detected. "+
					"A TacacsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TacacsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("TacacsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra TacacsValue Attribute Value",
				"While creating a TacacsValue value, an extra attribute value was detected. "+
					"A TacacsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra TacacsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewTacacsValueUnknown(), diags
	}

	defaultRoleAttribute, ok := attributes["default_role"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`default_role is missing from object`)

		return NewTacacsValueUnknown(), diags
	}

	defaultRoleVal, ok := defaultRoleAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`default_role expected to be basetypes.StringValue, was: %T`, defaultRoleAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewTacacsValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	networkAttribute, ok := attributes["network"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`network is missing from object`)

		return NewTacacsValueUnknown(), diags
	}

	networkVal, ok := networkAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`network expected to be basetypes.StringValue, was: %T`, networkAttribute))
	}

	tacacctServersAttribute, ok := attributes["acct_servers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`acct_servers is missing from object`)

		return NewTacacsValueUnknown(), diags
	}

	tacacctServersVal, ok := tacacctServersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`acct_servers expected to be basetypes.ListValue, was: %T`, tacacctServersAttribute))
	}

	tacplusServersAttribute, ok := attributes["tacplus_servers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tacplus_servers is missing from object`)

		return NewTacacsValueUnknown(), diags
	}

	tacplusServersVal, ok := tacplusServersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tacplus_servers expected to be basetypes.ListValue, was: %T`, tacplusServersAttribute))
	}

	if diags.HasError() {
		return NewTacacsValueUnknown(), diags
	}

	return TacacsValue{
		DefaultRole:    defaultRoleVal,
		Enabled:        enabledVal,
		Network:        networkVal,
		TacacctServers: tacacctServersVal,
		TacplusServers: tacplusServersVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewTacacsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) TacacsValue {
	object, diags := NewTacacsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewTacacsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t TacacsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewTacacsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewTacacsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewTacacsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewTacacsValueMust(TacacsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t TacacsType) ValueType(ctx context.Context) attr.Value {
	return TacacsValue{}
}

var _ basetypes.ObjectValuable = TacacsValue{}

type TacacsValue struct {
	DefaultRole    basetypes.StringValue `tfsdk:"default_role"`
	Enabled        basetypes.BoolValue   `tfsdk:"enabled"`
	Network        basetypes.StringValue `tfsdk:"network"`
	TacacctServers basetypes.ListValue   `tfsdk:"acct_servers"`
	TacplusServers basetypes.ListValue   `tfsdk:"tacplus_servers"`
	state          attr.ValueState
}

func (v TacacsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["default_role"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["network"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["acct_servers"] = basetypes.ListType{
		ElemType: TacacctServersValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["tacplus_servers"] = basetypes.ListType{
		ElemType: TacplusServersValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.DefaultRole.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["default_role"] = val

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.Network.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["network"] = val

		val, err = v.TacacctServers.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["acct_servers"] = val

		val, err = v.TacplusServers.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tacplus_servers"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v TacacsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v TacacsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v TacacsValue) String() string {
	return "TacacsValue"
}

func (v TacacsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	tacacctServers := types.ListValueMust(
		TacacctServersType{
			basetypes.ObjectType{
				AttrTypes: TacacctServersValue{}.AttributeTypes(ctx),
			},
		},
		v.TacacctServers.Elements(),
	)

	if v.TacacctServers.IsNull() {
		tacacctServers = types.ListNull(
			TacacctServersType{
				basetypes.ObjectType{
					AttrTypes: TacacctServersValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.TacacctServers.IsUnknown() {
		tacacctServers = types.ListUnknown(
			TacacctServersType{
				basetypes.ObjectType{
					AttrTypes: TacacctServersValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	tacplusServers := types.ListValueMust(
		TacplusServersType{
			basetypes.ObjectType{
				AttrTypes: TacplusServersValue{}.AttributeTypes(ctx),
			},
		},
		v.TacplusServers.Elements(),
	)

	if v.TacplusServers.IsNull() {
		tacplusServers = types.ListNull(
			TacplusServersType{
				basetypes.ObjectType{
					AttrTypes: TacplusServersValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.TacplusServers.IsUnknown() {
		tacplusServers = types.ListUnknown(
			TacplusServersType{
				basetypes.ObjectType{
					AttrTypes: TacplusServersValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"default_role": basetypes.StringType{},
		"enabled":      basetypes.BoolType{},
		"network":      basetypes.StringType{},
		"acct_servers": basetypes.ListType{
			ElemType: TacacctServersValue{}.Type(ctx),
		},
		"tacplus_servers": basetypes.ListType{
			ElemType: TacplusServersValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"default_role":    v.DefaultRole,
			"enabled":         v.Enabled,
			"network":         v.Network,
			"acct_servers": tacacctServers,
			"tacplus_servers": tacplusServers,
		})

	return objVal, diags
}

func (v TacacsValue) Equal(o attr.Value) bool {
	other, ok := o.(TacacsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.DefaultRole.Equal(other.DefaultRole) {
		return false
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.Network.Equal(other.Network) {
		return false
	}

	if !v.TacacctServers.Equal(other.TacacctServers) {
		return false
	}

	if !v.TacplusServers.Equal(other.TacplusServers) {
		return false
	}

	return true
}

func (v TacacsValue) Type(ctx context.Context) attr.Type {
	return TacacsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v TacacsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"default_role": basetypes.StringType{},
		"enabled":      basetypes.BoolType{},
		"network":      basetypes.StringType{},
		"acct_servers": basetypes.ListType{
			ElemType: TacacctServersValue{}.Type(ctx),
		},
		"tacplus_servers": basetypes.ListType{
			ElemType: TacplusServersValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = TacacctServersType{}

type TacacctServersType struct {
	basetypes.ObjectType
}

func (t TacacctServersType) Equal(o attr.Type) bool {
	other, ok := o.(TacacctServersType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t TacacctServersType) String() string {
	return "TacacctServersType"
}

func (t TacacctServersType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	hostAttribute, ok := attributes["host"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`host is missing from object`)

		return nil, diags
	}

	hostVal, ok := hostAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`host expected to be basetypes.StringValue, was: %T`, hostAttribute))
	}

	portAttribute, ok := attributes["port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port is missing from object`)

		return nil, diags
	}

	portVal, ok := portAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port expected to be basetypes.StringValue, was: %T`, portAttribute))
	}

	secretAttribute, ok := attributes["secret"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`secret is missing from object`)

		return nil, diags
	}

	secretVal, ok := secretAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`secret expected to be basetypes.StringValue, was: %T`, secretAttribute))
	}

	timeoutAttribute, ok := attributes["timeout"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`timeout is missing from object`)

		return nil, diags
	}

	timeoutVal, ok := timeoutAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`timeout expected to be basetypes.Int64Value, was: %T`, timeoutAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return TacacctServersValue{
		Host:    hostVal,
		Port:    portVal,
		Secret:  secretVal,
		Timeout: timeoutVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewTacacctServersValueNull() TacacctServersValue {
	return TacacctServersValue{
		state: attr.ValueStateNull,
	}
}

func NewTacacctServersValueUnknown() TacacctServersValue {
	return TacacctServersValue{
		state: attr.ValueStateUnknown,
	}
}

func NewTacacctServersValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (TacacctServersValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing TacacctServersValue Attribute Value",
				"While creating a TacacctServersValue value, a missing attribute value was detected. "+
					"A TacacctServersValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TacacctServersValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid TacacctServersValue Attribute Type",
				"While creating a TacacctServersValue value, an invalid attribute value was detected. "+
					"A TacacctServersValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TacacctServersValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("TacacctServersValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra TacacctServersValue Attribute Value",
				"While creating a TacacctServersValue value, an extra attribute value was detected. "+
					"A TacacctServersValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra TacacctServersValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewTacacctServersValueUnknown(), diags
	}

	hostAttribute, ok := attributes["host"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`host is missing from object`)

		return NewTacacctServersValueUnknown(), diags
	}

	hostVal, ok := hostAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`host expected to be basetypes.StringValue, was: %T`, hostAttribute))
	}

	portAttribute, ok := attributes["port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port is missing from object`)

		return NewTacacctServersValueUnknown(), diags
	}

	portVal, ok := portAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port expected to be basetypes.StringValue, was: %T`, portAttribute))
	}

	secretAttribute, ok := attributes["secret"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`secret is missing from object`)

		return NewTacacctServersValueUnknown(), diags
	}

	secretVal, ok := secretAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`secret expected to be basetypes.StringValue, was: %T`, secretAttribute))
	}

	timeoutAttribute, ok := attributes["timeout"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`timeout is missing from object`)

		return NewTacacctServersValueUnknown(), diags
	}

	timeoutVal, ok := timeoutAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`timeout expected to be basetypes.Int64Value, was: %T`, timeoutAttribute))
	}

	if diags.HasError() {
		return NewTacacctServersValueUnknown(), diags
	}

	return TacacctServersValue{
		Host:    hostVal,
		Port:    portVal,
		Secret:  secretVal,
		Timeout: timeoutVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewTacacctServersValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) TacacctServersValue {
	object, diags := NewTacacctServersValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewTacacctServersValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t TacacctServersType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewTacacctServersValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewTacacctServersValueUnknown(), nil
	}

	if in.IsNull() {
		return NewTacacctServersValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewTacacctServersValueMust(TacacctServersValue{}.AttributeTypes(ctx), attributes), nil
}

func (t TacacctServersType) ValueType(ctx context.Context) attr.Value {
	return TacacctServersValue{}
}

var _ basetypes.ObjectValuable = TacacctServersValue{}

type TacacctServersValue struct {
	Host    basetypes.StringValue `tfsdk:"host"`
	Port    basetypes.StringValue `tfsdk:"port"`
	Secret  basetypes.StringValue `tfsdk:"secret"`
	Timeout basetypes.Int64Value  `tfsdk:"timeout"`
	state   attr.ValueState
}

func (v TacacctServersValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["host"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["port"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["secret"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["timeout"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Host.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["host"] = val

		val, err = v.Port.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port"] = val

		val, err = v.Secret.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["secret"] = val

		val, err = v.Timeout.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["timeout"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v TacacctServersValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v TacacctServersValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v TacacctServersValue) String() string {
	return "TacacctServersValue"
}

func (v TacacctServersValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"host":    basetypes.StringType{},
		"port":    basetypes.StringType{},
		"secret":  basetypes.StringType{},
		"timeout": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"host":    v.Host,
			"port":    v.Port,
			"secret":  v.Secret,
			"timeout": v.Timeout,
		})

	return objVal, diags
}

func (v TacacctServersValue) Equal(o attr.Value) bool {
	other, ok := o.(TacacctServersValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Host.Equal(other.Host) {
		return false
	}

	if !v.Port.Equal(other.Port) {
		return false
	}

	if !v.Secret.Equal(other.Secret) {
		return false
	}

	if !v.Timeout.Equal(other.Timeout) {
		return false
	}

	return true
}

func (v TacacctServersValue) Type(ctx context.Context) attr.Type {
	return TacacctServersType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v TacacctServersValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"host":    basetypes.StringType{},
		"port":    basetypes.StringType{},
		"secret":  basetypes.StringType{},
		"timeout": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = TacplusServersType{}

type TacplusServersType struct {
	basetypes.ObjectType
}

func (t TacplusServersType) Equal(o attr.Type) bool {
	other, ok := o.(TacplusServersType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t TacplusServersType) String() string {
	return "TacplusServersType"
}

func (t TacplusServersType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	hostAttribute, ok := attributes["host"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`host is missing from object`)

		return nil, diags
	}

	hostVal, ok := hostAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`host expected to be basetypes.StringValue, was: %T`, hostAttribute))
	}

	portAttribute, ok := attributes["port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port is missing from object`)

		return nil, diags
	}

	portVal, ok := portAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port expected to be basetypes.StringValue, was: %T`, portAttribute))
	}

	secretAttribute, ok := attributes["secret"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`secret is missing from object`)

		return nil, diags
	}

	secretVal, ok := secretAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`secret expected to be basetypes.StringValue, was: %T`, secretAttribute))
	}

	timeoutAttribute, ok := attributes["timeout"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`timeout is missing from object`)

		return nil, diags
	}

	timeoutVal, ok := timeoutAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`timeout expected to be basetypes.Int64Value, was: %T`, timeoutAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return TacplusServersValue{
		Host:    hostVal,
		Port:    portVal,
		Secret:  secretVal,
		Timeout: timeoutVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewTacplusServersValueNull() TacplusServersValue {
	return TacplusServersValue{
		state: attr.ValueStateNull,
	}
}

func NewTacplusServersValueUnknown() TacplusServersValue {
	return TacplusServersValue{
		state: attr.ValueStateUnknown,
	}
}

func NewTacplusServersValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (TacplusServersValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing TacplusServersValue Attribute Value",
				"While creating a TacplusServersValue value, a missing attribute value was detected. "+
					"A TacplusServersValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TacplusServersValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid TacplusServersValue Attribute Type",
				"While creating a TacplusServersValue value, an invalid attribute value was detected. "+
					"A TacplusServersValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TacplusServersValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("TacplusServersValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra TacplusServersValue Attribute Value",
				"While creating a TacplusServersValue value, an extra attribute value was detected. "+
					"A TacplusServersValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra TacplusServersValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewTacplusServersValueUnknown(), diags
	}

	hostAttribute, ok := attributes["host"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`host is missing from object`)

		return NewTacplusServersValueUnknown(), diags
	}

	hostVal, ok := hostAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`host expected to be basetypes.StringValue, was: %T`, hostAttribute))
	}

	portAttribute, ok := attributes["port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port is missing from object`)

		return NewTacplusServersValueUnknown(), diags
	}

	portVal, ok := portAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port expected to be basetypes.StringValue, was: %T`, portAttribute))
	}

	secretAttribute, ok := attributes["secret"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`secret is missing from object`)

		return NewTacplusServersValueUnknown(), diags
	}

	secretVal, ok := secretAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`secret expected to be basetypes.StringValue, was: %T`, secretAttribute))
	}

	timeoutAttribute, ok := attributes["timeout"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`timeout is missing from object`)

		return NewTacplusServersValueUnknown(), diags
	}

	timeoutVal, ok := timeoutAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`timeout expected to be basetypes.Int64Value, was: %T`, timeoutAttribute))
	}

	if diags.HasError() {
		return NewTacplusServersValueUnknown(), diags
	}

	return TacplusServersValue{
		Host:    hostVal,
		Port:    portVal,
		Secret:  secretVal,
		Timeout: timeoutVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewTacplusServersValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) TacplusServersValue {
	object, diags := NewTacplusServersValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewTacplusServersValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t TacplusServersType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewTacplusServersValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewTacplusServersValueUnknown(), nil
	}

	if in.IsNull() {
		return NewTacplusServersValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewTacplusServersValueMust(TacplusServersValue{}.AttributeTypes(ctx), attributes), nil
}

func (t TacplusServersType) ValueType(ctx context.Context) attr.Value {
	return TacplusServersValue{}
}

var _ basetypes.ObjectValuable = TacplusServersValue{}

type TacplusServersValue struct {
	Host    basetypes.StringValue `tfsdk:"host"`
	Port    basetypes.StringValue `tfsdk:"port"`
	Secret  basetypes.StringValue `tfsdk:"secret"`
	Timeout basetypes.Int64Value  `tfsdk:"timeout"`
	state   attr.ValueState
}

func (v TacplusServersValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["host"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["port"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["secret"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["timeout"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Host.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["host"] = val

		val, err = v.Port.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port"] = val

		val, err = v.Secret.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["secret"] = val

		val, err = v.Timeout.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["timeout"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v TacplusServersValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v TacplusServersValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v TacplusServersValue) String() string {
	return "TacplusServersValue"
}

func (v TacplusServersValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"host":    basetypes.StringType{},
		"port":    basetypes.StringType{},
		"secret":  basetypes.StringType{},
		"timeout": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"host":    v.Host,
			"port":    v.Port,
			"secret":  v.Secret,
			"timeout": v.Timeout,
		})

	return objVal, diags
}

func (v TacplusServersValue) Equal(o attr.Value) bool {
	other, ok := o.(TacplusServersValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Host.Equal(other.Host) {
		return false
	}

	if !v.Port.Equal(other.Port) {
		return false
	}

	if !v.Secret.Equal(other.Secret) {
		return false
	}

	if !v.Timeout.Equal(other.Timeout) {
		return false
	}

	return true
}

func (v TacplusServersValue) Type(ctx context.Context) attr.Type {
	return TacplusServersType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v TacplusServersValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"host":    basetypes.StringType{},
		"port":    basetypes.StringType{},
		"secret":  basetypes.StringType{},
		"timeout": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = VrfConfigType{}

type VrfConfigType struct {
	basetypes.ObjectType
}

func (t VrfConfigType) Equal(o attr.Type) bool {
	other, ok := o.(VrfConfigType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t VrfConfigType) String() string {
	return "VrfConfigType"
}

func (t VrfConfigType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return VrfConfigValue{
		Enabled: enabledVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewVrfConfigValueNull() VrfConfigValue {
	return VrfConfigValue{
		state: attr.ValueStateNull,
	}
}

func NewVrfConfigValueUnknown() VrfConfigValue {
	return VrfConfigValue{
		state: attr.ValueStateUnknown,
	}
}

func NewVrfConfigValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (VrfConfigValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing VrfConfigValue Attribute Value",
				"While creating a VrfConfigValue value, a missing attribute value was detected. "+
					"A VrfConfigValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VrfConfigValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid VrfConfigValue Attribute Type",
				"While creating a VrfConfigValue value, an invalid attribute value was detected. "+
					"A VrfConfigValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VrfConfigValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("VrfConfigValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra VrfConfigValue Attribute Value",
				"While creating a VrfConfigValue value, an extra attribute value was detected. "+
					"A VrfConfigValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra VrfConfigValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewVrfConfigValueUnknown(), diags
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewVrfConfigValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	if diags.HasError() {
		return NewVrfConfigValueUnknown(), diags
	}

	return VrfConfigValue{
		Enabled: enabledVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewVrfConfigValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) VrfConfigValue {
	object, diags := NewVrfConfigValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewVrfConfigValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t VrfConfigType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewVrfConfigValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewVrfConfigValueUnknown(), nil
	}

	if in.IsNull() {
		return NewVrfConfigValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewVrfConfigValueMust(VrfConfigValue{}.AttributeTypes(ctx), attributes), nil
}

func (t VrfConfigType) ValueType(ctx context.Context) attr.Value {
	return VrfConfigValue{}
}

var _ basetypes.ObjectValuable = VrfConfigValue{}

type VrfConfigValue struct {
	Enabled basetypes.BoolValue `tfsdk:"enabled"`
	state   attr.ValueState
}

func (v VrfConfigValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v VrfConfigValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v VrfConfigValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v VrfConfigValue) String() string {
	return "VrfConfigValue"
}

func (v VrfConfigValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"enabled": basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"enabled": v.Enabled,
		})

	return objVal, diags
}

func (v VrfConfigValue) Equal(o attr.Value) bool {
	other, ok := o.(VrfConfigValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	return true
}

func (v VrfConfigValue) Type(ctx context.Context) attr.Type {
	return VrfConfigType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v VrfConfigValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"enabled": basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = VrfInstancesType{}

type VrfInstancesType struct {
	basetypes.ObjectType
}

func (t VrfInstancesType) Equal(o attr.Type) bool {
	other, ok := o.(VrfInstancesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t VrfInstancesType) String() string {
	return "VrfInstancesType"
}

func (t VrfInstancesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	networksAttribute, ok := attributes["networks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`networks is missing from object`)

		return nil, diags
	}

	networksVal, ok := networksAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`networks expected to be basetypes.ListValue, was: %T`, networksAttribute))
	}

	vrfExtraRoutesAttribute, ok := attributes["vrf_extra_routes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vrf_extra_routes is missing from object`)

		return nil, diags
	}

	vrfExtraRoutesVal, ok := vrfExtraRoutesAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vrf_extra_routes expected to be basetypes.MapValue, was: %T`, vrfExtraRoutesAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return VrfInstancesValue{
		Networks:       networksVal,
		VrfExtraRoutes: vrfExtraRoutesVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewVrfInstancesValueNull() VrfInstancesValue {
	return VrfInstancesValue{
		state: attr.ValueStateNull,
	}
}

func NewVrfInstancesValueUnknown() VrfInstancesValue {
	return VrfInstancesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewVrfInstancesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (VrfInstancesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing VrfInstancesValue Attribute Value",
				"While creating a VrfInstancesValue value, a missing attribute value was detected. "+
					"A VrfInstancesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VrfInstancesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid VrfInstancesValue Attribute Type",
				"While creating a VrfInstancesValue value, an invalid attribute value was detected. "+
					"A VrfInstancesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VrfInstancesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("VrfInstancesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra VrfInstancesValue Attribute Value",
				"While creating a VrfInstancesValue value, an extra attribute value was detected. "+
					"A VrfInstancesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra VrfInstancesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewVrfInstancesValueUnknown(), diags
	}

	networksAttribute, ok := attributes["networks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`networks is missing from object`)

		return NewVrfInstancesValueUnknown(), diags
	}

	networksVal, ok := networksAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`networks expected to be basetypes.ListValue, was: %T`, networksAttribute))
	}

	vrfExtraRoutesAttribute, ok := attributes["vrf_extra_routes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vrf_extra_routes is missing from object`)

		return NewVrfInstancesValueUnknown(), diags
	}

	vrfExtraRoutesVal, ok := vrfExtraRoutesAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vrf_extra_routes expected to be basetypes.MapValue, was: %T`, vrfExtraRoutesAttribute))
	}

	if diags.HasError() {
		return NewVrfInstancesValueUnknown(), diags
	}

	return VrfInstancesValue{
		Networks:       networksVal,
		VrfExtraRoutes: vrfExtraRoutesVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewVrfInstancesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) VrfInstancesValue {
	object, diags := NewVrfInstancesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewVrfInstancesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t VrfInstancesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewVrfInstancesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewVrfInstancesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewVrfInstancesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewVrfInstancesValueMust(VrfInstancesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t VrfInstancesType) ValueType(ctx context.Context) attr.Value {
	return VrfInstancesValue{}
}

var _ basetypes.ObjectValuable = VrfInstancesValue{}

type VrfInstancesValue struct {
	Networks       basetypes.ListValue `tfsdk:"networks"`
	VrfExtraRoutes basetypes.MapValue  `tfsdk:"vrf_extra_routes"`
	state          attr.ValueState
}

func (v VrfInstancesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["networks"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["vrf_extra_routes"] = basetypes.MapType{
		ElemType: VrfExtraRoutesValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Networks.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["networks"] = val

		val, err = v.VrfExtraRoutes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vrf_extra_routes"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v VrfInstancesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v VrfInstancesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v VrfInstancesValue) String() string {
	return "VrfInstancesValue"
}

func (v VrfInstancesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	vrfExtraRoutes := types.MapValueMust(
		VrfExtraRoutesType{
			basetypes.ObjectType{
				AttrTypes: VrfExtraRoutesValue{}.AttributeTypes(ctx),
			},
		},
		v.VrfExtraRoutes.Elements(),
	)

	if v.VrfExtraRoutes.IsNull() {
		vrfExtraRoutes = types.MapNull(
			VrfExtraRoutesType{
				basetypes.ObjectType{
					AttrTypes: VrfExtraRoutesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.VrfExtraRoutes.IsUnknown() {
		vrfExtraRoutes = types.MapUnknown(
			VrfExtraRoutesType{
				basetypes.ObjectType{
					AttrTypes: VrfExtraRoutesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	networksVal, d := types.ListValue(types.StringType, v.Networks.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"networks": basetypes.ListType{
				ElemType: types.StringType,
			},
			"vrf_extra_routes": basetypes.MapType{
				ElemType: VrfExtraRoutesValue{}.Type(ctx),
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"networks": basetypes.ListType{
			ElemType: types.StringType,
		},
		"vrf_extra_routes": basetypes.MapType{
			ElemType: VrfExtraRoutesValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"networks":         networksVal,
			"vrf_extra_routes": vrfExtraRoutes,
		})

	return objVal, diags
}

func (v VrfInstancesValue) Equal(o attr.Value) bool {
	other, ok := o.(VrfInstancesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Networks.Equal(other.Networks) {
		return false
	}

	if !v.VrfExtraRoutes.Equal(other.VrfExtraRoutes) {
		return false
	}

	return true
}

func (v VrfInstancesValue) Type(ctx context.Context) attr.Type {
	return VrfInstancesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v VrfInstancesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"networks": basetypes.ListType{
			ElemType: types.StringType,
		},
		"vrf_extra_routes": basetypes.MapType{
			ElemType: VrfExtraRoutesValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = VrfExtraRoutesType{}

type VrfExtraRoutesType struct {
	basetypes.ObjectType
}

func (t VrfExtraRoutesType) Equal(o attr.Type) bool {
	other, ok := o.(VrfExtraRoutesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t VrfExtraRoutesType) String() string {
	return "VrfExtraRoutesType"
}

func (t VrfExtraRoutesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	viaAttribute, ok := attributes["via"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`via is missing from object`)

		return nil, diags
	}

	viaVal, ok := viaAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`via expected to be basetypes.StringValue, was: %T`, viaAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return VrfExtraRoutesValue{
		Via:   viaVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewVrfExtraRoutesValueNull() VrfExtraRoutesValue {
	return VrfExtraRoutesValue{
		state: attr.ValueStateNull,
	}
}

func NewVrfExtraRoutesValueUnknown() VrfExtraRoutesValue {
	return VrfExtraRoutesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewVrfExtraRoutesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (VrfExtraRoutesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing VrfExtraRoutesValue Attribute Value",
				"While creating a VrfExtraRoutesValue value, a missing attribute value was detected. "+
					"A VrfExtraRoutesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VrfExtraRoutesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid VrfExtraRoutesValue Attribute Type",
				"While creating a VrfExtraRoutesValue value, an invalid attribute value was detected. "+
					"A VrfExtraRoutesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VrfExtraRoutesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("VrfExtraRoutesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra VrfExtraRoutesValue Attribute Value",
				"While creating a VrfExtraRoutesValue value, an extra attribute value was detected. "+
					"A VrfExtraRoutesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra VrfExtraRoutesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewVrfExtraRoutesValueUnknown(), diags
	}

	viaAttribute, ok := attributes["via"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`via is missing from object`)

		return NewVrfExtraRoutesValueUnknown(), diags
	}

	viaVal, ok := viaAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`via expected to be basetypes.StringValue, was: %T`, viaAttribute))
	}

	if diags.HasError() {
		return NewVrfExtraRoutesValueUnknown(), diags
	}

	return VrfExtraRoutesValue{
		Via:   viaVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewVrfExtraRoutesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) VrfExtraRoutesValue {
	object, diags := NewVrfExtraRoutesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewVrfExtraRoutesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t VrfExtraRoutesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewVrfExtraRoutesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewVrfExtraRoutesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewVrfExtraRoutesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewVrfExtraRoutesValueMust(VrfExtraRoutesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t VrfExtraRoutesType) ValueType(ctx context.Context) attr.Value {
	return VrfExtraRoutesValue{}
}

var _ basetypes.ObjectValuable = VrfExtraRoutesValue{}

type VrfExtraRoutesValue struct {
	Via   basetypes.StringValue `tfsdk:"via"`
	state attr.ValueState
}

func (v VrfExtraRoutesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["via"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Via.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["via"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v VrfExtraRoutesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v VrfExtraRoutesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v VrfExtraRoutesValue) String() string {
	return "VrfExtraRoutesValue"
}

func (v VrfExtraRoutesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"via": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"via": v.Via,
		})

	return objVal, diags
}

func (v VrfExtraRoutesValue) Equal(o attr.Value) bool {
	other, ok := o.(VrfExtraRoutesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Via.Equal(other.Via) {
		return false
	}

	return true
}

func (v VrfExtraRoutesValue) Type(ctx context.Context) attr.Type {
	return VrfExtraRoutesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v VrfExtraRoutesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"via": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = VsInstanceType{}

type VsInstanceType struct {
	basetypes.ObjectType
}

func (t VsInstanceType) Equal(o attr.Type) bool {
	other, ok := o.(VsInstanceType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t VsInstanceType) String() string {
	return "VsInstanceType"
}

func (t VsInstanceType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	networksAttribute, ok := attributes["networks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`networks is missing from object`)

		return nil, diags
	}

	networksVal, ok := networksAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`networks expected to be basetypes.ListValue, was: %T`, networksAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return VsInstanceValue{
		Networks: networksVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewVsInstanceValueNull() VsInstanceValue {
	return VsInstanceValue{
		state: attr.ValueStateNull,
	}
}

func NewVsInstanceValueUnknown() VsInstanceValue {
	return VsInstanceValue{
		state: attr.ValueStateUnknown,
	}
}

func NewVsInstanceValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (VsInstanceValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing VsInstanceValue Attribute Value",
				"While creating a VsInstanceValue value, a missing attribute value was detected. "+
					"A VsInstanceValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VsInstanceValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid VsInstanceValue Attribute Type",
				"While creating a VsInstanceValue value, an invalid attribute value was detected. "+
					"A VsInstanceValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VsInstanceValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("VsInstanceValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra VsInstanceValue Attribute Value",
				"While creating a VsInstanceValue value, an extra attribute value was detected. "+
					"A VsInstanceValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra VsInstanceValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewVsInstanceValueUnknown(), diags
	}

	networksAttribute, ok := attributes["networks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`networks is missing from object`)

		return NewVsInstanceValueUnknown(), diags
	}

	networksVal, ok := networksAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`networks expected to be basetypes.ListValue, was: %T`, networksAttribute))
	}

	if diags.HasError() {
		return NewVsInstanceValueUnknown(), diags
	}

	return VsInstanceValue{
		Networks: networksVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewVsInstanceValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) VsInstanceValue {
	object, diags := NewVsInstanceValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewVsInstanceValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t VsInstanceType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewVsInstanceValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewVsInstanceValueUnknown(), nil
	}

	if in.IsNull() {
		return NewVsInstanceValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewVsInstanceValueMust(VsInstanceValue{}.AttributeTypes(ctx), attributes), nil
}

func (t VsInstanceType) ValueType(ctx context.Context) attr.Value {
	return VsInstanceValue{}
}

var _ basetypes.ObjectValuable = VsInstanceValue{}

type VsInstanceValue struct {
	Networks basetypes.ListValue `tfsdk:"networks"`
	state    attr.ValueState
}

func (v VsInstanceValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["networks"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Networks.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["networks"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v VsInstanceValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v VsInstanceValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v VsInstanceValue) String() string {
	return "VsInstanceValue"
}

func (v VsInstanceValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	networksVal, d := types.ListValue(types.StringType, v.Networks.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"networks": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"networks": basetypes.ListType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"networks": networksVal,
		})

	return objVal, diags
}

func (v VsInstanceValue) Equal(o attr.Value) bool {
	other, ok := o.(VsInstanceValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Networks.Equal(other.Networks) {
		return false
	}

	return true
}

func (v VsInstanceValue) Type(ctx context.Context) attr.Type {
	return VsInstanceType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v VsInstanceValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"networks": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}
