// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package resource_site_setting

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework-validators/int64validator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/booldefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/int64default"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
)

func SiteSettingResourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"ap_updown_threshold": schema.Int64Attribute{
				Optional:            true,
				Description:         "enable threshold-based device down delivery for AP devices only. When configured it takes effect for AP devices and `device_updown_threshold` is ignored.",
				MarkdownDescription: "enable threshold-based device down delivery for AP devices only. When configured it takes effect for AP devices and `device_updown_threshold` is ignored.",
			},
			"auto_upgrade": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"custom_versions": schema.MapAttribute{
						ElementType:         types.StringType,
						Optional:            true,
						Computed:            true,
						Description:         "custom versions for different models. Property key is the model name (e.g. \"AP41\")",
						MarkdownDescription: "custom versions for different models. Property key is the model name (e.g. \"AP41\")",
					},
					"day_of_week": schema.StringAttribute{
						Optional: true,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"",
								"any",
								"mon",
								"tue",
								"wed",
								"thu",
								"fri",
								"sat",
								"sun",
							),
						},
					},
					"enabled": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "whether auto upgrade should happen (Note that Mist may auto-upgrade if the version is not supported)",
						MarkdownDescription: "whether auto upgrade should happen (Note that Mist may auto-upgrade if the version is not supported)",
						Default:             booldefault.StaticBool(false),
					},
					"time_of_day": schema.StringAttribute{
						Optional:            true,
						Description:         "any / HH:MM (24-hour format), upgrade will happen within up to 1-hour from this time",
						MarkdownDescription: "any / HH:MM (24-hour format), upgrade will happen within up to 1-hour from this time",
					},
					"version": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "desired version",
						MarkdownDescription: "desired version",
						Validators: []validator.String{
							stringvalidator.OneOf(
								"",
								"beta",
								"stable",
								"custom",
							),
						},
						Default: stringdefault.StaticString("stable"),
					},
				},
				CustomType: AutoUpgradeType{
					ObjectType: types.ObjectType{
						AttrTypes: AutoUpgradeValue{}.AttributeTypes(ctx),
					},
				},
				Optional:            true,
				Description:         "Auto Upgrade Settings",
				MarkdownDescription: "Auto Upgrade Settings",
			},
			"blacklist_url": schema.StringAttribute{
				Computed: true,
			},
			"ble_config": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"beacon_enabled": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "whether Mist beacons is enabled",
						MarkdownDescription: "whether Mist beacons is enabled",
						Default:             booldefault.StaticBool(false),
					},
					"beacon_rate": schema.Int64Attribute{
						Optional:            true,
						Computed:            true,
						Description:         "required if `beacon_rate_mode`==`custom`, 1-10, in number-beacons-per-second",
						MarkdownDescription: "required if `beacon_rate_mode`==`custom`, 1-10, in number-beacons-per-second",
						Default:             int64default.StaticInt64(0),
					},
					"beacon_rate_mode": schema.StringAttribute{
						Optional: true,
						Computed: true,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"",
								"default",
								"custom",
							),
						},
						Default: stringdefault.StaticString("default"),
					},
					"beam_disabled": schema.ListAttribute{
						ElementType:         types.Int64Type,
						Optional:            true,
						Description:         "list of AP BLE location beam numbers (1-8) which should be disabled at the AP and not transmit location information (where beam 1 is oriented at the top the AP, growing counter-clock-wise, with 9 being the omni BLE beam)",
						MarkdownDescription: "list of AP BLE location beam numbers (1-8) which should be disabled at the AP and not transmit location information (where beam 1 is oriented at the top the AP, growing counter-clock-wise, with 9 being the omni BLE beam)",
					},
					"custom_ble_packet_enabled": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "can be enabled if `beacon_enabled`==`true`, whether to send custom packet",
						MarkdownDescription: "can be enabled if `beacon_enabled`==`true`, whether to send custom packet",
						Default:             booldefault.StaticBool(false),
					},
					"custom_ble_packet_frame": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "The custom frame to be sent out in this beacon. The frame must be a hexstring",
						MarkdownDescription: "The custom frame to be sent out in this beacon. The frame must be a hexstring",
						Default:             stringdefault.StaticString(""),
					},
					"custom_ble_packet_freq_msec": schema.Int64Attribute{
						Optional:            true,
						Computed:            true,
						Description:         "Frequency (msec) of data emitted by custom ble beacon",
						MarkdownDescription: "Frequency (msec) of data emitted by custom ble beacon",
						Validators: []validator.Int64{
							int64validator.AtLeast(0),
						},
						Default: int64default.StaticInt64(0),
					},
					"eddystone_uid_adv_power": schema.Int64Attribute{
						Optional:            true,
						Computed:            true,
						Description:         "advertised TX Power, -100 to 20 (dBm), omit this attribute to use default",
						MarkdownDescription: "advertised TX Power, -100 to 20 (dBm), omit this attribute to use default",
						Validators: []validator.Int64{
							int64validator.Between(-100, 20),
						},
						Default: int64default.StaticInt64(0),
					},
					"eddystone_uid_beams": schema.StringAttribute{
						Optional: true,
						Computed: true,
						Default:  stringdefault.StaticString(""),
					},
					"eddystone_uid_enabled": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "only if `beacon_enabled`==`false`, Whether Eddystone-UID beacon is enabled",
						MarkdownDescription: "only if `beacon_enabled`==`false`, Whether Eddystone-UID beacon is enabled",
						Default:             booldefault.StaticBool(false),
					},
					"eddystone_uid_freq_msec": schema.Int64Attribute{
						Optional:            true,
						Computed:            true,
						Description:         "Frequency (msec) of data emmit by Eddystone-UID beacon",
						MarkdownDescription: "Frequency (msec) of data emmit by Eddystone-UID beacon",
						Default:             int64default.StaticInt64(0),
					},
					"eddystone_uid_instance": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "Eddystone-UID instance for the device",
						MarkdownDescription: "Eddystone-UID instance for the device",
						Default:             stringdefault.StaticString(""),
					},
					"eddystone_uid_namespace": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "Eddystone-UID namespace",
						MarkdownDescription: "Eddystone-UID namespace",
						Default:             stringdefault.StaticString(""),
					},
					"eddystone_url_adv_power": schema.Int64Attribute{
						Optional:            true,
						Computed:            true,
						Description:         "advertised TX Power, -100 to 20 (dBm), omit this attribute to use default",
						MarkdownDescription: "advertised TX Power, -100 to 20 (dBm), omit this attribute to use default",
						Validators: []validator.Int64{
							int64validator.Between(-100, 20),
						},
						Default: int64default.StaticInt64(0),
					},
					"eddystone_url_beams": schema.StringAttribute{
						Optional: true,
						Computed: true,
						Default:  stringdefault.StaticString(""),
					},
					"eddystone_url_enabled": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "only if `beacon_enabled`==`false`, Whether Eddystone-URL beacon is enabled",
						MarkdownDescription: "only if `beacon_enabled`==`false`, Whether Eddystone-URL beacon is enabled",
						Default:             booldefault.StaticBool(false),
					},
					"eddystone_url_freq_msec": schema.Int64Attribute{
						Optional:            true,
						Computed:            true,
						Description:         "Frequency (msec) of data emit by Eddystone-UID beacon",
						MarkdownDescription: "Frequency (msec) of data emit by Eddystone-UID beacon",
						Default:             int64default.StaticInt64(0),
					},
					"eddystone_url_url": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "URL pointed by Eddystone-URL beacon",
						MarkdownDescription: "URL pointed by Eddystone-URL beacon",
						Default:             stringdefault.StaticString(""),
					},
					"ibeacon_adv_power": schema.Int64Attribute{
						Optional:            true,
						Computed:            true,
						Description:         "advertised TX Power, -100 to 20 (dBm), omit this attribute to use default",
						MarkdownDescription: "advertised TX Power, -100 to 20 (dBm), omit this attribute to use default",
						Validators: []validator.Int64{
							int64validator.Between(-100, 20),
						},
						Default: int64default.StaticInt64(0),
					},
					"ibeacon_beams": schema.StringAttribute{
						Optional: true,
						Computed: true,
						Default:  stringdefault.StaticString(""),
					},
					"ibeacon_enabled": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "can be enabled if `beacon_enabled`==`true`, whether to send iBeacon",
						MarkdownDescription: "can be enabled if `beacon_enabled`==`true`, whether to send iBeacon",
						Default:             booldefault.StaticBool(false),
					},
					"ibeacon_freq_msec": schema.Int64Attribute{
						Optional:            true,
						Computed:            true,
						Description:         "Frequency (msec) of data emmit for iBeacon",
						MarkdownDescription: "Frequency (msec) of data emmit for iBeacon",
						Default:             int64default.StaticInt64(0),
					},
					"ibeacon_major": schema.Int64Attribute{
						Optional:            true,
						Computed:            true,
						Description:         "Major number for iBeacon",
						MarkdownDescription: "Major number for iBeacon",
						Validators: []validator.Int64{
							int64validator.Between(1, 65535),
						},
						Default: int64default.StaticInt64(0),
					},
					"ibeacon_minor": schema.Int64Attribute{
						Optional:            true,
						Computed:            true,
						Description:         "Minor number for iBeacon",
						MarkdownDescription: "Minor number for iBeacon",
						Validators: []validator.Int64{
							int64validator.Between(1, 65535),
						},
						Default: int64default.StaticInt64(0),
					},
					"ibeacon_uuid": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "optional, if not specified, the same UUID as the beacon will be used",
						MarkdownDescription: "optional, if not specified, the same UUID as the beacon will be used",
						Default:             stringdefault.StaticString(""),
					},
					"power": schema.Int64Attribute{
						Optional:            true,
						Computed:            true,
						Description:         "required if `power_mode`==`custom`",
						MarkdownDescription: "required if `power_mode`==`custom`",
						Validators: []validator.Int64{
							int64validator.Between(1, 10),
						},
						Default: int64default.StaticInt64(9),
					},
					"power_mode": schema.StringAttribute{
						Optional: true,
						Computed: true,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"",
								"default",
								"custom",
							),
						},
						Default: stringdefault.StaticString("default"),
					},
				},
				CustomType: BleConfigType{
					ObjectType: types.ObjectType{
						AttrTypes: BleConfigValue{}.AttributeTypes(ctx),
					},
				},
				Optional:            true,
				Description:         "BLE AP settings",
				MarkdownDescription: "BLE AP settings",
			},
			"config_auto_revert": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "whether to enable ap auto config revert",
				MarkdownDescription: "whether to enable ap auto config revert",
				Default:             booldefault.StaticBool(false),
			},
			"config_push_policy": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"no_push": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "stop any new config from being pushed to the device",
						MarkdownDescription: "stop any new config from being pushed to the device",
						Default:             booldefault.StaticBool(false),
					},
					"push_window": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"enabled": schema.BoolAttribute{
								Optional: true,
								Computed: true,
								Default:  booldefault.StaticBool(false),
							},
							"hours": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{
									"fri": schema.StringAttribute{
										Optional: true,
										Computed: true,
										Default:  stringdefault.StaticString(""),
									},
									"mon": schema.StringAttribute{
										Optional: true,
										Computed: true,
										Default:  stringdefault.StaticString(""),
									},
									"sat": schema.StringAttribute{
										Optional: true,
										Computed: true,
										Default:  stringdefault.StaticString(""),
									},
									"sun": schema.StringAttribute{
										Optional: true,
										Computed: true,
										Default:  stringdefault.StaticString(""),
									},
									"thu": schema.StringAttribute{
										Optional: true,
										Computed: true,
										Default:  stringdefault.StaticString(""),
									},
									"tue": schema.StringAttribute{
										Optional: true,
										Computed: true,
										Default:  stringdefault.StaticString(""),
									},
									"wed": schema.StringAttribute{
										Optional: true,
										Computed: true,
										Default:  stringdefault.StaticString(""),
									},
								},
								CustomType: HoursType{
									ObjectType: types.ObjectType{
										AttrTypes: HoursValue{}.AttributeTypes(ctx),
									},
								},
								Optional:            true,
								Description:         "hours of operation filter, the available days (mon, tue, wed, thu, fri, sat, sun). \n\n**Note**: If the dow is not defined then it’s treated as 00:00-23:59.",
								MarkdownDescription: "hours of operation filter, the available days (mon, tue, wed, thu, fri, sat, sun). \n\n**Note**: If the dow is not defined then it’s treated as 00:00-23:59.",
							},
						},
						CustomType: PushWindowType{
							ObjectType: types.ObjectType{
								AttrTypes: PushWindowValue{}.AttributeTypes(ctx),
							},
						},
						Optional:            true,
						Description:         "if enabled, new config will only be pushed to device within the specified time window",
						MarkdownDescription: "if enabled, new config will only be pushed to device within the specified time window",
					},
				},
				CustomType: ConfigPushPolicyType{
					ObjectType: types.ObjectType{
						AttrTypes: ConfigPushPolicyValue{}.AttributeTypes(ctx),
					},
				},
				Optional:            true,
				Description:         "mist also uses some heuristic rules to prevent destructive configs from being pushed",
				MarkdownDescription: "mist also uses some heuristic rules to prevent destructive configs from being pushed",
			},
			"critical_url_monitoring": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"enabled": schema.BoolAttribute{
						Optional: true,
						Computed: true,
						Default:  booldefault.StaticBool(true),
					},
					"monitors": schema.ListNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"url": schema.StringAttribute{
									Optional: true,
								},
								"vlan_id": schema.Int64Attribute{
									Optional: true,
									Computed: true,
									Default:  int64default.StaticInt64(1),
								},
							},
							CustomType: MonitorsType{
								ObjectType: types.ObjectType{
									AttrTypes: MonitorsValue{}.AttributeTypes(ctx),
								},
							},
						},
						Optional: true,
					},
				},
				CustomType: CriticalUrlMonitoringType{
					ObjectType: types.ObjectType{
						AttrTypes: CriticalUrlMonitoringValue{}.AttributeTypes(ctx),
					},
				},
				Optional:            true,
				Description:         "you can define some URLs that's critical to site operaitons the latency will be captured and considered for site health",
				MarkdownDescription: "you can define some URLs that's critical to site operaitons the latency will be captured and considered for site health",
			},
			"device_updown_threshold": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "sending AP_DISCONNECTED event in device-updowns only if AP_CONNECTED is not seen within the threshold, in minutes",
				MarkdownDescription: "sending AP_DISCONNECTED event in device-updowns only if AP_CONNECTED is not seen within the threshold, in minutes",
				Validators: []validator.Int64{
					int64validator.Between(0, 30),
				},
				Default: int64default.StaticInt64(0),
			},
			"disabled_system_defined_port_usages": schema.ListAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Description:         "if some system-default port usages are not desired - namely, ap / iot / uplink",
				MarkdownDescription: "if some system-default port usages are not desired - namely, ap / iot / uplink",
			},
			"engagement": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"dwell_tag_names": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"bounce": schema.StringAttribute{
								Optional: true,
							},
							"engaged": schema.StringAttribute{
								Optional: true,
							},
							"passerby": schema.StringAttribute{
								Optional: true,
							},
							"stationed": schema.StringAttribute{
								Optional: true,
							},
						},
						CustomType: DwellTagNamesType{
							ObjectType: types.ObjectType{
								AttrTypes: DwellTagNamesValue{}.AttributeTypes(ctx),
							},
						},
						Optional: true,
					},
					"dwell_tags": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"bounce": schema.StringAttribute{
								Optional: true,
							},
							"engaged": schema.StringAttribute{
								Optional: true,
							},
							"passerby": schema.StringAttribute{
								Optional: true,
							},
							"stationed": schema.StringAttribute{
								Optional: true,
							},
						},
						CustomType: DwellTagsType{
							ObjectType: types.ObjectType{
								AttrTypes: DwellTagsValue{}.AttributeTypes(ctx),
							},
						},
						Optional:            true,
						Description:         "add tags to visits within the duration (in seconds), available tags (passerby, bounce, engaged, stationed)",
						MarkdownDescription: "add tags to visits within the duration (in seconds), available tags (passerby, bounce, engaged, stationed)",
					},
					"hours": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"fri": schema.StringAttribute{
								Optional: true,
								Computed: true,
								Default:  stringdefault.StaticString(""),
							},
							"mon": schema.StringAttribute{
								Optional: true,
								Computed: true,
								Default:  stringdefault.StaticString(""),
							},
							"sat": schema.StringAttribute{
								Optional: true,
								Computed: true,
								Default:  stringdefault.StaticString(""),
							},
							"sun": schema.StringAttribute{
								Optional: true,
								Computed: true,
								Default:  stringdefault.StaticString(""),
							},
							"thu": schema.StringAttribute{
								Optional: true,
								Computed: true,
								Default:  stringdefault.StaticString(""),
							},
							"tue": schema.StringAttribute{
								Optional: true,
								Computed: true,
								Default:  stringdefault.StaticString(""),
							},
							"wed": schema.StringAttribute{
								Optional: true,
								Computed: true,
								Default:  stringdefault.StaticString(""),
							},
						},
						CustomType: HoursType{
							ObjectType: types.ObjectType{
								AttrTypes: HoursValue{}.AttributeTypes(ctx),
							},
						},
						Optional:            true,
						Description:         "hours of operation filter, the available days (mon, tue, wed, thu, fri, sat, sun). \n\n**Note**: If the dow is not defined then it’s treated as 00:00-23:59.",
						MarkdownDescription: "hours of operation filter, the available days (mon, tue, wed, thu, fri, sat, sun). \n\n**Note**: If the dow is not defined then it’s treated as 00:00-23:59.",
					},
					"max_dwell": schema.Int64Attribute{
						Optional:            true,
						Computed:            true,
						Description:         "max time, default is 43200(12h), max is 68400 (18h)",
						MarkdownDescription: "max time, default is 43200(12h), max is 68400 (18h)",
						Validators: []validator.Int64{
							int64validator.Between(1, 68400),
						},
						Default: int64default.StaticInt64(43200),
					},
					"min_dwell": schema.Int64Attribute{
						Optional:            true,
						Description:         "min time",
						MarkdownDescription: "min time",
						Validators: []validator.Int64{
							int64validator.AtLeast(0),
						},
					},
				},
				CustomType: EngagementType{
					ObjectType: types.ObjectType{
						AttrTypes: EngagementValue{}.AttributeTypes(ctx),
					},
				},
				Optional:            true,
				Description:         "**Note**: if hours does not exist, it’s treated as everyday of the week, 00:00-23:59. Currently we don’t allow multiple ranges for the same day\n\n**Note**: default values for `dwell_tags`: passerby (1,300) bounce (301, 14400) engaged (14401, 28800) stationed (28801, 42000)\n\n**Note**: default values for `dwell_tag_names`: passerby = “Passerby”, bounce = “Visitor”, engaged = “Associates”, stationed = “Assets”",
				MarkdownDescription: "**Note**: if hours does not exist, it’s treated as everyday of the week, 00:00-23:59. Currently we don’t allow multiple ranges for the same day\n\n**Note**: default values for `dwell_tags`: passerby (1,300) bounce (301, 14400) engaged (14401, 28800) stationed (28801, 42000)\n\n**Note**: default values for `dwell_tag_names`: passerby = “Passerby”, bounce = “Visitor”, engaged = “Associates”, stationed = “Assets”",
			},
			"gateway_updown_threshold": schema.Int64Attribute{
				Optional:            true,
				Description:         "enable threshold-based device down delivery for Gateway devices only. When configured it takes effect for GW devices and `device_updown_threshold` is ignored.",
				MarkdownDescription: "enable threshold-based device down delivery for Gateway devices only. When configured it takes effect for GW devices and `device_updown_threshold` is ignored.",
			},
			"led": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"brightness": schema.Int64Attribute{
						Optional: true,
						Computed: true,
						Default:  int64default.StaticInt64(255),
					},
					"enabled": schema.BoolAttribute{
						Optional: true,
						Computed: true,
						Default:  booldefault.StaticBool(true),
					},
				},
				CustomType: LedType{
					ObjectType: types.ObjectType{
						AttrTypes: LedValue{}.AttributeTypes(ctx),
					},
				},
				Optional:            true,
				Description:         "LED AP settings",
				MarkdownDescription: "LED AP settings",
			},
			"occupancy": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"assets_enabled": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "indicate whether named BLE assets should be included in the zone occupancy calculation",
						MarkdownDescription: "indicate whether named BLE assets should be included in the zone occupancy calculation",
						Default:             booldefault.StaticBool(false),
					},
					"clients_enabled": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "indicate whether connected WiFi clients should be included in the zone occupancy calculation",
						MarkdownDescription: "indicate whether connected WiFi clients should be included in the zone occupancy calculation",
						Default:             booldefault.StaticBool(true),
					},
					"min_duration": schema.Int64Attribute{
						Optional:            true,
						Computed:            true,
						Description:         "minimum duration",
						MarkdownDescription: "minimum duration",
						Default:             int64default.StaticInt64(3000),
					},
					"sdkclients_enabled": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "indicate whether SDK clients should be included in the zone occupancy calculation",
						MarkdownDescription: "indicate whether SDK clients should be included in the zone occupancy calculation",
						Default:             booldefault.StaticBool(false),
					},
					"unconnected_clients_enabled": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "indicate whether unconnected WiFi clients should be included in the zone occupancy calculation",
						MarkdownDescription: "indicate whether unconnected WiFi clients should be included in the zone occupancy calculation",
						Default:             booldefault.StaticBool(false),
					},
				},
				CustomType: OccupancyType{
					ObjectType: types.ObjectType{
						AttrTypes: OccupancyValue{}.AttributeTypes(ctx),
					},
				},
				Optional:            true,
				Description:         "Occupancy Analytics settings",
				MarkdownDescription: "Occupancy Analytics settings",
			},
			"org_id": schema.StringAttribute{
				Computed: true,
			},
			"persist_config_on_device": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "whether to store the config on AP",
				MarkdownDescription: "whether to store the config on AP",
				Default:             booldefault.StaticBool(false),
			},
			"proxy": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"url": schema.StringAttribute{
						Optional: true,
					},
				},
				CustomType: ProxyType{
					ObjectType: types.ObjectType{
						AttrTypes: ProxyValue{}.AttributeTypes(ctx),
					},
				},
				Optional:            true,
				Description:         "Proxy Configuration to talk to Mist",
				MarkdownDescription: "Proxy Configuration to talk to Mist",
			},
			"report_gatt": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "whether AP should periodically connect to BLE devices and report GATT device info (device name, manufacturer name, serial number, battery %, temperature, humidity)",
				MarkdownDescription: "whether AP should periodically connect to BLE devices and report GATT device info (device name, manufacturer name, serial number, battery %, temperature, humidity)",
				Default:             booldefault.StaticBool(false),
			},
			"rogue": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"enabled": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "whether or not rogue detection is enabled",
						MarkdownDescription: "whether or not rogue detection is enabled",
						Default:             booldefault.StaticBool(false),
					},
					"honeypot_enabled": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "whether or not honeypot detection is enabled",
						MarkdownDescription: "whether or not honeypot detection is enabled",
						Default:             booldefault.StaticBool(false),
					},
					"min_duration": schema.Int64Attribute{
						Optional:            true,
						Computed:            true,
						Description:         "minimum duration for a bssid to be considered rogue",
						MarkdownDescription: "minimum duration for a bssid to be considered rogue",
						Validators: []validator.Int64{
							int64validator.AtMost(59),
						},
						Default: int64default.StaticInt64(10),
					},
					"min_rssi": schema.Int64Attribute{
						Optional:            true,
						Computed:            true,
						Description:         "minimum RSSI for an AP to be considered rogue (ignoring APs that’s far away)",
						MarkdownDescription: "minimum RSSI for an AP to be considered rogue (ignoring APs that’s far away)",
						Validators: []validator.Int64{
							int64validator.AtLeast(-85),
						},
						Default: int64default.StaticInt64(-80),
					},
					"whitelisted_bssids": schema.ListAttribute{
						ElementType:         types.StringType,
						Optional:            true,
						Computed:            true,
						Description:         "list of BSSIDs to whitelist. Ex: \"cc-:8e-:6f-:d4-:bf-:16\", \"cc-8e-6f-d4-bf-16\", \"cc-73-*\", \"cc:82:*\"",
						MarkdownDescription: "list of BSSIDs to whitelist. Ex: \"cc-:8e-:6f-:d4-:bf-:16\", \"cc-8e-6f-d4-bf-16\", \"cc-73-*\", \"cc:82:*\"",
					},
					"whitelisted_ssids": schema.ListAttribute{
						ElementType:         types.StringType,
						Optional:            true,
						Computed:            true,
						Description:         "list of SSIDs to whitelist",
						MarkdownDescription: "list of SSIDs to whitelist",
					},
				},
				CustomType: RogueType{
					ObjectType: types.ObjectType{
						AttrTypes: RogueValue{}.AttributeTypes(ctx),
					},
				},
				Optional:            true,
				Description:         "Rogue site settings",
				MarkdownDescription: "Rogue site settings",
			},
			"simple_alert": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"arp_failure": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"client_count": schema.Int64Attribute{
								Optional: true,
								Computed: true,
								Default:  int64default.StaticInt64(10),
							},
							"duration": schema.Int64Attribute{
								Optional:            true,
								Computed:            true,
								Description:         "failing within minutes",
								MarkdownDescription: "failing within minutes",
								Validators: []validator.Int64{
									int64validator.Between(5, 60),
								},
								Default: int64default.StaticInt64(20),
							},
							"incident_count": schema.Int64Attribute{
								Optional: true,
								Computed: true,
								Default:  int64default.StaticInt64(10),
							},
						},
						CustomType: ArpFailureType{
							ObjectType: types.ObjectType{
								AttrTypes: ArpFailureValue{}.AttributeTypes(ctx),
							},
						},
						Optional: true,
					},
					"dhcp_failure": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"client_count": schema.Int64Attribute{
								Optional: true,
								Computed: true,
								Default:  int64default.StaticInt64(10),
							},
							"duration": schema.Int64Attribute{
								Optional:            true,
								Computed:            true,
								Description:         "failing within minutes",
								MarkdownDescription: "failing within minutes",
								Validators: []validator.Int64{
									int64validator.Between(5, 60),
								},
								Default: int64default.StaticInt64(10),
							},
							"incident_count": schema.Int64Attribute{
								Optional: true,
								Computed: true,
								Default:  int64default.StaticInt64(20),
							},
						},
						CustomType: DhcpFailureType{
							ObjectType: types.ObjectType{
								AttrTypes: DhcpFailureValue{}.AttributeTypes(ctx),
							},
						},
						Optional: true,
					},
					"dns_failure": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"client_count": schema.Int64Attribute{
								Optional: true,
								Computed: true,
								Default:  int64default.StaticInt64(20),
							},
							"duration": schema.Int64Attribute{
								Optional:            true,
								Computed:            true,
								Description:         "failing within minutes",
								MarkdownDescription: "failing within minutes",
								Validators: []validator.Int64{
									int64validator.Between(5, 60),
								},
								Default: int64default.StaticInt64(10),
							},
							"incident_count": schema.Int64Attribute{
								Optional: true,
								Computed: true,
								Default:  int64default.StaticInt64(30),
							},
						},
						CustomType: DnsFailureType{
							ObjectType: types.ObjectType{
								AttrTypes: DnsFailureValue{}.AttributeTypes(ctx),
							},
						},
						Optional: true,
					},
				},
				CustomType: SimpleAlertType{
					ObjectType: types.ObjectType{
						AttrTypes: SimpleAlertValue{}.AttributeTypes(ctx),
					},
				},
				Optional:            true,
				Description:         "Set of heuristic rules will be enabled when marvis subscription is not available.\nIt triggers when, in a Z minute window, there are more than Y distinct client encountring over X failures",
				MarkdownDescription: "Set of heuristic rules will be enabled when marvis subscription is not available.\nIt triggers when, in a Z minute window, there are more than Y distinct client encountring over X failures",
			},
			"site_id": schema.StringAttribute{
				Optional: true,
				Computed: true,
			},
			"skyatp": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"enabled": schema.BoolAttribute{
						Optional: true,
					},
					"send_ip_mac_mapping": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "whether to send IP-MAC mapping to SkyATP",
						MarkdownDescription: "whether to send IP-MAC mapping to SkyATP",
						Default:             booldefault.StaticBool(false),
					},
				},
				CustomType: SkyatpType{
					ObjectType: types.ObjectType{
						AttrTypes: SkyatpValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
			},
			"ssh_keys": schema.ListAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Description:         "when limit_ssh_access = true in Org Setting, list of SSH public keys provided by Mist Support to install onto APs (see Org:Setting)",
				MarkdownDescription: "when limit_ssh_access = true in Org Setting, list of SSH public keys provided by Mist Support to install onto APs (see Org:Setting)",
			},
			"ssr": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"conductor_hosts": schema.ListAttribute{
						ElementType: types.StringType,
						Optional:    true,
					},
					"disable_stats": schema.BoolAttribute{
						Optional: true,
					},
				},
				CustomType: SsrType{
					ObjectType: types.ObjectType{
						AttrTypes: SsrValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
			},
			"switch_updown_threshold": schema.Int64Attribute{
				Optional:            true,
				Description:         "enable threshold-based device down delivery for Switch devices only. When configured it takes effect for SW devices and `device_updown_threshold` is ignored.",
				MarkdownDescription: "enable threshold-based device down delivery for Switch devices only. When configured it takes effect for SW devices and `device_updown_threshold` is ignored.",
			},
			"synthetic_test": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"disabled": schema.BoolAttribute{
						Optional: true,
						Computed: true,
						Default:  booldefault.StaticBool(false),
					},
					"vlans": schema.ListNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"custom_test_urls": schema.ListAttribute{
									ElementType: types.StringType,
									Optional:    true,
								},
								"disabled": schema.BoolAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "for some vlans where we don't want this to run",
									MarkdownDescription: "for some vlans where we don't want this to run",
									Default:             booldefault.StaticBool(false),
								},
								"vlan_ids": schema.ListAttribute{
									ElementType: types.Int64Type,
									Optional:    true,
								},
							},
							CustomType: VlansType{
								ObjectType: types.ObjectType{
									AttrTypes: VlansValue{}.AttributeTypes(ctx),
								},
							},
						},
						Optional: true,
					},
				},
				CustomType: SyntheticTestType{
					ObjectType: types.ObjectType{
						AttrTypes: SyntheticTestValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
			},
			"track_anonymous_devices": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "whether to track anonymous BLE assets (requires ‘track_asset’ enabled)",
				MarkdownDescription: "whether to track anonymous BLE assets (requires ‘track_asset’ enabled)",
				Default:             booldefault.StaticBool(false),
			},
			"vars": schema.MapAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Description:         "a dictionary of name->value, the vars can then be used in Wlans. This can overwrite those from Site Vars",
				MarkdownDescription: "a dictionary of name->value, the vars can then be used in Wlans. This can overwrite those from Site Vars",
			},
			"vs_instance": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"networks": schema.ListAttribute{
						ElementType: types.StringType,
						Optional:    true,
					},
				},
				CustomType: VsInstanceType{
					ObjectType: types.ObjectType{
						AttrTypes: VsInstanceValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
			},
			"watched_station_url": schema.StringAttribute{
				Computed: true,
			},
			"whitelist_url": schema.StringAttribute{
				Computed: true,
			},
			"wids": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"repeated_auth_failures": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"duration": schema.Int64Attribute{
								Optional:            true,
								Description:         "window where a trigger will be detected and action to be taken (in seconds)",
								MarkdownDescription: "window where a trigger will be detected and action to be taken (in seconds)",
							},
							"threshold": schema.Int64Attribute{
								Optional:            true,
								Description:         "count of events to trigger",
								MarkdownDescription: "count of events to trigger",
							},
						},
						CustomType: RepeatedAuthFailuresType{
							ObjectType: types.ObjectType{
								AttrTypes: RepeatedAuthFailuresValue{}.AttributeTypes(ctx),
							},
						},
						Optional: true,
					},
				},
				CustomType: WidsType{
					ObjectType: types.ObjectType{
						AttrTypes: WidsValue{}.AttributeTypes(ctx),
					},
				},
				Optional:            true,
				Description:         "WIDS site settings",
				MarkdownDescription: "WIDS site settings",
			},
			"wifi": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"cisco_enabled": schema.BoolAttribute{
						Optional: true,
						Computed: true,
						Default:  booldefault.StaticBool(true),
					},
					"disable_11k": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "whether to disable 11k",
						MarkdownDescription: "whether to disable 11k",
						Default:             booldefault.StaticBool(false),
					},
					"disable_radios_when_power_constrained": schema.BoolAttribute{
						Optional: true,
						Computed: true,
						Default:  booldefault.StaticBool(false),
					},
					"enable_arp_spoof_check": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "when proxy_arp is enabled, check for arp spoofing.",
						MarkdownDescription: "when proxy_arp is enabled, check for arp spoofing.",
						Default:             booldefault.StaticBool(false),
					},
					"enable_shared_radio_scanning": schema.BoolAttribute{
						Optional: true,
						Computed: true,
						Default:  booldefault.StaticBool(true),
					},
					"enabled": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "enable WIFI feature (using SUB-MAN license)",
						MarkdownDescription: "enable WIFI feature (using SUB-MAN license)",
						Default:             booldefault.StaticBool(true),
					},
					"locate_connected": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "whether to locate connected clients",
						MarkdownDescription: "whether to locate connected clients",
						Default:             booldefault.StaticBool(true),
					},
					"locate_unconnected": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "whether to locate unconnected clients",
						MarkdownDescription: "whether to locate unconnected clients",
						Default:             booldefault.StaticBool(false),
					},
					"mesh_allow_dfs": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "whether to allow Mesh to use DFS channels. For DFS channels, Remote Mesh AP would have to do CAC when scanning for new Base AP, which is slow and will distrupt the connection. If roaming is desired, keep it disabled.",
						MarkdownDescription: "whether to allow Mesh to use DFS channels. For DFS channels, Remote Mesh AP would have to do CAC when scanning for new Base AP, which is slow and will distrupt the connection. If roaming is desired, keep it disabled.",
						Default:             booldefault.StaticBool(false),
					},
					"mesh_enable_crm": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "used to enable/disable CRM",
						MarkdownDescription: "used to enable/disable CRM",
						Default:             booldefault.StaticBool(false),
					},
					"mesh_enabled": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "whether to enable Mesh feature for the site",
						MarkdownDescription: "whether to enable Mesh feature for the site",
						Default:             booldefault.StaticBool(false),
					},
					"mesh_psk": schema.StringAttribute{
						Optional:            true,
						Sensitive:           true,
						Description:         "optional passphrase of mesh networking, default is generated randomly",
						MarkdownDescription: "optional passphrase of mesh networking, default is generated randomly",
					},
					"mesh_ssid": schema.StringAttribute{
						Optional:            true,
						Description:         "optional ssid of mesh networking, default is based on site_id",
						MarkdownDescription: "optional ssid of mesh networking, default is based on site_id",
					},
					"proxy_arp": schema.StringAttribute{
						Optional:            true,
						Description:         "default / enabled / disabled",
						MarkdownDescription: "default / enabled / disabled",
						Validators: []validator.String{
							stringvalidator.OneOf(
								"",
								"default",
								"enabled",
								"disabled",
							),
						},
					},
				},
				CustomType: WifiType{
					ObjectType: types.ObjectType{
						AttrTypes: WifiValue{}.AttributeTypes(ctx),
					},
				},
				Optional:            true,
				Description:         "Wi-Fi site settings",
				MarkdownDescription: "Wi-Fi site settings",
			},
			"wired_vna": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"enabled": schema.BoolAttribute{
						Optional: true,
						Computed: true,
						Default:  booldefault.StaticBool(false),
					},
				},
				CustomType: WiredVnaType{
					ObjectType: types.ObjectType{
						AttrTypes: WiredVnaValue{}.AttributeTypes(ctx),
					},
				},
				Optional: true,
			},
			"zone_occupancy_alert": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"email_notifiers": schema.ListAttribute{
						ElementType:         types.StringType,
						Optional:            true,
						Description:         "list of email addresses to send email notifications when the alert threshold is reached",
						MarkdownDescription: "list of email addresses to send email notifications when the alert threshold is reached",
					},
					"enabled": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "indicate whether zone occupancy alert is enabled for the site",
						MarkdownDescription: "indicate whether zone occupancy alert is enabled for the site",
						Default:             booldefault.StaticBool(false),
					},
					"threshold": schema.Int64Attribute{
						Optional:            true,
						Computed:            true,
						Description:         "sending zone-occupancy-alert webhook message only if a zone stays non-compliant (i.e. actual occupancy > occupancy_limit) for a minimum duration specified in the threshold, in minutes",
						MarkdownDescription: "sending zone-occupancy-alert webhook message only if a zone stays non-compliant (i.e. actual occupancy > occupancy_limit) for a minimum duration specified in the threshold, in minutes",
						Validators: []validator.Int64{
							int64validator.Between(0, 30),
						},
						Default: int64default.StaticInt64(5),
					},
				},
				CustomType: ZoneOccupancyAlertType{
					ObjectType: types.ObjectType{
						AttrTypes: ZoneOccupancyAlertValue{}.AttributeTypes(ctx),
					},
				},
				Optional:            true,
				Description:         "Zone Occupancy alert site settings",
				MarkdownDescription: "Zone Occupancy alert site settings",
			},
		},
	}
}

type SiteSettingModel struct {
	ApUpdownThreshold               types.Int64                `tfsdk:"ap_updown_threshold"`
	AutoUpgrade                     AutoUpgradeValue           `tfsdk:"auto_upgrade"`
	BlacklistUrl                    types.String               `tfsdk:"blacklist_url"`
	BleConfig                       BleConfigValue             `tfsdk:"ble_config"`
	ConfigAutoRevert                types.Bool                 `tfsdk:"config_auto_revert"`
	ConfigPushPolicy                ConfigPushPolicyValue      `tfsdk:"config_push_policy"`
	CriticalUrlMonitoring           CriticalUrlMonitoringValue `tfsdk:"critical_url_monitoring"`
	DeviceUpdownThreshold           types.Int64                `tfsdk:"device_updown_threshold"`
	DisabledSystemDefinedPortUsages types.List                 `tfsdk:"disabled_system_defined_port_usages"`
	Engagement                      EngagementValue            `tfsdk:"engagement"`
	GatewayUpdownThreshold          types.Int64                `tfsdk:"gateway_updown_threshold"`
	Led                             LedValue                   `tfsdk:"led"`
	Occupancy                       OccupancyValue             `tfsdk:"occupancy"`
	OrgId                           types.String               `tfsdk:"org_id"`
	PersistConfigOnDevice           types.Bool                 `tfsdk:"persist_config_on_device"`
	Proxy                           ProxyValue                 `tfsdk:"proxy"`
	ReportGatt                      types.Bool                 `tfsdk:"report_gatt"`
	Rogue                           RogueValue                 `tfsdk:"rogue"`
	SimpleAlert                     SimpleAlertValue           `tfsdk:"simple_alert"`
	SiteId                          types.String               `tfsdk:"site_id"`
	Skyatp                          SkyatpValue                `tfsdk:"skyatp"`
	SshKeys                         types.List                 `tfsdk:"ssh_keys"`
	Ssr                             SsrValue                   `tfsdk:"ssr"`
	SwitchUpdownThreshold           types.Int64                `tfsdk:"switch_updown_threshold"`
	SyntheticTest                   SyntheticTestValue         `tfsdk:"synthetic_test"`
	TrackAnonymousDevices           types.Bool                 `tfsdk:"track_anonymous_devices"`
	Vars                            types.Map                  `tfsdk:"vars"`
	VsInstance                      VsInstanceValue            `tfsdk:"vs_instance"`
	WatchedStationUrl               types.String               `tfsdk:"watched_station_url"`
	WhitelistUrl                    types.String               `tfsdk:"whitelist_url"`
	Wids                            WidsValue                  `tfsdk:"wids"`
	Wifi                            WifiValue                  `tfsdk:"wifi"`
	WiredVna                        WiredVnaValue              `tfsdk:"wired_vna"`
	ZoneOccupancyAlert              ZoneOccupancyAlertValue    `tfsdk:"zone_occupancy_alert"`
}

var _ basetypes.ObjectTypable = AutoUpgradeType{}

type AutoUpgradeType struct {
	basetypes.ObjectType
}

func (t AutoUpgradeType) Equal(o attr.Type) bool {
	other, ok := o.(AutoUpgradeType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AutoUpgradeType) String() string {
	return "AutoUpgradeType"
}

func (t AutoUpgradeType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	customVersionsAttribute, ok := attributes["custom_versions"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`custom_versions is missing from object`)

		return nil, diags
	}

	customVersionsVal, ok := customVersionsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`custom_versions expected to be basetypes.MapValue, was: %T`, customVersionsAttribute))
	}

	dayOfWeekAttribute, ok := attributes["day_of_week"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`day_of_week is missing from object`)

		return nil, diags
	}

	dayOfWeekVal, ok := dayOfWeekAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`day_of_week expected to be basetypes.StringValue, was: %T`, dayOfWeekAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	timeOfDayAttribute, ok := attributes["time_of_day"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`time_of_day is missing from object`)

		return nil, diags
	}

	timeOfDayVal, ok := timeOfDayAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`time_of_day expected to be basetypes.StringValue, was: %T`, timeOfDayAttribute))
	}

	versionAttribute, ok := attributes["version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`version is missing from object`)

		return nil, diags
	}

	versionVal, ok := versionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`version expected to be basetypes.StringValue, was: %T`, versionAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AutoUpgradeValue{
		CustomVersions: customVersionsVal,
		DayOfWeek:      dayOfWeekVal,
		Enabled:        enabledVal,
		TimeOfDay:      timeOfDayVal,
		Version:        versionVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewAutoUpgradeValueNull() AutoUpgradeValue {
	return AutoUpgradeValue{
		state: attr.ValueStateNull,
	}
}

func NewAutoUpgradeValueUnknown() AutoUpgradeValue {
	return AutoUpgradeValue{
		state: attr.ValueStateUnknown,
	}
}

func NewAutoUpgradeValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AutoUpgradeValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AutoUpgradeValue Attribute Value",
				"While creating a AutoUpgradeValue value, a missing attribute value was detected. "+
					"A AutoUpgradeValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AutoUpgradeValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AutoUpgradeValue Attribute Type",
				"While creating a AutoUpgradeValue value, an invalid attribute value was detected. "+
					"A AutoUpgradeValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AutoUpgradeValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AutoUpgradeValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AutoUpgradeValue Attribute Value",
				"While creating a AutoUpgradeValue value, an extra attribute value was detected. "+
					"A AutoUpgradeValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AutoUpgradeValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAutoUpgradeValueUnknown(), diags
	}

	customVersionsAttribute, ok := attributes["custom_versions"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`custom_versions is missing from object`)

		return NewAutoUpgradeValueUnknown(), diags
	}

	customVersionsVal, ok := customVersionsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`custom_versions expected to be basetypes.MapValue, was: %T`, customVersionsAttribute))
	}

	dayOfWeekAttribute, ok := attributes["day_of_week"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`day_of_week is missing from object`)

		return NewAutoUpgradeValueUnknown(), diags
	}

	dayOfWeekVal, ok := dayOfWeekAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`day_of_week expected to be basetypes.StringValue, was: %T`, dayOfWeekAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewAutoUpgradeValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	timeOfDayAttribute, ok := attributes["time_of_day"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`time_of_day is missing from object`)

		return NewAutoUpgradeValueUnknown(), diags
	}

	timeOfDayVal, ok := timeOfDayAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`time_of_day expected to be basetypes.StringValue, was: %T`, timeOfDayAttribute))
	}

	versionAttribute, ok := attributes["version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`version is missing from object`)

		return NewAutoUpgradeValueUnknown(), diags
	}

	versionVal, ok := versionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`version expected to be basetypes.StringValue, was: %T`, versionAttribute))
	}

	if diags.HasError() {
		return NewAutoUpgradeValueUnknown(), diags
	}

	return AutoUpgradeValue{
		CustomVersions: customVersionsVal,
		DayOfWeek:      dayOfWeekVal,
		Enabled:        enabledVal,
		TimeOfDay:      timeOfDayVal,
		Version:        versionVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewAutoUpgradeValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AutoUpgradeValue {
	object, diags := NewAutoUpgradeValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAutoUpgradeValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AutoUpgradeType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAutoUpgradeValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAutoUpgradeValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAutoUpgradeValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAutoUpgradeValueMust(AutoUpgradeValue{}.AttributeTypes(ctx), attributes), nil
}

func (t AutoUpgradeType) ValueType(ctx context.Context) attr.Value {
	return AutoUpgradeValue{}
}

var _ basetypes.ObjectValuable = AutoUpgradeValue{}

type AutoUpgradeValue struct {
	CustomVersions basetypes.MapValue    `tfsdk:"custom_versions"`
	DayOfWeek      basetypes.StringValue `tfsdk:"day_of_week"`
	Enabled        basetypes.BoolValue   `tfsdk:"enabled"`
	TimeOfDay      basetypes.StringValue `tfsdk:"time_of_day"`
	Version        basetypes.StringValue `tfsdk:"version"`
	state          attr.ValueState
}

func (v AutoUpgradeValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["custom_versions"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["day_of_week"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["time_of_day"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["version"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.CustomVersions.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["custom_versions"] = val

		val, err = v.DayOfWeek.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["day_of_week"] = val

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.TimeOfDay.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["time_of_day"] = val

		val, err = v.Version.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["version"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AutoUpgradeValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AutoUpgradeValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AutoUpgradeValue) String() string {
	return "AutoUpgradeValue"
}

func (v AutoUpgradeValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	customVersionsVal, d := types.MapValue(types.StringType, v.CustomVersions.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"custom_versions": basetypes.MapType{
				ElemType: types.StringType,
			},
			"day_of_week": basetypes.StringType{},
			"enabled":     basetypes.BoolType{},
			"time_of_day": basetypes.StringType{},
			"version":     basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"custom_versions": basetypes.MapType{
			ElemType: types.StringType,
		},
		"day_of_week": basetypes.StringType{},
		"enabled":     basetypes.BoolType{},
		"time_of_day": basetypes.StringType{},
		"version":     basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"custom_versions": customVersionsVal,
			"day_of_week":     v.DayOfWeek,
			"enabled":         v.Enabled,
			"time_of_day":     v.TimeOfDay,
			"version":         v.Version,
		})

	return objVal, diags
}

func (v AutoUpgradeValue) Equal(o attr.Value) bool {
	other, ok := o.(AutoUpgradeValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.CustomVersions.Equal(other.CustomVersions) {
		return false
	}

	if !v.DayOfWeek.Equal(other.DayOfWeek) {
		return false
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.TimeOfDay.Equal(other.TimeOfDay) {
		return false
	}

	if !v.Version.Equal(other.Version) {
		return false
	}

	return true
}

func (v AutoUpgradeValue) Type(ctx context.Context) attr.Type {
	return AutoUpgradeType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AutoUpgradeValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"custom_versions": basetypes.MapType{
			ElemType: types.StringType,
		},
		"day_of_week": basetypes.StringType{},
		"enabled":     basetypes.BoolType{},
		"time_of_day": basetypes.StringType{},
		"version":     basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = BleConfigType{}

type BleConfigType struct {
	basetypes.ObjectType
}

func (t BleConfigType) Equal(o attr.Type) bool {
	other, ok := o.(BleConfigType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t BleConfigType) String() string {
	return "BleConfigType"
}

func (t BleConfigType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	beaconEnabledAttribute, ok := attributes["beacon_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`beacon_enabled is missing from object`)

		return nil, diags
	}

	beaconEnabledVal, ok := beaconEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`beacon_enabled expected to be basetypes.BoolValue, was: %T`, beaconEnabledAttribute))
	}

	beaconRateAttribute, ok := attributes["beacon_rate"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`beacon_rate is missing from object`)

		return nil, diags
	}

	beaconRateVal, ok := beaconRateAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`beacon_rate expected to be basetypes.Int64Value, was: %T`, beaconRateAttribute))
	}

	beaconRateModeAttribute, ok := attributes["beacon_rate_mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`beacon_rate_mode is missing from object`)

		return nil, diags
	}

	beaconRateModeVal, ok := beaconRateModeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`beacon_rate_mode expected to be basetypes.StringValue, was: %T`, beaconRateModeAttribute))
	}

	beamDisabledAttribute, ok := attributes["beam_disabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`beam_disabled is missing from object`)

		return nil, diags
	}

	beamDisabledVal, ok := beamDisabledAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`beam_disabled expected to be basetypes.ListValue, was: %T`, beamDisabledAttribute))
	}

	customBlePacketEnabledAttribute, ok := attributes["custom_ble_packet_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`custom_ble_packet_enabled is missing from object`)

		return nil, diags
	}

	customBlePacketEnabledVal, ok := customBlePacketEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`custom_ble_packet_enabled expected to be basetypes.BoolValue, was: %T`, customBlePacketEnabledAttribute))
	}

	customBlePacketFrameAttribute, ok := attributes["custom_ble_packet_frame"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`custom_ble_packet_frame is missing from object`)

		return nil, diags
	}

	customBlePacketFrameVal, ok := customBlePacketFrameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`custom_ble_packet_frame expected to be basetypes.StringValue, was: %T`, customBlePacketFrameAttribute))
	}

	customBlePacketFreqMsecAttribute, ok := attributes["custom_ble_packet_freq_msec"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`custom_ble_packet_freq_msec is missing from object`)

		return nil, diags
	}

	customBlePacketFreqMsecVal, ok := customBlePacketFreqMsecAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`custom_ble_packet_freq_msec expected to be basetypes.Int64Value, was: %T`, customBlePacketFreqMsecAttribute))
	}

	eddystoneUidAdvPowerAttribute, ok := attributes["eddystone_uid_adv_power"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`eddystone_uid_adv_power is missing from object`)

		return nil, diags
	}

	eddystoneUidAdvPowerVal, ok := eddystoneUidAdvPowerAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`eddystone_uid_adv_power expected to be basetypes.Int64Value, was: %T`, eddystoneUidAdvPowerAttribute))
	}

	eddystoneUidBeamsAttribute, ok := attributes["eddystone_uid_beams"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`eddystone_uid_beams is missing from object`)

		return nil, diags
	}

	eddystoneUidBeamsVal, ok := eddystoneUidBeamsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`eddystone_uid_beams expected to be basetypes.StringValue, was: %T`, eddystoneUidBeamsAttribute))
	}

	eddystoneUidEnabledAttribute, ok := attributes["eddystone_uid_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`eddystone_uid_enabled is missing from object`)

		return nil, diags
	}

	eddystoneUidEnabledVal, ok := eddystoneUidEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`eddystone_uid_enabled expected to be basetypes.BoolValue, was: %T`, eddystoneUidEnabledAttribute))
	}

	eddystoneUidFreqMsecAttribute, ok := attributes["eddystone_uid_freq_msec"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`eddystone_uid_freq_msec is missing from object`)

		return nil, diags
	}

	eddystoneUidFreqMsecVal, ok := eddystoneUidFreqMsecAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`eddystone_uid_freq_msec expected to be basetypes.Int64Value, was: %T`, eddystoneUidFreqMsecAttribute))
	}

	eddystoneUidInstanceAttribute, ok := attributes["eddystone_uid_instance"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`eddystone_uid_instance is missing from object`)

		return nil, diags
	}

	eddystoneUidInstanceVal, ok := eddystoneUidInstanceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`eddystone_uid_instance expected to be basetypes.StringValue, was: %T`, eddystoneUidInstanceAttribute))
	}

	eddystoneUidNamespaceAttribute, ok := attributes["eddystone_uid_namespace"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`eddystone_uid_namespace is missing from object`)

		return nil, diags
	}

	eddystoneUidNamespaceVal, ok := eddystoneUidNamespaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`eddystone_uid_namespace expected to be basetypes.StringValue, was: %T`, eddystoneUidNamespaceAttribute))
	}

	eddystoneUrlAdvPowerAttribute, ok := attributes["eddystone_url_adv_power"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`eddystone_url_adv_power is missing from object`)

		return nil, diags
	}

	eddystoneUrlAdvPowerVal, ok := eddystoneUrlAdvPowerAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`eddystone_url_adv_power expected to be basetypes.Int64Value, was: %T`, eddystoneUrlAdvPowerAttribute))
	}

	eddystoneUrlBeamsAttribute, ok := attributes["eddystone_url_beams"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`eddystone_url_beams is missing from object`)

		return nil, diags
	}

	eddystoneUrlBeamsVal, ok := eddystoneUrlBeamsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`eddystone_url_beams expected to be basetypes.StringValue, was: %T`, eddystoneUrlBeamsAttribute))
	}

	eddystoneUrlEnabledAttribute, ok := attributes["eddystone_url_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`eddystone_url_enabled is missing from object`)

		return nil, diags
	}

	eddystoneUrlEnabledVal, ok := eddystoneUrlEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`eddystone_url_enabled expected to be basetypes.BoolValue, was: %T`, eddystoneUrlEnabledAttribute))
	}

	eddystoneUrlFreqMsecAttribute, ok := attributes["eddystone_url_freq_msec"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`eddystone_url_freq_msec is missing from object`)

		return nil, diags
	}

	eddystoneUrlFreqMsecVal, ok := eddystoneUrlFreqMsecAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`eddystone_url_freq_msec expected to be basetypes.Int64Value, was: %T`, eddystoneUrlFreqMsecAttribute))
	}

	eddystoneUrlUrlAttribute, ok := attributes["eddystone_url_url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`eddystone_url_url is missing from object`)

		return nil, diags
	}

	eddystoneUrlUrlVal, ok := eddystoneUrlUrlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`eddystone_url_url expected to be basetypes.StringValue, was: %T`, eddystoneUrlUrlAttribute))
	}

	ibeaconAdvPowerAttribute, ok := attributes["ibeacon_adv_power"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ibeacon_adv_power is missing from object`)

		return nil, diags
	}

	ibeaconAdvPowerVal, ok := ibeaconAdvPowerAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ibeacon_adv_power expected to be basetypes.Int64Value, was: %T`, ibeaconAdvPowerAttribute))
	}

	ibeaconBeamsAttribute, ok := attributes["ibeacon_beams"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ibeacon_beams is missing from object`)

		return nil, diags
	}

	ibeaconBeamsVal, ok := ibeaconBeamsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ibeacon_beams expected to be basetypes.StringValue, was: %T`, ibeaconBeamsAttribute))
	}

	ibeaconEnabledAttribute, ok := attributes["ibeacon_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ibeacon_enabled is missing from object`)

		return nil, diags
	}

	ibeaconEnabledVal, ok := ibeaconEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ibeacon_enabled expected to be basetypes.BoolValue, was: %T`, ibeaconEnabledAttribute))
	}

	ibeaconFreqMsecAttribute, ok := attributes["ibeacon_freq_msec"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ibeacon_freq_msec is missing from object`)

		return nil, diags
	}

	ibeaconFreqMsecVal, ok := ibeaconFreqMsecAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ibeacon_freq_msec expected to be basetypes.Int64Value, was: %T`, ibeaconFreqMsecAttribute))
	}

	ibeaconMajorAttribute, ok := attributes["ibeacon_major"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ibeacon_major is missing from object`)

		return nil, diags
	}

	ibeaconMajorVal, ok := ibeaconMajorAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ibeacon_major expected to be basetypes.Int64Value, was: %T`, ibeaconMajorAttribute))
	}

	ibeaconMinorAttribute, ok := attributes["ibeacon_minor"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ibeacon_minor is missing from object`)

		return nil, diags
	}

	ibeaconMinorVal, ok := ibeaconMinorAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ibeacon_minor expected to be basetypes.Int64Value, was: %T`, ibeaconMinorAttribute))
	}

	ibeaconUuidAttribute, ok := attributes["ibeacon_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ibeacon_uuid is missing from object`)

		return nil, diags
	}

	ibeaconUuidVal, ok := ibeaconUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ibeacon_uuid expected to be basetypes.StringValue, was: %T`, ibeaconUuidAttribute))
	}

	powerAttribute, ok := attributes["power"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`power is missing from object`)

		return nil, diags
	}

	powerVal, ok := powerAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`power expected to be basetypes.Int64Value, was: %T`, powerAttribute))
	}

	powerModeAttribute, ok := attributes["power_mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`power_mode is missing from object`)

		return nil, diags
	}

	powerModeVal, ok := powerModeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`power_mode expected to be basetypes.StringValue, was: %T`, powerModeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return BleConfigValue{
		BeaconEnabled:           beaconEnabledVal,
		BeaconRate:              beaconRateVal,
		BeaconRateMode:          beaconRateModeVal,
		BeamDisabled:            beamDisabledVal,
		CustomBlePacketEnabled:  customBlePacketEnabledVal,
		CustomBlePacketFrame:    customBlePacketFrameVal,
		CustomBlePacketFreqMsec: customBlePacketFreqMsecVal,
		EddystoneUidAdvPower:    eddystoneUidAdvPowerVal,
		EddystoneUidBeams:       eddystoneUidBeamsVal,
		EddystoneUidEnabled:     eddystoneUidEnabledVal,
		EddystoneUidFreqMsec:    eddystoneUidFreqMsecVal,
		EddystoneUidInstance:    eddystoneUidInstanceVal,
		EddystoneUidNamespace:   eddystoneUidNamespaceVal,
		EddystoneUrlAdvPower:    eddystoneUrlAdvPowerVal,
		EddystoneUrlBeams:       eddystoneUrlBeamsVal,
		EddystoneUrlEnabled:     eddystoneUrlEnabledVal,
		EddystoneUrlFreqMsec:    eddystoneUrlFreqMsecVal,
		EddystoneUrlUrl:         eddystoneUrlUrlVal,
		IbeaconAdvPower:         ibeaconAdvPowerVal,
		IbeaconBeams:            ibeaconBeamsVal,
		IbeaconEnabled:          ibeaconEnabledVal,
		IbeaconFreqMsec:         ibeaconFreqMsecVal,
		IbeaconMajor:            ibeaconMajorVal,
		IbeaconMinor:            ibeaconMinorVal,
		IbeaconUuid:             ibeaconUuidVal,
		Power:                   powerVal,
		PowerMode:               powerModeVal,
		state:                   attr.ValueStateKnown,
	}, diags
}

func NewBleConfigValueNull() BleConfigValue {
	return BleConfigValue{
		state: attr.ValueStateNull,
	}
}

func NewBleConfigValueUnknown() BleConfigValue {
	return BleConfigValue{
		state: attr.ValueStateUnknown,
	}
}

func NewBleConfigValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (BleConfigValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing BleConfigValue Attribute Value",
				"While creating a BleConfigValue value, a missing attribute value was detected. "+
					"A BleConfigValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("BleConfigValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid BleConfigValue Attribute Type",
				"While creating a BleConfigValue value, an invalid attribute value was detected. "+
					"A BleConfigValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("BleConfigValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("BleConfigValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra BleConfigValue Attribute Value",
				"While creating a BleConfigValue value, an extra attribute value was detected. "+
					"A BleConfigValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra BleConfigValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewBleConfigValueUnknown(), diags
	}

	beaconEnabledAttribute, ok := attributes["beacon_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`beacon_enabled is missing from object`)

		return NewBleConfigValueUnknown(), diags
	}

	beaconEnabledVal, ok := beaconEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`beacon_enabled expected to be basetypes.BoolValue, was: %T`, beaconEnabledAttribute))
	}

	beaconRateAttribute, ok := attributes["beacon_rate"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`beacon_rate is missing from object`)

		return NewBleConfigValueUnknown(), diags
	}

	beaconRateVal, ok := beaconRateAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`beacon_rate expected to be basetypes.Int64Value, was: %T`, beaconRateAttribute))
	}

	beaconRateModeAttribute, ok := attributes["beacon_rate_mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`beacon_rate_mode is missing from object`)

		return NewBleConfigValueUnknown(), diags
	}

	beaconRateModeVal, ok := beaconRateModeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`beacon_rate_mode expected to be basetypes.StringValue, was: %T`, beaconRateModeAttribute))
	}

	beamDisabledAttribute, ok := attributes["beam_disabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`beam_disabled is missing from object`)

		return NewBleConfigValueUnknown(), diags
	}

	beamDisabledVal, ok := beamDisabledAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`beam_disabled expected to be basetypes.ListValue, was: %T`, beamDisabledAttribute))
	}

	customBlePacketEnabledAttribute, ok := attributes["custom_ble_packet_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`custom_ble_packet_enabled is missing from object`)

		return NewBleConfigValueUnknown(), diags
	}

	customBlePacketEnabledVal, ok := customBlePacketEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`custom_ble_packet_enabled expected to be basetypes.BoolValue, was: %T`, customBlePacketEnabledAttribute))
	}

	customBlePacketFrameAttribute, ok := attributes["custom_ble_packet_frame"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`custom_ble_packet_frame is missing from object`)

		return NewBleConfigValueUnknown(), diags
	}

	customBlePacketFrameVal, ok := customBlePacketFrameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`custom_ble_packet_frame expected to be basetypes.StringValue, was: %T`, customBlePacketFrameAttribute))
	}

	customBlePacketFreqMsecAttribute, ok := attributes["custom_ble_packet_freq_msec"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`custom_ble_packet_freq_msec is missing from object`)

		return NewBleConfigValueUnknown(), diags
	}

	customBlePacketFreqMsecVal, ok := customBlePacketFreqMsecAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`custom_ble_packet_freq_msec expected to be basetypes.Int64Value, was: %T`, customBlePacketFreqMsecAttribute))
	}

	eddystoneUidAdvPowerAttribute, ok := attributes["eddystone_uid_adv_power"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`eddystone_uid_adv_power is missing from object`)

		return NewBleConfigValueUnknown(), diags
	}

	eddystoneUidAdvPowerVal, ok := eddystoneUidAdvPowerAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`eddystone_uid_adv_power expected to be basetypes.Int64Value, was: %T`, eddystoneUidAdvPowerAttribute))
	}

	eddystoneUidBeamsAttribute, ok := attributes["eddystone_uid_beams"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`eddystone_uid_beams is missing from object`)

		return NewBleConfigValueUnknown(), diags
	}

	eddystoneUidBeamsVal, ok := eddystoneUidBeamsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`eddystone_uid_beams expected to be basetypes.StringValue, was: %T`, eddystoneUidBeamsAttribute))
	}

	eddystoneUidEnabledAttribute, ok := attributes["eddystone_uid_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`eddystone_uid_enabled is missing from object`)

		return NewBleConfigValueUnknown(), diags
	}

	eddystoneUidEnabledVal, ok := eddystoneUidEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`eddystone_uid_enabled expected to be basetypes.BoolValue, was: %T`, eddystoneUidEnabledAttribute))
	}

	eddystoneUidFreqMsecAttribute, ok := attributes["eddystone_uid_freq_msec"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`eddystone_uid_freq_msec is missing from object`)

		return NewBleConfigValueUnknown(), diags
	}

	eddystoneUidFreqMsecVal, ok := eddystoneUidFreqMsecAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`eddystone_uid_freq_msec expected to be basetypes.Int64Value, was: %T`, eddystoneUidFreqMsecAttribute))
	}

	eddystoneUidInstanceAttribute, ok := attributes["eddystone_uid_instance"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`eddystone_uid_instance is missing from object`)

		return NewBleConfigValueUnknown(), diags
	}

	eddystoneUidInstanceVal, ok := eddystoneUidInstanceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`eddystone_uid_instance expected to be basetypes.StringValue, was: %T`, eddystoneUidInstanceAttribute))
	}

	eddystoneUidNamespaceAttribute, ok := attributes["eddystone_uid_namespace"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`eddystone_uid_namespace is missing from object`)

		return NewBleConfigValueUnknown(), diags
	}

	eddystoneUidNamespaceVal, ok := eddystoneUidNamespaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`eddystone_uid_namespace expected to be basetypes.StringValue, was: %T`, eddystoneUidNamespaceAttribute))
	}

	eddystoneUrlAdvPowerAttribute, ok := attributes["eddystone_url_adv_power"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`eddystone_url_adv_power is missing from object`)

		return NewBleConfigValueUnknown(), diags
	}

	eddystoneUrlAdvPowerVal, ok := eddystoneUrlAdvPowerAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`eddystone_url_adv_power expected to be basetypes.Int64Value, was: %T`, eddystoneUrlAdvPowerAttribute))
	}

	eddystoneUrlBeamsAttribute, ok := attributes["eddystone_url_beams"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`eddystone_url_beams is missing from object`)

		return NewBleConfigValueUnknown(), diags
	}

	eddystoneUrlBeamsVal, ok := eddystoneUrlBeamsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`eddystone_url_beams expected to be basetypes.StringValue, was: %T`, eddystoneUrlBeamsAttribute))
	}

	eddystoneUrlEnabledAttribute, ok := attributes["eddystone_url_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`eddystone_url_enabled is missing from object`)

		return NewBleConfigValueUnknown(), diags
	}

	eddystoneUrlEnabledVal, ok := eddystoneUrlEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`eddystone_url_enabled expected to be basetypes.BoolValue, was: %T`, eddystoneUrlEnabledAttribute))
	}

	eddystoneUrlFreqMsecAttribute, ok := attributes["eddystone_url_freq_msec"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`eddystone_url_freq_msec is missing from object`)

		return NewBleConfigValueUnknown(), diags
	}

	eddystoneUrlFreqMsecVal, ok := eddystoneUrlFreqMsecAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`eddystone_url_freq_msec expected to be basetypes.Int64Value, was: %T`, eddystoneUrlFreqMsecAttribute))
	}

	eddystoneUrlUrlAttribute, ok := attributes["eddystone_url_url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`eddystone_url_url is missing from object`)

		return NewBleConfigValueUnknown(), diags
	}

	eddystoneUrlUrlVal, ok := eddystoneUrlUrlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`eddystone_url_url expected to be basetypes.StringValue, was: %T`, eddystoneUrlUrlAttribute))
	}

	ibeaconAdvPowerAttribute, ok := attributes["ibeacon_adv_power"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ibeacon_adv_power is missing from object`)

		return NewBleConfigValueUnknown(), diags
	}

	ibeaconAdvPowerVal, ok := ibeaconAdvPowerAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ibeacon_adv_power expected to be basetypes.Int64Value, was: %T`, ibeaconAdvPowerAttribute))
	}

	ibeaconBeamsAttribute, ok := attributes["ibeacon_beams"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ibeacon_beams is missing from object`)

		return NewBleConfigValueUnknown(), diags
	}

	ibeaconBeamsVal, ok := ibeaconBeamsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ibeacon_beams expected to be basetypes.StringValue, was: %T`, ibeaconBeamsAttribute))
	}

	ibeaconEnabledAttribute, ok := attributes["ibeacon_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ibeacon_enabled is missing from object`)

		return NewBleConfigValueUnknown(), diags
	}

	ibeaconEnabledVal, ok := ibeaconEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ibeacon_enabled expected to be basetypes.BoolValue, was: %T`, ibeaconEnabledAttribute))
	}

	ibeaconFreqMsecAttribute, ok := attributes["ibeacon_freq_msec"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ibeacon_freq_msec is missing from object`)

		return NewBleConfigValueUnknown(), diags
	}

	ibeaconFreqMsecVal, ok := ibeaconFreqMsecAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ibeacon_freq_msec expected to be basetypes.Int64Value, was: %T`, ibeaconFreqMsecAttribute))
	}

	ibeaconMajorAttribute, ok := attributes["ibeacon_major"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ibeacon_major is missing from object`)

		return NewBleConfigValueUnknown(), diags
	}

	ibeaconMajorVal, ok := ibeaconMajorAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ibeacon_major expected to be basetypes.Int64Value, was: %T`, ibeaconMajorAttribute))
	}

	ibeaconMinorAttribute, ok := attributes["ibeacon_minor"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ibeacon_minor is missing from object`)

		return NewBleConfigValueUnknown(), diags
	}

	ibeaconMinorVal, ok := ibeaconMinorAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ibeacon_minor expected to be basetypes.Int64Value, was: %T`, ibeaconMinorAttribute))
	}

	ibeaconUuidAttribute, ok := attributes["ibeacon_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ibeacon_uuid is missing from object`)

		return NewBleConfigValueUnknown(), diags
	}

	ibeaconUuidVal, ok := ibeaconUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ibeacon_uuid expected to be basetypes.StringValue, was: %T`, ibeaconUuidAttribute))
	}

	powerAttribute, ok := attributes["power"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`power is missing from object`)

		return NewBleConfigValueUnknown(), diags
	}

	powerVal, ok := powerAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`power expected to be basetypes.Int64Value, was: %T`, powerAttribute))
	}

	powerModeAttribute, ok := attributes["power_mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`power_mode is missing from object`)

		return NewBleConfigValueUnknown(), diags
	}

	powerModeVal, ok := powerModeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`power_mode expected to be basetypes.StringValue, was: %T`, powerModeAttribute))
	}

	if diags.HasError() {
		return NewBleConfigValueUnknown(), diags
	}

	return BleConfigValue{
		BeaconEnabled:           beaconEnabledVal,
		BeaconRate:              beaconRateVal,
		BeaconRateMode:          beaconRateModeVal,
		BeamDisabled:            beamDisabledVal,
		CustomBlePacketEnabled:  customBlePacketEnabledVal,
		CustomBlePacketFrame:    customBlePacketFrameVal,
		CustomBlePacketFreqMsec: customBlePacketFreqMsecVal,
		EddystoneUidAdvPower:    eddystoneUidAdvPowerVal,
		EddystoneUidBeams:       eddystoneUidBeamsVal,
		EddystoneUidEnabled:     eddystoneUidEnabledVal,
		EddystoneUidFreqMsec:    eddystoneUidFreqMsecVal,
		EddystoneUidInstance:    eddystoneUidInstanceVal,
		EddystoneUidNamespace:   eddystoneUidNamespaceVal,
		EddystoneUrlAdvPower:    eddystoneUrlAdvPowerVal,
		EddystoneUrlBeams:       eddystoneUrlBeamsVal,
		EddystoneUrlEnabled:     eddystoneUrlEnabledVal,
		EddystoneUrlFreqMsec:    eddystoneUrlFreqMsecVal,
		EddystoneUrlUrl:         eddystoneUrlUrlVal,
		IbeaconAdvPower:         ibeaconAdvPowerVal,
		IbeaconBeams:            ibeaconBeamsVal,
		IbeaconEnabled:          ibeaconEnabledVal,
		IbeaconFreqMsec:         ibeaconFreqMsecVal,
		IbeaconMajor:            ibeaconMajorVal,
		IbeaconMinor:            ibeaconMinorVal,
		IbeaconUuid:             ibeaconUuidVal,
		Power:                   powerVal,
		PowerMode:               powerModeVal,
		state:                   attr.ValueStateKnown,
	}, diags
}

func NewBleConfigValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) BleConfigValue {
	object, diags := NewBleConfigValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewBleConfigValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t BleConfigType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewBleConfigValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewBleConfigValueUnknown(), nil
	}

	if in.IsNull() {
		return NewBleConfigValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewBleConfigValueMust(BleConfigValue{}.AttributeTypes(ctx), attributes), nil
}

func (t BleConfigType) ValueType(ctx context.Context) attr.Value {
	return BleConfigValue{}
}

var _ basetypes.ObjectValuable = BleConfigValue{}

type BleConfigValue struct {
	BeaconEnabled           basetypes.BoolValue   `tfsdk:"beacon_enabled"`
	BeaconRate              basetypes.Int64Value  `tfsdk:"beacon_rate"`
	BeaconRateMode          basetypes.StringValue `tfsdk:"beacon_rate_mode"`
	BeamDisabled            basetypes.ListValue   `tfsdk:"beam_disabled"`
	CustomBlePacketEnabled  basetypes.BoolValue   `tfsdk:"custom_ble_packet_enabled"`
	CustomBlePacketFrame    basetypes.StringValue `tfsdk:"custom_ble_packet_frame"`
	CustomBlePacketFreqMsec basetypes.Int64Value  `tfsdk:"custom_ble_packet_freq_msec"`
	EddystoneUidAdvPower    basetypes.Int64Value  `tfsdk:"eddystone_uid_adv_power"`
	EddystoneUidBeams       basetypes.StringValue `tfsdk:"eddystone_uid_beams"`
	EddystoneUidEnabled     basetypes.BoolValue   `tfsdk:"eddystone_uid_enabled"`
	EddystoneUidFreqMsec    basetypes.Int64Value  `tfsdk:"eddystone_uid_freq_msec"`
	EddystoneUidInstance    basetypes.StringValue `tfsdk:"eddystone_uid_instance"`
	EddystoneUidNamespace   basetypes.StringValue `tfsdk:"eddystone_uid_namespace"`
	EddystoneUrlAdvPower    basetypes.Int64Value  `tfsdk:"eddystone_url_adv_power"`
	EddystoneUrlBeams       basetypes.StringValue `tfsdk:"eddystone_url_beams"`
	EddystoneUrlEnabled     basetypes.BoolValue   `tfsdk:"eddystone_url_enabled"`
	EddystoneUrlFreqMsec    basetypes.Int64Value  `tfsdk:"eddystone_url_freq_msec"`
	EddystoneUrlUrl         basetypes.StringValue `tfsdk:"eddystone_url_url"`
	IbeaconAdvPower         basetypes.Int64Value  `tfsdk:"ibeacon_adv_power"`
	IbeaconBeams            basetypes.StringValue `tfsdk:"ibeacon_beams"`
	IbeaconEnabled          basetypes.BoolValue   `tfsdk:"ibeacon_enabled"`
	IbeaconFreqMsec         basetypes.Int64Value  `tfsdk:"ibeacon_freq_msec"`
	IbeaconMajor            basetypes.Int64Value  `tfsdk:"ibeacon_major"`
	IbeaconMinor            basetypes.Int64Value  `tfsdk:"ibeacon_minor"`
	IbeaconUuid             basetypes.StringValue `tfsdk:"ibeacon_uuid"`
	Power                   basetypes.Int64Value  `tfsdk:"power"`
	PowerMode               basetypes.StringValue `tfsdk:"power_mode"`
	state                   attr.ValueState
}

func (v BleConfigValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 27)

	var val tftypes.Value
	var err error

	attrTypes["beacon_enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["beacon_rate"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["beacon_rate_mode"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["beam_disabled"] = basetypes.ListType{
		ElemType: types.Int64Type,
	}.TerraformType(ctx)
	attrTypes["custom_ble_packet_enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["custom_ble_packet_frame"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["custom_ble_packet_freq_msec"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["eddystone_uid_adv_power"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["eddystone_uid_beams"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["eddystone_uid_enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["eddystone_uid_freq_msec"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["eddystone_uid_instance"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["eddystone_uid_namespace"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["eddystone_url_adv_power"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["eddystone_url_beams"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["eddystone_url_enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["eddystone_url_freq_msec"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["eddystone_url_url"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ibeacon_adv_power"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["ibeacon_beams"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ibeacon_enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["ibeacon_freq_msec"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["ibeacon_major"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["ibeacon_minor"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["ibeacon_uuid"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["power"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["power_mode"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 27)

		val, err = v.BeaconEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["beacon_enabled"] = val

		val, err = v.BeaconRate.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["beacon_rate"] = val

		val, err = v.BeaconRateMode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["beacon_rate_mode"] = val

		val, err = v.BeamDisabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["beam_disabled"] = val

		val, err = v.CustomBlePacketEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["custom_ble_packet_enabled"] = val

		val, err = v.CustomBlePacketFrame.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["custom_ble_packet_frame"] = val

		val, err = v.CustomBlePacketFreqMsec.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["custom_ble_packet_freq_msec"] = val

		val, err = v.EddystoneUidAdvPower.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["eddystone_uid_adv_power"] = val

		val, err = v.EddystoneUidBeams.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["eddystone_uid_beams"] = val

		val, err = v.EddystoneUidEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["eddystone_uid_enabled"] = val

		val, err = v.EddystoneUidFreqMsec.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["eddystone_uid_freq_msec"] = val

		val, err = v.EddystoneUidInstance.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["eddystone_uid_instance"] = val

		val, err = v.EddystoneUidNamespace.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["eddystone_uid_namespace"] = val

		val, err = v.EddystoneUrlAdvPower.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["eddystone_url_adv_power"] = val

		val, err = v.EddystoneUrlBeams.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["eddystone_url_beams"] = val

		val, err = v.EddystoneUrlEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["eddystone_url_enabled"] = val

		val, err = v.EddystoneUrlFreqMsec.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["eddystone_url_freq_msec"] = val

		val, err = v.EddystoneUrlUrl.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["eddystone_url_url"] = val

		val, err = v.IbeaconAdvPower.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ibeacon_adv_power"] = val

		val, err = v.IbeaconBeams.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ibeacon_beams"] = val

		val, err = v.IbeaconEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ibeacon_enabled"] = val

		val, err = v.IbeaconFreqMsec.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ibeacon_freq_msec"] = val

		val, err = v.IbeaconMajor.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ibeacon_major"] = val

		val, err = v.IbeaconMinor.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ibeacon_minor"] = val

		val, err = v.IbeaconUuid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ibeacon_uuid"] = val

		val, err = v.Power.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["power"] = val

		val, err = v.PowerMode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["power_mode"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v BleConfigValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v BleConfigValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v BleConfigValue) String() string {
	return "BleConfigValue"
}

func (v BleConfigValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	beamDisabledVal, d := types.ListValue(types.Int64Type, v.BeamDisabled.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"beacon_enabled":   basetypes.BoolType{},
			"beacon_rate":      basetypes.Int64Type{},
			"beacon_rate_mode": basetypes.StringType{},
			"beam_disabled": basetypes.ListType{
				ElemType: types.Int64Type,
			},
			"custom_ble_packet_enabled":   basetypes.BoolType{},
			"custom_ble_packet_frame":     basetypes.StringType{},
			"custom_ble_packet_freq_msec": basetypes.Int64Type{},
			"eddystone_uid_adv_power":     basetypes.Int64Type{},
			"eddystone_uid_beams":         basetypes.StringType{},
			"eddystone_uid_enabled":       basetypes.BoolType{},
			"eddystone_uid_freq_msec":     basetypes.Int64Type{},
			"eddystone_uid_instance":      basetypes.StringType{},
			"eddystone_uid_namespace":     basetypes.StringType{},
			"eddystone_url_adv_power":     basetypes.Int64Type{},
			"eddystone_url_beams":         basetypes.StringType{},
			"eddystone_url_enabled":       basetypes.BoolType{},
			"eddystone_url_freq_msec":     basetypes.Int64Type{},
			"eddystone_url_url":           basetypes.StringType{},
			"ibeacon_adv_power":           basetypes.Int64Type{},
			"ibeacon_beams":               basetypes.StringType{},
			"ibeacon_enabled":             basetypes.BoolType{},
			"ibeacon_freq_msec":           basetypes.Int64Type{},
			"ibeacon_major":               basetypes.Int64Type{},
			"ibeacon_minor":               basetypes.Int64Type{},
			"ibeacon_uuid":                basetypes.StringType{},
			"power":                       basetypes.Int64Type{},
			"power_mode":                  basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"beacon_enabled":   basetypes.BoolType{},
		"beacon_rate":      basetypes.Int64Type{},
		"beacon_rate_mode": basetypes.StringType{},
		"beam_disabled": basetypes.ListType{
			ElemType: types.Int64Type,
		},
		"custom_ble_packet_enabled":   basetypes.BoolType{},
		"custom_ble_packet_frame":     basetypes.StringType{},
		"custom_ble_packet_freq_msec": basetypes.Int64Type{},
		"eddystone_uid_adv_power":     basetypes.Int64Type{},
		"eddystone_uid_beams":         basetypes.StringType{},
		"eddystone_uid_enabled":       basetypes.BoolType{},
		"eddystone_uid_freq_msec":     basetypes.Int64Type{},
		"eddystone_uid_instance":      basetypes.StringType{},
		"eddystone_uid_namespace":     basetypes.StringType{},
		"eddystone_url_adv_power":     basetypes.Int64Type{},
		"eddystone_url_beams":         basetypes.StringType{},
		"eddystone_url_enabled":       basetypes.BoolType{},
		"eddystone_url_freq_msec":     basetypes.Int64Type{},
		"eddystone_url_url":           basetypes.StringType{},
		"ibeacon_adv_power":           basetypes.Int64Type{},
		"ibeacon_beams":               basetypes.StringType{},
		"ibeacon_enabled":             basetypes.BoolType{},
		"ibeacon_freq_msec":           basetypes.Int64Type{},
		"ibeacon_major":               basetypes.Int64Type{},
		"ibeacon_minor":               basetypes.Int64Type{},
		"ibeacon_uuid":                basetypes.StringType{},
		"power":                       basetypes.Int64Type{},
		"power_mode":                  basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"beacon_enabled":              v.BeaconEnabled,
			"beacon_rate":                 v.BeaconRate,
			"beacon_rate_mode":            v.BeaconRateMode,
			"beam_disabled":               beamDisabledVal,
			"custom_ble_packet_enabled":   v.CustomBlePacketEnabled,
			"custom_ble_packet_frame":     v.CustomBlePacketFrame,
			"custom_ble_packet_freq_msec": v.CustomBlePacketFreqMsec,
			"eddystone_uid_adv_power":     v.EddystoneUidAdvPower,
			"eddystone_uid_beams":         v.EddystoneUidBeams,
			"eddystone_uid_enabled":       v.EddystoneUidEnabled,
			"eddystone_uid_freq_msec":     v.EddystoneUidFreqMsec,
			"eddystone_uid_instance":      v.EddystoneUidInstance,
			"eddystone_uid_namespace":     v.EddystoneUidNamespace,
			"eddystone_url_adv_power":     v.EddystoneUrlAdvPower,
			"eddystone_url_beams":         v.EddystoneUrlBeams,
			"eddystone_url_enabled":       v.EddystoneUrlEnabled,
			"eddystone_url_freq_msec":     v.EddystoneUrlFreqMsec,
			"eddystone_url_url":           v.EddystoneUrlUrl,
			"ibeacon_adv_power":           v.IbeaconAdvPower,
			"ibeacon_beams":               v.IbeaconBeams,
			"ibeacon_enabled":             v.IbeaconEnabled,
			"ibeacon_freq_msec":           v.IbeaconFreqMsec,
			"ibeacon_major":               v.IbeaconMajor,
			"ibeacon_minor":               v.IbeaconMinor,
			"ibeacon_uuid":                v.IbeaconUuid,
			"power":                       v.Power,
			"power_mode":                  v.PowerMode,
		})

	return objVal, diags
}

func (v BleConfigValue) Equal(o attr.Value) bool {
	other, ok := o.(BleConfigValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.BeaconEnabled.Equal(other.BeaconEnabled) {
		return false
	}

	if !v.BeaconRate.Equal(other.BeaconRate) {
		return false
	}

	if !v.BeaconRateMode.Equal(other.BeaconRateMode) {
		return false
	}

	if !v.BeamDisabled.Equal(other.BeamDisabled) {
		return false
	}

	if !v.CustomBlePacketEnabled.Equal(other.CustomBlePacketEnabled) {
		return false
	}

	if !v.CustomBlePacketFrame.Equal(other.CustomBlePacketFrame) {
		return false
	}

	if !v.CustomBlePacketFreqMsec.Equal(other.CustomBlePacketFreqMsec) {
		return false
	}

	if !v.EddystoneUidAdvPower.Equal(other.EddystoneUidAdvPower) {
		return false
	}

	if !v.EddystoneUidBeams.Equal(other.EddystoneUidBeams) {
		return false
	}

	if !v.EddystoneUidEnabled.Equal(other.EddystoneUidEnabled) {
		return false
	}

	if !v.EddystoneUidFreqMsec.Equal(other.EddystoneUidFreqMsec) {
		return false
	}

	if !v.EddystoneUidInstance.Equal(other.EddystoneUidInstance) {
		return false
	}

	if !v.EddystoneUidNamespace.Equal(other.EddystoneUidNamespace) {
		return false
	}

	if !v.EddystoneUrlAdvPower.Equal(other.EddystoneUrlAdvPower) {
		return false
	}

	if !v.EddystoneUrlBeams.Equal(other.EddystoneUrlBeams) {
		return false
	}

	if !v.EddystoneUrlEnabled.Equal(other.EddystoneUrlEnabled) {
		return false
	}

	if !v.EddystoneUrlFreqMsec.Equal(other.EddystoneUrlFreqMsec) {
		return false
	}

	if !v.EddystoneUrlUrl.Equal(other.EddystoneUrlUrl) {
		return false
	}

	if !v.IbeaconAdvPower.Equal(other.IbeaconAdvPower) {
		return false
	}

	if !v.IbeaconBeams.Equal(other.IbeaconBeams) {
		return false
	}

	if !v.IbeaconEnabled.Equal(other.IbeaconEnabled) {
		return false
	}

	if !v.IbeaconFreqMsec.Equal(other.IbeaconFreqMsec) {
		return false
	}

	if !v.IbeaconMajor.Equal(other.IbeaconMajor) {
		return false
	}

	if !v.IbeaconMinor.Equal(other.IbeaconMinor) {
		return false
	}

	if !v.IbeaconUuid.Equal(other.IbeaconUuid) {
		return false
	}

	if !v.Power.Equal(other.Power) {
		return false
	}

	if !v.PowerMode.Equal(other.PowerMode) {
		return false
	}

	return true
}

func (v BleConfigValue) Type(ctx context.Context) attr.Type {
	return BleConfigType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v BleConfigValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"beacon_enabled":   basetypes.BoolType{},
		"beacon_rate":      basetypes.Int64Type{},
		"beacon_rate_mode": basetypes.StringType{},
		"beam_disabled": basetypes.ListType{
			ElemType: types.Int64Type,
		},
		"custom_ble_packet_enabled":   basetypes.BoolType{},
		"custom_ble_packet_frame":     basetypes.StringType{},
		"custom_ble_packet_freq_msec": basetypes.Int64Type{},
		"eddystone_uid_adv_power":     basetypes.Int64Type{},
		"eddystone_uid_beams":         basetypes.StringType{},
		"eddystone_uid_enabled":       basetypes.BoolType{},
		"eddystone_uid_freq_msec":     basetypes.Int64Type{},
		"eddystone_uid_instance":      basetypes.StringType{},
		"eddystone_uid_namespace":     basetypes.StringType{},
		"eddystone_url_adv_power":     basetypes.Int64Type{},
		"eddystone_url_beams":         basetypes.StringType{},
		"eddystone_url_enabled":       basetypes.BoolType{},
		"eddystone_url_freq_msec":     basetypes.Int64Type{},
		"eddystone_url_url":           basetypes.StringType{},
		"ibeacon_adv_power":           basetypes.Int64Type{},
		"ibeacon_beams":               basetypes.StringType{},
		"ibeacon_enabled":             basetypes.BoolType{},
		"ibeacon_freq_msec":           basetypes.Int64Type{},
		"ibeacon_major":               basetypes.Int64Type{},
		"ibeacon_minor":               basetypes.Int64Type{},
		"ibeacon_uuid":                basetypes.StringType{},
		"power":                       basetypes.Int64Type{},
		"power_mode":                  basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = ConfigPushPolicyType{}

type ConfigPushPolicyType struct {
	basetypes.ObjectType
}

func (t ConfigPushPolicyType) Equal(o attr.Type) bool {
	other, ok := o.(ConfigPushPolicyType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ConfigPushPolicyType) String() string {
	return "ConfigPushPolicyType"
}

func (t ConfigPushPolicyType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	noPushAttribute, ok := attributes["no_push"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`no_push is missing from object`)

		return nil, diags
	}

	noPushVal, ok := noPushAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`no_push expected to be basetypes.BoolValue, was: %T`, noPushAttribute))
	}

	pushWindowAttribute, ok := attributes["push_window"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`push_window is missing from object`)

		return nil, diags
	}

	pushWindowVal, ok := pushWindowAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`push_window expected to be basetypes.ObjectValue, was: %T`, pushWindowAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ConfigPushPolicyValue{
		NoPush:     noPushVal,
		PushWindow: pushWindowVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewConfigPushPolicyValueNull() ConfigPushPolicyValue {
	return ConfigPushPolicyValue{
		state: attr.ValueStateNull,
	}
}

func NewConfigPushPolicyValueUnknown() ConfigPushPolicyValue {
	return ConfigPushPolicyValue{
		state: attr.ValueStateUnknown,
	}
}

func NewConfigPushPolicyValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ConfigPushPolicyValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ConfigPushPolicyValue Attribute Value",
				"While creating a ConfigPushPolicyValue value, a missing attribute value was detected. "+
					"A ConfigPushPolicyValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ConfigPushPolicyValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ConfigPushPolicyValue Attribute Type",
				"While creating a ConfigPushPolicyValue value, an invalid attribute value was detected. "+
					"A ConfigPushPolicyValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ConfigPushPolicyValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ConfigPushPolicyValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ConfigPushPolicyValue Attribute Value",
				"While creating a ConfigPushPolicyValue value, an extra attribute value was detected. "+
					"A ConfigPushPolicyValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ConfigPushPolicyValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewConfigPushPolicyValueUnknown(), diags
	}

	noPushAttribute, ok := attributes["no_push"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`no_push is missing from object`)

		return NewConfigPushPolicyValueUnknown(), diags
	}

	noPushVal, ok := noPushAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`no_push expected to be basetypes.BoolValue, was: %T`, noPushAttribute))
	}

	pushWindowAttribute, ok := attributes["push_window"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`push_window is missing from object`)

		return NewConfigPushPolicyValueUnknown(), diags
	}

	pushWindowVal, ok := pushWindowAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`push_window expected to be basetypes.ObjectValue, was: %T`, pushWindowAttribute))
	}

	if diags.HasError() {
		return NewConfigPushPolicyValueUnknown(), diags
	}

	return ConfigPushPolicyValue{
		NoPush:     noPushVal,
		PushWindow: pushWindowVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewConfigPushPolicyValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ConfigPushPolicyValue {
	object, diags := NewConfigPushPolicyValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewConfigPushPolicyValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ConfigPushPolicyType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewConfigPushPolicyValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewConfigPushPolicyValueUnknown(), nil
	}

	if in.IsNull() {
		return NewConfigPushPolicyValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewConfigPushPolicyValueMust(ConfigPushPolicyValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ConfigPushPolicyType) ValueType(ctx context.Context) attr.Value {
	return ConfigPushPolicyValue{}
}

var _ basetypes.ObjectValuable = ConfigPushPolicyValue{}

type ConfigPushPolicyValue struct {
	NoPush     basetypes.BoolValue   `tfsdk:"no_push"`
	PushWindow basetypes.ObjectValue `tfsdk:"push_window"`
	state      attr.ValueState
}

func (v ConfigPushPolicyValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["no_push"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["push_window"] = basetypes.ObjectType{
		AttrTypes: PushWindowValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.NoPush.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["no_push"] = val

		val, err = v.PushWindow.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["push_window"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ConfigPushPolicyValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ConfigPushPolicyValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ConfigPushPolicyValue) String() string {
	return "ConfigPushPolicyValue"
}

func (v ConfigPushPolicyValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var pushWindow basetypes.ObjectValue

	if v.PushWindow.IsNull() {
		pushWindow = types.ObjectNull(
			PushWindowValue{}.AttributeTypes(ctx),
		)
	}

	if v.PushWindow.IsUnknown() {
		pushWindow = types.ObjectUnknown(
			PushWindowValue{}.AttributeTypes(ctx),
		)
	}

	if !v.PushWindow.IsNull() && !v.PushWindow.IsUnknown() {
		pushWindow = types.ObjectValueMust(
			PushWindowValue{}.AttributeTypes(ctx),
			v.PushWindow.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"no_push": basetypes.BoolType{},
		"push_window": basetypes.ObjectType{
			AttrTypes: PushWindowValue{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"no_push":     v.NoPush,
			"push_window": pushWindow,
		})

	return objVal, diags
}

func (v ConfigPushPolicyValue) Equal(o attr.Value) bool {
	other, ok := o.(ConfigPushPolicyValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.NoPush.Equal(other.NoPush) {
		return false
	}

	if !v.PushWindow.Equal(other.PushWindow) {
		return false
	}

	return true
}

func (v ConfigPushPolicyValue) Type(ctx context.Context) attr.Type {
	return ConfigPushPolicyType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ConfigPushPolicyValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"no_push": basetypes.BoolType{},
		"push_window": basetypes.ObjectType{
			AttrTypes: PushWindowValue{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = PushWindowType{}

type PushWindowType struct {
	basetypes.ObjectType
}

func (t PushWindowType) Equal(o attr.Type) bool {
	other, ok := o.(PushWindowType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PushWindowType) String() string {
	return "PushWindowType"
}

func (t PushWindowType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	hoursAttribute, ok := attributes["hours"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`hours is missing from object`)

		return nil, diags
	}

	hoursVal, ok := hoursAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`hours expected to be basetypes.ObjectValue, was: %T`, hoursAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PushWindowValue{
		Enabled: enabledVal,
		Hours:   hoursVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewPushWindowValueNull() PushWindowValue {
	return PushWindowValue{
		state: attr.ValueStateNull,
	}
}

func NewPushWindowValueUnknown() PushWindowValue {
	return PushWindowValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPushWindowValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PushWindowValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PushWindowValue Attribute Value",
				"While creating a PushWindowValue value, a missing attribute value was detected. "+
					"A PushWindowValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PushWindowValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PushWindowValue Attribute Type",
				"While creating a PushWindowValue value, an invalid attribute value was detected. "+
					"A PushWindowValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PushWindowValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PushWindowValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PushWindowValue Attribute Value",
				"While creating a PushWindowValue value, an extra attribute value was detected. "+
					"A PushWindowValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PushWindowValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPushWindowValueUnknown(), diags
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewPushWindowValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	hoursAttribute, ok := attributes["hours"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`hours is missing from object`)

		return NewPushWindowValueUnknown(), diags
	}

	hoursVal, ok := hoursAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`hours expected to be basetypes.ObjectValue, was: %T`, hoursAttribute))
	}

	if diags.HasError() {
		return NewPushWindowValueUnknown(), diags
	}

	return PushWindowValue{
		Enabled: enabledVal,
		Hours:   hoursVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewPushWindowValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PushWindowValue {
	object, diags := NewPushWindowValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPushWindowValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PushWindowType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPushWindowValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPushWindowValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPushWindowValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPushWindowValueMust(PushWindowValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PushWindowType) ValueType(ctx context.Context) attr.Value {
	return PushWindowValue{}
}

var _ basetypes.ObjectValuable = PushWindowValue{}

type PushWindowValue struct {
	Enabled basetypes.BoolValue   `tfsdk:"enabled"`
	Hours   basetypes.ObjectValue `tfsdk:"hours"`
	state   attr.ValueState
}

func (v PushWindowValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["hours"] = basetypes.ObjectType{
		AttrTypes: HoursValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.Hours.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["hours"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PushWindowValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PushWindowValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PushWindowValue) String() string {
	return "PushWindowValue"
}

func (v PushWindowValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var hours basetypes.ObjectValue

	if v.Hours.IsNull() {
		hours = types.ObjectNull(
			HoursValue{}.AttributeTypes(ctx),
		)
	}

	if v.Hours.IsUnknown() {
		hours = types.ObjectUnknown(
			HoursValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Hours.IsNull() && !v.Hours.IsUnknown() {
		hours = types.ObjectValueMust(
			HoursValue{}.AttributeTypes(ctx),
			v.Hours.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"enabled": basetypes.BoolType{},
		"hours": basetypes.ObjectType{
			AttrTypes: HoursValue{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"enabled": v.Enabled,
			"hours":   hours,
		})

	return objVal, diags
}

func (v PushWindowValue) Equal(o attr.Value) bool {
	other, ok := o.(PushWindowValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.Hours.Equal(other.Hours) {
		return false
	}

	return true
}

func (v PushWindowValue) Type(ctx context.Context) attr.Type {
	return PushWindowType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PushWindowValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"enabled": basetypes.BoolType{},
		"hours": basetypes.ObjectType{
			AttrTypes: HoursValue{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = HoursType{}

type HoursType struct {
	basetypes.ObjectType
}

func (t HoursType) Equal(o attr.Type) bool {
	other, ok := o.(HoursType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t HoursType) String() string {
	return "HoursType"
}

func (t HoursType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	friAttribute, ok := attributes["fri"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fri is missing from object`)

		return nil, diags
	}

	friVal, ok := friAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fri expected to be basetypes.StringValue, was: %T`, friAttribute))
	}

	monAttribute, ok := attributes["mon"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mon is missing from object`)

		return nil, diags
	}

	monVal, ok := monAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mon expected to be basetypes.StringValue, was: %T`, monAttribute))
	}

	satAttribute, ok := attributes["sat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sat is missing from object`)

		return nil, diags
	}

	satVal, ok := satAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sat expected to be basetypes.StringValue, was: %T`, satAttribute))
	}

	sunAttribute, ok := attributes["sun"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sun is missing from object`)

		return nil, diags
	}

	sunVal, ok := sunAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sun expected to be basetypes.StringValue, was: %T`, sunAttribute))
	}

	thuAttribute, ok := attributes["thu"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`thu is missing from object`)

		return nil, diags
	}

	thuVal, ok := thuAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`thu expected to be basetypes.StringValue, was: %T`, thuAttribute))
	}

	tueAttribute, ok := attributes["tue"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tue is missing from object`)

		return nil, diags
	}

	tueVal, ok := tueAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tue expected to be basetypes.StringValue, was: %T`, tueAttribute))
	}

	wedAttribute, ok := attributes["wed"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wed is missing from object`)

		return nil, diags
	}

	wedVal, ok := wedAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wed expected to be basetypes.StringValue, was: %T`, wedAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return HoursValue{
		Fri:   friVal,
		Mon:   monVal,
		Sat:   satVal,
		Sun:   sunVal,
		Thu:   thuVal,
		Tue:   tueVal,
		Wed:   wedVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewHoursValueNull() HoursValue {
	return HoursValue{
		state: attr.ValueStateNull,
	}
}

func NewHoursValueUnknown() HoursValue {
	return HoursValue{
		state: attr.ValueStateUnknown,
	}
}

func NewHoursValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (HoursValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing HoursValue Attribute Value",
				"While creating a HoursValue value, a missing attribute value was detected. "+
					"A HoursValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("HoursValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid HoursValue Attribute Type",
				"While creating a HoursValue value, an invalid attribute value was detected. "+
					"A HoursValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("HoursValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("HoursValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra HoursValue Attribute Value",
				"While creating a HoursValue value, an extra attribute value was detected. "+
					"A HoursValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra HoursValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewHoursValueUnknown(), diags
	}

	friAttribute, ok := attributes["fri"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fri is missing from object`)

		return NewHoursValueUnknown(), diags
	}

	friVal, ok := friAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fri expected to be basetypes.StringValue, was: %T`, friAttribute))
	}

	monAttribute, ok := attributes["mon"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mon is missing from object`)

		return NewHoursValueUnknown(), diags
	}

	monVal, ok := monAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mon expected to be basetypes.StringValue, was: %T`, monAttribute))
	}

	satAttribute, ok := attributes["sat"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sat is missing from object`)

		return NewHoursValueUnknown(), diags
	}

	satVal, ok := satAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sat expected to be basetypes.StringValue, was: %T`, satAttribute))
	}

	sunAttribute, ok := attributes["sun"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sun is missing from object`)

		return NewHoursValueUnknown(), diags
	}

	sunVal, ok := sunAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sun expected to be basetypes.StringValue, was: %T`, sunAttribute))
	}

	thuAttribute, ok := attributes["thu"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`thu is missing from object`)

		return NewHoursValueUnknown(), diags
	}

	thuVal, ok := thuAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`thu expected to be basetypes.StringValue, was: %T`, thuAttribute))
	}

	tueAttribute, ok := attributes["tue"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tue is missing from object`)

		return NewHoursValueUnknown(), diags
	}

	tueVal, ok := tueAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tue expected to be basetypes.StringValue, was: %T`, tueAttribute))
	}

	wedAttribute, ok := attributes["wed"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wed is missing from object`)

		return NewHoursValueUnknown(), diags
	}

	wedVal, ok := wedAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wed expected to be basetypes.StringValue, was: %T`, wedAttribute))
	}

	if diags.HasError() {
		return NewHoursValueUnknown(), diags
	}

	return HoursValue{
		Fri:   friVal,
		Mon:   monVal,
		Sat:   satVal,
		Sun:   sunVal,
		Thu:   thuVal,
		Tue:   tueVal,
		Wed:   wedVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewHoursValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) HoursValue {
	object, diags := NewHoursValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewHoursValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t HoursType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewHoursValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewHoursValueUnknown(), nil
	}

	if in.IsNull() {
		return NewHoursValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewHoursValueMust(HoursValue{}.AttributeTypes(ctx), attributes), nil
}

func (t HoursType) ValueType(ctx context.Context) attr.Value {
	return HoursValue{}
}

var _ basetypes.ObjectValuable = HoursValue{}

type HoursValue struct {
	Fri   basetypes.StringValue `tfsdk:"fri"`
	Mon   basetypes.StringValue `tfsdk:"mon"`
	Sat   basetypes.StringValue `tfsdk:"sat"`
	Sun   basetypes.StringValue `tfsdk:"sun"`
	Thu   basetypes.StringValue `tfsdk:"thu"`
	Tue   basetypes.StringValue `tfsdk:"tue"`
	Wed   basetypes.StringValue `tfsdk:"wed"`
	state attr.ValueState
}

func (v HoursValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 7)

	var val tftypes.Value
	var err error

	attrTypes["fri"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["mon"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["sat"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["sun"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["thu"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["tue"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["wed"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 7)

		val, err = v.Fri.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["fri"] = val

		val, err = v.Mon.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mon"] = val

		val, err = v.Sat.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["sat"] = val

		val, err = v.Sun.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["sun"] = val

		val, err = v.Thu.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["thu"] = val

		val, err = v.Tue.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tue"] = val

		val, err = v.Wed.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["wed"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v HoursValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v HoursValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v HoursValue) String() string {
	return "HoursValue"
}

func (v HoursValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"fri": basetypes.StringType{},
		"mon": basetypes.StringType{},
		"sat": basetypes.StringType{},
		"sun": basetypes.StringType{},
		"thu": basetypes.StringType{},
		"tue": basetypes.StringType{},
		"wed": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"fri": v.Fri,
			"mon": v.Mon,
			"sat": v.Sat,
			"sun": v.Sun,
			"thu": v.Thu,
			"tue": v.Tue,
			"wed": v.Wed,
		})

	return objVal, diags
}

func (v HoursValue) Equal(o attr.Value) bool {
	other, ok := o.(HoursValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Fri.Equal(other.Fri) {
		return false
	}

	if !v.Mon.Equal(other.Mon) {
		return false
	}

	if !v.Sat.Equal(other.Sat) {
		return false
	}

	if !v.Sun.Equal(other.Sun) {
		return false
	}

	if !v.Thu.Equal(other.Thu) {
		return false
	}

	if !v.Tue.Equal(other.Tue) {
		return false
	}

	if !v.Wed.Equal(other.Wed) {
		return false
	}

	return true
}

func (v HoursValue) Type(ctx context.Context) attr.Type {
	return HoursType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v HoursValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"fri": basetypes.StringType{},
		"mon": basetypes.StringType{},
		"sat": basetypes.StringType{},
		"sun": basetypes.StringType{},
		"thu": basetypes.StringType{},
		"tue": basetypes.StringType{},
		"wed": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = CriticalUrlMonitoringType{}

type CriticalUrlMonitoringType struct {
	basetypes.ObjectType
}

func (t CriticalUrlMonitoringType) Equal(o attr.Type) bool {
	other, ok := o.(CriticalUrlMonitoringType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t CriticalUrlMonitoringType) String() string {
	return "CriticalUrlMonitoringType"
}

func (t CriticalUrlMonitoringType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	monitorsAttribute, ok := attributes["monitors"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`monitors is missing from object`)

		return nil, diags
	}

	monitorsVal, ok := monitorsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`monitors expected to be basetypes.ListValue, was: %T`, monitorsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return CriticalUrlMonitoringValue{
		Enabled:  enabledVal,
		Monitors: monitorsVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewCriticalUrlMonitoringValueNull() CriticalUrlMonitoringValue {
	return CriticalUrlMonitoringValue{
		state: attr.ValueStateNull,
	}
}

func NewCriticalUrlMonitoringValueUnknown() CriticalUrlMonitoringValue {
	return CriticalUrlMonitoringValue{
		state: attr.ValueStateUnknown,
	}
}

func NewCriticalUrlMonitoringValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (CriticalUrlMonitoringValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing CriticalUrlMonitoringValue Attribute Value",
				"While creating a CriticalUrlMonitoringValue value, a missing attribute value was detected. "+
					"A CriticalUrlMonitoringValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CriticalUrlMonitoringValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid CriticalUrlMonitoringValue Attribute Type",
				"While creating a CriticalUrlMonitoringValue value, an invalid attribute value was detected. "+
					"A CriticalUrlMonitoringValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CriticalUrlMonitoringValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("CriticalUrlMonitoringValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra CriticalUrlMonitoringValue Attribute Value",
				"While creating a CriticalUrlMonitoringValue value, an extra attribute value was detected. "+
					"A CriticalUrlMonitoringValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra CriticalUrlMonitoringValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewCriticalUrlMonitoringValueUnknown(), diags
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewCriticalUrlMonitoringValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	monitorsAttribute, ok := attributes["monitors"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`monitors is missing from object`)

		return NewCriticalUrlMonitoringValueUnknown(), diags
	}

	monitorsVal, ok := monitorsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`monitors expected to be basetypes.ListValue, was: %T`, monitorsAttribute))
	}

	if diags.HasError() {
		return NewCriticalUrlMonitoringValueUnknown(), diags
	}

	return CriticalUrlMonitoringValue{
		Enabled:  enabledVal,
		Monitors: monitorsVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewCriticalUrlMonitoringValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) CriticalUrlMonitoringValue {
	object, diags := NewCriticalUrlMonitoringValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewCriticalUrlMonitoringValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t CriticalUrlMonitoringType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewCriticalUrlMonitoringValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewCriticalUrlMonitoringValueUnknown(), nil
	}

	if in.IsNull() {
		return NewCriticalUrlMonitoringValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewCriticalUrlMonitoringValueMust(CriticalUrlMonitoringValue{}.AttributeTypes(ctx), attributes), nil
}

func (t CriticalUrlMonitoringType) ValueType(ctx context.Context) attr.Value {
	return CriticalUrlMonitoringValue{}
}

var _ basetypes.ObjectValuable = CriticalUrlMonitoringValue{}

type CriticalUrlMonitoringValue struct {
	Enabled  basetypes.BoolValue `tfsdk:"enabled"`
	Monitors basetypes.ListValue `tfsdk:"monitors"`
	state    attr.ValueState
}

func (v CriticalUrlMonitoringValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["monitors"] = basetypes.ListType{
		ElemType: MonitorsValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.Monitors.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["monitors"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v CriticalUrlMonitoringValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v CriticalUrlMonitoringValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v CriticalUrlMonitoringValue) String() string {
	return "CriticalUrlMonitoringValue"
}

func (v CriticalUrlMonitoringValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	monitors := types.ListValueMust(
		MonitorsType{
			basetypes.ObjectType{
				AttrTypes: MonitorsValue{}.AttributeTypes(ctx),
			},
		},
		v.Monitors.Elements(),
	)

	if v.Monitors.IsNull() {
		monitors = types.ListNull(
			MonitorsType{
				basetypes.ObjectType{
					AttrTypes: MonitorsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Monitors.IsUnknown() {
		monitors = types.ListUnknown(
			MonitorsType{
				basetypes.ObjectType{
					AttrTypes: MonitorsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"enabled": basetypes.BoolType{},
		"monitors": basetypes.ListType{
			ElemType: MonitorsValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"enabled":  v.Enabled,
			"monitors": monitors,
		})

	return objVal, diags
}

func (v CriticalUrlMonitoringValue) Equal(o attr.Value) bool {
	other, ok := o.(CriticalUrlMonitoringValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.Monitors.Equal(other.Monitors) {
		return false
	}

	return true
}

func (v CriticalUrlMonitoringValue) Type(ctx context.Context) attr.Type {
	return CriticalUrlMonitoringType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v CriticalUrlMonitoringValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"enabled": basetypes.BoolType{},
		"monitors": basetypes.ListType{
			ElemType: MonitorsValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = MonitorsType{}

type MonitorsType struct {
	basetypes.ObjectType
}

func (t MonitorsType) Equal(o attr.Type) bool {
	other, ok := o.(MonitorsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t MonitorsType) String() string {
	return "MonitorsType"
}

func (t MonitorsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return nil, diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	vlanIdAttribute, ok := attributes["vlan_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan_id is missing from object`)

		return nil, diags
	}

	vlanIdVal, ok := vlanIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan_id expected to be basetypes.Int64Value, was: %T`, vlanIdAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return MonitorsValue{
		Url:    urlVal,
		VlanId: vlanIdVal,
		state:  attr.ValueStateKnown,
	}, diags
}

func NewMonitorsValueNull() MonitorsValue {
	return MonitorsValue{
		state: attr.ValueStateNull,
	}
}

func NewMonitorsValueUnknown() MonitorsValue {
	return MonitorsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewMonitorsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (MonitorsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing MonitorsValue Attribute Value",
				"While creating a MonitorsValue value, a missing attribute value was detected. "+
					"A MonitorsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MonitorsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid MonitorsValue Attribute Type",
				"While creating a MonitorsValue value, an invalid attribute value was detected. "+
					"A MonitorsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MonitorsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("MonitorsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra MonitorsValue Attribute Value",
				"While creating a MonitorsValue value, an extra attribute value was detected. "+
					"A MonitorsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra MonitorsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewMonitorsValueUnknown(), diags
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return NewMonitorsValueUnknown(), diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	vlanIdAttribute, ok := attributes["vlan_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan_id is missing from object`)

		return NewMonitorsValueUnknown(), diags
	}

	vlanIdVal, ok := vlanIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan_id expected to be basetypes.Int64Value, was: %T`, vlanIdAttribute))
	}

	if diags.HasError() {
		return NewMonitorsValueUnknown(), diags
	}

	return MonitorsValue{
		Url:    urlVal,
		VlanId: vlanIdVal,
		state:  attr.ValueStateKnown,
	}, diags
}

func NewMonitorsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) MonitorsValue {
	object, diags := NewMonitorsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewMonitorsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t MonitorsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewMonitorsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewMonitorsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewMonitorsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewMonitorsValueMust(MonitorsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t MonitorsType) ValueType(ctx context.Context) attr.Value {
	return MonitorsValue{}
}

var _ basetypes.ObjectValuable = MonitorsValue{}

type MonitorsValue struct {
	Url    basetypes.StringValue `tfsdk:"url"`
	VlanId basetypes.Int64Value  `tfsdk:"vlan_id"`
	state  attr.ValueState
}

func (v MonitorsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["url"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["vlan_id"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Url.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["url"] = val

		val, err = v.VlanId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vlan_id"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v MonitorsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v MonitorsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v MonitorsValue) String() string {
	return "MonitorsValue"
}

func (v MonitorsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"url":     basetypes.StringType{},
		"vlan_id": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"url":     v.Url,
			"vlan_id": v.VlanId,
		})

	return objVal, diags
}

func (v MonitorsValue) Equal(o attr.Value) bool {
	other, ok := o.(MonitorsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Url.Equal(other.Url) {
		return false
	}

	if !v.VlanId.Equal(other.VlanId) {
		return false
	}

	return true
}

func (v MonitorsValue) Type(ctx context.Context) attr.Type {
	return MonitorsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v MonitorsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"url":     basetypes.StringType{},
		"vlan_id": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = EngagementType{}

type EngagementType struct {
	basetypes.ObjectType
}

func (t EngagementType) Equal(o attr.Type) bool {
	other, ok := o.(EngagementType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t EngagementType) String() string {
	return "EngagementType"
}

func (t EngagementType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	dwellTagNamesAttribute, ok := attributes["dwell_tag_names"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dwell_tag_names is missing from object`)

		return nil, diags
	}

	dwellTagNamesVal, ok := dwellTagNamesAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dwell_tag_names expected to be basetypes.ObjectValue, was: %T`, dwellTagNamesAttribute))
	}

	dwellTagsAttribute, ok := attributes["dwell_tags"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dwell_tags is missing from object`)

		return nil, diags
	}

	dwellTagsVal, ok := dwellTagsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dwell_tags expected to be basetypes.ObjectValue, was: %T`, dwellTagsAttribute))
	}

	hoursAttribute, ok := attributes["hours"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`hours is missing from object`)

		return nil, diags
	}

	hoursVal, ok := hoursAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`hours expected to be basetypes.ObjectValue, was: %T`, hoursAttribute))
	}

	maxDwellAttribute, ok := attributes["max_dwell"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_dwell is missing from object`)

		return nil, diags
	}

	maxDwellVal, ok := maxDwellAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_dwell expected to be basetypes.Int64Value, was: %T`, maxDwellAttribute))
	}

	minDwellAttribute, ok := attributes["min_dwell"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`min_dwell is missing from object`)

		return nil, diags
	}

	minDwellVal, ok := minDwellAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`min_dwell expected to be basetypes.Int64Value, was: %T`, minDwellAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return EngagementValue{
		DwellTagNames: dwellTagNamesVal,
		DwellTags:     dwellTagsVal,
		Hours:         hoursVal,
		MaxDwell:      maxDwellVal,
		MinDwell:      minDwellVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewEngagementValueNull() EngagementValue {
	return EngagementValue{
		state: attr.ValueStateNull,
	}
}

func NewEngagementValueUnknown() EngagementValue {
	return EngagementValue{
		state: attr.ValueStateUnknown,
	}
}

func NewEngagementValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (EngagementValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing EngagementValue Attribute Value",
				"While creating a EngagementValue value, a missing attribute value was detected. "+
					"A EngagementValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("EngagementValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid EngagementValue Attribute Type",
				"While creating a EngagementValue value, an invalid attribute value was detected. "+
					"A EngagementValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("EngagementValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("EngagementValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra EngagementValue Attribute Value",
				"While creating a EngagementValue value, an extra attribute value was detected. "+
					"A EngagementValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra EngagementValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewEngagementValueUnknown(), diags
	}

	dwellTagNamesAttribute, ok := attributes["dwell_tag_names"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dwell_tag_names is missing from object`)

		return NewEngagementValueUnknown(), diags
	}

	dwellTagNamesVal, ok := dwellTagNamesAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dwell_tag_names expected to be basetypes.ObjectValue, was: %T`, dwellTagNamesAttribute))
	}

	dwellTagsAttribute, ok := attributes["dwell_tags"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dwell_tags is missing from object`)

		return NewEngagementValueUnknown(), diags
	}

	dwellTagsVal, ok := dwellTagsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dwell_tags expected to be basetypes.ObjectValue, was: %T`, dwellTagsAttribute))
	}

	hoursAttribute, ok := attributes["hours"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`hours is missing from object`)

		return NewEngagementValueUnknown(), diags
	}

	hoursVal, ok := hoursAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`hours expected to be basetypes.ObjectValue, was: %T`, hoursAttribute))
	}

	maxDwellAttribute, ok := attributes["max_dwell"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_dwell is missing from object`)

		return NewEngagementValueUnknown(), diags
	}

	maxDwellVal, ok := maxDwellAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_dwell expected to be basetypes.Int64Value, was: %T`, maxDwellAttribute))
	}

	minDwellAttribute, ok := attributes["min_dwell"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`min_dwell is missing from object`)

		return NewEngagementValueUnknown(), diags
	}

	minDwellVal, ok := minDwellAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`min_dwell expected to be basetypes.Int64Value, was: %T`, minDwellAttribute))
	}

	if diags.HasError() {
		return NewEngagementValueUnknown(), diags
	}

	return EngagementValue{
		DwellTagNames: dwellTagNamesVal,
		DwellTags:     dwellTagsVal,
		Hours:         hoursVal,
		MaxDwell:      maxDwellVal,
		MinDwell:      minDwellVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewEngagementValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) EngagementValue {
	object, diags := NewEngagementValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewEngagementValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t EngagementType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewEngagementValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewEngagementValueUnknown(), nil
	}

	if in.IsNull() {
		return NewEngagementValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewEngagementValueMust(EngagementValue{}.AttributeTypes(ctx), attributes), nil
}

func (t EngagementType) ValueType(ctx context.Context) attr.Value {
	return EngagementValue{}
}

var _ basetypes.ObjectValuable = EngagementValue{}

type EngagementValue struct {
	DwellTagNames basetypes.ObjectValue `tfsdk:"dwell_tag_names"`
	DwellTags     basetypes.ObjectValue `tfsdk:"dwell_tags"`
	Hours         basetypes.ObjectValue `tfsdk:"hours"`
	MaxDwell      basetypes.Int64Value  `tfsdk:"max_dwell"`
	MinDwell      basetypes.Int64Value  `tfsdk:"min_dwell"`
	state         attr.ValueState
}

func (v EngagementValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["dwell_tag_names"] = basetypes.ObjectType{
		AttrTypes: DwellTagNamesValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["dwell_tags"] = basetypes.ObjectType{
		AttrTypes: DwellTagsValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["hours"] = basetypes.ObjectType{
		AttrTypes: HoursValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["max_dwell"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["min_dwell"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.DwellTagNames.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dwell_tag_names"] = val

		val, err = v.DwellTags.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dwell_tags"] = val

		val, err = v.Hours.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["hours"] = val

		val, err = v.MaxDwell.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_dwell"] = val

		val, err = v.MinDwell.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["min_dwell"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v EngagementValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v EngagementValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v EngagementValue) String() string {
	return "EngagementValue"
}

func (v EngagementValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var dwellTagNames basetypes.ObjectValue

	if v.DwellTagNames.IsNull() {
		dwellTagNames = types.ObjectNull(
			DwellTagNamesValue{}.AttributeTypes(ctx),
		)
	}

	if v.DwellTagNames.IsUnknown() {
		dwellTagNames = types.ObjectUnknown(
			DwellTagNamesValue{}.AttributeTypes(ctx),
		)
	}

	if !v.DwellTagNames.IsNull() && !v.DwellTagNames.IsUnknown() {
		dwellTagNames = types.ObjectValueMust(
			DwellTagNamesValue{}.AttributeTypes(ctx),
			v.DwellTagNames.Attributes(),
		)
	}

	var dwellTags basetypes.ObjectValue

	if v.DwellTags.IsNull() {
		dwellTags = types.ObjectNull(
			DwellTagsValue{}.AttributeTypes(ctx),
		)
	}

	if v.DwellTags.IsUnknown() {
		dwellTags = types.ObjectUnknown(
			DwellTagsValue{}.AttributeTypes(ctx),
		)
	}

	if !v.DwellTags.IsNull() && !v.DwellTags.IsUnknown() {
		dwellTags = types.ObjectValueMust(
			DwellTagsValue{}.AttributeTypes(ctx),
			v.DwellTags.Attributes(),
		)
	}

	var hours basetypes.ObjectValue

	if v.Hours.IsNull() {
		hours = types.ObjectNull(
			HoursValue{}.AttributeTypes(ctx),
		)
	}

	if v.Hours.IsUnknown() {
		hours = types.ObjectUnknown(
			HoursValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Hours.IsNull() && !v.Hours.IsUnknown() {
		hours = types.ObjectValueMust(
			HoursValue{}.AttributeTypes(ctx),
			v.Hours.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"dwell_tag_names": basetypes.ObjectType{
			AttrTypes: DwellTagNamesValue{}.AttributeTypes(ctx),
		},
		"dwell_tags": basetypes.ObjectType{
			AttrTypes: DwellTagsValue{}.AttributeTypes(ctx),
		},
		"hours": basetypes.ObjectType{
			AttrTypes: HoursValue{}.AttributeTypes(ctx),
		},
		"max_dwell": basetypes.Int64Type{},
		"min_dwell": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"dwell_tag_names": dwellTagNames,
			"dwell_tags":      dwellTags,
			"hours":           hours,
			"max_dwell":       v.MaxDwell,
			"min_dwell":       v.MinDwell,
		})

	return objVal, diags
}

func (v EngagementValue) Equal(o attr.Value) bool {
	other, ok := o.(EngagementValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.DwellTagNames.Equal(other.DwellTagNames) {
		return false
	}

	if !v.DwellTags.Equal(other.DwellTags) {
		return false
	}

	if !v.Hours.Equal(other.Hours) {
		return false
	}

	if !v.MaxDwell.Equal(other.MaxDwell) {
		return false
	}

	if !v.MinDwell.Equal(other.MinDwell) {
		return false
	}

	return true
}

func (v EngagementValue) Type(ctx context.Context) attr.Type {
	return EngagementType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v EngagementValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"dwell_tag_names": basetypes.ObjectType{
			AttrTypes: DwellTagNamesValue{}.AttributeTypes(ctx),
		},
		"dwell_tags": basetypes.ObjectType{
			AttrTypes: DwellTagsValue{}.AttributeTypes(ctx),
		},
		"hours": basetypes.ObjectType{
			AttrTypes: HoursValue{}.AttributeTypes(ctx),
		},
		"max_dwell": basetypes.Int64Type{},
		"min_dwell": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = DwellTagNamesType{}

type DwellTagNamesType struct {
	basetypes.ObjectType
}

func (t DwellTagNamesType) Equal(o attr.Type) bool {
	other, ok := o.(DwellTagNamesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t DwellTagNamesType) String() string {
	return "DwellTagNamesType"
}

func (t DwellTagNamesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	bounceAttribute, ok := attributes["bounce"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bounce is missing from object`)

		return nil, diags
	}

	bounceVal, ok := bounceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bounce expected to be basetypes.StringValue, was: %T`, bounceAttribute))
	}

	engagedAttribute, ok := attributes["engaged"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`engaged is missing from object`)

		return nil, diags
	}

	engagedVal, ok := engagedAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`engaged expected to be basetypes.StringValue, was: %T`, engagedAttribute))
	}

	passerbyAttribute, ok := attributes["passerby"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`passerby is missing from object`)

		return nil, diags
	}

	passerbyVal, ok := passerbyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`passerby expected to be basetypes.StringValue, was: %T`, passerbyAttribute))
	}

	stationedAttribute, ok := attributes["stationed"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`stationed is missing from object`)

		return nil, diags
	}

	stationedVal, ok := stationedAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`stationed expected to be basetypes.StringValue, was: %T`, stationedAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return DwellTagNamesValue{
		Bounce:    bounceVal,
		Engaged:   engagedVal,
		Passerby:  passerbyVal,
		Stationed: stationedVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewDwellTagNamesValueNull() DwellTagNamesValue {
	return DwellTagNamesValue{
		state: attr.ValueStateNull,
	}
}

func NewDwellTagNamesValueUnknown() DwellTagNamesValue {
	return DwellTagNamesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewDwellTagNamesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (DwellTagNamesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing DwellTagNamesValue Attribute Value",
				"While creating a DwellTagNamesValue value, a missing attribute value was detected. "+
					"A DwellTagNamesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DwellTagNamesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid DwellTagNamesValue Attribute Type",
				"While creating a DwellTagNamesValue value, an invalid attribute value was detected. "+
					"A DwellTagNamesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DwellTagNamesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("DwellTagNamesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra DwellTagNamesValue Attribute Value",
				"While creating a DwellTagNamesValue value, an extra attribute value was detected. "+
					"A DwellTagNamesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra DwellTagNamesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewDwellTagNamesValueUnknown(), diags
	}

	bounceAttribute, ok := attributes["bounce"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bounce is missing from object`)

		return NewDwellTagNamesValueUnknown(), diags
	}

	bounceVal, ok := bounceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bounce expected to be basetypes.StringValue, was: %T`, bounceAttribute))
	}

	engagedAttribute, ok := attributes["engaged"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`engaged is missing from object`)

		return NewDwellTagNamesValueUnknown(), diags
	}

	engagedVal, ok := engagedAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`engaged expected to be basetypes.StringValue, was: %T`, engagedAttribute))
	}

	passerbyAttribute, ok := attributes["passerby"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`passerby is missing from object`)

		return NewDwellTagNamesValueUnknown(), diags
	}

	passerbyVal, ok := passerbyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`passerby expected to be basetypes.StringValue, was: %T`, passerbyAttribute))
	}

	stationedAttribute, ok := attributes["stationed"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`stationed is missing from object`)

		return NewDwellTagNamesValueUnknown(), diags
	}

	stationedVal, ok := stationedAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`stationed expected to be basetypes.StringValue, was: %T`, stationedAttribute))
	}

	if diags.HasError() {
		return NewDwellTagNamesValueUnknown(), diags
	}

	return DwellTagNamesValue{
		Bounce:    bounceVal,
		Engaged:   engagedVal,
		Passerby:  passerbyVal,
		Stationed: stationedVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewDwellTagNamesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) DwellTagNamesValue {
	object, diags := NewDwellTagNamesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewDwellTagNamesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t DwellTagNamesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewDwellTagNamesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewDwellTagNamesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewDwellTagNamesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewDwellTagNamesValueMust(DwellTagNamesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t DwellTagNamesType) ValueType(ctx context.Context) attr.Value {
	return DwellTagNamesValue{}
}

var _ basetypes.ObjectValuable = DwellTagNamesValue{}

type DwellTagNamesValue struct {
	Bounce    basetypes.StringValue `tfsdk:"bounce"`
	Engaged   basetypes.StringValue `tfsdk:"engaged"`
	Passerby  basetypes.StringValue `tfsdk:"passerby"`
	Stationed basetypes.StringValue `tfsdk:"stationed"`
	state     attr.ValueState
}

func (v DwellTagNamesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["bounce"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["engaged"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["passerby"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["stationed"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Bounce.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bounce"] = val

		val, err = v.Engaged.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["engaged"] = val

		val, err = v.Passerby.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["passerby"] = val

		val, err = v.Stationed.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["stationed"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v DwellTagNamesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v DwellTagNamesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v DwellTagNamesValue) String() string {
	return "DwellTagNamesValue"
}

func (v DwellTagNamesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"bounce":    basetypes.StringType{},
		"engaged":   basetypes.StringType{},
		"passerby":  basetypes.StringType{},
		"stationed": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"bounce":    v.Bounce,
			"engaged":   v.Engaged,
			"passerby":  v.Passerby,
			"stationed": v.Stationed,
		})

	return objVal, diags
}

func (v DwellTagNamesValue) Equal(o attr.Value) bool {
	other, ok := o.(DwellTagNamesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Bounce.Equal(other.Bounce) {
		return false
	}

	if !v.Engaged.Equal(other.Engaged) {
		return false
	}

	if !v.Passerby.Equal(other.Passerby) {
		return false
	}

	if !v.Stationed.Equal(other.Stationed) {
		return false
	}

	return true
}

func (v DwellTagNamesValue) Type(ctx context.Context) attr.Type {
	return DwellTagNamesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v DwellTagNamesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"bounce":    basetypes.StringType{},
		"engaged":   basetypes.StringType{},
		"passerby":  basetypes.StringType{},
		"stationed": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = DwellTagsType{}

type DwellTagsType struct {
	basetypes.ObjectType
}

func (t DwellTagsType) Equal(o attr.Type) bool {
	other, ok := o.(DwellTagsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t DwellTagsType) String() string {
	return "DwellTagsType"
}

func (t DwellTagsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	bounceAttribute, ok := attributes["bounce"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bounce is missing from object`)

		return nil, diags
	}

	bounceVal, ok := bounceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bounce expected to be basetypes.StringValue, was: %T`, bounceAttribute))
	}

	engagedAttribute, ok := attributes["engaged"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`engaged is missing from object`)

		return nil, diags
	}

	engagedVal, ok := engagedAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`engaged expected to be basetypes.StringValue, was: %T`, engagedAttribute))
	}

	passerbyAttribute, ok := attributes["passerby"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`passerby is missing from object`)

		return nil, diags
	}

	passerbyVal, ok := passerbyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`passerby expected to be basetypes.StringValue, was: %T`, passerbyAttribute))
	}

	stationedAttribute, ok := attributes["stationed"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`stationed is missing from object`)

		return nil, diags
	}

	stationedVal, ok := stationedAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`stationed expected to be basetypes.StringValue, was: %T`, stationedAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return DwellTagsValue{
		Bounce:    bounceVal,
		Engaged:   engagedVal,
		Passerby:  passerbyVal,
		Stationed: stationedVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewDwellTagsValueNull() DwellTagsValue {
	return DwellTagsValue{
		state: attr.ValueStateNull,
	}
}

func NewDwellTagsValueUnknown() DwellTagsValue {
	return DwellTagsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewDwellTagsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (DwellTagsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing DwellTagsValue Attribute Value",
				"While creating a DwellTagsValue value, a missing attribute value was detected. "+
					"A DwellTagsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DwellTagsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid DwellTagsValue Attribute Type",
				"While creating a DwellTagsValue value, an invalid attribute value was detected. "+
					"A DwellTagsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DwellTagsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("DwellTagsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra DwellTagsValue Attribute Value",
				"While creating a DwellTagsValue value, an extra attribute value was detected. "+
					"A DwellTagsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra DwellTagsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewDwellTagsValueUnknown(), diags
	}

	bounceAttribute, ok := attributes["bounce"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bounce is missing from object`)

		return NewDwellTagsValueUnknown(), diags
	}

	bounceVal, ok := bounceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bounce expected to be basetypes.StringValue, was: %T`, bounceAttribute))
	}

	engagedAttribute, ok := attributes["engaged"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`engaged is missing from object`)

		return NewDwellTagsValueUnknown(), diags
	}

	engagedVal, ok := engagedAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`engaged expected to be basetypes.StringValue, was: %T`, engagedAttribute))
	}

	passerbyAttribute, ok := attributes["passerby"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`passerby is missing from object`)

		return NewDwellTagsValueUnknown(), diags
	}

	passerbyVal, ok := passerbyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`passerby expected to be basetypes.StringValue, was: %T`, passerbyAttribute))
	}

	stationedAttribute, ok := attributes["stationed"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`stationed is missing from object`)

		return NewDwellTagsValueUnknown(), diags
	}

	stationedVal, ok := stationedAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`stationed expected to be basetypes.StringValue, was: %T`, stationedAttribute))
	}

	if diags.HasError() {
		return NewDwellTagsValueUnknown(), diags
	}

	return DwellTagsValue{
		Bounce:    bounceVal,
		Engaged:   engagedVal,
		Passerby:  passerbyVal,
		Stationed: stationedVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewDwellTagsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) DwellTagsValue {
	object, diags := NewDwellTagsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewDwellTagsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t DwellTagsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewDwellTagsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewDwellTagsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewDwellTagsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewDwellTagsValueMust(DwellTagsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t DwellTagsType) ValueType(ctx context.Context) attr.Value {
	return DwellTagsValue{}
}

var _ basetypes.ObjectValuable = DwellTagsValue{}

type DwellTagsValue struct {
	Bounce    basetypes.StringValue `tfsdk:"bounce"`
	Engaged   basetypes.StringValue `tfsdk:"engaged"`
	Passerby  basetypes.StringValue `tfsdk:"passerby"`
	Stationed basetypes.StringValue `tfsdk:"stationed"`
	state     attr.ValueState
}

func (v DwellTagsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["bounce"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["engaged"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["passerby"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["stationed"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Bounce.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bounce"] = val

		val, err = v.Engaged.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["engaged"] = val

		val, err = v.Passerby.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["passerby"] = val

		val, err = v.Stationed.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["stationed"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v DwellTagsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v DwellTagsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v DwellTagsValue) String() string {
	return "DwellTagsValue"
}

func (v DwellTagsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"bounce":    basetypes.StringType{},
		"engaged":   basetypes.StringType{},
		"passerby":  basetypes.StringType{},
		"stationed": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"bounce":    v.Bounce,
			"engaged":   v.Engaged,
			"passerby":  v.Passerby,
			"stationed": v.Stationed,
		})

	return objVal, diags
}

func (v DwellTagsValue) Equal(o attr.Value) bool {
	other, ok := o.(DwellTagsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Bounce.Equal(other.Bounce) {
		return false
	}

	if !v.Engaged.Equal(other.Engaged) {
		return false
	}

	if !v.Passerby.Equal(other.Passerby) {
		return false
	}

	if !v.Stationed.Equal(other.Stationed) {
		return false
	}

	return true
}

func (v DwellTagsValue) Type(ctx context.Context) attr.Type {
	return DwellTagsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v DwellTagsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"bounce":    basetypes.StringType{},
		"engaged":   basetypes.StringType{},
		"passerby":  basetypes.StringType{},
		"stationed": basetypes.StringType{},
	}
}






















var _ basetypes.ObjectTypable = LedType{}

type LedType struct {
	basetypes.ObjectType
}

func (t LedType) Equal(o attr.Type) bool {
	other, ok := o.(LedType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t LedType) String() string {
	return "LedType"
}

func (t LedType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	brightnessAttribute, ok := attributes["brightness"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`brightness is missing from object`)

		return nil, diags
	}

	brightnessVal, ok := brightnessAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`brightness expected to be basetypes.Int64Value, was: %T`, brightnessAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return LedValue{
		Brightness: brightnessVal,
		Enabled:    enabledVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewLedValueNull() LedValue {
	return LedValue{
		state: attr.ValueStateNull,
	}
}

func NewLedValueUnknown() LedValue {
	return LedValue{
		state: attr.ValueStateUnknown,
	}
}

func NewLedValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (LedValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing LedValue Attribute Value",
				"While creating a LedValue value, a missing attribute value was detected. "+
					"A LedValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("LedValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid LedValue Attribute Type",
				"While creating a LedValue value, an invalid attribute value was detected. "+
					"A LedValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("LedValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("LedValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra LedValue Attribute Value",
				"While creating a LedValue value, an extra attribute value was detected. "+
					"A LedValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra LedValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewLedValueUnknown(), diags
	}

	brightnessAttribute, ok := attributes["brightness"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`brightness is missing from object`)

		return NewLedValueUnknown(), diags
	}

	brightnessVal, ok := brightnessAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`brightness expected to be basetypes.Int64Value, was: %T`, brightnessAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewLedValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	if diags.HasError() {
		return NewLedValueUnknown(), diags
	}

	return LedValue{
		Brightness: brightnessVal,
		Enabled:    enabledVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewLedValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) LedValue {
	object, diags := NewLedValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewLedValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t LedType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewLedValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewLedValueUnknown(), nil
	}

	if in.IsNull() {
		return NewLedValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewLedValueMust(LedValue{}.AttributeTypes(ctx), attributes), nil
}

func (t LedType) ValueType(ctx context.Context) attr.Value {
	return LedValue{}
}

var _ basetypes.ObjectValuable = LedValue{}

type LedValue struct {
	Brightness basetypes.Int64Value `tfsdk:"brightness"`
	Enabled    basetypes.BoolValue  `tfsdk:"enabled"`
	state      attr.ValueState
}

func (v LedValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["brightness"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Brightness.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["brightness"] = val

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v LedValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v LedValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v LedValue) String() string {
	return "LedValue"
}

func (v LedValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"brightness": basetypes.Int64Type{},
		"enabled":    basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"brightness": v.Brightness,
			"enabled":    v.Enabled,
		})

	return objVal, diags
}

func (v LedValue) Equal(o attr.Value) bool {
	other, ok := o.(LedValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Brightness.Equal(other.Brightness) {
		return false
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	return true
}

func (v LedValue) Type(ctx context.Context) attr.Type {
	return LedType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v LedValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"brightness": basetypes.Int64Type{},
		"enabled":    basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = OccupancyType{}

type OccupancyType struct {
	basetypes.ObjectType
}

func (t OccupancyType) Equal(o attr.Type) bool {
	other, ok := o.(OccupancyType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t OccupancyType) String() string {
	return "OccupancyType"
}

func (t OccupancyType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	assetsEnabledAttribute, ok := attributes["assets_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`assets_enabled is missing from object`)

		return nil, diags
	}

	assetsEnabledVal, ok := assetsEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`assets_enabled expected to be basetypes.BoolValue, was: %T`, assetsEnabledAttribute))
	}

	clientsEnabledAttribute, ok := attributes["clients_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`clients_enabled is missing from object`)

		return nil, diags
	}

	clientsEnabledVal, ok := clientsEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`clients_enabled expected to be basetypes.BoolValue, was: %T`, clientsEnabledAttribute))
	}

	minDurationAttribute, ok := attributes["min_duration"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`min_duration is missing from object`)

		return nil, diags
	}

	minDurationVal, ok := minDurationAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`min_duration expected to be basetypes.Int64Value, was: %T`, minDurationAttribute))
	}

	sdkclientsEnabledAttribute, ok := attributes["sdkclients_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sdkclients_enabled is missing from object`)

		return nil, diags
	}

	sdkclientsEnabledVal, ok := sdkclientsEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sdkclients_enabled expected to be basetypes.BoolValue, was: %T`, sdkclientsEnabledAttribute))
	}

	unconnectedClientsEnabledAttribute, ok := attributes["unconnected_clients_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`unconnected_clients_enabled is missing from object`)

		return nil, diags
	}

	unconnectedClientsEnabledVal, ok := unconnectedClientsEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`unconnected_clients_enabled expected to be basetypes.BoolValue, was: %T`, unconnectedClientsEnabledAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return OccupancyValue{
		AssetsEnabled:             assetsEnabledVal,
		ClientsEnabled:            clientsEnabledVal,
		MinDuration:               minDurationVal,
		SdkclientsEnabled:         sdkclientsEnabledVal,
		UnconnectedClientsEnabled: unconnectedClientsEnabledVal,
		state:                     attr.ValueStateKnown,
	}, diags
}

func NewOccupancyValueNull() OccupancyValue {
	return OccupancyValue{
		state: attr.ValueStateNull,
	}
}

func NewOccupancyValueUnknown() OccupancyValue {
	return OccupancyValue{
		state: attr.ValueStateUnknown,
	}
}

func NewOccupancyValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (OccupancyValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing OccupancyValue Attribute Value",
				"While creating a OccupancyValue value, a missing attribute value was detected. "+
					"A OccupancyValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OccupancyValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid OccupancyValue Attribute Type",
				"While creating a OccupancyValue value, an invalid attribute value was detected. "+
					"A OccupancyValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OccupancyValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("OccupancyValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra OccupancyValue Attribute Value",
				"While creating a OccupancyValue value, an extra attribute value was detected. "+
					"A OccupancyValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra OccupancyValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewOccupancyValueUnknown(), diags
	}

	assetsEnabledAttribute, ok := attributes["assets_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`assets_enabled is missing from object`)

		return NewOccupancyValueUnknown(), diags
	}

	assetsEnabledVal, ok := assetsEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`assets_enabled expected to be basetypes.BoolValue, was: %T`, assetsEnabledAttribute))
	}

	clientsEnabledAttribute, ok := attributes["clients_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`clients_enabled is missing from object`)

		return NewOccupancyValueUnknown(), diags
	}

	clientsEnabledVal, ok := clientsEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`clients_enabled expected to be basetypes.BoolValue, was: %T`, clientsEnabledAttribute))
	}

	minDurationAttribute, ok := attributes["min_duration"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`min_duration is missing from object`)

		return NewOccupancyValueUnknown(), diags
	}

	minDurationVal, ok := minDurationAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`min_duration expected to be basetypes.Int64Value, was: %T`, minDurationAttribute))
	}

	sdkclientsEnabledAttribute, ok := attributes["sdkclients_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sdkclients_enabled is missing from object`)

		return NewOccupancyValueUnknown(), diags
	}

	sdkclientsEnabledVal, ok := sdkclientsEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sdkclients_enabled expected to be basetypes.BoolValue, was: %T`, sdkclientsEnabledAttribute))
	}

	unconnectedClientsEnabledAttribute, ok := attributes["unconnected_clients_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`unconnected_clients_enabled is missing from object`)

		return NewOccupancyValueUnknown(), diags
	}

	unconnectedClientsEnabledVal, ok := unconnectedClientsEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`unconnected_clients_enabled expected to be basetypes.BoolValue, was: %T`, unconnectedClientsEnabledAttribute))
	}

	if diags.HasError() {
		return NewOccupancyValueUnknown(), diags
	}

	return OccupancyValue{
		AssetsEnabled:             assetsEnabledVal,
		ClientsEnabled:            clientsEnabledVal,
		MinDuration:               minDurationVal,
		SdkclientsEnabled:         sdkclientsEnabledVal,
		UnconnectedClientsEnabled: unconnectedClientsEnabledVal,
		state:                     attr.ValueStateKnown,
	}, diags
}

func NewOccupancyValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) OccupancyValue {
	object, diags := NewOccupancyValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewOccupancyValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t OccupancyType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewOccupancyValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewOccupancyValueUnknown(), nil
	}

	if in.IsNull() {
		return NewOccupancyValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewOccupancyValueMust(OccupancyValue{}.AttributeTypes(ctx), attributes), nil
}

func (t OccupancyType) ValueType(ctx context.Context) attr.Value {
	return OccupancyValue{}
}

var _ basetypes.ObjectValuable = OccupancyValue{}

type OccupancyValue struct {
	AssetsEnabled             basetypes.BoolValue  `tfsdk:"assets_enabled"`
	ClientsEnabled            basetypes.BoolValue  `tfsdk:"clients_enabled"`
	MinDuration               basetypes.Int64Value `tfsdk:"min_duration"`
	SdkclientsEnabled         basetypes.BoolValue  `tfsdk:"sdkclients_enabled"`
	UnconnectedClientsEnabled basetypes.BoolValue  `tfsdk:"unconnected_clients_enabled"`
	state                     attr.ValueState
}

func (v OccupancyValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["assets_enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["clients_enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["min_duration"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["sdkclients_enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["unconnected_clients_enabled"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.AssetsEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["assets_enabled"] = val

		val, err = v.ClientsEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["clients_enabled"] = val

		val, err = v.MinDuration.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["min_duration"] = val

		val, err = v.SdkclientsEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["sdkclients_enabled"] = val

		val, err = v.UnconnectedClientsEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["unconnected_clients_enabled"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v OccupancyValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v OccupancyValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v OccupancyValue) String() string {
	return "OccupancyValue"
}

func (v OccupancyValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"assets_enabled":              basetypes.BoolType{},
		"clients_enabled":             basetypes.BoolType{},
		"min_duration":                basetypes.Int64Type{},
		"sdkclients_enabled":          basetypes.BoolType{},
		"unconnected_clients_enabled": basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"assets_enabled":              v.AssetsEnabled,
			"clients_enabled":             v.ClientsEnabled,
			"min_duration":                v.MinDuration,
			"sdkclients_enabled":          v.SdkclientsEnabled,
			"unconnected_clients_enabled": v.UnconnectedClientsEnabled,
		})

	return objVal, diags
}

func (v OccupancyValue) Equal(o attr.Value) bool {
	other, ok := o.(OccupancyValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AssetsEnabled.Equal(other.AssetsEnabled) {
		return false
	}

	if !v.ClientsEnabled.Equal(other.ClientsEnabled) {
		return false
	}

	if !v.MinDuration.Equal(other.MinDuration) {
		return false
	}

	if !v.SdkclientsEnabled.Equal(other.SdkclientsEnabled) {
		return false
	}

	if !v.UnconnectedClientsEnabled.Equal(other.UnconnectedClientsEnabled) {
		return false
	}

	return true
}

func (v OccupancyValue) Type(ctx context.Context) attr.Type {
	return OccupancyType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v OccupancyValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"assets_enabled":              basetypes.BoolType{},
		"clients_enabled":             basetypes.BoolType{},
		"min_duration":                basetypes.Int64Type{},
		"sdkclients_enabled":          basetypes.BoolType{},
		"unconnected_clients_enabled": basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = ProxyType{}

type ProxyType struct {
	basetypes.ObjectType
}

func (t ProxyType) Equal(o attr.Type) bool {
	other, ok := o.(ProxyType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ProxyType) String() string {
	return "ProxyType"
}

func (t ProxyType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return nil, diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ProxyValue{
		Url:   urlVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewProxyValueNull() ProxyValue {
	return ProxyValue{
		state: attr.ValueStateNull,
	}
}

func NewProxyValueUnknown() ProxyValue {
	return ProxyValue{
		state: attr.ValueStateUnknown,
	}
}

func NewProxyValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ProxyValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ProxyValue Attribute Value",
				"While creating a ProxyValue value, a missing attribute value was detected. "+
					"A ProxyValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ProxyValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ProxyValue Attribute Type",
				"While creating a ProxyValue value, an invalid attribute value was detected. "+
					"A ProxyValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ProxyValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ProxyValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ProxyValue Attribute Value",
				"While creating a ProxyValue value, an extra attribute value was detected. "+
					"A ProxyValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ProxyValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewProxyValueUnknown(), diags
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return NewProxyValueUnknown(), diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	if diags.HasError() {
		return NewProxyValueUnknown(), diags
	}

	return ProxyValue{
		Url:   urlVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewProxyValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ProxyValue {
	object, diags := NewProxyValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewProxyValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ProxyType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewProxyValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewProxyValueUnknown(), nil
	}

	if in.IsNull() {
		return NewProxyValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewProxyValueMust(ProxyValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ProxyType) ValueType(ctx context.Context) attr.Value {
	return ProxyValue{}
}

var _ basetypes.ObjectValuable = ProxyValue{}

type ProxyValue struct {
	Url   basetypes.StringValue `tfsdk:"url"`
	state attr.ValueState
}

func (v ProxyValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["url"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Url.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["url"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ProxyValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ProxyValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ProxyValue) String() string {
	return "ProxyValue"
}

func (v ProxyValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"url": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"url": v.Url,
		})

	return objVal, diags
}

func (v ProxyValue) Equal(o attr.Value) bool {
	other, ok := o.(ProxyValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Url.Equal(other.Url) {
		return false
	}

	return true
}

func (v ProxyValue) Type(ctx context.Context) attr.Type {
	return ProxyType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ProxyValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"url": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = RogueType{}

type RogueType struct {
	basetypes.ObjectType
}

func (t RogueType) Equal(o attr.Type) bool {
	other, ok := o.(RogueType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t RogueType) String() string {
	return "RogueType"
}

func (t RogueType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	honeypotEnabledAttribute, ok := attributes["honeypot_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`honeypot_enabled is missing from object`)

		return nil, diags
	}

	honeypotEnabledVal, ok := honeypotEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`honeypot_enabled expected to be basetypes.BoolValue, was: %T`, honeypotEnabledAttribute))
	}

	minDurationAttribute, ok := attributes["min_duration"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`min_duration is missing from object`)

		return nil, diags
	}

	minDurationVal, ok := minDurationAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`min_duration expected to be basetypes.Int64Value, was: %T`, minDurationAttribute))
	}

	minRssiAttribute, ok := attributes["min_rssi"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`min_rssi is missing from object`)

		return nil, diags
	}

	minRssiVal, ok := minRssiAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`min_rssi expected to be basetypes.Int64Value, was: %T`, minRssiAttribute))
	}

	whitelistedBssidsAttribute, ok := attributes["whitelisted_bssids"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`whitelisted_bssids is missing from object`)

		return nil, diags
	}

	whitelistedBssidsVal, ok := whitelistedBssidsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`whitelisted_bssids expected to be basetypes.ListValue, was: %T`, whitelistedBssidsAttribute))
	}

	whitelistedSsidsAttribute, ok := attributes["whitelisted_ssids"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`whitelisted_ssids is missing from object`)

		return nil, diags
	}

	whitelistedSsidsVal, ok := whitelistedSsidsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`whitelisted_ssids expected to be basetypes.ListValue, was: %T`, whitelistedSsidsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return RogueValue{
		Enabled:           enabledVal,
		HoneypotEnabled:   honeypotEnabledVal,
		MinDuration:       minDurationVal,
		MinRssi:           minRssiVal,
		WhitelistedBssids: whitelistedBssidsVal,
		WhitelistedSsids:  whitelistedSsidsVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewRogueValueNull() RogueValue {
	return RogueValue{
		state: attr.ValueStateNull,
	}
}

func NewRogueValueUnknown() RogueValue {
	return RogueValue{
		state: attr.ValueStateUnknown,
	}
}

func NewRogueValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (RogueValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing RogueValue Attribute Value",
				"While creating a RogueValue value, a missing attribute value was detected. "+
					"A RogueValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RogueValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid RogueValue Attribute Type",
				"While creating a RogueValue value, an invalid attribute value was detected. "+
					"A RogueValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RogueValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("RogueValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra RogueValue Attribute Value",
				"While creating a RogueValue value, an extra attribute value was detected. "+
					"A RogueValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra RogueValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewRogueValueUnknown(), diags
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewRogueValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	honeypotEnabledAttribute, ok := attributes["honeypot_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`honeypot_enabled is missing from object`)

		return NewRogueValueUnknown(), diags
	}

	honeypotEnabledVal, ok := honeypotEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`honeypot_enabled expected to be basetypes.BoolValue, was: %T`, honeypotEnabledAttribute))
	}

	minDurationAttribute, ok := attributes["min_duration"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`min_duration is missing from object`)

		return NewRogueValueUnknown(), diags
	}

	minDurationVal, ok := minDurationAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`min_duration expected to be basetypes.Int64Value, was: %T`, minDurationAttribute))
	}

	minRssiAttribute, ok := attributes["min_rssi"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`min_rssi is missing from object`)

		return NewRogueValueUnknown(), diags
	}

	minRssiVal, ok := minRssiAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`min_rssi expected to be basetypes.Int64Value, was: %T`, minRssiAttribute))
	}

	whitelistedBssidsAttribute, ok := attributes["whitelisted_bssids"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`whitelisted_bssids is missing from object`)

		return NewRogueValueUnknown(), diags
	}

	whitelistedBssidsVal, ok := whitelistedBssidsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`whitelisted_bssids expected to be basetypes.ListValue, was: %T`, whitelistedBssidsAttribute))
	}

	whitelistedSsidsAttribute, ok := attributes["whitelisted_ssids"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`whitelisted_ssids is missing from object`)

		return NewRogueValueUnknown(), diags
	}

	whitelistedSsidsVal, ok := whitelistedSsidsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`whitelisted_ssids expected to be basetypes.ListValue, was: %T`, whitelistedSsidsAttribute))
	}

	if diags.HasError() {
		return NewRogueValueUnknown(), diags
	}

	return RogueValue{
		Enabled:           enabledVal,
		HoneypotEnabled:   honeypotEnabledVal,
		MinDuration:       minDurationVal,
		MinRssi:           minRssiVal,
		WhitelistedBssids: whitelistedBssidsVal,
		WhitelistedSsids:  whitelistedSsidsVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewRogueValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) RogueValue {
	object, diags := NewRogueValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewRogueValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t RogueType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewRogueValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewRogueValueUnknown(), nil
	}

	if in.IsNull() {
		return NewRogueValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewRogueValueMust(RogueValue{}.AttributeTypes(ctx), attributes), nil
}

func (t RogueType) ValueType(ctx context.Context) attr.Value {
	return RogueValue{}
}

var _ basetypes.ObjectValuable = RogueValue{}

type RogueValue struct {
	Enabled           basetypes.BoolValue  `tfsdk:"enabled"`
	HoneypotEnabled   basetypes.BoolValue  `tfsdk:"honeypot_enabled"`
	MinDuration       basetypes.Int64Value `tfsdk:"min_duration"`
	MinRssi           basetypes.Int64Value `tfsdk:"min_rssi"`
	WhitelistedBssids basetypes.ListValue  `tfsdk:"whitelisted_bssids"`
	WhitelistedSsids  basetypes.ListValue  `tfsdk:"whitelisted_ssids"`
	state             attr.ValueState
}

func (v RogueValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 6)

	var val tftypes.Value
	var err error

	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["honeypot_enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["min_duration"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["min_rssi"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["whitelisted_bssids"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["whitelisted_ssids"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 6)

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.HoneypotEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["honeypot_enabled"] = val

		val, err = v.MinDuration.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["min_duration"] = val

		val, err = v.MinRssi.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["min_rssi"] = val

		val, err = v.WhitelistedBssids.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["whitelisted_bssids"] = val

		val, err = v.WhitelistedSsids.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["whitelisted_ssids"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v RogueValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v RogueValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v RogueValue) String() string {
	return "RogueValue"
}

func (v RogueValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	whitelistedBssidsVal, d := types.ListValue(types.StringType, v.WhitelistedBssids.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"enabled":          basetypes.BoolType{},
			"honeypot_enabled": basetypes.BoolType{},
			"min_duration":     basetypes.Int64Type{},
			"min_rssi":         basetypes.Int64Type{},
			"whitelisted_bssids": basetypes.ListType{
				ElemType: types.StringType,
			},
			"whitelisted_ssids": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	whitelistedSsidsVal, d := types.ListValue(types.StringType, v.WhitelistedSsids.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"enabled":          basetypes.BoolType{},
			"honeypot_enabled": basetypes.BoolType{},
			"min_duration":     basetypes.Int64Type{},
			"min_rssi":         basetypes.Int64Type{},
			"whitelisted_bssids": basetypes.ListType{
				ElemType: types.StringType,
			},
			"whitelisted_ssids": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"enabled":          basetypes.BoolType{},
		"honeypot_enabled": basetypes.BoolType{},
		"min_duration":     basetypes.Int64Type{},
		"min_rssi":         basetypes.Int64Type{},
		"whitelisted_bssids": basetypes.ListType{
			ElemType: types.StringType,
		},
		"whitelisted_ssids": basetypes.ListType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"enabled":            v.Enabled,
			"honeypot_enabled":   v.HoneypotEnabled,
			"min_duration":       v.MinDuration,
			"min_rssi":           v.MinRssi,
			"whitelisted_bssids": whitelistedBssidsVal,
			"whitelisted_ssids":  whitelistedSsidsVal,
		})

	return objVal, diags
}

func (v RogueValue) Equal(o attr.Value) bool {
	other, ok := o.(RogueValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.HoneypotEnabled.Equal(other.HoneypotEnabled) {
		return false
	}

	if !v.MinDuration.Equal(other.MinDuration) {
		return false
	}

	if !v.MinRssi.Equal(other.MinRssi) {
		return false
	}

	if !v.WhitelistedBssids.Equal(other.WhitelistedBssids) {
		return false
	}

	if !v.WhitelistedSsids.Equal(other.WhitelistedSsids) {
		return false
	}

	return true
}

func (v RogueValue) Type(ctx context.Context) attr.Type {
	return RogueType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v RogueValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"enabled":          basetypes.BoolType{},
		"honeypot_enabled": basetypes.BoolType{},
		"min_duration":     basetypes.Int64Type{},
		"min_rssi":         basetypes.Int64Type{},
		"whitelisted_bssids": basetypes.ListType{
			ElemType: types.StringType,
		},
		"whitelisted_ssids": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = SimpleAlertType{}

type SimpleAlertType struct {
	basetypes.ObjectType
}

func (t SimpleAlertType) Equal(o attr.Type) bool {
	other, ok := o.(SimpleAlertType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SimpleAlertType) String() string {
	return "SimpleAlertType"
}

func (t SimpleAlertType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	arpFailureAttribute, ok := attributes["arp_failure"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`arp_failure is missing from object`)

		return nil, diags
	}

	arpFailureVal, ok := arpFailureAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`arp_failure expected to be basetypes.ObjectValue, was: %T`, arpFailureAttribute))
	}

	dhcpFailureAttribute, ok := attributes["dhcp_failure"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dhcp_failure is missing from object`)

		return nil, diags
	}

	dhcpFailureVal, ok := dhcpFailureAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dhcp_failure expected to be basetypes.ObjectValue, was: %T`, dhcpFailureAttribute))
	}

	dnsFailureAttribute, ok := attributes["dns_failure"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dns_failure is missing from object`)

		return nil, diags
	}

	dnsFailureVal, ok := dnsFailureAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dns_failure expected to be basetypes.ObjectValue, was: %T`, dnsFailureAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SimpleAlertValue{
		ArpFailure:  arpFailureVal,
		DhcpFailure: dhcpFailureVal,
		DnsFailure:  dnsFailureVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewSimpleAlertValueNull() SimpleAlertValue {
	return SimpleAlertValue{
		state: attr.ValueStateNull,
	}
}

func NewSimpleAlertValueUnknown() SimpleAlertValue {
	return SimpleAlertValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSimpleAlertValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SimpleAlertValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SimpleAlertValue Attribute Value",
				"While creating a SimpleAlertValue value, a missing attribute value was detected. "+
					"A SimpleAlertValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SimpleAlertValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SimpleAlertValue Attribute Type",
				"While creating a SimpleAlertValue value, an invalid attribute value was detected. "+
					"A SimpleAlertValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SimpleAlertValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SimpleAlertValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SimpleAlertValue Attribute Value",
				"While creating a SimpleAlertValue value, an extra attribute value was detected. "+
					"A SimpleAlertValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SimpleAlertValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSimpleAlertValueUnknown(), diags
	}

	arpFailureAttribute, ok := attributes["arp_failure"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`arp_failure is missing from object`)

		return NewSimpleAlertValueUnknown(), diags
	}

	arpFailureVal, ok := arpFailureAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`arp_failure expected to be basetypes.ObjectValue, was: %T`, arpFailureAttribute))
	}

	dhcpFailureAttribute, ok := attributes["dhcp_failure"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dhcp_failure is missing from object`)

		return NewSimpleAlertValueUnknown(), diags
	}

	dhcpFailureVal, ok := dhcpFailureAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dhcp_failure expected to be basetypes.ObjectValue, was: %T`, dhcpFailureAttribute))
	}

	dnsFailureAttribute, ok := attributes["dns_failure"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dns_failure is missing from object`)

		return NewSimpleAlertValueUnknown(), diags
	}

	dnsFailureVal, ok := dnsFailureAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dns_failure expected to be basetypes.ObjectValue, was: %T`, dnsFailureAttribute))
	}

	if diags.HasError() {
		return NewSimpleAlertValueUnknown(), diags
	}

	return SimpleAlertValue{
		ArpFailure:  arpFailureVal,
		DhcpFailure: dhcpFailureVal,
		DnsFailure:  dnsFailureVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewSimpleAlertValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SimpleAlertValue {
	object, diags := NewSimpleAlertValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSimpleAlertValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SimpleAlertType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSimpleAlertValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSimpleAlertValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSimpleAlertValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSimpleAlertValueMust(SimpleAlertValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SimpleAlertType) ValueType(ctx context.Context) attr.Value {
	return SimpleAlertValue{}
}

var _ basetypes.ObjectValuable = SimpleAlertValue{}

type SimpleAlertValue struct {
	ArpFailure  basetypes.ObjectValue `tfsdk:"arp_failure"`
	DhcpFailure basetypes.ObjectValue `tfsdk:"dhcp_failure"`
	DnsFailure  basetypes.ObjectValue `tfsdk:"dns_failure"`
	state       attr.ValueState
}

func (v SimpleAlertValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["arp_failure"] = basetypes.ObjectType{
		AttrTypes: ArpFailureValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["dhcp_failure"] = basetypes.ObjectType{
		AttrTypes: DhcpFailureValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["dns_failure"] = basetypes.ObjectType{
		AttrTypes: DnsFailureValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.ArpFailure.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["arp_failure"] = val

		val, err = v.DhcpFailure.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dhcp_failure"] = val

		val, err = v.DnsFailure.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dns_failure"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SimpleAlertValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SimpleAlertValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SimpleAlertValue) String() string {
	return "SimpleAlertValue"
}

func (v SimpleAlertValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var arpFailure basetypes.ObjectValue

	if v.ArpFailure.IsNull() {
		arpFailure = types.ObjectNull(
			ArpFailureValue{}.AttributeTypes(ctx),
		)
	}

	if v.ArpFailure.IsUnknown() {
		arpFailure = types.ObjectUnknown(
			ArpFailureValue{}.AttributeTypes(ctx),
		)
	}

	if !v.ArpFailure.IsNull() && !v.ArpFailure.IsUnknown() {
		arpFailure = types.ObjectValueMust(
			ArpFailureValue{}.AttributeTypes(ctx),
			v.ArpFailure.Attributes(),
		)
	}

	var dhcpFailure basetypes.ObjectValue

	if v.DhcpFailure.IsNull() {
		dhcpFailure = types.ObjectNull(
			DhcpFailureValue{}.AttributeTypes(ctx),
		)
	}

	if v.DhcpFailure.IsUnknown() {
		dhcpFailure = types.ObjectUnknown(
			DhcpFailureValue{}.AttributeTypes(ctx),
		)
	}

	if !v.DhcpFailure.IsNull() && !v.DhcpFailure.IsUnknown() {
		dhcpFailure = types.ObjectValueMust(
			DhcpFailureValue{}.AttributeTypes(ctx),
			v.DhcpFailure.Attributes(),
		)
	}

	var dnsFailure basetypes.ObjectValue

	if v.DnsFailure.IsNull() {
		dnsFailure = types.ObjectNull(
			DnsFailureValue{}.AttributeTypes(ctx),
		)
	}

	if v.DnsFailure.IsUnknown() {
		dnsFailure = types.ObjectUnknown(
			DnsFailureValue{}.AttributeTypes(ctx),
		)
	}

	if !v.DnsFailure.IsNull() && !v.DnsFailure.IsUnknown() {
		dnsFailure = types.ObjectValueMust(
			DnsFailureValue{}.AttributeTypes(ctx),
			v.DnsFailure.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"arp_failure": basetypes.ObjectType{
			AttrTypes: ArpFailureValue{}.AttributeTypes(ctx),
		},
		"dhcp_failure": basetypes.ObjectType{
			AttrTypes: DhcpFailureValue{}.AttributeTypes(ctx),
		},
		"dns_failure": basetypes.ObjectType{
			AttrTypes: DnsFailureValue{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"arp_failure":  arpFailure,
			"dhcp_failure": dhcpFailure,
			"dns_failure":  dnsFailure,
		})

	return objVal, diags
}

func (v SimpleAlertValue) Equal(o attr.Value) bool {
	other, ok := o.(SimpleAlertValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.ArpFailure.Equal(other.ArpFailure) {
		return false
	}

	if !v.DhcpFailure.Equal(other.DhcpFailure) {
		return false
	}

	if !v.DnsFailure.Equal(other.DnsFailure) {
		return false
	}

	return true
}

func (v SimpleAlertValue) Type(ctx context.Context) attr.Type {
	return SimpleAlertType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SimpleAlertValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"arp_failure": basetypes.ObjectType{
			AttrTypes: ArpFailureValue{}.AttributeTypes(ctx),
		},
		"dhcp_failure": basetypes.ObjectType{
			AttrTypes: DhcpFailureValue{}.AttributeTypes(ctx),
		},
		"dns_failure": basetypes.ObjectType{
			AttrTypes: DnsFailureValue{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = ArpFailureType{}

type ArpFailureType struct {
	basetypes.ObjectType
}

func (t ArpFailureType) Equal(o attr.Type) bool {
	other, ok := o.(ArpFailureType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ArpFailureType) String() string {
	return "ArpFailureType"
}

func (t ArpFailureType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	clientCountAttribute, ok := attributes["client_count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`client_count is missing from object`)

		return nil, diags
	}

	clientCountVal, ok := clientCountAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`client_count expected to be basetypes.Int64Value, was: %T`, clientCountAttribute))
	}

	durationAttribute, ok := attributes["duration"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`duration is missing from object`)

		return nil, diags
	}

	durationVal, ok := durationAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`duration expected to be basetypes.Int64Value, was: %T`, durationAttribute))
	}

	incidentCountAttribute, ok := attributes["incident_count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`incident_count is missing from object`)

		return nil, diags
	}

	incidentCountVal, ok := incidentCountAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`incident_count expected to be basetypes.Int64Value, was: %T`, incidentCountAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ArpFailureValue{
		ClientCount:   clientCountVal,
		Duration:      durationVal,
		IncidentCount: incidentCountVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewArpFailureValueNull() ArpFailureValue {
	return ArpFailureValue{
		state: attr.ValueStateNull,
	}
}

func NewArpFailureValueUnknown() ArpFailureValue {
	return ArpFailureValue{
		state: attr.ValueStateUnknown,
	}
}

func NewArpFailureValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ArpFailureValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ArpFailureValue Attribute Value",
				"While creating a ArpFailureValue value, a missing attribute value was detected. "+
					"A ArpFailureValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ArpFailureValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ArpFailureValue Attribute Type",
				"While creating a ArpFailureValue value, an invalid attribute value was detected. "+
					"A ArpFailureValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ArpFailureValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ArpFailureValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ArpFailureValue Attribute Value",
				"While creating a ArpFailureValue value, an extra attribute value was detected. "+
					"A ArpFailureValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ArpFailureValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewArpFailureValueUnknown(), diags
	}

	clientCountAttribute, ok := attributes["client_count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`client_count is missing from object`)

		return NewArpFailureValueUnknown(), diags
	}

	clientCountVal, ok := clientCountAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`client_count expected to be basetypes.Int64Value, was: %T`, clientCountAttribute))
	}

	durationAttribute, ok := attributes["duration"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`duration is missing from object`)

		return NewArpFailureValueUnknown(), diags
	}

	durationVal, ok := durationAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`duration expected to be basetypes.Int64Value, was: %T`, durationAttribute))
	}

	incidentCountAttribute, ok := attributes["incident_count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`incident_count is missing from object`)

		return NewArpFailureValueUnknown(), diags
	}

	incidentCountVal, ok := incidentCountAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`incident_count expected to be basetypes.Int64Value, was: %T`, incidentCountAttribute))
	}

	if diags.HasError() {
		return NewArpFailureValueUnknown(), diags
	}

	return ArpFailureValue{
		ClientCount:   clientCountVal,
		Duration:      durationVal,
		IncidentCount: incidentCountVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewArpFailureValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ArpFailureValue {
	object, diags := NewArpFailureValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewArpFailureValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ArpFailureType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewArpFailureValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewArpFailureValueUnknown(), nil
	}

	if in.IsNull() {
		return NewArpFailureValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewArpFailureValueMust(ArpFailureValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ArpFailureType) ValueType(ctx context.Context) attr.Value {
	return ArpFailureValue{}
}

var _ basetypes.ObjectValuable = ArpFailureValue{}

type ArpFailureValue struct {
	ClientCount   basetypes.Int64Value `tfsdk:"client_count"`
	Duration      basetypes.Int64Value `tfsdk:"duration"`
	IncidentCount basetypes.Int64Value `tfsdk:"incident_count"`
	state         attr.ValueState
}

func (v ArpFailureValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["client_count"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["duration"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["incident_count"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.ClientCount.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["client_count"] = val

		val, err = v.Duration.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["duration"] = val

		val, err = v.IncidentCount.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["incident_count"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ArpFailureValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ArpFailureValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ArpFailureValue) String() string {
	return "ArpFailureValue"
}

func (v ArpFailureValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"client_count":   basetypes.Int64Type{},
		"duration":       basetypes.Int64Type{},
		"incident_count": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"client_count":   v.ClientCount,
			"duration":       v.Duration,
			"incident_count": v.IncidentCount,
		})

	return objVal, diags
}

func (v ArpFailureValue) Equal(o attr.Value) bool {
	other, ok := o.(ArpFailureValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.ClientCount.Equal(other.ClientCount) {
		return false
	}

	if !v.Duration.Equal(other.Duration) {
		return false
	}

	if !v.IncidentCount.Equal(other.IncidentCount) {
		return false
	}

	return true
}

func (v ArpFailureValue) Type(ctx context.Context) attr.Type {
	return ArpFailureType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ArpFailureValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"client_count":   basetypes.Int64Type{},
		"duration":       basetypes.Int64Type{},
		"incident_count": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = DhcpFailureType{}

type DhcpFailureType struct {
	basetypes.ObjectType
}

func (t DhcpFailureType) Equal(o attr.Type) bool {
	other, ok := o.(DhcpFailureType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t DhcpFailureType) String() string {
	return "DhcpFailureType"
}

func (t DhcpFailureType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	clientCountAttribute, ok := attributes["client_count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`client_count is missing from object`)

		return nil, diags
	}

	clientCountVal, ok := clientCountAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`client_count expected to be basetypes.Int64Value, was: %T`, clientCountAttribute))
	}

	durationAttribute, ok := attributes["duration"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`duration is missing from object`)

		return nil, diags
	}

	durationVal, ok := durationAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`duration expected to be basetypes.Int64Value, was: %T`, durationAttribute))
	}

	incidentCountAttribute, ok := attributes["incident_count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`incident_count is missing from object`)

		return nil, diags
	}

	incidentCountVal, ok := incidentCountAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`incident_count expected to be basetypes.Int64Value, was: %T`, incidentCountAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return DhcpFailureValue{
		ClientCount:   clientCountVal,
		Duration:      durationVal,
		IncidentCount: incidentCountVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewDhcpFailureValueNull() DhcpFailureValue {
	return DhcpFailureValue{
		state: attr.ValueStateNull,
	}
}

func NewDhcpFailureValueUnknown() DhcpFailureValue {
	return DhcpFailureValue{
		state: attr.ValueStateUnknown,
	}
}

func NewDhcpFailureValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (DhcpFailureValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing DhcpFailureValue Attribute Value",
				"While creating a DhcpFailureValue value, a missing attribute value was detected. "+
					"A DhcpFailureValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DhcpFailureValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid DhcpFailureValue Attribute Type",
				"While creating a DhcpFailureValue value, an invalid attribute value was detected. "+
					"A DhcpFailureValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DhcpFailureValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("DhcpFailureValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra DhcpFailureValue Attribute Value",
				"While creating a DhcpFailureValue value, an extra attribute value was detected. "+
					"A DhcpFailureValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra DhcpFailureValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewDhcpFailureValueUnknown(), diags
	}

	clientCountAttribute, ok := attributes["client_count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`client_count is missing from object`)

		return NewDhcpFailureValueUnknown(), diags
	}

	clientCountVal, ok := clientCountAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`client_count expected to be basetypes.Int64Value, was: %T`, clientCountAttribute))
	}

	durationAttribute, ok := attributes["duration"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`duration is missing from object`)

		return NewDhcpFailureValueUnknown(), diags
	}

	durationVal, ok := durationAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`duration expected to be basetypes.Int64Value, was: %T`, durationAttribute))
	}

	incidentCountAttribute, ok := attributes["incident_count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`incident_count is missing from object`)

		return NewDhcpFailureValueUnknown(), diags
	}

	incidentCountVal, ok := incidentCountAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`incident_count expected to be basetypes.Int64Value, was: %T`, incidentCountAttribute))
	}

	if diags.HasError() {
		return NewDhcpFailureValueUnknown(), diags
	}

	return DhcpFailureValue{
		ClientCount:   clientCountVal,
		Duration:      durationVal,
		IncidentCount: incidentCountVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewDhcpFailureValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) DhcpFailureValue {
	object, diags := NewDhcpFailureValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewDhcpFailureValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t DhcpFailureType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewDhcpFailureValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewDhcpFailureValueUnknown(), nil
	}

	if in.IsNull() {
		return NewDhcpFailureValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewDhcpFailureValueMust(DhcpFailureValue{}.AttributeTypes(ctx), attributes), nil
}

func (t DhcpFailureType) ValueType(ctx context.Context) attr.Value {
	return DhcpFailureValue{}
}

var _ basetypes.ObjectValuable = DhcpFailureValue{}

type DhcpFailureValue struct {
	ClientCount   basetypes.Int64Value `tfsdk:"client_count"`
	Duration      basetypes.Int64Value `tfsdk:"duration"`
	IncidentCount basetypes.Int64Value `tfsdk:"incident_count"`
	state         attr.ValueState
}

func (v DhcpFailureValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["client_count"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["duration"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["incident_count"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.ClientCount.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["client_count"] = val

		val, err = v.Duration.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["duration"] = val

		val, err = v.IncidentCount.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["incident_count"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v DhcpFailureValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v DhcpFailureValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v DhcpFailureValue) String() string {
	return "DhcpFailureValue"
}

func (v DhcpFailureValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"client_count":   basetypes.Int64Type{},
		"duration":       basetypes.Int64Type{},
		"incident_count": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"client_count":   v.ClientCount,
			"duration":       v.Duration,
			"incident_count": v.IncidentCount,
		})

	return objVal, diags
}

func (v DhcpFailureValue) Equal(o attr.Value) bool {
	other, ok := o.(DhcpFailureValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.ClientCount.Equal(other.ClientCount) {
		return false
	}

	if !v.Duration.Equal(other.Duration) {
		return false
	}

	if !v.IncidentCount.Equal(other.IncidentCount) {
		return false
	}

	return true
}

func (v DhcpFailureValue) Type(ctx context.Context) attr.Type {
	return DhcpFailureType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v DhcpFailureValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"client_count":   basetypes.Int64Type{},
		"duration":       basetypes.Int64Type{},
		"incident_count": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = DnsFailureType{}

type DnsFailureType struct {
	basetypes.ObjectType
}

func (t DnsFailureType) Equal(o attr.Type) bool {
	other, ok := o.(DnsFailureType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t DnsFailureType) String() string {
	return "DnsFailureType"
}

func (t DnsFailureType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	clientCountAttribute, ok := attributes["client_count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`client_count is missing from object`)

		return nil, diags
	}

	clientCountVal, ok := clientCountAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`client_count expected to be basetypes.Int64Value, was: %T`, clientCountAttribute))
	}

	durationAttribute, ok := attributes["duration"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`duration is missing from object`)

		return nil, diags
	}

	durationVal, ok := durationAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`duration expected to be basetypes.Int64Value, was: %T`, durationAttribute))
	}

	incidentCountAttribute, ok := attributes["incident_count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`incident_count is missing from object`)

		return nil, diags
	}

	incidentCountVal, ok := incidentCountAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`incident_count expected to be basetypes.Int64Value, was: %T`, incidentCountAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return DnsFailureValue{
		ClientCount:   clientCountVal,
		Duration:      durationVal,
		IncidentCount: incidentCountVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewDnsFailureValueNull() DnsFailureValue {
	return DnsFailureValue{
		state: attr.ValueStateNull,
	}
}

func NewDnsFailureValueUnknown() DnsFailureValue {
	return DnsFailureValue{
		state: attr.ValueStateUnknown,
	}
}

func NewDnsFailureValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (DnsFailureValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing DnsFailureValue Attribute Value",
				"While creating a DnsFailureValue value, a missing attribute value was detected. "+
					"A DnsFailureValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DnsFailureValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid DnsFailureValue Attribute Type",
				"While creating a DnsFailureValue value, an invalid attribute value was detected. "+
					"A DnsFailureValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DnsFailureValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("DnsFailureValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra DnsFailureValue Attribute Value",
				"While creating a DnsFailureValue value, an extra attribute value was detected. "+
					"A DnsFailureValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra DnsFailureValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewDnsFailureValueUnknown(), diags
	}

	clientCountAttribute, ok := attributes["client_count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`client_count is missing from object`)

		return NewDnsFailureValueUnknown(), diags
	}

	clientCountVal, ok := clientCountAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`client_count expected to be basetypes.Int64Value, was: %T`, clientCountAttribute))
	}

	durationAttribute, ok := attributes["duration"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`duration is missing from object`)

		return NewDnsFailureValueUnknown(), diags
	}

	durationVal, ok := durationAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`duration expected to be basetypes.Int64Value, was: %T`, durationAttribute))
	}

	incidentCountAttribute, ok := attributes["incident_count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`incident_count is missing from object`)

		return NewDnsFailureValueUnknown(), diags
	}

	incidentCountVal, ok := incidentCountAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`incident_count expected to be basetypes.Int64Value, was: %T`, incidentCountAttribute))
	}

	if diags.HasError() {
		return NewDnsFailureValueUnknown(), diags
	}

	return DnsFailureValue{
		ClientCount:   clientCountVal,
		Duration:      durationVal,
		IncidentCount: incidentCountVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewDnsFailureValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) DnsFailureValue {
	object, diags := NewDnsFailureValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewDnsFailureValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t DnsFailureType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewDnsFailureValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewDnsFailureValueUnknown(), nil
	}

	if in.IsNull() {
		return NewDnsFailureValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewDnsFailureValueMust(DnsFailureValue{}.AttributeTypes(ctx), attributes), nil
}

func (t DnsFailureType) ValueType(ctx context.Context) attr.Value {
	return DnsFailureValue{}
}

var _ basetypes.ObjectValuable = DnsFailureValue{}

type DnsFailureValue struct {
	ClientCount   basetypes.Int64Value `tfsdk:"client_count"`
	Duration      basetypes.Int64Value `tfsdk:"duration"`
	IncidentCount basetypes.Int64Value `tfsdk:"incident_count"`
	state         attr.ValueState
}

func (v DnsFailureValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["client_count"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["duration"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["incident_count"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.ClientCount.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["client_count"] = val

		val, err = v.Duration.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["duration"] = val

		val, err = v.IncidentCount.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["incident_count"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v DnsFailureValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v DnsFailureValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v DnsFailureValue) String() string {
	return "DnsFailureValue"
}

func (v DnsFailureValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"client_count":   basetypes.Int64Type{},
		"duration":       basetypes.Int64Type{},
		"incident_count": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"client_count":   v.ClientCount,
			"duration":       v.Duration,
			"incident_count": v.IncidentCount,
		})

	return objVal, diags
}

func (v DnsFailureValue) Equal(o attr.Value) bool {
	other, ok := o.(DnsFailureValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.ClientCount.Equal(other.ClientCount) {
		return false
	}

	if !v.Duration.Equal(other.Duration) {
		return false
	}

	if !v.IncidentCount.Equal(other.IncidentCount) {
		return false
	}

	return true
}

func (v DnsFailureValue) Type(ctx context.Context) attr.Type {
	return DnsFailureType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v DnsFailureValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"client_count":   basetypes.Int64Type{},
		"duration":       basetypes.Int64Type{},
		"incident_count": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = SkyatpType{}

type SkyatpType struct {
	basetypes.ObjectType
}

func (t SkyatpType) Equal(o attr.Type) bool {
	other, ok := o.(SkyatpType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SkyatpType) String() string {
	return "SkyatpType"
}

func (t SkyatpType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	sendIpMacMappingAttribute, ok := attributes["send_ip_mac_mapping"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`send_ip_mac_mapping is missing from object`)

		return nil, diags
	}

	sendIpMacMappingVal, ok := sendIpMacMappingAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`send_ip_mac_mapping expected to be basetypes.BoolValue, was: %T`, sendIpMacMappingAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SkyatpValue{
		Enabled:          enabledVal,
		SendIpMacMapping: sendIpMacMappingVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewSkyatpValueNull() SkyatpValue {
	return SkyatpValue{
		state: attr.ValueStateNull,
	}
}

func NewSkyatpValueUnknown() SkyatpValue {
	return SkyatpValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSkyatpValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SkyatpValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SkyatpValue Attribute Value",
				"While creating a SkyatpValue value, a missing attribute value was detected. "+
					"A SkyatpValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SkyatpValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SkyatpValue Attribute Type",
				"While creating a SkyatpValue value, an invalid attribute value was detected. "+
					"A SkyatpValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SkyatpValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SkyatpValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SkyatpValue Attribute Value",
				"While creating a SkyatpValue value, an extra attribute value was detected. "+
					"A SkyatpValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SkyatpValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSkyatpValueUnknown(), diags
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewSkyatpValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	sendIpMacMappingAttribute, ok := attributes["send_ip_mac_mapping"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`send_ip_mac_mapping is missing from object`)

		return NewSkyatpValueUnknown(), diags
	}

	sendIpMacMappingVal, ok := sendIpMacMappingAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`send_ip_mac_mapping expected to be basetypes.BoolValue, was: %T`, sendIpMacMappingAttribute))
	}

	if diags.HasError() {
		return NewSkyatpValueUnknown(), diags
	}

	return SkyatpValue{
		Enabled:          enabledVal,
		SendIpMacMapping: sendIpMacMappingVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewSkyatpValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SkyatpValue {
	object, diags := NewSkyatpValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSkyatpValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SkyatpType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSkyatpValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSkyatpValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSkyatpValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSkyatpValueMust(SkyatpValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SkyatpType) ValueType(ctx context.Context) attr.Value {
	return SkyatpValue{}
}

var _ basetypes.ObjectValuable = SkyatpValue{}

type SkyatpValue struct {
	Enabled          basetypes.BoolValue `tfsdk:"enabled"`
	SendIpMacMapping basetypes.BoolValue `tfsdk:"send_ip_mac_mapping"`
	state            attr.ValueState
}

func (v SkyatpValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["send_ip_mac_mapping"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.SendIpMacMapping.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["send_ip_mac_mapping"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SkyatpValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SkyatpValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SkyatpValue) String() string {
	return "SkyatpValue"
}

func (v SkyatpValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"enabled":             basetypes.BoolType{},
		"send_ip_mac_mapping": basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"enabled":             v.Enabled,
			"send_ip_mac_mapping": v.SendIpMacMapping,
		})

	return objVal, diags
}

func (v SkyatpValue) Equal(o attr.Value) bool {
	other, ok := o.(SkyatpValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.SendIpMacMapping.Equal(other.SendIpMacMapping) {
		return false
	}

	return true
}

func (v SkyatpValue) Type(ctx context.Context) attr.Type {
	return SkyatpType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SkyatpValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"enabled":             basetypes.BoolType{},
		"send_ip_mac_mapping": basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = SsrType{}

type SsrType struct {
	basetypes.ObjectType
}

func (t SsrType) Equal(o attr.Type) bool {
	other, ok := o.(SsrType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SsrType) String() string {
	return "SsrType"
}

func (t SsrType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	conductorHostsAttribute, ok := attributes["conductor_hosts"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`conductor_hosts is missing from object`)

		return nil, diags
	}

	conductorHostsVal, ok := conductorHostsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`conductor_hosts expected to be basetypes.ListValue, was: %T`, conductorHostsAttribute))
	}

	disableStatsAttribute, ok := attributes["disable_stats"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disable_stats is missing from object`)

		return nil, diags
	}

	disableStatsVal, ok := disableStatsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disable_stats expected to be basetypes.BoolValue, was: %T`, disableStatsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SsrValue{
		ConductorHosts: conductorHostsVal,
		DisableStats:   disableStatsVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewSsrValueNull() SsrValue {
	return SsrValue{
		state: attr.ValueStateNull,
	}
}

func NewSsrValueUnknown() SsrValue {
	return SsrValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSsrValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SsrValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SsrValue Attribute Value",
				"While creating a SsrValue value, a missing attribute value was detected. "+
					"A SsrValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SsrValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SsrValue Attribute Type",
				"While creating a SsrValue value, an invalid attribute value was detected. "+
					"A SsrValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SsrValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SsrValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SsrValue Attribute Value",
				"While creating a SsrValue value, an extra attribute value was detected. "+
					"A SsrValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SsrValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSsrValueUnknown(), diags
	}

	conductorHostsAttribute, ok := attributes["conductor_hosts"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`conductor_hosts is missing from object`)

		return NewSsrValueUnknown(), diags
	}

	conductorHostsVal, ok := conductorHostsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`conductor_hosts expected to be basetypes.ListValue, was: %T`, conductorHostsAttribute))
	}

	disableStatsAttribute, ok := attributes["disable_stats"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disable_stats is missing from object`)

		return NewSsrValueUnknown(), diags
	}

	disableStatsVal, ok := disableStatsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disable_stats expected to be basetypes.BoolValue, was: %T`, disableStatsAttribute))
	}

	if diags.HasError() {
		return NewSsrValueUnknown(), diags
	}

	return SsrValue{
		ConductorHosts: conductorHostsVal,
		DisableStats:   disableStatsVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewSsrValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SsrValue {
	object, diags := NewSsrValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSsrValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SsrType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSsrValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSsrValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSsrValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSsrValueMust(SsrValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SsrType) ValueType(ctx context.Context) attr.Value {
	return SsrValue{}
}

var _ basetypes.ObjectValuable = SsrValue{}

type SsrValue struct {
	ConductorHosts basetypes.ListValue `tfsdk:"conductor_hosts"`
	DisableStats   basetypes.BoolValue `tfsdk:"disable_stats"`
	state          attr.ValueState
}

func (v SsrValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["conductor_hosts"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["disable_stats"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.ConductorHosts.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["conductor_hosts"] = val

		val, err = v.DisableStats.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["disable_stats"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SsrValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SsrValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SsrValue) String() string {
	return "SsrValue"
}

func (v SsrValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	conductorHostsVal, d := types.ListValue(types.StringType, v.ConductorHosts.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"conductor_hosts": basetypes.ListType{
				ElemType: types.StringType,
			},
			"disable_stats": basetypes.BoolType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"conductor_hosts": basetypes.ListType{
			ElemType: types.StringType,
		},
		"disable_stats": basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"conductor_hosts": conductorHostsVal,
			"disable_stats":   v.DisableStats,
		})

	return objVal, diags
}

func (v SsrValue) Equal(o attr.Value) bool {
	other, ok := o.(SsrValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.ConductorHosts.Equal(other.ConductorHosts) {
		return false
	}

	if !v.DisableStats.Equal(other.DisableStats) {
		return false
	}

	return true
}

func (v SsrValue) Type(ctx context.Context) attr.Type {
	return SsrType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SsrValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"conductor_hosts": basetypes.ListType{
			ElemType: types.StringType,
		},
		"disable_stats": basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = SyntheticTestType{}

type SyntheticTestType struct {
	basetypes.ObjectType
}

func (t SyntheticTestType) Equal(o attr.Type) bool {
	other, ok := o.(SyntheticTestType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SyntheticTestType) String() string {
	return "SyntheticTestType"
}

func (t SyntheticTestType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	disabledAttribute, ok := attributes["disabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disabled is missing from object`)

		return nil, diags
	}

	disabledVal, ok := disabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disabled expected to be basetypes.BoolValue, was: %T`, disabledAttribute))
	}

	vlansAttribute, ok := attributes["vlans"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlans is missing from object`)

		return nil, diags
	}

	vlansVal, ok := vlansAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlans expected to be basetypes.ListValue, was: %T`, vlansAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SyntheticTestValue{
		Disabled: disabledVal,
		Vlans:    vlansVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewSyntheticTestValueNull() SyntheticTestValue {
	return SyntheticTestValue{
		state: attr.ValueStateNull,
	}
}

func NewSyntheticTestValueUnknown() SyntheticTestValue {
	return SyntheticTestValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSyntheticTestValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SyntheticTestValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SyntheticTestValue Attribute Value",
				"While creating a SyntheticTestValue value, a missing attribute value was detected. "+
					"A SyntheticTestValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SyntheticTestValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SyntheticTestValue Attribute Type",
				"While creating a SyntheticTestValue value, an invalid attribute value was detected. "+
					"A SyntheticTestValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SyntheticTestValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SyntheticTestValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SyntheticTestValue Attribute Value",
				"While creating a SyntheticTestValue value, an extra attribute value was detected. "+
					"A SyntheticTestValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SyntheticTestValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSyntheticTestValueUnknown(), diags
	}

	disabledAttribute, ok := attributes["disabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disabled is missing from object`)

		return NewSyntheticTestValueUnknown(), diags
	}

	disabledVal, ok := disabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disabled expected to be basetypes.BoolValue, was: %T`, disabledAttribute))
	}

	vlansAttribute, ok := attributes["vlans"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlans is missing from object`)

		return NewSyntheticTestValueUnknown(), diags
	}

	vlansVal, ok := vlansAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlans expected to be basetypes.ListValue, was: %T`, vlansAttribute))
	}

	if diags.HasError() {
		return NewSyntheticTestValueUnknown(), diags
	}

	return SyntheticTestValue{
		Disabled: disabledVal,
		Vlans:    vlansVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewSyntheticTestValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SyntheticTestValue {
	object, diags := NewSyntheticTestValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSyntheticTestValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SyntheticTestType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSyntheticTestValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSyntheticTestValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSyntheticTestValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSyntheticTestValueMust(SyntheticTestValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SyntheticTestType) ValueType(ctx context.Context) attr.Value {
	return SyntheticTestValue{}
}

var _ basetypes.ObjectValuable = SyntheticTestValue{}

type SyntheticTestValue struct {
	Disabled basetypes.BoolValue `tfsdk:"disabled"`
	Vlans    basetypes.ListValue `tfsdk:"vlans"`
	state    attr.ValueState
}

func (v SyntheticTestValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["disabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["vlans"] = basetypes.ListType{
		ElemType: VlansValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Disabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["disabled"] = val

		val, err = v.Vlans.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vlans"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SyntheticTestValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SyntheticTestValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SyntheticTestValue) String() string {
	return "SyntheticTestValue"
}

func (v SyntheticTestValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	vlans := types.ListValueMust(
		VlansType{
			basetypes.ObjectType{
				AttrTypes: VlansValue{}.AttributeTypes(ctx),
			},
		},
		v.Vlans.Elements(),
	)

	if v.Vlans.IsNull() {
		vlans = types.ListNull(
			VlansType{
				basetypes.ObjectType{
					AttrTypes: VlansValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Vlans.IsUnknown() {
		vlans = types.ListUnknown(
			VlansType{
				basetypes.ObjectType{
					AttrTypes: VlansValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"disabled": basetypes.BoolType{},
		"vlans": basetypes.ListType{
			ElemType: VlansValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"disabled": v.Disabled,
			"vlans":    vlans,
		})

	return objVal, diags
}

func (v SyntheticTestValue) Equal(o attr.Value) bool {
	other, ok := o.(SyntheticTestValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Disabled.Equal(other.Disabled) {
		return false
	}

	if !v.Vlans.Equal(other.Vlans) {
		return false
	}

	return true
}

func (v SyntheticTestValue) Type(ctx context.Context) attr.Type {
	return SyntheticTestType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SyntheticTestValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"disabled": basetypes.BoolType{},
		"vlans": basetypes.ListType{
			ElemType: VlansValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = VlansType{}

type VlansType struct {
	basetypes.ObjectType
}

func (t VlansType) Equal(o attr.Type) bool {
	other, ok := o.(VlansType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t VlansType) String() string {
	return "VlansType"
}

func (t VlansType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	customTestUrlsAttribute, ok := attributes["custom_test_urls"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`custom_test_urls is missing from object`)

		return nil, diags
	}

	customTestUrlsVal, ok := customTestUrlsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`custom_test_urls expected to be basetypes.ListValue, was: %T`, customTestUrlsAttribute))
	}

	disabledAttribute, ok := attributes["disabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disabled is missing from object`)

		return nil, diags
	}

	disabledVal, ok := disabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disabled expected to be basetypes.BoolValue, was: %T`, disabledAttribute))
	}

	vlanIdsAttribute, ok := attributes["vlan_ids"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan_ids is missing from object`)

		return nil, diags
	}

	vlanIdsVal, ok := vlanIdsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan_ids expected to be basetypes.ListValue, was: %T`, vlanIdsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return VlansValue{
		CustomTestUrls: customTestUrlsVal,
		Disabled:       disabledVal,
		VlanIds:        vlanIdsVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewVlansValueNull() VlansValue {
	return VlansValue{
		state: attr.ValueStateNull,
	}
}

func NewVlansValueUnknown() VlansValue {
	return VlansValue{
		state: attr.ValueStateUnknown,
	}
}

func NewVlansValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (VlansValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing VlansValue Attribute Value",
				"While creating a VlansValue value, a missing attribute value was detected. "+
					"A VlansValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VlansValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid VlansValue Attribute Type",
				"While creating a VlansValue value, an invalid attribute value was detected. "+
					"A VlansValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VlansValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("VlansValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra VlansValue Attribute Value",
				"While creating a VlansValue value, an extra attribute value was detected. "+
					"A VlansValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra VlansValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewVlansValueUnknown(), diags
	}

	customTestUrlsAttribute, ok := attributes["custom_test_urls"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`custom_test_urls is missing from object`)

		return NewVlansValueUnknown(), diags
	}

	customTestUrlsVal, ok := customTestUrlsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`custom_test_urls expected to be basetypes.ListValue, was: %T`, customTestUrlsAttribute))
	}

	disabledAttribute, ok := attributes["disabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disabled is missing from object`)

		return NewVlansValueUnknown(), diags
	}

	disabledVal, ok := disabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disabled expected to be basetypes.BoolValue, was: %T`, disabledAttribute))
	}

	vlanIdsAttribute, ok := attributes["vlan_ids"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan_ids is missing from object`)

		return NewVlansValueUnknown(), diags
	}

	vlanIdsVal, ok := vlanIdsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan_ids expected to be basetypes.ListValue, was: %T`, vlanIdsAttribute))
	}

	if diags.HasError() {
		return NewVlansValueUnknown(), diags
	}

	return VlansValue{
		CustomTestUrls: customTestUrlsVal,
		Disabled:       disabledVal,
		VlanIds:        vlanIdsVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewVlansValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) VlansValue {
	object, diags := NewVlansValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewVlansValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t VlansType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewVlansValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewVlansValueUnknown(), nil
	}

	if in.IsNull() {
		return NewVlansValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewVlansValueMust(VlansValue{}.AttributeTypes(ctx), attributes), nil
}

func (t VlansType) ValueType(ctx context.Context) attr.Value {
	return VlansValue{}
}

var _ basetypes.ObjectValuable = VlansValue{}

type VlansValue struct {
	CustomTestUrls basetypes.ListValue `tfsdk:"custom_test_urls"`
	Disabled       basetypes.BoolValue `tfsdk:"disabled"`
	VlanIds        basetypes.ListValue `tfsdk:"vlan_ids"`
	state          attr.ValueState
}

func (v VlansValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["custom_test_urls"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["disabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["vlan_ids"] = basetypes.ListType{
		ElemType: types.Int64Type,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.CustomTestUrls.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["custom_test_urls"] = val

		val, err = v.Disabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["disabled"] = val

		val, err = v.VlanIds.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vlan_ids"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v VlansValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v VlansValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v VlansValue) String() string {
	return "VlansValue"
}

func (v VlansValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	customTestUrlsVal, d := types.ListValue(types.StringType, v.CustomTestUrls.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"custom_test_urls": basetypes.ListType{
				ElemType: types.StringType,
			},
			"disabled": basetypes.BoolType{},
			"vlan_ids": basetypes.ListType{
				ElemType: types.Int64Type,
			},
		}), diags
	}

	vlanIdsVal, d := types.ListValue(types.Int64Type, v.VlanIds.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"custom_test_urls": basetypes.ListType{
				ElemType: types.StringType,
			},
			"disabled": basetypes.BoolType{},
			"vlan_ids": basetypes.ListType{
				ElemType: types.Int64Type,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"custom_test_urls": basetypes.ListType{
			ElemType: types.StringType,
		},
		"disabled": basetypes.BoolType{},
		"vlan_ids": basetypes.ListType{
			ElemType: types.Int64Type,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"custom_test_urls": customTestUrlsVal,
			"disabled":         v.Disabled,
			"vlan_ids":         vlanIdsVal,
		})

	return objVal, diags
}

func (v VlansValue) Equal(o attr.Value) bool {
	other, ok := o.(VlansValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.CustomTestUrls.Equal(other.CustomTestUrls) {
		return false
	}

	if !v.Disabled.Equal(other.Disabled) {
		return false
	}

	if !v.VlanIds.Equal(other.VlanIds) {
		return false
	}

	return true
}

func (v VlansValue) Type(ctx context.Context) attr.Type {
	return VlansType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v VlansValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"custom_test_urls": basetypes.ListType{
			ElemType: types.StringType,
		},
		"disabled": basetypes.BoolType{},
		"vlan_ids": basetypes.ListType{
			ElemType: types.Int64Type,
		},
	}
}

var _ basetypes.ObjectTypable = VsInstanceType{}

type VsInstanceType struct {
	basetypes.ObjectType
}

func (t VsInstanceType) Equal(o attr.Type) bool {
	other, ok := o.(VsInstanceType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t VsInstanceType) String() string {
	return "VsInstanceType"
}

func (t VsInstanceType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	networksAttribute, ok := attributes["networks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`networks is missing from object`)

		return nil, diags
	}

	networksVal, ok := networksAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`networks expected to be basetypes.ListValue, was: %T`, networksAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return VsInstanceValue{
		Networks: networksVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewVsInstanceValueNull() VsInstanceValue {
	return VsInstanceValue{
		state: attr.ValueStateNull,
	}
}

func NewVsInstanceValueUnknown() VsInstanceValue {
	return VsInstanceValue{
		state: attr.ValueStateUnknown,
	}
}

func NewVsInstanceValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (VsInstanceValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing VsInstanceValue Attribute Value",
				"While creating a VsInstanceValue value, a missing attribute value was detected. "+
					"A VsInstanceValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VsInstanceValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid VsInstanceValue Attribute Type",
				"While creating a VsInstanceValue value, an invalid attribute value was detected. "+
					"A VsInstanceValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VsInstanceValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("VsInstanceValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra VsInstanceValue Attribute Value",
				"While creating a VsInstanceValue value, an extra attribute value was detected. "+
					"A VsInstanceValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra VsInstanceValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewVsInstanceValueUnknown(), diags
	}

	networksAttribute, ok := attributes["networks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`networks is missing from object`)

		return NewVsInstanceValueUnknown(), diags
	}

	networksVal, ok := networksAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`networks expected to be basetypes.ListValue, was: %T`, networksAttribute))
	}

	if diags.HasError() {
		return NewVsInstanceValueUnknown(), diags
	}

	return VsInstanceValue{
		Networks: networksVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewVsInstanceValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) VsInstanceValue {
	object, diags := NewVsInstanceValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewVsInstanceValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t VsInstanceType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewVsInstanceValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewVsInstanceValueUnknown(), nil
	}

	if in.IsNull() {
		return NewVsInstanceValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewVsInstanceValueMust(VsInstanceValue{}.AttributeTypes(ctx), attributes), nil
}

func (t VsInstanceType) ValueType(ctx context.Context) attr.Value {
	return VsInstanceValue{}
}

var _ basetypes.ObjectValuable = VsInstanceValue{}

type VsInstanceValue struct {
	Networks basetypes.ListValue `tfsdk:"networks"`
	state    attr.ValueState
}

func (v VsInstanceValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["networks"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Networks.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["networks"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v VsInstanceValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v VsInstanceValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v VsInstanceValue) String() string {
	return "VsInstanceValue"
}

func (v VsInstanceValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	networksVal, d := types.ListValue(types.StringType, v.Networks.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"networks": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"networks": basetypes.ListType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"networks": networksVal,
		})

	return objVal, diags
}

func (v VsInstanceValue) Equal(o attr.Value) bool {
	other, ok := o.(VsInstanceValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Networks.Equal(other.Networks) {
		return false
	}

	return true
}

func (v VsInstanceValue) Type(ctx context.Context) attr.Type {
	return VsInstanceType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v VsInstanceValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"networks": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = WidsType{}

type WidsType struct {
	basetypes.ObjectType
}

func (t WidsType) Equal(o attr.Type) bool {
	other, ok := o.(WidsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t WidsType) String() string {
	return "WidsType"
}

func (t WidsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	repeatedAuthFailuresAttribute, ok := attributes["repeated_auth_failures"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`repeated_auth_failures is missing from object`)

		return nil, diags
	}

	repeatedAuthFailuresVal, ok := repeatedAuthFailuresAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`repeated_auth_failures expected to be basetypes.ObjectValue, was: %T`, repeatedAuthFailuresAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return WidsValue{
		RepeatedAuthFailures: repeatedAuthFailuresVal,
		state:                attr.ValueStateKnown,
	}, diags
}

func NewWidsValueNull() WidsValue {
	return WidsValue{
		state: attr.ValueStateNull,
	}
}

func NewWidsValueUnknown() WidsValue {
	return WidsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewWidsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (WidsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing WidsValue Attribute Value",
				"While creating a WidsValue value, a missing attribute value was detected. "+
					"A WidsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("WidsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid WidsValue Attribute Type",
				"While creating a WidsValue value, an invalid attribute value was detected. "+
					"A WidsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("WidsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("WidsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra WidsValue Attribute Value",
				"While creating a WidsValue value, an extra attribute value was detected. "+
					"A WidsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra WidsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewWidsValueUnknown(), diags
	}

	repeatedAuthFailuresAttribute, ok := attributes["repeated_auth_failures"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`repeated_auth_failures is missing from object`)

		return NewWidsValueUnknown(), diags
	}

	repeatedAuthFailuresVal, ok := repeatedAuthFailuresAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`repeated_auth_failures expected to be basetypes.ObjectValue, was: %T`, repeatedAuthFailuresAttribute))
	}

	if diags.HasError() {
		return NewWidsValueUnknown(), diags
	}

	return WidsValue{
		RepeatedAuthFailures: repeatedAuthFailuresVal,
		state:                attr.ValueStateKnown,
	}, diags
}

func NewWidsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) WidsValue {
	object, diags := NewWidsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewWidsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t WidsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewWidsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewWidsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewWidsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewWidsValueMust(WidsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t WidsType) ValueType(ctx context.Context) attr.Value {
	return WidsValue{}
}

var _ basetypes.ObjectValuable = WidsValue{}

type WidsValue struct {
	RepeatedAuthFailures basetypes.ObjectValue `tfsdk:"repeated_auth_failures"`
	state                attr.ValueState
}

func (v WidsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["repeated_auth_failures"] = basetypes.ObjectType{
		AttrTypes: RepeatedAuthFailuresValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.RepeatedAuthFailures.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["repeated_auth_failures"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v WidsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v WidsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v WidsValue) String() string {
	return "WidsValue"
}

func (v WidsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var repeatedAuthFailures basetypes.ObjectValue

	if v.RepeatedAuthFailures.IsNull() {
		repeatedAuthFailures = types.ObjectNull(
			RepeatedAuthFailuresValue{}.AttributeTypes(ctx),
		)
	}

	if v.RepeatedAuthFailures.IsUnknown() {
		repeatedAuthFailures = types.ObjectUnknown(
			RepeatedAuthFailuresValue{}.AttributeTypes(ctx),
		)
	}

	if !v.RepeatedAuthFailures.IsNull() && !v.RepeatedAuthFailures.IsUnknown() {
		repeatedAuthFailures = types.ObjectValueMust(
			RepeatedAuthFailuresValue{}.AttributeTypes(ctx),
			v.RepeatedAuthFailures.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"repeated_auth_failures": basetypes.ObjectType{
			AttrTypes: RepeatedAuthFailuresValue{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"repeated_auth_failures": repeatedAuthFailures,
		})

	return objVal, diags
}

func (v WidsValue) Equal(o attr.Value) bool {
	other, ok := o.(WidsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.RepeatedAuthFailures.Equal(other.RepeatedAuthFailures) {
		return false
	}

	return true
}

func (v WidsValue) Type(ctx context.Context) attr.Type {
	return WidsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v WidsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"repeated_auth_failures": basetypes.ObjectType{
			AttrTypes: RepeatedAuthFailuresValue{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = RepeatedAuthFailuresType{}

type RepeatedAuthFailuresType struct {
	basetypes.ObjectType
}

func (t RepeatedAuthFailuresType) Equal(o attr.Type) bool {
	other, ok := o.(RepeatedAuthFailuresType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t RepeatedAuthFailuresType) String() string {
	return "RepeatedAuthFailuresType"
}

func (t RepeatedAuthFailuresType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	durationAttribute, ok := attributes["duration"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`duration is missing from object`)

		return nil, diags
	}

	durationVal, ok := durationAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`duration expected to be basetypes.Int64Value, was: %T`, durationAttribute))
	}

	thresholdAttribute, ok := attributes["threshold"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`threshold is missing from object`)

		return nil, diags
	}

	thresholdVal, ok := thresholdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`threshold expected to be basetypes.Int64Value, was: %T`, thresholdAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return RepeatedAuthFailuresValue{
		Duration:  durationVal,
		Threshold: thresholdVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewRepeatedAuthFailuresValueNull() RepeatedAuthFailuresValue {
	return RepeatedAuthFailuresValue{
		state: attr.ValueStateNull,
	}
}

func NewRepeatedAuthFailuresValueUnknown() RepeatedAuthFailuresValue {
	return RepeatedAuthFailuresValue{
		state: attr.ValueStateUnknown,
	}
}

func NewRepeatedAuthFailuresValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (RepeatedAuthFailuresValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing RepeatedAuthFailuresValue Attribute Value",
				"While creating a RepeatedAuthFailuresValue value, a missing attribute value was detected. "+
					"A RepeatedAuthFailuresValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RepeatedAuthFailuresValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid RepeatedAuthFailuresValue Attribute Type",
				"While creating a RepeatedAuthFailuresValue value, an invalid attribute value was detected. "+
					"A RepeatedAuthFailuresValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RepeatedAuthFailuresValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("RepeatedAuthFailuresValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra RepeatedAuthFailuresValue Attribute Value",
				"While creating a RepeatedAuthFailuresValue value, an extra attribute value was detected. "+
					"A RepeatedAuthFailuresValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra RepeatedAuthFailuresValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewRepeatedAuthFailuresValueUnknown(), diags
	}

	durationAttribute, ok := attributes["duration"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`duration is missing from object`)

		return NewRepeatedAuthFailuresValueUnknown(), diags
	}

	durationVal, ok := durationAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`duration expected to be basetypes.Int64Value, was: %T`, durationAttribute))
	}

	thresholdAttribute, ok := attributes["threshold"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`threshold is missing from object`)

		return NewRepeatedAuthFailuresValueUnknown(), diags
	}

	thresholdVal, ok := thresholdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`threshold expected to be basetypes.Int64Value, was: %T`, thresholdAttribute))
	}

	if diags.HasError() {
		return NewRepeatedAuthFailuresValueUnknown(), diags
	}

	return RepeatedAuthFailuresValue{
		Duration:  durationVal,
		Threshold: thresholdVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewRepeatedAuthFailuresValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) RepeatedAuthFailuresValue {
	object, diags := NewRepeatedAuthFailuresValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewRepeatedAuthFailuresValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t RepeatedAuthFailuresType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewRepeatedAuthFailuresValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewRepeatedAuthFailuresValueUnknown(), nil
	}

	if in.IsNull() {
		return NewRepeatedAuthFailuresValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewRepeatedAuthFailuresValueMust(RepeatedAuthFailuresValue{}.AttributeTypes(ctx), attributes), nil
}

func (t RepeatedAuthFailuresType) ValueType(ctx context.Context) attr.Value {
	return RepeatedAuthFailuresValue{}
}

var _ basetypes.ObjectValuable = RepeatedAuthFailuresValue{}

type RepeatedAuthFailuresValue struct {
	Duration  basetypes.Int64Value `tfsdk:"duration"`
	Threshold basetypes.Int64Value `tfsdk:"threshold"`
	state     attr.ValueState
}

func (v RepeatedAuthFailuresValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["duration"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["threshold"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Duration.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["duration"] = val

		val, err = v.Threshold.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["threshold"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v RepeatedAuthFailuresValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v RepeatedAuthFailuresValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v RepeatedAuthFailuresValue) String() string {
	return "RepeatedAuthFailuresValue"
}

func (v RepeatedAuthFailuresValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"duration":  basetypes.Int64Type{},
		"threshold": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"duration":  v.Duration,
			"threshold": v.Threshold,
		})

	return objVal, diags
}

func (v RepeatedAuthFailuresValue) Equal(o attr.Value) bool {
	other, ok := o.(RepeatedAuthFailuresValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Duration.Equal(other.Duration) {
		return false
	}

	if !v.Threshold.Equal(other.Threshold) {
		return false
	}

	return true
}

func (v RepeatedAuthFailuresValue) Type(ctx context.Context) attr.Type {
	return RepeatedAuthFailuresType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v RepeatedAuthFailuresValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"duration":  basetypes.Int64Type{},
		"threshold": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = WifiType{}

type WifiType struct {
	basetypes.ObjectType
}

func (t WifiType) Equal(o attr.Type) bool {
	other, ok := o.(WifiType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t WifiType) String() string {
	return "WifiType"
}

func (t WifiType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	ciscoEnabledAttribute, ok := attributes["cisco_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cisco_enabled is missing from object`)

		return nil, diags
	}

	ciscoEnabledVal, ok := ciscoEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cisco_enabled expected to be basetypes.BoolValue, was: %T`, ciscoEnabledAttribute))
	}

	disable11kAttribute, ok := attributes["disable_11k"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disable_11k is missing from object`)

		return nil, diags
	}

	disable11kVal, ok := disable11kAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disable_11k expected to be basetypes.BoolValue, was: %T`, disable11kAttribute))
	}

	disableRadiosWhenPowerConstrainedAttribute, ok := attributes["disable_radios_when_power_constrained"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disable_radios_when_power_constrained is missing from object`)

		return nil, diags
	}

	disableRadiosWhenPowerConstrainedVal, ok := disableRadiosWhenPowerConstrainedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disable_radios_when_power_constrained expected to be basetypes.BoolValue, was: %T`, disableRadiosWhenPowerConstrainedAttribute))
	}

	enableArpSpoofCheckAttribute, ok := attributes["enable_arp_spoof_check"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable_arp_spoof_check is missing from object`)

		return nil, diags
	}

	enableArpSpoofCheckVal, ok := enableArpSpoofCheckAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable_arp_spoof_check expected to be basetypes.BoolValue, was: %T`, enableArpSpoofCheckAttribute))
	}

	enableSharedRadioScanningAttribute, ok := attributes["enable_shared_radio_scanning"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable_shared_radio_scanning is missing from object`)

		return nil, diags
	}

	enableSharedRadioScanningVal, ok := enableSharedRadioScanningAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable_shared_radio_scanning expected to be basetypes.BoolValue, was: %T`, enableSharedRadioScanningAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	locateConnectedAttribute, ok := attributes["locate_connected"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`locate_connected is missing from object`)

		return nil, diags
	}

	locateConnectedVal, ok := locateConnectedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`locate_connected expected to be basetypes.BoolValue, was: %T`, locateConnectedAttribute))
	}

	locateUnconnectedAttribute, ok := attributes["locate_unconnected"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`locate_unconnected is missing from object`)

		return nil, diags
	}

	locateUnconnectedVal, ok := locateUnconnectedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`locate_unconnected expected to be basetypes.BoolValue, was: %T`, locateUnconnectedAttribute))
	}

	meshAllowDfsAttribute, ok := attributes["mesh_allow_dfs"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mesh_allow_dfs is missing from object`)

		return nil, diags
	}

	meshAllowDfsVal, ok := meshAllowDfsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mesh_allow_dfs expected to be basetypes.BoolValue, was: %T`, meshAllowDfsAttribute))
	}

	meshEnableCrmAttribute, ok := attributes["mesh_enable_crm"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mesh_enable_crm is missing from object`)

		return nil, diags
	}

	meshEnableCrmVal, ok := meshEnableCrmAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mesh_enable_crm expected to be basetypes.BoolValue, was: %T`, meshEnableCrmAttribute))
	}

	meshEnabledAttribute, ok := attributes["mesh_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mesh_enabled is missing from object`)

		return nil, diags
	}

	meshEnabledVal, ok := meshEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mesh_enabled expected to be basetypes.BoolValue, was: %T`, meshEnabledAttribute))
	}

	meshPskAttribute, ok := attributes["mesh_psk"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mesh_psk is missing from object`)

		return nil, diags
	}

	meshPskVal, ok := meshPskAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mesh_psk expected to be basetypes.StringValue, was: %T`, meshPskAttribute))
	}

	meshSsidAttribute, ok := attributes["mesh_ssid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mesh_ssid is missing from object`)

		return nil, diags
	}

	meshSsidVal, ok := meshSsidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mesh_ssid expected to be basetypes.StringValue, was: %T`, meshSsidAttribute))
	}

	proxyArpAttribute, ok := attributes["proxy_arp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`proxy_arp is missing from object`)

		return nil, diags
	}

	proxyArpVal, ok := proxyArpAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`proxy_arp expected to be basetypes.StringValue, was: %T`, proxyArpAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return WifiValue{
		CiscoEnabled:                      ciscoEnabledVal,
		Disable11k:                        disable11kVal,
		DisableRadiosWhenPowerConstrained: disableRadiosWhenPowerConstrainedVal,
		EnableArpSpoofCheck:               enableArpSpoofCheckVal,
		EnableSharedRadioScanning:         enableSharedRadioScanningVal,
		Enabled:                           enabledVal,
		LocateConnected:                   locateConnectedVal,
		LocateUnconnected:                 locateUnconnectedVal,
		MeshAllowDfs:                      meshAllowDfsVal,
		MeshEnableCrm:                     meshEnableCrmVal,
		MeshEnabled:                       meshEnabledVal,
		MeshPsk:                           meshPskVal,
		MeshSsid:                          meshSsidVal,
		ProxyArp:                          proxyArpVal,
		state:                             attr.ValueStateKnown,
	}, diags
}

func NewWifiValueNull() WifiValue {
	return WifiValue{
		state: attr.ValueStateNull,
	}
}

func NewWifiValueUnknown() WifiValue {
	return WifiValue{
		state: attr.ValueStateUnknown,
	}
}

func NewWifiValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (WifiValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing WifiValue Attribute Value",
				"While creating a WifiValue value, a missing attribute value was detected. "+
					"A WifiValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("WifiValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid WifiValue Attribute Type",
				"While creating a WifiValue value, an invalid attribute value was detected. "+
					"A WifiValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("WifiValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("WifiValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra WifiValue Attribute Value",
				"While creating a WifiValue value, an extra attribute value was detected. "+
					"A WifiValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra WifiValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewWifiValueUnknown(), diags
	}

	ciscoEnabledAttribute, ok := attributes["cisco_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cisco_enabled is missing from object`)

		return NewWifiValueUnknown(), diags
	}

	ciscoEnabledVal, ok := ciscoEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cisco_enabled expected to be basetypes.BoolValue, was: %T`, ciscoEnabledAttribute))
	}

	disable11kAttribute, ok := attributes["disable_11k"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disable_11k is missing from object`)

		return NewWifiValueUnknown(), diags
	}

	disable11kVal, ok := disable11kAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disable_11k expected to be basetypes.BoolValue, was: %T`, disable11kAttribute))
	}

	disableRadiosWhenPowerConstrainedAttribute, ok := attributes["disable_radios_when_power_constrained"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disable_radios_when_power_constrained is missing from object`)

		return NewWifiValueUnknown(), diags
	}

	disableRadiosWhenPowerConstrainedVal, ok := disableRadiosWhenPowerConstrainedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disable_radios_when_power_constrained expected to be basetypes.BoolValue, was: %T`, disableRadiosWhenPowerConstrainedAttribute))
	}

	enableArpSpoofCheckAttribute, ok := attributes["enable_arp_spoof_check"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable_arp_spoof_check is missing from object`)

		return NewWifiValueUnknown(), diags
	}

	enableArpSpoofCheckVal, ok := enableArpSpoofCheckAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable_arp_spoof_check expected to be basetypes.BoolValue, was: %T`, enableArpSpoofCheckAttribute))
	}

	enableSharedRadioScanningAttribute, ok := attributes["enable_shared_radio_scanning"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable_shared_radio_scanning is missing from object`)

		return NewWifiValueUnknown(), diags
	}

	enableSharedRadioScanningVal, ok := enableSharedRadioScanningAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable_shared_radio_scanning expected to be basetypes.BoolValue, was: %T`, enableSharedRadioScanningAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewWifiValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	locateConnectedAttribute, ok := attributes["locate_connected"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`locate_connected is missing from object`)

		return NewWifiValueUnknown(), diags
	}

	locateConnectedVal, ok := locateConnectedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`locate_connected expected to be basetypes.BoolValue, was: %T`, locateConnectedAttribute))
	}

	locateUnconnectedAttribute, ok := attributes["locate_unconnected"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`locate_unconnected is missing from object`)

		return NewWifiValueUnknown(), diags
	}

	locateUnconnectedVal, ok := locateUnconnectedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`locate_unconnected expected to be basetypes.BoolValue, was: %T`, locateUnconnectedAttribute))
	}

	meshAllowDfsAttribute, ok := attributes["mesh_allow_dfs"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mesh_allow_dfs is missing from object`)

		return NewWifiValueUnknown(), diags
	}

	meshAllowDfsVal, ok := meshAllowDfsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mesh_allow_dfs expected to be basetypes.BoolValue, was: %T`, meshAllowDfsAttribute))
	}

	meshEnableCrmAttribute, ok := attributes["mesh_enable_crm"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mesh_enable_crm is missing from object`)

		return NewWifiValueUnknown(), diags
	}

	meshEnableCrmVal, ok := meshEnableCrmAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mesh_enable_crm expected to be basetypes.BoolValue, was: %T`, meshEnableCrmAttribute))
	}

	meshEnabledAttribute, ok := attributes["mesh_enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mesh_enabled is missing from object`)

		return NewWifiValueUnknown(), diags
	}

	meshEnabledVal, ok := meshEnabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mesh_enabled expected to be basetypes.BoolValue, was: %T`, meshEnabledAttribute))
	}

	meshPskAttribute, ok := attributes["mesh_psk"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mesh_psk is missing from object`)

		return NewWifiValueUnknown(), diags
	}

	meshPskVal, ok := meshPskAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mesh_psk expected to be basetypes.StringValue, was: %T`, meshPskAttribute))
	}

	meshSsidAttribute, ok := attributes["mesh_ssid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mesh_ssid is missing from object`)

		return NewWifiValueUnknown(), diags
	}

	meshSsidVal, ok := meshSsidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mesh_ssid expected to be basetypes.StringValue, was: %T`, meshSsidAttribute))
	}

	proxyArpAttribute, ok := attributes["proxy_arp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`proxy_arp is missing from object`)

		return NewWifiValueUnknown(), diags
	}

	proxyArpVal, ok := proxyArpAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`proxy_arp expected to be basetypes.StringValue, was: %T`, proxyArpAttribute))
	}

	if diags.HasError() {
		return NewWifiValueUnknown(), diags
	}

	return WifiValue{
		CiscoEnabled:                      ciscoEnabledVal,
		Disable11k:                        disable11kVal,
		DisableRadiosWhenPowerConstrained: disableRadiosWhenPowerConstrainedVal,
		EnableArpSpoofCheck:               enableArpSpoofCheckVal,
		EnableSharedRadioScanning:         enableSharedRadioScanningVal,
		Enabled:                           enabledVal,
		LocateConnected:                   locateConnectedVal,
		LocateUnconnected:                 locateUnconnectedVal,
		MeshAllowDfs:                      meshAllowDfsVal,
		MeshEnableCrm:                     meshEnableCrmVal,
		MeshEnabled:                       meshEnabledVal,
		MeshPsk:                           meshPskVal,
		MeshSsid:                          meshSsidVal,
		ProxyArp:                          proxyArpVal,
		state:                             attr.ValueStateKnown,
	}, diags
}

func NewWifiValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) WifiValue {
	object, diags := NewWifiValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewWifiValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t WifiType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewWifiValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewWifiValueUnknown(), nil
	}

	if in.IsNull() {
		return NewWifiValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewWifiValueMust(WifiValue{}.AttributeTypes(ctx), attributes), nil
}

func (t WifiType) ValueType(ctx context.Context) attr.Value {
	return WifiValue{}
}

var _ basetypes.ObjectValuable = WifiValue{}

type WifiValue struct {
	CiscoEnabled                      basetypes.BoolValue   `tfsdk:"cisco_enabled"`
	Disable11k                        basetypes.BoolValue   `tfsdk:"disable_11k"`
	DisableRadiosWhenPowerConstrained basetypes.BoolValue   `tfsdk:"disable_radios_when_power_constrained"`
	EnableArpSpoofCheck               basetypes.BoolValue   `tfsdk:"enable_arp_spoof_check"`
	EnableSharedRadioScanning         basetypes.BoolValue   `tfsdk:"enable_shared_radio_scanning"`
	Enabled                           basetypes.BoolValue   `tfsdk:"enabled"`
	LocateConnected                   basetypes.BoolValue   `tfsdk:"locate_connected"`
	LocateUnconnected                 basetypes.BoolValue   `tfsdk:"locate_unconnected"`
	MeshAllowDfs                      basetypes.BoolValue   `tfsdk:"mesh_allow_dfs"`
	MeshEnableCrm                     basetypes.BoolValue   `tfsdk:"mesh_enable_crm"`
	MeshEnabled                       basetypes.BoolValue   `tfsdk:"mesh_enabled"`
	MeshPsk                           basetypes.StringValue `tfsdk:"mesh_psk"`
	MeshSsid                          basetypes.StringValue `tfsdk:"mesh_ssid"`
	ProxyArp                          basetypes.StringValue `tfsdk:"proxy_arp"`
	state                             attr.ValueState
}

func (v WifiValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 14)

	var val tftypes.Value
	var err error

	attrTypes["cisco_enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["disable_11k"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["disable_radios_when_power_constrained"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["enable_arp_spoof_check"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["enable_shared_radio_scanning"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["locate_connected"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["locate_unconnected"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["mesh_allow_dfs"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["mesh_enable_crm"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["mesh_enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["mesh_psk"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["mesh_ssid"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["proxy_arp"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 14)

		val, err = v.CiscoEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cisco_enabled"] = val

		val, err = v.Disable11k.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["disable_11k"] = val

		val, err = v.DisableRadiosWhenPowerConstrained.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["disable_radios_when_power_constrained"] = val

		val, err = v.EnableArpSpoofCheck.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enable_arp_spoof_check"] = val

		val, err = v.EnableSharedRadioScanning.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enable_shared_radio_scanning"] = val

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.LocateConnected.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["locate_connected"] = val

		val, err = v.LocateUnconnected.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["locate_unconnected"] = val

		val, err = v.MeshAllowDfs.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mesh_allow_dfs"] = val

		val, err = v.MeshEnableCrm.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mesh_enable_crm"] = val

		val, err = v.MeshEnabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mesh_enabled"] = val

		val, err = v.MeshPsk.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mesh_psk"] = val

		val, err = v.MeshSsid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mesh_ssid"] = val

		val, err = v.ProxyArp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["proxy_arp"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v WifiValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v WifiValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v WifiValue) String() string {
	return "WifiValue"
}

func (v WifiValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"cisco_enabled":                         basetypes.BoolType{},
		"disable_11k":                           basetypes.BoolType{},
		"disable_radios_when_power_constrained": basetypes.BoolType{},
		"enable_arp_spoof_check":                basetypes.BoolType{},
		"enable_shared_radio_scanning":          basetypes.BoolType{},
		"enabled":                               basetypes.BoolType{},
		"locate_connected":                      basetypes.BoolType{},
		"locate_unconnected":                    basetypes.BoolType{},
		"mesh_allow_dfs":                        basetypes.BoolType{},
		"mesh_enable_crm":                       basetypes.BoolType{},
		"mesh_enabled":                          basetypes.BoolType{},
		"mesh_psk":                              basetypes.StringType{},
		"mesh_ssid":                             basetypes.StringType{},
		"proxy_arp":                             basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"cisco_enabled":                         v.CiscoEnabled,
			"disable_11k":                           v.Disable11k,
			"disable_radios_when_power_constrained": v.DisableRadiosWhenPowerConstrained,
			"enable_arp_spoof_check":                v.EnableArpSpoofCheck,
			"enable_shared_radio_scanning":          v.EnableSharedRadioScanning,
			"enabled":                               v.Enabled,
			"locate_connected":                      v.LocateConnected,
			"locate_unconnected":                    v.LocateUnconnected,
			"mesh_allow_dfs":                        v.MeshAllowDfs,
			"mesh_enable_crm":                       v.MeshEnableCrm,
			"mesh_enabled":                          v.MeshEnabled,
			"mesh_psk":                              v.MeshPsk,
			"mesh_ssid":                             v.MeshSsid,
			"proxy_arp":                             v.ProxyArp,
		})

	return objVal, diags
}

func (v WifiValue) Equal(o attr.Value) bool {
	other, ok := o.(WifiValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.CiscoEnabled.Equal(other.CiscoEnabled) {
		return false
	}

	if !v.Disable11k.Equal(other.Disable11k) {
		return false
	}

	if !v.DisableRadiosWhenPowerConstrained.Equal(other.DisableRadiosWhenPowerConstrained) {
		return false
	}

	if !v.EnableArpSpoofCheck.Equal(other.EnableArpSpoofCheck) {
		return false
	}

	if !v.EnableSharedRadioScanning.Equal(other.EnableSharedRadioScanning) {
		return false
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.LocateConnected.Equal(other.LocateConnected) {
		return false
	}

	if !v.LocateUnconnected.Equal(other.LocateUnconnected) {
		return false
	}

	if !v.MeshAllowDfs.Equal(other.MeshAllowDfs) {
		return false
	}

	if !v.MeshEnableCrm.Equal(other.MeshEnableCrm) {
		return false
	}

	if !v.MeshEnabled.Equal(other.MeshEnabled) {
		return false
	}

	if !v.MeshPsk.Equal(other.MeshPsk) {
		return false
	}

	if !v.MeshSsid.Equal(other.MeshSsid) {
		return false
	}

	if !v.ProxyArp.Equal(other.ProxyArp) {
		return false
	}

	return true
}

func (v WifiValue) Type(ctx context.Context) attr.Type {
	return WifiType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v WifiValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"cisco_enabled":                         basetypes.BoolType{},
		"disable_11k":                           basetypes.BoolType{},
		"disable_radios_when_power_constrained": basetypes.BoolType{},
		"enable_arp_spoof_check":                basetypes.BoolType{},
		"enable_shared_radio_scanning":          basetypes.BoolType{},
		"enabled":                               basetypes.BoolType{},
		"locate_connected":                      basetypes.BoolType{},
		"locate_unconnected":                    basetypes.BoolType{},
		"mesh_allow_dfs":                        basetypes.BoolType{},
		"mesh_enable_crm":                       basetypes.BoolType{},
		"mesh_enabled":                          basetypes.BoolType{},
		"mesh_psk":                              basetypes.StringType{},
		"mesh_ssid":                             basetypes.StringType{},
		"proxy_arp":                             basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = WiredVnaType{}

type WiredVnaType struct {
	basetypes.ObjectType
}

func (t WiredVnaType) Equal(o attr.Type) bool {
	other, ok := o.(WiredVnaType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t WiredVnaType) String() string {
	return "WiredVnaType"
}

func (t WiredVnaType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return WiredVnaValue{
		Enabled: enabledVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewWiredVnaValueNull() WiredVnaValue {
	return WiredVnaValue{
		state: attr.ValueStateNull,
	}
}

func NewWiredVnaValueUnknown() WiredVnaValue {
	return WiredVnaValue{
		state: attr.ValueStateUnknown,
	}
}

func NewWiredVnaValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (WiredVnaValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing WiredVnaValue Attribute Value",
				"While creating a WiredVnaValue value, a missing attribute value was detected. "+
					"A WiredVnaValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("WiredVnaValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid WiredVnaValue Attribute Type",
				"While creating a WiredVnaValue value, an invalid attribute value was detected. "+
					"A WiredVnaValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("WiredVnaValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("WiredVnaValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra WiredVnaValue Attribute Value",
				"While creating a WiredVnaValue value, an extra attribute value was detected. "+
					"A WiredVnaValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra WiredVnaValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewWiredVnaValueUnknown(), diags
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewWiredVnaValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	if diags.HasError() {
		return NewWiredVnaValueUnknown(), diags
	}

	return WiredVnaValue{
		Enabled: enabledVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewWiredVnaValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) WiredVnaValue {
	object, diags := NewWiredVnaValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewWiredVnaValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t WiredVnaType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewWiredVnaValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewWiredVnaValueUnknown(), nil
	}

	if in.IsNull() {
		return NewWiredVnaValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewWiredVnaValueMust(WiredVnaValue{}.AttributeTypes(ctx), attributes), nil
}

func (t WiredVnaType) ValueType(ctx context.Context) attr.Value {
	return WiredVnaValue{}
}

var _ basetypes.ObjectValuable = WiredVnaValue{}

type WiredVnaValue struct {
	Enabled basetypes.BoolValue `tfsdk:"enabled"`
	state   attr.ValueState
}

func (v WiredVnaValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v WiredVnaValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v WiredVnaValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v WiredVnaValue) String() string {
	return "WiredVnaValue"
}

func (v WiredVnaValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"enabled": basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"enabled": v.Enabled,
		})

	return objVal, diags
}

func (v WiredVnaValue) Equal(o attr.Value) bool {
	other, ok := o.(WiredVnaValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	return true
}

func (v WiredVnaValue) Type(ctx context.Context) attr.Type {
	return WiredVnaType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v WiredVnaValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"enabled": basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = ZoneOccupancyAlertType{}

type ZoneOccupancyAlertType struct {
	basetypes.ObjectType
}

func (t ZoneOccupancyAlertType) Equal(o attr.Type) bool {
	other, ok := o.(ZoneOccupancyAlertType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ZoneOccupancyAlertType) String() string {
	return "ZoneOccupancyAlertType"
}

func (t ZoneOccupancyAlertType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	emailNotifiersAttribute, ok := attributes["email_notifiers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`email_notifiers is missing from object`)

		return nil, diags
	}

	emailNotifiersVal, ok := emailNotifiersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`email_notifiers expected to be basetypes.ListValue, was: %T`, emailNotifiersAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	thresholdAttribute, ok := attributes["threshold"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`threshold is missing from object`)

		return nil, diags
	}

	thresholdVal, ok := thresholdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`threshold expected to be basetypes.Int64Value, was: %T`, thresholdAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ZoneOccupancyAlertValue{
		EmailNotifiers: emailNotifiersVal,
		Enabled:        enabledVal,
		Threshold:      thresholdVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewZoneOccupancyAlertValueNull() ZoneOccupancyAlertValue {
	return ZoneOccupancyAlertValue{
		state: attr.ValueStateNull,
	}
}

func NewZoneOccupancyAlertValueUnknown() ZoneOccupancyAlertValue {
	return ZoneOccupancyAlertValue{
		state: attr.ValueStateUnknown,
	}
}

func NewZoneOccupancyAlertValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ZoneOccupancyAlertValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ZoneOccupancyAlertValue Attribute Value",
				"While creating a ZoneOccupancyAlertValue value, a missing attribute value was detected. "+
					"A ZoneOccupancyAlertValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ZoneOccupancyAlertValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ZoneOccupancyAlertValue Attribute Type",
				"While creating a ZoneOccupancyAlertValue value, an invalid attribute value was detected. "+
					"A ZoneOccupancyAlertValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ZoneOccupancyAlertValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ZoneOccupancyAlertValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ZoneOccupancyAlertValue Attribute Value",
				"While creating a ZoneOccupancyAlertValue value, an extra attribute value was detected. "+
					"A ZoneOccupancyAlertValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ZoneOccupancyAlertValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewZoneOccupancyAlertValueUnknown(), diags
	}

	emailNotifiersAttribute, ok := attributes["email_notifiers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`email_notifiers is missing from object`)

		return NewZoneOccupancyAlertValueUnknown(), diags
	}

	emailNotifiersVal, ok := emailNotifiersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`email_notifiers expected to be basetypes.ListValue, was: %T`, emailNotifiersAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewZoneOccupancyAlertValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	thresholdAttribute, ok := attributes["threshold"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`threshold is missing from object`)

		return NewZoneOccupancyAlertValueUnknown(), diags
	}

	thresholdVal, ok := thresholdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`threshold expected to be basetypes.Int64Value, was: %T`, thresholdAttribute))
	}

	if diags.HasError() {
		return NewZoneOccupancyAlertValueUnknown(), diags
	}

	return ZoneOccupancyAlertValue{
		EmailNotifiers: emailNotifiersVal,
		Enabled:        enabledVal,
		Threshold:      thresholdVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewZoneOccupancyAlertValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ZoneOccupancyAlertValue {
	object, diags := NewZoneOccupancyAlertValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewZoneOccupancyAlertValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ZoneOccupancyAlertType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewZoneOccupancyAlertValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewZoneOccupancyAlertValueUnknown(), nil
	}

	if in.IsNull() {
		return NewZoneOccupancyAlertValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewZoneOccupancyAlertValueMust(ZoneOccupancyAlertValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ZoneOccupancyAlertType) ValueType(ctx context.Context) attr.Value {
	return ZoneOccupancyAlertValue{}
}

var _ basetypes.ObjectValuable = ZoneOccupancyAlertValue{}

type ZoneOccupancyAlertValue struct {
	EmailNotifiers basetypes.ListValue  `tfsdk:"email_notifiers"`
	Enabled        basetypes.BoolValue  `tfsdk:"enabled"`
	Threshold      basetypes.Int64Value `tfsdk:"threshold"`
	state          attr.ValueState
}

func (v ZoneOccupancyAlertValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["email_notifiers"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["threshold"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.EmailNotifiers.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["email_notifiers"] = val

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.Threshold.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["threshold"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ZoneOccupancyAlertValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ZoneOccupancyAlertValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ZoneOccupancyAlertValue) String() string {
	return "ZoneOccupancyAlertValue"
}

func (v ZoneOccupancyAlertValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	emailNotifiersVal, d := types.ListValue(types.StringType, v.EmailNotifiers.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"email_notifiers": basetypes.ListType{
				ElemType: types.StringType,
			},
			"enabled":   basetypes.BoolType{},
			"threshold": basetypes.Int64Type{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"email_notifiers": basetypes.ListType{
			ElemType: types.StringType,
		},
		"enabled":   basetypes.BoolType{},
		"threshold": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"email_notifiers": emailNotifiersVal,
			"enabled":         v.Enabled,
			"threshold":       v.Threshold,
		})

	return objVal, diags
}

func (v ZoneOccupancyAlertValue) Equal(o attr.Value) bool {
	other, ok := o.(ZoneOccupancyAlertValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.EmailNotifiers.Equal(other.EmailNotifiers) {
		return false
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.Threshold.Equal(other.Threshold) {
		return false
	}

	return true
}

func (v ZoneOccupancyAlertValue) Type(ctx context.Context) attr.Type {
	return ZoneOccupancyAlertType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ZoneOccupancyAlertValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"email_notifiers": basetypes.ListType{
			ElemType: types.StringType,
		},
		"enabled":   basetypes.BoolType{},
		"threshold": basetypes.Int64Type{},
	}
}
